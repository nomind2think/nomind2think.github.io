<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aefbab3d007cce32fe4fee06a5952da0c0ed63072a406c5d0e64f21d1662f051a5a4b097c82bd232a8e2f5629b3d69b33881c3542badc452ecd50e9e2162f291f0a7f97a6c4f9377d85d908db0f6db11ee8d7f9563161601ec5e8b6e68fe05ba409019ea05fc78d802b5ed7ec11e2ebfb00cfbc42d7c0d062a3cd722339cc1d353f82e5fccde50fc6ec26421f9bd5aca7e9700d69b61bc9bc6c51ba41e66e092b0090238d3a0eb056fc2e3b42a319b15d25e8bd18638075958c23c2e47ee252632209e5fcf55309c8ec57866c85ea9392a4712d32ee484e6b64639deefe2d711ed7cfb4575fd6eeb43c731fdf63a67e4b5b575cb1e13c57dc9d012e7cb2ecf94639d082a555f22c50eabeb1e87a109a28bcfdb4f753edd7c349dc84f18dc7bd9c5fbc76fee6d76b32e056f0baa6079afcaf10ac5cba66b754d5fc846f3314583bcdb07e765306ff787933f017d589f9accfa5edc1df4a55c14459863ba2f91898124413626e22256ae4312c4a334b747b4a9508b88e7e361456d6a25c530ca9a712daff214952591094768d37827e3491206bd31b038614ad0ab038b57d90c84e88cd3e33c3f38302d8463597b77de388de8197c90f319cf332216685d6eec6732524e573b0f9e178c13a23862e242809bda3f9529e577b0ae647b0c9af68405070f6436793336e559642898d18b56b8ae382d29045a2e67edab73211ca5f3de9e7e374fe113add34c0dede40dbf8277b6d7ec84aee9e5d419c5b6a83d0b3873428b0dd4ae03e7efdef9c8910f83e996091ded913220a14a3aba9ff98d40acda5f92683f81a07c4c078c3ac91b3605b0eb5aa8c8dac2473bd4079046e341edd86f42b79e963092e5d2880f526149416eed7523391a70fd2d741d467f76548f984b95e1eee184238b49d6de5a5602815cd413894b9828e03a36196bb1d887e36c37e2e0c86a5533a8ff8c56f4424359c7e6fff423110d7316a86b400da4e73db06ae954feb919a99b8066bcb1648ab7b4f2afe6fbe06b0a9b1fc230e33cddcf9d8bf60705c44fde8a793cfae780b5f90d38d59c0e9fbdc5af682a85efca8668745c76988ceb6825b7e3dc0fef219a233aeb850c45d7dfed415506e8ee897eeda277b041171fe1db83efdbb08eae46c4d08fa93683761fdc818ba2da234c31c0c95d2fa995918f8f9b1f439708a13afb52dc8c21a31e06d39992d14b0ed540615dff41cd94a471d5e085cefcc12d4cf39ded26ae0dbd2dca1584eaf0d7aae6cbdd0197acaca11ca68d75d09a195973e6fc46d7c9b16af1b7941b6d1aa95a853c67aeb372a1e03d78e5527c80d4c08dfd57d18082f4499c9f4e549220e0222ee38e3684a95b28c0e442bc97a6af485ac9a5b517c9b48675a861b5d333ce4b7044fe483382e9ed5589fd2ebca578a03f5e0a869248494d4fce19caf41b3a9d0570e68d24d667f05dcb876620679c775ca093c91645aa60a13ad12218c6f51e51b96c59ccba38f15bf51adc3ffd55e7710081d03e7876ddf0c80f72736eb6960cab52aaba09ed7f1a53469b86b8d8b434defba867fd369b742b9ed185d836969b171cca871c083fc7e076b0ef7755f7684ac850e832a1b51bed341e41e9f60b00d18193a3a69a9b466894861fdaae96236cb25595ec0cfbe1f99c72354cae48beb40bca6142f00b738281815cca501cf673df1083f0e617e6dd222bdb188be561cf18200cb2a9fcd58b8af4480438ed3782cfa3b35651fcebaeed3aee46124dcad2fc586d44ad426f0aa67ac0932ca3b7ba8197015d1e825b58ab3730ee0ef9041d74ae1f2343d28fb9793f5e7aa48cd8c0c433397a6b5e5a8fab3eafa9c56ffcce6d206d85f696f511bd711b7d20491a58216f8297e211796cf7489a3add80f954b9fa3103572e6f17cbc0b48377ee5313dc9ac330394e0463d0a466c375ef734f58e4b5304f5c844d8481222de4f6ea6cd4ce29c367e44e2c4257ee7af4a7f2b589bdb5e48010a5e21ca4544dd37a329790ecf722b8ab6d823fbd96610f2d561fbe7ebf3ee1dc9911574401f8f8a33a3dd54f4cc8d40f581e4aec76c7cb2bc956d11337e3bf2daaafc5980e7028009d1ca13fe8268f03655b20bfa6892090d7ad6394fff5972a45cdbcfc95764c6c358dc696b43eda606c32e02af0ad95e0762a53ee02b167d416325cdccf143bbc8c8d18e29cbfd9e424b58035041b3812c588ed1bf45467fbd87d0db46c109290c480e387d051aa9843e95c4134f7da00b09b16270fbd5c07de1229e01f0bc9da3d5ddb6457987d22246d7f01917ff34eb7358967f8eb08ab836849a0b279cf55486288bbe796726880d5ddd50f31c32a7acf7d644692614c0bc289077de2b4a46f56e621350400c340b20167cdfedf39b83c90ee0d4ac330084d0d5037f2f35734db185975325b6d6619666dd6871f763e75ce39d703a3b665ecdbfbd1a73db56f901cf60271b9a3f4f2d671f1547101c81f54e14f9f4917a767b83a9fbd39e2fcaa0ac6e0a9f7bce5310289ddce3172be349ab1c8ae24b180628a2c089bf2d7ba7b080751f099e155d1f4f228ed5e17707a6374ee06aef0e2b408a18909e70b66fef6b3ba336cd6fd96301fd7192340156fe7a1c9cd2a887d5af174578aa1bb097edded2c6e6b8dcce894e9d6815c9fbc447d9460ff774881fb8a409e9ffd310cfd1ae476d9d4b3700c6ac9ecfed75a465941ce70f6517cf81ed3c216e4ecbd824897ce40ad443507aa189e17a2a41a1215e1b0d7242faf2961c7a1091091a24e6c3731facedeb58daa5456e2b5322657d9737d137641d0f537f08aa2abded9b0bfdf372919c740f4275715ddbaea89171b7f7363e8917cb70e4106c83b4d9831b8cc881163a962f6cb94adac97bded734a93dd796f1c9f69f238d28deeb053fbaf37a958e57271d6e29d13a168cbcc6331f45dd55c985affe88a8030934366a14057e32e591e3e51e21d2d37a0f6c14701311f8b6f4ccd1a8bc07e4be8e3a5e32b5d287de8b78963f2d11cfdf962a802cec5f86a57c4c2640d1ed0393ff54219cf961b47f43138b581e1843f0242d371558110520e037eec213fe79c45f9a4203a80b6b037b887f33a051bbd66a8a8b4c2a4cdd9ae095c762991ed9f7f569a57f374cd4b98fd267d00d0142be68a55162cc1b4e1e390684915bd9fe4c88c6c29d951a5127aa9360a3966ef745d423896f5bddf170efc435835412582fd63fc27d21389c9d38dbec60d2437dc6a0def651ad63c8c9367b2fd368eb859383ec234dee0375b3150e952546dae814c4dccedc469378375a71a854543cec39bd285449ff215f181a6083dde7cc541e1b210a5679f4a5f06f8ede3fa8569205c82755bbd61d2863d75f7a676a81addd7d18a8ea6aa3dd008c22864040e9a405c06503f26bc7f66f4606064749504dc361822bfeb179d25d621a4b879c8a0ed733738c4fbc3e35371bb5d671b1156763a9e6a7c5cab7b92dd01e2e595879e0d4e02caee1cc6142d311f596a41bcaeb7320dda8fad16d9ebf98b809e0340188968e09a42d1c227e3acf7497490e7f4008468ece64767c7a6e49b7ce3dea019f475a13f357c40e256dd92f3aaeaf00c00e1ecf6f1f1e2477ba8c36c34cb9790a29c4dafb1fa2dc9792388a430573a30c1be022c2819633f3fbbc2ea609651563cef4d081c4f24b6aa56b10f3a87146077989f823053cdbf08be9c5a5fe86df9ba65bdd7065d40f40f74fcf13d720fc812bc584ca9ec196a9cbc423830ad9272b0897fcacbe0c188d90cdfd7e44063a1eb9f0ebd74be9784046235902f40214634c1226ea2c6c6e45505526593ae933bbff0ab5470ed7d7740ebe23cd1c879b38331e22fc601b9fae44228f5cc46e9040580af506c8af1958e3c3a05b5996cc8dd46ca7452f035adf810b460ed40bae3faa2be83278fde655ca2d92b3c3648ff04bf8d83f82c7a19ec72217046034abec82dc40f77f373758916c719d6a2662e5b5f691c064c92fbbf5125d9859e05438846a87b71c101122f876d19c01439450308d47dfd2f8e8f7b78c8d8dab19ece4eb95cc8e9104ce505fe4c7f440c6cf516adf9bce515b6e402918b9a82b402445fc9febe26bfce70d6bc9291cd52f97a666c955db80eae468ef8ba3c25b3d1b785c29f8c98405366361313099fc1e6463f2ea133978375d7089600945c6a2016c7c38c7819b0ae2c367cf705bcd69fe3edc1912f9f02a3cca963eb93ccee6d7720cd72a213a7aac71ac633f6025fcb953dbeac3b2ccbfd45451889bf932aae02b6528c825f634997bd6494ae8f7e20ca5131353977b24ea79918595331713313212739a152e86ba939dd284d58fe62568468f1f9658fc12a66f0adfb94a713e3f2f58015a3110b0b40ac1c7089c512bdd1254c744c32bc6e142ee914ed753ad16c41968f65112515ed062e8dccc5159ccb7d87d620ee937cbe7d0bb01177eca2c9dbec8da30bcaeb27ddf322b43408f3db3f3b7865776634d01eeed94b8091cec1eec4ff2cdbeb660ff83211d3a80cb620981812c6c5cceec93b0c046eee2737690e971073bc922c3cc209349cca9b257b10fec758ffae343d9b595f41301a25999c04d4828738c3df2736495ec2e1b3c1426810714aee0e9e908aceac78d6470f76e37537de91997c05150ac53a411505f3cbe5f3afcb664a18042a6e65e2645bd6d654fcb449cd9ab03a147ccd75c8b0305d1c32eb6e134c15a101bf115ca5ddfd1c1e6c92bb488314a1edecee4f79cf5b61e23e46ccfcdc94028b8c57994ea1c44cfafcebbd35885c0219dff8cdb5932c465970edfc3c2fba43110f582d819da0a7898e2530d794222c0696855e63fd1e190db3ee53b6aace89f700b7fad79434053dc1d0fd7fff142abe03771a7c5e9365fcc4a7a760c91afefa29f956fc6a34189e8efb1e7f61473aa694ad72f735e5e59bb26144899fbc74de5ef34710e69031022700cb54f2b4309dd41a96ef43b069ee832706e1c8c4fed816de91fb6abfa97484d7e0f6e4554e4a8695137a9f742c101f2594060eaec9d405f1e212ad7a9f22af1ba7c3b39ef0879e0a088bebd5b6e470e321cad76cf6d4de6c013f50f8b753c101c6078eaf9d01448686c18f62235f9ed6dcd379e724c9042b41b5255d006c821956f7710660440163b1a2bec7fe7a9019102435187bdb5498fc1fdb683e1a43c3f0f79a14a34b2df118f314b14b6c81b42d3060b71aa8091ada5b514a9e29c1f08011a2478aa1c0c3f77e58613f91be9b6b252c307727c9bd63853fa980a00bb42874f9e8c13b986c4adb68b356ea7fa7ed9c09c7c61e50c13e598e5040cc5d72decd079307e10d47c09931560a29a1c652186d933ecfb7f96bd6d375ca9502b8da014fcc0eec2b9425fe5b5c72f8edcb2c37861dd16dbd8737690b31b153d138045dff0a270c63656e2270bea00723570dcbfceec058e2e760da278c5113d8bd88e99d71ec1568c681afc87c2cfbb631ea8d8f59fb43305f065ae59014c7b9ea55cd0368a51eb775502699d7d6f355f096afedc41f7cdaf0ae5d152aa3d1c944d92dce4ab2e2f5b4c01071c4fbfdcdbcbe17099855373cdc939531db904e5f01db67cf521d7c7bfd13aba167ea3bf14c858480cc8e142fb9c438754073a8486fdad02a8e13a9efaa0d33f01d5b0b4ca93a2250ba93b7602399876d97fdddfbdba203f06ec50f668b3847e6e5e24d49aab1ebde1c60c293539a47e4f1c295365a68f6434af1a5fdcdc9468883aa6ff660242768bdc68d3aba8b468ce676fabcaa12400342db19d48d433d7309d9985ccd8d9c5b652241d4bfa9b6864b0133b1d15b4ab77fe5ad7de59fc279a27de5c138715e6da04fe64e4532ed768f38900d18d160b58a1e6515a9af02babb14072ab38fe84659d9691a26bc2050bf17db5dcd202c82874c5417fccdb00618990041f5164032ff60c68a4e90af2ec8059635b0342e2a4fca9b7ef2995b3c8fbb972f8f7bff5b3ade7cc3f83c10330ee7c3aedb8ef42caadd7f9b3bd082006fca19501057b8669739d79ea38585f2a1841729c04c243f48471d3f326970eb90191cb8b419687188fc515bddfa9c6fc5d270076a15a33533cdcb26181fbac48e616c2848d6773fcfcd1557e4a105ac55db79ea82f1989e828d961cfda4a4302499b4bb817402c4b6b8b10b0a2f0f7e36325bfbb743055d184df0959bfd96046f06671fb126ee48620bd37b320fc854577df590eea41d067108f7c2f1e2780cadd1e5659a5d4670886a40d6f55390818ec1664a61c1843aa5f893e3a0e51a58d0601af753b98f4b9f85adc00d0d2bbe440639bda85763105153d73c1ea3bab19eca3c60eadbb5d2be7a3e557877d1271e93e79358ec71f8924c67852682fd9e6fed7546220eb94b8f063ed87e6a05392b32d4393a78774c814e3f41b884df4ba823f4cbfc65732bcb0723917f79436cec7d93486859c55eb63c82a7f59a0273ab348ffe4a83c6f13bc8c06ce037c1ba055e4c7d59cffa957a8515c609ba4ad2044a6f8bd82f6a9c7b95258513b082ce030a6f0b0db78c33d2849cfb6b49b61222ce71871e09c27bbdc3274848cc2dc4f9a30aef975e7193d37286bd63fe2f0bfc9e4ac99e7cd7eeef23276aaa5458e28a2fe583743a6d2ced3cfe699493369523e59994484ff85e477ed261da55e285b5a49366e3a747d50cd9b1f8f5d7fe77890390db97221b5ae9c07e025630315ce274d38b85ecd9d964d7b4392b3bd659a2a1fdea8485df1b604ed1a534ca230b77a178802a772c0613eb05f3d3b833e64262c28656b115c33edf6d694b1d1d45ad64878f9d869d2ada1223bf8077e4067937dcbf0674f64bf57f0e2926960e5f807398634f31d3b474fe18db5bc156a6ca4533546ba87628d94c2e4b2e1a027f1e204d0d053228aace8524ed5d96a44a47bffa745620cf7c2b3c0a0ab2bbbd4cee9e405b3e70dbd015492efd423d6b46d2f5d157d3e2e0ed6047ae68d5700ceb0353f1fe8c805a1c752a1e72e806326edb7dedea1265b94d22c94dc42b401d77589c96f9a5072ff54b797bb03f0b964d2c949d3f972b66dda4fbbb48390ec2995b7d15d9189685d14e45c25e7691064a1b44456e049a32a3be017840cb6a093f3c9d0edc6960086c83099273ab44020a35fc475d44aee8efc5241c08edfcff6029f7cfd2796f0807f33723b104d9f862403097c1c626d2b437e71516633622e066f48bf99c4beb77e999c4307dc05029f96e812933e251e2eebeeab4d4d4b63ae727f10e3ab59071ac5351f46398ac1e1f276f27bdf82f8e52e54c8f221d3f4441a262a086a6ab8f216229a918e313f3c43f020a3a293616dee1bea66ae7ebdf12c87f72d6236ce5d71ed11174278215a1025fa3904a6c8329cb54f3eb2704b9862d17bf7b8ebf7ead6479fb537c64043f4a56012934c85db8046b9a81ce5285cc5bad5a77e75fe0bda1a16d7e3772e31bb7666925ff66f4f84e78d993ab2f97488ae3b3ead9a0434154cd2696bf5dbe2dba5fbaaacc2c45835cd3719667e8d095e5416f96aa06e3a39da08de9cc7128f4e2a172397001202bc2d6ade11f8be83d6f8d713d34eaadd6356aea7032fde34c20e0b80dc296293ef193c601c4c4cef9cdd9e11c168f1615a016cbcc63444436d94d01e4a92948fd9da04b01150d0779b4bea2d2e870f6387e6646d8c34985a47ef2805439e97fe6313889ccf5f3f6a20ae792cea79d55ac5c3fff79b5988c93af07f1e362bdbf4fcec8da5b3bcaeedcad4b48623ae4e8c3d388b667cd12471eb0c1e0798e51bff6cf7b3b772a2b9e9eff9b2a1b8f11c0b9dc54c22c18e3211eeb0ca7352983dcec205a5ec0d867dc6bb3c6dbb378f04ba6bc4e1c2b8614f5a21a18bfd5efb85be2de2874462e350d5cfedb272b9aac3d81b35595c364b97c70b3e996e759aefd7e9338848d346d035f2e1155577dc4a005e07f00ab3a9105d3337a7d85281661d7524a0cfbe9cfa1cd99276ced5dce9a75b7883c308f82e66615cc589b40864c4507118eb4cf8d63bf21675d0c4de1254bf4ecc5e5930a1847f2eb56c9bfa25c240857ed393c94be5669528d40109f4fdf14a9c37bbe2508aa030c4656566215ae89c93d46a1acc35763103cb171487539d1a55d3e64272f4cb51380dc97a95bcce228776c156beccd10b7bec57cd54da3c7a8471020faa82b56b9df644be557947710e31ac4eee2f26224e0a843b338ae231a7ed7d55ab9a5a331e5ca9f3b4c3a921501e2a59360275109d38029a910949c747edcb16e8dda76911127bf188ee83ef2edb97447dc642bf0329f9a465dfabd8fec97a6714cd8ad271db81198f4a93ae41943326bf6ec5449b7cb328a3d280974c6f01cb9fe3b8d180dd28bf18dfdc2eabc1346157681f461f334f60e19722309cf48d9454a3dabefee124c8872214ce13ec11974377620a31265b5bb718778669353b20256ec91a3988570e43f6f519849c9607f273e59b3845a7ed6e952d374b1a76c7afe84e09d10f5d6592a0e406e08cb2c7473af5b3e9fb0a2e3d199bb92148519975ba17f120a2c9d01cee02a28557e905b02df5dc222f444d538e4363f5a7540916893d2400fb5a37d40b741418cce550017af88e96f9da482ab06f698a24a927d44cc8a39fe4d2bd3548a16ec053dc5074dd942e97c4a479a281aa76941a6ccef727ff7591de20d4fc24a069fd69d7a86e6f7d24ea2cdb572aa139abad0bc8538b2542c0ef437a8072c2cf5ee8bf1035ac8f25bc2f837f294564e75699229bebea7dce4e160b252b500c92bbe6ebd7017fe70c72928eb6236df0835987510cfd140a376cdcd1fc043dd3758d08c7249a186bc61da7e2d3b05b936a1dc4bc7ca76c609305437deadd6f879abea56bf6dcc87c428db0979363b6485904f0f9cc281efbdb3e12c5d1166f0532cec64cc4acb5b0b13fc38b1a46094210f4df444979a87107dfbfa9f2aa31d727be44b10b17532287d5496f34421699be0b1b4e5a314791dacfa695130087bb07859cb07d3729a757e4e11a993ebf83f3e974ef5dc1fb8fedfa994566bf2083a5c7a6898c67623df1330b2c3f548d1aed0e778e2afc8697cba32d099a7f14c9da2aa775b43e8ea303e6142317de1ea7fba4f1a3c6fbc61de7dc707f19dc92eaf902caaeadf6d922494347b1bdd05bff24376831fc2a7f5ae5be68b6808007e129830031886013ef269402b8b813cc822fe21848c9911459607ef50b87e1fba79c36c819e1f941f64dd3e30eb4448a60d189e8f880a56785e50a9b504f7e9e33b572e318ddbdbd6c77aba9dbae9297ee9e994a0342555eb2f1e245e1025c677d6af9b0a7f793c16f31231b2474149581ed0473e35bb272ac7deb0752f5c7b20950b4f4c33194b431513593687bdbe4420ee6ac5aa8fde2cb17dd4a8f89cc09e37be9c7045328d7d2ad452d86abed1fa9c00c1ac778bc37a2a03dbcaf02de0113dec6405ac76d77e02d4143b6cff3ba2783408f40d7599270789d2886b4fe007e7f8f4876a0136d8789546aa08953531b93aca36eaec9f84d637d6ffe14ce0a3ace20d00d16ca8e2d51d27b92b19adf59ed85cf8a5e43696405a388b7254d2d630ef76cd651667d262f85ec2004b3f5cd80ae59ef9a7f3559c323d9dba61bf1c8baef76a20f83a48a35cbf28b13635ef05cf72a6f0667bd71c8dff0ba45c56d010da9dd8a56ec821e4d14ba67d9886ebb446bae7ef7d40694882bdced2bb265eee070220a61d0fe23ac21f75a09a4ba9de46247156ea3c3ae1768556cbe3686ad36f3f8283b4c30a3df79518a504ab83aa2b189d829ef2e9d1ba9d3b6cc5caa1194a34d3bfef3aafea4e64710be5ed2a9019ba083ce0472b6c708e88fbad9b3e4bfa3907c104848a9743f40455b6b0053011ef82967e01bc6f512c19c2d5679a42fdb8baa70d86fb14e46f85215c478f9b91b3ae3a52e4c8473d8214544771ed2d394d9a07f8d544b7b5cd4634d1f671537683d6e4b8d225e8f719fdf03810c962b9c50657d304e9815fd2337f2792a15849db73b49dfc2b8f379c552317708e63b771340871f172df65c82120547054eb3b54912d01c1bb00dd1fbe675cbbc525a932b46cc9ec094a4da4b2d7f5334e9ced94ec5d16f1723067b72096f80883af8e2be841fba7a03881eb61931e26a17e2bc9218ffe623023855e2a4df2344d54c42d763d4861be607293b0b33d04df0c9afe0bd02e8693b64415439dd8186af14dbac4f57ab3810ae29a43df5ab9f16c082aad09676b8a7122fd89d8a4a6e5a8ef4f3deffa9bdccb2b6ff639b81d7897af94eaebb42b4782d10fcb24da50e1d16ca8622cc18c9b41d1479edf6f48120275bac9ac86a01441587dce3409ab8092b4a803e916f9fa6491a08680780db90c9d0d8bb0c7fccda922bf05e29f658f9f5c390b9ea0382fc37a5d5f22199b1851a445f51dd6be367250f12272d8fe3f6d9a984616655a146b4cdceb99070da740b4aea8cc69c5583ffc89199edffc65d8fbb343fda7928605f0b8de767a8a37dc039d2b550563699de6663dd371cc422fddc3f92c4a011d9f199239d23b8ce3467e845b1c0f5e5bb72230dcc02699058a1351e35b3cfe0777cc687737ed2d03469dae9d85e70b0ed8cc7d6f681a85107004595d22d9c11773291d9437160894241d9a277e3197dbeef89f04c0231676140d1d7a15f1790208cdf94976799636b8bd54f07e535d5d7c2d320fa972e2a6f7cfeb7292213493860b2c9227a50727d4f99696f3ec8b7443b11b43ffac1b071e6c0ee3a32db60e8a22e2f37e8384afa55462278afc22b72cd31bde18f7349fda5b3bd0757ca576cbb993f546a6fbc9d8d9559123d99882997c8aeb54db57c140ecd7f2cc554175d741a172935d92c76df21046c05d0279964ff0eda0d6fbd5a1241438bc2440db46266ef40a5a81f9c27d03b56902336759fbe1399adf13362b08074db4c7d7e75c924a69126e8ebf577110e88a704d658befa18e15fbd08f4a2cb5b53b81bf4efc44d3adb5fb41de1cac2f34ddf7b906c6ae86b3d6e8a8a03319243fb231d58358011a3ad6bf3c94269d7c12429ddbb2fd93801720cdbacdceabdd066eb4155b2e8d58f3db68f3ed3eca3ba26a627b4a13c58655f5ef9f27c6f8e3a3a2d5e05821a2082eed0c62b49c2a41f304bda6a2cf4f7be5a2421438e96d19896d07777c6235abc64117512d46cc64fc31bef172afc4a9f72da0ddcd1e0c1b324fdd6b260b3c879e5f1f673e0fd8e317eb13afd5b6cb838888d49c6c16e291c2d54496eed32304c36e92f03e13efadb682af6f6204f48c263cfda274f652ad49f66802630f5f5bec6f809fdf9921f58e4324bd9cf962b91bd7a0161a82429166a4a4ecba1c2bc7ebdfde8edcd6731e510374da5e667cd168fbf45e9af06d46c025243a1c7ed1d93df8b9336f457404903141fc6a797d6caf0db52ee833a83e92cabfc61909edc2fe3d559fc671f2b5081a7232261b7cc61036c3c30f7eb8775ca0a7943baa5ed34e5b528f8468c8431a726cd05fcc41650254bdac7ec2ae3b06ab8a28d1ad51f95823dcc977475be99b7e6859c5cffa4a0d2c20e9fbf46d46dd50e63a122c1921cfef291cb122bfd9447192b7312289353f27a2e5da0b248051aabcd3337c76a7ce1adb89f358ee3e63b8f50135bbb72c6b9b2362c66dc69c2a32878361443123ba0c0d36445684d5bc01c1061288b2c05decda2f01319642a7c6f9d725db29077e50cddcb3f0541cd26107d6f254f3c478a7f3c69a19024ebead50e16d2a7f0d7ca3f54fa2b90bed801d1c5702cbfad7194fc03d3891da00649d0872ce01e0fe3daa1b0c8813a47a1588ed18e0ed918dd6c870e598c1d75bacb90ff539288a6aea936b52223420d54180d97a21a7ca6477ccc2ab312284ee30a18c5e8d9762d91c1e4b596c5a5c2c16cb938096eb34523108e3a865112c3ffa0ff6d9f9554a5ec52453c579618f80c8410422529a435b6c7d82a1ea00f9952756b11e5edcb67af03d573f31ff8597543aecfce1bce41db8f255fdbb222eee19939b51b2c4c8575117fee608c727fbc8e654b602cf3512ec3c11b31a99b373db050a653a8de9337e88e7a16e790c7a2e602de0718acd9c100b14076df031aee238b80217ac87a895e93fe47a024cd63baea9be18a7271e54fe32bd8af89c021fb4c029634b00b22f79aa51840e3bb0e01977e092d7a60f5b9d234a436eda01e139fdffd50fb4e6b06f2d27c76fcc70286fd438dc8a4eb4f26748181c1f586572db6c228eb8460eba140ed09d1c17c1b46f56826ba156bb59642efcc770cd5ea16aa7a795bcbd7b2911e6254956052eedcd3b7d807fe9a6472554210f4dbdf88c2bebf8ec5969de0beebd701044ba51e8060f3712534646da20138165250fec1e868a54f8d808bace02bafc0a62ce7bfcaeb32200e2653de1c1cd51d816d3508274dc9673abb79644dddfe81354c1219c51ef2644cfac57577b09fc6147081530cad0ae31434111e180721d872a051199e5bd6ddc16a7914848a0d20beb736842143fcba7e3a4db3a153e37f265176d602580635df1d394c8d462f5f09d93670ce8fcb36a778b47faeaf53c06d97aa649c0cd6dd99b86eb498b032bfb84b374cb59ae4fdb350851ffd856fc5b51af43f2ab9d8d51a3fa8c8d6621c1a481543c18019870eeb8ba931932e320b546dc2816637b103faec00d23aaf80edebe36cd11283d4cb1c2b9d98270e53df6dc27f4aab06df5625a2b466f0f9f6bbb51bb29091744fe95f6e24281ac484d2e66b20dc4a5933415095bae6f2bbafbb824e2f88fde0b21182d339cd93222bb8c24d2e64c0e46cd5fd22c02e229d9fe0055e58262f82459c952ac984b2bb4b85a3348dc60e0b7d2888a1a86c016f66013907319849549f54dca0e3387dc2cd14188f7aff49147dfd90df3e4e2f37f669862571741fef24ed9c714c0f9f82ae5c19d91b78da390f53dc2e52102ce6afa55dc0a95b0f0d7951d89662c3e5f489bae24fc489a87f8252d9a0cf5a90d13162e76637f13199d2a8a63f2fe56957308984f21ebdf7782f9049e7abe4892d409e4266f956cd27dd8cf78ec6478eb179cc1837be03a10e7564cc0d9745af8b2c602086cad40a614fe738ab12db1a94ebeb9f6b212a28155db267a8073209994c6cdde3a434d1dd3b18051a9110698c9def185896e77f0ed0cbd2a73edd494006a919ba6b3b29be026b5862b0680d524d6133a458a7d8d40e2254e044d0c927ad045302155f991b62fd5fdac77dc4dca41d599f1c1988fc9007d30b8fe26a9199e27f6faa0c30e25a130bda56e937faccb6ac2783ca809fb07fcb0d193590fcb677235083aaa07a8492806c5be6ff586e81c2c37702c3cf1349be10e7a4caf4ff080436706406ac921fd206db4a538f6fe6f068330ec1b74d906aa1a65a53a3689f6dcb703e284b4130fd1516dfe898c6a10a8e939af9066cd5813934f8ec506c7b80f017b3d110f3fcdfa81a6569fec15b0c05041d1f8caff81aa9b2c2c6c878d4f52d739be1f0ba1ec3b7656c1ba5381c6bf3857075ea54327c253f7938ab2fcdcd95aace3c61c8493b3a7b9afb43550d1791008436c4747a38b9c311286fd1dc4b0976df35a623c4d549a2847257c8608de1dfd7cbbda0af70e194604f3481cbd851acae19bbf12af359ea9bc91074840eb08fc49e88544243b8c5a59ff087b1e48c5fcb223190839e1e88da0cae0ff1b039261fee9abaf19d4411daa2f38c572f035a1d7aea4d3839a08e4e4e82511cb27b1b6ca39061f421e1f17d30c9b531b94ca525a5625dcf1c705cd109bbe1de4e07681b4855651cbe89b951cf110adcd3de1696127033afd2ea889ee45c04e0bf52a0748922b88dd41ccf4fbbc81d40de5fc2fd755b3a4033d10c80b154699b32744bec057eaaaf410bbb1d4319f088d0e24ec55b65117876421aaa56b4de2ef391f4aca965866663bdc562de6a2033c9b697bdcf7fe2558a2ab4b67dc6d6042770951963403c9a34b82cf7fcb3b8950d796f99272cd2e3d050fa22fb5262cb3bc5374c793c5bbcaedceeed7b23378cd1e475b6dfa7865bbedeaa7442a7ad52ef237d262b25c379651b9ba4bb268d2b850cd464fc0fb8b0b919f887451d85006b5183fd417650d1c9e558a14dc7f4cbbf259572f7387869c3c86456e1a541d4eb4569ed62cdff18148c2f5d05f541d60a86198c7f104afceef939c509ff9ca9b2b9a83667a7292e3865f2b53c8a627ffa83c25a8ff0a4894b43361d37400b6acb60fbb7db7f2afec5b10129472136b0dbed1f87b552c2f706e0c0432971d8bd6f3e1e11b8fc2c3550ff1e9659e910b5a95ad959c25be8f1ca0e1bfcf90993c34e7b0d0464f5198c142c393a3dfa4386c2b84465d424ac5624ceab7cbbf1919e112452c5e1fbf2bd1578ef8cd82e699cf8728432d0758520b788698b88e274b39c15d50ce3d9918ca7ff90bef47a6e7a03e65461b30074b41c6cb6d56dc558f9f118d5ff10b07fc14f08d4287b847c6037eefc9c9dce53d39ba3e3e42665803321ed667f539e39454e8dda1a06b584380e9f32f05b4e6e599733e447313f2fc8bfeafabfe82c5214ea01ef640217101ab4b4c6e64fcc1b6c2186cdeb90fa8292a0b52626706e73da1045f931cb9c3ea2716949d80133faeed99a6a260ec5207f68ee9168875185bd78e3d5be1a358d62d299b6630868e6e24e41ed588d51e2ebff0ab8de1140448e2d3f44bfcf20486ee88346826dfc74bc808a62c6fc76d51b23988215f8510921aafeffdd62912bd437a1ae46b322c25015519c69b6348c27ab15b9f3099495c126a2b5c712268dbf05f00a020a3a68fcd04a279257b755b53bcc15d75e956f32cd7a88d95a7e0cb722f3a3966a13c7ed247c5a07fad6d0c14d8615bb25e2294c164ca72d0deb77dacdca7535c18451553c99c6c817670f7c6d9fe4c45128c3d6331eabd53c45f06b121f4fdc984613170c4cb01cb3e3d0009cf20bcdeb5b734ad08422c361680cf4d747ad2fe6c3b983b9e5b65e2e57bec393ee4f796b7072eaaa576afd3ce96cd848f84d83b25334afde18bedbdb6354f4a9b13b7c1915bb43e4d54af59ea342ddadf5c59aca50bb8278117bcb72e32e42180d841124cf5d9ada351b6314db66ec71cac4165f6e8566097b121fafea4aab3a834fe68ab9591265b90e34c0225cc1361c413aff6816feda9edf5ac5c3ac498d106e3bf1b2bbac8185e300126e803bbc0cc3737917007be9f42c588ecff4daf91fc34ba77334ac1aadd587bc3a3f175b8166fa2bea1a0a66169d83e6d173f5ec35d863caa9c1c445d494f456f3cd50b6c291531b627f94ee25d7ee21c44deaaab9bddaa5faec27c3dd9c67c7ca7ea296c97e7d165a6f019a88fa7a2098c7a31dabedc8482e0774980f31d8d82c87cb2a7d30017f93b7170f0173bbf60dd7d978863840ef0d01126b8a5e6ec30fa6c5f823dba648eecc8bcb91f714585411637de2703e27a31b2289357d922c3eb05c363667970b4a1888971a20fc33c08bc4072b364c0cf803a293f5fb35dab6b1c2428ba237688783dc63947628947a4342f96fd85845de9f355642d987ecc34c998057757d82caadae4666024883967ab02007dc55f797a67211c190af88421a43be20bb9a5f3aab0bb124cffa88b62958fd6e811f980649096c984260031349dcc6c5badcf3976a85ba9f42ec9d675439846babcb1d8f048eab50217f0baa06f8252ba48ef980f130d4c85195e64ed28dd42ce93a9d6b1db81bd6784aa647922a784bdb3b3d53d745b0346142141d0a94182317482faf6af36aa98742862389c24d68f000baaf9fb48b2882495bb37fa1dc91e9f97d2b53d9998590cd5b357a6ac5720eb2b855d79eeee49daa7653c99b3e8c61f376b2bcb49cb41e4ab3d945654095a5ee4efaec7d291d7af2178c91c650315804cb6d2c3c600a348b05d1dc3c43ef59434d3608496daffede495373221ff80ef58f9fc8393847bc0bd8f4ea7a08dcba0a68c836ae73c0e56a128f7f7eb170594b17715c35af94a45e68699fa8b0eb160ff70cdcd10510505c3ea6bebef6685d8da137a6507358323f1ee1d327c61f723b2c34c8cfb0af1d90838a75f4d071dab474fd94081e8631c5a67afc4bc7183e4623c588d1176626a397c826bbaaf86caa81f6c67a55774d9952ac54d0350162ca2c221d390383ec284044527b5e64f2e8d1dd0c6dfd13c2d26c26bf624a4b5d0597ad462361c0726ae87b8b033e6fd3d1fac98a2e068ae7b7c0c686707caa440a223b8ef099405660db9e530d240bc39b6b00e68486d9bda930f4ed358db4e9fc755718e761729751ba515755cfa3235cf89df1b5f32a4d06585f66a4a3b66c14b1ae8d1a6cf69bbd8cfa9bc5edad552bbec8c497ebf5404c8e869cbb8a4329c5298b35873e225435ab4ba5845d6a9e94e082a425e01c4eb8cb4b582bba035da2c0bc31e1d9ccc192a345155932b62be4f52acae46538b6f47eeff81606d9bfd0103c4cec69d4e4398bf007e17be022534fe7991ba30ef284627bf6a9e6bf6addb4a5b6b1a44027c83d6be20314102fbe59d7290586236dfb30a68c23e81100daa2060151851a72096d0c379991227a554eef0cf9b01b02d6c4bbf6b4630373a98ab8938693d23c77d16a37549102084fa97cc4fc39a5486a75fa63290ede9a08a2981416bd5b48c6c6fe49d0b11f096dd3e50b403333ca6f840de92f24cf9c7a5ee4ccfd32bf4e55f3bc8d3b80f9005a1c03341142af17daaf66b42725443aeb7e7c583bc8cfd5a5652430381b2f43dc2925dc6b31755b5edf7f5a014ee06a323c9af07b7bb7eb1d8df16ad13604c4282abf6812ad46197df0e3262b1da447e01502476b395108e8b7640442e01b543121ff0f8222949f80024a7f12d704643df329b175debf1b2b9c80e4a0c6d05186d6048ddf1630498f78edd9bc5b7c4992a0bbe8a3125e424c3d9d38ae4d5f524907b3de8e9613bfce41cb02146ceca5e0e81099e1c4e7b0abec55c47cc5f1d00e464168cc3ccca85bd91888e84956c4e34058d7267327a487a57fbbad100c00c8b9ab5b99afc19b9f2c7e45e4d62c7bf1cec2eeae369e5ceaacf823c4edd8065b48c5b7e006fb3c60698bc52f9d82d0949fa05880c308cc3d5262af81a3d2ed4d32b4e9167b56af4f6372da9412968997d7e3b31bab251ed9477762dc54fa17c8a2b94bfb873fe74cdf1d26d392c119e9aa257c7bf644407c79bee6415ef5b3a0d180fe293da67910563a0fcefebfca49979cdd521fbefc535cb45ebd1927194ba3fc6da3b8b6470c817ff9b9522a007a6d6f741161e6f8f77a34f11cc6f2bd39103a8b9358cbe7c0f86376f9e7cbec919fc31da6930f8bbc17414e127288e54a288952d18434e5029d996bd24b5323082ed1d6e6564239cb42492f869099b7324f28bb2fdee0fc7704406ae0076c1062c2e70fb93979e3d6d65bfd8b9d4c8483e97e81d398c94259a6bd78ee2f917e3275b06c433d30e5da179a4e9656a970240de76520e109bf01c0ac46c8a1986e1590fed1a77b16eb20fcc63ff8d68d1c8c8e25345fbe18744e50e59","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
