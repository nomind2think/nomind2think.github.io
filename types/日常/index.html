<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bce6b9d2fd6fcc4668369ee5c95630f4489ea0ca391187d85669cea82af2ad19fb21ed2a09e4ca9499fd82e6a836f74944fba6199555a51fb74bf824ec6f9aba7a82c0bd66543c5e2365b07e186da3946d019bbdc858834b397e71591464d0a33f7a7509a1d2cc730c6ecac5a18602625923ca5f75827f1c19dc1ce0eeae369c4fbb3c804eaa41683e125750f48f5e35141a9448389f53118a84577dad4c9d0accf3f073688c66207fb687b211d4867d9d906f012392c91f83aa63f64dcb80fecd15013bde2b47e152cc0e4c5e4f0747e90b608223e70f9efabe0356a36505ec4e9471733ccd16e952dc23d7be2af1ba4b935c015b42c6424b2b511c15c6caf1e1128c32aaa4dac3636df4e4ba183a1d55e2a40efc0e54a665a9c14ef559dcf2b1b15de722b57313800cbeed52acbf9f54825635fff630d4c185d3f69456cc610a1a31f5df500dcdbbe9a456864ddc84c59390ce7642b1b994d1eee061802ed8af1511f15927fb5be0496610a58dbfdbcc7d1f7606ba64a930dcfd9a6c12e2c0faab2b719c48942d26dfe32ef73fe234f01e7320cc05b646a498d8dedd906e384332a93d9df76544b65f996bf1559e525b0fb28ec3a77c7bf0b4c0af017cf03f8509cb5be45711bf58ba75f293fbdb00ca2969e1b6b4354caa1e6848d54211f80c8d976c16c203e584136785b9cdabb719e5f4474d326e593c87ef763ad452b784197ba892efb2fc75c2282e7bde315cae5a73729dd682b689eb04591e7ab24681083092ef843a493bcc7d2b192cacf8809f73c3af97573491de14fc2d96125df5761db482082e39763e4473af6b61bc71134295e725e28e4bd8774a449ed0ae9eccd37813188ef2074fff73bed134e27b3c9c99b0271eaed7ada6802a97804a021fcb0316f0d62cf4d79bb0c4b3beaf6bb8d2390858f9fed1b826fd2716f98abbce8b63494c4a3be2733824cb35d4adebb847ed393c9bce137c12c6b1dc2ded856fa19df89adb9de95e67d2914838c61b96194acb373802950409c51b724f4a7b4f859d948f8f3d5b8a022c9df2ded25a5e62380f82de3585f2fccd847ecb49417793f4f2a314b33a290eaeca727a76e6bd1e9a8052ed9c45e76092f4d5ff0847b6008711810d3ce9180119f55f70fbafb5bde8623107aba44d8c240aef75f98fc3d1cd538b0243c0ab423fb55a296040c7633eb2456f023093bbfb523e272212b4eed04477a308d5434d1e4b012d5e93cb41ed5ee1041dba0efbfecda2bc3ca17d8c6e988dc6542e4bea20e56076eea013c78e24c213771ba16deb4050001aafc9d9e213766b3be56d2fe6db28258d9559834f450b79da8794080c3122e0709d8db7ce3cddd890f8db3d32b0540158b3aa33fe1868524cd15abb32c0596d77527455eb31e3fbe02ebbf2e54888e0c0282370d15d6cabd047fabbb084eccb94248ed08858025c2cb54011fa744c5c1dc2f6462b4c5686f2227983a59801c99859fbf1e5b3af1a2b45aab7d524e1f3dd477f9bfa04ad114e1a5d4be5577ba6fa4a6eeb200ba0fa911c2987c77e42a63566ca5c636f0a79673154785812ab0c6958c923c8324e850d2b4e06b171ac2d7ce745158aef09b74fc0ed99e8f0d4a9b3e3b8a49d07690d46ca0046e0327b57a3aaacf10adcb8ed67663b800c67efcbd4a5047ccf1a6c56c459c26313898d5b0ce0e2c20d1c3f05c40895843ca4d9b8f4741661f55f02d643ccd5efa7f02234ceb860d5a9deeaa563043637b3adaa446632157781d00d2af2598f96c36e80b06a52bdb9bd563a9bee1e633991a8caa467a16fe4c6b6e23bd4cb83a587ac9b8d62a5b004687de000a34bc3fee978c8aafeda88ee37f2bc9080b757e09a005d08d7ae79a4ab88e4609de731e505b47a8822b0c9f0cf9798fba1392b6a1e83cead6ef45538ca4bfdea9c9dd933b1e4f72c59fcc1fc8155ff694b2115cdefce9d917c2ccf22f1b7b38f955197ae73270b5fd5c3538c6a5fe0b62c0264907c7a2c31895f13c041da573a3484ece3698ac046bc4c8e7bdac9e93473d4570d0e787cc85e0a1df9bec213f82af33d4bd23fc5bc89550b3c91832fc6ed7dcac100b373c8193866dee1699b59a3beb0730d4902fa90102215043a970dac9bc8fa0829f298d932204feed8e414cd7013e2b41b79d8e8ac219bbe011617fdd00c8fc054040fdbf0366a69d5f7cdc58378bb138fdf73b6bfaee44a01e9270d2343e605b2ec398a06095fdf0c464077c1c2329a3d00d40b00998445f3dbd5c9669c0cf049111982b2d23265e071dbed989e5b5efd25e89f99b813b1b1922538e37bbe9866106f70976912a7acb52ec13d6d9ffef3fd7ec706642a71b1e8c73d6a50e0d19ed3abaaceee1c5c2a562bfe8cb0e86504f3d39922b83214ceec139729b65df5086dc5bf873448086df9795ff58b41b0e0f2058ab745b8e3272fac5358a07605ce72af503427f60484b4d14c2ff845d44d7ad8844448c56e606bbf2276c1e3688208f0f5785467e2fcb4985ad20b42d9155c0b8c7e5c7b527780321a4d6f499824d0ed2d84ea5180cb6e77edd32eea1c4d316c6a7e8ffdb6b997548318a67df8b75826fd996aa4dd072f4744a6f7b0a3616412c3b016a1f331819e46aefcaa9fe89153c336d03534d2bc7752fcd46b083fef3c2ec32eb5e6301a471dc3d5173de757575f254af2bcc97a87deea671000b78c2896f55e9045ea0189aaf88f8bffe58e3b29c8a33dfb5bd4c78bd393d7d79cb9e07d689c4af4ef47e2484f0e6b930a6c7aee6a8830376823a5f53bd57f04632f5dd759ece3c87b4575c816880c15a4d7cefce41e33791f5a782dc4ee24b64f35f0fbfe3f9f8f0c73d1ac990a4226f88f679b2c07e3508de10da61713536a0a7aaf4c0f1cc2506b92bf3bd0235bb739db40a19c570f561b7314beb96c98a3010580e8d8ffde1baab0e59ba98e530cb12da231459ed7a6cf83c8d7c01f2557d43508a3c08dbb8b2662670e28bb145652d4bfead234520df682ffe309521c867983cd13e0134f8f8b3817ec103bd7ce0c43e4e6b425d9bc691dab0c1b7e97b4e0e32e1285f18d4c410b6d17d36b89c3b2c2a8113abd45c68400e64c3b06e8300d2f19aea8651f36303f43eb4c356cdf008ea05b6de46c3d4087bd4ccc3dd4d3c940c31ea3962690b54334de005c689409afa07293b9c132b955add82b5a9ca19578ce022915ec1b1831808f71833677140b40682dd5fce4d1cce695185a6becb128ef7cdc2893f1c104164ca2aa370a6f2d3aeb6a7ada4c1c508ec9ff220beb95d5e1a6e093cbe5565a826aff36111c6b9a910b80d9f590080ff8f17f65b2b8623a9522e9895b0b43ca2f55a04d6c8bd74d461344c2d555b2dd51762efd6144254366edaa5b3c2e3504f0c8891a152c1d050ec0f2625f135be5d68a63f3dc577c60c6bea84e8786a0105f836d7b626f9b3163c2b5318d170a83458aeeb1420e9e28c7755d750998bde85dda1864c199850117c360db725b395ac6351e9e239de5f2bcd0cb0a78d1beab58beb1338c3dcfeaf88b3619c3a4396f657cd3e0f1bdbd7c262ce06a38775e19f53180eff85eed8f1e02fb57b487f9bf37ea18a9fda30651db8842eaa05d8ffdf436e21ba18746ce2c8b3b607d194022d950e2cef53159027f847d3fbbce52e31ddaa11c36b0cc3bf5f47658ef8170c4a23f82691faefce565c8b634582d02899e6c2e2448516feef96b9bc0011bc86c205cea54b4783f6673826a3b97e403ce4fa6e6a7bd34d69e4766cd18afef32c2b6faaa1de75d56365d40ddedf5e5603a502d983ba0f2c9d2daacbd0af4a74605dc4cdd54e3db5420dea6c8a4969fc3144756974aa523a5f0a06e96db7ce80aa10dbd9cf58a7337ac9d98bf1a4e2e78d5d0d941ca2b9e299b03740638c7ed5f97658ac2c2c4b5ab5bf36f5372fb7bc5caccfc1d09e2983d2ca7070170ad9744fc66011d5e0c8434dba8ca4a8723a5a9e633de9d435d8f595a2e7a962b69494378f042f196aefd29b239c3c5dbc5e388df56c80a2f3429a054228ec91836e0e0015032d478e00158b28bfc29fba9ec7134d8aec27f5a72f011d57256bb3fea36f15ac4e464756ff8654061b9aea32ab1fcea1033e995f3d2c93291f46441f2675f05affea3114aa007e6010625eefab41dda66766c77ce8de3b729d15099766552c86ff702893610cf3cd4f50bead8fc83f31b6ab0250a961ab820b9a1d2623019c042102033377f2d036c0ef161e1608aeb65034418554248c2f9acf46648dbb086c5d7abd7177f96296d112825f7aa2e03dcb58a3ae8e3743f7167fbcc6ce13c927af2b435313730097206d6e580c5c31d1e521cd86d6a81ae9b05aed7575f854d6f987fcba8f0b9fe5004527c9a1544a2139477d302f45d32799e4c66bcdccbedef917866bda4ce6cded08e1b255a05e42d8f29b6227497c5906ed06b79d34099eb31d7d4e1903febe987793214dd91b72db7000048656fc48d8ddfe49e870f01a858800abebb108eaecf3dd5d118fdbe127e2da6e2ea8f67568dbd815a1f0f0038c5babe34a8f680628ff7f3fad8c7f1d16182b0c9846516153ec180a515f1be4e2a8d451022c8b68bcded363a0aa5b4162b4483222a0f25f977de5b1aadf3b5a6429f16058f93a284cdc98fc1120dc70dcbabec6b67792ad17587a04df6f2c04d70da2c04d2820917aa1fab0e6e878a54be2176f23095a115efcc29b82eb6ec63b5990e6ef6f57d265fd50e33b2ba2bda9d4f75e77b706182937301d02623eaf89a71ab69ba10d09216aa032479c7853356df2d751b6f0fbd96deccab2e86c33f0892e538fd86cb9afa39adef37b3a46e690c40e59cf9034599a312550dfcb7fe0fc2268c0d29286eb178b870b0d2adc116b6e0f7d679be21d9c0d11ded953c89e2c16ab97eb19e36678db21b1ddad4df947d89167972c74fb4572f503f396a64d27418f00f1d7df70b3891ce0d2e9fdd4557dc1936c29d8ccfb8f5ccdd1667af1acc07fe65e16a27c19e751442f84df9aaced0585b16f017ba07a6064b95cdf1c3ae416d0aea98681752586d234d621bc98394d397f67fdbbeaeeb0f2dc39be0e56db9f83fdd939f4f81a224139ec1dd583d7be8c45896952cb5e3db93299f521bf5876137ed9748491826fb41e142b1ffe4227f03de5747ce784562ce2ef8fdc0c0380af429af545e87b51cd558234e86074927304ea50041304ec5c381f1fae95928ab4a1b117beb4ba96297326fe37f22814d3c4a4c28b84ae0bc72b8bbf558a68fe7b5c6e8f02f451ab83da3b89f725079a03314347c5f7ebdf514faa1004e6b21d8f20557f91564fdde7f35aa13218558439ae9d15ec3f3a3d425cf4c0f11fd431cdf183fa233a957e5b4358cf4ac0eca5a39f5f098005f5382aaa93f7e9ad97e186a0c2642752994dd6563e52bf1e2332d8cd3495d11fd9336a62f378fc2f04086c63cf4d6963d76e468ee294d9a635c0599ac10afc14a6a38f15c99e56de9f3ed1a7f8d7eace4cdc9c2bf0cd6e05fb19f390e9b7fa4165cea263406a90d657bd62d877cff5c9109206e0ba0fdc466eb5ee19365903263f186d1b503566b665e95120da0ba15f147d9d13c0e2400ac40a19e31c34752d810c0aa5a5dbfe1aeeada485bd812c5c184b0571d8598218115743bc7252e90d769e4da4a344c5b1df0c92b16c48fb91bb0ce9e50f375bc57afd756359cb927f1799a625598da80853dfb20a000484d65ebc7e454adaf29a9e09b987c2f7fdad561ca1764831c7dfdf3c8c3015f7398643ac3dc25687cc4f068b248690a337dc2ad4322a4963ad7003ab9f9921941f9cb79d12c8e7e4406d2aff4c2d341b01a3fe2682d5429e947103f534c104b08b521d6ceaec5125def72092499f1650926978eefb76b486504c87655df883aee1a9ca332a523d8289573ce07c80d5ac7b3d94e61ca4bf42b31e27a10688eb19d16df90c362c9557a08a6e1c88278769b7171657c4691e5cc26d83d8b0665b586da70248c181c57e252470eca95f994fc60abacb934a2dc6e1722d6be16d52ff7b6b98448950c1bf2d0c3795793ed52a3c04be1eb76380af0265321053865b83e3bd4a94b5bfd6cf208fb99432ae0baff81ae342faa03d8bff45d3c0cc48d9e1368aa3995aa0d6b2a6fc03f50cce2ff1032248cb489cf508242e93b74126a9e102f32f97d923c60e260b524ac29ce1769066dea0cc3e6cb1809a184a2f6496c9ec3d21ecf19e2bb80d052c5f2e7d0775fabab1ce0da62bacf2f21222e64bc99f7e4928d1fa5afaa5fd1fec8f8442fdbb6ea1f37ffa02a3eca53d0e887f0dc6cbbc4bafe2cca6a1b90c34c24dfff62c1f8ad549ae7f91760155243fc4c29e2e35d5ae3c95b7087c934d4b225e745dc85bddc58dc078d4c72aa9eba49044c09347924201c4ed0ae3cb126f9b5d5e038cba2921b68b36c36e13da32d51b7b30e049874c2c27cc993560771690f3daa92e292b57326aa69cbbc51a8c1d1fc70235e3f22bb72217a8ecbb9bb4b244a594616c024cc5023340b30853188cc86a1976eb9e96ae71a656ac91bb728a3f5d7e8b8e30418f4ab6a2f3eef1cb11944e4a3ac3db0d738f5ed9480a250a9268d36af9367c92c588360ef420dd0278a1625e6a168b1db3c95e022b081beb147837228ac935a784864d641dd4144429723bcaa3f5a22d16b667f48d463a0ef21e67a7e18a2aaeb5b11403c7bcd5525dc27e38a9d870fb5277fc4dac89bfb711f9ee409d13edfa06feea4f9477b2bdea38296c7ff8998ed21848c440bc1dbe4cc39e987818ef0ff7c9c9745717521273ba582b7e690920a8a0f3f6524af8b1b1c8030719eb522dc188321a63bbf5c31f70a0c09eb9790e4c33ea09150d18df8fbbbc9072ea3dc600d84d71e0007d4640e69686889f10ebf0c10634fed83ed21ee2a80ad7996953c865f6eb9c222cecd58767d7c05e3d615f1aa12e80e9cb291d90ef49f08a3d4123e56d3a0315289ebd920fd236571b97c2210e830e24e14d4d05bd1e821a2c22f9bc9627532b74cbb1cd18a1a65e15df75cc412f53fd8b7fa17b3f05733a75a9219aeacc6edb72646f2c1e98868e219fd0e0a7c16e1fc2a3e623470bbd3cf2e29ca5b1f257b877e1144f45e9cd13ccecee0d5c4feeed24ca94b82cfc0c0784bef555f6b70892b7dff3a2fe75fcd3986e301bbc2866e8c71cb040e5c1c747e83808fc77407561a95e8734f8f89199846c636f6cd7cbef01ed497e850c4c1b3f6053ede421693de8fabaea1bc3187c9ad38abe03e27ea7fc52d06af525a97aea19398cc2bc3321902809b72b927724aa868d5ad6a506437729f70ffd9ea6ac3781518165564eaa36c0f5a770d360c20fa30fb23f608687a5a6d1a7e4f1ec30aff153bad4847b7041b710b417ab6a75fa0d3f37ce1df736733c972ad868983aff159d97ab0493f5187efe3aa29a9cf65f838042be21089c48ae1d540c8ee8feb20b8c89865718a2a75406b3deb5c3bf4ad1183b966f90a92ddf2b230136af13085cb63e76a8a2e1e76d5e2cc6de54d77dca29744c39bda4091d8a28fa6475c45b2e0672697a34e9af3174077c0475a53acecb1ca16cee8159b8e8cf3b8865348c9dc3172a047e8a3e09d7c103eadb25656ba2f185adce2320532699f9f972aea3961a77b7872225f4af6d00a492735a04e0f20369c3c9b321bb936cbd2e6b5054f6b581af516c39f0458b00459e461ed05967580ad5b96a526ff4d5b12a4ab28471c7158fda2cbf84fb1e8fc1012d55a8fae8117e94fce52aa836fbdf31df9050603dd7f51270c2ec46ca03326feb505afb2c65a4ccc1fff737abf5d4e56d3b096bb3b1f66c66593875c4e8b65997d061fed2d77a39143675a0e15e7cdc2055070e7887ff03f3afc91010d1dcccaa012130b9435736ab16beea322fe8ef1e1f4fd131221af4d7457114711b768930362c24f160ad49e6a9a1a25cf76952405015e3a086574634cafc1476c4eb5ec46be60c12555b655b0663cd6b0df9a0c962a1c3f81b9bd605b06bab42bbdf754f735e3fe105567d58aaa244ebf8b3e68c19aeda10b1d9aee42b98db6d0bda1e4820dbd7e03f67db8b49029ff966b4b129c16632c611df8484d520f5e36ead2a1ec7a1d15a297f7ab7ad38e1517a89d576ba9c1dfab9234cd89338b663c38608f21c56a44cb0596500a67d34502be336d7dde22cdf4cd4a63403c93e6cb8ccd8de8545ab96fc644c69fe8318368515a150d43366c42836e5442e4ea6888e403a5f75ad46fdfbcef5671d1b3c8c83dce98e24b8898f9e128cb643c3b4294dcbbb3314ae0313cce35aa53bec0755bc8797fa939b03c2729d47fa48f9800634960adb193ccd00cbe5b459b030f74fde43df58e8188a5492f0cbbf86cb7322fa260b2f549566f27c496b4443896df01418e156a0340fc05f89fc42bf845f0fb77a999033f3b9f250820533a2fe5310983b07f9f4a42367ec0724ef16071b81328e422100d7e218cb1e906456cd05b2b85837178fe994fec29d13c0f0f9ab61c67df65dae233a217787f4ed896b2ce7b61e16ef83750615e3ffac5e1c51d494940df99a06b1fa685cd74bce6b5e38d1ebfdfb93610a85301c04947bafc0c26745e971fc9bfde14cfadb5f14b4fb84c9e78b82c8889feca16b21ec97caf03cdec5a925681ff30180dd55fcecba74133a2fd413680290be293ae546e5ae4fc2e2d59d73426192ba1c35d56b957b3ed150400bb7cca2a3c9e68125edbf0e117cbc5018fcb5a5adb03f59f8ba2fb29966290f96f8588393820e3c1d24450dd0805dc1641d2946c106ad52dc69fac551131d0ae68c9ff85bf74c8a28c99b55eae13fc6a231bf246f282e597386a283f6d2c3c0ade73b1d4b56df1a2283775fdb990c701dce689c71984d671fd7a4e4afb3d863a659541eee1daaf7e2aca64e77b98ab40cea329c25bfcd4b3e86af5eb9420b93b2a05e5ab198f80f38c655065b936d76369e82c9d845012551a4aa2fa6f66cd45e8246f548a0dcc69f389104f01710df03076d4456bb139ff123d64893f943d082fc3c77c22a73387b4a7271910296ef6a85ef9d11fd9a30bd71aee71b3372c88cf5db5f9d9d3c607d7b1a2eeafd714dd8fc6d4d063a8ed0bad039d01f998ab7473de809cd48cd3ef53247f2ed1e8ba27167fd766afadf4ff44967b34cdd5f578a0d362002fa5a503ccd1713b942aad8bfee79295173cb85bef86ffcf6623acc2a981045adac94fdbdfe6ebd53a1ac97535e126191ff8b16e1069eccc92c2993b0b623834e2314835a56ceba3fe59e49f6545b8ffa991f310067746120a008442f0c4854e73e1aa89eaff5aaac3f06923f7d54377af93abdda28dbd982c09198b44078415ed5f836f0713a76e09fcf0b1df15bcfdfafa9e29ea30fe6bc79f1e53695b134ed0662149540ee8cb9e351090fc7823ac7879f38fe6fec04d8e2a7956942817897b50ec58d0048cf7f51bc458f59698e03a070142c6a529276e6f162b30013592d747ce84880f8f3eabc37b339dbf27c068c3d381c282c7e39100304fbf440fda0aa53d33f62f31492138823a4d18eac69753719bb8623577e626c4f9856dcc5745491156b1b016dbd3d0e4d4081894bafe1d4034df0cd1bc06905d9d66bb84f02463af1dededc9e3b407bb40fe26f2a3bb7a7afe08375e988c32be5405ba3a82b3519522954a3c2830ecda69763ec6f410e210d2f518f1cf2d09a69cd5c382e1119d8df0f79ad8b70c6cd503cb865384c2b46848f33b11276bc8629d936bea1a89a854ddc01d6bd0064aa8da00836ca78ff57b141173650e2f943b2f96e73d4e1f3a5840ff36d707f4c2fdfb08f0bce374e458512e6682a74fc1dd78bc36ada218e679380d2c01dc5b81e84eb8591ca32f353fadde104af799c9394dfb222fd5495a6d237b461dbcb1f5de1becfe88222a589fa0a759a1303ed3b90afc39ecf896c5287a644d3e9da9136a2773e97f47a301b90cea92fb9a894db34e30ef119d67ca003eb460427c59fcdf10972acc174c0835bb38880b8461cb0bcce08d756577081039902c3313820af8f420ddd945c730821464659b347d86255addfabdece1d158c61628005380cfb79e1e51e09dd221e25bc1d93e460b8784933309d021c1f7520e8db349b5b8070a5416a3de9d42237ac98c123d77dd8fc4b40c69be6e54fb4b495400a0eefe987dd31285a5d4a89b2f19a0fce9fce5730bb3f3118016b27f1186621755ca87d2ad8a7159568c56a92d3690605d270eb8e806726c9a278309ac729dd9de0d5d98da86626646e94b7ffa3aa9700746e39318c7911242487cc36862960509064c3780d1e23d1cb063b062378cfe2d2473c46caac04a93fe4fa0c6855c0231912a720615a8a55e5ea87193c87e7e08bcc091fc760a702db03f7f05bcefed9361f763c0a2c3d186251e733a8a056be47bd1221c34c9d9e2d7823d20cd211e34c60455671fb19ff83e6ceb11da38bb318efe9a62b72ef0f20f8130afb07c3c5e04bff34f6e3cf124a76fc89a934d809847384b36ed5eb7da5c1ce13950aeb14fce378a622a802d1d51a2776ce464687f710e04b11e4f14e4cccc37db6b2f2111dbec4d5f3afbd89f71960c441a397924d117c6f9758e2551e9de4e5b41019248c327741577fb21331b1979f3fe5e7d1d7ac616672a5bf459d75e821a9b3d43b06b38595b1acf938a38","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
