<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6bcb38202488388afa07ce0a5563f96bc0a28074b7cd4698d2cf6d5be7858b8282fa584dc1707180fb63c1630ef25b638db36ce4ed2b27a6002d89e44bd8369000d812ae8c388fc3b5f7d6e3eccc552062223dcaaa53c36de89ca7f9fffef8238fd3f385a6f2c089e70965497e811006b540905e550e9535398b27b7d1c8b41ed1a2bbf2e7613b854e319d3b3304450c144853075edeb8f3b1b41be3fa718c1d05b3bf92bc504eaa1d445363a031691496e02eba6d0e39010f477ec395c21f210dfaa4da1d2417433c40e52d4295caf1e1ba7d4b7b866e99677b61e671154b3e4b79d990c059342d77d0101289ce93719dd7bd0b0c23175e9429d8e988ac48a092616f82dc3b04f333c6b99be0b5743e119ec2d87fde921e5890392f81d34357f7b41b5b04bcac3c36b2e5a4736770cda4298d429165cf339deb5289f3efed2cc8416eee191c67b3887a6fc9bf0c514014952fb699a6bfbd83667ab866168bc3b4b21efe9a249c6667358957438b6f24470e2b9b6141871078c52026adfe25d3d60210797043b3b6c213b38c634dc4ec08c0dfa5fa49039e76cc09c0e790b0c7730cd845010920a22a3cc37998712319d425095810331e60d745f53bf5d17d9ebea7872253d4bac719634ad96da0e52feb517bfd2336dbde55a57115d694b059a33434ebf44ff3dbce70241d4d4d2569272465c6f0d7764387c80838d59e22995deacc1ff2cbe8f6bca8bde80c717b7fdbdc239c4db0014bc2055a7e8eecf242873dde99038c5a955172704dd21484041c4e46bcb4184a00c5ccffce448bdd30cbeeba99c23bc540a7c28c286808219fa7d0d9a99de2e75d0be9ab398fddaec7d082b4d8cddbbfccfa826d8688893f5f9f5971d765cbe0d27a04d9a4faa0060e392e20045a920838a6aa7ff04ca87cb2b983510c3101e916698ac9ee98a7f80c06a06bc119a1a32fedf9e75697ebbb0249204a379861336a912bfb6c24517903a81e0b4342bf091db8098f6c5cddfdc1eef735c9bf37fdfa7d7669f6d7918432e5c4186449dbac3bdc081c4f66ad30274a0015abcfccd9c9936cb867c9aeab19591da767822d827d875bb9c84bc56148f7597b211b2a4571f136391935c7bb4396a372e8db9669c6ad3e1d49e85d8339cde378da8d186bec7c3e9aaa05d89f86a18624d41b1b6fc7c5a6a8ff03cefd3907664dfdd3b90016b4f98ec56256124ae5cdc062c8d996704244a4861beeea036f21436ea59e6d20e379be110a570aa20516f653afacd81711b1ef0596d42b80a40c7439f81d63dda1d059d563c399cbf715f0c89a914190c39f16f3c8b4adbfda493d9e30e78732cfa96a77604c442866af39d74b43708b277e3306e500814e25fd69504c8807d37f345878b20cc29d272f8bdd775472dbdb61e35627d311fa21afcbfcb6a66ad64b5274c642e488dd6ce7c00385b3004d3b33f4eccae985756976f0b82389b3a2b5026156b7ade4a7c0c80b5f7dd21967095488a6cb138722655db5267710f04ddff9a3d906b00e7bd6a509edb15141aec70a7085ed79db917d1f321b01007c42eaa8a3067b07432e8071586a2b2404b82c84d1f74f5b07df573f4ee8ddfbae257f279c2d22d82242addc0fbb8c0c3f9a0b34f7cc2e4a63ba301e1d49b0a0673a774648041f32ca3e416b8f6b18a514280f3e2a4a4e22ff2117a43eeca95553a5a2d80969ca40b774bcb6f63799981b04a7b6490437af7f697890e238078c9604c06de31ab883df225a30954568b48fc26d037fa6df559c8a3ca6df9ed639c2f8be2b0106593b3df847b46de04c331f23112899f87f10a5c576dd47ce83031cf5151bd4998ff0765e272692a4cb2e42567770f6ebb8084e9abad169a5bd1fbc5a9c1ab5686cf53a7a57fbe2b130eefa6436076c42210d1a1bea3d46a5aae1b77ccd6f06c321392da730e4e3fb44aa379bef37e6e06fd1fe589b2d4cd3331d397a985cce184818bfd01610ebc51fc08a62d1071185faa1dbb50634d9299979a92403f93ecb747bd373db4d71043520a376edea7ae730d6f17cf7f5d137dc23cf46864e9114bf90575cfa4fc57264aaaac452093d4b8321d11ff29072773debf310c25fb16bf60c31ecccc7a2fd2b7467289c97bec9efc8ec949cccfb935f2e71a0816de17a22db560c41d4f8bc98f4825782cad00aa5d2036f6bb0c0d82371f911495ede508d78f773664d97125b969b6355788c4b8f9c2d8d6be36bc838af64352abfadb0217b0686a15cf1268fa149ffd72b8dddb390dbb716890ab5f24bf5b2161d820610461491add62c58c247f9f9a73444f48b556f3543424eef4820b13dd2dba16e1d8cfd67bda265a8496a2e1989c08bb564583a4f2656a5282555f0082dbde5a7a16e967899ecdbfb8f46c688b56aa414ee3813caef8a4acf7b95e98c98353c6671781537313910461792f725e2cc80d71b41bb839d7abedb3f6faef207877080cf446c2c76854d6aa707f07e9ca61887ab4698b8cb59769ea4ef3e9f363d5d3f6b734f5eac1f352564a0655ceec63777696acc3a37bc0099ea003967d38e429f9e3227b549816a918f9e194eea16c130fdb8330bb51e94e29c20c3674ecf4d16997553fb2712de21b427a4944102e88794d8d773056ef0b8a8a6ccdfbb17eaccee894233179a99a54712dd0620bbc8e68d869091bdbba16b18c0dc0d02a5cca32d30be431a981a55d23f185be0eaebcf2fdb85952961523f6f26f0a7e0c74b81016016476bf1c1f43b240cb94a83b8e61add20a51a6a5ec08c0ee51f937565db3ef856f7ee06a2e16e9a78c6937968e837471e8ff7867d2838853da8112f43089409f0698e168c86bc3f6d4ce9695e71ab47a17ca0f4e7a58440444886e2962b2a47cd373bfdfc86375a5aff034352c89eac8103b04bf00dcce4f181b24224c2aa8cecb2dca7fca01340db11384a2f4b7ce6d858e30d18a5cc42660995c342a25eadecf1c837da97320dd517cf47c088b88998a36c57b322b19db468f9437f431c8bd4ee4933267edfbd054cf7e2066cb5175ea38d607ff7c6413b1a5bb70d4c274db2e3742cce2979fa699ed030e605a5f471a0937c3bc7999b94162033c8920433faa51e138a68ad7143591874520bcc7ac17d1a42a3cde2011600adb1d9e5e7139df0109eaf797fd101dc0f0973cc91ad7dc8653a7ae874baad584e7af257cfc62ad0a5ce588e0d92bdac787fefc45d1a0fdd8018cfebf575161809bfe64e3baa51f205c604d1e8dfad3c7086e723722ed9df374e126cb2c0106207e47ed52d95a218d950b238c32fc419ee23065f5837f1f973f538b952caee54fec8e7d37cbbbd1a121f3f23610186360cb7da552099b10d968d735b4e606abf1fdf6b86c51159ed40f7f35fa0d11b5a71d4a9a0d9913ea249b86490d9767dadbbe3f0d6d84c9eed7e4ba7cfd2b3a77ecb9dd0cfc669ca4fcdfeef7c8b5137a5658b132ee4f4d940de69a6e419a54f559bf6b859501b25211589056770b95f016461741415bb715dcd14514a71c105b0a7b70b84daac7b28d2f3bd13c3d084f51f11d97049bac60d87d54e59689df0b1e437d5a0c190311d9d7a02791f5fefa94c17eb9b43f62b74446ad839ca051fb620d53826237013fe43bbdfa99ce6afacc273a3bfe5619ade2857bc22b623292e30c77ab5197e95cffc802fa993eee11d547690856aca6fb18e852b89ba46974805bee145420b33113e53c024fd20856aef3fdf6b330c54c607dd49570ea360594ab4f457bade902c3ce82da2d9500b4f54e37797b3807f79f7416c2ffc0b0788599e65e5d490cee09f73a622ae17d621a402151bdff449513a59a7180b394bf1e6109da80382102d8d24a2367e1c7c7c3f51dc9afd1d53c48f90c2d2d5d6f0f19c1ae4383f9d4ef2b93f79dbdfb9257c1aa719305ba771e0d011fec60d62857c6b7a1f3490ebef34b7f952b2d3ba8c7a0ecb46e75935ed11fc1beb0d255f8cc88938d10fddf343b84fae3c2ba2c217ed0119dc0ac441455ed334f641938bea8e35bb608ecf66d5c886a6fe51fa7e90bad8fd4e4a6d370d832ef337a58b7eb27d8118013aa3b322953728ed5f8b7eb43b6cea0ddadaaf6c765f0ecb55bb435ca4a1e443f1fa55eb171e85ec1f5cc14dad7d3004c1995147ac3ec39d5382aee299708f579a02b84b099190ce785be8057d3329f37dd33a7ffbcb5c96585659bddc25529e8d100b3313812bffb783ff8a7e2adf7b9e8535d02e9846082922dc0b24d7e5d8dc9d85600dd792500765db4cc3fb769016a32c4063f1d579a6749d12565136ab8f69a82a4375918f459b4cce8a61c9a5cff0bc5a6c1f4ce13f217f267a54a31d478e58d008e108a05b084f830977aceaf3e741d540d9f8a2405da95a611164ba442651b8b677ab65528297c8bf8b978ab1e86106ad2b2926fb6f7ba7d6036d1c39be023c3d9e12eb480ac7bda69c6c10639760f10428ba02a6e36b4a1aa9a1e8daecf3d568391c6d07166fc76ed29633918da43d765baf6a13a46416b9efcf6d892f0d0ad6007eed4c86abb578eb844c0b6c85385a5c6368f76d6a85bff432819658598ebde637d3f291a5f3d3825abdd01c55d6f0ae640b3ac9a232111eb08c9c8f5cfbf14adeb09045d2bd330c4d1688961c3a8e26f5dc49160abf93d65fdbc5eb92a89de19bfb9ae4cb4ef89c4e84c8f438ceb576399232f9b674967922118eed46f32854f0e943dbaa5fe800b23a4c58e498e2a00616ba3e5d3311c7e58518dc4545a44693f8ad60bd8529526d2087bc2062c73848434afd86d5a6e64b2921ef9d42277347eb3b885f530af5bd1f4a76ee7509f0c0884e90beb237e242458a3d48744cdf1b926fd3594cddaac1b8a3eb0c2220dd9888b98f395600d9df170e36b2e7fddc39f54dc0d4436c69e56455f40e5591ce3f0a547c7bf03cd1ed79da9f8af4c6386cb9b24e5b0c8084035936ff061793fd43130161baa982d1912a1b20a9b1067b27f8ec49aee66cfb6bb0f731e9516ff478218c60f8c37db178d201e8452947dbc8bde52ef5b48b407592d8b61bad326ca97bc43c158b647e9e63cb4491551bb3a3042c762ef58d95b2b651b9dafae5bf893e6b01a6211396f32c6370492160ff702035d363f6adaf1e27193cd81648889ae88c0252dd28460e80fd328fe3e495849cbf98e954c3845a7d69deb7c65e99269027a640b848cfa4e7e7b43fe17a929e8b59666f5c1f819051f4a902b3e202589267fec0b59ef38ef7b3c9941478a51541ca637453aa0a278254f2d5fd6ac3429259c1d4394a24b4d88ea299aceb3d0d51769b206edfbfe957328d1ab1d1a7cc356848ee9ba9d4e9673de08a646f022d5ccdae04194f1c7b8e45ad106a78263a9b93475c75ce4a99523e6616352718d9ece0210feb23d2a8a4ee48d7d7be2634c8bf50bb9a5e5a4287e1484aff3d3c902cafb465093892a62e2c083ea4936992420fb359f402451043de6b358a3579e99576a8a08f87e59aa222479c3e2640ae27f1c4787e0663ee23a81282a314502cd33c3643535d78869b3e572cc5ea4f50d73db7abbf408816f641f458a293572a84e9342905f86d3dcb50796ec24808219f9f5dc183d33561c2d778d645a501f449e4ec9bf9a0afdb1c68a8ce202e712fce51e0c502e430d04d8d3be9943deca7e5ac023106f15883cae36f3bab4d4316f48ca985c75c077cb069f004b5a78da564ed0b53e73ca19bdb382f45aae35de976fea4a20b4fd937dbaf275154d0e0033800653098dfbf13e33ff34207e455e81c1e9728f365c9f08fb0ce774fc845a16d39e7ed227cf70e66ccc59c27342dcfc9f136284ea62bfbf9d19d84b3df67e1b0e3b36b4314ec3490e801b31ef72eeba58413632122290b03ac5f4749ce92fa5a7e2c5edd82efad9991bb71163fa6fd08b3c63fcb018f1b5d8559d00ad923c13f679c2f20a2bc486abb36e1d29ed4f64cf23a15bc318c3c1fbdd48f61622df85f221d3f344d781c8997155dc758f1f5c0cdc22ac8bf53960be3879791c2a52283b64de8b6172eecf74e792060d2bf980fc618c6359ac0e436464fc5dd61917e011d267e86b8c3724882550309e8a492ec6bc7bba0f3df5f6f71ec59d241009e305dac931ee02b66701c06c4ccdb56440f185df4ab221b7753e7c33b511e8457cc14bbfa6d7f095b81d7a975bfb5f901297a5cf7876a762df75ed58a47bba5ff849d9f494c7f1805fcc4ad1377988d4b67919faeffe148cb35e51b3c1b7bbe286824780da1c88acc15ba22a61757dcc1e6383413501c245d06257378d51f47e7986bb3ef88157e92be88e8463b5a6423b0247738a697cfccdd3769ce9ed7c8ee74b5734499bf29da32be2faac66755b9eca506467bd1d0d4d879eccf122904b80da910a6a9c25c8f7e530bdab1ef353797b03bc03a03f92a4f7af1e4596a8372eb03c3fbc8d6d71de7c1422fc88c1719e2bc703265021b47f36c4aebf42cc639fe3f0b9a8f4b9b6679ae71e18a36163c41eb9e834d01d566df3dd21694d1f7558ccf5b207b9ca91477029024bc57cd5de04392901fc724ef5794bfa3ad256ec943f86889f1ad23f1b96185d1f3ff47c71c1225943fee8cb6d146455f9247b2ebed5776e4e3b35e667d17717312b82f3aabc3cfb9ea3f9e03c99aa9e28a89d342fb7685ffde70895eb55ba382922a246419449fa5dc17f3e22fe718dab37b7574d0ae6075e9cce1fe2221a95aea37414823f7dab5a7bc08b0d330740e4bb8182c00882675a30dc5b8689121cc8630e9fe04acfc025cdfbbc063d7e8bb8062716a56fbb9ace2cd6ef28e84103ddde1a8864bae9cb444e374052672eff74db16401cd618a8b9b6bc1a44494274e0bdd2bac59dba4099b228a8f4e563a9c0bde8ec3f1d6f81a7e2c71d77b4b7d208e04fc5a8c45285563bba62c3a115152a6cdd32f3c77ba9a891d128ed8666ace4e2b2f1df15582e8718f5e893273b86eddc1c00f275b879c9657321567db55e169ab7a4e3426ea09a58c45c36f358a81372f3b262396f86f0a64cbcfdc47dd5110949da37399c6ee471cd963b299d78f681981c670689f42d8e77c8ac756e71fa2b4595a6559d9618162acc35e788583cc9e171bac7795e36c9f8819f545a01738ec28a6a40463b8c6818316d9583beb9fb9ac5850fdf7024ab5ab7e19e53a33f9212feaa4ee4985b8a886f02c1851fc7756a592ece81d638ba67331954612981481322d137afac5395aa337bcc374d63ceedf5d8745459d1eee6f0e294329402736a121a9f207515a9d32a412be0baaa17e5642b066ff8349fbea92c18c400be7620e06ec5dd25068f92ad1ad868539aabbee39926c6558c2528856bebe4c04ce96d01c6af37a2505649a5d51a96011b6c4c7caba8c709827ae0177c1b79e4b44e95f591e7f8c2cec82ebe86c87cae6cbb77308dabbdd4db9dc2dd4dfdbf83293886bce393bb79fe57f7c6f3d5e94bcfdacb4da7f098e7501f05e54750f1cf1ef545c20efcf0d35a970da8f7399efad7fdff09bf46317540ff519a190242f05e3cf181a8007728d95ee34ceaea7ada39c078cea650972746585c88121d3d54d882841aca36647d58de058a80fdabfb14d2b7f15fc9acf30c5f7c5120705be8b340f7520deb3f48da81a3780ab91754f5f9d12a6eaf8fe47c5e0290bf7efff0dcc21af16ab706eb2c22ccb3f037218eb198f9659ea6ed2a6cc49869838b62c38a2c831990b7cc0fe85978671412e03f2ef0d32874a2bba6cf2f7f26fbf424bce5722986822468281a7096c95df64d260962977299ec6e6e701d22d4d01001be63b3af35c174d99a7a4d2df5ea63836f446df87592975bc65afba06fc11cae5d4e8fa844cc616fa18555dd3e060ab5815701b0b3cf5f45a23fce0ab1d1b7f0b38f904cb0bf72ccb3be480c629566f97ca7673bb200daa93bf52cbcd5c4f6d147e37a37209ff2683393725827c5db448ced5afd0057c065773511ebb9db0a815a19182c48187ff21b64207288751facb04c53468e3d77a6886802d3240974ffbb087a028c7f6de9589c1eba1ebe3fd46548a57a704651274a9e0e409ef7c66086a7640b420bbf1cc167ce1c3d5c10352b68d20232ca14b5d850b3e5ef181c28c7b10d76d31a3685232dbf9c99fcf488d59ca27b01a79ef98b1981b447e4005915a67b63d9946ad1607d70980fac24af51edad59f67d2702530d7d84a80b7bf7a1f420b7eb84a014ae050ccd573ad83652b2302db275687035f94bc363c246e82b5d8d614f7829f789850b028e4b4d519c954b82d73fb4a47d752ae574ee86080428f11ba05f6a85c56d7d2ea1131c0e37ca89c41466e5270f028bffee6ef6fce5b8200c4067a41de8f94180ecf36ddcc4771fd6a9d89706baa1abb9f8bb922585de45d44c0454cfa643f3e4643e37f3c283a45f377b853e900f1681aa25571e5c5aada5aab21383627f20bc2728f2cb54cfbaffd70eba4d3d53b1922d9b09dc69db507c9aa5292e1c0312f4fa5f9dc8153bd1a7bf47836db7f45fce85c5c138ec801b66ddd4f4dd37653b3c63603144563563f5b7ae4b90692e25d80ca3f65b43cc05df15124a1aba5313624771dc06d031301e2a3e4018a1f9ee120161e071f24eb61a641e8915794c4ea619290d79cce62f3a5b5f7946bd17d9905f729eac18936317ea8a28e1caea72c5ba7dafa01ada039d88cc9dad043381639e80d857edbe542c5fb6ff5457eeafe780f913a483710a84bd99085651d11900aafe288838d611f15972c73981024e94828e2c68953094bf34e17a6f2aaee55ea748101244587f40e88623f6c6910e1757e077f44334223ed189bb17feb885eebab9578a609deaab1bbe818a1242cec716bad25f10d7053b5fb7543809472515c24d53c560678608d08474c71b26d08834f92ff1f069105cca169c547c84bd4944c65df55515a1278f151d3e5155fca7aff7ab6ebef7f432e6bcdbf96e3ab859b4d0f89f3bea16b5e04e942557b910b4068bf9c7065cf9d54d3c1489dcbe783a6390a9cd46d43f9388309827158838a4ca6994ca4db23f639b4ec26012756e9b3ec9673e6a00c0cfc99d651a9ba1969ea9fcf8023bead3a4b3ea82f2e5e9f1eed7e949489030aa2048843f22f6917f4822ece42e6f3e301053821a9de7be0339c367a83b49c505138cfd97ca6b0990d0c92a5f8c8cd76fc02ea5f801a475d889cd9b1ec31babf97","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
