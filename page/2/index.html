<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0954c8e6c502d9a2d09032bb28bff4e419020f90bad5b091a8636d2fa5120515f655366276958702f7de4d30372035e424699ecc816c60a4d27e0139a893584d70b95a74a0f3471badd855e4ae3297d5da51dd26d1081052409e3692b2499202a3316d265a13ff2a52f1644a4dc29221da3b3e8cdeec94927698c081dae5b593ac0a5cd4e0c6db1cc7c5733cedb97849452728c1738b4e84d9a967edbf6570fe1a07dba1050da17411671850c4034314d6402c455eeb0a65dc7e40a872d68ad1a29a3db1d8e89c117ec4e1e6a181834568234e72634e8920029066822128d1e92c3695d920726f05aa330d71b69c13481a21ad11094b7c2c76bdc617e32464763efc345e7efdb8fd76b4f02bca1c08369a71e7b72e4e8333bf4e6564dec6d5cfcef7b3349c163bda059f82114d547735069d7fa45ef1a940b15c610e454f12da73deeded66b59b1bbf543fec1680ec43a5e7d6d88a60ba3920f7a770d036b417a6fb4d98c86c0e6fcb2ff123774b81b595c606a0366f7cae3ce8ec124eed537835000ea2208b586e6c38351ffa6c158caf97952645a780b04069f748c1f1d899e2998ac49cf9aeff77f26c3cb5e48c97d52a638814ce1d462ed82d0466d19b192eb02819d989703cddc47f38b2b91b912b354ea6719e27113291669e08593741a05b79f7ef9e0334816ca4f29d43d540170456a99dd52f2daa2420c446e70eccfa0ede84e41681fc6e8fd7a75547568ef3fb9f45ed21e6dacbd6fc09640b2b7c1d5c15c16f939762095c3f4cbfe85bda368037edbb8cd7edd641cd045c2f5e5aeea9814aefb8762b2b5a79022b5d6c5f2bb9841c1b6abcbc81974b1405cbdca09fc95c13dddd758acc31fb55f450d644c7bd784b5a26055281a6ae7d18b6073b8b146c4f047588d9f4092389d4a8a54d30ff62299b16a7a31f490426f32bbea4b9b3d75f5d1b098ae4d6057a7b5e9d6fbf850c2bb92cf02558f55b9cbab43ccc74122542cd4336a42db5151861b14c1bdf87419305bc4d233bfa69625070aa5a28b1bc746e0cec95bc1ef56ad876d0d1dc253d44f086f1620192c84b33125f47a320e508529e380749c6289f0838b04b6d77a9abf2ca2f62922655e53507be597b4f8d370abdedb559940ec337815e6fa8099beee23d5917d94ad06e23e5b7529b8b124be1757b69717f8b17d0eba44f4a4bfe0ad7b6917be3ddadf130fb6d329403dc4ea05e9464b5abf47431b0a9c52f3155d04ecd856df928ca30ea7bf658aac4eed69d87e423be707fd6d78d135211b739ece75a6b45f0233933a22c41f45cd250fcb25d9a16ef17912f7682e21e4388c5ba5bf6b7af37bcb9ea3cc9fb2b586d1b5a2dda85700af8ec68877d09bc27e1d4fd072d77b73fcdacaed021c675093b9f9e2c5846307f229bff3932103c1573aeaf897bfbfa17d057d748680e4f8097bab83ca6021ef624d6a3db8c84a0ee665de6871ac225430bbc75ac10a1fa39a772a1ab844392dcbf849309ebc4ef1740b3558f4a44f7b9541be6cff4b9397d22c529db277c97ec91e4a65fcafe0a1b06c6ee7363636d3a180a5cc3375ee25686fdcdbeee8ee5b321704b00d73c4b08f239c4eb69740e222d3139a5ad6b57b1e6e557122b26aedb484de6fb776618010cc3a8612206c8b01a840742b9949457a4318d1b0ae3984b92dd3e3b3c878ac33813a0ecbbf92046f97679b7792e75309afebce5f730bcddea0c578921cbb3ca2717c33f6f796a1b97a571a8dbd337612276d6ed27df5ecf3a1ea0266f06e43b46fb302c5752573cbbf1c9baf1de1e291fab74d1acfd994c7bbd580a93d34c33a1bc4b1d2fb029bbe88f95803143185c43bbf565149d31ae95adbc6057da35415e6f6f32f8b8a5248f18efbe1d40ff81b2d2a6a0134d6508702a12639a2fe2b16e10d6f77daef73ecc96942f17d5ce7611282625f0e3f30cd0e917d0b078a4cf889908188032becd8253427b668e59f2cc27b6ab4955e61bb6b3524ec048071c0021598b985ce0c0431b15765b3c3cbe8315d227bef872093af08399d55bf046288b778db0b8a72736c28838bf0fe419803e1615f609a7b2ab82c9a75a9f8dec2216e37b41064ebc90c85cb677c8192b04643b7db40253a2f3fe5cb2485a377bfd7a696c97a76552135d02fb4d41540123c82fd2218e5e73604f335a5c3d92d6415761598d6741d08ea347420f04303be2a6593d29401eb7bb8bc6035b0d9111bb43f48b76afd74043547bba14f5a3b7e1a2024fc19823175ba0a73f4671569ae32d92472150a8409eb2aa7a7919a4b14e94c56212e90d0cd5dd3a485bd875c8a3c54f4f4e64710d86c485e9d798815bfc7cacaec5506b3aa5520d8c81b5525c5631c1139513487b36bfd63f04a4c9bb0b922ffe4fc502664c614f2603945fb5c0eb98f153e9ec90033f425760963fe7f1004a135358cf1ba1240d739fbe769a55383ad272ad6702e77141992af33cee0569cce89c0ae2f98e144400b74793378c93cdd039d12aa05999667bfdd0c7f76895915d32081073db933e42562c879d5f11a70ca59e796e3c94ed62690a8af8ced7ae498e7d04a50cb6d9c26d00e178ecb559208fddf0f44ef05f4c4c2d17ac13be5bdfc4b3e654d6648b40b42c965934c5508be2d209a139467746d8dedfe098db7c3fa1eab5740176b4b1a73f96d8c45a76f82e919dcde3b66e2be9863693798fc24c793112891e39701fc8d628278a646bb4ff8978b7501feae263a97967286ed37c4cd446d4ebbb170bed22ec8d2da468634fce394d16fe9c3e66675a2265759d848d236cb6e7c6cb07ccfa893d06ae52784c201a7a3765d4604c6ab8240d7a5d5dc5144c0d70fce33d7ff49f836cc01a4a91b0f501dd6aa98f4ccb22ec476efedf469dd4e4c11d1936db68d6303411c1eedc1413c2397480547976fc765450f3b929b2b54ea07377d46b6cc74fac84be04753aa16e62b122decc162ac4018b7ff7a5d1145f4d6fecc780ca7319992217f90965bf5253dd27da4bc319a32d24e933be1a6d98b12b1c45982caf8a70e1403c281920fb3390875f4201c3d7d82f0598dd9d3a4716199e05d2caae2a4cb596d3957dabfcb353ff1cb19e6b1ed79547dfac9b2e333395c3ca9543773a457ec365443169b12d52852c7ed29a4919daa9a1b97034319d1ed17260b8c6d6359551204479e8aed0628c3e6e0d67c8775ffd4afe133d2f1b9911ba9e7b7339db776e00dbf7cd2c19dafe17f0490f7e9ce4678f9af5c3a4608ce895a5fc4c13120d082fb2becddfe7cce4cdc850e404d9af2fb7e6ad58571eb94d95e8d0c787558ed2cfd7e8df288fb3321f7b67175551c86662edabd45e35f9705de5e4eb5017b067d5ecd250a3b4224f0fb893cd2912ea257b5c5cfe1c83c0180885947214fec0aedf430d080953f59130b6df6e8f49cd9bcb962d1c625b4c2b3d6c9132ea9d7acf2f04f8e865a62e9babffc5c0fa9ed381f95026c21782d20716c8ad606ee5684228b2e7c5626ff68f9674a8872601d4f0a54ace9759db21ae87d60fa444adf389cf475e68730696a3165d8f5f165d9eac4eec9e759c51966b90ab89825c8993c4855c8e700a05f2126ae78a354b1af0b7c7927da10b5823338c0bf7d887e80fecaed255885418ffe7f01695bac3219b6868f5219ddaed5612dbd1f1546ecdb1a788f98a6e74977966a45075aa8fcf5ad2f686fcb73cd5d31a2242b3ec9c3b78bfb1c16ecc446d60a90f1d6bc5c1f46b0e87486c98401a1be77c3050a6f6cc998196fff103f30ecdbcd33e118b1c6fa9a76ac3158f78616e8462d9e6037a0115944f984dc8ebc330a2018e478919fad9d37f79513eafcc90f1e12010d508d4b00800ac6d8ce081ba66b3284025593d3aa58f3362cdf6b6223c23db509f83194f17f0c5227aa7d2baffd3ad06bb6b33db58df2713ada5fa4fabf568b5233dc404a2d0634609e48dec98a1d80e4b9e4be0f982bb7400e29d2b2cde250b20c26d2d373b286a2c246dff78f99f0001236051ca291cf276bea9ea8555d6573e73a5a45ffa29243820794b01bdfc3e817ee9a6a840c8d0c35850668dca17861337189cb6a5cb1df2e373904adfc749c0101650c4e5aeb8588609872b5a79efb1b1bf13970677ead90339611e10d378d942adfe43b40451ecb600f3e4f65d7a266940c04c23a4a09ed37008d7983b46737b82ee4536873bc22bd48c44254cb489ee356db785f1eb485fa801e62d81115fee38b84468d7ef545efb6426e24ce182768861f7902be51a273f9dc200528c806effc905d6033d8df971c013697edee7a8d73b9593a7ae79b81cfa5c22c49e8681907201beaf785e8b1a73c2dea476d75e19a8489705736d50f74e13184c8d7e0dbd5bbc06ee2101bea8af840d2276652931de0b58fb959122db8d71ea22cc8b4fe8eca8c346cdd04e859822de443cb4720a1d258992c6e58a7ff6eefa710925981d4b2fa52f48789d26f4ba348d9b346d7aa760a49d73d1fd55c5cb094401430bcd22d802cd3bdb6d8c0bc5f54b7b421fdcaad2ab7a30e9ee6b160aca7564768077cab958bba97a9fc2731357987a8168fbc88b039355c2a3c8edc7dbe6e98c1516f8a3082d3c3b4f4db8ed60f5f788b458fa6e34211d63fc5893f4bd157978962a2d8c794454ef26cf4ed1994ee40c4b59cc0bb6d13c34aaf7ba453a72d1522278909a4235981f7c0aadc4b2b69644462bd1f7605079c8519048dd3d1112903657ca8daffb427cb4dfe491c662f7ad12c3ac7f6724031432f46227d15191e1c7993271a05a0442b42bc24ddab18e1c44517fe845f0c806def3b7fccb5c875571a0f38e5f5123282b804ae1d18a81b2ae30bc613611911c1563d59c2e6374b927435a488a9fcc2d75f3d78e617a1b50312310467353a425abc7c16fe92345bbca54b21b11cd15c9f1486167c7046d89c1292c5ad271ca1e7fbe21b666bf1f99c02f51cbec3a058a303ee3472a3fc64f40743410b6131e0755dcfe9caaefca44f3af8a3456f6ead13a75abf1adeee2cb65872470601fd2143e62b09deb26a28fde02ed38b90bd125c9440f30c907dd5c54c4dba4d1f52320feae0ab2b2363ab0bb6be8cc66c3d303a15920a94851fab148e1ea56dc23aea448cbcbfd0fed340773a9ca3797fc524fa38a11005e44f384361897cc79912ccbdfbadfdb63968dab6fa730437f2b95fc4bac83d8c3381b03f53059834507e92d513dc9b1a2e87022e073087a8bd5c07f4bfbcf7be7dcbc8be7082643fc406e28b9b1adc9c4ace4efeafbb161963dbecb7404b6492d570d2be03f09f34db6f0d701592d442d03c495ca108205189a9a8c608eda2d248a26628f2e32fd60281229ea0dba7214d1a484df6a037add14e1c3644fc51baf525e24c524506580d6c65ddea8c71c340561ed6be33564f8048a1aadef2daf237ed70829a2a72d41050419981b92dbc7128f8b9f7494891205d55a56f6f049eafda1927b69507a9884463c634fb0a43f91037e5b4b289fd5b55aa2bb13bc3fec86b0ecca8e53e85e4e19abf78d4010df4c5dec2860259fb0ae5ec08a66e4ea01ab3ee0d95761a24e2a89521f7614cd49edb063c61ae1274410a388be41ccdc86d072b591748aeb4b99cd571cb721d1ae43d935a325b3b6e5f4cca6894b2f3e887da461e8aca6412ca8f0b624a81db47f4b07bd162b9bd23c8b747d29617b3dff12a8e347875da0d3459d398511dffc38e3da79fd2b84d5f729f28b290b02f129c3ceb54dcebadc71979fb3887e9b43f5530f1a6d6fc408c300a8b41693e477ff967d8450f89fec3a7060ef88ec78f761f2455d29cb4f39c10b0088a1be69981cb636b88466ed79195bc5e445f74a1379c7f8272e7d19b25cd7b9fda1add3968d6f8ef2e8a20f2ef17a988d83f6049c5f117024b7aa8d06d3f2227a590bca1eb09d64a3cbbf92bcc7aaa495fdf20801cb1c8eadc4d42e04a49068673cfd29748fa591f2879be50964856656f6b5aae415f7cd95b39e5e9650547e5ae52398ae59fcafa7c4a47338290adfeef2403b7c27e035a35ed82b41b581b2f38395eb62fccac483389a6b026ed8c182d8fe8d7b4d225289d0ee83c57c24cccdc15c6cd911503b2e90e6e7efa4794961b35afcfb9369e464b7f4b66c472f7a099767428da34f147ca5fc7b610736c5527750744c45d42c963b47a6b6bc518485492592e24a55a8d82927d95888f09e89ee3cdbc326f9ee70df81997adb6c120fd1e550d9c57994e8c6a58ccfb0325c5393c0cfc88228c551213b6027a84ca9e3eadc87baea30c66fbd7a79e739366b273c84593ed5142bdd30a1d31b3634a9f491d4f27accd3b8e96564dcaf289fe46e7dbb2f85ce5b5944863523fbe972803b4af8e71ec69d51e0cdb71747fa2746c5c0557ee117e41ca782f7a99b19b6b6fef5a58f08f444614986e1e2348129af3406fd2f1014171927d768efd29c57784dcea07000f78713e3951d96a441624322806855d9bf1aa529f9487311044fc86e3d61745888cf173b0b335c4a99e561b1366f9fe8655523a5829f2b665005e5f74fb3afed174512cd50e885214b6859757967479586bd54b2513a5cbe1ba186f00d32cd95e898c7164bcf14621dc9fbc78766c00d09977f9471618a14e2d80a520fa8ce316a04e2380da385d7280ad58ad643376eb28430b0453d34347486391e837b3b997bd0856fd702aa1db9a83b991a990e32afe41c8e36118707d206f0ed7cbd9dea01cd5e3c0be996424332450b7551a2ef6e12c853a1e502768917971cc3f31e0f01b21a7a032087239d0e183a8bd83619ace5ce13732eb324a4ece197beb5b9c04fb278832a1686b65e503151029c29f0d44f4c94c62a6aed12823129067523eb3f9dc8c0c4160984267863f29b32b6438e534cee8e3888971801183d00e37054caf15fd90cb64ac259eb72f9c787587b6b9d52d45dfc43f55b0ef9f14f594d0fa3dad8adf518e711694c8ea996dc81ca5c1f475c9800d3e2541a403d95af4d29872d228644395869c269a1bd7b6dc61606ebdbcffa4949d4b189ac24a35646c067bc01e9e748b091fefb02395edd8259e4c6b87c69e23499a61754f5b3a825ee519b106169e0d6c4bc6e93a257590e51fa89ef961960e6bf3847957303f700375cfb074235485949418fe593824e728f050b0494acb379711055c56e859074bf088f0bc4c184a0ee84ac28e9e931670c1cbc80c9a5787173a01eab6dfbc11aaf059c3b7d996718bb232dad032f57e4b9fbdfd5e10a89bd056eeeeb0a15e9e91ead8979475493c9c819074207e937f0c5c8ed1d2a59f0390ff2fb0eb843fce4b3db7714b61c35936472cb24de4b12ebaf9195f2a487d17bc758a95e3e5884b1b25791f3c1c956f4967d7c7ab74bfd32aad11c0a85845db3838df1c8907ee8ee189b07a2affde9f4548bd43a3ba6317e9d48eae89c9251bffda1803e3ef4566ac7f34db35250c9ea790a01f4d004ac03690c9666f83de82e6b4037b2784ec44e17b4234222f6a34858e96253f4a4c778b689714b14991f0e532e9f2c66c464b76054a237e588b4ef366a7a70bc7cdfed83e765f05ad913cfde94142a0972ec7cc1edbfa65a2078e86dfed56777dbbae2117b621ed73d40ec6cd8a2df11fdfc00e61281e5bd74ab1a2c55e8deb6cef1b3eeea1fb2f240eb928fbe3367a235ecb6c043d0fac34d329fd3d2072f0868679805e874f9303bdb4f68b5596642165e4136c872570d439e103e58e24c52373894d822ccbbdde2a553ab365a6020975c5f96860790adaa7916e7283a3e83ee3cb490c59514ca92cfceaddfcd8d2e3f74c6b55e046b918498db528cbdb37a118e2a1706d1845238dbd99cd838e9321c42798e9cc0f78ab82b75aeacdf0175db4ca503028fa1ce4b6a1de90a1d35ac0065044db7b6c31a252fe10ab93d644ab3d3caa7d9c32565eba1a4f13ee9413c5c4c977afc8a64b970f0346d7606bd8f84a2515f0c89d462cdd81444cc05ea5a3a3441fa4b1f15db49b58b32f1da5a9f5219a9a56b85636aa7c671b7e180882fc79797b16d1cc50c6da4301d1d24fb899a55e76411f22b7d9818e818ccfa98d515d62c19e29c569f111d702b229f97ae7377cda73a4195eac48cb36e7089a917ab5483afd89e5f581d0a378fe3c2bc5a8c1b7c1c65bea704585c1fd2b968d85f3bc5125c1907e4c7772628350393c4c281d0e1fca23579414ffd74afb85526c078873d26b46b7c0825d22f4da952a70730d13a843ba8e12bb046bf6fad9963692d5292e310aecc40b087c3a7584ad0fe329c7a0d41c30b5bc35ba6e75fbb12b0d35b4ee8e32c5345c07956b94d62d3b21e51044569faa36fa921f9d5b1f2aa0674d67581cffb949037680d5e0c9ded237862fdb0bb7aa1be62f178a95da2b13f9c21c5ed4ca6340f3887f4bd7e069d04c0f43d9e67de8802bf9ade9318a96c6a7c68a6583ff7e24741b327c0a138966a3ab45f3f36fa871b76dda000bb9f923543ced684a965db05b0c03779be2b70e828ea7dd6554afe791fae23161fc650be36ede77a4c25e509080d4ad45686f4ac85196747c3323a4419b904eac081d4e729cc15e666183e81e8b688d2a02069d45156eb543d468e8d71bcc9902b6f2b4eb66c931fdaf2e11630a11f3d9a4e7286d8717a86d1387d7dbf2e01484d4ed0102c4582a79c9abc9ac1f6b71eebdb4d62449653bd906026ab4e3cddae7da0043e10209dc58089026e0879d49edfce2effbdb33bf90ab57252b5705ee7117b4f33ea35871661bcb64eef9eabcb65f3fd7046db711b528c66879f9b5b6f7a5e54e50a65a53d666105db4e3c4a98b6f12d965c75cc8aa522a46a2a854c4db8523186ef788c913e1e40269d07b7481780d815339cdbf33a6300e07b33029a6e76fd1b0c0504cfa7436a92ee2e2db3648fe35d7d7aa74faa943f9baaf7ac294d3a5c1230945b3ce7f4f09ebfcf8fb2007a96eeac0597b7629824c26df1955bc025cdbc59cf1a008c911f207f959262afe8702493f6ec6ab3b7ff3e2c75fcc81abe11715528d4759d4ce01b6ef127685ca8ff536b028f2884c160fa5b4b80080d54ff87ec2ee62a0f3a9d3c281f2d3cefa487edb33d11dc068c3297be1386b2ac09b928ae6cb6cc7a2fd7f032b1a49145600140dc3bfc82fa3940d2aa945bf985a945bc80b362ecd15b404f51a4a05dd9c3ded252ef3ae6936102d63eeb22f14965fac942843efab3d6695198f61566a78282b170753ebfc5c257e47e01ac5b708bbeb6e4b20b130fb1491c82de2f70cfb8e9d57c140d5dad38c2565cfcad0d575ae24b0b150bd5de6cf66765102e20ad87c10dd6f2873dc92ae97b4ac9be69a7ffef1be8ae585902af7797acd9a6534343b3e90a58963f51d4f3ee12274298ecf89478a781c8a48360796349191ea0154cfed239d62266744888db631d8639b77390fd41e311ffc6815c25c5d2670c347a55d8add1ecd32c0fcb666bc02dbb5d561bad7e2c151c5919ad3f19bc1cc18e9072c785a3656f390747b57caa10f64fd4e28cbb793784172b591a401673dab7ced01c7b00b56ee08389315c0f8cedea01461d0b2ce54a126f0ddf671cc557cef6fd2de7bbf227aa484fb2337e61fb822394b38be1340741507238621455b64e38e0366858513de65082f6bb80129a0377d2bd4a03ff9c6fba2f0428b1dab33fba68cdad41e78e00636464d12a79b0afb2bf5d299e1b53ddcdeb711e70abdcd2a03cfd3b6876d07a3c7752cf5f0fcac8c97f5d10fa5459d4a536efe155908ffe3638cc005de7bb2240fcbec483adcd20eab63569650f3651545db294eba355dee515d0fbe75d68f11db9e1fbaea6cfd84c3405eb89fbed14391b49a12af735af9881bd1e94273f35e42973717af0a829aa9403d09ed0b7eb32e0942cf6d0a180e2edea459850b4d152d3ffd47a70326b46bf5c2ee1c37c44cb0b721768d5cee8c11850e77a7d99f2c4e0169baa04fcba1c8adec1adb8f15cce70877724278e57d2dab1e7ff2cbfa6291d30a2cb9c422f4aa2fbe47e06f467d10ce73b9e9be06428a9bfc35b841268a70d2528f4d837be86b71303be5ff6fb5b1fb4b202892349925f0d81a35dd63f58370cdafa9214f50570923fb3742fc29ebe25caf9ddf2d78cfd17a73e57c16706397df347ddf3cac4c0463f8dac162b6f3bfc65b8b86eddaa4ffdf668eaafd15373b463cb99ea78d70e53e6b147e88773211e94e8b8f2d94a249f73bf9d8b3f60b02ac29c262f6ccfb8274077f7b00226e88324a006389a64cfd0ee165f684428d1351dacf79c9ff6e39e525fd461c22dfa2f6a8f8e5ae145c405879d9b11b74cbed77e8e9a702a41b059a2f2afc52bc8d74d15b2b81cc464e588a5057bdc121b6018599b5ac36d57b137513d3d4977bc8ef3aca2d36ecfb798fdee88082c165e1c32a9a3d3a4716857af2ec58d1ff33c7190516b7a64e857f31eced5954580d045f36b026febda49983d79ddb11a4719a3b4994113d73bd0c895109d648eb9d4b3e7067354ffdc8ee02dc05e7828713daf43cddbe65654790aa11cfed2e0f669b80fe41abd1fa99ae47e95f7b8ca43de5ba17111317a4112d44f8a685c09daef7ed0c7518bcbd6c3dbd9cc0fbc983a0b20e67388a3ca4efcaf34cc693a2b11f85e087f6f63aafd5f99643d45324ece9242d972c877fc1614e80c19709a5a068f685c6a8f5630ee3ef5a968bac64c95ba06a29e991510def8cb9101f66a80150348536796cfaea84dfaf689453f451ab0440a82b5c29417b817ea0b5bc421e49aa15c96d908de940173cfbf0ed2fa0414c694671b7a6a90130f2b8d218dc3ba39ab0c9abc14c3dda48242d479938355abf87a140cb0aa2337240da0eed41503b8c18fb0287989ba055aa2703956e7186aebaab7ab16ccd8d623ae04a0813b91c2a6d484d148707491adec8134e40bf4f9ea6d06df4f4c5c4f521ea464fde0ed900099a41b721b5ea4fdf8ec9a741eaf8d9c8dbac082c6df3222ae0cd84be917f743ab8a12ff5e7e66aa47a7510fd5fbb90ffe7b5a55c30126c1260f01a8b85900946055b15396b55c5f7a705b6fc7871ec011e0922a1a2ac2069dcca2a08dbd34d93e167179a0d1add232c35167884a53a7b7f8e4d3cbc7769fb7654d8d4b381d924c032418bf89b67182073bd46db6bd4c2a797d97c07ac5156e9ee2afca6e4f9e2c03df7b20225a4f13d2e1bd4c7e2ccf6f9e9fb05cc5020d695313c5877671dc2961ec8d68381941800c77b84915e4358ad9de6b848fd2e0ad7383d44958eff2f551fc05598649cbe6bfd8ba88b482cb501f46109d14023bc432416ea4ef8d66a7a4959b232d94758870d6a5215f019997ea6bff4c511aaed972eb9eaa114300e5b757581b29ee259a1fb01e421add9f63fee62790e5796794bac8ed4d3094a435c04268a010e0eb3ee016fac06bbd64b035dbe72ba9e03ac1877ae16811975cc89fcfed843dd444e8cc00f4b2e4b855f5b3844bec6186bb4ad11a0e6fd4cebe1d6c7576e6bf40ad8417990f7855556592b72141b1c3ad0423e085bf11cbe74203ceb54e5aa2dc9c9f9db135a14b23639de86fd89dfd60680d37cb67e0c6466f9bc8fbedb19601442cbfdf95b6a7e3a5a3d31ced23fa3b0e7678a1ed1e5ec59a92522e7a106d806cf3a2a12814c055a83a41102e8346f98b4e124374300280933b640a2bad011990a8f5a92cbac1dc8501b4296d1efbb50dc5769dfdc8557db12f280f5e3cdf716c6833e59e8f60842229a625558f0ea3903788951f02bec94f23a16688d6144f442106627ab4477e0fd86099f20888e2a199da8f780e5af335f68d7257eacbacf3156ac1d08888e9e0cca4865ae8e290479582d19eabcf7037fc781e8283592e6f8f4a3d480f9bef8ef9fc434492bb1da733cceee3dadf717ac795b82e5e74d1051ad7e8a0fd5291db3aa04ae3a5cfd6b13049279d56e0e7dcebeb4c3884975a7dc349961d8da91818062494d75dd4ccbb3bf2a7bc5696f0373944c9bc73d541f6ffb93193baf57d44aed790809682b3b144d7314fe04fb52675a11d9b64aa454d3f6ce9ccb75f2e1bfadc55d954e43fc4d4f06373fe41039cec4703010520f96ec56d2b62db3aa8ac6dbc0becfa4e5792e51c3feeb78d682b093f200bf6f15245ecee3caab5e8fdaf53f95a5863ca94496407e6d8b7f0ebb03ae0f5f6461cbfea97c4fe5da8a004f596719b89c706499de4a49ec2c9d533ac4a5d66aa6cd53bb62873bc2f798c71dcfb9a2acdcd1501024e8fccd9ad1664da9be55e32014e7f70ac15f7191e293ff02c75be940c87392294a253656cebb56cf4b6e8559d5e75462a7044b7968d39c76cabd8046b05d168f5cd6d5f72de54957ea4eac6c4e812e4e7a9da5b0c4f706027ea1828a5c5cab6b674970ab618ed7858f4e3d17edaf5c80bac27850d4b37a533f554324d589e071d8e87d8ff2348ac8261c7f6ca05814ff8691f6c4cb6fae37b7f17c9a833f34712896354aaf27d278a27101b9d36dd9853f703a0cc8c2d2dd4b05d368900048a8b194c3322ba63941888610bb4823186c032738063bc2cc71f659f7adbfdb9724391a4e76de1e494ac6530acde6e57dd619485a05c733c057d6ab28ed480c639156b8f12f8971fe37c2eaa8aa962f034fa223073bbb7b2f98448e1560992dd7046b5fa4c4defcf6286d38c85dd054219bcd5e169802f810474f8a016c4a84756ffd7efe11298eb3ebd98dd3d1f02dedf3c500b9daf63b85f1365311511f9614cc490e1f58e6df337beb714463a65a4f1e54ef5c5b2adf1d3918ce91db9781701ee754124bccaab2792395658683d410d1c20a1298eb8e9430f65e61dd130095a095efdf06978df5fdf1e6c868ff3f398ef707c28ff69f1a44ba198158c3f505d1aa977c9754e9b709213248f92a4548442fc032803e244a804b251d34d35fbecf013f8e426a197c9dba7ed12a620a6d06a298e75236ccbe26c6f48dfa497f8e604f8f66adfe48a7ad3418d13a42d06e321c5f932a6313abaad5b9e9400dba089ffb7a151e6512c24b99d88ec0b987339bd36ab5a6b131466f67d31afccd878c4a304196af0ce51a2082d77ad639bb7bb22009290bc6431f6431c199c8cd44e9e5951bc92329b5bd879571a633f536a4415dd56836170adf648aeeaa474e8b4a6ddff80f046cf7c6d34c7bfa639d51922f92d745e1b82e3e235de2e406a1d9dd2b9c5b2009d2907ef4cd3bff70f894d2eb91f984a5fe2e709ea3ad62c90b569fbaf026251553a84afea80f7eca7fa94120b84eedcdbc936959fdddc2be8ac1c38fcdc5f57357e64e62f44c8d7db6d8849d4448656223a4f091be6c9d5a385054974eed78bd6cc8d1c67aec7b230259d6c2ccea319fe3c61a2bd3d28799da4f41b289e068e0a031e7088fb0918f519e796c24f95e32edcdf585a5e2796404f2500b93921c1d4b80dc7adaf0f30694528a99b5fee82f7f05316102848f76d5dedaa65ce8e5f366415cc17b19b9b9969bb881a37757ef24dc0e0ce2bd0dd3346c249d6e82218f217f0873da57072c3e04df552fb009e49f1b8f1bc3dc0fecbc4a87dff9936d606c05ec8424701d56e39cb259c1172c3086e02f00085de97d7fc39afd35a375f8ae20d4c3ff40651881eb47beaafff0ece962f5b34082789af539e6261d9c31e39bd6765ff5f40b904eb20a99d5e44aa8bc309a9ac5c9576f432adc5893b7f5035f0814d48a0ce55f66ff0ac7d804c1357e8735af4724b601faab0f4b16f2f9efdf2a176679a66fb51111303917361d8aea28dc62704d436e2f964d1126b41ccf7f4a69fa4369278a0e5c5d15c3d69b150b32cd41493956c34d88ff5d610ee097840616ab2c74e2a75ab3d14f9e6fd3b18211503f35d2c0717f43f3bdf5cc8236781685976483169f328fe3d94c2a31505b695ff3f307b60bbbe52852776386ce84058ae3548bc3576a528d8451ffa4b9d7c2b205c013cac47f1e55b8e0825ae874696002d2744e349d2c8c4d7e3d022dfd3f141bb862d2b25d556718552f03bb1e1b4b410a4ec9df15c45d86069bd59a57e40e6e2a964cf375af038df968b1ac2677d86d57478f4f73d9afa4ecdfe3483041546ff4564ede13e41a32c0415ecf77d8c48a7de3672b6752b2108153f618f26faa643caa72abd2e1fb4b005469e7f7e35d6a383fc738c6eaef4634a02410bbcc25a117845dcffd2535e460c235bb5d5e73e8464b2ac1ae8b2f5483ca57da997fe291cef11813928b9bc80e3d1bec747a376e1084858059228a0e8b0c8696485697c4c253d29ab0cbec7b3af49feb3d7e4e5de3b8675a39b6a7f9ab2289c38373b1742006c0d9bfaf2364312676e3bd4ab0038e7fcf84f2f9780d7226ac72e2e3db88c7e5971215572ca5b30d65f70b1b96fef5ff4fb6aa42fc50375ac3302d890b88d1c7c899afa5083b55be75a4179b0fbc98db2c9b9e770a7bc310fa26becafa042d91698c99d80496f08e4bc7fb67c7792093df142ab90d0392bf8a8655ebe109c8e3822d5916d51ddcc14898d6447decd880a4b27b0426c2ea96e4dcf2d54ed093209255eb653bda9262ec70c478570c641a36d12819b0b083f87cb64eea4d6bce2a42df0159a824fba30d8550b021f18c197531b8fa119f8ab9c2a64f9b4a740ebe92cfa48267fdaffb3c966bbb8f5241caf564c4672e6a68ad24da3e8824f2ece7b530c2d6d8b8eb4fdc77d0647d3211561c3ae29810d72c8c6b45d9ade19958f045b683745ccf60edc1bd14574fc41806c0107213106f82c646c7dddbdd7ec19c3d5ca555228c8d56615a6e1d9d1fccb45fb79f80ef5fd8abad559ed962ecf9334f9701a4412544bd2d3544a37d93e5ac8e8a736c2a9da81b435187413354602c81b985a117c77b39f13f6faa42b1725d282d5bd99c349e33fe86be1623da6633e62489fb925e019a502ef609fd43e52598fe8fc91ce35a9c7cf8d60b8a34c6362ec4aa1646fc418c5ee2b0d3ded6347c8fa39fe2b2d54564e79607a324580f11da8e4c416c2f4944e36ae9cc0bd2acffcb1d5b3734828222f69bcca88f07b4dc80b5bf84c4105526aad39c826618238c92ab7dfe931e773a44eef00b1fb32fc71a9f9ff83652e7db2a192eb8fd451b4e6b8b70b0a4845d5592a443f6df1d57509b61a3435ade77465a1271b8db4e523cb3164fc63d8de97c649780f9ed6c97a57746abded396a801e6cdff2294b6654daae66187e82d53d53bd6f3a6069f21108ed1ed07f27af2e3b4a73058bd9d2438b35e8a77f7493649e8938722816935ff6b2814acd6483b50d0d7a376e7b741f8eaa161c71da627acc548f3490f8b30526f2f78bd86eec89a6b46c9acf2d52a21c7a5533c53508f08f595393fc23f176a91b2c027f91fa45de10ad414e2b9384ce0a0c654cfc653acc829f9a4c5caf090c1c1b2038fdb22f4df2746daf7c2d5bd976f224c2fc4e9bd5a57cbce802e28676f73457de186acc547908f4e4dc2a24d11ba5a25a3122377d55adb6c1db3c1b2a80ea244388496d5ad1b7e575ad1d85fb3acade713824e008cb6c50b0a0a9dd1054425f7b09dc2a9cef047b4712b3a8b1e1fcb246c9ee7f7c759c8e12e0d6ba191ce7ff06023e9a4615ffcb6f928","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
