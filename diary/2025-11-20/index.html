<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"572fee1aa906b1c0209e8910069bb820de9eaaf94a4eea331b76a2e4d2be597cbd3cb4a7bbd50c714dfd617b2d2e4ed8e452b2fd11078e32c1debe08b59ac6051f4c952dacb84baa447563e05d630ad4b9eb7b52fe24b812dabc159a6e5b9251a27a15b8093ec0ab95e99afe41b92c19b131d35d3a4e9c1dc92f58bfac20174b07f4a75709af3db3637e0a8924cec9f5dd30ac662181ba8098b5b2595d2eb575f5d096522ef016b9e37c69fffefb71fd35b1416dcc9d3c6b793082f3ec73f991035bb8c1f8be781301d956747ae62a34d04746fc75b953c18e2452cadc17323eb222d006204cede4693367d3609925717d265fec47724bf3af123bd7d19031cf7fd06f4fbdcdd964073cc8a19696aecb08bcc0099b5bd586aaaa04aaea38ff38377d0ce9a749cdec02e286ba5a848211e92637edd2002dd20d08c50619e81ee42966f0f119902d826c188f545c987ddcb02d36fbc66c19dcd6fe27a63f6a7220b1a1a5e1703e63846ae71a85e0b945b8255d6345aedb19d4221ff7f09361dabc0eb3c386e4849b5c5b683d7db1e2b5a911debe1b00bc51464d85fe013759aec7a43328953e5bebcd7b31b7099d253067bdbb50c3c7cce222d84d35781e2a2c313ec01b86c8b5fdcc8eaae1f9df9d2c5431a22cf69228e7287aa084a85695c634d1d7fac40a1b37e70f9a6840745b90938261dcf6becdfb7c793d4a2b96a531dfb3ec2466dd684bb89c145cb422b8dddbb4174db23807711452ff370450becf89221d7aa5537eeb7b98943e08839958beecf41e9dc3c422442caf13f98a338efe215114b3c1bfd16e12cb09a7a91dd75e6ddf383d6657fb360e67060a7282d032d2925a1954145f5a40d6d259e9c9a12bc21db7a13ec3659cdc0ba781138eb60b76f2e09c6a3c302013795adf2c567f9ee7521737565be7eb1f31c9897d27cac11a9eb20028328407ae7150dfd355eefa8e4063ff492cda3bb5274149c1cce6ae5c9adb220d92556dd2d37dd9d58120cc49cede37dee8a6514cb6f54431d847070f1ceaa5c289c5cf60bd1d60e75ea796db0184a17b19621e53f709e0cd743ca1015e9a65924cf9cabdd3b9786dddaa50d2e76e9d10405b529424e071632cbb608452fcfcf1012f463f88a6ab432311c7c28c22bef6cfb7015e777faedaf56ec55f6c8d3898381f168e5675d864b63c6b8ec40696298fbfc02f538372ed339effa52c5ea5b904d2e81adf92a42fcf83a0d88206db8cbf84e3d1e8b654735f0e106f8e82f1e4e679615cd63248cf924bc6e8089b456cf9154904e04dc690e51309f270f82a36dbf9c84e60b31a3d8d36d59efa22e32800d7dd47c0f8e0bf9006c79f7d023bb0c42e88bb9a50cc5037887ca9805ce15623c1737fc182cd863355a5ea1736d13c419142f4b8b6755f305e0257f4e14f8aaf9983ed520d42386d6feadaaf9b1d967d5c43278c16e6de2a112ca55d74242711522856d58c307ce839100b4a364af8ad349f289b6a1fb04db95d814000f5cf7b98374b6ea0eaa7f07e19bfd5d87f32b4e64e5704eaedc20ce1cc6e5b19fbe86751912351c68efe272557b05509e22cf31ead96bf8f47865c5f82d5478a092cf081a8762e0cebf2ca282df94fef2a0a46239626bb058aa51c4bbdd15d5e764d11f22dcc5dc4efc9e5c42555aecd400cd888de3f1d3bd813fae1ff134cf38fe6e4d285ecca6c4ee433c4e2069cca586075981c2641839888df3595b575d775846dfcc4bf99475f9bd22f791d516f02e7afcb0a7c29074a5cd5e0eb7ae848a5feeaecf8ce89c1223c93739d0b24f5ab65060e042ecaddd4df3505dddaa3dd8d4e03733788363bb677016905f5095808705724715f16541b76f1d9baa74dfa86a6c3c73615b662c016ecf1c81fea4e5314b0765c2e2907d7aff4c5a0b01c5e01be8505d0094bb5e0d307ebe9c9057c9164f975262c201e6268593d55410674fd4d789a59724f0fcd2e8e6bc500c14b6d461210679f6dd1b5d3c4ceebbc9647cb7b06a10fad4ac6b3a1f4d1a794c0c7d19a51145171518c137bd5d09cb44c74bae2376114518b844cc5938a95bef3baf63fb0900888e22aa04cb1c76c1a2f6cac519c1ba9fa2ab9e9ba2872ea779d2e59d0a075fc492d1f8fb6796be03f8502a25560c09519b7332ccbcd1e8f98320436e8753af083580a9dba0cbabafe776c5a4e2f562975900add5046d1e86f69004b479c9b856852b2761a115d17f5aa08c12ad0757cbab903ea946a34d49ca05ba5af2b6f66fe4ba4bd1e60882ac08e493d41f5dca326c598f8330160de9562e87b3605a66136be933fbd6ccf7fe375c21c4ff9641f0c184e9425cfb7abe7bd2b961aad7320ca7efba6bc3ed313f34199da8ba1dc3122e368ffd80dfce435a63ee1d58421a816e3ac2ca7e29bf708419d9361aa8004c914959c959ee8c6fba7a194ec6d2cd2f1f096568d0632a90f5624cdb9bcf1b6fd95a35d7c9e4d05988e647c609a86a53cf775d8d3801fc5c71f557bb359a87868f2d7cf5d92d7c545a0bfa64b4ea3bca1bdda6f0e39f28689202ff1b8eb62dd67c10a2fb19aad796a4c4b7c38cd8c72c086634ad51fea387576fcaad3652e3d5fe6d30f8a97975e8b72a0dad1f812fbac9cfa75261ca29cecde23620a2cbd285bf8d923370542bb57b07d88477375553a2abf6aa3bce7d4f7fb03faebdceb24e98f65fcaa97517465e202016ad26920b52ab732f3634d4b6bb0b3c75674ebaa1bd8432d584b58d6b4ab6e40e8ec94afaa3219170b74960f7554f97cc07bfe2fbc3319314d5710638a744e619c15f179d0b6bf3d3d4f0c09cd6a9bebb46bd7ec2f65f9870bf90c4a7ee86df9e7c3a7437b126aaf42cb91ccd61f378a9e91df6d7e00d5f3c0b14508b4fa91ef454ea95e8718c0ce2718485f235bfb7f08b121281d35b8c889ed8b1e514b8f2473737ab74fc7580f093cbc775d90b005ad6c8e3cc3b7f70999d71949d3f7636cde55eae45c2fdf1e7d3a4eaca8c9e4fb312eb58f9dbf75b61c8d0e42f0c0083acc1db925990cd4bcb804d61b01d96531778f9d42a6d54bd21903a575d1aaee90c8aea2d45fc2138d6d2447d78bcb627b45588eadd186197f13e551dcab5989db0a3a46eb21c9ff706d877891e0b7d12fadec72a580a414f2ffb596c079534c270be8d4ecb98f1a64d67365165c0b2aecefb959b42c279d105c822c8cf85cd149ff444b6c1a77a957817bc5857fdd182780fcf9c5ee7dd9da89981c192786347e0f34f49d38904acb12c6f4d09d4bbfa8be6fe9f027e08c83138a175f91fa67c64da8a03f2649a0349aac0d90dd1a19f401dd0815efc82b6d1a2d65906e5954a8a9184aff261b6391df1a9a60a8a1f5923554b49ba5f92e014464ab039b7af724c662d6522bdb376da36a3a64bb262423da4fc0ba7bde7bc73c6aff290575fbb706dcbd77795cbb4928e32789d714d653d4eb679753c3ea9fef009ca69509df4a69a208406eb472bbab3eafa52e7af29d4393ff7dd1b3f607ed70c0046e4f244f1bef43e9d33cbbe9b3878e9d8119d7781cba3c4ed8fd6b1af92e3c9c2fcc2bfa9fac806e3ed8a1503d9b57b6a04ccc9245739ec40d8a168e42f57a88aee38e544becf786f7db6b11bde2fce4cb6de4f68b381863a3232ed71731ad21e2f49c27c9376e2ecd4e6ce21d5b3ca1d586148b806529ff3c1e2d2515ed210a14a12899917ab7d61dd159fd4f205645b341286887addd8406c102c439c9c29018459df81902619c790663a0ccdba8f32a2006c70ca1445675453eae8f6614ad085a60b25a128090846ba487cb369d49086c3cfc3585d8982e1c91464b3df66d2ed488c95001c2bab98754d33c3702b1f79537ec11858b4ba24e25503f266bcf5001f3bcec11012fcf164afb4127975e8802eff6e756b9bc7549cd76272c323aefd3a2505524c6f7888da52f89261550e60f9c2aa68d94def82600f51d22951d6d36a2911e2d42aad9de427056fefaf2d480b7dc46acb6588c91b17e41efd914da6ffde8051df0a246255931a50d7b5f279282c2a9198b40db4fd559e3aecea3aac33ca69f1fa05af28dd29811e866ef00ac50cdba381013a8a24417c4876bda1e67ed028fa34b2babe82f616ffacdd02e14de1c47c0400b6a76cfa7ce87f43b0dae3e7947bc096df1711cd604d7978ad23fb1111e4e57c471268e30170518d132d7baa9443908d48900f295170adb17916a045ec2850ae56590a90c8fee03b84b0eb81ad0587ae433924e56a44ae02a1bbf411c157860fbc5b946346d748067b18ebf43c393259b2b484be2c1c240a24dc1c188833ae92c3a1a2bec037ddd28a5fc52bc6760a8c3f0af763d453ef2a980f0dadccd3560715b6596f3ccf166979fd40708e6c01f51a27add0e21471821f763dbd358297401064faf1b16446c0866f5ca17de729a876044d1b59e667020959b63f8adfcf1b77cbc50c277b775d9b49ccd908bcd3948a5aaa91009a73924e9898faa7b59447af7328c766b31c29a047fb4aa8f0e2634b8615fa088c8b7915c6d3b9650afe292a893f841fad202c110b8f58897520b3ce2b1d024ebae01a8c0dfd009b32aef89f51baab4d70184ae771831ec92094e2b6fa9a89ef70f331e4a2b5a8d9a96d08d8a005c7673c0803f62e51603a570245979c6e9c114e78eccc3b8839a754c36eae4fa5e0a6dca09cfe71c2c5c00205c46520020ec97ab253e936d35dd3a961c20b1f5843fdaf046d01e1cf65043b35755632c026c5caf0517dc42d3dc6f01a82a8005f9eafad1db31423d2d4850f2cf4032d271efc059956820cc0ebe8b5c0bd084998f3e7d6340c74d42eb7181eb1b74b3618a2660822c0206220d08082fe0daa29c3d0925c7f0dd6dd5ab19282025a4f1e05ba13b5f49a6d6455de7d62884b95d890463d7cc3f8058976a1b4f7e88a7532355b5a625e8c6d5297175bbab34848c14e11fa7b37592423e724a62e318ae9dc80fa792f2e807db9efa7a9db206372882c989e50aa32b3be7982730db9cfa2345e0bff53881374fbff45b67ba0264c7e1ef79bd282d5f42557a3f0cc31807f2bfd7bcd0a7566c292d758c32cf717bb2b69850ba790a07e3fd5fddd3486ae53416edfb87e522087d1e66739d723b8958b8c97e8c2a05278055a042c54f8a49430857a0afa20ee622860e813a60922551a5696596f7ebb251f0ae76d21f7ca14085976b208b9b393e411b0ca8fcaf4a00fa75288d589a0d555a3c8c6efdb2b2d345b0ec268a1ef5f609bf692f2f34d3d8f03ba95303c95aa10a464850ce3f835f3f7592d43b7a4dc85fe612f2b6a8b461b6b5cf853e22440660439b26a4e6b8b802eb2ce3c016e331ada996bac823e2c78a7d8e75432695e1fd44c933fb4cd6c116e1df123484e2a2caaf2ed3590414ce8c7a439da071f4933c93c3db645addaa8215437cce769dbf2e805139b224cf007d05d98df47a7b5d4e7a332515ae4e042df97e2138be962cdf7d001f052918c2988fd74e03e81a5752b49070198977f0fd8c12e29b16e6b234ca9357e205741f5d4cbc3ae291c0de7feb6a76571ee3520d1c3cac810040f48568aed767c8443cee849e6933f42454f225700ed7d9e79099fa36d148050cf87b67dcbf639ee445240709d50fb31f83de79cf53db4e746f97fb4fb1d5d0400148d0cfe3b5a844cf0f21ff1878f715c52c1eb3094bd0923026ccc22c53b30070d4160ef8da429d0d21e57479d62f4b36bc28ea6a4b544e012a1a2ad5b0d09a2bd0d3f5e7ad8ab715c223bc0c423e50e8a98b6d68c01c844b3e4e80bd800fa192b5fa07fbcdd6cd20d938aa4b9c7ddd8401d7aadd2d52c438147b9707482b8742299aa32b5d98b6b906e76b523b326008a1af62f25b95c6b624cb4d7abb4f2ca08919c509bdea74331e89bd0cc9c510401b2839086abcde308420bb7aae27f2642ec71d969263ca4177f0e3d866015db55bafe55b70f8f4a4d1998e2d32cebd0e932c9d5cc99ec9be9c43d25eb5ddc58008c155f2aeddd10f6f6d1c2f2b5427991e67604e3c962ab9a92f3dc746dc6d8892b6e4a30e17f7307dbd5dc1c1d3c6fc35e74906908be5ac280749ff9b490f8f40f733f6542785289fb4a55ecc6117114bd892f3849d4901ebad38448441beb0ac4ca7fe9fd365e8432091d4ce3f90aab77991620777e001e345d04effe26a70fe7c2b7f2eb5f16d6503929c507503f0ec314cfce619b62df3d38a474422688fe509e30ad212ca94a6dc0dea708c5b21d7da01cc5f43eae2c296ed8136136eeb1a5cd3d1e0e722251ac18319237c12ad8eafa612374b68c6906de4bfcd496650a3d900b2a7630f0f780b5a022bcc72aa10bd457247158f6e765a2f1d59d3e1b5281f854fa93d749bcc1e03911bfc32087c3fc2a6b5f189e0f19cc8aa34e48a2fefe5829cee7d4a655e71ed1e82692e70db906c0f41d9b7bbab2de4b79621020c4733c817a3b6fe78a5f95f53631055e447f62f4863a9700d25b7bdc8d347237e5aeba2024293d6a752d202c98602fbf7c9ac55913a1d87052b839631c3ae7b1d272f18236013e850ed5af7018e26850f7165958364c7b72bcec4c9f9ce0f38d6234061ffabfd0f3ffe7036bcc92d884282530ee2a84e797077c6b1ffb0d73e8ac08266ac769ca4b8e933deccf94214f0a5f1a1214011d803c56c967033ef2190b278a36afe322a1a796f5795aab182ee3d740061ad6330fcd273015785b0110dd53db37d8fec0ff565997f3e66ee9097af1a21f7c1abdb23b51c80fe465278540e749c16c5cba0ff073a3332c584f6639a943f72239b8712d3a28fa04693a198506a054965581160d837d9dd4624377b91faeef8c62e5bf041e1f37e55079b7a94f7f40feec9cb613f9fa183e0bb0948e538f4d5cb58bfee7b9392f50a23f32aa4235efb9bdfdfbace754578dac8e84c3f224e014aeabfa29e31c94b1849fcc422f75665a330a9db29785e8b68843c08856226e5038d67eb216288af29974d52b295915a7c82eacdbb9128606443a2e36e2a47047e612de1943f3ce5583c7fe44d26b64559dab468b23e2ed66f867d17f25c0f774a20ca06fb1e209c8987ed4ff3fa002dd4becf110dc82c0c90283e7d39128c578809f89ddf3a43789322c506b71ff64d6a366b56df185117ee0bb2099d665e52fc58e059b454e6293fa92ab1f040342354b0d2f85f2856a4d3a909039004281ade3cedaa264d43819a91c295034d8ffd0ac078b1bf9ce00a36e8871642ac79e7fe30699e7c8009881f16034c309e15a19eb2ccc71325c03a080eb4767c14d7e19990f1ede28a2948ee0f3948d53fa72883fd524cc6bdcfb2e4171d00acb0aa72d275058904308797b71fdf70fea6955ac62f4de556ea3fa1c83d9d9dd1fa992fbf71ebaff88d395ea14b76b05cfb6ec565d370fa8958dc163cf393aef3201adf0ac9aea8e6318798f58d82bc680df25aa18d82ab2c5d832dd7c50f78e14ad136d99b0f1bc3c068774a437afd022d62b98fd27ebc4aca4399401c8b9ee019d8c5550de30d41bc005e757bd32e4272c53c6038f35e4afcbcd682c478cf547db4d3019f36f92c7e469b6f1dfe80bc0bcc880cadeeef89c02be993026932995555cb038d2c3b7da734757c81e8c85819bbe04f85a3df2f7fc336fe18e272c3f61845155dddb3899a647ee8552a33897a0c9453fcb4ed4ffdefe3ce9567f1703b9f509bbf92b3e2fb8c914956cedf81a2ee110b29d40d19644757bb5bd7dcf494b16bc5f4f6fc7ebc3efebc07c85c4a5b8322ec55cc684f7a086364103c10c022fa6822676e1f867fa696bbae78ecfb8b5b3394f7b1fdbf5dd428b281bfec274f6cca62c4db616f0a7fe979184e8f989f31e2b4aa4ecaaa16a04745840d1b8a4e44d2a45f935c5942a73dcda4a62df6ca9c891545cb416c05bf03176adaaa2a902d4921aa6123983c473c13e7b0853d0e2c979e472c4997fcbb9df2472ad706fe49fc8c7274fcc537042e443516d46480bcec4c23d42f8b459ba968ca9da7524b21d2990c5d41cc4182b91a9ef353343ae760f1cbe614689cb8f89292026092a1ace27f6aa559b21633d53048fd613e88f1478bb8fea3f9d959db89727a5332b73351b22ad142492b3a80323adf6e3031b24ea72abae2b1b70c46480908de7b647e69b41b231b915922c9914412f572e828cc34fdb0426368d302a37c4bb660abec8c4db0c24ee7795e17ce85b75c23dee35816e6f15dfa2ba9cde59b6c96120abe81dbb886e54744366dbc10e3ed5192180c8e3fc087c776bb0cae36af1e4d4ce73a4d9becf4954cc0b6b927bda8ad71f65b9e649468f957ce4e0c482a76405f122f1f881da736c8ec422ab9a2918c7a52a2b283d11efb84bcf2a81f554573dc4694296e2821d2974e0537d30b689e40bd6665e0efee4a50268d2b75916da8c5ec5c7dd9b3b86ddf074349884c2e8cd32f31738e05c7b14a066b2d685f9ee1d6b62562682de1e8daaf112daef9d5fd51d51d00d3946d96d1695afe83e285bb5150e4459eba6f495dac1121754ec38091134d563c8b853cf171d89fda692e02750219440f852b50adab1fd2686d43dbba32dd19672931ce3f4f931b8e748fe9fad358e6e8660dbd8bf4803afaf693734d759d3b5af6a9da654c4245b4fe3c48eae42389fced6b86f18268ea56365b2d88f151e5d531ae165ba67942195a958f01465601a98f94f2477e6d37085816dd358f556ccffbd6e131af6dae3f5fa6a192efa1a0eb24ba201db01e9858057e88b1e735a726876560f23929efbbb6d9536485529e447bbe2fdc230268512309d8bf6648db14f988308cc381a27e47882a5687d533a35a4d1f465940802f8f9c87d0a92b606ec24b9fde8e34d7f0f2bcea31a053d92a71fe6947b4085808e04df96dd8831b36bcc7c8d809955a57fd96853fe30317cf57326eadc0917c47671502e32b0bbf496790ee0203ee7a1e2bdeed66f9511bab4d2e56e376c5178683f53ab3d625e971bf3d9bb5b2e1eeb0623125ab1f26664a7012d3778861009806d74bf3634a89851134d92b16e3b1331bdd68e720515d2d1cddf1bcfdd1925e04d97af6b337e012000d7ac941613df78b059581abb2bc764dfe2f694de5e68892a59403a9e5885c6f7ba31e106758c8af4953cb9fc36a1d7c940f967412aff4583c06bbd532fac43856efb03bbb6e17d5fe0af418cc9a7d53f0268490c982c5cc9700c5122a801385287114e4da972577aa33116013e083e21b9aa7d52bbae8fedde707cb9fb2a32d88fc62e801462f5d7166e6931824be7d4e4879e8b249c755a1342280b9e66798647526601a291aed97a76e5b1472bb9c5c052cc7266d46f2049866bde3928bc2da8b93be615183851e171dd453e8770be75750ac60f0e306d4e4a4f58c8af3ef04d795b852c95dfb993376fd2badfe687e687f08e2b0cd0f18f067cc509cbb530cc685168819f0a6b27a0187ef5cb57f24584d4e9e65ed5d2486b19738f1643e81eda33cd530b1bc7f02c16b6331e7a5ebf25e113c8a66e036325fc46b68773ccdb3c6756d42c9a6632315be50e217ce42eea0d122d454f6793aee2a8fd70db0bdd65b456256c180f9228d6166b8e0fd99b3001d66a07a916d6a8418c2bdad8785569f3b9d1fa1e82d0157003fbd88ab11ee5cab71c5d3d07dcc30ef70478eb3c6256c608b9ef003812240eaf50e043fb4e637bc95ea02a9c48abb027773dc92e0a9f140311f51d4489b4ef78bcd2fef30283ea610d5a730a4f860f51c1703a44859f29d593f41949c7b761a20a07bab3371ca76934aff2e7150b831faa0cef9bacd12e768a61fcea25722b714bcd6485fe67b46a46e009b0264a8413d5f5c62b636e9915da3d2878cf3919aaa87675352319b133822895b4397d4a99b67a78fe9558b4025a4cdbf02dcef50025f1962209b5d2851be3da3b77651023a9d009bd054ff1f8b57dd7764acaa69e6b074419af93313424876520be2ddcf2b9b327b7cc2088e9fd88996900de8e718570ea8638e0bb8c176e24655effd8ab281d85995abcf97600408f49e16c0fa65be829605124f28e151d5577434197b81f1a90ad13e779c41505d8a0ac39126a0b6a6a9c6354a530a1165f4c50694cca352de4ff2d93602980a69f0f331ad93343e7d8e23ec409c112a053607733081519c077034ac3fa6ad3090b09f0e67e8ed58b10143ed7a869ec2f09d8399671ac319ca8d368ea0a1fb4525a05475269a80d17af7bd5a9634c7a3ba122b45685413c398f7ea557bdb85329eebb4408a7272e8f9268e0534e4bfc6be3c237b381edefc83126d24e62ec9ab375fe1326c517cf4678c9ca46d253a781deed093fb509615f9e59aba26c6c9caf750a57b28c53ccb28c77e355b7833158fafc85a20a70f5a9d02769555fbaa8ee4a5a45ca3b96d004e4498a6452951d7195f202c31fb46165aa17b11884eeaf9b4b4b53a9def30db4222395f7acf3d4828eb64c31fe3b811e74221164b5eeed5896070f77dd47f5549a23d339c7d581ece18f77a2d7d67ec7fb0002726808ab72979d9d43c7b769ab1ea51c32ac5926da88520713b77b29b3688728ba98b65543c49d7de22265e9fc9791bf5d83aff3e692a69366760b90e09135c9e29fae076faefc2c8aafc61b4d060a5c806c384e99a730f14be79b5943d274f25f74dd7c37e1945e6393dae85211bc8a74e42850de5e43acb61579860dafdd108684b0cb9d511d34c6f7aa02c3ba359535fa92f0396a54dfaa01ba5ee8038ade5023aa0343c6b3f479e5a0f90c3db9aad1954f3e1a7bcac7466dd14d17b2109492e38439b12cf97282afccc20831710f71f2cf5ab9ea5b75c8254f9975f2892a26d14d6e175c24864822f95050595848f906c8ffa8107d40b7010e7a1f084d2fdbb31c6755a8fbed34c28f5cd1406615095b122e74d547aa4c2389781aba660d65b95c751f1dbde0a82619785d9dc009ed773bb1feb5a84bbca956861425854c78d53dd18c81c883823234a2adc90b19429a5ff61327e5f726aa1e72f25a71ffd648204d11c804d9035dd67749978210c23067eaf651eeba73901796474eb29b173b42f827375cc0f7e365ae128b07df63339546542115a5560a35ce98e8498eb8b081e314156e4cd01343ebb850fe6ed102ea0a77fd23cdff9907b9e7bb7d27733e78a8cf9790e4c6a96a9abe06870fe76e4bb4b6464183c2365eef3f586c2e4343cabb69072937df25ecb398a5cae3a6ab5e1d994e380c687218e27db53b49a6612758020c32094fa7659906da0789c964cd800512cb3dc6057ce05c092f2b013621ec8868924f33fe13bacd9ad81dba00c04d8561a33ec71b46c47e83651ac44030203b6d7bc7b9a5a8fa766798a8090d3a45b663f801e4cc5f087c65a7dd331d7198af38417a5ec4d8a93aad341fa3ba6ae4eeb242fe0561edd2c6c8858d9d95f4977aa278f531a1a4e80d6eb5652bf359af41b3bf7624156867f94dc91d923f8f7a545f116e6c71fc1c25efcba2da02c1eede367b0f2f877fb2a2998cc4abf42c48408d3d668cb02f95a946e1509f4e7cb3cecbfae645c60a7accb91b321659649061a392cd33d665b5c38a37a353877b7edcb91735427aba4bcad97def249dde74faa51674145bcad4047730802a2f81bec0bd86ce5042cc324876ff6e1862582670fea0bb361398ba0b086ff1bd5da285ac7ed4b2b3eaf0acd0caf7913466eac36cebe804c17e662e8277704d7522d37dadc1f502f1cece91ba584a515b23286d1736498fb51ca2716547320f3f8a5a64aba290a1b53731038f5291fc2ac72d390e93bc8d71375d43b3e73225e94142e2927bb73d1a6d088905185b96a6385aeb097f024180c4bbbe0e08074109f22aaebe55d7c9d65a79c9aeef4e89477ef1f2812c16fe23353075e5d3e88dbd6b76b879b66c869b6b46ab29c9f9c520f9005b6d7aadf33017d0fe5b46205d0aa80369220f437e151dd30ca42fe26a86794b42893080fdbf2d3c3ed0b51827c44120bb2e38c3dec03aec35799f9257004e0b55321c387c7e3b3e7a10506ef0c1b0dd72e8c6679f2609dd5057c4413674b9d83ede4726e710e802b47e6cd77b4e5062964f1d7b3f9e430f84c252ff65d76c9f527a6dcfb8089ec7210db6774c856602e71bc3549ca723dee7c007ddadb5270f7d6dbbc4d8cfa051b58591adf1aa6c2259602e46eea55cd7592013dc56f5f97ed0a044433d0dfc45a4db0f0bb4ae5256d48ce3d0cb303294e5d3f0278607e7fc6e1961451e737266086fb4de7e2812d1f420f24af1cdcdcba6f0d37f4d8c00ac2011755d08d2279526221d4e0f742f944274e619a1f8d198d9370927a7f1550b33ebbc583b9c8ea2b3a99c039b538e58257d41354c66971c734024cc07d2d2c5424466916b9fe8bea74ff158d93f6fed9f12fe5a7b356ea0ff9db9351ce0e2dde72b3632906b42b7c50ab442560bf2f0bbbb20fbb0a1f33ebc99420d5ff6514d0bdaf6de727a676ead7d986a74abf867189a70d12d8bbfe94974d9039d6b5edcbdbcbd1117ab2b2f875e28826399c592ee04c4c691dd0d3f85a59252973f9425ab639bdeeb2a7ce8dfcda19826b92202d77e99cf88eb3d8f82599908e91fee854501a34f98d1adef9f3e3fa0950991860910ecb1151886ec500302ab9bf768a09e3327900390284d423eb881b98cf524464ba85b49ec358afcf01f5409ae0ae86a44e806194b0766fa9a19d6492b9d85dd0411e12ad27b75886d17df5cc6c6a9b2c72b489340d3cdb6d4e3711f3ee413679b26b638a5ccbb6053feb1fe45fd16b847030e19d7c5bfcc851eb5fd8b4fba9c9308b275c852be4f0623a42c86d337bf4b26de7f076651771f6c1bca1a3de0064a83978e4dab7b2c570b3b870c220646b4af6e7251253446b3c667868e62d580152976185efd82629f6de8c2dedb9d6785b57ee12b0060a1fd188bca0710606940cc130f2cc46a7d2e3e1011728b77187be944667a863cb6e37a1c80db60003da737414d645ae96766c87b114e8bdb88facdcb5def67e13297ae8542012fbd796b84805356ebee204aad3a681cd1f06194a9a5e6d9033df669c0b8a5ab33a32f0eceec2d30efeb5ffeb22bfa9504697a42e56b72112ca62f5a6df349c6e10e5431313eb0341158ed86bfc89c3e4b046affaf0524da7ff169198efaa4f4e65bf3179ff2e6a37e7e370a92160e4377960a20ec2774510d946b3fbc8de8a0267c067574999a7dcc643b573dd275232a9fbb34f937a266273cc619ff5cb739385d7410bd884571e467d628ca3459d86484ebf59b5c84ac87fb61a539ff6c09fbae2cc29a9211e1dcb13fb9f54dc693ed579c23c94d8d763d630a4610f7843a1fe76abae66840afdfec771ac0d566627454ca1028959291161e13065da1ea5efc23f1170165346ca0471c083483e8b3bce20d5e6f807df6128bb6af624af50a8b158eae12586381d92ca6af4836cdf6dbf3b9596b8a681ef6b36c95132da6954c4b0353d74d5d2b65b87584f306862d970bd622dff265f0bc999aa6f23de3722770de56624ad312e427daa17ed9e383b9a345864acb64ebc92c4a83b4eec003282454a9bf032be1790c665a50c4e1a1d48e102a4440e0c137d8349cc784d80db0201648235b5bbc1108615ccd2876d77d0b421163959efbf90a0bb2aa1d27c71b9037d0c4c7005f55d6204cbd4f71dfc04be64018ad0d0b36b78fac454522eb708311d3140bbb33c6b561d0a425feb847041b4a7afd8feecd894508df842b88ac00e983536f3f94c22ec91236bb261e707c0ce9c60bfe5ebafcf195392f80b54299cd4ea1dc9d6bcb6ca17be16af4930bd125c8f1ca94ef43fa4c11409b3fdb65dfed0f50cdac6139de79b9c0b23b0719a2e05d8d0617aabef915aca301419aff16318c82064140f216dd092fda3806ba7c1e7548fda651eeb4e8f88f558daeda6ecdbdf96504ed9e6e1cc45b960f28acccbe91d53956ff7b707f2f3f8f1a1b8aecdff1cb95ce83246d408f331befa20b84bb6ba504b5e4fe69f00f106de053b1a5b7cc5e4587edb948f8abcd9b9c201c427a019f6547fd5e9d5d83f665cb643c5e525235b699982bd238e49b5efe08a503d55fdd79556ad56d723ff2c483c117a23a4f7cb946a9dee2d274c4946a83d7c860d2752ff8b5ebc57744f67a9604b2f14c4d0a266af793bfc1e8342dc81554317adb8699ebeaa8bdf99da43350b8140ea90bfab95cd5a8225578f1ccc911308f553e6cb079b10e12b31f018b9d302e441c929c5cb9a3f9670d38bd018e3c6910606831e03db0e4e29644a896645fb265586c98c03b1d5dac604174119f413894d762235a54d69ec428c3cc61249dc5c8e0bf788f7c622794e0545cd739ff433498626aa504f1bba15497242480007e51f5bbbbad7b281486208c324a69441f2d2d2bcd868ac2b8661e7d940d72ca84850b4a90ebaf09f35acc6a97001939221851141dcce894fe0777bffc449d43fb2e5a8da48e71080cacfe58070f8fdb5528284138fe973e7985730209fd20ddb001a6d7bfddc8519db8f5b622a71bdd9c0f53005308bb42cbe4dfc0cd22c1e5bd44be71eb47a1d9c5f6c3a8fd534b6ce7279c846a61dc07138a57fac326ee845c4cc4c036adbf42b56b425b5942c35a0a285010db7bee0aa5474bc94b1b50ea2870f2da98b53ae3a9654651140de5037185867edd0c8ed59ff57b591f32692a5cd6df5186c0858945a98306ce224bfee603523419ccf95affe7ce8bc3e527c4253b37197cf92a7506b8d2c975814cab7f6c639fb5cb500be66ba251cca883595780c31c1b6f7827ede4ccd2a9af1c16abeb79bcd58c9960f335ae9ecf549dcbae26846ae578259e9bdea57f9975e6e6e6d5e51a8e9a37c0973b67471ffb7f25f0c394f55073eb9c300d6ee34777f88539431fc60ddedb974988ee2ee40801ac57e608fa24a9f7d062637a704005336c5c9449dcd9fdd8479efd519dc8ca8d3cbef3b3cfd97b806ef0f44a06c602cc8e26011653977dc7abcb26b3e833b3cdd00dc9e58bef8b7f6c94f7e65fc432ab41917d121b098ec99b1936e5b3555d3671988e1e7b7cce7ad57b63e5d59cf4ed8fc48284d97d8f83aba74e36393d19efc89c1d2671f5e8d280226e34a831ed4db32a9395c9a6f2d01c25817ee36ec0a08b5003cfafafc3102a7c8604d55167efdd9e98d59010bca1f65be60c40a95a7671be787feb302572b1c766092fcabac129172173e00f656ecac263fb7dc469ef36812a2ea835b67842bbfa1b14e8b645b5c69124e15093a560c36e3db745d9059b6c682ba6b6456d3880ecb77f7e95c28ebd183f207b0fda0829f802365d4277db9ad8fd7226b9b15b084affb56e818ac5a758244dbb72c295ae22233cb330b983e43c5e0a311982b3e5d4eefd4a37f93c5fb4cfc462193b6791875d8062dd0cc809173ff4d8c81d7f34fe3d27e56f32d14e5f786decb1c898a70f3399574cbd8ee9b730aff3d903585f47d60769053bce0d798ddebdecb9624dd1991c11a4f309d5025c71d9ab6411b88d8e5ed34549f3d21b1c63b9f19b0906aced235f741fb235b60677061d88f5851d243409a077ae1d42149612cf0ffa85683613ad4d97e63067e9a35c65f45e9eb742d39510627da2b7b2007ba01c9e245b8cfb9b6464cb30aad86cd95b883a4b9b8ccbbaf6916ebc65083265fcf2dbbac6c5172bd5fe301282283ed3bcc689d9461ab6e4a202490639e2ff213ef36b4c64d7e1b4d56c97395975eb86a961da8f75e4c9fe32ff508f61a31d573d4209ca17921f55307a1f5a2b74e25f4575a5a05b64c23c8861cb545ad16cfc24f70eeb7cb6a6c62279c1550891db2781621d8731f259e9d72d95975bf64e0ad9bafa52aeb9b52aa4be7badc80e97a05925cf720aa9adcc3caf5dc8f9e770ec5defb24f82cedd485532b0cb5dfdb1785da23d3cd03f7063e44df3912501e60ee97e9eb19c586826d9c5cef8cbe915cffda7352a825af78ad41f2c161df8bd04163cc3f14e8c36026609dc922993eed5ef28ec60d14661c6149a0f036483b616292d9d1c36809b7ee040c73d61c688328c4f5271c27433ee56bf5ac5df1deafe6c4bf30d8a8e58729150e796585d9d871dac064082806d57e9536093525b7364979eea2ccc9f6334603f0675597589e7646b0ec4da633dd62da74d09d17b3e4bc70ceec456e443a3e3313135fd266f6a64ae546ab5448a39b35631e0a43718b7cc430e93eabf969f2410ab1832814a72afd0cf3925bf87cc74338aca01f3355b6fc606a7afe5d9628ff4757350989d89194b4c4a76c4f5b2d63ab859ed9375600a454c64016e2d1404cb64e878b52da1f6820ae800e2b232f54a769399e0d3c078daf53545783383d9036258bb68cf120cc83ccb7eacf069b67642e339eca3f69fbd58c9e09f7c4e07d76e68f13dc108c0156eabc03102aa7e06fbe39d5ecba33e7a9581da41b29995ed5b7b58dba7756fd7230cced5febf38ca5af57d58c5e91ac11985cf4fb4e763c0899a78f432740126a0bcbff4750f6608119a7b786765e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
