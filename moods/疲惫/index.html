<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f742401347ed2b4ed53c8d418635319ccbc5bd855c02dd8cb18740967d6b19426968434ba39c114df3bf6e489ad3b98cc0ef71a03e2c88eedd4310582b99cd848d0bb8099eb4fa8de071ef92c4eccb90d0eac6b6f043dd2b425ae7f8fd880f955e5d747de6cdabd14124af847574bc9bd34a6f48ad513140f94247377094acb353dce2fe8556a75418a63d1d86ed20d0007f7899a3ae70304c27ae9f6bdc56b8f4e214c7f5af5c11b8891b6d2f4dcefb6d396ce30eb1e6ae52eb38a6f93af4c0cf571dc573937d65d1069e2b18b6bd86facfe743d2207dfcbb6f0e980d0bf0b360e1d2b202350456bcad370e869dae53d931bbc252a6801a98fb9a5f0b2203628062b4c4f8b592c40192e02ba25856519ddaf3ffd96a6a56787208647e4838c4af6751849cb8805cf9d796b388b812b89bbad3497cd1d31737cc7ce65f56c4c82885b264755c0f651b6330956e66384495377360552b7047c7a1e394128c2af7db7405b3cc5984ca0b10448fdba63db0cb3b6e3a8b701daaf013e238d1a720420d06192fd91f55cf841d3728cbc6f96de4d58f2dc2d963bdcac6add86b25a5c41d1343d68432e9885f99f9904175a093a95559fadfb4fcb5d8618480aa9e6b6155043260f7a96cc45b3982b4a045c9f76a005c0a9a8e74f55fb0c82a5adb2eef88a5f8468c75a4fa7b6e93e96798bbec731413e8f5747629c220a85188440af772c2948c2161a5caa88d766ffe5020fc43a7976fe1022e03278ca73fedf40eb13fb6f9d3a3effc7da8aa3c69078f6bf5e2767fbe4f4351065c19d43efbe94cffe2ed0733268744fee5385ec6727a0732b4d9e2f59b15e66b48a6a893596af20e4512a3fb4d4cfe4aa11bf42f682b43834db24a3fea78a6eccac5860c58307bb50b153e1fac76e56386b9d14eebcf0e9f4519ad2285fd6aa94098dae5de3dc9237408644dad73f2c14a88954938b961f6b6cb1386a7a017d8c7782197f565a931519d7f406b7887543eb17eca29f4c49d0aec6a79854d1e3a6f09b9dc78e85d2e670601bd84f97dddc6719fad7384c8952a9797636eaa82427ffea94897ac37494251ec3d052f12cac3540de3c1ede4602a3abf286e654d749852b50fe8e19d5383857f4c69ba9bd906f348133f5af0cf496dceac3c3b35c3f990eb7f2ced0a6280cf851d5ebdf461723eeaef5de468689d0bc8d98d3d72766b640fb5a27637a855a109db1c5d9b74405d3045dcea469588ad0926dc5affe7ba67e82659732e7995cfcbbe34c33ddb21badfc9c95dee1fe3c625ef4237282bc8f3b408488beff88fbafff33e0282f425cf7f0d0ad66263b3321c290e2190f1c0d915b958c12a63fb2c2f1245f6f91601cb7b84650a8a6260e12261cbb440629987ee53446e75afa32eea3811b2a3498b2a15809ed4eb0cfcea75dabea2f758f99d7a92e088f62c98e576eeeaf7235e1846e83de03af08f28f39b9f8d7085cf9bc73ef4c43daa3da9809c95fe3fcedc9e050f55f457f4dbf009ccca9e261a7f502cfef80498f74ff03b9b93d5444b013e91571a33e26f43ec03e4a21ddb18dfa113db99d7f5802d74f195cc585e1653a0149885f84f8bc530dc59065b8e5684239d2b48652ff98d05502daa1b8584659acf08068afbda752c09ebfb99ece539ed19acdce24e6b50c79ed23056835249eca3e39a40c53f077a01b7355c1089f582ab4c6ac79a18a66427c22580950c9af7774c35c62a2fe08daa61409109ba785573c7127bda053485faa970a2a5d1a4eb32d2978996c737b412358079536edfc531bf132dcaf901a7156eba091dd568e7fb691b5386128489e22f5a56fb8c409276a92f67fa27b1fc7d4b395add15a69db0ad979370e4624cc996f7795a69c60cce3134f43b7a9aa6ef88cddc758e522b26f9dc0241fa1d4fddbd9c922aa85adbeeeb2c4774215b57f63e3feb8150eecb84415e737c78dd9f4a00f2190874825febb421532ae31bb458fc8683712734d2c8c3a5bfa3c061f86d76f547b9627f7f6b5600aaab94b6baddde0d6c59b45ece59789f7067da1f552b2bb2157ce725237e1eb1f781226e7a1a1a4e892a994af58479b23bd5431f217b1118371ef4df53d8c8a57bd791fc6f94d40a6301985494cad40c5836acf413209f30dadc53f01b14e1049452b8821911493bde87b2d9f569cc4acf6468c7b91c79680bfb6b23c67130f37c53dc354d9d49c8688d12c97f189a668b5482af3281fba90b765c6eb24a6d2175b86439db04ee8217e20d9286e88c60ed048ebcaf90722aa648d6c13980874bfb7a0ce7204ba23808f560337e181201c8dec1f91ee794a088a39385eae958364c423198a2cebeb863c0bc51153f8aac998bcbc701b4bb9341188725bb050b5332887ecbb1c4a961eca54c0c7abfcab15aa936041b3656f35da9e0e836eeb2cfba5a04a91d06c289ad467498f97d92606e4a24ab037359922ccce5ac4809bf6e9358a7bcc8604b99f02aa364ab536db188479e2e8801e6622262405fb6ac37504198f407267fe99f099be640c2ca7f3ce8d0d1e50fee4865629202d5cd74b9e8bb9ae12dc1c5c7e1640922e0fddde6803a059a584f722538d5f30f052e3d0fe64082727eb3dd6bd15f2c4df8c257ceb83583f7c30195ba4b8a2eeeb85ff0d0ab128f8aa96b6b5dfaddb3e0f3ea0a39808a738c41b1ac9d149b1cff558416a5d39ce6aeb32fd07313f825e1953eedf3a98ff027ff4063dea62a01e163e9058b72645dcd545a3164b6912761adecc695fc2f5b97c8f87a02fb83016e535f974fcd42afe9cd21b8d8c8047f9050bb43c0c031f18672aea254faae91adbaa6e12ccfd8644cbf796f3113820cc9779d321d2807d04a071ed414e74eb384ce6b784f8a9765315560d6e045b24d030e7b405183646b0e3798ae33be766c294073d6ab8735e0b4aeb65643ca5cf1394c68cdbc33e4177586b0a64a3d60ea4970897915433f29b6fa0543008deef085d547e53ead002e8d18ba706a83d78a169f1bcd3ad1eb03ccb7ba43ae20546501b702e35fe055e2127f24bbbebb7b2aa2c8f4037522cd31fcb4494932a7e69b5536cd8d8b63eba4afd1afb03002949fee65f7c334ea00a20e454af46498ffdfda39e220659851316807b41abee2e0a7709141d0a89bfccdda949599c98a722ea11a6487f34ab33180f79c10ac9b3ae324ca11008c4e7839472a72d8c46ecbb02b6049273f579853e104e2a9d08448ba96427d7d678047ae6e6d4764050861e0fbbf60b158fd001d10b8c25353d3fb53d6e7cfe7484348e5682dd2732360b15517fca2344e6c51ace628d02123de6268a8209da8b7b10dff2570301d1c2cea661c089acb83be201c501f22abec40ff87cba2da1e6813d1bb650b91da8ab7dc744c231c0ffe0a9d3efea8187cdc17d85296998327d68e42707712291859144be42fb687cc377d9823b35f53f33828d0c2b0a950f8f129be08624630f2389ea1570b1a1691539947c312b5834f6d3b250326e763ba7154ffe00d42e6e240d0905b1f98fc202dbfdb4c4e57119fa602fbd050d617d343eb21e389eba096a822320ca5539e43e216e2d100ce856efe67aaae92e516294d2a207d97559541795f146ede56aaf5ad3bf26fc4e77ff7bef8222b9db8a272d0b6c31502730078f0164d64509be23508d6e233da02388ff8c1356f322f55754e91352b70616b011f1be7d8c36c1e962f3421c74ce523e0164bf3582fd70c5d1e8bd7777e301819aaf276a7dbcd741f2fa72599ab9e3c434ff4357de8714fa1de24069f2071f93544a81ef0bd9a5f32daf4916d91a89bcaef977b4320934840cf79b38b2294512ca95a2105f80b46bf36c27775d17161438e4bef89245c2192743a9f3116e5d4d886b3a66628d7894b93589d2cdb18d6a7b44d22dcab10610dd2ea1d17e44dab3f824c2bdbb16b716c13a28db5f9874bf58326cd59cd8dfe29129f6d3c9ba86ef2f80a87312d3b62dd98e515d5e4e8ad8346f65c853f38f62e212653c05a9f5e3d4e34a2324ddaf968cd60026c4ed0ce5142f839954fb5dc257cce094f244cfbfbe1ea4093a1935cf4aee9b34fc7b776fc1ac6cfb077a6cb54d0ae64453522a5ca7cc849cd71f2240ce600aa722ed64ad1c08143cbf7a3a99b6ab8cd28532a53fdea22c638a321456c5f874655d9e5b9f3a6e7d015d03b4ede7c291f503901bab7f99286176330ba7ef79b50662890d2c5b63321b5542630bb2d1301b696db2a906e1465d939baf3f565d3f5bbb8af95385025fa56611a90fd212a2325eb1d5200c3b20b732413634704b0b069f7fc66da00ab57e6495144cb4f0378835d6fa6526e397201cbe65a4fc9d6d2ec201e3d555bc331ff2e3232a894c122f15f728a58da5db429e3a2bb1f71fc8ccd88293ebec33a10dc2e66fea3b9905fbd1d7d199433c0d403e787d64f50d5f05eb252056534baa8b75869490311dd32dd6abf0c3e0e81163a6014dc715aebefe8571e0f79d76af864823bc674bcde41e3bf98f7bd71617c0712ca9ad547aba472aa9be74530445c920ab2884e2eed8b130d73775e0cf0c24cc07b24b74ec7734cc147b624d33bdbd929bd4ee769ae8f25b55abb8361e1550570e33577d048f024e0f8b419cb6a3eb1a26cdba10639848c16330230a3e347fd0a9922f0a349289de9e2ab283c530360a4736f8c63c653cf388a96507acf855ff07ece8f4dc70d8b8f1b43f87f390e196032fdf1959c3d94f585ecd39820220bd18af076dbc4584450b2a813f6d0fd7ab50c0296683c5167657a02e56d269885af2657d5740efdc44e1dc0a9d9d49a9d1d162a1c6cfff057cd345ffdc4eda30d5dcf7fc1fa8672e37773e0011c1453e2660b313dcd8c81356ec7fd21e452123d0b91a6cc31db27f380cf62009e78e504abb628ad717b539494a1f0bd86a2611194a82c03bcbbac015d7c8a78b00af374ee7029d7b33b483486fadc9de463159ea655daac8780ddf0d363a682b516afe2b1161985be30ef471b131eae77b6c45fd7fdff1d985969ee10b95e9562a3973cc3a79fc309282906385cca63923ceb0d12afa5120aaa390be3da24557012507d93f77cd40e964621068106766be845eee780d8e09116d00c002dff91ba14179fb8d48fa24c60496acd41a1e9d676518e1f46852897dc048aae0b539c33742c5dcd4780a79214537e27c338595d7608ce29e3499a0fabec4d70f35247f85cf3d32d79fccbb4c57f062d1f225ed8bd733c9bc15be3284fe6add2f8cc8f96c60689bbc5c0b5a6cb473129aba72412f25dee3b502ac8344df1919443ad644f553c5ea25f8ef7e53aee7cafc8056f23963d3c109eee9c60d7cfde0adee09dfdf5c596794880891dd60953a7ecbf321c5103bd0af60ecf628c1cbf78270c4e0c592fa2a80fb8d203f7c1fe75042e398824250dc1d12e61cf3a1673939e2d2e1bb2ad2210320a6f017db4e31804242624db48daea83698c88cc32018a78457883da582a9311655bf13b8a5636822cae550fdf94f3e4bf60aaf6847a5235e82377f5fead722f0d4711abd3548202b96a45902f739cab5801527e947768d9659a731b6a28a098d832d7332b51bcb7d95ff051e4b7216b353f31e53c8ec286dd34dfa25d21f51fc117a8880916f28cab1838ba9a1ffd21c40b902efbfef467e1cc9cf6850205c1868a944494610f3506ff323d463a7557e842b2da3f34d759081749ff07355b011b66a8feb9e7767bca23a750e151ea70395d672b06fe55a366f6b78f360f505a2c10b7fb15d27b1766410b7c8744a7de35c055b0f98fc19617e2bfa6ebe5f8a0827df750e0f1af250a2db27981b1656203403932cb61dd324cd8a29ce4a56d076f089cf94514bd51ae567cdd3df88b1aa9286fdf2dae476d0f71a7dc6d4155710c3790b9b39d68cb30bbf3dfdc045dcd0d3b9499659b73a0c945cb8f8a811a0e0c8b2247c7f1185de3157d3ece86bc1be245dbc5058c90578190b0097ddf4d82a73e776afaac2c4f50caf3d776e1d89a38c046a0526aadd54a711d8dde1f34c178beec4c1c29ac515c375feffffee1b3cfc5214b3c41ea191cd78680d4fa3d58b22c3ddf685c7df197d0490f214ec20bdf3a65e3f803cc15d147057d5f08e3822aa0ec1f6b356fe1ef4fde76655eaa4532274fa9dc22e9095fceb7639c6d4ac388c1af546656c6cc528699b265bf73fdd0916c7622e49e6ba2f0e1b1cefd6fc123ad9d35a146bff3cb538a8f87592915a197edf21e243fdeaefdf0757693089c966ad1ceaa134bc436d5f2aedd3a26da7e031b4e77ed4a38380e2281d1318a15ea0a4135ef68a47a4982f2022dbef56124a25f56b036f1e052b066627e0f3042a457313fb29a9c3376afec97181dc328a1b8bf85c3ba24a0517eabdb327a7a513795f4fa4263c57e8b871af052e0257f3b423886bea7fc963d22bf7c2bac7333946cd5a4bd0fdb7344e6acaa25430cc225bdc1f37f55f156284c536bbd50109b132f1c79c91de32df07a762685d36b7eccb2705ab3dc535cdfe1c3de63d7c9ca813e8393d1768e1c22555980cecdf0aebd83c66d0e0402c25a5e69399a0291989ea27689f116000afecbc19e308679850aeba43ec6023364b0884460c4997855df0fee3aa6eb39b21e7b8dd37076ca30cba2992abb1f8b11a0efef1b5aee7a1ff7a11563975e24f274020338755c460af169ca269048b3d228b7021f2c9894d85c287ab52aefbe3c40157b82d511c7f9a1c48232877daeb7d31b88fd01845e2d2e6e3dc9a499f283dd10eb22f8e46bd6d072a5cf1325c83e326676797462f91016a396b1771c2c3c8b4d16d6a04869357a7229ae82bdc60a9582b5530e715095ddbd662bd78cf9a62f5c1f0c66ee8b657c598deddbaabfe786db8896e657a001e5679d121049cea949d475a6adc05ff6e1ea646041f7c59486d232728a08b8eee566aa3e8d4f0023a3ef73526947918643046ebb3ff5ba974c2f6c3fc9e6efadf3b7edc8b196667cdc376a836f239dd8420a47a129f362403c1a474e45d11b665d7941d59fcdfe9d17d8a34b884bf9d9e2307cc3cd6bef00d4cf42d2ab82ab3323a282773c4a3b8ab98a0545428f91029ca7a2b205f4da254be74fed8dbaa2699d3b3fe43c86273ea26c12c18336170273e649de8db75d0521d2ff8e27ea3260f2a113bf84afc8ab6891bcc10c90b773ab65132c6b0b3cf5295651adb57b0974987e6c799832e9781b2cc1297185d272a2f4138746fd98950b8dc5a84a5ec546b7f7dd444f8ed9b36bd1b33bcc46a7604300fbc36007b9668cf3fcbdf6e82d8efcf8ad52e6ebadea59ec422295c20c5e8673a1a63de19635fe536eccf56e9e1a61e58041ffb3fe47a52033750879b383a1991dee30dfb00543d5c4728cdfe70ec463b04b07da2142ab3591ca7ce358a35fadae40368362b4b3508df47f3858c6609458ae270fd91ddd0adeae3d06b701e08a7d4c521783b60033d368c9d2a40f8bf442ed692454d41949fc208b6c97dae181c3cd14f39f455fa5057bfe6ba6f13025f45170e5d016458f4d6e80770d917553b3616b60543d128eb0dd7840b4873049e8fea20d6cf8e3cc59796ae551daf862a962ca76ac372b51384c48d8dafe28481c1f578ab462fb6060eb1c725694dc4cb2bb6c1b0e81e01caa1728dc572ca4f83b0f0e876e5613ab2604ccbdcf2013490e2c784a78d971c065da9dc33a68cf8648e63050f304d35c49a7adc65b6aefa47d385fc69f81b1ea5933665853c438b57f8ba798fb9f9e27e6575a0067c4be3db01c819f07b41bea672561e4cadbfee457e42def8d4003c9e3ff5e46104c3d3335a18eee372a2bde6337a3a9f446dbe9a263d18c5605b143ed66e3b87b61611f0cb54817f84aab31bba326c1416fd6897d3ab77c827da2b057b2374fffa66df3b82266de5ed9054b66f37d2cfce93dc57d1ca038dcc1849b88ecdcb1778da86090e95776b46d8b4da5d86d9874077576767fe18c88f9620753b1bfd11fe835bf2d440a45cdeb4ee24bd3583e9ac9385ba978649a6c7aaaf6385264357972bb7af3b6fd1d5c54b39b4500d93df28aa59f5668dda783c7011a4a9e4aee5c9265b40593141d88ae17a09df7ed690af2b927e12b52ffe9d3f41108c665b6fd33e2b8f3abd2e264d4d4b518a6c75fa1210ddd99abeb4c116785e8737e6d7d58296cc1a74ab58f81ac7da3a30a0943fac048770b07e338277bfbce786dbdc0a1ad76b82fef68fc970e7315b232b76c48cff06a0971ab5d52b37d85b019f25f15308eaacc4361323bc0cb0c2b91a2d89fff17e500ec99f2c763b12dd52e66b2abb2b9251e8aa02d75d67619dbe3c7033232e1a032fa8c4040f29399031b7efd7a51eb29b62bf02e8760bdd74628200d35ee2e38d4e8a070ec50cf5d2f5a747e6fc01fc4024c88c7cb7d2e4c48d4653fe667a0c87cd9a6ce82ef8be160e0f1c703792a342b76fbf2c1f483b56b9afacbd9ae31738a3c1ec2cca6005ac6fc994ac4486aa58476adcfbfb8116788e9dabd1a451a378398d90fb66947ee70f1dd40290548f388df9f99728adb701816a8a7ec0fe35594e1b3f426d11332fdea19d73b67858ab60418a64cb51ea2a9b792b2e6c013e4cf69f741d3e370581096f40f747bddce2378e60dcb15ae71bfd762e5b7ed3a087e6407a50a668ce88e20872f94e7e5bfa8bbb03c1337d7bae96afe16a8009fe971876a80b90fe3b7875d8fcb8759a1780b40811cb00a679a9d96a679b73b7d38090133442c9374b69c73641c8ac62bf11ec3bed797569cc6be63ff40a378423bfe0c07151aba799629be82cfb96a719336f653107e4ec7e3feb62b80b168088e68386c97531454abdef326588070820171e3ab0c94dce35e83b725c9f5eb5e76e015597ffa8885221026642fef0c2081294ad31dd568d90f570a3e0d5fe65ef384341a5988ddb46d78045ded34b5d1dcde86ca36a4750b8facd73d7318f72a03367306a9ad817e2aa6df61e1066229d50da88d5f963495abe9e53997506c2898f5f44556da18e4bc027aa6ea4f495cfe8b341b5246c0b8241def0067e0f30e7b1f3b9ef739edc14478b9254084a80fa4c662f0ca5ad0d8139db87a73987b2b739b382745fb0a50d05671c51a9e58c1441f86ee0197bd333498166b68a02faba2dbcd18426b1a4a58977f9dad8ca482baf44ef93545c3cdea95ad632d1f372ddc09ea92d6a0ac0e17cdb349023551f0b6a87e774eb12ff52cddb31653707fb8c5775249f003c2ed7c2b38c79e610748fdf3b996c5b180d50b6da944c8f3c7b56ead14fd3f75d53b5f736db270509172e9442d0a128fbe161a9aac72991408b22569d4b1773929cbe01abc3ce401cb45e765c52cb20601b2604e79355e8c60217a8fb51c4ce87ad34bf761d82a217ed5780d44420f60142e558504204e6189126d5cca24658573ee5a735e618ddaf8a22fec738f1e2a3518903266ffc8fa9a638679912ad3e94adce796da0eec96a1bc4965acdc56d2848b4d4aa70158192f8032a241d56f7a4adc6099fb7f1080de5a1903a970c5ae16c0646b6033696ac73b4a9ec90b81946f91f0b3ab8a309e72a21fb9e7613cb3df803528b5cf6a9326784734cd6e842766c0a11b30b60d831fae60d9d950ae1554923755213379033d69a1bfd5818eab29619338fd5ba4d540a9240d565bcb9c6160efa49c496ac372878b36b3e95620de30adb15769c81a7d003cd2b6358f8a8b35479a1dd7fab6365617730b384ce4d7e12098bf08d41e17829bb89b18337f5b0f112e549864b7f267fa48d8c30862d2e55dc1388c82965259e2f830352c70f4cccc961acdc787860afa60db8a4de8aac56ffbea020a01143e72744c6d36f064139abffa46fbff39da35b629dde54365a9c24587bb00790ba020c999ffbe52f5f9064f134ca8a6efb12b1f681ab8a461bd7b791fb3496bfd642a0affdee607b961611d6c4397e4e66eafe4dc9cbc0336438099e02951e8696effb6283c5011586be695e081b68ef10d35201454bedd6677cd7c822cf52884ba8d9833b9f2fd68d7b2b03c0d2453df0969ba860a1761be91f49ca69d33f470a3133e7fb2f65b65597df9bf3a82bb63ea57e66226d7e4c3d7d282939a58aa44e6ea6c2952b2d472c10f2f1e8701425aa08d57c53d00014a977f7c92e85d34a3dfd6d38837fa646e50b569a9f7b394925b8d6dd5dbd8992d1ea370a2ecebd764a87e374e84e0698e0cff3f54292084ecbc076139fc6890984402d4883fab47a85d9914a9929aa56b0c8db8fa7669e98a799bf64fd27a2dffafcb86f6d77970377314e90fecd472cc2806b68ff8b40e016586a583f795cd552d26086f41f8151012a95d56d866ece076ee39a3978f30f38794f3bf0fe0558fdb31bbf19cf598ebf33cae0529c52ba1a6e4c2dafdb5127fe99a8823b8a8e1f4693771385886e1b97c47fb509a94104cd1f09481d2f85c946b3b9cac224941841e0ca899a07b3ccb64e82742867d4c6dc0865819e11d37f8e0c99a0b81d139e9850fb71967598ba48f6e8a22b668f1ea6ef70f2c33d0d3e77c6985ae117a6b0d3cc399110522d1547e72a1058a0bb71130489481064eb12f1b26b16525c476f65f19d32db9899a1d0b4bc098c79a102f7e6d943f7f771f768b4e0ad7e36c9864072148f367f26970a1049c0e8a2c19b3fb13e76fffd61d53854533a36240ccc9405cf1ada0463044682227f66a150803bb94199899e763b6332e8e248e139435e9c2d3b1459a25051e532d2297a6ca45b21c4ef4b7c89ae23c333cf03c2d19b04c0b44b250e56f25847c3ef244e5bb3c6283d7e468efa4de4d93c434163244de2a22a5515d9cd6a319615ab38493b9bf447b799abefbac7621d98b316ed865a7f9aaba833255fea292469f7b5a5f1e1f0bd0c06b2420fbf6c76dba640a25056bad0fac308546c011c3108aba3583c0b313baf381c15b66565f713d4fcd6312b5491001483b4587cbc4967fecca0e4585ed937fa2def7595142f738bc1c5903bc7a495e9d1e243874f5b43089085468b2c22f5c105ad92664733555d5b89e3db2f4a45bcbf246cbaeab42fb6f5f608c8fd8c945660febe1c3ac5ecbbb7de9890cac595484164f33aef962b2fadbdd6fc7a8929a1cbc82a1aa737d97cb297ab4301657b72866a5aeee0e3aa65d0c7f5df98bad973e351995d1677f1554b219202a7a36f320ec08975008c3cb484d1d6cb2a632d902de8cc033015e850421e734c8ec35242e442fa23faafd85b9a787031ea261b771712331413b7d80824270171ca4a0d43dc7ef0f216931b94f6e859678ed7cbdd413986726a83a8410a6710680c1e100e5372df8baff1f27dc9f9672a80862efda61e9b1b97985496318c3843a4f8bacf7db8de7f5442cafb8784ab7013f8d7cbd1a74f09ab9fc67be72fc0d16e48f62472a23799050728bcfd3f7dd19ff0d7ad87501812be860bda4f7fa52429da2c621b72dba2c6db516e32448f0ac6e49733a561a67905d42e562d0683c5f1e6d7cbb1726cb7e74ece32f563529ae842cbc551d721f1311e5317513e65f9bdac97895e0398a366888da130c73aac8015ca0aa8707fb092e25af11a0ccec8a34c143ac3b608ba7e258ca9b7975e953bfa0355509ddba99cc952886be75bf9e67ea8b01de85cf567031c2db80303115218d587bf41adec602e1a79067d4ca46fc1243186eadb19222f68e46541653a59649dda0c8ec8c5242dd8c368816b98882155a6e7aff8ee8da9b8e40dbe1f40821e9ba6518e4600107151249a2747f4f83adcfa49e871833c8720dcb3e7d6340463eef274999ea92483ed4e8ec967207f52f51839a28d6e1cafa284ae86d6d09e570ed5bc9f5ea506df0e35eccc6a7f6e2e5899fdf08e3602b743d1abb3638dd2e6b3237ee0b4c837628dc6f6362f2ca2ecf1c70a9c1607fe1daf6528df9f26e6f28769ede4a160ef0fc224299e45d529cfc95d047b8106424e539e7451a70dfaa7e62c4f324fe0ced99af8f078a17c47ce7dfffff8b2a31fb5d61fb76e522edabae02aa16676c9cdcbb1ea2d499ad7713c7f9cff86901ec59f02af9fc67bfa03889c6e18dbe11aeb38ef38dfe1110b0cd77816377721061cb8ba03ee64f32eeaa983e541ad6240e609176e248d7a11b8388b093d7d798819336c2913560487bc302cae136af29c0ee69ae1510a82aade496ed928d63bea62620f9c17b09f68a6dcc2f880b486a8cabac74c12e73ec9797650ac0c8c27d7123a3eb91ae29756f5098ebb3bd7e067ea012b151eb973915d436f40c286247db92d1f305efcdac130e7c8050c8219f9cd35a3d5643ac89fa11baa8a2a40f98d22603a7f5e8d5090fe6730e0341de717aa52c3a1ac996a841a114f6ddb4950099487af4b3e43a7de97252d3380eb4e65df97f63eb5539b62288ae7434c043863b1dbeb0cd7c67a69b43976e40832aadd7e82ad67b554e9892f2891cc04345b46846c37f0ffad6ca324385593ab2e36e3a06b5c8acfe029d20c588ddac8aabf0a8bf80c060a05062633b5456912debf74cb3d13825f2043abdcb7fd15de5b531d2b69b6a9f072f9e62fecc62f56d21413a7dda7cdd38e80853ce96f5510871307c8e988a67db33d49369e084ca9dfe2501d06ef1a332af3ca576695084c5ed3cb708178894a25505910b2c5da88dea316d9859a0f41ebefcc280938e1f27e8630fefc4852e73e2a8aa7c94ebf813c4e1b8d234904234e561c567e5c700068384578a654eebc0b0a96ed5d0fbbfbe3719b89990056c5c2e386f45fe7f5a267e9b786c2b7184fdb83aa157ab931f9dfe03be29b35f9e0e47bfc8251072627f6496aa4500b34219318ed276935e583afae43cbaff516858e7d6759ab7eb406101f521549c21782a88ab979450f55e64998cfe13610529677f71ed551ea550be3cd8926deb99ff478b0d82230809a4825837820964d914c3e16af5ffc9ddcd18f886c2fc3b425e313bb0b562929adb8321ba5edbee74ad28740e9e1a923ab2a1113734ee653680c87af9b437967dca1cfb67585b08b744af10b632a039e2c8a5d0b74da2a7aede7b1ae5632a0864e96a45ffe1c2fc61b62a658b002321d681f6257be8b9e78cb474746e2238a81f4a866c28239d6953b348ffa55ab30323950b9de6b1ec387b2c7182235ebe175b9d351eee1cadfc678e6be9f0b97040525a0f9eeba10363a7808dc944849e66d7664047db366d7483afc30ed3811882d1a78245487cb8cbf37d6e485e8d502ab90a4d3affc53975fd26320a85332789a3b5011338925b2ebb88c0be798535604bcdc77b1b2fa035915c8537d50b70034948dd49cdce42a46975515a7af4e11429bb4d6c88382eaf79ef386e3e1107836b104106bfdd4e6589a6ee196e6bf2e812b215f156344f593ef92ce534c852c706d50c19d4643c81bbd49078ac77271a2e3e597c547a64ac543b8ceabfeb548b139d9f11a3024db9f3846e55f604ff57a30c0d6ed47a43d4d74a68ba9c57592d9b376e73f883ccc603df4b92c65eff9758bac4ec6796eaa99099722fcf57ebd3c6fb02ffe987a4d0c489e784dc6a4e10d90c09e7287bcf3fcf86818bd5c184b1c4dc085987151193b9f14295379a5aabc9be6102cb82984d3325816f572ce57c6ca61753140b13dd382733c19a80ab7cd5de25a01c3074d68ec7bffb8e82384c1ffdbf1498be251fe70ba5e3e0620424b75fef583a02d921c1d7beac08e0ac69d13ba3bd4d28298f8826652de6eeb4db510efd9741733414db0672456e9cbdc72f95a4504691c25bdc5350718742c5ea5a2a51cc9cbb194b40028ee6675897a3accfc54a600e784417c217be24ae7aae5939d0c94ff1cdaac005ff89d73b8837030b40782c92d8ad9facbff5c7dce4e1a76fb6daf2fcef44a47ede4da82262f6a482b3bbfeeb9adb517bf3aed307a43a414fb31181440f8b37f9dfaf433313a2c76ce057ac81dbf45d8af2a9d551da169c83b8e442c8f79efdb0cf88c8c2984df737e020331aeef239edf2a1672882dd7940a572157e4b3f551eb3deaf5ff05d099b3e7ac77f3015b078e956b76cdfdcdfbfc148c7c6374b6b6a77f5bc054053460d932d8353079191a3a38fe9fa63e191594bd607d9ff64dd9e462f851a69758ed7e4c327f06c483350c601022e1c2cfcee50fd1556dacb6b832287cf8c44eddaad8953d0d75af5549dba218cf8cfaa53b7af1c6ecb418ecd3060ed8e399bd694a65b42a58c3dd79edd86326af4f02dd4dbf883d1bf978d2e42fa42536248692b008c7ce716cf904f03b38ed39ef23e96a0a7db056ab812e7fddcff24f1f9b355a3023774304eb5666bfed73a32443b6cf14739d313d1c362e30bba3b0450393f3383de3c05ecbd2493697c01bbb4c49f6db4c9760f4e7f90fa45a029af35b52f8926b59b5e4ee9a72517ca0fca585f8b14df38ab45652fc9ac34416293a80ed0feeb158fdf0fd64b1cf43ee0ad12a6b3abdbe1c2b1da9830af18751518e0c9016d5c7a1d6fdac4336bec670ac7146561bdb024e18b05b3be1679066523a69c314f7e89900629c3acc3fff79af6560a63c5f1e56efe94970ae867c55fafd1f10420f10804e380cad2f88ff444b25215d9de036f10b37ad560a610e8a89e1cc6861b017fdb781971c609ae7af74f8d04c7c54120ee7174a600ab415c2850b99a27c70808224d73f0d432305b41370c54ecefe2541c9c9099b291a83cb777f420a0fb84127dde3dcdec88ec02faf48282c7ef4f3f371dae29f39b3e6372059582088cdbacdd4c19512beb76f94b48686221bee1c13308fc6634cff434dee808144f9307b369b6198395efa0ed5184115b8943a05d31fce11466f1ac1f025d1d5321bbc419cefef2e73a614289b4e4ff18f9f009172766070c7348f5466e67badedbab2fa2112ec643617ba51d6a2bdbceabeb474cb9edbe00291202aed85d5d16ecb35a6e00fdb93d6931583ab51ec703401476a1ef004e9c1448e4ed22f814e8d1c2b75c34c337c63d3167f99bba231bee55517980b585389d2c36ffcf7bbd04160bf6ec07dd1da7e924b99716804f2fadaf1b6e9248d878b8334338ae36981a2446a1945887d9eb85f13a486c38fe5018fc4980e83ccfba74800b5ede326de2ebfb6033c430cd3b2676ed9fe060931feafef73b25993999610d421ef1bb37b09f5fcbd7c1ede7011e9b115411e68867af985f6014e776c3762fa9997712e0ea929d6b7f5cca2f34ac4ecf5384af4fde0a951522e73b21ef99397c37c2665492cde937b99139a5f2287766aab5ec6d58c290d3976e501dbbeef83e964a929f4389d7943e3674fead932ea0e690e908dd2bf24765f7967d7eea8573f4715ff24dc1844a82329f222e45d9ff8b81f44d47d16949de0b28c8dc1872a2875cc76ee24e74bbab09c834dbf0fdd2522fa903f420cd6cfc4fb3073fae6ec8c389898ab0dc09db3dde8041794b428b9bcbaf47532a912179cbc0ea76b5f63ae172160209012818c90d94f2b6de181ad5064cb6e14955ebb526260159d9c6ced156f4f7a7b9da7240930d45c88d07e77ad80be4d19316055a6712532a72217fbd8c343df77db53aa381430cc54d47da47b8b983a55aa13ac08fd32de24c44107efef75e7c7769aa4bf0b06b3d50b417986bf03f34a6c2b68039790f769b3c8677eeaefba8d0e01989af5cf068d03587ffe238015f6396ef3ed892bb230d58657dbbe64871a3056ae5669ca96bc107945f8f6fe1161a97bfe27d7c20e6985fe664cc25a388f006a8f27b6a83aa339e18ef5e7776b24adefdd955aba76b90c76324d44e9ce4348c184f286d782c35feb0a16e1a4230fcea0133f8013f0bdb03a41f855b441b22443f099dea28fec2369ee160c924d7dfeba7b88f7764ce17d9e57ef7dda4994ed2746737fa84da99e3b953441071b94fe0411a57b9adf7a523d0a3de772401075e4aefcf672874ffa4fd52ada03975542214449c52aabe9d79ee974c31cb446b577c64fea149abf78c093f4a179de9b9c8eefca6f42abae8ce1808ca57ff412ef24b881950a8bf23d55ba5016fabeededa5ed1de187560c8bc3e5826f748507d5e7fdeaf56902ce032a98e2479f408dea8c6bbe7bbeaba4ed26a3a3a9a530c41f07eee1a091d5e75c82828c32f0946791816085d4a0a9bb375b48e013c7df45a08844ab48120d92aa60716debb0d53510de55bfd0ee2a920d98490c6a8a6498b0acd9a237d79bdcc391e8d6a3a0817e856c29c37620a2e92e202abf59409fbb9a4ed71e22992eea27cc922c0ea2a45602008caaba69377a95f557319b712dea7d2a7c435cb6221dffe349f0312233c6663f2e57413231f8598771d934bf753e9f1f88280ea6132f2a6a4e296b82f576bbf3fd1069a574fb39071c9fdc18047148605000c3c2caf2378f51f25bc1e188ab55f5b93e194721c41ae8a572e766647cadae21b9c4b601d74bd91132b8a6cb966bd81ef99f47aeb6c0eedd5b4c611085ae86da3f3d92a453de2c3b19ef9d25999cbc925792fe315ca0b9a0fc7361a8c3d19e9e015de9ef14de1b841f2c926b7f5fe00ed0daed2f7cc4c77203737c38729ab49e4c6f8cd1063256b1fcdb2d51a3cd691f73a61ce5938fb6f92f31c201cdd515b92f00cc30624068703e9b19733d4e04cb91181f3a3dcc90b59f01f48b3bf96ba915f900486015312a200839314983f4b5ccef4f09aea825afe17f3d1fad01488a6c756670947216188d01ddf7ff51ccae92cc98e57acda8dc1250906fe71e7f9ec4a0ae7daf61732e21ba7fad98b2bc639e00ecde9ef0ef9ce0917a03fa8ddf7d9490241f965578919b19e0f5322aa080622483007ab26684724db0dac87e917e33ed849b023c6fb159da18c440fb992c68f348c05ff69a9a44905302677b516d228ee07f3e8c98f7d6a5cb3bc42ad524b0aa52293c2d23e6ec42b26cb9fa1d468ca281e51637020e8793af58612440f161f29fc3be5bc22d9ab78d58ffe057597b5b8f7a00616e33ec157d285d047e34f3e3c497f78e508715d04bf3a336f919e9e4f7e2ceda395dc3b4aa7b7bb637f512739648e60f591e8f0b099225d59e676c795abfd5dbd4e5ce6de5b689ca2c1be26b109b3a2583a2af590ae2e9ce8923f1bcfacf4de8891a515b93cc16bc8a7f6400ae4f525633d13802c81f9dd509b3362491ff1ad156cdde856a6ac8f63a4a652e44286886f046f0f3099b8183f1df2a26f552f90bc55c89f71094028be25ebe1c72de951bcab39180372f0aa0a7ce255647fc83b4ada27f76d84917dfd555e14272012b4fb672d7b8c1787da74bdc898007ccaba23b8643941545f07a7eef2064325a650e90b2ea7c034471b4a3369c1811c8acb6a4de4f8bbe66a5f5a3d936b05c1b8359e753fe3a329fdf2e80a8da264b202758478cc6d137645cfb3c939a2fbc514f0af035c27a855dd67008b890813c27c716a903d20ce935a32ce407e3e85d01ec3c5c1bd48aeab3d0102ba3fdae328a1a1efa134ecf4bd2f9badb433c0fe270a2aa97650e05011529e2fde0e2324ea703ebac38c2c38d85142beb17b11373acd8969514973f1fe758e6575fd6e27064ddd3454667a8c1220bbd46c0100e65c82b75f07077ddbd6ffbe4d0695ebfa0ddaa95e5aef653caa60eda715c07e25ba141a7fafaec183b802487b1a68e12463375ff1b088828da0b2a591e29f1a3cd70ab9928d8ae71149030042d1169d539428fd4a965d98b2fccc5dd379e63f2288e3031a9c514ffc7d6b3be2ef6983f8f6fecb30ef1de858f55479b4c9a857bbba37c04b02b650638bfdff59eef3d8c9fc19195de97335d9d63a0c64c2fc7783ea72e0f95bb650572696f9651cd2e6e83ce2994e1221229ad0ea65b3c92ce51798ae897506c83efd11bf3ee9d6be87f4028a9ee39ac846fe07859fa83bb5407b7a1498e732cb62cff61787bed0e0a6d359580e1c9baa7ba4647ff792d72fba02c0d8bd635d71dff61367f4475e484c89916c6e54df014aa8f5295281fd2810a5cbb756636e44b99c34e83ada6c099f2705ee569784727a76cc13b0c47680cd06b29737c84127ec3e30e8a0a4cd2206b66817c592c802646382a00506c584e9a848381dddbc580120d29c6a6d636a8d31f99826a63dc07577d374a64ca5364774442cdeae43630fa7a995893af22a5d6eb8b5a0e4632bfe0b21ba4a07fec6212eaf98e62c8fe0473bf44a256638465b0c2ec64cd1c3b6d39a16f3657aea8dda7c5730d55a24c71ae3699ff43ac94f283148fb55c6ea7e41a4bcc6a9f58239998c99b1ab122cd133fa59c9d63e4af5e79c3f8c5a36a740f5a73f5660c56f2ab260634ff3f029385ad116bd17164cc777e769c44c8ff66a12224701d6857e6686a92ab37760fc4a37e68ccfe3f41241f82c2c94ae3d5e404a6dc549b992d83f605b7a04c7459c8262887690070cd9c0c4bd5e01c81b79ef38bd5d78a55f85177d6477484ff736adb3582ca27300585b7a0ee72c7b638b40fe9c15ba6a2b29834eb47c0f0336df857898e8127d921ab948abf6eb121d76c3a87d0ddca7ade955b0dfcfdc12f01ea2006c73900150459963f4b7915b256df1208649c65636c1f6e5d341c3820ccaeba494a00404dcda59749caa5556c682c964f4c790fd561803769edaafcd824019d220f46e56265005e5714f22da62b5b834a395920fc5873ed2540b86022553e126512db6b6e64e9e892819f7cde26cf37df9f642c9ffd15ba73be8bd4a883f71bef27796f1bde295e561688be9f147c0f9e96983a75341bf49408f94becbaf7452","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
