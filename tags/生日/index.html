<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02c4c2d5a1a5d2dc6f25a63a55047b8a4af9aef2d3c9ff044b6229ef61fbb9231a7f80b421fdd4e21e245ced7d133033e16bfa457b7e40078244f821692991bc1924bb13af42f3174a0c8a5e4521a3dc4a39c3601df9f68c45b662eb0226fd267ec1f23973b4ae4ee5ada0faeb41a5e9170d43c3c4fe4b1c58dcd8002461bfa3e4fa411c1ad77d1d0f03739212dee19c0714f4058ac297d34bb5ccaa5cbab64da1d149f8714d1e14bab7b89186a9e47747f615a0374eeb98d20823a5fc1cdba8d5a13f5f5faa630d5cfea150b54b9d7382e0014676e8047f0b983728d56413714d341354d6a61926d5e007359ea47bf4b8e5f1ab4a874aa10d7ad939e213152f37287efaf213b5167d13e4e5d2c460084b6c7d6c30f0e72eafb1602005563c025f8b8ec028fd65b3a6d30e824d7d52f2423a448f8545884f6bd3df46a4bc775b6fe83cfd643e34e8eb0e03c663642a9e042b39697c1d7e9b428782631ca8df4399657b122f6fb38fbaa67913ffa0e0df200f3a994989def79b0285388f632946f6523ebe12421033776d4ecfd6e1fd012d54bff1fcc3c745efcc4e96e3ec377920b072e243c02b305d710c6725c88de9095f1fa59a3a0399aa8eaf8312ddede0175e57c7ca5537a2776c1c53b7e0fd8984011c8e56becb9bf0bc0691a669b03fc63b8d8a40b67855621fb609e293d2bb32684d96851c9d596401b3f05c294027a460b9b732729e15b0e89f541be50cca4ac4a67c3bcb7f0db54d862fa6087e58d8b331ce50041f6207bbed80f58bd506b1ae79d68f3704b440dd8ed60e29a69d74bd663a3e4ed081a4a04f185acaf2a653ff2678a05d21f8653bd072995fe82a6d8a0ebb33bd9fc8b3d09ae27dc7a66c3f7fd6943aaa34caf293667c35097cdd8895e48912086889d680918007335563689234bdf0852a2635ec58e8749408e6e79b1b71a3a80243cc249e354b97891ab6d28353c21b77a47cd670595319bcfc08693be2205662b72f51c3f47e98d29c3d2fc90e7966ff363f343c5c2feadd345ecd085ee1a02e84231bc0fa14c9195b9c520c8e989c4f670007b84c4d2f401d5bb994d6aa0f5ca88a29590d639b13b9a20c52abce3b24ad419a0be855d52f21b07bfbb3d92700b9f98d4221362bdcf5c519743401b566a34a0550f596f279ae288585c957243c020903087fcbdacd49f5c7a8e0ede70145d08ec2e03f8c0f6dd571f794b8d95c79b11920dbd47dd27e818a7f911ed785780910976b21f596a9d7f903e7f91ee12967e4cafc9309fd57b4765a9fec6f6bca72f3904dc0dc516668ae2ff670e7e16f1458f08820dd8128ef191d5871808408fbaa1f928cec2d7581a79a52a0c05a6de53c9c95e080dc3bcef2a14d64dbb20d7f494c0424ed6f6ce982cade8d2bfe580d3b12684cda5069cfe440943436213cb028e8643f7daea6bc0633f0146b29275cbf3a51919116d77269528f628ea099996490c36c9e96ddfc966ea6fd9b14ae5c80850d962e57f221c419121e46e85f1351a8cd2b9bccaafdaf40a90debc37caac83e4dc52285d906851dab90a8ccb05d2fc7a5cd319e913b14ccd53d500db043915b5048b0907dafb29fdacbf28c4707c9f3881a004fbb93e646c2e1ca95edb6959246d9f717457eb6c9b36744856fcff6e7bbccda3b87ea28fdab1a09e98f5686c753784accefa405a6cc71e82f775e9c3b1e7dbacae5250a3b099dda53417e4341647d0cf47970e10326cafe3f00470ebfec5e0c9d27e1be772cc3a5762f197b315c6c215ca032606f750b517abe996c1f77378bad3a580a687bd18507caa52e719ab1f71c5a78338c47f48a6594deef29ba1a2493edb3a9962201fe8d3632a74b02418c2d4fd398749f6c66531e52b9ba0d6a7e67395766edabd829d687523ef34c2d8cf3d8cdfa1a09617d7d69af23aa3cae41339053cf0363aef1f89db6ab8dea4ba80a7928fdbe8932003e02656eb36d2691aa6db1594c78545a700b9b9f6e4e3b47369632d9c4ed3d4620384bca84273974488986ef94974c8d782a8f6c5552c11931de705a5a72fb43faefe754c699a6fc239504ebb55ce375632a6b1e6f650f0b4629edf4450d1d1d5503cfadf4bf453fc732fd60d55d8c5679fff26d8055715445c26b263def8693253e41134312c18bd5454e6152307e5465f21910c6d9a2cf57ba723cf7409fbc5ab07ab1132c39a7d72bf5fa396ab9e8ae7514642bf9e4f328dab0355261928a28bbda0f86c69e9e66daccc0de0bb5f7b689ba2b099cbc89dab5f157802f494a147d65f8151579be446b85af8b5c1fe22a52f72f7f9939c1359d14663b775432d3a5b656acf6d9ad34991c192c9b5594ff650174a7ef940fde35e60b9afacd8c47811c0ef60f88a87dbcd452b872971e5cc501d45c690dd8987c52d0272ab0812f1cc11dcb22e84fdb2c47ed61d9b9b9c10ae05445b601d306bfd083bfeb448f0d2cc3384898b268474caeb33276e4b74b1d32ed9f0f76a9a3c9837ea2cb378177f65efafe0ef09d64fa03b05f8d6260f179179b61e5f343e6e8c850ac2d6b680b082e936209b205ad81cdbc1480de5761b73562914f5d627ef2d56e8d6d4327bbd30856e8182ac729a2919f01e720d853f2f2dd8bd76a2a99c0aab26ff39cd21101cda40f4dc22e7c612bb8fc43c88dc616d3f44540a1458fac79ca0cacebf11b3e193e52a9b22168cb01780bb235aa5ab551102298110ab9f0a7e87314621569d1fe59c3764d764ce864d57d684fd49f171e8b86e2a2ae1aa96e1cbcfaeb85bf06fee5d3f64ec0f3fae8caef4c2f6b10b8b9607f6285f4976466d3d73a74e2b3021af7f9cb84d8b50b7368ac0985de9f29839d4ffc3bb06ac190205d03010795a9e1a4c204be2e4048aa6c041350d6981fd19c747ce5245c3e535208fce64a29b2d6dba9e747a4d3925688ec3308e57e021a3161cd41e35a2d168b6d7b394024dea6e8fc72a18952dabc0f5357ab1449ed7e850c5a7fbb1e420d0d60f70db24644bf96a4977a13b9f8f43a28926c85dee084765110ad768f9e7d57f0ae8765ab99e64e2ae9d9148205eafb9363fffe6fafc09a98916aa1115ff0db5b0e92133404e1daf3d7f36df8f4eaf94c27b0cfe1014f4d83123a11ff2622b1d8cd4c88c5f0f601ebee82253dd424c9b4116ad14c3c99771d810173aaac771d9afce546a44e2f2d22eee5cf07603a1c2f82231ba99b6c416051106319d9a02fe7612d23512eec9242f13a9e7d0250473f50f36be12db923b2afd6d40400309c03cf6e283abdbd2955cf47e19bacf17ea81663d4ee7eac48ef03107cde688ed07e90424c05fb826c0e24bcb6de5c21be756d6f001e56fe119526732ca0d91d7c61d99b6d8ad4d7f91af9ee5098287473c2b33a9aaeffaf875dabaa2b3c8e993a5da81591892b8aea8eeafeebd12174d917ecb6527f9f38a58711d6d9bec06d35dda5bff301730b6949741104b3e296608153600408a10ecfb93a885d79c0bab1ac28b89885212fadbf2a60f0672d89b2b98b4d4c9f454b5f112711518686b430d14c949f4c9df653212054a61c3bad90e4bfd449d51942b7109bd34c14c5f6ef8df33b6486e7580e04e365dad26789e37ba06541d3910ca4a996a3145c036a975d13b2cad1610e07c24bdbeed3a0fd220885fb98f50f4c3d0a57077aa5080e2b0ecf4668d434fc18efd4a14fe1cea0b0deec4e4b87e64d38624b7045d5c5ce5325f4f4f10339570d9ffb3be81342fb3b71a570101964e3e7434348de2adc43998faa56732ddfef5c055057948dc5ad83811e71c11141ea1b2cfd2f0cfa67203cc2f63b86daf529aa6271c1a1b60c07533c176ad3912a33104b6a5eb4ea85d525f421d8c97696374924bd73fc14c499c5f738dc6eba3b81659adf19c8ded5a7379129965da0d92d1195963b1b9057bda4330c801a0a2243247ae8f8ba6e0ccf96d1f4cde979378c6633197c252287c6f97dd3933fc8e1d55ae326a0e7a58c5dc6189babc90238ac69a8e37fa6ea675fa6eb0ed83bb9d1ea0da0d7dc56775c0c33c4f1b7a57842c785209a8bd421a6fac68b043e3478077ee28068ccf17839f0ca0463540b2eaa50081deeb709c709a736a86a990797e66f2102c7385360169dd1697b3bec025412a1e41a68ae665e01aa21f04761eb2ee95ada1b721c4f6635e6908ff19cace4466eed9f1fccbb896613aa282a9d16913cfb6d521d2ce9e67e8694fee8466d1505d1577b8a7bc46d3565ca832ae28d2e1a4fcb742a92ab8051956b44b1259f9d9f8e52a3d00335be82293460e7e7292c792e9eb8c66d288e0e4d7465de87fe4f91801da8d19cb70180d9167c4867d64c08b162f5749c15c4c52faa58f17e296edbd1f7b4fa502d326f83994bda22f18a182ea0e7fef9ca3ee2e2c762fcc8d9e89383b75966b32c3c3569e0ede47768cd90a6dff11154b2cfd08acb6a63e7e798a4e3249750f27c87bd918bc62022c117da669e397d60049a7233657bc46f152459f595cebccc148583a1cc1d0e4bd32f80080aa20e498b6d5de360d32e9ef8fb59d3437a499d3b3412039848f8dc6429bef270af32e0d704606e1e31fbfd3fc5fdfaa7abeb0d1e771304c6e253f69bcba6fd62f02e03efd1a47fc2f58f99f0fc7ae2fb73622fc14264f29e7ad9a5972e3c3d3c5c922f48180d7c9be6d5930f7e9451f3ca0f8845744bd44b94dbb39054705e80ce14006e440da2b1c469ab01a6455301863144e521dfa7f7c42a6f02cf9d1832ebbd70db348c971c7bb9467dd4009c86d970c24cc3d7a3e87adc7220adcae0c36a328caafbaaf9545dd895dbfd455c27eccd43b522580b5ab5bce0cce00b31d429c411e4ea17be7234aae2eff9487df77299e10ba5a8aff98f65150d8172a415e8172c6e42b82f6ffae0896dfe1ac2423c655f016e2773e27021807cf9eabd8d0682ee720a87b44bcb0dbf8a1c9766b882453d22b735484d030c6c9692960ef8ebd480013371b9e0997c832d58c5f472fbaf5b79c971a45581779818436c7f1d0536d309dbbca6babccb64859c27e9714d86baf8bfaaa7f18d706082fa36003abaccf14d48788dae3afdcb3bb5a78be8bc5420aedeed9a15660b54e7bc5c1f922ba10c09318f79a4253055ac95acc05a4fed5cefcb326b2cd72f443c66302815f2be4114a24792e65562c61f65d93f9f518ac618f351d54187e18385beab0a09cf525151f89fa43ce2f511535492c70b97fddfe9d04000c0dc9ba95b36cd7e01d7a9ce7556a6d7e80c9c57a36651e3a3610e337909cabb54529fda615e26a1a487e18c01485695b750816b1420e99b1424c9c8bbabbebb50467e2c3dcffc71799d788c425c7d8ccf2d421af93a5ea8941860b8782853b04817ad553f04aa41d25f7da0f9798d70667351e2e95bd6ba87f20a1b1e315be21d8a5b68786ba2ffb53219027113a96f6d3d02a040a7b5cbf9accf768b284bed13172e877cdb0b0868d61a5879facfd3f4ac473a8af5f2ee625475e312b2622e7e37eb95f990f5a8ad4c291ebe1d32ee0901d144e68400a103c8aea6627ed9f644cc72fc818c82485eeb797248a50ef796bbd32c125779f15dfff9ecf6da1cd5c8deb1c62de707e4262621283b3f7d3b68a389315c998d9ae178fa3294e4418fb77d0834aa6fed2efcbcd443b9c424e568758734d7ec0fd848da42143765d65ac278591e87cc239e92b11390bd56beaf2a7e053ce428e7d5137290ee799ae9612be5d3b78f85307dbb28a8ceffb0a56cb8c79cfafe6ef6ef03d09d4f52b302105667f2d46071129696b139a79a48e77c900f264c040b6977c90c6b606867ea7987f803ea18ab02b2c56e6465f5bdc98f4d6d8df80935bb6029f00c97fff9930ba7c4ca2b61db6292dad5d8e8e16538fc6c490dba4ca63bb50bea034d97b9854ebd40772771f80ed7df59ef69759f40fba4a491e6c90aeb331e216f9c086b2dc61c6b8239c9f6732d2e2f7650c486b5649658a8a4c26c0d87de586a144ec9531ba01b985651715ffac75fb5cd93e33b8287d76aa9942633582021466b693d18fb47a203d0e8087aa9353eea96ddd43f9abb2b119d33e353b20611f2b5f7f794a0a2d6abb5c3a084387d48c24fd64011380e3cfa58cec960cdaa496fa5bcd7aeb60d9b3313a510d14a72cd2db0b78cf6274219faa7425e5399481df6796dd8cb82e7ca8158dfe1a2368ae256fe065ebecaa04e1b512fff0dbdc884e9ac665b0d1b52973816706da18f604aca8be64dcf3f47a97c1998d6b71d0e8b587108a36e3b09be9f026d2f54173f7be78be666c2d62f78da6250f6ba344258955ee18a30009cd2d45c0fbd579642c9a80faf4239a7a33155ebf2dca25ae6643e7f09f844dd7dea481226ad6af4846ff320cb757cd5ea6ef84af236b29f80a0bb56f3c8c9f7d9dfc52e918eed5b211241387628c935b48bccf62bfbad13edf7ef7e0d5a5274e95aca209d3bc64ca8e49b9d2a7261ffb1e83a7917e89e283efdd841419703a857579a2e40a94f75860fcf37b09d8f231d45ab6c31007d3cf2735f5c336915be1cb1b3bb43ba8e31237b3286984cf8f2a67a8fb40c13212d78d86eece38c5801bfea7d4768cc831f76310f67ee6fb7961caf4ec134162944166646fb13686a985f8ee90cae119aa0f3e738cd99147957ed31ea699bdf0bec0cbc6747f7b83d135b0dbb672f6313aabff9db1ae8b6bcfec95f2819fc405996681831dd03a9a240a9f592d7d9e2a5b1172aefd61b257f0842a83b4e4d2422fca5c035c44bc74f77d2b04794b6fbc6aabdb86e4ce1564980f6a4618ab890f58b9cd0a0ca423b2eefe9817d8fddbf53532e1833b8cd28f83ca8a9e7b0e5c4b2a0ea597ca7b25411d4c50b77ff4c343a08b73a1969c3f66cf9ed1235f21a30e397ba220c3524f10f9f46b90761431611c3632ecda103a1d4bc3d63cc7be4195628caebdd9cc85f06fe5f0b9cdaae2d3130fcc03ba7d43a86dcf196094368285d430df29aca737e20e1fc9829396619d7f9933b0fa8885fbb0ab95f1f39496c434f1fa15bf3ddaf99a3d2c6d55ec58e2bde47d1a74ae82d31e9c9e640b8597cfa64d3ffc02d760085da71662ead57c857eb29160a19810dd9c33a160c19aec38ae42f326a226a3b2662396f84983c7cef3815aa646de6a98a988f3bc19a56523f2f9be07bc72d690f683f04d7eff97788f2a26f718592bd10a5c0353ec0e39c7143a112db41a420ce209c713f866e442ebf1f721bf6a30f4a1995d71ef11b77bea5bea881c7adbd3b4f724bdfbcf959b0883f69607f1190104364e55014f44dc96462c8e7eb5816518e531184fec484b78b140e04ff68af17dbc5c970c268c46cb2c82ddd7d3f8db333c2f0de794dafcdc07211f7fc4b093a2fcfb7e52510033e34ce93ac448a0b827952a629575e24c02074751e7cf26bda31192d9e6186760bd5d806278ad237331b5efc0990f4ca1aa99701b0d6a54584e0a8b1c3a18574d38daa11bd7d4194cbaaa1e5a56d1e49c1eccb914cd8845d003e9335d4a14f92173bef127699b1094499a53f13cdac5cd2962ea0ef740c4abf3182e4ab93f3e98f2f0fb394b4a79c7e42e7b9c8a355a6295b46a1d0c66eeeebd0fc5d4bd23c540715b323c7c6814554ed287ce045a58b57ae36f41cb03ed830ad78eeba3d4a30fe997ca2b3b56b7abfcaa66c1e3c27eb493bb16240053bc0f5b42999507597e103e9ca90b3d60f1c2e4edbe8706f132b9af33aaf9b39a44bd601f8f17ebf5a503447e5408938771b5bba5ec8c1b075296acd471101cd69d55a39b34e5f9f123b2824e74951f7c36e2ac25e323f2e2ef474c552f356f2b96592f2cfbbde17cc69cccbb03cf02c16fa4753b01ce8e860beacecef5572b070c342edeb5034fc67ad9b76da5083d515cf43fbe694b3333fb7fa4e9fe84da30f577c2930badd3be5efd35ef45f0638136e7738b67f8698c40d7e8774acd776e27937dabc356c87af198ea8edd6f20fab6ec39436a0e95373351cca4c2a7e1c748128278ffd3cf6fe891e7f02d73617a5b5c6e21fd21c197bcc76c5cd28de267f82ba4a785cc7e633eee164e44eeabe41cf68e990319cd14abf1c3cb848c76c0e4a948343bee79c46a75102663abfb2252e1fc79ea7f418ebd887bb5c1531913e9635ddfc28b40b675a032b27d358f5b5080230a60f5f33d9321bfefd52171218abbb71fbdfca21650190b91d0ab0b5a39a803da34d7a14e7ec2cc5a6607fbc259201950829cd5e66a1c2b53c40e09d448409af4bcb91f0b5ee4017efeaaa547a1c9dc8fc51fd83b40bed03aaf2344da8d785e01ec3579b9cbbadcc5f4e465c173c6df7d0e16ed81407338f4eb7b9984a6d048ff85388084672339dbe0a28a5024ec7c7e2a6b3552b041a49105a1c27ba28a868e6dbb89e56ac13df5d82c21f35d4432605651976f8193b486bb71e38e8fe12efb924be4c4bd5c18f556855ba1fca2c31e05c5fd7b6507cdecb82f8e8949028a1d85eb9610167cac06984d1472fb58a7983751a74be07092b75e964dfc9b00d9c06f0e7bb9e6bb02660ca3b6fca60de0c3dc4f42da51c859f7c32b8e3e80e08f39fa0016b217715fd5b2fc5624ad7508d434daa5fe8d2ca7e08f93a6b0ab431af1fecc925d2ccaac7e2005b8b9cd31569baeb7eb698067bb22f7261bebe0dcea6550b942f12353b51094104431ff54f000a073afd40ba411bc13e503b84444341854977813894a67405c23954ff62d067b1f4e72daacf815e5acd06df88104792006d568c73b65f08d240745507f47068b914eb8a1ef9a3acaddcc7c4839786f1850b5ab1b725c3fe923e4f40c6e67889475f9ef3843c2adeacf7c60bb16d9004933f27126e47488b40e8a2b46c1e16516353bcb273bd43564cf5b0cfb9b91be46e8dd1a7a1d4d6dff8ff0fce24ad412f2c0a88c959a463f8a7b1e6801da1a1213a7d506d3ccb6121dec6b0b3d587f8d8614814f9847299768992f7ed2f9351396b5051d082808860711d94daecca2ea7e17bcafc055b1f649d09d8c72200d75beeb315b9e91c84d2c85ea2b8d383c4c858358673271204e2d76703c231ef10e86b8e4977674c8aa9f3e9659c5825e1ae38d7c89c477ba7fa1dcf45f154ed062e591face0aa15652d648c51a6779d3b8ae712d35d8edf347cb28b3a5fce044455469e7b8c9c26b8a27418d65f9e37aeae8d087c9fe8b4637a803df18a26e990dcc3029dce19fdb1df5d48176b8347d99660391a8c7d90d899b79c0803688361776670d534c61eba5b0f1228ced33793e2ebed4ab5ffccf01d3b1a3a44693707e169616a16666d35f95de35fec9d8ad9e1d56a7f5bae88612ae9765ebfa237d2ecd1c7522c94eaca3553fa41e29f8466d414fc9a0fcb0cc40e361aa9598201a8df6abe77d94b533e89385e2be65b872fff7afa00c28154fd0b1625ff0e8f751c8bb19ef34d931ceedc122fb53226bdcc67a5f0bbc8169fa93e1beeb3d4ad208c5b1a3d423a2abd3dcbb34dcfd9e92bf86053104f59ad3b8e830e021c850b55954b932449e5bc68211114987a4d72c5a615e6adf8e373cb7ea4e6f62952f4fd3bc07cce9c913d0985b7c34cea4534ce16b016cc88a6ffe2c5d423da8357254b28ae0e2e9b537ea260916ccdb1da514d82d84811efca506e01c4d2e7cefe9c2b5e54a99376cbe2a31127e26a4b0604dd5530eccbcd820e0261bef8fb7ccb7160852c10f676a6cd22204f9d382498754b83fbcff025730561f471fe790e955724d76cd79e6b3e5753c217be03c0fa555bc662311f9539180dc814976d1b8f7c01fc59e9b2c029dca672d056315c683d3c35a39403a60e0eaf5ef8bc894f3b60a7b6cd40d087608851fc3439dec0fabcac0022a88db9289c587e8d7f21c310bf84d4b64726b0e2388fc54ed262d3d4886f886f5b1fdcabfc4f5eb7da81b63d71b0c8583e6ee277227a4b274e5901d0903d84f33e7b3db9f96089a9b679f66761ee2796c5106252bdf107b7662fff03153db0db56cd0d4ff56caf99f4fd793296290703bf7b45be78118a1d4cea02a78242cf7b7c8761b2f5066754e3378c76a0c1c65f595d81d2829c0bd075f050b1d24b03d9bdf774a82795735baa029acd2c318041f9f2ea55ffcd62b428b035dc654a8cf1727b50e2c33e975083032a3f42d79316924bbdf9a6ef18ef72151a13a1260b8c70e7220e9acabfc858137d3b4ef0d34faccf43ca415dcd5d299a4bac09eafc36d6e3b66ae2e074887f389f88151457dbf454cbb5ac5abef3a58cce8bb2048e79b444a3fdb74369be73b49241d421ec6efd56200c120dea5a9e8820d6b67e62b1fce83a3efe9b23d1373070af5d0a0dfbd8fba0f6d42e05608dd2b8932c511f9729263ffb2477da1a85931bfd5f2d63fe72ee4c319ab290445e4e9f1aceb0fff3a93ffdab807f6559dc3d03cfb8f88823574f42536b269e9ae6bb7edbb694156cb2e3c690066cc67ebdf937d38ea2a07cebb1d8e15fe5bddb608646e3c47fcf5308b63d4309580ebc6edd782d442b504d7c47e6bd92e9aa96a840a987e1d02ececa1a387c4f703f277c7bc730551a2f6041f2a040d61a35009ae8d6d76ac6845dd53404d8e5f5ce7308d2504c0ef8af0014730886386676c7b6d08db9d2eee1e935c04b2259b0f156088b7ae63c95be34bc4540a509ffd7e5cdf530df174ffc844f8597361391c51d34cf5a3bb8834ccfa309c02337015685fec9b6048048682adcc33e6a9897bb4c7d6d028bfd52b236cc83f93365ee37cbc7003e0175132d1f110928e15217d1f901e09fd51d830bb26bec9fd5a80b0c30c9ed8468991b21c6a0f6d63fbd3f09b5344a939ac21fac2abab2f262bd6adc36b9dd3d75e37a62b13d6f3c660cdd2a6150edb31f25cdf282a5268c34927cf45fa027f219970a342d29901c21fe503a4779de7ffcb5fee7b28f6ff7bec6677f47fc0f6cd12795353c6507cfe40bbe3abb5d478ebff49174415ba6c051d953bc332074365b8e0bf1a92e3c282e7a9e7109ea34510abbe13939cf85ac62441419a52b1381e9f6910a80f1bcc0ea34eab2bb96221361cf15428f0500818c554ab671670b846c38ea3e97066a4c72f4dfca453b660b238cdebe9f143c9d0ef08ff04e239aadc95270600b22f2ed4625c30b8841f6e05affbde1a1ac458c2a4ecbd68d70b0615ea6ccb7d68ce3b5b77276b511ad13f9ab2ff1403098300a3ff99bec5b9f7ca5ee7dbfb8503eca525cc8265dd4b6c17848ec4a8266240729660278928c89af8227953b6b6632fe289a0d2d9df24f2afbb9edba6912be3cf13b39000f537771d7feb022579c43011e39aa2099bdb841703900ed7b692e62b6a323c05cbea0f8fc5266a86dd24401afa019909b44e8b576fc0f5266580789d4bf2e0c3f50c1afdcc694a62f911b5c83509fea03f77bd454706d8e35ced1d93d059a1f4a41418c5b3e803a37825ccd53db39442259dc883e7eef40f751fb2addc8de48d6617c263ded0d66727f0c8ac0149c5a76024bf7540a7bbb4a0e700d717c405af7636feacf926a64d51635bd64aba9e5ab3c34bdef0de849a00761bd9274f32f49f28ae569e4aa3eb0cced561cc73f6db88c84950eb53a1da7c27693261292800878d70cc565b40a63518a5534103e0d1aed2e664aee19cb0cc090225bcb4ddac8c271371f0c9ab20da04108fdc986e018b3c81f70c78354251f61f3bdec9bee7474cc4174642556d44f0f45e1fb8cfe5a661585356bc7c648ee1e7ff7bb0bc8a1090220fabf40363c77923045b91d55419bafd8534e16e1d1b7c0270c88fa721973424cf43c32c0b11e7c306da6b05ba4c1ee05562ed2e9f7c4794632148d2bb374cfb5aa4accdf2ad70ce9e62481975a97936cedf849e07c5e6c1b2921e01a89c76dc17a7d5c2ebbd99054d271a2e56a709057e8025d7c0df90d3fd696f398094d58ee6c602cfc144fd0083ec439185876b634b696006ada9de183743b460e632824a6fdf9a875ef67581fc6754dd0cee3894df3435c26a89a5ec9a261f3b67eebbfa255a9df3639fbcf9b608d84d3f3d0003aea8489dfed69955342786d4a7d8305ec83a8eb48fddd4fddd354583512e9a92d45838ace932afb2ce85de0c94aa25abbda4896b7d220fb9fa8282e3fb0f93a0a4415bc160e270436ce9721c0e37d9aa3292fc49f8fd0a531ab1fa6b34dfb3e3f4a585a6543db04efdeb65ff2c0a8f6a6b700293d13a433a75384d9ef49cb4f3b3ad05a2347e5bfa29c75584c85e398d669167c829e79fe727318e45aa46d83d251bf2d2d42d90bc8719322761d0bf619019590727c63de1f21287077196b0c1fda0a5a2f05194cf183a5d7cbbb278c713b679e3d9a974cada947641a67e756eb2828e35b8da1c5a6e90d7a6e8208769bd6063eaf605a3b23c7aabb38120f4504975b5a30d68507afd9e8e9bf8a8ccf61f4f5581175352bcab9fc2bd643feef7c0819683e4dcf0873ab6462445d6937a10467fe67965fdd894d365e2f72f376b0082084e315f8fc26a0c7d4380cab6c58079544ef74f9b61189c842323714ab4480130bac4aacf289748e8ea6c11c7d10a8cb0b068b1a2ee8acc56280b26254ecd1aa2ff5b181a1a32689e637fc5337efd5efd25652b8bdd684436325932c68e510b5e0d868eaf491fa48abb40763870a303aef9bbc7301a805815aa0b9dc1667833f542047c220c4361304a3c7209bd8f4a62c86d7c4549e98eebc6c88125278ac90736880ab6a9e89d65e3b77d10451e23217a58b5de3b0d73a0c368e582b21d48ba17c51570f23ec5a2ac945818c50c1f610e9976ea15b2e1c90937c76af4102267c86c80d63365b0eb1bd9374c3508dcbb94dbac418bcef9c4993ce95a1a12c1013c625dc71c2c09aca8c1f2c83ec14af6280257a40a264c071ab29ab4934a6ba5b27b7671855af387043425f5a105cde89b533360ad04614e97d57a04e492f5e0bb7dd6c5d2f2f6e84fcb71519230717bb3308388ad1c6a9d1e26530c36b2fa193fccd852af8db1b11a86b30e952460d7dec87d712ec2e5a64180eca52ae841e06054f5e112acba53023ac525c32b451b9080c5039b05a5f64ffdfd75737d2cb2fd9ac707379cb15d5a0f0f996d7587c30b1fb39467a9875948792fa73b68dfb660357b2819f5a47da73b675ff3f9249e948c45900d126fe056ef3c2d6b289225873a9ac96ee8a26245d3579eff9a4743ca5d65065e4f6bddbc1f01043cc74a4a4792485b7fad2be05388aff14e7fc75d908671139c903134e048499848e427627a47b268c9c81bcb5fd96d4f8ab8567d6e025cfb7265b4058a21a806758c0677dfe17667caf3aad6bd52f0217bdf8eeccc4d18b7726322529d2112a5a3ae674965d02930085b6012370cb2c7214623a8c9059e6ae499151d26fbe312a9145da50c0617931afddb6fca3330b194958bec8d8a7cb792092726bd9011df9322f3f7a131bc5078a18c52f225b92aeee1a280d6b6daedc8a2b51b5267b469675fece3ebbe6c578b9f6c5199ecdb63386409e0c105b89a0efcb3bcbe7e68cd34f3e2032daa9251262f626944524c8e9ef3596cbe82f8c6953f3615ab9a4c5aa6412adf6bb958871dff69fafbed9a5d64517836424a18094b0f2a8cb81e538a162b46cd163b222fa800a2c70a44d32c2062056821b567be0b62226d2a33e1ffecda3dbd5413cb2ded13f31440329a8b0e415872cafee0a703025fc258b38e465102767a3e36b2a3a6e4871476010194fe10f6786e24ac1b5b82231092ff50ccc051f5cab9b32cd6508728d58a3a3aca01f01dcc74e1515c3ae0f36b36b12a77eefd266989c6c3dc6a4c732295cf185538309873a85726a7e7563a789d059ee639d6200803b3fc70b5c7062113ed56476647c03054b1cf388fda1766749f97dcb480573c6f8c1ac63587faa2b47e64fa88266ddbed178154fe7660cc930ad6456ab3c9d7f683d30a8a62408d4257076fb8a59d09a239f2e62af1177b227da5b8887b4c4e22ba41ffd8dd9835acd1f4777eb384621e2da4e2787959da074897a25be85a7ebee0ec29a0252060d9fac666aa98b59648163639760dad2149e8e99465193b08ad1a74bf29c8092e0c97fb731a45b039a2cf675a175f44594076fc5d724a1395d848522e26a334598eb45dfbc1b23932087063744d2e199ef7b9623989ba35c63757603fa5c48326a781ad6d8a8f69bc2341677427bef75c263a04f6f58d66a6bce2e188fc3783f39d615f4d9acf9a926ce6cdd7b36b6039d68c3efad6798cc3e645bdbd07fba2399524aa8c11ed2dfada3477262510261de890fcceca08830e2d65c4ef4512f76e44cdca86e2bc33133dc0b4f585209bef593922a56ab694b33182e844c2f2fc8a5feacacc604e2483106e3633e59dd465514b0a7338bb1d7950c996766b467aaa0ddf54205fed8ace0fabaa4e8470957bcb838a711497546376d93280faf2a7997c00a1248b57ad0ba01b9c1f865fb44d8261fe19dd145a5e7c3f7ef70865c337a64705d3d21b3331eec28a411defaa0d21df142aeccbac6cede396e9dcd774ea068d4869ea649fd63b410dc5653519e313fa4c63ebb610bb2175031f324c9853fd5241d1f93c8c46775e3ecfbdc23231631d9b4fd7c113b3328238c3429b475014610b19ebf5abafd23867bf33ca66cf35df52135933e84ad9b6446e34c812dc37a70e6d1dc9e18be498197e2e28bee16fe2420e64aa895c2e05a666b08f4f1527e66a361b9b2dd9b50dd54cbff8b08495853accabaab7ed528cda09f47f7e485a79e7ebd38bad3d7093d4b153c745a52beb7a84d1c6a60676a0ceb0d2af21016de86ab08f537d993eee515891aed77b86185cb546532c1ac4a2fb90a83a842d8f69acdab2bf4d57d039e9d7beb6f009e15126d0585564fbe3f098afb1438f5f695c0c0d2d59e9de3fbc5336107136ae880e53f55c214f0b87bb5e9f0605f48b31405feb3cc28437c71b02bbf7cd20135c14123a2376eb6b1b67ad3dbbd0fcc10c6a4fec42283eca2bf8544e5dea52eab2917677a872cac64c43b93819e0353d2a7b72e4c02d490afb9e6008429a2092f07e70c05d165574ac628c384692dc230f54ac67e19838658fee0a1c38febeaceb12cc3c319c9f07e981deb777e09aadace55c549f206695405e523016de4e83061c42f8086acd9e729018c97c84f0a644ace81c552b1567e68d435879fc08eb887ffb852247876adbc7ec7dd3cf4a663a468657f68210d27420deae5db6501ff32d65e8f7f72a53742cb636e33c85122ae96900850d7ca0ddc9bd26f32b97624c0a448d209b719b8cf41605eb1563c50ecfef5151cd434bcbbc91342f5a464dd9b0d7d75e8c2a439a6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
