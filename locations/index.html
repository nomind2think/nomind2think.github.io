<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5db60dd64dabe4a9410db79bc3ecd117d8da28b0bd1ba91bcba997ecab872cfc854d9dc9f95bc91246440234c5c0dda8452df2d5134c03369790e2394f09b3d16c0f03858a1f896dd865159e013f158af1d1b69334490d33f4785301926d709875a0ad5b761c3b8c3989835a2ba45eeb2a46e42080e70be2c11b6e4224d99769141f60be713b03b39ffbf1a82e3825c915b4d2e78e0964ccf75780743d973cf91dc09b03477c59c94014576b5870ab13f4ace7f660e5e6265650124d58bef0e3dcf44abf8d5a8a4ecd7b32037170c876b6baf7edf582b97e94855b7cac44e13d8d6d6d53a9fdfae0ef008be7789fd5efc8968334c226db9d56abc95d31e3a0717db84d89b9a3c29eb44b391db3c5da3421dc0ec6bdcd34f3d5d5c3b791d0b798d808c683395e2fe2ed91f4ec83bbe37621fed63c4da1e968e2dc7c9e753c946bb107f5cdd245bc14b8ad609ba2dee090372d0e895c3bbb29a7da30e953b3eea37577ec6c35a5d0e8cf0f11a26156c9c0a0e5c0292524966c9a71e847c955fb382da8413014acde76f484a8291e298a5e68d52031502d4c9770f82d1f969ecd1e229bd6b79bd814c8fd4cf10576ef16e95a9f569c18aa3a6fdfcd309e66b88ea14c149fc5a1bba7c4d5b41e74642161cfe509e96f1dbfc8ddd91b4a4b60f568da57f0b5d42dcbc3d03e66582a39b6bfd35eb69a2a9eee60906a363acc5d11377b2d73584fb73ae1d331df5c3e1e2b3b6695f4345956e526e13234d9bf88127fdbaa8f1f62c0329375f3d72c72bb021e5253952d55e091d75f2ec3d3425f84ea3a7efe369da14f9a9103bfe514e13ae46e83ea86d0b56e48e52d3fccf24664c5f5098b64df82116c844e604e4af53f01c6d1531b734fd5ef194444540d840e230bb2883cbfe8dfa296f15503e700460825cb505e1c7fa1352cd47d599b2e557dd21f2cb5c0c8bd6de1dac8ef6713f9bc032373e17bd5d3dec8a8da6c12dee5ab3dc38287c86034bd6c1625fa93949c5d6daefb0dd09e78cb009d72c4619c12da9d04ed7c30ecd32ee3f495c29e22c48687e745676b28229cc1d96a99ecc0bee1e42f0355e05918535a598be5d4547477f0c7bbca71d21d388916064d8a4116acdb31a0e20415756b837b815c17ee7078f8b791fcf04caf2175dd7afe86e6f4ddf0d72492873384325b3e41ced9a262cd09eb7e3278aa73dd5dfff94c4608470b7d0b95f04e3fe8dd9bbf7ffd49f72c6bd35b59bfe61ec2d14ab81675484f40205c2b237a53bd948e000869b764153164e05065d1d89177fda57d9d7a0ee3b7707eafd8e951a26d8a5ac90b3dacbc03f56c27d98ffcd06951916237b9f83f2af6d68ef79512ff95438a179ed20dde89d67f2e93af1c61ab0b826455ff74219efcd7c9b87ee7d7f8451f0d6d8264a6285cbf6db115449743c74d3cf3b9406353b65f86d945f4e8b368cea94d9803ced694d9b990d38a25c40d6131dd6a39b1a48ceceb89de3382c001aac2c5559aa48d0772f4de062370133c0dfd3c357b9b6411a7f3127927eda1e3ee242ff6e360c7b827b76411fed0be1a267fbdf51b27fc2197c2348ae4622905804c04ec6e1ac2dd999c5dcc42227ea9e7300191672a9975b219d9792cdb18de2c51a1c3a820c73831f0b7f8851c63cc8f4e1afd86f36f02b5dce91e0746c3ecc4e5b7b4a75dce43e6bea540d3f70ab736b63178e1b4b58694c086d61210bd3bc496df38d4921d0088f37309410384241da3fbea433673b6441b7f3d7b6c68e4c5f9743a144173c477e5a6d4b78eb78c0ac759ea783af822369cfe4b72632dcc929f89d7aeb6fd8d01443200dc198d8c593d7e37719551c0f67695017d29f5c1e873ae54f3aa8050b231be6b227163d78c302cc47678fe4f39850f6d89276c75af6c1d3140fa54486b2062ebc1ddbcfca7ae40b70848f4f0a6f3ac70de10ce28cf841a89fe89c4a47547988bb24ffec10fd6903f56555a9f111e6fd46f625717e5732ca1282c47dc50943c5267f4c91139314e77a893c77cb1165027ed9393e7c2ef83f659a013720368f71a0fc49ea8235fc841e91299d0efde1abb74fca6a3a18fe30e12964a6244f4530c9bbcc5cf8f15d2ffc56ec007adc523b7a2c66672c94e4b91299a1bf7979584435547981bf8a09a4081456fdee2f4fee66b5402336c94db7f97cc67f42fac731d770cfc7fcd25395fc4aeedf3e684166c38ec800c17c8c3ba81ee4f3cbc62d0b52cc16bde421c3fb81ff43b9f0bd1f24d2a55e05706b2e461cf15bec82cc84b78312cee4a1b52d9ee685f84f69184bc4a57c7fd9100faea69c90dccd7a7c95599805314e279354e4c86c73ee0d1a257ecfd7bfb9b67dd38d6ede42cf973908bee28bd89a8b49a8b2db6883e37b3aa8963265122387ba76aed8bc6b5dffceab313496392c77194b317949303e0650d61e604d12a2ed9789c324b3c44b523b2b94a261439e2905ff7f8757f99059373d7626f47aa8f5684d5b675fa9845becd82e54444fdd37f758dfc2746b7a9310dcd984d48e152c99c907832361d6abfbb1f0686ab2fc165e6fe58eb1d1ff9ae686454b5c7458d98d2a7319c7e667c3348105648d4211e80e682c3650b02f43b18c540343ddd91f3d65f86b25fb28223531223b275c2af92cab4dc2c7a416d65b6ef07dc1152fcbb14563a80b34cbaa4c62f1a47d338662052f78537f155a9eae86bbbf76366c38ba6f7b245a5479b624d672d6357586f24978cdabcb6f4f9c719e08f4e6f29c786a63b877bdb785d5e3d5bbf1db64eebaa63f28a3e6e9229cf3f6d14748bcc618b00743d2de001e48ad93bcdb1e8c3213a882b45e02377e9e6a526e4918e57d8b590382a397bda8267b0d73f8760b50bfdfe4aafe38a09626f15fb0b00e75a6a329d43037a57a28849adf00e1e99bef1ae96e10ec609665be946d4cda7acf675990c4a929364a259ebb2da8ff467ed8760684ef0a6ee077011fd3fd5e8ab0677881b9a2e1b4bd096f00af760573166d4793b7f9d1ce0e155d1082434b413092795ff0e75ea9ab9a60017fa3f4f534d7cb15573dbc94999890c28477cfeecb0d2b1fdcd0de2348973854d1aae181213656305f5aebff44817c1ee6985d4cc8e098c78a3fa53d5d368afa6cee5cbaf118cbabf9c98634c6f5c01a892f3a98cd194324bb6abe61944e9549aca35b731cdde6d4db02e4a3f91979ea36480e405086dde2939efb4bf00d730f1be830ecae9d70041d7981df1674c946222138700c253b524dfd8eebb620b9a58a6c985bfffcaabec25570098e133f1b4ce85caa16c106808227deb8d2982bb4becc334b0c7815ccf71c1ae3c31be8d82e7d21434d3087dd582ba8aad3118d197c913d5293fddcce49184f64981a696adec785e27b4630a0eda269c64d229a56f4de33c7dcc49d0e6655c5bdd5a24e43a8b162961046c4df1c9dba2a70d6613daa8070604165742dc927e4d9c3fc72bae3242f450a3a58b620e7d310511e2fda6b83df60e6b215dd71cc849bd738d16aee3b4bad43ea74cb010a56b6e094d9a8aa60cceef31d89bfd229d700d6a1254a4ba30cc787f7621d4feba3104a15c1541deb5b9951206ef72c81195bafd3b8895ce8db24ddcded50ff1043a338cd842c594aff8a1bdcc37f220847ce07d93013e3158e1e6beda1ffe1554d2c3eb8ddbd6a97f72dc98479c582b5787dd114ed606ee0bd858544e037e49997aa0a1f05510b22b85d22e29d1d5b136992abd175911c69003c3299128d874d4e673e1962cf4323a292a5c651f178b6bd6f0134308ec995f7653d8a57e0a1c11d82c092992fb4285bae34b9402621c10b510a063ddd90359f18d4db2a659aeb301ee7b7cd4682aa8294ce1e3fc20b52f3247093ab343bbfbd21ebe9123a05dba53efec34a3ddedd650f3c95cdfbfb61cc5701c5672d45dc021e4f90a4591330ff29dbbe49d27576ea4a628d98ca23aef7a3bfdd54bde9cbeda162e920f2f5d1862828c32c9d5c4c258f58586ecb61be3f57507b4574e2108a8a9711d587aa13a0d54f7f98dae789213559416cd6054867f743d2cd2bff5092b24f4aa1a5e87578e1b6dbad957178e239a549f05af27eac03859c3a8dab67314f7ecdee1d74733c639ef65b63b6e6817e1d3699cc90a0a96ce8d31607d6af17c86af64c48355d3c8542e2f8121d4cf7ac0116d35528701230c669cb0d9d7c852bedf51f3f499323bdcbd1a6fde8f29ac4ddccdbaefc367e59c50e3fd3efdcaee594a5df24449f0385e1adc286b9d610fed251bb73a2fca04ad2dc95f75ab8eabf6e74d4a16ab17feb838581a3320d49e5b1f80757566a0fce078b345996986213a7190d2bdf3278ad52aabd6e7783db2d6989c571983ce91431c16316037ff56673b84db474bd54de1e7a428377937d162a53d7e65da315d9b6cffe3f82adc3fa183bbd3e64b971eb608a09b478efff197ccf88693e4b9e608b1c49a8a5d6f2ed4df0bfc6fd5d7e9c92eb9c66983343f0526b3c5efc056633a3e39dc06ed59e9351ee1bd5cd4039bb429832efac98032f7d4769654b013d9c0f82b8e31e172e93989141151f6a7ff282e181654d39d2abba0156704aaf2a38309a0d90adbce97535979389a09271b9deebac3eec7ef02546ca56fc341688c6876e3dc73c93b3254e87d440df9b568a0df005065e46cf24af70a6b8c2339362aa666aad896b51845c159b493de042bc4881de9aa9c792286a4d4eadeeba1cdf14d3f2b2b1d62a64f93fb2d163dbebee03bc79b68df4b8ad9290a41222d75df1953073055dffcbfce5b35de7ef994fcb70535618809149326448d797b8dbd1b739fe6b0e554d4e4404e6841edeaeac3200165a30ed84e450dd25c0616faff6a4538d749cdca11447e0cbf731f7a2921ef41ccd5ba1ea8fa24f98141bc75cabb580fcb8fbf3cfad3edf93895f8428115a7cb41fe4ba0f78e83a92f282398ffeb09a2d1a8607723a3b5291b4da365cafda3d75a1ae7b799158c702108eb15bb1d47f97967d654614c221f84047f34f732c9bcece8ffe964b25792ef47f35a1053cd242a97647702908ba6e3d83839cda154d0aedee408781da885fc6411f2d2a090df4c5a46ae3766c0993b5e92e472decefb73e1e485cf7825f68f6edbe5d4643ad1f921efdf5c7ae2bbfee92f5da5c82f7edd47c541c59949bec44341dcd2f3f95e896f662b503c13b3fddbd739acc3fef98f339552824859aae9a8dd8fc67bbed1020ba0604046f8e1cc16adfcac8c2d36028842e3f9afb823176ec9ed9c2721d613f43ff5e5c06b0240ef7ef6d42a3062e0f4e5d14a84678e8a93bad9cf54e6c400cbe376b4b743f1c8fdcda124b612c5a964f3c97a816afc033ab15dc6041fc8ac8c4258edf90e1441280ba9aa5204e28ed27205aec37a3acfeebe2eab859e736cd4f4a7fe472fa44581f51cf7c2fb09bcb090b4cec85c126c3f25aa4bbb7a25fe706b3bf58c511f37f6204f2108647cc7df9ad91acd48cb47fc0481a924b8b63fffa2aa980e4eae6abfac119eb32fb842bd2bfcf0de68b58f82579fc6c6c335ff5c3a881a91d4ac79f4f4297b0e839eb9281bcf522101f3d541731b0cea98d21783d229a6b421dacf5cbe6a63dbc5f264b9a2c335b822157f982e64350d9e33525e755699b48de7d95b35f6cd24d19ba5cc649c37b8ffdc5c1b258e58fb4b0b2794df013ca92c0b8d9de0acf177b4f48778e9caba66768f0b08c561b1b193c7b5eca691cc9c2adf021aa7e618b6af636b4881d5cfefad8a5122c7783065a7e0055cd6f6877a3c09b6b78d3af94686766d25997d56721b804e5e2f00af5a81354bf33f6a8cc200859c6942553ff94bddee7f2aa18a3461d43d90c0061b6b21494440bb9a6d6d7e5708a262dabf0f996fb3049f1a227186d675f3f9aaa0c3b2a3051098b6b1aa27077c29da46d942d5dd00d0301f08a6ba4ed32727fe6046617327dd798581d3d8845d5bb54f71e7deafc4eda47e2e891db2531ddb872dcb0b53a8fd1762b73320a249ebe703c6e04408858bca8d1dd857030385dce6a0e26587963b6eab52e406c47bdf10ac473a2d8d512c9836ab3d3d9839bb28f21b94419c7628dfecae9ba10c4a5b2f03c1e9d293cf2ba754c59529bb385e340c0e9393d9c71210fdf66b1c8daa5e473b283cc4e7a650702054f8eec35bbcc0dc94c3ec205e3d828bfaa09889004df74bf8a9e89c83bcf43f2c0b1f3e50dae8f3b219bcb06f9292d50d5227618932fd2fc4746c9001027e064980502143b0d298b0e69960939274c214c5be113407a7319fd7620d1bc1a6daa1877a5ed47f6fd495eb1f98e4cdf51c2f7a05c8215b596228609003746ba1bd9c5a2dd775a1f90669a9f696c3530900aa04b13d2349fa54a2972675f80f86b9c35e035e0f7268adc133eaa507bafba38b6558d7beea6f692bf43e84ec380c6c75ba58fe74464837d8ff7bf039c2579f56682098f7c0a211bf09022722937cebc15b09f09e6083d455a17611eed9ec04ae4f75a27945229166daa6008958715c188b2258856c8925d87c901a8be573eb06c386185ec318d2a852bd84a722c78c39cd8554cb6fb94efb80b259d1fc523ef9296142924d3f62844d3137e7b8c7662c8a7c375df280dd42f8618444a2f24f4a53a3a4bf980971503b6d6b1b79e220eabab1a37b70f7b895f4e01f0d1d49e151f8399c819d8ac5bb83aa94b5e2a27b6ecd33d0859f99986d7bd448babc4a5e90aed8ee50f3f8e1f31ebdc10e6724bea6c9712ea58f753f83742b256afbd2a4c0f2ca3c175723d945ad9ce0b2a6fc70634cdbb6836b8e49c3bb03e3c7ab624e7d98090f3bef29821694d756256d6d1764f79d833314fffe1f3484a74c8414bd0887dc6cb20e6f43d9b54d2f4d5d651840eee232acc846b00f0a1882b08a937c67f037264fb3abf180da8db24bb5e90e74cf62d82d51c722d530474a4930a7197cdeb643542e9bcf736ab39cb187f6148347b18f72991b05e79a4edd2c9bc3675874f18e3dd4212b615187ec7c319b978df13f91e0709e3d1347430d0a17edd62156430e44f5eb485aa618e3a8b0c8b1755fe5b245799c4b8327feb1a2d0502bafd4bb814149d1923fa1b6e083276058c218eea352283ad22f421addb37581b5f6880a55bc38cbf520a76c2224d498289f3de068cd09a549c0ad5bd16d88131ac3376a0d6fa978ea58c4bd4cadfb733ab3080c817cbd34ae57d51ae9b4a80ec60b7c0b9b4ff3f1a8f8c71fa3fd1cdc194cdef966cf2e99a70803cbf705a5ff2f4763ddae170b9b9152de94aee4326f1ed2a1b0a7818a59b101df1891b676eec2a1adf8be81cb543276598f902081e89dfd327842351510b6220b96d1aef0c301563d21379661339494cc500a70fe9805643574c18e128aaf3e2a63581eb8baea273e1e112329d58194d29ae99237ebab58d9e8a7801666f459366a8566fd6ea30701180c8a0f82c03967eefae837070eb8457c1d92d6d79bfda9f2b64df1d3047f59fab3dbe64c2767a7c1b9a1800fb48c6cf32c33cc9abd08b14817d03d6924df600611cedcfbacc4507c060008f4869f6e46e9ec76d4afd9a8df3333ca839e1fed9bab43ec9a947fc35a771caace3fc9476e6cd4a14602190098b0710225e81511c47e5783bf99f6c564f63d0ae291dc8a6289b0b25842413ad2674520d9e17142394c1b054fbde8047e3c9eaf0e60b40b0aedee0ff8b2a037e6306eaff557954946913058eca18790ac6611b0cfc13830174d82448a4ebb8356d3f3d59378b3f4b413b753196b5ea2eec59ac4c218780186bed1356be9a4cb8cb81f5da1d2094a6f599ddb04cc2abfe3c4970528433b61d17843da8c2301495593ac383a0fa35e5ff1bc77ff31921529333a6a90b20c31044a5f3f0de33885d8a1fc67e84e54d0b6c047c395ae08605f81bc7742ae2786dfdbabdc3fb27453cc849007f6fe557bb332559138b154611258e59df1760c0fa5d348e72a8ca3a636eebaa3e956fa990c51c3cb85ab545b0ee8e66f83639fcedbe95048854df2b47a6296701343d937de180181a9c33b56f04fc81b975c5e9aa8e38a37651edbf95c46b994f3642c4b867c2ae84d6dcdd4aead35a346f23f6aa6404156b48b38189342a9e48a08c6566c63db35e72702849945a9bb6660f201ae6398f461bdf2ae594227719d9842c42865ac0bf8d2e371fd015b2f66fed0f65e8cbf0e4a19f45f430f603b1f3d2675ebcbc0349b82f9b39f04f22388f384a2de2f5a3a6e03be023b33156421b470c357847fa0d583935334de3a37d2c04018f6fdf438c0357161a8ed7caeecb15b4d77cb325076ab28d13711fa038f40e543fd81210131c48cf1b1311b8e12eec1f2ebf6555245528b1059c44622c9dec219447cc6a8f8e3fc41d8d1f62b9c03c6426012ebce62d7f6aefb1c115b800b0a85df0f1c7c29791604e9a95383c9298b8aec53d894f8cdd63d39fa810602cdba8431743f4dd7fbfdbf4643521d4a5af714f71c596cdc97d7a5ec3b2b089dd43bce49434920371adb223d49a4321f4f4a24686eb330dac48ad1933dc0570efea95b604c10234c00c330432ca8406665248b6b42a6d3f4ce4e7259f06c15c0c8710f6a67a243c84c5b8d70337b2585ae82dc4d801bca690241ede23841982bea3e004ca88ace416a437f3c11c4f21db756fc041a9cddc1830e9ed2eabb7b5148ad1cfe7670eaa8dde769bc0970989aadc6c05f6065ab7976d9e7cda57934d5a8be2c99caca3c0ec80f5e4e88c8985329d7d7a36b3ea08975340d471d627938e7b8b2425f2fc88bf36eb4e02d1e60e810abf3b905f3a78c9c41c58774ee7161c3e1c91a0083af13ebb8fa6ab3d529bd91fcb73e07dc8455fd375a73bd51af8e84faee2f43e31fef3cd552b74ee552255c194c3b08d04c3bb236c5d1a04fa96008d1ce2f603dd16096f00f1162dbf118b53473a255dbcccf8fcc7497581ed293053f59c6d325bad3ba5065d88e96d66c6dc4106e24c144b54d07e6f5e616d6f7a2e76dee7486948af5aa677dcc370bdd8a3db502e0fcf73bf966d8d5df3861567474b36e6ec2fe2ca0322f6912690d394ed5d4ef56ad3d9742947e7ac137b2274f8182b1e4b121bc571ef6a01b5362b41d420bd00496902b5ca428361a8847a6502f40aeb69c5afc1d2e5753affac2c32c4dbabc1de20daa26d466395442634d94713d30c4c923c92bf2d11df373023f36d11873936b66b849ce503d1ad1636ea0abac25cf7319f4a667afa754ae1db935239f3834f6427a2b175bb15de6b51364187ff5ac58d940f5b4754b86a83910703172ccb25edf65891f77711bb7148f3049035390ba32b24a1aa4aa1d88b471ee8e5bdc24f573cd729bddb2f6154521899094f1bfb0d4ceeea8afc5e33f5aa6afe339cfc593cab780af7780c96fe624d3f44fd73923f48e10d78e47a345d72e3d9764ba2ae3bdd1639e5fbfae36837881e26f9fc83c56f6adba121209d35312e502d8f31e76dca86ecc6ddbf95ba6b50af46abc4e6562fc7d79542bf76f95f12661327db3e278439165775af1fb00d3a476d849fe187fbf6e910ff05c8f72cadb6932f71fe2e9b11d37341c13aa4e1868bcc54616bfa0b37840f68ff8bb4316fdce550ccd90759a5ca26b9432d28f3aee2a6b215b1fa515946031dca12ce20ee8c31a9a4d0207beb04fbbc8d230a7d68f72bbbcb4ca56a44e0a1a7ef92f1445948fc8881d0b115491b9ce085a383bae0b038c61cc5fc027943248ef0637a9fa472c332d1786a9ab69beb24bfaf0efec4d1a0d384a875e3fc4191e75051501e30d3ad1796226ec3b31c2562bf1083","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
