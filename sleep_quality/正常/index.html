<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1556025bc032ad006be40d9f89edc7b794ed8bc473955807f9549e11283f17f0f58383c18766077bc6106802da9d0fbb1eab9c04d2e182cb1f855807a9ca09f09b35faa8e48ad9e6d921edc44bc8641adea727c9fc451f1dfc4adba7a7826d3d47a6a94c70b64fdc7025157f633035eedfa89413ad91bd00a9ed9a63dff6cc932a58df84500af040f601b1253a79eae345207061be84e6c787317ac343de9eacd4e964cc371e80c9452c87e7f8cabbbeaee71f1e6fda5fa12481b9844e75a101ba3bda46c54141f887825a2668f7b3b67f0ff8de347b3b1383bf1d2370744a3e60cc8d019f72f2cb1be0f5ad014e8d7ddeed528cf7ed5bb0c4d39e715b5a23cbe17207e6521ad3bd52ba9d5e34236ae650e05ca053cb0235564b818e9e2becd6836519e69a766cfd07c4ddc8d9adf8979cd18171e562a3fd41989d4e748fca5dfab0027b95b3eddb0ea8fe7501fd5d148809ca3f470b2b34a51d566dc05c3d8dee6633874657f77795a27d1bae2ad680643b41333e6c15fbef75986275e70bcb04f96e9356fc89f85e03ab8198a4206a2b441992fcff3aab875ae16822a9671bda4b76c745800ec390a34196cf733fc6d11c3e5a89940d1b88b0513d0b0fdf9d7f6773b8e016f7d0ab2033840b2660497c745d1a8f31d6c6b3880f7a34f15b69c4e838f6a7a9c098f8c0e1cd7db872f6bac5a55eab5bb72cb243afb7767dc0940288a81a0d1938de0239d1a570cfe4f316c5a35eb0697d2dda132f4102f00f43166fb67680190d3375d5e11f81a49bc3153a244889a37beb1f98c526254268d1923ecd3a05a8d2d7c5d43c4ddf42cb882f671a2825d5a02b0bb5feca58497119f9a065ec3cd76ccf49309e3368f18c0c7e19876e0d8e9cd3219bd321a05849b99151e178fdd46533700bb695a95a5165eddadc892ebd27150ed8e0fa17b43a4fd36d4e8be57bb41b8f2ee402ef3049897494e598ee64ab606685a7d21097a847a513e6dca3c26ae188c779dfab89d6d0f5d3ac72723198e203c4013eae418682bd436aac467203a52afdced6ad81e58ee24a7338e898c58e39127aa51d36a02849a2ffaa87b897fc5d8c34ca95e8a958849914fb281eb9985d4ed70334ff967c8eab2d8120b816bd72a352b2afab5c719131bf95aea5063b119aeefcc90b3353d5a73f1434dfc4d0d31d4a0be75b7ac08583367eab57049b1dfac802b52adbb9dcd531e9addccebaa5eb4bb47864f27890c4abea451d1906a880c35ac11bf8bcd5fb210084c4e66db2942a65db026fd7cf591a8d8d7956b40d0e2da144b56e9cae5a74963cd3b5e04bf15c2a9ce4fb1a3eebf3b71fd837671c27e2ef08d78da85f4afc18f78b88cb2c6b0ef446e1a5b223484106ec0effbcf23a15e80d1fb8e67444f68ee0aa3726336e5cdcfb7d3d33a35a7baac3e1d9b15a7a34782501ac6243808e9be363b1d65cd180fffd9d4cc99cefc7278fdf1a71d3cb4723660d573c1150f8534520fb9a3519055c4c612fd066e4b4545229204f572870cb98c1c0d3f7b8bdef7616ffe574b66f77878acdea6317c794c3da791f8bd37c503cc90e022e944459310ffa74cb4c771b7276203708200a1cb6cc39137e57d48bd19a17bd8b8de0d1b5dc4aadfbd3f7bd692445e782c553f2ef835ea61cdd931998b39515897ca9c567bddaf501effe43bbb93d89db6662659f4c69d240c9f956e72641e86a47d1c4b31bd1263899ec5875be75c0a608fccafe6e2ec2844c4a76dec76a222d5e055a0b000c69079f34a3bd30cef855d4f16dd959322eec893625c7818c06be3e8197f13b27277fbf57d67a07895b9cb18f0e2dc0cb3c853e4680fa61d6808ac9dbeb78eaffa43db0191e51b83275adb83ab2e507f961aa82950f6cc4ba5465a2e5ee5426250186fd6a9d9efc723ec40132cb321fe944d8516f6a188ae555bb45058c20edce5cbfb1221ab34a7cf4d306c736b268f92ef35f71380a7fd366098ef2b829127fa8ea17b8bd5b523756e633888278a252e4bbcb18e7c1838ccbed652db9eac528a65d5726fc4550f13e8257c9125a43d771fe07691a646e3a3becc9bb303f79a605ab4e6302b19f6993ad3f429187931eefc36ebed3b08fb379003d73c628436e2a1a3c55c37aae7ff7c50789c4c71858ed7e3f3d98f0d93861717c03d16af9edf3a88d88edb9bd202c498a3646eec0ae4c7663f6557c6768838577a0455225cccdf287b098beb60847301651e0bd4d952a6d50f035e67e34231e37030f260ce6f62cb8cd02f1f8687a652e3c5b0f2089dbc4adf09eea3bcd3a06126d6f6003c4f98b82c8565048348292b9db0d96ad587d51e4badefd5315e622bdbee72cd4d043e1ba01d3979400a77cfc3bc65506694c2c0c2415956b6bb6251abf4d35a75bbc77d1eb99399329ae70c68188568159da478304a8bef578eb88016b6e62d3cde729666124f77611290bc38c14703cf0779f2ba36c68ee36bbb0471ab4b6fe2fde973c73726a4d22237ff306f2865e8a289fd8dc32446dafc58b5368a231a3ead355583a11fa6719f00c62232a9480b4fb24a855aafe867d510953fe5f0c4462fbd3671c5e07b53c21689294aca37160685ae993b46eac8992f397df6860ff9e94b9bf979cb32a18220e95b7f2d9b86eb6d62575979b962bf1c737535596bfb08a7975923a0aadbc8473fd66a736efaf6f522be192ffc6f3289e62850fde0c90b6376ce53a5ce472ff5fedd3f15deea80d7004428d6ac379345d2c3bf6f7c114bc19f1f0f8cbae8c7cf73eab7a948e292b87e70bfcf004180e00470e876ea320e0dc5f2cc48bcb341cb043930e3ee7034296aa7e4d2ddabe62617783085a6ef1824bb84f6a0ed3336bbd1db2d3a5892d9e966f4cc8dc65ebfe7d06d08c871e6e4bb5c430f1ac68487a5ab06271e26d34da2a1dfdf6678e060f346f3c2e88296e595d050313fcc6d6ed0085e47ca999e113e2cf107a8f68dc91c67d41ca981e3494780167f4cf44cf940f0495a5351d472a3557cc4ba5eaf288d14b79afdfb41c6a718ef824df55261f4b9c0014c09da717a66167c8d979dfcedcd532b43c66fd1df54f11b8c65ddcedb823b56467d449b2a149934f4287e3c89ebedb99af08cf5ae8452ae3e001b1cda6abb31d0876f3e0ac553caf67c50eacb7c0abf038f8897b8af6f259a8e75dad82f1730c652f28194f4c5a611d9a04cdffc0719e36748d3385240aa306b44ca7358305c79d6645bde4d224706400404f3434e35ad688030cffa70da5c5ca05541eee6b4bab6136d0b586722906d3fce654c5b8850020c16b3fa3359eca23f4aa6eb15cbdee8d65c197127e6ee6610d6363df70e7083f75e79203d67db1ca376687a466d1982a7b2e14f4516dda47da78c23ffd99b06e3fcea17dca7dbd567612e582cdb8a4a79edf362aac9d4b378ae78a849a84d3e7ce78edd4ea3e0bf2a32052b63f0a583b49e51d2dd6cfc4e962edd3ab07a21c4877fe69b9da0706452511d27cf459770e7e79976df5a74685c30ef762b22e1a55a3488a0b2c7053a3b9e161a2585df6b0bcfc162f740524416a93cc4009cc232854d8bb44d2ad9d789c0b890b17c2b511a7263e917bb7619a8ee8b238d50d3718f73bb978e42802641f891a358dd44a4840b55d4abd2375275fe778faa13824301a97e15d47a9561862df6d103320af69866a16551cc9dccc815d35ca829725bc480a63115453f14550e61525423220b86b2f6e55db5b9e55e3c537661c0f15f50a4cd23a9edb06ebd06f3716653c1c8244262609db3ad0c664f6a4cef04e0cf2dc2fb95c3d90c825df0ea4fbf7aa1762938b26e85154bd490ba2e088125f9d7594c0031c6307de3f5d140b46fadf3ce0117a0f544aa5b4f27cd5f2eca6bd1ad47ba441f62ff46e11b8dc7571472b91a3652c5e85639d1bc94d360873745df594c6a6673b55ee3157cc6ec725c3a9c7eab34578caf66b79243ca0106fb3a7116b511eece8a981c54f0d0e57f30c8db1c663c4613bed9371e28c7175faac9f3bbf8009bf40b796e8932562c289dbd21e44408f263f0c93845ddfd3393315c963a4af981a8d3817e48f4939a990954757cd3bb3f2debadbaff8c3f27585681e6c41db4dbbc25bde4214deaba48dcea1be4f7e79546b461f25c4125d9504db489c2ccc55e66e0ce9a58d99e1db0b90b60e0dea4fed69d6eff1d9c80de7978f7e255d11276c7041a0987e859c111c75209438626074816d1641bf997bb709d73d36140ad99522f3b50d37ce9a96e7552b94d4a5708a8c37f562763070692389cf95cc03961d5428cbd90f0025e99003e737c0fa9eb2ae707de9b7067e19f12b26dd2edcb5c6cee052adbbdc76caa86a90129d371025dc1b03b8b75d185689abaa47e00f09250d17b32c2ed41fc430d5b1c4dc1597c87f314c863d73312428418af8d59fcc1340deaec15c48fcad2061af037650ffb0b7984a3d490fad678c43179080cdd1e9a49189faa4b724350b25ac79c1c090b7596f4cd9d7040070c3fd0911faf10e75536259ebbd568cfd2958a6a900f2e051006abbb29ce3e9ce7fecba9696a3d071143fd0e992650ea45b5838a47dc550381455fb8601597e118890fda20e291017360a14cb98f6307a90eb26c5c1460e5a55dd94584f1aa47ee5e7a0e0a7bcfadcae35bc5e88a9f12dd6454b9b54aaf57547712ba415d917e1d51c1cb66d9a4d43377c888528ba1369aa14453a7433874adff77d5fcb7a6c389e82b6f9267d1e641a2b778768c037aab8df9c5a15e021442a74bc8dca60c246f321bf04640fca454e7a2ff91dd54802e9be7f492bb54f7836440b8e63459dd436edc38c8dfef4748091abfa8db2beb51a2ac2b5cea2fab6e2d607a3267420e5eccc59626e3428c3e5d2b06cbb6ae057df99657fca49933bc75b2705dd99376bc23809e54eb35eb58dfd2eb774f6606a06de364f22ec191dde9681b02b74c15d3f13da44a36d2792bc8fa1a7dad821e06a9a1636f66c13cced54ee1df0749301014d460bd598171f051eb472b898c01c567d7ebf92580ccba57d0f81dd514d4e472492c39c1d4178c23ba5a15ea0512310d6c16c699508d48be2994aec8efcdca23cda7d3287866d284684e3351c637ad8acead4b2c75baa680a8fa2b34349e7be873c62e933f53c26ed68528a1b134079bbaf157bcc5b617a9ffddd1a1f132c1d77951d8612f1119502070676fee83c2465ebabac1c5022b7332c384138d7cc1b444ba8807ea69f5937ab6cd565800b0cda56bfe7d97dbe3464dea40d94e6a955890c3024196c248261f49bb7229d4baaa898665eed107f5597c1bcdbb413361e84260b7a08c41677164f3362986765ed8534413c51ad878244030f7c525cc1fca578fac816a5715ddec38e95a32d51a7c5fd0d392beffeb25bd7f7090b6839607f98f26162523eb434c08675c9ef2ec49c75d04fe48bcb24e8c158f4498c1be9a91e0c86f3c3e0e9fe75e5484422651dfab0599b24787b32815a4f830bbfcbc56291d55b734d7a468978c5a67c585e2023ceecd5a9fa569c3bc4c3ed886c2b872f8ec82cdc83b26a94dc42a7767e03927a5b29a452e773cdb78f8fb1b069d57278d595fc885c0302bea14e0ee11bc50181eca0d955c72a894ad10d1d1f4e3547458a29f5f32463a06bac6a4415cbd498ef1ddf3ee96e5a6037bf7481c07488165d4c3ab0cc8b10c956ca8e3de299cd753a851d0d65cdbb0b068875b59a9994c08301d2ab227d78f99fad9be556a3d0f3839c447028ee9e9f13eb6d99797aeaa667fb983477e8311776670e90f883400fd58b724085fa245c12da007838e6904da7ab30bb42bfd3ffdef80eb4204fc43cddd18d65cb68cf079eca11acdffb1bd27625a21feef1b003d746c97b37c89a5e1aad647f95182812b30fbefee8c3eb256c20e9064a82d1797c23cf2145c16e49fba17fa6c6c831cc1e0e5c8d8b1b286dcfbc5d6d3ebe3b0967f109b34181e5d7b679d9c99b74bce9f388ad985066b47e5def1dbd6bef1cca7a7d9e04b32890a0d6b1240abf5688674995333d170d8d20a699552b831abc807bf2fa3d40a3dcce67a4faa9be9935862f3b775c7c60746c249c0fc4e174e38650499e2c36d4ea2de58677a0795bf3c87f969679a3f9840d9e03c0b92e2fe56ecd9781d88967b69604244ee9bbec1749a53d6df5eae99637db52701f1ce57aeabb32b3506b2b6647538b241d65c22994d649029b075c2d4878e3542de04321bb030cdfaa61dbfa2263ed758679df7298017372f20df0468fb91ac1874b7f1405ed3cdc645101b785bc35253b8f967d4b03bcc7f310930a857802906391d033dab884cce462bf86e9a6c474fca3884afbc23a51807568ff880e568869f4e642b29e94502cd9a51319a1bc77c86f42207e7effb1e411eac2b606a0aae3847fb2a43314289aa95a3ed2668b6cad8b6c8b4de645f38b1de4162c5c2385f5c6bf219173125852b4eb19705b1894fa67d72deaa17574511d30b51b345df0832e32a389e470ab5a0e7e923c33c198ac8015de6ff6b0bca7466c15d6c904dcc9923831c45eca3226cb4828fe889124183482e16f3d119583b8bd3cfc4e08c44aca1391a4df818ec725ccd8531cdb184df467ae95bdf40a5192b28a138d3573741d34000b9d9fcef0250a250e98bc16a45f24f92ca3110599ece685ba648fe455f98f63d0eb6a628ebce4f09b18b4478a8e6343899f0ffb95ddcbcb1f47dae48c2ec682fcef7e5550065e5de936e91349ad10c8af534ee2d34ba1cc2c6e66769a186e41e7c9406f4548913a418dd3dc5588740313fd9db255ea1628da9f0a54a0556fd2dd15557f5a1048483f7e20be7738d67e3a2b958b9c558e3d1430e76c2b07c4ab699217b3d294316aa3509de5ed1e461005d77233c8338074c5ee020c877beb73c547d39f50b6d8b293e308043cbe31e88f1d2aebdc741a89537d4e08e2a9ebd9b1999b570fb2b3a33035af01a89ee1f185163290fa316bd29bc4c56bd63fbfe80dd01c886191b707268604f00138a2cbc453f3ca4284f6e626ba9fe55328b56885cc54d7a74fbb9f16164cdcf82db5bc4e41413557d7dbbdb1c4684bab411208fc289c0a6bd0d5dd37509b280765cb0b1f9c39a6c5de8fc260900ea20b22aaefbd5ea3a1849eff25ea097cfec15e84c5fb1ff66b27c7ed0c37792372f2c36058f3ef39b48b3a9f380e95cc6d29704070fb8bc10a979bce22ba9420a4690dd78a2159169ae9a96eef21058ab63b87b7e8a47da8cf4bd58554b71052ccbe231337efd508333ae346f97941fecf024c4ab96b082c36729ec5f672863298c0c4a0464c627336ddb609ccb62747b7b8460f33e869270cb1cbddf8b5bb05eb3bf1667e816a020d2b9caa1ad0ae0906ab9a5c2237328b9c55836276e78382a18613b9f29c4414bab281869bc9096de59e111f6a3e219536c39edcf09af00f7aaf8a0200aa0ac0801cbf18c9526338e3dace7049b4f78e1ca4c43a86df3f0cb631b8ba443ba51125c4351a3ce73567f11f7a9a2c75250318271f35a6f01bd7e21be4f4ac00457c556957e5f1943e146f8f021ad009fecf3978c0e29e4a5b901e4572e5d27217a8a8d73bd4847a79af8bb500f28d5640aa92f9e9272131a78f9cc21e1ed5118c06860e55e47f9dea727cdcb921693ab55e70c725460e226ad77bf144922f29f2f0d4bd8d0f0c5ac7536ef784b388bcb07cee2f113e9eea8e60e22d3e1b5c046f6e01a793c471d6b1ae6bc02d37014d3dd61772f1b8906eb212a6c1801a6ce46c3c3eefb7e1e311da3846bb18864ad890984e6365da46f6d5130ffc556bba7d43b857d6d9bd38df15f2a8cd1a4da775abd9742db2f20d52368f31cc4d01a30609585ee0e74f2ab486d5b1f533695252b7fbc102edd920f09576b3de0bf092b1b072154b0bb72140e791e23f7a3005101d67fc07fb5d2fcebd3f440ff393bd7e8edc984329cf94944fa4e2beca0968e8fbd1e761d248b9b45c0c30f7b6de7c5aa06e837191a5207ad1c7ad1e8d44fd86c2bce67a39bc967289f4790620e8ce52802338a06aaf85b09f7258f020530a1d07df71e9e2df2682cbbeda9fa9c663ff51224e3368c7cae4218c9fcbb398edcdeb951c51e45cd3257ebf57eb2900fb69fbcf8af05e12f1ac16963f0036527df997a9fb2a9139ae3ee0c17ec1d2486799e78e121d500dbd41cbcf4c23339261e8a2fcfbca00a15a1e60cbc3866faa3c3fb34d202d8977484428f27dbbd7a55d9301ca9f13205c920d1267cb12809e32a4f1c3d42ff95d5c5e7d47c11bd638f3de2e863dbc53bc6b02bdead041ec4c19faa502c2b0c0476f636bb44529a0183763d4e6d2d8507ac523937bce61237883eaccfd05c94872314f16952ba3d7a03407b9830ac12b9231b112ef4c6774cdba8156dbe4f89f20f670e88bab35f445625fd9300649597dc5e26337e4bb3aafba292523db3ab535040edf21623405deebc9b15d10a75bd61dbc85be7aaa9a0ecb215dc2dfaf3227c6b12a9c36397c0e98197fb08377aa52442ba31ac07b3692a185fc17ea2326b8e918254fab2b026500bb451721f2cdee14630c29f8be352ab7733811d3e73fee7a358d92df7bc094aad4ffb787a727f4bc1ab530b8fe77f9b901c9ae3b89337b50c38ca5c1b8f2d976260c5a87baf25673236a4560c6201cb7bc94cbdc73c4525450597f696db33d5bdd97c0d06b254c5a65f6ffe81cae40b88b45d75837dabfb8600a68b85a5dea0f5ef0fe421ffbbb3157266db0e98cd40b8ee25de64e32ab1ce35bea2f6caec34558bfda2cb9ce743a23cc2075378f503ba8253635f619aca0ecc9419d8aa19c143cb9fa0ebffa16d4e59f46089a8c5d653820e6ed7bf1127dcd1176a85fb5eb17ec0361d667244b3989d763d3c7df441b465ade4a9e565ba40541885477fbdc06555c54f5b211da9995cf11304d9727500c55f1b0415f6148252460428f9d642c74adbca92c1dd9b8df4e9eabca2ee4e248d491352309feb186a5d6b3bfd302b8ce58c406190f5007aeaac1b3bafc2a41d93f3ef097d6d7ee87ac7f66a221890b056f7a81546cfd9b49e1ff48a01fabcd87d8ac6ae2a7b030eb36307955b0796d45f03e05e4217e902ded07479ba18fc5c3fff0326f11682d7eac00216102fd21d08884a6c879a12962dd845ee0bc2b50f8abe93c23010a0b724456f4780d1200a4d58096a9917a3a8beecb4305c4f535a4c28a8fc0cab2508ea70e18cb79dcc12f35a8c4753f7070162f4be445efe70d361a745015f07c8757ab853443184794e2d668b394d6f27ae1e885d6b2e17420e918b278b07167fdeb3e6812f687fb03b2cea89c6714af2ff2901396631806b2c44f100272093aee3bc4c4f75a584193c8e7b5c210bc4366f7923cd5526f7177a451827c42cbf6b7abbcbbb89b1758123d6e84aec23472c1216c4c7cfb37137cd9f1da0db0042312a333cb63eb6f702190212cf808b414fe2c08c49cd506c460c55de036de1e239c6ccb2bcb7fd3938ab149c4529397984cafdf1fbe9520ce977def3d72c08cd7844bc422d1db8cdf598136de0887974fd4eb7b4502cf41f97b35f2422736261cc4b44bb7d95986c1e24f28e2ce1b24cdaccf7006c126ae6284bcdf82b0b620ce1993ecce971e8c83aabc53ab98b086fe77cef92e65b2f062d64f570bfd62e950c44d87dd0f5900053999086c02f8e9f1b2edf178ed7da219f62610789e27d45e6f5d97131af965147df93bcf32f5885be4be91e3e88ab416477645624aa9fe232c069b00a1521cbf20a8f9877145be9bbe53882a99ea340f055a4437e60f3ac1910f715a177b8a1d38eed13cc4eed8016b0641610a19f14869288d1b00a2513e615762e694d45cf56c6abc960f89eb1670fe485429e9b51de4993589838d8d738a19be75f3de0dcd30dace7001db69ea4763b689be3946663d279f3c520f7963eb9d73d4e4a6c4d1570ee30264c0a4a3ad4cb9f42f61ab7c88df54312e14f87bf6658d9bba4d185e685a3a1d018032ab8b24b08e8b1621f0380fe7fcdf38877443b8cefac187b69effe85a11d753539acc646caa85c17c858d80eaf7c6e9a247d712a389e6c9cf29f815b62e6fa0e8363fc8657cdf992904feda7c0ed9bd7408b364915f3b6feefe627e91eb837c859b91012320f959d40bbe9a8ebe77991a422f460928f3701eb3e58f53501c75f32a3ae029b83a90b2ade0f135d8e14ce9ed42af1d4d1b4953fa16e12402b78d373fd1732bc33e71615bf0ba1532691836814476ad9e5a5c6d2966d57c8bfa16b29d06eab9b729683e2bec979ff154e356323eac2b0f3c50d4f948b1f141ee37a2fe19e0ee4165e84ed1acb40ce8341f032c4694d5c54d57331541ee7e95e3a719f77ac7aec006e96423822d0ff644cea14f030c16882c1d3ce6ebd35f772479b76b854f268c29b82a066bd5a3f038d8ec3849100fb0a0b3e6e08d71ae16ad57c71c811a19140e55433640da7178edf866f3f45318d98b6c284555ec176d843239054af2ead8060099238a43be3a8eeab6a65d4cc797f5d9dbb08b6acbd2315ab31ee72bb0f9ed8c5804f335fe30481663e6f88b311b825a19c214a90d2dbb0eb20eaec66208db5e47476743552d692071e903b2b3d9582dba929992a73759c60de64117f29681c69f9e96fd8cbddcf743e0bc065c96b1c197cc82c6bb27878eb149665143d25a97f10d7c8add048d1ccc7793fc792d1ab84161add0ffcc8e790f66e9f337388ba5e4acf2e57e3cca5d5e7bd5f62a926041cfba85e89dfa94403dc2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
