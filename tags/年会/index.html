<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a8f0ebe1d46f1f577813745a91198046d1c854dbacc3cb9a3664e8431fa2bed2a0af8c9e7e74e2e88af2c46552f0d2228a4cd02973ce64ad858d0dc386050d82b188c783c56838cc5b9bd2f233951f40727ea21d571a93052d6bf944e5603dc24508310a785db7ff210f1fc2874f5b32dab92d37ee91b114be72a4748e7faf39516f93c7f2b4e7816344b8aa84c8e6eae0b64ee7be0e9b478125026b1331b40208a673522eb9889a6c2df5ef7fddc9fd17d7e41b74d9338a0cd45e5529174de47d303219f20841a3694e97b54a023582c9a59e22a83ce48f175ede1cbb30f22fc98a04a1ca439ab28be7f6c72bd52102d04316e07f36ef058537c018c14594f1e8e74cb0798bfd25919c16d3a43c2d25d894c6ca092063a3d7d811e09dea6af2e714d5213e5ef2b2523d99605b1a1b39689b212d63ff56735bb86c37841c82a1c08725700911553f9805e794cf46df10e20d475a690a6cb545d0f9e036a9f73d97f04338fc72366ef88eb756601939b06340c1d15d5d608ec8a000deb90540b9ccefae6041655346857f292cb05a5e91a081a13d5f68675f00a6779d8e75757aa97dca6bc041bbb570623c3b4e01b22faf47cdd8213f9145c7dd401a8a23516172f45b088156849e1179ddbe7925c4a2cb755db655354da6c15fabd7c5ffc1c1792932c90c12f55b96faf6e03a0dbed5660e88edbc0202dd59a4c061df3498aaa5a345858dd3ec829562900ef75b1e71602c121c2605bd6a895f4c3603793f72af9eec38f7347b7280141fe17156b128591091f981da70a26ec684680fe8a9ddde3fd784452627a43dd6f1fb5c980bde7d08b1c31e0c952b2295b6fc722283dfd883d9acba21648e8190d95aedf905778ed75f18bfab2d378856d213f1050eb4019bfe10b62533039d7f3367585aee49df00e2ce32581571bbb6497519f17c755ea6ea62cfcb1880b250c4b34cf8ebd6827edc25512dc203ae94a16b0aa56d0097eac374e6d4910526cd4dcd20652b736bf918edeb0e7dfe1088a7b5b468cd90245a336747ce32765d7425cfa7c2aa8519db695753521cd11b47e1c35957156ef7d0b77f63ae3f774c4daa89053d5f6781486486c498c91ed40035f5a936964b5844894aec627d9f5ad578d0567cf65fbcdd4c6815c7c027bae3026562a21316a6ac6c077e3688ff8faa9d0c760ba52c584eb95daa0e57d983a7ce61337e280de29ce24e759e50e8dd2fc30c1deed3839680c85886c96caed24660e052e6af0bbc7aab8d659f2bc0187a6af50b7b1dc8f955730c6df9e54b584baa27cca6e542cda624a47bee4218f9a7c303f4ede29a10559708f95083a1ebb6539d3d0e488108556efea1bcb5285291f2f385fb21c2536e797e69217df5f4a95436c6c9375cc87a2c471f5a9c93534199b4bad3d9478fb7dca233a4651364bb251179c637fa88d21c6e92a94d2d52519648aeea6851b22edde8af85b9643a7cdf5805a30aabadf074e47992ff67821852b991d3597964fc68e521a7a0fc883c52c1f1090348a15f46f3dc34752b51ac4bb1ada115781e9cb23329f004856330f02b17872e844f29ef50242d5d18ac051fbb08f2246404ec32edb271bf84a6bc46566ab9cf99df0e9b607eaf41909d44144f5914f04d474722e9978d2c4009a2be37332ee20295acc626cd640847030c87920bdda0ebc6b3a1e256cdd6c5a7462935bb8f82116984569acada895d7d3e79dfc41cf6314b42eb4ab7a88d280fed5f9716688c80da989664ccbcacaf7b0be9ec7b6b7bfdc2e42e13221ab6c42a3d10e08df1db77bf568ff62229453df8334a5e7c51baf3e2839392d8007012767885e334ec23c59ae34a44a5221d72a82c916b21bc5ba45bc1dd6544652e3f17c9401e2369f1d01c13ea57b8a7b0036c3c8205341e42b73aa7ddf8aaa7a5d1f4f3d7adbd2f025ff82b091ac5ab6627de13db76d5dc07a990396113029895725de42ecbd4ed62d20a61aba3cb6baa4812aec547b19dc6ad1dfd5aaafd93917f9b553f4574431f7d6e68e8e8f1b5ad8dde0a2b18bf7f33cc0bf6b6396bfced1c607228edb1e557351856b5add6397f68bacef78431b1fe468382061122d11712fa6424dd13b47107928a5eddfdc7c5236e15e4243b50a8d5b85fa96f4fe1f6961087a2e6f912e04a48bb6c9b0d7f66009de854f9b2cf72b842bb5fe60e12c7d1de00b396116f1a8903bf82a0861c13992aa41ba7f3ccb3f88f9c3b890cb397275d1a17a168c4dbb0adaad81a58c7f89cff071d41074fb5409ff02ba793a766a7efd3f32cb24cc294a5c11a8c7d7bdc01500eb54e1d93bca33d953fd18b6227b129548abb6c734a6da542e44fc8dc1393af39b01ab307bf64c236c9c174dc6294c8105253b311d8a6ab3bd2266b5b8cdb357362238cbb2db405ad9729c72ef282899a9178c9ef1b9d2fb94220ec94099fc476a15d8cfa2c82fd2a7af9e73058108fdb84bdc0142c33b3b29c18d6d273b8b78de9596f583e24c873396769dd449421f90be9d8da729321fc5476712f22be9d61ba3d20dc05a5b3a6077c6cf2ebb462002b001251653e3cbe17785d789ce3bc1ec85d46fb54d4450abd2e1632a7ec363edf5e8437d1be829d0fa43e431c1ba5a3b7349b944e18f9d766e3dba2546351b4c37a3797bf554e0fcef6a5f64fd38dd08394b94de9bf0ce1a3d92aab3638807c95bce0948734abab8af282853dbb22c602f21542a0f72fe54aacc1b2709f95b611a8b2dd1e4afe3d5f5c78127dca3f38ac2f6abbe787ddda69ae61f99266fef75341eb2de2407f766be004ab0c739f1517a0070b0fa42933d6a7e2c8085a8f3d94969faa5691a0b42b4af1f1c2859c53fd3a6fed4573194d75d99dc5a2282f74f22e377f810f8df63eaca21a395df9973a4a14fe2a655db8925381ae7d8364c0f4ef968361b936c91c7fd5030130413842f22cfe72bfc775ffe55a275954038a4470a652f0f1413831de6a8c38c9447e546bd5e94358fed71e0b928185076e3d0bc3217ed11fa650a2f1a9fe09f767e611cf683224e84684ec3e056944a252422339712aa227ec65f44c13d43f7aa46482821d30ae6cbc55c95262d8bafba606c4c0bd97fc1209757a19bd58121e8098c01828e11af1d31fddd6e0661463e69557b08fc046ccf6dd31a0c2ba4a0b5a874ea1839bbf8800cfce813ffe1e89bab9a94ae7922f27f0eb14674244673f8bedc6b63c3a696270a1427bdcf28ca58333f992d46221d8091fc96d82aae50740aff5e35a7348bc6063d7b937d65985fdd4a3fe487d4812bccd976de719be0b58ad7e34bd8753c8ab20316b2513440cb21b105bd55fb622163320b1b850da7b40e4807c3467f51bc37ecc3d7a3c45072e9118909be3fa05ce1812d733ca009d94e4cfa9273b33cb218b67813d371e1fa501944b447308e77d8eb2402215708ef70872c577b64ed9c9f50b18450201e053f4d661a2db01bea6091744d8d608e2af6b4a181e6bcd74d25ce1e8f4f333507670c91e55ad28a3db2bb0f0cb59a4d55102bf02d51e229f767fc6a9a29faf1eca1aa12bae7bf1a7f4b9df76ca4db4ddd7ca4aa68b851cfc30d4e6121b650fb286924571fd2ffa408c06b4ad30dd720da81264a94fe70d33efce9e96ac92e99fbd4a201737f8ce017050dbed2c190108c19e73fb34d3a928d495c550591aa31a50f75f5cfbf83048b56d81e99fca13f9bdd062e4544e1d606324b8369bcfca87018e27fd9c183fade9ac2940c9fec5264b051caf1c7b7f238cbc402e798cb266e36283139db6ff8ae2ade9944275938a0518066c4161c0ee7fdefe1eddc607bb6ce99f3e7d2e21537aa8825383039a17565c5db4352e920e8ffb87f41958f71aeab39c343c86fd3851ab4070eef72f125f4b2e78ad70d317ae7ed62cd84c3f940b81956a4b2632b878d080964953c0ff651b5bb171ed6ad33fa969e3cc5c5d1aab3a336fcb06a9f978e9f8102c774b2f63a534f9483ad519e77e5251eb992df8ad301895a9bcff927829826a1e5684f095535af96c80bab28d58c8c2429b52e74599003e3e93da2e05375284c67c44b569a161a657818301f8cccae6304f606b7aa57d83b0d2e9715fc546f24e43c8b7bd18b11895649d628fadbea5b749737310dfbb437e95d871125e32e88ce868df5a3c52d017737d978e0fb206e3cb711c2ce732af347a799721ec86a15659b876e7994c2f7a971b98769bc710c869ca9342cc36eb2147413da9383ec4784153138f55cc32209bfaf3a024f1cab69ea13667a525f8e10525b27fa38c9876accd78ab915c63ad44a91c6a191134227b265ac6b737dc847b3b2a88030bba3b0a10900999d73aa5603feec171d4f87f71ae3dd09fbafa52aa08f01de6179d8fbf8ea1db9eb235c3d9fb942b27660d6de8d165acb3183d229429584e11e0a6e0633c481ed21da816e80b6a45ca582de5e5b53a68553ce39507e5cd2d31f4a2a9fa3d0c4d265fb902ef0ad73121fcfcd8d327a623ed68d7d1abad14376ce8987e86c3613814e157f32fde5192a0ed9e6bf104674c0e4a53b3528b552bef898f160499dbf772cae123aa5595d8494b1d9271db91c141e8afe2cbae42ed84f5ed40078fe7492c1c02f3260a84343cbffd620223e3f4852beaebdf594e721905f9df74a4628088a46999ac389a35f0dc3be7fd7549f8b00b7f85c991bbbf9ea3f1e3b180b6aac617283ab01e8ef78f8f24ceb79b0e0a6530dc3c0946e615cb65b7b701129bbf1a4509fa0aaf69c0fd33865a1d24feb42fc6475fbcb2292bae7d5cd0bf4867f4e328861c3092b8babe24629de40971099dff40310e0634de4a51b48fd945d649e6c36e1f24835a720500550369b471cee47de5461f7437fb22177a4b226d1114c09d4f5c6c80f3d3b23ec0b43a284fe94b61e526cf9cecb1ef84ddf933988bdcf25d6458f5826365730595b27e03debc0326724dd75b4c2cccd82382c742453f9010da018a9f33a7b684957d6c995a9d1650b979db51d6b39b5841d4d60f705aee42f57b828500d740bc4f62ef5ab303d7ea0c4b8193b9bfeb1058fc140b0425fbeacad9157e9375fe77b6b1d1fc9ed4fbecdee5d68ea7af7a2450322c93dd99f3d9ff7ff52e276af67dc5ce02d25c467852b3ddb5cb757bafd7cf2ecaa01929e9cb75ce97d3047f08a4f22bb7a02830319baa2e03c09d778276e047e0242ee7dfa49dd02a304a4732ae1479302593a3d43b03aaaff613d6b0c7ac99c1c09da2fa0698748bbcba8b3e39ae15cd6628e514af2ace3fe55bd05d609e9279b9736c688c4723187d9ca030c3fa6b9373208b8986edebd441114e1dd60133fbd0f42094a61cd46ed9b7179b12c35808ac9acd9cbeec2e340c6266e823d3c2e052e56fc126da9e4bed89c3f8514fa29e5a3a7918505d332257311198213937ecbb7fc2d917d26b8c3e93882a44c0a0b01af96c1328666ec95c9774d2b72c9159b9ca5e19ff973536d1be91d5c9207dc8de752c265b4ddda9d9c6fd010d9da53cdf033a2e9be004f0aa63480497e7e1061c8a54e307c0bc74f060b87f63af3c589b8c36c7478b958b417a9995c23a20ed6f8c5b70e644dbf2c7c1672d5489918d26e1dda7e68674c1851ea0387c31a278165583293baf90f5c500118602ca1dd7f665e7e1cd2cc18cca8f239ce68f913595423892b3ba4e91964029f43888d65c4c9222fef7f6351dece016d13b0b514f34cdbf48b718d68414964c883d1fb13ff59c95ba5f5fc5a2d249ad3d1173afe2d9cdc862f8f91503bdcf499a31767781df3bce2047685fffe5b33648181fb8ebd426e79b7c2ebb29edf3ce7e2aa928db778ed2b8463ee5c0f2b21ed730493e00b4029836ce87629ae6d1840f23ef5ac51a87113a690647c5445d0ac83219e8afa431d14d8880f102b079f9ed6a032ef74e4a511fe8c3d11fad2478a1d5b818af6b3ab42a96b8d1fb42704ea73f8abfd5b7979e99669e7f1699bd9b9244b00a04343f0ce6d396e82561122b162a509754352389d79d35a6f0bf51ccd2d75ee12b2d901199ae535f879195f87b2618042f84bf5737723bddb321ec2386cc018a4a9f3c1d7af85fe2f498bf53c4e2ad0dd0ca04a82aa0302a5466c85165ddc20998f38edd3069137fc059a1f63d48987ac7229cb1cfb5b2789ab27956c2cc550cd53e5bf8e9eb949754f6e67b8e0bd832879642e47b8ce0f3ddc4239e61179e9e42f634b97c546c00cbc914e2daafdb0cbca8656f9299fd788d04336001cb24de0193b3d857da279576caeab2ebb0e8281b2dcf8ab73424abdb48cd324c9464a73e086347830be93c12562240a51447e06da0efffbb9f8e868925acf882469a057bbebd9368863b0bb0599b988cd9f9ce7a2da652db9f5d843fef17d398ccc968ffed4df0da762713b3f821e6065ed2e5c870a0c2c6c87828290a407d00968e1326bc8f5920cec0dcff6386b5ade0abea65514acd4a621f2de8b30916cae73fa9d7896f62848487a8aef8169b75befbf7cba6709475d24dd07caa1aeeed7eda7ba31150a25ccbef18227836e9c0bcea8d0cf97890b51dd797e01fde4a1d5ec5c8e934a9e300981359cd2a2832e48209caca73a67b1723a168a7b7b3dc393d1b54b517f145c11337fd460d3cde313392e8d9afecf047369c051e35a1012172457db01330b89b809531c63c183eaa3fa24035ae3315e14c39f38858fe992264e24640854dc48586c17a894e934d3cdb3d5732d32f43f436fc4b54b2d2e6282fb353e17c50975e6b2ca89453b87c7f49d26a3a33c31a2204051affde668f569e1dbeef76b4567f07034a0fe04d339bac5fe0af9184d1fb9e40ac90c0b923e4b554f9c9f6c956304484e222d0bf0dccb3ab078923b6501517a3777fa47c6f41902ca9e27b9288a53be13c57a874ea94cec4858fb2313f8738d350544188bd51f1685fa02b5e328ca678afaec7627a5e887310091395d72a259596fd48fed622590a8da8a5b6c4898ac801dbaf5b89517c1df2646a3d87c3e51cddb5a127a372099c1ead55113aade58b6249512020c4358e639e37e467734dee441f052c9ca96bf1b6466bb4f7406594ab7f340979ce9110b115b4d2aeb4cf331544beb3506d5997e64b7ca99c488f9fc7496da24328ab667e9400c3e080d748a8267a2398e53d4855dd6f45e89f66e32e5564a8e4faaa4d9b1c4ba40d43d7f3acb08f892329b5362dc59e69c94c709e6124e600fa7192d44d3cc52182ef72f72d05af138b83a825fbc6660af14969894933bf35f60357f10558a9a8446f2beeaf0ce7e6a39424d7b305bebece6dec45222f5aa6afc571d3e9e47cde6299008f6a2d22f243a0b1d9885e3e1c0b25eb2439ee4e4a3db2a2b7b55602c6342fac7995b1db6195444ee90b85d74c98a4e2899cd7c5c71d56cc0d4024a0b2065230adfc181a002eddaa0fbe536a0fc00d8f4883eb023a359a35a44841224083c89f5895730208b85e61eb725885289d03eb7d75bad8348cd4540c0cba7a551586be65c60682abd86db8e6cf85e7a3bb078fddc00ed3e9f6ba007effc7d866e589ffc3f09877978c5015a0e361eaef4da801b604b5e08fd671f473b87556c67a4e0de6e28d35c5168f2921f22d14d1597d14587ae32bed3ce874a6ec150fac9c88e87a5f28a8110c23e0b0e2adeb0c7797313549c4dce21da9a670790c819e2d468b346829ef9a0b0a5b3431a950deb9dd00d0020ded38b09fb273ce516735bdc4839cba8939c426e113ca5fe9a902727a39693150cb551de59ff1f042cfd29c100ea81e6e63fc517464d5725f5e37b133748ec4e2e54d41c103e84eb77e18f2739d01b58a0ab679f7e4a3e1518bc2426c3248db611ce7bd9cd43094a5cb5ba567d1cf11443d645cf70d9660275662e7850bbb17261d1b2e06e1958e8d86a5e5119c004dbd0dda180d18eeb23aeed4157bac9df6809e5c604b529450f65ac4226f68e58d2a3ed1782e7d0d1ee2563f1da26e1831d77b77aa2dddcca266faa4398faa1b0a342528c038e6a9169973970622722be083925ee1efce57575d5091575855d2975986e9da1fcef0387ca19e4d40d2f68dea89f2490d7f7b1206171da35aed93c64dadb132905adc9f0d96754082a300fff7f2bcd50d0a5c492cfddea078cb7c85e06b3c390ded6d47588bdc87a8b697c4379947177265d28d61b273159ef6e852c6a6c82ff15775c85d17e80ec47ad17328345d58388a0c40f10e259042e9d9cd152b1249baae227756d0c829a1df3d659d0e38778b0a8602995f2dcb0add839af4c2753c03b1113d774ca9071ec7857fde116002bf3f1b1cde9f6427f2aa967f1f51ebdc6f3630fd958efbf7e61d3563966075584c3cea483abaf0488e6baba8c58e9d7eefae358034a339510af71860b79bc8aa9565a78111768c2426266e2971830d7a3e20f7751e7a14696f5bbf47016eac1289adcd9304df8ef5b7ab0a5ac9e14b362a9bbc3f33d1d9e5112b68bdd3c9c8bde9012e681b22fbe1ec992762d478aa82fbc077635687eead6b8495f5770caf541292f9b01da713f44892e880f32d99be643e54cd4e3de11129a5bdeaae260438e7b7756aad5767b4b18a1b832e1095f5ea357d2dc5fbe2bb6d4c91926ef3d5c3a996fba39fa2b38260bf60fbc281aeba52b8660ffd27d7b3d48a87f90ddf8e45397926704acdf5bc27aa167a5bdbe6c4985e543f793a0470a376c62dd53bc05c9f9e97f67895156b343dd4450a3d9c29d324bfeea7440185146f6532e9206f746beee55173be3520028954305ebeba2abe332b930e672c008407ce6fc7d072df806af8c1f19f15749dd60401440e0031f56c5ca3d1eb58119b24fd5e4dca7794609fa5b7857238d8ebd1ea3d855cb012467b22a5ed4254c67bf447b82fac7e694e59372f5f1c62190b2a1731f0b4d7d3cd17a00c411e2aea9281362d44ea348069886174da7ff16fb32ee41ca19e9dc370f234163ea6a9370a85d8be9de48f1a5017fbf6973cc7647d3adc59f60ed7c919ce26b26dc5ac81dddaadd7405993e2eb1b1c51a97d7f85ecd22f101a205d69b9f909f137728305efbd63da3ff71bf3cd762808f105fd8832610500e51a8063aaf53739cf2ed2e6f4b47035302039bb7c7e3b5c11d7a6f26d82b26c43f8fdb54392418e454e1eb3cd644a94f497a9ed9ac75b0ec7b1b9e38ab422a725a6aae5ebedb290481ae93b0bf5d6b11e391a27d52ae42edf340682612512b4fb578d998bf5b47f2735f08e12763e224a96cfc06f8972dca548fe73c08890e63d924febea14304fdb20c895d6f4b844782f6e4d632c5fb3489386cdb618bbe4292e71523ec9ece47cf18fdca66d60ab117b0b9f692526ee64fe499c70055f170ff32089612859b5d3615acc63a3fd8e2ada7ef94895eb232ff7bd6239479eccb48bb1e1aa21657ee4bd6073fed584388f58feef0b14766212ba3cc79f2dea5f93bea66536ca2f6c6ae44ba9e0e3cb05dcaff247708511670396e1ef62f0c8cd4d5dd795b928229a4445419bd459d39f55c677c63dea42e2432c0c36bcbc82a832eca9510742f4ab7e30c8636ba8bfbfd5f9d208419cc1a7928968117c61becf0b5eed8e39c757d3680f8fd75f47d6abad4442b87f70d8dd8fa6719bcf43a7de8163b0259e1ab358cc9b423ef8cb654cdf3fbb35d0a4c5d58c8f31b60ded92c208b39c8c050637379bc91112366825ccb2915437662d409cbde30f4a27ce23a6c1833bccf0a96f53c78d5959ecd2639188e8b1ccea54f934b1fe70334a0075a86353a78b061f27c96c718f4f894c54d74da4f08611e02ba434414dfb62f5ebac51c9ac8538b7b26a7e8e7ca9f5409bf22ae49ffdb408177a1a940e8cfa2baa747fef8d4bd8cd539e75996c10ad0a388187aef3c8d0bf249dae19c46406a2eabffefb45e56679c6b5e04b45c28b8386164633535fda702d83966a7bc5123f1e4d6e1033812cb1a781b1b085feb11f1fae4ba4332027113ae8656fc0510dcdee9adc377044e44f644d3784caf90c64146343b62cda934b18a16f6f21d41fb6af2facdf412a9b11ad8d2b8c18fb29d435a31caa7fc000a84a3214e704da80ef3f23e95ad33e24c5a625b2baaf1f693072fe881adcd973cf18ed25286adc0d60ba4ed3852da555969515f16b690a30b2ae585cf4244b81f4a5ec9fabbd5a0c7aa3a3861c0d9a43103da6c904c6a0ed8f5d97031394995c21797e894748d83b2a45a4e0ac1e721eaa47ceb612df06bb48dce4e2e1a14654dac557542c2acd54be7650ad4a5230439dac56bf754a1a9340c67d9dd42","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
