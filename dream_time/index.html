<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec514a5f7536d8f817a60b6b1ea5a68f31741d5b7f08a7f43853f18425de16896169362a96d9f7f98f1e46f8031c920afb9e935feeac77715ff3a5f8c8e02a6a4fda17436acaae7075a1e2263bdf383851a1cd8881b0b698873fe406c5025fb5d75dc57ac6d4cecc753027c39ada6dc5c7aa1f814801e8c006630932b0d998fafe82e8d9a516baccba605b9479e1604de8578e9b5d9ebba67ffbdad5e352772075b14492781433a25d474ebf56ca73af3288cf0ce91b94773f69d1aa478a35df631b2af43219a72546e2b46332f33214e63113868e2e1bf6ff31287e7fc2d75a9c64c360d23d29489a770840596a633bab5d2ad64f6ff28f3d586910d3b7e1c56a0819613414c8a906c0f43dd5a6e3ca91e5a7243bc8b7b5d750c2ef8683031cfc55c18bfb8350b2c0e582f43070e2bfed2cd074339b278ed03ee31d5434dd26f0ca98fc425d8fc535cb1b138e1130713dc0aaf11e20fafd45233082f6c1d3eb3d79af34ff2dcb08bd0a449b5caa4109c5a2fc14036213aa16493a7c6482c1b9998802bb9f39aff78a68fedf34e5da8201c625e77695083822cedea32b177bab591f37bc81c65c0e39b767bba6bb44bb813fc297de4b47c72fa56fdb8a16a326d33cf49cfb3550fc0430e88aeabd73f0641315ff55811b17cb9e8eeb5e3617e16d3faa82478971b3e0b9d11643045a52af5ac3779cf54ab700be6be67851e0d3f815bda477fb2bb30c41458cc30567b5aa3f2df992ba9b67a4a781c30310bae3c48de2f85e78f83eedc298ae2c823b130c22701dcfa542f4079b309400804453f21ec99da6119fe5fbf17467347151ac35bbfb413559f3d1eecd0101c62b43e0a8a30ed84462bb1ab68797a58de7324d870f11d4e2643760b6e1cde82bb599fd4ed3827fb65037cd66db872639957913d8d6de7db6e9fcdf1bc1e5aff8c2d6a59919ebcc11e3a668605ea80d5fdd1b7085037e55a3dc5981a2e87b27d5986a70835385c1ad811351da2bb563df5ec2162e946bef5332a8f47e1e8787b5b3219e926f1e48cdfc3c1ff0794ddab8e1d8ccf155125fff24c584b9017896de42454c4c5d3bb32bdc00f86b4c1b4306bb915a1be2be645309b62c2d183599c6e51c14f2410021e731db61665e2ce08975b8e81bd43cf7b9e8f5df7759956a036bfca55262faa6ec73cfc475ef518eb5e135f4b1729680c3abecf0a00cbf7e27bd279f371ac5189664ee37c13d95418d7d33c63134db6c9ad2048e479d6ac5ade98ee4bbb085f1bb56a313c0e93167668d680cc30728ac0845f826b42d641d327fe14dbb19dc06a61937ba1f7bdb875461303171f0167f628f44030466b015fc860ad6ef550901110058558da8ba62d498f8ea5dc1225dc0753b0f72644656c857f662559e6aa9c63852826456179eaf5f30b51a4164268dc798a51ad1dcc216845bcae28df0cd23b751e2192e52a08e91d142c528e783b111b1c28fa0b1eea78c5cbe716f4cac0732096af73876991269e8e2f6a87da2c4c5ede09d97d7ce6e56bee1a1ff5bc8c809dd914f05d8ae6449f4b9cdf9cd7a21250371dd7dd17b3029234883a19129ab71f3d5fa398a69bfaada13b6f47249c91894edc819043a17779fb50bc7b23a217b502c8407160a47614c38f8cb9304cfd4d36d8cbf255b103be81a476d30bd3e6072163d940fa3e3a435d64f7377d7d1189632756fa7e873a533bb13f086b02f37040bb7c246954a4cfc5f44e0ea36d40d0f909fc40bde484a5283711469392fd740e25db46c38bffa9775cf8cb5804bcd2118ec92eaf875d69d3666b29180ab36a2ec905a191a6bd7955d90476d339e0b05a89d4a566f21118acef08c390164ab7e9ec7f05e8015419635412638cac17c28d9fe465ebb0467c72fd3509907fcad933f7b8f060214c2e2b2d623efc94c09b809f9b7b4f7a48ed623309af7e27167054375aedef53976fdc825abcd2e1607521647371dfe0a9dfeb2005872166c6ec43d0e199d75ca82367de8df87525f5a42aefd466206b9219d41fbe9c2449c859c648f8fc8fbc469bd87ce4b76eae227adca3652deffa06fafb66f27312f46c9760b817f76c5605ea2d1eda2da89a1efb9482e798fcde9bf2848dbf1091de6be1d80d22dc41ae7718898adbea6356efbb032b053850e5c91bb1434ed609bdb6645100524974b2134fd241130e6a2c5df2a4bb0fc16148e9ffe1c3e1805754e12029a4b69aa763d4cfb50ea9ffd9c096ef32a710ff43697112d28ccaa7a9e4247098dc178a89aa0d38b1be9dbeaa77c7d62c2becffbe15f34d666befc015064a4dc97e3e17520c65b19d6d608afe2528c02f9a5ad624e7cedbd606bd8624b368977fd8a1a50a54f5930f12be9bd54c58d456ca67ee54cacb7e8212786fc6af5fbfed2023fe22f7148ec7a5460e23e1f2680afef3f47c4c85e64e1ceedec3664b562edf23247567d1f4196240d47c10c46640f1805ad297ad12098b87c40ddeff1e88aec13def1c849956bca3fdfc64af83e9913153ece8b66ed845feadb61b0be17388e1a230636ca89eaef8f5f6092101e8ec4d098e14faf2006d2dbb22e4b8bff414edda93b3322a81a8e229b5a4d80190cf924b90929b0d4e71299d1a70b5044fe6acb2b859365a627a707566fcae596886431777cefd5c49bdb55071f62d6d1fbc9b4cc09a7e4ab3cee1ea2792898599a33370d57c7bb199c9b4237e667310fa3d6801d4b6077d2dfa4af09bab49f620d519e4592131538b65753ca4d5c53c886ea0dbaa1f9fc5c46d6af3b6bf69da33524214045beac90b9e9cee857fcb5dd10ae7588deef61c808174ee418da088706f072fa78acc9d5c8c4ba8410ccf4e4369ac2ae89743aee54d45d0dfb669e26e5d5ef22fb4c5af63b3d663e941f5fa28a9ae845b4896b4a14353e6c07d360c118e3fc6c92da822653b0e031ee3fac82bab74ba605f264c1f71ae6deee35a4291f72fc99e26bf3024d15a892816098ddcb7ca83ff18e5fa84f9c1698fbea8c50bc94e2b71f97c6c7bbf3f8f66838cb8fdcf1a0c08850ae2c56228e21fa273782a6020a6cd36baaa009530b548009b23096551a9d3cfe2510bbc05e78f9f81d757c103089e48f43448b18ee8430ef67cb5110652983797e1f8dd3b6e023e72dd9a53fd97c52661db94021acb1103270528ebc8571de5ae2b1ea273404e6ca66c91daabfc1b5f3adb5de96df7c74278ed1e53e199b9c67f69bab7864dfbe6d6db0cc9f18f892985a561e014dff8bd11ba4bcd031f260656ab6706258c6225dd0b5dcc27a144e432e2be44ab3fb738d94ae53f1b5bac5e544ccd87067c988daefd989481b9cd5f756e464e83668be3f722dc42cc0cdb7291f739455f5211be5e98f94f6b1d90c699c4f0c0866a312c78ebdb9b92c6fb7ed36ac63c3129913f2ca21f1b3a2fceebebb57db1d275f722255ca3814011122305170b8ba083931d89396d882bf08c61ac253e802bb0840b2d55cfffd1e6dc9fd845a168a222881915ba893b6f808b750988c5f42dc39835e54587d8858b0ab3d62f1fa68b16b1df7e28e76a65ab953a343efc6a7f5aa2a557cdd75c0bdfa8e58bcf419f58aeb208affb24274ec8ad3613d092fc1d5f41b899211590021cc7508204ef7f72947876a3d129cd0248ab2b507e5a4fa487abc4465d3c35c84b08a29656eef1df2d2b8c0fda2f978c185185a6dd58544e1628e416858514c96cfff6c6cde58c6b8e789ef372a4ec767da0c1beab2acc0ea987284176dac854c420ca94ed786df3d9c59eefea49ef3f82e4d6d3cb3d9896d4758a0417af0f141ffd2458abb2827667b1a0949ed348ba37b175850610847eb3027cb165af05b6c77c4b28203653df541c61bcd75cdb25c16b9c8b24ddd46ac0d8bb06d32dd3ddeccd1f4682160a427c6641b20105a906aea4a98186c951b29b156bfc2e6180c6918a7863d09779aaf236b8958c20f7f8dff2a6730ea503a22d7b63c6db4aee9b7ea19acdd14331d9de0678176d48898772ffc0618daada9ef070118e20fe46df241a6315b28ed1278ef9e9603381760a95a8c0df812f3efeb287c046a89c5f2e429ee6d0ef741789c81be5b45e60f59f5ded7d92c12e28ef3172008586c9a179ba6551a657561bf3a7cc842207b7e5d01e271916c3ae73b70a78de344043f2bef1fb3b3d55c6b10fe584f252ac077fdd0c450f57e091d980ef1a4bd924974577f1500262d19d24accd08818c2557f1d5f969a60f9b71ce9816cf03d5551c6ab50a3b3da1765cb68e22d750c05d1f7bc730fa81d555161605329636c0e701ebf60b03d9378cf9ec6a0fad76de5c4919c6d9d7b68e8d1462cc1518d6f3089d33e7230d5c57d1525f787d5704711040601bcb441e2c8a60ba926f079dc9fceb2e94c61db4d902a58353d73bda99c5c2fc60007538352ba78e62bba7df87f585e2f41b9f301d2eac0e4e1e0dc892bfcfb0f7a0ac2162b55c6df81eade68055dac98dca24bc02d9c9e885139ca2a29abab33d53dab3d63ab786c8840b1e2439a93930ed59c608d89d25e590b04db14bd978022b4ef2c2edf7286414c5bba3591115b122620d04c615da803dadaa771581654e1a8cfb6add2713ed94bf5c2891729aeab47d158df2ac517cb44561fee8274433a85f584c76fe407b2d30dd091280fef8be8a102762eb223f915116be2b92eca199ad7530612f28116e9a0e9f1e8dd0f3c3157104801eaac0062470402e91099f99e3c523bf34600c4b92f088e8457a7c4924b2905c2d35551f4c8eeac9c34f1d8309393be6aa220e7a3d34c5af5f8f631fc9e0d4ceb6579b91c79cf1cecb3d9349c68f2012a01df97243c6265b19eb402d56085c2d0ed191364bad5030ab325fdcc5f19eb2f0dcab3685444424ad8c3a4c474a2a65f2f9330a828850e6d63b11780e6da88e8466b0fa7eaaa0662993141679040b2085b1457530502d37811b256802abab8df40da3c09e6d74c4066dda52a79203eab8c4bc739cebafefb5007048cb43e6004c23a81e24e6bb45dc241f8ea796fc452096c3371a577f488d3ebefb1c9a55e172d1d84f561953fdc4c4cf87a4b55a6eda9648efbbbcf01df166cfbf0b3044de605efbe290f3b3b8e97be7ca585503dcee9e8b9230f6fdad1d677cbd8ec6ac7419e9fb7bfdd74647571f00769b435bb70b1bd45af13a36ae266d1165fa57a4538631c2fa772516a5ad2d0ee6debdacf936dbb2addca8e7f005621ec94576bca605704cc44a99205cda833a3d6c4eb2c97fc2982472fa6685788c57cbf29f999208c91b3d814eb916cc420a8d13069fe47987720800c72227c240d1b1ed24562cbd071b254b196d21196dceaaa4cc2549fb07747428b522eb7fbca0ba78362f7774bfdf314531d985d51d379c671089bac1c7ffd1440bd1c5b74f1e3ca63042d6b72d0c6a5d3d7b885ac53df152f9850700c481303cbd62899d406e74475caab795cb98ad6b4a211dd5164c1e75159a2e5ef79aeb6d6eae140c82fdab11eddff0c300fed5260f547e0508cb1657ed2b479b3e2ac74d009c4ad2618e36369950ae71e8792e4e1db2ddfbe165fd883b620e0a488c14b49bc45370de547e4e9d71dc7ac72b360907743aad96aef621f8c65b68d8ddeba086202e93843ce941869e79d04ce9f6d7861b1f4d1ee990d9e99d476fc63d60d85e663650bdddb87ef374b653a53d02140eacdfc3b4f5767b5ae6fb106ac874e50f33f3ea1b487cf0f37395755eb84d24eb258a9432d30cdfdfdaafd019eeeb32321e0a91352ce276d7fb2b691e59740d6c0fe0294df026ab922de6ec7110d92ac2e3da8cb9b03b83b0b2eb73b8e17d4babeb1ca5bea49987b03a63cfc0bbd8cec76db9e598ffcf90fb926616d8ad3cefec27cc2eed38d2dd38f1ff7e6a00d816263a8edf0ef0182638c27d967ea106b221a84d4530b786d36514930aa706394a3838b93bd425bab39cb1f3bf17131ea613b7340c6344e6c282b8533a8b7c77392b466f9b200746414673758fb48ac55556ad9ef35757eb8a41f2fa9f08b9eb8e7dcdf6c45a55d655cd7256674352c86ea04e9fdcb52487b68412be1eb1376e1bd3ba475a8bdfdab435ece7dc8e12bf009d9fc7f582ca4847b31d7775c0d6754a21ef1dde1170e667ca139c846d74b08f711d43f3bd3c072520ae47daebf6f5ba7fa77b373af04187ad08decc65c73d48a033419ba1c8cb621232d66f0628b6c97bd496d96637ec1cf73aa2741f5dca67f21d93749d7646ccfc4c81c9749c28782b8160a64e71541f31335daf820fefcbf3744cfd4a60eab216542516c3f65fa56ca36586b40c5b9b2af731cd2acdaf6804afdb5b4a80cd5e4e29353fbd3ba12843443f84539bc620abc25a94a6aeefeeeb6b731309de8fbf9a50ac2733ce95c7f6ff34265b9afa72912eba7998f7907e8dda287c4e72ef77637be066e110175a388d125eb1053ecf054c328720b0d1bd686c1ce258e9a4a939fe56b179b575b92cfc685375d875e9f60e8ed292af694c70eddd1a38d6ad62dc44326d7a5b175c09269c361b79be584c067dea71364eb672c6757cbfdedcb33c173bff4bfd31979d62c878456f4d804d53865e2a7bd6580efeac6b7fbab7b963df5320eac503df775e038b8687a4d4e01b5424695ef4dfaeba8f0b2f914058c4f563e376e620b216bfce9cd8701deed5b1c2c6db820d8c7be4f060ee6058529450904547113d8671fafc5f0ccfc56307372ec5a4a5415c63d841db792dd70fa14ffc010e5208bfeec7fc366c91eca2de72b7e4b1ceb439d8add78b6c94c1686d5cc7cc61761ddc3f9500fd8304fe045c2db1a38314552eb868af00f99b614233b7fe2c3006d84facd7e5fbd531e112f2843277920884b6834c444056ca200361f890eb1a17462c345071b6fd3fab345aa302993a164d641067370c704b48e82a86a47cfcd3f1c00f8b0b0ef6da5d7a9e4f557f520bd5e16daa5fecb078389af21f9d2f03080cf0d47c5ab32fb0ce9516b495483c9a13a36d119cb34db2e55946594e712bf7abd4132bfbe1797f8d9339f60104a69c7d6972aa1f2c5557144b9faad6ad276c25d7de3519ef179cd565b0730d639daaf24ae0605b52f523d6c6926ed818fefa3e813d1db71bac69f86d2cd6485a53adebb046a686fee8f19b4a0778a35142d1f3612d193a9109e2064edc641886d65585a17449413368ad0b917a38e0158dd8376986b3d2254021c7745b86863cff56ea3f6b7bda3a7ca069203ccb3ecdd1287a743ea9d6f58017c790df52a2c7b9e3bd3e3355d33c61c15d83d72ac5851d037dc4e184bb1390d3efe170cc870763d68ec364196864c363204a1cd48817739736946edaeb0eb0051a8ad9e5675f174d025feeec664ecf716a7fb9cb4a7dd21407088fade66f6e5fe9e990e7886924bf50be26b36b4b41579c0826978a336916a0679f9d9e04241bb0d94cb117eaa21a23aea14ca60765571b6b3883efe624ab064b4fcbb3a078767c3220f8a2002551d0bc61dc8c1be2c2fdfe9703f275aac003fe501a3a4eb52820f7b7001adcc0be7883637840ec235d9c7eecac3975082987993a56fc787c5b9070149bc52c5e85bf6c20ad6101f930032b7223c08bf6b525575c51e56a552be7bdac5027552f76e468fb43b6254a42d3918bd9b4600a2530c4555cd7f7aba7c0e87d6b40e6171925bef1aa8fe90f18f56b0bec69ae7592fa6c4148ae49311405b63326a0536c5a772a1340167600d0ce7855808875a9cf8296383ac1139ed339175df80235387c2aa910c65362531e63bda273e1a5882e70b65cc05e7a6f9731dde3163e3cf4d22b29fd0ee2b69135df033fad5ba7adab7a4da5cc9089c03b363e36b2597f2ce673eabb01e68c4c21dc5a3f3f687b87b744ed173e5ce203d0609e46d717d965cb6471f1605603e648dc0e5a59172f98cfbc2597f8c443b09a8dc9db6c7c9bdc16c3fc258b6407f43819ba4abe80b95aa3471dd495960e47af92ae41585dad4afb2a0d4b7f5eafe5d48817e1a2bff7a8c2b8c42914ab310faf4d2e2eaf8a452dac9fd2a6fc6e427679a4998e0762e5605a87009f17b35fda113edd8c37fd7a401ff1dd9374118f84531b43214d1199140394fa257549af26447ec41844b7d09dc809f88d0321f32edc508ff874fe1df2bda9f2673455a91c5bed61aedb12101a21ece29793505d37f7b31a8e063e6236037934caf01354a7fde0cac57afb600eb7e8be39c3a6d1e762e6ccf4a4d3ea6a8deb17988c06d2d3236c6b748322177b1c30500cf318b9c99df77256307aa3bfbfd732294d2e3ddc37d28cab9a3136c8b97e75d9144a1ba2428516a9b8406515e9df61f893202120abf2fb66b8a49393dde45e8a03a59addfd9b274009d578a66e0d03faa92dd6cfde33cf399c9131063201458a54154002bcccb58ef219cb27ef858d4b406f4ea6091a8ed5309907dda3f8ce89ef3e07da0ee74c8033601f77e0b399e12c2a05e5810441cd6dc3c314399876797af2d14fc984ae63fb224219b0f4d0ec808924e2113267a79e8b5cc13ddfe06c554fd7debed90868edebcce6d3cfde7bde47fb783bfb7af56b94bc66155e8b7ee6ac0d02d54b4dc1192718526015998c1c6c18301bde7462a8e92ab8116fc52d53822d575eb90c344db0d72fdbc1a64f4b5a0443e9783f72dafa67230f87d8bd3ad07de74059a841e734862147f2aa161c569cfcedea054deba308aa0758309f0f70920725449ba941427c40996db31fe7f925e5da4570f9a5f0ea09102924c3aad0d0e97c7903173e0cb7b0ed1ef6d247847246fb1f14059ea73542d3d71153316e4482b8c3afedc9561abc389fd4ce7386b6a706c24b5932d169fb6fd451552a57c3dfd3987100791236701c598d4f586e7f34524a8ed4ed5a515ba7172285ee8f3734bd87afa64b6aa1c0c66bea7b9fb7324ed29825ecb0142498875a2985af7d1a0a4867ff90d2b7cb96e0b2add35db999cc6ff15a3d47072ceb83aba8cdf7fb7f441a498b946a2db98c86ed2b148bafd049138c8092dc4bb6e294f6c914a642cad0e6ca91bff0f5f172be18119015d5bad230f01cd3b84de25786a5a4f305ca9504fdf01a6e3a42b82ce6a453f181d16089b547ccd623042d94eea07d1e5a8bfbba7d094d618fba46f118a80b99b33894969a8ebdd4035330d5f647dd14305154ed83b8db739329322bb31875413be7d7fd9faa50578bee1a4","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
