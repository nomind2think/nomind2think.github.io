<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7bee008d01181e28ef07c2d148d4142fdc09e419d256ef8a41376a9e8c091d31717fb5313be9047a61efc6281c2f074277d3dc82ae380032b695408a87eaaab7508124348e1265ea3569408f7aa74b7503d5e0ea00f29600bfadafab41ce85d0ee6fb505dcf88051e1eaf2514507c755f92510c11731f26c1fbde082601f80a54f61d94e015d60b4a39d6d5c6e9868cdcd7d98e69db2c716ef4982c3d3c9b4cfeee0d972da18994e69465b609f76f557b0f52407f253f9c137daff12671ec7c84952e368b1b8e4f6ced558bd09ed1cb6a53e901ff223e1d7510241bf62bb620db6b20d168fe52482d5c5293c3bdd7d7a979d55f1390e21ca2f5ea473cc04f129df02afdc9d0880d6af07ea905154da74a28168aa5e738f94bec0a4016b26f4ea1431243a4be2a3d9dd5c81c2659b4840cb3c44c20f8c2c1b6ad7f9a3bf7467d8214ecba53c01258bba2de3be0c77498553d714dacdafeeb7af41cc7323c0b3c7cb326767c0d4252b39da1091ce7b7082f21cb9e8695a6ac44888b3a277bb99014feef58690d2cf05eb2e94a912074c4f4ba04bb5060ca9938a63043c196bcd700b690dfcd9f8485557efcf6604b862d0114537c3fd85445736343f80edb1e50250bf390585d4a7e73433f64658174e8c75f6dca8e1e3de91ee262b5440ec0f7dff9cbabccc50a9f0914008497d20ed291df549e93a26b44ed43122a8ad33801b8d9ba9315774b18765186fd1d13e09e1c199ee44f1b5b6ad74aec4047ae0f8ac2a544c5467ff68bd12877d3bb0570e13605794d8993801e07f3b68074a87fd24bd0301061bc3ae534eebfaef1f4b2f50c9969f8122f7e868b5e629255f1df5c1f8ae30255b2e70afd9bae8d6aca68a4ba52764715e89b93b6178c3755593d3c643bb304659e7db08a409703c8de68cd75a62df0fdee1e9e182fbef1569a6be463e33d946f071e71562c017db67508a772f541d0c8ef3bcc42de7955de8f55ff446c580d3c261955035e869f4d10cb118dcafe9b01decc924e122383044cebca19d84b34bf0c0d654535a12c37c1f265047fc46fea08b24789f06667be439b0320c68a70402912ae0d2bbeb1b9f7c2e002882a20138cc9d1c1a9f67280e0be9a1f0b7338eb32328c327e6aa92ab2f79579ddd71b400a08c7be4996fc6c008605a317f14575d8b09efa86990a6f6fbae459887ce75ad29c7d1dbbf85c7dce7324f7904ddcba9eba3c023b67a448d3af831114100d079b3b260a93e826b2e2203ae188806b001d52e420998b08906a51e067671215ca59b078e0b3937ba0c1500209ac43a90f2f726c8b2dcaea1fc3375d981011071934338f7883345a9058b7b2b12c6bed8bdac19b859cecda71421ee29075c85fa4ffcca3c68a41a21d5f400466bd0641ed259e7ff0eb66134aad9eecdc2f1707d658f09cc03c27385576f6f5ef9fbf8f2f30a424d5d2b5f203fd2649041ad7522b8864046f14dac4f062d88ab3c830452ad73572c1f114ea5df54f37589a48e8b81e56924e210bcab155419b97193c31e9f70006d2942b0d8139320d1cb6c7e249e62df26e89de862e4308fe30772b440d34c6d704283a277e654848ec4f9efff27c295f0c8fefc6b3af9c9b692ec9b0d7a26bfe0e1bd8e29f8e880981466708de934e9a33b30a5cc75eb1374a0c01d5820e1f1cc16a174fd7f268b3162a9678d2e619f5b31b6c7b1ce4ae44537ef8deb63562527e5e6d4bb63246dbde949ae2a546bde3f9b729de637dbe3694f2f74e6006460e321b721ba068e7dccff31a8d3191ac09f8b230b098c0d2989c49f3ba995a331412294bd78beb53602692318745c7246c64dda659d49e64a2135b551e644a4d3e5ef7069141f5f7a0844cfbca04b002baee5eb07544a9ea5f494bff5330e1bbfe004c4412794a8f049474eef61a79f79c162b52e1f42621feb02d5309457e5fe04667dc1a1976fbc945135698743e989f28db95e112602aee2c07696dc87246aec5b855cae150b42cda4d2239c89425f9262076000184ab59ef7f944dabec47bb79bf8ca37524b5c8f5cc30c8e51ca679a6d6137b07e7ce79c5daf1e63540c4d36718dc633a261349585e7acd85700081666d72eaefd5d72b6120e1a3c4359be825f3777319c1e9b41b1194a929bb7905c1122f6cbc39069bf26da8393987f51cd446a7cb272655e67993502c85d3af6b9da1018e77835dc43da309696f4d0f33bb5a29d279af4b4a09a918d9d32791ca4bf05f4a013a48bd17f8e9fb999534471268778e0efa6208582848595fe383a0499f29611110e3d3ba77f3f0580bdbfa7d75bb3d73badcb3c0ae4f5efaab2bbfb549962268bb369638d5695e5bee0d39e6d18c66d512056dd4f9e40c4b7a8a5bc9e5b99fcaf8bcd92e79fd7011db90ff4d43b488acafb4f995118c9339fb83135b9913e6aafe5c680dc5bcae655bb958541490972ace68479778bd30c6b76d658a494f0dc8b5286fbb2f2f01bcebfcdecdb64be145d80e014a651f6dce86d8364487eebf7438cccf7c7b9f990876bf61d5a957f94a76b260e5f020b877a55925decae6f2baf1b78311e1449d11cb1fc74e8ee14628f575601a572d18a3b2d882a62f0fa6d5c335aa52622963ad75ae4812db432a5d98ee2d60016e7e83ff2464a757b1050a2f55aa2362233878acaf5ee5ba5533e4112b804d9f04616d676288766817f23ba06144542c4bbc55bff2666e5747942b9bb5a36652e2cd89206214258907c2ce057e2584a168bce23c5080e27cef83a30c66ec5f861b16248805c61caddcfb2ef1682fbc5d6354f7376dba2bc6a03afbbbf0a953072a4a3abb116a5fc1bb9723812a707b59bce2ef3cb61105d6f57cc89607b6aeb6c1a5ca9d304cb07633ae8568ca7dae95d65b7a67b05d963bacbd34cd1eeb680196f79d47e68abb6478efdf1dcf34d7f0c14fad8f0859db18f8c207e2d69ac75d2d15fe9d89e9471310df57df5dd66e83919961ba3cd498b072d73f262591f0be5d2ca316a3c1ad2be2f8f91bc93bb27b627bc3817e001f128183f6b2a6dbb3bb51dcff7eb823525fd51c8629307dfebad59cda28d1566cf51dfe79a5f5596611dd097412cb00743bb07ca59b95b1a82ebcbfd49d2945181182e63b460be2302a7e1f4f53cddcfd0bd5717ac35a01cc5f8a78c46dd265daffd28c964ccc2b57a323414c04494cf2683cba82c47a136382f77e0af5beb69f7f16b83bf0afdcbd9460d4e81a268f5563b101e2cd04c540b53b8f86224abc3809e61db355b15a015068e04c335f3cc2a4cb0095d68dee40b0db974f1977db2206e920716732827a4ff40d6690c89a2869f6f1caedd70dcb97efac523603e48418ceb1875f5bbec9b345875a09996e6d7ddafd33fb856962b338d199da7a51d686360ea5b235c94d071ee03d11a2573ea704886dcf49c743a5b4bfb0f1836c61203a2b9d6f84f722624970e070f8ccf2cd747e26c88490470729f08745f3eaf1ed85b575ddccbd97200ba11e8502395bb36164eb77ce13c75fcd8e24de433869e576b52b2637fe68bcaa8ba268ab50ccc9ca7d550748e98b5e3f1644c6ca4d83eef0fa1541e274b498b180a901ae81041df55070410eee6d0c459f6de50af0191dfa374f7fae6f2c4776904f2df425876b41ec6ecb827bc45cb06242cf170dac7484e7d3707fe78c2d17c3492252b7df94c9efb2c92bda8320754c3a8bba44e8d208e0f153afd66e3b12436b5d4d7bdec375c402b4454b49a4f3d767eff06125eac58eaf9e73cbf3150041fc00cde07a4b4cdd0a4571fb4318a4fa56f302818d1fee630415dfa1ba488f3988ed4080d4fb8502334a37741a4ef44fcb4d31bc8850b7ea534464aa48404a1c1ddd70c38ea5cdfbae3f8ac5ef6ea52fbd1baf0b8db97d84b004e81c3b92403925af4d7654789fff8fa0318e64bdfec41dbcb5e2e97f3dd7fa63668e260675e2eaa93dcc5773ff470dc1a4a017650b0f124414a3c88269b608d9f5e4637ee40159be4de4b299dca85b6847eb50d06c564f7941fd9c21e3965872f8a61ed613369b2b6bc3554a778a762e79f9db29ebb3277c73866930b2ec6030f8f4d03538640d2610f6182ef568a7e4075d7c325912fc705260663a30287b9486d083c42ec46de3b3aa9bc8e222209f194be6525e4dc84425b99889a1889c63d93cb17932f36e4990a5ebdfcec43e4ab97a02b709195571c6bd434c3c99245920f72cba2c6178c85d40f5b4458a8886f6d973093ecd8f69f23c19af55835b5600ddc99d0fcb31ce2edfdc32e79578a8a41f60b0acc8ffd04128c99719f64d650a39a0e2e929a2346f315d2bfd2b7edc3fcc588e6f725c7351f4e986b66792d3b1888ffdd2f6cd37affbc336e58460b7f505fda5e57c0f3935469c0a82a03df7da9e3fe35cd6c859c764865018ab1c3c9c5f67ef57979174706e4182373fb9d2eb893d087f0a0d223ceb433e3e8074a87faec1a730e1dbf1c884b07ba2577e19710cd66213814df077dad5aaa884c1fb0e52111335f29359da5bdbc6135ca7461f0bc9c5e57d1c1510843ca7d6bbc391b8df7d671449458156b937b19e93e5059da09c765270fbb5cbe5f3c5ec6fcb3da453ecbff9d3b88b867cf279762eb6e9a11faa75b8a1255d228e1293ff731a052860dfc11f63015d22023fd6328b09f5d9b403dd08d1029daa2919924ffed39cbcd18df81e9ce22441757c68eb2e059569534fbe63000901228c37e3cf41720a0ab7e040978090c0db5376fdf7ee7e3028f5601f1181e3a8b9f8f152532583cf97746856e79f1989c4a64641a8537c829287944be3d48a2f7840d8f5c456c09775a9eca8f32bb464b102fbf697ffce5ea66621494f4ec391c51aaf44d37d5434c9a7e70b9aac0b8ebd851a2e1fef93159075586bf9e9feb2b35877c2c33131092829bea0d75e8d7fdc4f86eba5422af4718589a6c1c82b052bb6ea7c561c5925d98216bac98c49c0a47b5e4d920e6e0ad5358008463da407fa130c718743ffb43937d50f421038bcdd8a21dbb6f74a53587f550c14d6b709eb444161adf0ef110959a97fc2ab02a664f349f296396ada025b7e6e5a51cd05ad3e8fd90d01a468e0ee109a5c23efb2108caba6a020725a310942cd8142e3b186f331d822fb2c6be9b30bfbfe821312cc933e45fab3457d6a903ef1482e005f53718d8d35282cbfeb62a93fce0c94713d4d3d818bda6af63bfe071ebbaff7284786885aa21c7419e97cacd03d894d3be1a995b4aae709d97d05dcfaada031d9fc9a761f4644c5b81ef70deb37f0e52f10304461746c8cb420b018f123e944bc2cb239590c930e70b6a02f31d4f41eab94eca91cdf464bda43b0d7a012cdd7f2965496231186398ca780d4d7db662ea713e6972ce38f2dd7f1715189aed9bca57f3af32a1ca2bb998aa3f7520a245021dfc779bd29267c2b27da364ec38fc687844a273fe8da17e51bd2380af072b09b855db05c44e0ddd43224f7300e6897b27e3763765f47e2991c41f53d9a9f51872e5238fa7cd9f855486f1508c7b76ed4693425887a731082ebd815c4094604958bf8e4f9250661a9dbe40f3b2110c11fb81446a6d188b88ffa2d91b71bd0101da7ade73c86cca2d53624691ff5151a80ddc95fe5ef07372885ded73a106eee89db281908b8c6c0cdb91c6dfbbee6a446f1606d29cbc208b5c1c98d3931e2cc4f2de9c13c56bde02430e23a3566abb163d7f1d7d7ec3eaded29949f058f46fa1c29bac64fde0447acb56d46a1d717b957ecbb069f1875012de8619ce801e3e26af74eadfa15762c6757e6c4e9eee4ce86dcc5b017ea71e64759f7130a4896968f87a0ca7304f2842f70d787994ef2cc45f653437182e8f28048bbbe259d6c1e1cf3e2d6c2b26289b47d0615c073e1088f75f6c4ad9063c7c796951cccd6e4d36edd74213e7c82fc0047c8a8795a89fb44f6ee23725c40d786226380a0cedcf78207b83c18123f096b067fc28f6d3eaf0a7ce0e0947fa99f0433c4e8a5c2af67ff11fd5c930c623481fb28eba0897ceb6d01ee3e6ce97241e7183d98e163b7493faae39fcb4aa62d0d0a93e4aa6b16f4f743e4184d3288be052463abfaf9d4a233b48f236fe14f41334d2b978ac11e0b688002e1b39569cc0361fef507a39b6f895bb28060fac3b6405498844c73bd712a07c6b46ba11320f9ba420efb5e8a727354d8120cca88397bfb8afe8607d6a2f97287cabf06f33a17c839f4858dfb64ca3f6e097f27be3ebc2c02f33a4e4c7f9d09c8fcf28f7a99d22223cfcf12486c41c4c0b7514500b34b9c601a378034fd7a17c89969a5ca74f7bb64964e3be841de9f34d00cd83af0ffe5f28e248a3a7467e50e9b4254c6a955126cede7e8bf6646223cbdad1c8203ef918b12e04337ed5b26b073a2056d28cb7c903bca2324883529de236996dedf1064d6df883ceb206cd390b2f740af95073bf5adf3c19848de6ee2e61ab88d99b35f139f1b9cff6f8b048c51f6d0d093df2b8f9b2de353261534ba77f40e27f7564cd71774b67c6d984f9393dc98ba18f35cbc8a66a3a08279260247cb3f038fab92612e25417e71548224f7b927fc5f92506ec8efb3c0891c444873e05f23dfaedf008fa9ad24cc09ac359da072bf92ffb6a1ebe01328f9329659f1b8d2d196d1513ebae9d5ae540e53068e36cff81eda8f570741e79fe51666c6112b70f35b2e2f9a9332e715f2e66e3a829f5f12e0d8e3315fe938dedaeb7fa18c8394f313a8ba247e260e64264ffb1471750ee439d01a5e22c773e16faa507ee0111fd3f0c02b9ad038a8aaf62d6128603c98f0e463b647ad489f5f1de053e332586523bc38e104382b44d11ef4977fc628d43bd58030527995b1bb5c97be2cdf3fde1207d279633afd59c8362db89469a4edd8f0c2f131ea832013a38c987f91a9154d98ca8beff8e4e4d271ac1d4d820d8b1d834d45213b29a270116f243b8ef8e47033e30d8141a82681e2a7083b76bfcfef33be7a79cb790ce9f029f03b761d19b4baeaf7bc28527ffcf8991be52aa4e764c83cbaf91df8718bd114b0a6f8b61a60ba7f88e5957e83806b4c33d4ab3e8bfea12ae14a3fa224f3a440f53a6a59fc54f1e1d5d437629127dadf5e3668b6689f79ae704dd8bf0ebe4393e42fe29c462efd33577fe5cbae1f6e214cff61056be8895ce8c69324185804f91c07d9b4304f33cde9be85ed5bfa4332616d2231955925c4482e190c7fa754976eed85618d850c7c86eaf49887a5b98a04ef513176efa2a05e55b2296294f8c481646641cf0dbcf7273504059a7a5f81a51c8ee0a3497bb3b7f5aea42e3418c5f62f24072b7c0e355b49c76f5dcad1e5cadc181410847fc087529ec95444ef8e417a342eb6a39888d8d5f32072b5ea3eae7f1a4f109bc1ada4c62da5ab5eabcc03b2b11d7e94a1de3384940d47bd616168c44b540f4ce3ffd4e2fd9d80823b7fa2f3bd3c6a889b9898e0ed56ae3c9b8197359e845d339485ab5dcc8b415453644cad20b31c539ef3d191b5a1ad704357f88fc411a12fff1a2f8e85eda93675a82b6b63b121cd1f6455c45259d2fbc81a7090361e1f680b105fcfa62d2bdc1ba082b0e7f2a406db33556c1f6d2329d1bac386f190dc1f73af24aa06bb7a5fb54203ac51e74b66a26e9a110a3a2e3bb0e236ddbf118a6290134436570a971283abb6d5bbdfb1d7ba7f6706f0a906b11b6dc3031d0f3818362572bb6ef22478851904d51244be902ba14d781d802ca9efd5984699f948626b9984580bcbaef0deae568519ff8b4c38b07df4e9f3f4acf2c165a4dec715465f2a5de4aa1fd439b0094e8bec567aea07bdb0064e064d0cccb2fcaf0960e3c4adebc59dfaa1927fc1bcf4ef76b393307475bcc95fcd7279529d9c45bb11a035e45a8d97827055ae0a3de20548ad882f5595446ceff6e4363c2b503fe15ecd7edf2f0aa651a62f32903605579b05b0eab80f845363c6958b022996341f48a4c17570210750b2fb2f3d97744b421c125be2121d2cc56e2785cb06b0074f2b23e0c5bec4e53e9a98a3ed55a8a0c9dab6f9ec8ce75040ebc2079119f1d0a87a83a6ee4068ef06c5a83503541246101392f7d51e085a92d8404ca9fb68083f4f84fd896fec10a26741af2b9073b141efa92c71bb52cc6005126fc549e9dc0365471a2e8342759f2e6c932093f642f889bb19077b42ac2643eaf0666ed46bef0200ae2a116b001825cab0f62b8d3e6124462c9e2847f1fa4d3c3d1a4c8825fe7897595404c5c6d278f784689614c94b2996f6ce7b5972e98ca8d3e5d9ff362205db8e0068883d0185f9da386fb63e37a7636433a73845386a79364d5c9350b85b26589a64894833da3551d300a0b7380b3ca7d88d4f730b15e0061c431f46ee423d24e3a2fa019d5adab2d0418a87fd1774158dcf8ac9e8b703cd7e34fe50098f1a701d555bec3c1f13c9546492c2ed9f7a8fe9ca034f466268667b248760620072b3861005f30e44d97233556dba33d476094b6c5931c2fef5a218d142656cd67072280fb2c274ebabd14f2541e9a154dd5a3b71310e1160b8d8295466260e799d15b1267ec16d3315ed05406832f9e78154d52542461ea61dad1cdea6268a0a2e46c3dcfeeba4394f95aa14c63947029286b68fc36608cfce26194b12e0ed89eae0113f13f5fa0501df3350b0a0355172c539b1fb0be492094d11242f1d52d14caf4901b2acdad4bd677994d6c4f126b8d20d4e51f59421cecae99381f682a4396e53669b3a7c0bf4ed6852046ccfd178f3bf18d936c5d62e5baa379dee5820f51a0466857989b45d5decdf047696480fa5f323f3b3f090cb0bb3b03f59ddc5d65309fef75d26fa83b70b889a20ba8c47730ab27cc9af2650763af6d14c83c26c0b44404cbcbb8157ad7da368ab776da430641ab952813d34cc8a4deaf8ace073b680768a152cc57f50bde32097625274e9b4d12b9aa500c734cba87b875c6830f1547de33f74daae011fc875c4e33298b765ea00b5845784f5ca5426697a7465963517b82972abc0ff7091237b6831d6d097a5c88d33e8c64cf93e2c109b276c87fb36bfc53105d52f096ca34e00f244f89817c8c53a054250313b2a8537a02cb1b9beee9da194336ad386a7bd44b7522a60d045ce83c9b24cea18e8f4c9fc20334407203bc53a22c282b72e838ea3e9a9f7d119335351347101f9f899695f0bde2dea2f42b4f578e8c8ae80097c5cc41d6c4d923f3117f989c5e7add1b418093c194f847442d11eb075061ecb22e98fb969c00898bd5c2393f5783e656c7b6a6df255f63d6bb5c81c6c7049fa1c1e4d4a5bee139816bc678828b94d06ee8bcc55eada2a594f1e66d797df7ce49846315595b93a8468fbaec8f66968ecb111e5bc18442c2f3c807e967f52316dd16a4af9e422430f302ebd7ac4378a665ab1ecedf168e6b886639b840efa96a39e1ccf7d97ac51461660dd944f6c200ddae7e97d643ecefbec11adc0827180b8f8f91cc308da1ea1616d8c34ef1754173a5f3a9a17cb81384901d32eb94bbc017e1fba37d083cace4b4620e5c375f32f58d1d41a444e0a132987981450ce1576e4353e8f29a0878b513cfde6983e2601a4c34f6d9df5ec6da15925a3bc4938cb3235d14ebe98589139e42b28ee8bd6c6c3bf7e9b5baee226c678da9e162d40678466918d9ce4d0cbcea57eb8995e4ed4d7e3e75ae7e35f4a4cf31aefb604b9956d9b9be47b6592a5791f8530123ea62861940437668827f8229e1425e89b950971b7b18960d477034f6acd9c47523d8781876f7e12c511e5efc877e8b2de25889460fe8a23f2b95670172b2b9133af44474bf57b55ebdd8951367dec305d5372946aac1f89820e34f8cd34dcdebc574b3d2707d78a54fc92d3cb9a9cc108ea4a855483ea7c5b0f15652fda0668d4b367e6553435cef2e2e10924d7960fd1c5068890f06fce6b31cbdc77e6e1022c330494da916dfdecbae7591013b6a442a4c8e266c35a2b985f2ed6e00024733e487c958b5c63ec8e3bcf6310a9a2e677cea646653dadc361d77d081f50d34b9f36aab99eebef31ce562df013b902bb7e4099a3a74725abc34fdcf378b695c08c6e52ef23d4378a98423d228a747638656eb4a5284a1b079600570ca27f1cf8b4482fb67b0202e62dd544414508aabfa9bfb2c7681fd686625f7aa1eb64c0096beef2ce27c88c4ae27eb9c3420235ba93039f9c8ab8dd84dedaf3a17631c290f79ed21430c2f01cfcf5cce5c922be2225a19af6f17b4a97a2097524f48e62090269cbd2015a1814e8241ccad406e8480b70955ddc4716be683a240426164cebc1edf6c6b6cbbf757e73fa1d64640c0e215091f9673f92357de1fb1f546899597ac7f60dc0f7c3c13844e7b0402d291c72554a6a2b6ea147e93050e6779350f5941a6c5914e893e0140a0da103e953a172eab1c1a6199fb96ffcfce30fb473ed33051d3e45b4a6e62740b83d5ab4e17e9d30f8aa14ea0fe3bc79719ceb0581cf978552aaa46db5f69ba6ab6c63596f7ef4ae8534a6512b49c9163f41532a1a88e78a6aa3d66d8ce1476e73892a3789b70964dd9b9e16ab58db9152a76da31d9de289a8632fe7788a97759a159876dacd205dae3e3087c78aca9559e82d6338cc361704ae16e6c31d941391d8ab45b58d9ba8f2fd0218423fffa764e7b6f7854f93e790223587aa7f141ea691d0624d3b2817b80199b7efffd230fb20dcf9e70338ff3f0ec771b51d4886827022f7368d4c2ee8cba1befefeaa0abc560aa6a7ecf50a030cc2d917393e483a6c7bf238c2be237a60690265905477ed824e1ad2e58cd219f5066432c4bcf3f9316dd31985c80d737706a1b467fde3ac22a52c6fb6908a5a523c0161ba9ae77ebecba820c286cdda21b0e389793339bd32e1d79181285432bf91dfba816d1ffd65c9ddec3835539916ddd1d5229411674132a34204bb00d81e05510ca5f9cd49a3cf2730f3884516d58978b546c5c621ca81b7317017cd64a5ff2448381364d60481a75b4c46478a81597d434b2e19e6b1f17a67c7f9c46e0a02c224f1b66fc1180fa61f58821ccd0b370764b4ff64492604044f821999ee4d2bcd1ed2c69b7209e2b0778c23ea0f8f9b7ecde359628b73938e0c76f9a0f4584d3bb9078339816e02e7458298b7a6eb6b48c652c88f7e194991c7b6701a949547edb538ae10cfca3e10f2d0846fd6667c521f8dc6c09baa47ea6db30747de3ebf140257ca19367733e128fc89297269a3108a31cf6c6c0d8b124b69a62058788a43965e6de2c2ad7cf46dc141ffeec4233035041a1393b6f1dee5c2a783542d51713e8624b1eeb26e451f1a2d254b7c28cf62fd0a3bcb52e55c9cd48eab1f23fe7e97f7d1e722cef923d34d858e0d5459bc7dba54677868ee62ca2cdbd9b88c9e7b798d668a230a872c4a11550f2d50ae8dfb5a7bc90611220a8abea91ce5c18ce76624a7546156bfd1a1e66aded6cc838fdaeef0ff6b2bcc1c5a032b0ec0501b745badd12598de7e48986e4e68f23f9c3f66aba787345b759df76c52421c261954f578e0625d8cafdcc73e53b87d1bd6364f2fcf8fb547ef8b824ddbc5e93ac02fdeca72a6f17ed6459a1358916b1e81617266686d1750a620ea050ef0ff0833d262a92165f7a963c23f5c61984479d2b58d9e43b355cb7900f2e60139edcee10b7e87d7be1b506c653f2ae1c4633ac5d2c97ae33ea7e988e99bb94f3cd3b8ca46deaa8b11f7b0075ec6d9074e8315369b952b182882dc875881e45fd4ce6b99b0abae0d5bdbee602cc3978dab38f36dc2e4b1c70b4cbbb454c9e66a9919c3da14bb50d171169422235971ab373ca5d0389896d089908d44c83b9dd560bc87c3311e28d50b48a4156e4c02c7d9f7c37cf2fe9e3d5cf351140c39ce5a14a785c804962adfb5f74ada68e8288122d3be63f679cf456b39f0c1445ca1393fe305925935c11cd625145416b0eab0cb6c107c0561c82da3c54a9b8f342f8ffdb781c0f8b64a8c708868985951d4cbba348491d027469ea73416f33f4815e1a0dcdff78ec6afec90e3342da27bfcb1b583b317a5de4244e29905bb7fea42ed5bd715f92543fe71a4c98cbeedde51a001da9fde1b4f978e60c16ef0cce7d09b793fb738508c7ab81c6d78ba29acf21ece691a388122bf7cf0229aa73794aaf3956b95641811c1e74d24f4e8b3f1746265b6b60c3535ed4a60737b04c88b6b5a4cfca3a444bfd20f8f190ac3284e111b46976b835cef621e52bc09cdcf099bf43f141da9779d822c388d7f0cd0e4a539042265c8062d1567e3963dae830cb82698daf07ce3f19ee0386d466bef654175344367d787d5aa9d69e2bcd66320240826768372baebf11573a6d9cbce7d3b8599274c7c2f0486f2a0322253be3ecccec6dafb866801bb38d1a4914e742a1f19175e029a3a0c310b63ea97b3e0821475a570cf44455f52cbe4a6048e596aae9ab934ec6f51a7170d8b5e5792ecd44798b3035b42cad0c99f494e03ce308db6bd920e4517011a49498274e55803e3865a6d5f1da57809820550d562d591aa72a58dc3a3650c320ab29b6d678bb6e1bf2b312b1cd5ad382843586c9636b60aa3b3dae69b6d14680b55be8b5519152238b57d3a598fdf6a914900a7f04d825f2906fad0b460bc3242095e0473c2735d41c41c2d952abfeae79f618d3ac81ea327e5820346b4c4d56a7bf03e0c3660555b25ddc0545ca02812d418686c0acdeeb38e29d3a4740e1304cb6082d01653ed2828c1cf9707188ee4c15e7e5d3e9c8db942ee78445175d713e6127ab12e9aeecfc88b95b715936bdf87fd43a5f9a155f4bd20fd6a5ec327c17a283b328550758f20a38d5c70112949c26f9e9c8c5bd22abece8e7826922870c7ddcb0784cd40854a79b106520204755d7d2275e78bd2c1a35d84de0232fedcc009fbdc99952721035ab58e279446bc413bc12c7fe1e9b01389e660898cc07d6867430fbd769183a28e7e07c84d8f36af3f168031007a1b87fd9f3762a6fd54160691e6279c12f3825b770146d0d8c80e17189a8889bb0b1aec88525909ea6d08dc695145a455cd038fb1d760724c504176571067c855e207e107f99c649512e17ac2f82a8300c046470f1b95f6fbed4d739bcd264cbfa19ecd5e91142fd7416c3b8e2a77c3a538b3a350924bd5f57ac0273776ce812070fe48596963eead6bffe15784d84ee458d277b42320b39c748fcad8faa89b9b64b0ba6d2f5672d05edb4f1157d9f19f0aeb680d8c2c9b8624cef22459e68e2f636d1f039bfb946ea88a7284438dc0a14c604f2ed1ebc2646063da77da833fff2dc705c87cdf8508f29d3bb8d89f76c2ed5af92a5a62872a53849b5db46603f9e242f2d0083ead5adbc841cbb360662ed1a5465e07ddc54524522f20ae45768b0c1f60c53e6d607e5359bb536affffc54ce7a33928931a6833f1668428098403e66eaad206992565150f4a1d5e261328e0c402dc4d7a7eb644cb33e5fc979a8caf26375a07aa341d2d97436bb50ad7072d49a738191c8504a80cdb8edfc25455fb5e6f22aecb888660075f6b6bc162ff9d71513bcb5409316237c79f44381ee8b6b8b95e8268ba33dab04cc816f085f1f389400e9b34cbb12507a66f8bd5024d66f9a6d4bbc59d5979a75a46d5997bf0c1ff71678ce8b562abe752556742706167547f7373d384ecf8958a82d210d8e5a3c13b226c60420a7c244df901b141f33e16ee4369b5703136e36bd04f60b34231de71d8492f5ae292f01176cbe89528690a9dff4bcedf6f6bcc386f6b4528ff47930dfd61c1156ee57e6613d057758d720d7caffe5c2d5148475201ac5d34f01d1b4e1483c9db24e94bb1009db9284d82797745d0be7147e5841e7baefffbc9cc26a7026eb754f5e2898baf1a8faa3361614eb543ff7c54c7a54c11c5aeb019072c64f1a93f33b0c18c70582705c06e5b542a89faaf224279fb08252f08b8233c64fc427a4db2702fb623cd0495c4f34b92f49547930714cc68c91439c0523173664c0420599909c61e3d9e855721a90fa02ec67e8910ffe5983154c2a2be8ecd6b6f376e0ee57514db0cae8003e89d4355a7d241bfc6d936855ea629cffdd04c7f4450293af614c640fc6c955175077d2f131c1dff23a2752d4ffbb3f4b0dd831c6b8b6f8712459dddd894244d0e9ab26962bf2ee71606a9a277f344e4d4b76b4ba25d5309f04e5cb1047eae921e7c82c2744e730479ce440e5914c73b28fd4ce8aedb5e2cc51ce4daebcaf3ece85b3830d2c79c76f342c881889f7c982a27ef1d5dc4876ce31f794ac07359d5658a52bc00540fdfe36e6433b32c34839434574b6350e42d49a32ee7777ec5ff38d370a4e22fa95ed40058457d9792fe3eb7a940e13e1029fa96fc76f28d644d759f15ad6c86330e0f11125cea0df75d54d56a19af6c74f65f0208dedbd8e7a6b91b04d5d140b2a98773f26c0065975dea4554e9d7b63d1bb6b3936e440255e6e888f8880b0d4c85f946f7d5cb4b70612bf84413e4bd5d84c77cb0cedf936fe08e81c6991235257d586ed43d388204ccdfe19ab3abce771343b909ba102d8ee43cd972bb9fec2610997da29a4a5f787407cbaa42474555ce1c8a4ef140e1358579152b060637025c41345770ea29e4330fdbe0d828802007e2c35dd71083b4c97bb6456be58dddf7e219a812644f3db57e5fc6987906596c731359f1cc5025c776eff40840829f32f911cecd13a2b91094e191856d2a85757cafdca567217dc800380a46f650f0c111cabbfcc4118402d9f6db226db07e3ddf9ba5a5fa9889ebe114ec43527dccc81f7169fd8a87dfa1d1abc946ce97eae8318435c628beff02ceb87d1c81518f60b6b222bc50abd76c25b03f4e2487c0e6850ac9646d44ae00bc53685c874326c622cd556faf5b2ed4a88af5f88faf39c20311334eb9bbb5d53ec15a64d50491245a5134c41c27337066655b8cbbe4e53aab7a292825ca88b224c19c48ce7280624314eb22a114c0b74d9dbcb8913e14ddd8af07642bdcdc1cdf0f51e103a0fafa6d06834b40d134d6d0a6c618ee774e4a72aeec9e972f2335e61a77f5d4034c3d1a8461baffa3c5da34aba23e70b28a24b91e98acc417a2dbdd0529ebcaad383f6c08358dcb011518e16abed8ae3567ae2a54fcd8f60a559cadf2e73ed0a6a7520fa2b5b915e86a9737e2d67e13eb6edbad644ae148d8182ddc3b73b01f0248b0f72d6ed8b4527b54c9242c17996d84283a1ddd8250199451f0b4b824da236091a4f84710e5404e9de905d26d40ecbc3586591e78d28e7418f0c606bcb0102e6a13e1f88f038016e4d011b46f0d62c6093b612a6a080788c1fedec0180931a24f90f3fdba2913390593ba963623ae5c56e32edefaa5a179075d08956f7d486cb68b1c2cc34e66d0e262657a5aa2cff6d0ebed427bf0531d0ac8d99cd05b4dacb22fd802e0393752e0d78a40a9001f54e9ac8108af9f1091ca5d933f0b91b9fff5f12c9dd02685e48ad23bae15da202918e7c4b40a2999541a31435a27efd1a28e93bba9f94d25e2a470e5159e227842c5e2d7dfeb7f21539d3e424bcf7e7756ff791a68057e7c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
