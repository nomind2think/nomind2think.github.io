<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"264ac5573b44f93f9869144c20e068a25c448f6b19782095e8ea7251952425b23cbacda059c93fff2e1a3b6a54b22f0284b32a05f6e6974c43296cb5f7003311e8cc8cfb59914fed24c31d1776baa7696617d646453f896d202ea10db154d2250c9faca1e1e39127c347ad0dccbec0149ac666deedbe254bf047e2ebd9266bdc1e1f5337d3b9f7c127e923f4e295d28e710fbbc327c6b8da808c72dbe69c670b7802e805739ee3590720f7ab7ca0031987ab71bd4542441c999c76a150c3d23b29afc6000216fbe91c11f23f0ba5e3f2d6db5bc07a9cdef3cc8daece9cacd05b3d02c7522bd8ef0f3e1497f66580187cef075041237b67fb4ec00bac07f4c5d9085b1730b06652efbf2c6f70512d00743a81bbab9a3576160c105c3aaaa9459366e14b257db32b89c44d347c5239a50eed99804f6a944a8e9bc7dfb98d9906724ebe15ba013d25a984d605b8b57abda83a7a2b5f5c339332b9eb88db93f099fc324f4006f3153a3ad5c3f07d5f6de04a9d161c4cf56155142c1178a842c0114c90f555e4de3b48b9dea981e6bb936735461c9b73788425f82fb256854c90f2fcb633da7e466ebeb124a95bb9b5a7ac6b902b3c280650c11cc56e4aff7fc9fe0118f6830295000b4881f888d3dc42a95b1ae5e08844f465fed860a25321c673b934e9c63f75b772a7aae1cbe786e37700a6ee23dfb47051fa0e12d2735acded44813f5da7d42a111be9d93873b6e768f0cbe8d1511a7335fd1b10bc41f71c98a9d67ac72042a3a73de56b7a7647f0aed6b57fa006648dea1a5d65ddccaa022064d5f8fad2c72e2c4d1b8315a3594a043fdb79a2e37693e826a75b205c0c229b10ff4b7c25f2a649c16341121f8ba4ac1f7b85413a75b85fd989346a9a8dde458e4ef743e3fce9ad760f7b37d16da8a2a8422a8c7165e7489e874dc7cbcc143c96bc8e9a6873d34ba10c71a98b1d275e4a38f9685e03929f3808ddb431f0fce6c2c0ed8c8286a66b3d96ab4c2de86906585f911861c3ccdb4c0d9e76d100133f2c1e26296158cec2f52059c172b0b473c4e28e72b7d0a7be5b0354d33512643731d3ad59bc0e701299d0c9745925bd7d130894c21efcb5a3d47a2f89b5e12ff34049199a2c46bbb393fc8d803cb663d9ebc543b57f26a588512b24cf484ffae75fe52f573f49e501defa015ccf2e4009aa1bfd53b68a8fdc1551ea1ab2583332aa2fc99820764e4263a328c7d0b205779391355fcd41ddaa62bbd611af596bcf6275f6f352dd5e728f166e89ef06d93c3ce3bce98620757cbe3363f021d2cbd81970f70a010e76f22f050e9b71964ccf5cebc812ea9f5c826b73706096dd7ac43d01a2b3029d8b6ea4b59fc13657d7eca3d3235cdfbe31d5cd19eb12c07a29a8962bd319adf3c7dcd4eb7db5ed1aa49b6a70b1d3bb87e9e1255a73ce4d8b76241caf752e5fd8488bd1888c0a89b2daf691bad0045fbe57c5f6f0faa7b0db33899c26569b5118774de41e12f903fc05cde858bdedf8d0855d8f8b75cfd5e27c9535cd4ac5032d458897333b1eaca354f6f5c7d87740b442a40dbd606eb1e96a6d7efbde9bfba97ca8424a0e59dd0208e9fea7d4d86bec5f7e77f6a5e26a0a4f87a89a8cae117f207aec8531d79a59bbcc3d119afa5cc7e08cb1c1f669dbb5f2bde2b8582673072fbf097a7b1810a7593a82c13d9a5427032da67346db794f6ff0a75ff78111b9c12e23398a18b520638f316fcf882aac93ff375f10987a979926b3bfb0b8ee2bdb837c34de72417662834a48bb6ecb179263e05b257a4b914fe14012030bdc2992e6b2db0cc0c1d2f4b75d65433aba291c962bf1eb4f4ba1c6c9892d88b24aceab67ce2627e8c0c1c3ceb2fcf9a87c5e1a79916a44b65e2d015cb109af39b8046e7e8cce1f27dddedc0c11a2ea56e98f3ae70822aad7bcdef458db786df4e286137f981953e17cff19886c7b6b1684890f22fc02c835f4f97cf2c8cb39ada663dad626ae7fb39222f3083086ff1fec98ef854a28da6389e10517e9533a1874a4a3725f7c3860526cdbdfc68ffe7bc54de1e682d3d4db61f16fdbecdabe52d998d0bd643ec632e4c7d5c6f343f296cad05de290aa7b67552b76e32aaeaed7efbd34eea424d107ce6eab75dff6a82f0d62e3e113277831f76efa225c472b051e3d5f75054e9537452ac5df79404159b564c99c7373b5acd215e7fae4ae0b77a640aaac1dfbd2bd41b68a5f980fc68d1a04233288c8da14c204331a9e4b36f204a1435ed2b614ea02850bb92a87a5b1e57efe7a4714aa998c488741385de694fe49eb6baf372bb29a941efdc4fec1eee4909870b38e4719ac9d52c0e8b037dc3b91afae0da117ff7caa450cf7eace66f00dc4f98118c2e996c417e92cb126901115ae1c60e4dd6e24cbe9aa9f57623622b1b96ff3dd7d311d8ef092d540d4c008cb2fcd5157da45d34a272f6f8cb0127df2458ce01c52b885f47b6f2cb9cf4f2190a10fe144bcfd4d1d65a18d1c7a6c62be5b74f071763dbb04c7332996e81dc9d53d29c13da1b8ec631917ecd8e8832e29043f2e91cb6a95eca2dcb5736fbf39a3091f4671d7948b32f23201c60c7427f5a4b436449563dc3eeb9e08d70df3649e154a764b345e4ae0a5839ae3cf9078adf3588e2d6ec748ce5493dacd9c561afcbf34a3fc05cabaeba8b2582a2737c91c1712711c9a93992b8e614c5c17387107278c493bffdd72d87f8793cd01776bd79b6737d36917b0c1a007ff18f2084e466340dec344bfb432701734fb81b3b64090e61019922e4bc6eabbc4e234e8531b0c5357bc8a2f84e35c9c2337f4bc1f97ce8e9edb71df60bbab90d6539ce9c96fea726fbeb4ddb43e45b7727a3c696676c725368185d174856c19e12992dd7695408a36a178f3e982e97685bcdbfd0e18a2e88621c91bf292855738aadcdbee970f670c201c44cf50f1647a232a0c8c433e778ee5dd88b1701790bab0aae14f9511c1db79f24c655339b4b7388ab0b911d3d4583abffa2c264221d38f6bbd9c626f800ffd21a3ec90e9659c11a29f44286d328c8e78ed4e81b294a69c2d1fc3dfdb53fb5c857558940a4f1d178e4ef4b5e01f2e968f3176d96bc2b5e45fb44e61b4a98d06818c092f3c4374414fea07f13d40eea30a328fce854571bff8a31ff6b64f371fe3077e4c3c03f8287b50e56234108de2e1172277afc3bf307f6b1fccb9bfecbea0d0d7500f111c538d8b7247e3a6fdd08caf2fd179534fcca995d5bd6d3018f14f18f31c1d80d513879b9917e6067a04f1ffd7a0c91d9b7d63f76fb058f51acc1ba2f6a35f64700fff11e97bd942fd206fc6724979993a3bd29afabee2b6c41ded004a373e35b1b91ed1463289f6a178b68cdaa53f4c9f31c4f1919f21b5252125f1065e1c008034255482fd456d5040b635c0804a76520982acc7af3a19b49dc1717dba70f1cf99297fed1404bb31ddf315be7a97ab40ffbb768117e003f1c7b64421a136c885453b0a2b53432f002b95b3eb40e328e69932ff8e57fc7c93070b06da3a503159caf676d8f0f78dd6a68bb29183b5a40bd728917a5860fd8feecefc32ee416bf8e4ab19cb1b001219c499a3c2cff2e0316483dbf07d154e99d1a45dfa6235386a693373e1d2f194fc48c650f10f6830e416ad78e124a81e6a7d0d0eaebb451f3aa24d5f46c64e2eeb48995fda952765e8d18b3ceb39673b9520f8a21fdab571beb104f3d9de156c1af151709d9043a38a0993feefffb847bdecf6504934e96af9528fdd35df2752c9faf8faf77b6bdd87be2a0c094c84be9ab0600a27972301ef7a26496231f5aada25bc210c89ad913a15678fba0395a5fce8d88c72325e06ec893bdfc29cddb9894c97a589d220c92fdc056853e9afa5319c7f8a5100ace226c9681823809a8f512cd5df6b4c75b81a0e5fe71b674939dbac327e07414100d693c6695bb67ab962fca0eb27c193cc5bdcd5d8aabcff88e5ea929830a90a0f9bb6799850142072649763ba0cfa0522fdbf24e3f0d1061062e8aa400eaaeea4efbd1d93dbbb6a63a479570766e16bfcbaec0639b6bec33ed3e30ca077d925629a62cac73f77dcd455992b22b9b05df97be1ab9259d77710d1d14b29ffd0f961a4989bba06e24c40d0f1d64ac0ca889192ede97ff57849314c7a46f2fa8ce8dd909115101ed0b07fff02dede85c668c54ca0b3d0b5f6f7462342de332d47bcec9bb330d219497a63beb7eb7ac33ee553c433df5af825e64a52a1d5287f1951bc1e418f71092e39416b6c4a261a0313bd514c86df04f98bd0b638a6f1ee4e56ed1c6cb695bea75783096dc971016f7391e8923dbda04dac69aeeafc98deb1ab5a602cb7accaaa27c64422cdbc35c04182745aa84e73c1002959f2d9ae4a2984456e43ff6ade6cfff9bd27aed23a122d0333c041899259b1328c9e574cf01a4ef98f1239e56c9b198b6c3f15e418163872812802563612629e9d38284742e35c2013f145693afdc5d4eeb6b20d4ae8327349c2db114c46f8867e06c554c7828cbac6d2be75c59e3e4f080e8c9741c4d1fe16599edbd0090a104d5d16111f96454f21f0c6d9eebdb0085c33411a80bb26b702f4e7d3e7406c8a32b2a95206e3cbd4d0f1fec3aa0d8187a8f65b523474a09ff315314e6bff29e656797de8e86a8c71991c69f6036c8ca3b0278a857c03c0481af52d62a64f92289b74ba5bea3d49a514cc8a2633f7be1997247d301af03448aa6a7bd65523f60f07737a5bc990ed385642ee0a35b4fb1c80a8db70955db78047f6dc1dc099b1cdec9907ffc2bc688ca10330162ff495439ff32aeeeff2e9262b2b70acda349f7574021668322a0d0c21af3d3461392db5fc99d06f1f98bfcb1a2ee40ee0f1bf6b262e9b1f0def895edf017ee246f8cd2c52587c27a86a973f1d4843079c28e389e5cd4aabab112df391c6e0b31982630cd7b27a6aee0b7c920878599284b45bf18a566b7c3a347a0a0c693e8953a4adfb44940b41bc349ee479f397f88c9f4bc8fc1f272ef1ab27bc25c284d62deff4dfcdfe08883e6dc993f7b629eac3f4b286931a13f9232caded470931f471b49f3570df782725a082ca8a8e927bb7cbf3268e8e599b349432b266b8c35095213fc9649be8cbba5a7459fa4625487535c5686ac5603ae66602d60881760a54660bbba5bf10d953d1d935f73e0da3309eb88c4c29cd93fb644b0cb1dea4417bc47e374eaa19eefc5dc525c0331fb6ba20edd57782cfae0a3138d4b66bd215186d8f21d0bca70df93287e87cccb8aa13bb0024729c52a6fb36b16dfdee2bf2740a43c3ae22e606231e4178fcb3e491bed7a965acf670081c6eb2ee2d66b5e2797322302bae2e454cd288e0259cb13c5f9a9453aa594c2b2c50103974f59ca94082bee87812f7478e1ea77413594104e0a39a1b9cc5b85fad32a10f3396d0306d511cc64aa257d10e0aee51d8b936364bcb22d56afe4ad3b68092572b8b0332276bad3a55ef27e0a68273ae4fce68d1e823b931d5da33aefc15f0ee06a82218790d879fd4accd7324a83817fc867ca831ffc0a988478a428a1c89d31a38797b586b04cece015ba4dfd5c8c64c140c0536aa7e1561750814258bc2b0073a90839a8506904225ab272bac4cb2879da96c44647ad72d3a496577b1ccdbf2d039854962068d1fddc6040ea4ed7e8060cf07d4d1b795bc41fe29eab1ea7f41a8be00455835a1690432d9916bf60dd38c77c4dc08a8359dc54a00b26dc0b0c276c88f4b50d94a13e3cd6caa867fd655e862fe54afa7273c0bc11b137ecbd828487531c858a23fc9ef8c418bbb35ad6603d7a49e7cf3ce7bee7367e7fe95802ce7da9fee03fce87fe7f962203b66264d028a73215ddf736ccf1b5318363cbb23b38704b24244712ae584ca91556a2db36a71125079590af2a4e823a5ffc0b55fda102002f72a75c82f70407ef2dfb0dd4203d81e52675469ce59fa43a6685021b905b73f0a8740b359dd50f321fccfde2a0214579b3afaf1834af9c197d232bd46454da8875dcde46b4f014bec90128619252e8f2b7a15485b167a3b8a6ff7704af9728322299b1d05f9f2b9706f99279b93f34d2bde0678afdf45a94864c7a9bb9d477dabbe5833f84c71fafcc95913634fa4584e8c176a359ea2efc505f84bc26b682df64227077a400afdfabb5dd25968b7cf1d505bcda44e12fc98266faf9e2571349f05818e558e3d4eda96e7d79b2c817ff93b6f8bf147669dfb07aa8c4849e6a710f40020b9d39fdbfc615300809ef65bcd8d3e73fe41b0f922a06519041b6deed6bf28681b27f04079071c1fabbe1e16df716ee7dcd363cb17f2731ba4ce843b04a276cf5a6f3b1ddbd544304b5ba2eab0295ff025ceaeb24d5540d991c5f01f190a11a584d15a1d2272d2147bf989c5a360d6c40ccf249903323900c720e75672c0b0e11b363c0d1659352b800d07a0fee27152a794a64045f245f8beb0eb89e9c9e66888ca04cc41135a233fb725d932d65059cb2796c7c42702495cca97e17f316443f5ffe5efe4c070a27e6baa533de53f2f17d574c66eb35eb2cfd7e1294ed81a46547e55be8ee311a3c327059c608f3e9b0425750b7a8852a6f9c06ef4a1bca9e5495f712e3507e36e67d54a502bfb3d266a2bcc884c2a90cfd3e3786e44bdb2f09988f06d6cfe6a89b87231a3ae9e75fa610f87a867ab242f1b044b9eb461e5040578e4f8e5f7a858e3280f68b5335b37a1c003afc83be7f6f897c2497b42d0720a7bbc38b6e9407c37835c51fe84abd6f20e575141286a3a472615783e31095103e5d5ca3ecc60f8d82b152bc7c210147b184cf2fcdca04a060eb45718c0c8913c79d56c9980fe226b8d6ce2b40806f92552a27fa33475e68788259f9997d4313ba6e1d119d53008ff2c69731cca3c1284fcfc36e5f94826d08925885381acf87202208f16118041ba5d6211efce702d60e5eb1364eef23e5768b05d39e404126bf45e624b18d28556bc76ffe790bf73d31d345f08563c89667689a382d8584ecba59f972ce2d3fa5cad89399ba596fced01a0228aa60d72aa475c9a7db3a5fbbbda07b6081ecfbe2262f9bf9d1080f143f6488c64c165b4ac84a05bdef13278d9567114856bf28ca578ca271dda087048efbf86edede6096760b51805201730a3d924b120303b2a45f84d31da38d93bad98c5c6b7e2f4004f1abb023b986306496d9ee9ce2eedaeedc6e7c2b68b612ab26ab7480f545efef31a437669b31e5f068b4246a2213d04a3031d76f444b95b5681bf0570cd6d1b958d3d18af9c701e86706aaab0d3431ccb84ff4ced180ed522d8182ee23afe66c3be7df9baa6aad87599028e6a395414e34f020e2b4015cbd808776fd85b66210c07cda66f0b88394a24b4ba7e9379858b03bdb84b71bf2a1081f1efe566f7f16ed09d61a58efb57f9cae362a77e42f04dbe02c1a230cf349c4ee03bd30de04267ae45992e785b76cc9423e76abe0190c7c212d95ce357affa80a0bf44c994dcd526a6c77a137d92fc1e34471e525b02a40c2552cf7c531cfa7fca82f0cc079be2fab4a20595b06024d139397422e048beaaa80842be24909720f195609c76f247ad207325330af8e54b8b4886bb2f737506efc0ccfe0f2bd1ddfff21f8810f691c74df13329a84a040bf914adc8e904e3a487c780aaaaa808362302fbd2ce190a6214f936f44051a2a4e0251866ec4419cddc9abe7004c462dae12746c1c3c9c992922452e045ec3373000663cf339e5406448dcae0742a5e21da74d5b9396e1066868ba85f222e0d0bb67726bee7f6c3e06e968dd7879b892400bc0094284725c704e5b67d4dad5697bb6938e28305597f6a1b0bcada89b77917e14ce3a8ae9306c3cc17cbeeb19d81cba91c89bc2790490ecbf56a06f557684bcc3b15abe324c63f400d6cf58537690064e4f691fa508b3aca943bf83c87d4671fe7610c08595257ca4be16f38dbf303f53326cb9bd8e268fc1222030b5147a77688cad6d6e348e13906e9fe8625251041c995eb53d358d9a78dfbb99c546868bc7d09bec679544bc015246b71d80b15de777c7ef2d842f8618186446011fdb24b68501cce4241fcf7954d29f9188fb4e0e87f74535abc9794eea4d6e9780bf65bfabc718e642d3990b115ecd1ece055695204fc78931f428d42d5b142a0b8ff703537d08c2e9b3eeaef0a3dd9178642c561eec0cda8ed605d1aa9c6d3bb1718bbcd3d7c4c717fc734a2b804db57ffc3677b634864d573cb724c1dc748d20b8b4a53ebf60ce496e5120ed9e373fd24bf0315442a138edd0d3e50c4dcf6208a0854e2f009eb706bc493b3781fcc6291318da5cb4f457060a878ff24122dfc98339fb47b503103f4f9a9a93611cce6671ade8d6ac6a37cf96a5f76073011978f56d6927f94fe2bd3dc87c2e6bd649cf8f2a1939f578fd5f844512615ac20259d7aa387c8f56b31d9dc101a542a769e444e73f5f60ad6a6095bed92ac2b6a01d485a6fcc21104d5faf213005ed8699b19682f4480ec6fb26f6d5f1ae9a0a6605e3580f9d0787d30611aa7a1522a724bdbaa3348a208eea50762532f346b53584910c5a356f501d781bce887528f537fbe1b5f4932e65f7319d7a5eb354f23b86c4a679b9e052d4e60e53aca4fb7fb12ac0b938b77fe047a9db181264ad0510f00337d898141898e88080f7f527a64b042dba93c791b054ab209ea98245e8195193027720ab29acd0f95ea7d4e0c1d3bb1ee8c66730c97c4bb16fd19407dff0290793783c1ee9aa989b75453383d49dc05cc4ad2efe4516779fa5421cb5f52cfe6f00779222f5327b45ea8b884740cb73404f3063600cfe91a5fbbb0f2df53babf489fee6d6def6ce208f4cbcc415295adca842897702e8a3bfdd963401ca1b24811369e7e6ff07c8894eba0b53444f67ec1959a815f0ee160e6d717526a864fe5796e825f0d33a442e11fca19e8c1ca6d4a9321594b94805dde3d869f8749eef4b93e1df08a80e3f5bc53ed561135e07668357f2bfc87295c1cfeea5d9d72b0723cd4ed28297aeb9c1601aca3a5a9cdcbe56607086792423ab16010268911fca26f19764e6479d16c8715415728d030e1f2c2d2b146e59b978476bae4fd94a50ba9c80c2a8565dbdc25a4441c5eefdf4b6c172ade72923dc7c46a26e9716a4fec98dd9642e063aea52638ae337f491036aa414e6e0d1547281108cb711d7f3abbc2bd4b396762d79013b1d0db599418a719661380c44515a73a56477add4fe8e7e4d81ae91c3d055ac7dd237f73e5489b091947ceed3bd10f0cb1af11887846e5b0b8f5f9e18795211b1ef7061be381656d849d4ebe9c3a9b218975453cbe95c8f47ee3537837e391866ba434e824b2997cc677ddb3c8f4782216950df111c4f08b3db6c860fd0b56bc42c12c9923028b04668c37f842a8816fae748e3c40b8cae508ee6935086cdd9bb06525d54cdb17c8da52ac60546be217b95bee4d6fd927d7b9531e5d1ceac5493f81bc795bc08b14002e7d7d878956fd5d4b6eec76028de4cdbcb87150c488059c64e0f1ef0f001a153e37d1d1333edb96df2792b05285473a72a321a2f2f26d8de94bd3e50f77f3a5aaa6d678236763968c1e879d2364a0bd262fb324b69be22854afbd529be0523719b2db6ae627e31f86175e4f7e9e8d098e93b787009fc6224b1b0e20e80d5ec16c6f81a8e1fa1245f2d78fefb90e90deaf8a8be9b43301986dc05c91bbe0dfce8a62a42197d871cb4b660afcdc5b6c1b71b1e32b2d05ddb72b7d4228ef0d9b3d6cc4c03394d6fd530e47b74e4416e8b0b419a1cc6ef9d9b9346303b167b333498d1c8186a47194a4aea892eff0410aedf4779efea0aa574b950782e56df4b4e6ca2be0e84b8199dad9a401e0981b970e75d07f076c20dcc9db3e122b5694f8d5fb52c32a005643122805f46f2dff8084ebe0a753344b3062b9e562b86de78ecde5fba96a63f602ec5376066b50afc91d9f83de6454d2391a65182734b3f686b8f2e5717dae87ab9fc7ce6ae837f8aaf48608fd26f20f0da70715111e00ba6de8309f031168c31cd3070835dc29ae6579ccd1bd5924bff1654dc498333836b9e2c913b9ab88ef4d8502a53250eeaa3d243dce9ebaf6154ac3d31298f01d05556916d665c66a5c85d589400754c7174fd9dd227d4333db85a70a3d6523ca17cf5579e5fbfdd7162fefa6130c9603e54180132efafadca43b4e15b224000c7a767e5af3cafbf568caa9a90f4ede64d242b9aecdaaa574464ebda3c2a11ea48bd08a4b210b3822028cb53ff5fe325c80915cbf8c34247b77a12dd5ee47e4088ee3f686fe51049673ee664a0ee8e9152965914a8590aeb9b2e9b78ae3f2172fed30f7062ae240dc290ddfe4260ceaa267a6b0d3e402c3cf4fe7c13ca557ea72887497f0a1c9f9508552c279f006cf69b59fc901726b8531b942b19e8a848ca17e2e2fa285407e918bc5c9c8d24c105908dd3cd857db5e78acb961972ab41457c9c17e0ab85549952a2f758d502663f30b99c469c565d8681de6ff543c75d701d4a488acdb1432bdbfabd7bbb4160ec9ee31a7db1f55a2b0ddeced0c73d7140e3e2ff0f359bb72c4fd97d72e549a5126f5092ed59f3d8f118cd62a660a615aea9c63104e1ee248596766521596610fe3a3216f0e520657eb068f60229c93ccdcf25f6a4a16b1ba29e7453a9bc23598e2732b09f05dbd2a0d2d16a2a7fc401ffe3a33755782466bd65326cf28ded7b1543fc690f17a7a9ecfb3b8a46c9891018f40d3882dcdf579","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
