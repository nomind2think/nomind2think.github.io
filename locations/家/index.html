<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d81d917a43c63ee2c8fd4be7c94cda556a7900d9846da651640807f8290b82febea99ef4b05df1e31a8a6e0d6af0ce8c84b060ec7f1eb8fc5784386e05d2de8c394cfb582e275c54fdd15c450fc04dfa70514d0bcc7b1088682ee3d7304483298f8d24615164d1665e4754b59658558aa0816cfd0fd695c95e44aece4050b21ab57f58f6c96f15a5c2d308632936360971dfe2f7b1f93b5bf5afbfd1e8fcf8a3385fcf4e2f6819471b0c63f2d2a877e3e90fa96684e72df73b6102c69e0d0fa36f2374c8949f64a28377f1bccde80e41b6bb75748ea417483d339b1e9c9a707433361f08476e73787ea7cdb94a06267b6d84bf5fa6d8f503a50171dd3544f461617317501373526c7ff31949bf57d9c142fb3dde6d8e14faa487069eefb64c7ef31e5cd51287b3b2a4902719aeb77790ea1107cbb3be6cf70535c4fa407dc3063dbcfb80a527ca9d7d41deaa8d5ad7c0eca2a9dfc321ca225f2c2ea9d60985555a8b63267a033afdfa10d208493265d10d145136baa726988e5a1560ce2eb5910c6a0810a7fe0118843e78104720fa3f93d3f38599cf96c0a11afcf66f3bda85e532c8b07fd6c2565ba3b8b04a10d73bb84d451f6b6bc2f89f0fdbcb6fc76c2bb8ed63b10cf9c1911279528dc113794fbf753bfbbed98592395338fc8167507f8fa3686f04a53183313df45af9ad8111b5973777b915eddc876c398f781f6ab281b1959b75a598848277a6a6d052e706069f60bebfdda2e47ac0a8baeec1c11a9f80c5196a45c5bc389ffcbefd4c52c8a0c1e1749dafa1ae3ece572620190d751470eab1df4af7151a326127d38ed878b221dd93d9ec87ebbdff273d9ddd6ad8303822d262402f8075d9ef503069fe5ef1500b8fd7f0f334d5abcbbbf8ed4a33cc9aec987d342a12f9e70f7a271dd40142b69d7d8814fdc18cede13dd9617afdbfb10f72e8be770fba79ec5a2d68beeccc1fa45d8de0ef6e27c52d0ab8774b207781292828eebf8869a89d327e98bceec6f5672e55cc56c7d93176285bf0b497213b9916b9a7f7cc61c76f6ae4ca05163a5b3d6aef00e564406fd8c0c894d5d17a9b914aaea418dd98212cccdb6b48a6ed34d14b9aab625256a4bcd150c157891e13e23c876eff625a9031f2c55a1e8eda16d704c1ff403b6fabb2bedf78836dde3e690d43d54be6eb4e4dc15e76991f38bcc8e1304599726198a566ed3569f6d7a5e68e11882e8086ac30266345350b88da58c2e9b42c0a116d037484b27ddfbcd5ac3038802a3a08de6ebe95f4be8c3a76d569caca82a518b4500abbcd213b8f13abb18db22756075f5a55e1212b5d64485936f898056afeac9331722f8c40edeb5ea460c2413985e9e49d2ee24b425c404d81b1f01e70cd9cff3b246b49271660d8d415efa5412fc65d4b5cf29f6bce90c6e7a12404e2a5c6dc0cc77abf1400e52210704d9e54fd77d4f0184fb707d49a39d8ca7a983d64c6960d5ca963ff457dbd7ee43e12d39b80f78bd369e8c74e296c3055a41ed01277f4d9eb8b1d50130748bcf7c2472a471fb43554143c27e014e53684120fb0c482b209906f8fbc41966689cabe8abf21458381d7e41bbf05ed4c10e806b444d3972aedfa64859eef392fe73c3a3ef89e877983eca4ef75be1d1f782b71ec8692374a932b7292c74d3f2da34e102faf16ce445c4e43cbb41beee7afd6164b34df3b5b0ac5458d9cc8add9169f5b1d00239bf0a3afa89fa629c40b1e1728e46bd30369e508b477f79caa82120017f4063cd2568d9688773fbf397f0bfc14b49670f444f6e2b045045317c1aca7e59849c5b28f2101afe99c227c5a9b8cb73dba7e513fdafb03a48d55978a0975ebaded21971367942c7fa371d4eb910047e75df03fceb01ea769c5b66f1672f7ad3139a995321f2986920905845c0ee5b7e9427c6e757200bed190d8772efc5688e4deddefaac0c942e2a1a246adadff9d87afd33b13d072105bff4af75b45efa226962863819f5fbf3df57026e7005070622f56ed014d1d5c6196adf6c6ab2a2138b6d85810639c18b9089f920aae3d90d5a960f94487845406595b43a6650ef5d4a6e5e7161405596075f36f8884f215f6727588813476fd0f873ee17863261a591e4d33efe5a06006c2e9e89c81954e581baaf3d3686ab39fec2f3670b2a32157991ccc6606058629fb237d61d6a5809da4364976c0dca9ea366124b71a1be7ce0b4da0554644aa34f3a452b29f9543dd7770c9e82fb4c2c192fb6cc1424c2c242cb816f443f7051d02dac43af3efac6fa1d913b5105949c166270fff368a10882b3ac01f2fcaf9ed9d2b765d66090423caa71efe83f4e5a6af1de64996b8486c95573250f1df0a9c3b14ed1e386752b84ceb71291c3f0c6341c11ba2821988119e9441cf3fdf1e2711d3ac61b7c9e1b9463b510fac8165c018aba1f5875ca27a346a5f141c03db9bf19eaeb48fce687b463cbd39dfe295e99ff06d14416195759be06fb16a2f2e1d4dd00a74964a48da2ab1276d23cd5a7b267971ab08cf96088a70cf3e610772ba6dc606a5f09a13f7378b861f60985b17e4b060c7e175bf5cd3754bc2d7650442ef09888d79253c6319821a959630c24e06178d25198830bd83da09f3ba6fdede3e037ce8ffbb6818c986e37271012569d338527084f9e921a477648d4a4d3322f1f03ee1ce446de737d15e7d1fea1e388e53ebc10fb3ffae911a68788a5db4cb4c73da0460dd75285c16d61a83e989139e554c94a31c585827b885d78e6be354ae677e836189d36cd604db9d9e6deca05dfa67201d8620d6b12d01a0d1ae3420fc58d3ad60dc5acf2207912487deb5a6b7f3b4fe8ec8dc304574328d7e22089ab1d0f56d6cc9ccbc40d8410c974617f8ce8cad36cbbaa27270d0223b7663ef088f9423f21aca5680b19b0daac5a0156a9f63804617fabf810748124cd804d35da35b058ba21fbc1eeed52b847426efdfe5b116ba4afd497586cfcd5a7a18802bf63149cf8d8494f60fad60bacc64adce377833a7b1baa3d8bd05c84066e24b37f01608cbabe6cd5df8b96edb1604ec20075064c86b19c8ac7ecfe3510489e567d65609f3110e4cc294396b640072280a0595adcc3b9abd2ec1ad6e65f260f8a6da18a99514610bc297a2bd6d342c38349520fd65134c3e9cfda79bc02503c5ca3a708413659d799ff7201d30d60d27d1a1f3220f270087d994ca7bcfa38a66ed3f6b1be4239fdaa42a6bb0cd19a47fc9a372ed3de22082a4be5c5cdddd0940cfdd226d42be6e6b9c58b7587a7ba3f0811bfe7b84693e7ea14c81ca4e81f17f72d6ecea9c1b6fda3275583d936d8d61c954a184894eadc73a3a1c8775b4a2aeb19951d7e0c4aa9a964667796832df345e62e5f54a072c3fb071bad972b816a571843939759a98d8c1ba77b7d560ab86947d8677978974301f8d234d8773ea230f88cb3b1472aa8aada278c114cdaef76380cb95810220c4e36b964d4fa0ea26e7bcee48fe9e58b8214f99c4312082b98702ab321f068cf87e8d0875bb88740b60329e70d781aa19bbb845d63b972c404709b47945f6405359154089b6ac28641f9fc5dcefb9e01d95e813bf8d662f2c47c1b333eb40d68a89bfd908c1e72f864d959af9c99e6c98e320692d7f02888258b1a69694f35175ac190a1a20126f9d62adbbb1eeb3fdd467f0049264c7c0fac64e16429c4ff76d7438959946c367f328365da9ce47f8e58407c0bef5e0e5096b313c011c214a25633b7695681c2e6ae71083d9d359246a8aca97dee4d98faf9ecb136a1a56212aeb1b80d66527b69bc6b3854134e5a345cd962d40ae79489ef404847f54c57f4d0e2e6b20e77dab3f9bae41cf1644b35897d8c4b57003a8bb0955c744f5bc2f47ed3c602c25284ae6360e30c4e32ea9b8e10c3b374ce08abd67af0afb7077842f990fdc00439fb173ea6c4bbb0df854f84732fed9b310d6e5085a38ce62f15aca2ab4a9dda7dfcbc52776883b515aec4cf052b559a58962fc4cf83acd7592d05177ea313585faeff1a3fe19e34959c6a52fb2fbcb99d07ccd4402c4cafbea3ddfa77dfa71f17295298002e8334f2d1f764de3a4d7ad3575412d76f307cf2a77a3ee6e05b907a226a088bcf3b426c1ebca858c7193ee8ed31b10f09850fdb89d5157b6b7800e672e04c9de34969216c85dc7fbfe755bfe25d2f018ce513ff3d6662205831081a06120fba2280939796a30346ff58f98963a87d7e704b101e8098bebba8b203225e255f37768e4c089a76179ba725edd757e68337e1b23e1411e63c457cd885e1125feb0adca64dd897e88332bb0a50a0653459d3901c0d28b8c7ab442cf5f18b5f01e7218f2f4dc30806029439e4e9efbf8d799d91582c5bc6c48b8a71884d1e562e04a44c8c24896e9321fcb81020be600ed1dbfc7b9b648a9af676a4c22beb3cb89e6dc88272da928d5e802ed1ba7104df8d16e8bb8622ef6889d444c0fa595aa4c972f21a6d190df1f0f96b2b0adb4674f2058f9f2cad7f6746ebfe09f865513ac38460eeb490bc919bb21fb2effbd697e74339fab62c5f20155a02d7fe04abba9f141cdabb63331e9f7d5a2e0c6ead30a83cdb731b5d1f9f7da21759afb15f793a00b7ce586c1725aff523dc01765882ef8b65157f4de1106eff252ecb7e139b27b5ca0672ee1b09965ec9589693a94ecac041d0b0483dc712639cc2963912904745234e62d8909e3ea7f8bc585c581b727d0a757537f9481e6b43fa1244f3b3cbe150a4f830f21cca193e7c1f876cfc5aa9e579fca7b11c61fb99b5bee0428741eaefb68286e5bd60a49206d93a63bf1958d61c11e2554ae0dfd449418880d20a91fcc24a08c1d864cee7e1c0e63ce98f2135b304e535ab8713173fdaa9a296fde205d8fa9a157e64f29dbf659b40eba5b8c289668da7c7429e6a874440ddd751a7aa8b4b977b7ce35500e9af98cfb95fcb62523dbedea5193c4849e4faa47035d93f0933332ada8d653ad919d13db8160a0cf299540a1a6af388258993b13cdd08330d67951238f0975e37c71ffe6e9bedb576f1da4452079ec39849d5f8573a0fc0bf66d2a40030729bdbc5b6ebd51ef4445cb1c6885138637236dcbb169249fa78e78b2f7c8906e3eac81f3035ff027fb9ed44a62dcc2ba08f192b80b689266fc5c32b4f1a83790dcc4295ad585628e2eb6393b1be1624d8d38e0ec542a9fb16921a2e6bd9d48ffae2ac8ab1d097fa50b06e7803370fab48260e8fc7fecbe99bc09737e7bcfe8508f4202eb5dc3a092b66c3d778e19f269b67c146b00c41915c4036d1ff3e0fe0aed441490d8b24094fbe804b2322f59c0d34fdf5369a8877781d0cba358e7864903f42d649a6befbb068e955e790f796bc10ed6731b52b84fdf04ff3ff122347feb9138556cf19b956b5d65c5ad2d34ea87db236b0640b04c6becf73ca1dc3f7da11024c4f30c23458fd069b5dae14660870bc2219b99e284cbd923458ea4a30594336587f2211ad24cbefc3f333fc1a194f802f6a42de6bb0457d549388dd1acd6e070f8b9ffd9994cb9ef81982675e6894f83758ae5e0a1ae04195078c75bca463cb161eb698aec3ad7956d5cddcc7c7912f39c88c203cb42d649c88c9105d50e97c1910efd3ae1f96f5fe8aa64333dea8161bbe1732926673a0aeb1c133e0ef6dd2fd4c658e4f3e92238d4da0b6ea368cfcc038daa63d858e5dc6e88f73fccb02a3993e5bcb0ddacd1fe9dc6e75caae65382aa144cff4bae27e9f93b69bc73c5ddbee75c89a98f89055f04671be534341b2daacc34611504129c94cfc08a178e9c6a6e9a9eb84605b9af4865e87c4999d000a772d3adbe1f9487002dca5a5ade7274062218b522521144e0928b646caa865d49325707248614dc7ed3c69ae0f4a1d6dea3b4fe90884d27093e9d9e089e583a78b323eecc645a0808e449d3532b53a24fe850ef0046a1d8708e70b1bda7c883d3320159093fdc65e5b802d009a2c881f0fdd414bbc165c9aae26fc29c3d135a31d9f42360cc23dfcedc988ae048f197bd13c39e53fe7f8df14f8b25b84c6d5550acb464bda71611e83caea93a8938754addb396a6f49f715f63044c3d5bd1a2d69d333de7fab775dd6818be3be25c71c4e77758beff011c680800eb7394caad473e0c9a12e004a1a8934f0b84212ae270fcb103bc297c7f41d22e16185194de452acbfc59186c84602707b7a711e9e8adfd88d8eb49f2f2004f7c730b8b2997692db846e230bec1a87158934bd734d4d111a2e2a13b214509a6d5d6876e1422a9b3c4c2c4900484a32246d4fa3c8b8ff47ae06c157e848450744768dfaea8e589bc0fa280338f99ce76547351ad668ddf9579016b076afb1a01252571d0d6112842fcd89487a933d6899cef265a3892bf0b79eb779923d94217458249e950c1ecca40cad732881298f82ccb43d6ed1ccfeb10a46b55a1e91ecfaefe7a9b8bf631ef2f94adca53e41e95d19f7095d2a61878b9047edebf1e4934eac0dfbea97586ef03a1bffb1d889d2487a0d3cbcb784de7706c4055a5e87c957b09ac7b7047374e23348dda9d45fa06d82d8ee069845c17cbba074175b7904226078fc8b38d30dc83694cc43a843fc4a0a193688aeb66c74b4a60198fe57f3a7518bbb24c5a4c6d5a498d0c1c46c58537902c656a82af0892ed03f25834e6d770d03a0352f49dafa465dbe33f9a0cf0fa79aa8e661170efc5abc86b118c6c497dcb6e4e5734ac56b9d0a26d9e26f44ce32f78604ec0db9a47cdd0f974d7d47ae542317cc315a8687cba7fdd0e535ab3538d9ffdb9cbaba050c758f3c7e16d01c52615b8265a12c365bef74e30284a41986217e25b0c71048dafdb6960f1308267ca96ada3940e300bac40c16aac9249fb106c52ef17ab68f8948dc15d1c389b86d092053e78eebb095de962ae1f0f5c7375138e39aaa02818b2c3cd75e15a1032e90324c257245b56c192120a62398a62bfbdc197987570919233625c5b44020c615c647183bbed528d6ba9a0c2df3284307df32f457fe9e64fe673df3a0d0d5b210a4c61984c0c4fa53213f30c8fd2c9e818d2a3ebcb1844bf2fb6dd9bc6ca1e3dfa7e37e90401678e61ba5f482e9fe21414aebfaad8666b54cdbda2968bd6cd5487f461aba8ae6ec78f1921c38ba16e35d5967a49b1becd5f2eec987f220f2f3159782b4448be355cba34188d1c912a235404c03671b6d85a42878cae0ccb77ff77f918d5b96eb4836221461905f0d27ad8c7d97ce45d57f8adf2930ba41624c1f4d8e93dae343021b00db20f80b0ecba5b68330a18ea71b8bd2bbdc2d6915ebb5f11a73ff916e5178c4a517138d9c5719e51e29e93bad4d2d2eb646d596dd011a34a476a616d0e8b761f63c48f3c20a18f071cd657254dc0fefa04f15835fd05ac943de96bc97ffe87cc3f384e085446b7f177fef98b0905e0bc27434507cbd5ffc940ee9b23377b7b4c636038115a836726616e0db9b292eb9f6ed4f75b7cd8f87903e596e20c1502e42b3eeae7a2e2b745839251160bda51dbc2551eb1e0f89e950982abf224f7cf2fbeaff25496e6cd33fcdba4e021bb9dec3564ab697831b9796c0cef73fbdd832209966baae5f867f68d83647d0b62fb5076c4ca6f52b9032661d624af16e4f790ea3bfd19b3f1f497242a23ec62a7b7cb4710f6bf7ae9eb36b20aed9fc4961fb1e072b43fe8cb4a45364cd4a0ef7a52ace7605e2fa8db67c72d8ba85e923aa140dd817e5d3efafebc2a20dababa4be8d8f6c4a4a2081ba248041a70dc28ff295324035922086abbbd6aee65145f36f72ca04935461a4567cdac726f0b8f202bbb47d9b233697238b2c4c1322a16e96ad64291e57202333531b4e9df9ff47879f9cecb6328f665e12486227e36a837d02ad8f6ef0f29c457563382c8ae0226f752b3bb6a7c9d193c383e72818e07d806c750cc374f9c50c99fab6a33e5e5c815f4a9342e6037d8ffbe64499a002fc04ac64d19c85c05038c791c0381bbe6f0c1c7d2d465244239c75b79f57655a1decf7c79c839dad4c59569efbbc480b7a0d249fb837319958b5001de109fda9b899fb6bac67ee5ee152ff2cbb1a372dc60532170c3ad7489abb462917e466b71a7a64e24fcceee32c6f0385080f27e8579e1275f01927103906cf467c5b049ffbacb79e7d5cd4c0c0986d8a34357246dd1a3d6da48c5af8c4110ae0f94816d06165598a0b1f006c1e25f80eea4862b65ada95f09837f2725c6c4151629dbf94e2d9e0dc7e10df15663788e13185bdbb0d4e2c55db292d675b68a90b321d548735da9978b5bd53b3ae1bd1386b5b3e9ab9a774c63deee227780333b43213fa56e822b898a6adb22a0116e6913ba941d90b4e19d1ccac2e5c05a3f9be74cf6726150488d5734ad9d83c1e8f77b2864183bf95c22760d88b74beaef71b13a5c6315692d5476eaca9b9bb724cb3c3ef967d3930946c2100809316aed7b8b70c86b68b39d939d5136b9bd7ed6f26014379c2d1e4e6abb74e1c1b171c2e1b1d7cf9da9f93bf025198e6342a01a20e79e7f7c467085e2bc69e6e76f8795b9a8800ecf63d22a5cf4729b047a718b6c6c4a94666f6f155f4273969d18ac8e5233dfd5c9c96376411ad7c4f175a566da410a680b31d368999c66802aa8b8b9c3d2e8009a652d48867c27cd23c31728281b1d8c1ffaae67232d9be6c2d4fe42b6a71c36296d67bd7cde6fd9332ec92ffab8d01bd077430dfe499a00f11b5ba3ab3fb069a49726c8d0c0e53d9ac5dd73b8f1e4fc56317a31de5920ea0a3eb81a6c5e58e44f197be02c8833caa263d4216d3a8fdfdebd290bcb6de943d23bc6396405dfbd77f297832f53faca87b6dfbf138d87a23ed578e78fcade4ead1fe5d9101ac1efaeb9ab1619a38c403bb15463081f4ba1f2328eba2a24bd52440d243be29b30f051d996f29f38b9cd82623924a775ab25402a51ae7fcc5446ac3fecb685281ee7d5704b97a1f1969192d07d2eda15e34be48492cc79a4ffb82c7ba8632db2e11913b868959c715781dff34d62f40d425dc3ecfee6907c1e480209432c8d55c716eac85abd2b83a7672121b252d6e22edc6489c5e7b46fa757baf4b74ecdb6f7c7e7c9921fe180d42dd5ab030595785350cfc5282e25069d9fbca33a459cabec7b773414a9dfc47231ce056a4f16f8767bd06d38f2f5edabbd5e59012145b020d6a5c74a6dca26382eb72f7847da571dfbe35bc301375170402edc1be05a0b3becb1470f25ee603fcaaea25cf157c83619678b3051f1edaa7f7dc44355359526571d965770662d8fd4ccb496d535fa125e57c474cc6fd37a9aa6d3d0dc0c4c63fa488207db9c576475b87b0fd118201025c807cb94fc949d339686486c0d5783d75acaed5c38529e31c26bebdfae16efe045f96f617ce41a05bade14f6bbccea42a28b84d73ad589108fd4e518cc2d31fba202f130a6bc1843a06f07528c2f8dc5b3dda66a99595d548069d1ac6fbf94bac4d5973eeb630257cac24929b765506e3e1798d6bf0e2813a631f7111318a81200cf174290830b5c94533e8680ca22b297b1bec0d8ff0cd136164e0ac9af4d781f3c97c973bae011999e3a603402879a97d6ddbeb63179d4a253f885ad775a92d6029f3d7410944d0750a0a7045644c99ee631ae0d2dbf50af2aa505e944b31ab81781c7240268055ab32c543f0e59504c8e23ba02c9f21eb66a1928ced0d4975a835799b4ede1ce95309cde1f020f5c7b63ba9f0dc164977bf078c87cbf0a8d0934eef8f7579ff6d998afee7fe6117bfe81dc75940c2e4a2a45175b16f3f2445ac68c7e941d67bc38bbf3efccc060610b578f8bb5815aae238900f9aa4ec9ae6540afb41e6cea21b5ee870a4fc4d85c14cdf295fae893aeccf12524d16ccb3d7801b177884409767560533c7c5fc073e4b609497dae726705bd40d012401ab214a733eb909b447cb33e839c0f10e8229249d32ebfc31de8e1dae9eb8e482e527565286cee41c4971db892c229c5ebf7cdb049a1df48877a77d21aa74a9d2b1c4812380e9858a1e82d06d98dcf940bad9d7e46c7bfdaf663bcafb24277cb8c16e8c14adf13653119851034af79dbf4221df950dcaeb80876b465f66aef216826e1053ac4d77896ecaf554cb44fcb46b2e5de2ce60a99cbd558cde3facf272068aa4caf488106cd1c11bdcd1064d1bb2bd0506998a1223e0cffd4a4892345c013044aa9cf7ac4b039458351e2c6e00d58aed0bcdc1cd9d80ca304764ae9c12c58990bc98a2cc6ce5e68beedb63b8180926bc9a7841246348475c88099f27411696552f4fadae3c7fda83cda246d4cbb2b9255f8fc8dd71ed53c0e026a13fb992fecd57183cca376e9ce1e4264ae512fcb9d3bf6e00692eb53d2522b79d07fcf1ff4ad1fc6837248be643cb077fe820fcc6e5470098d9c83d6e5f9840befa927c0a6e5d96ac593f6e76616f0caeb733acafe6bb3960db447e3e1166ee6b82f58f4df0962683da78d058e78e224edc3ecb4b9d8b3059a25560e8c233514029415913d026532e19d49699c48d579108d67764879ea85a597dbc1ae43eed4fc2e8710f6e1d9832a4ee28e4f4467c58995e3aeb72292b7d8d5924e3db3802d58cd641d3dc6b1fb1233d3caa3192e3bb7e423a7d8d13519964f28f2ebac30750d210e63027a873da97b94d62006ca1dae9bbfa80c877b8c3561095a629f3991afd6c31f871e3185ce9e0a86e266203cf4c94ec36c0d99165b039883d0628ad86433966628db237a42a354dcba6d2d36c8255e41ec10217290886e26098ca4ae1af3720040c2c7bd0f2889b218f722b6a332261cf6f9cb65dc040f6dfeb58bd20f6575fb2a24776ee79aae735fe27b8ec9da6549d6375731eee26503209e77834b09f609a96543b8320000512186d92d1f90a04c3f02734808da9fba263e221c0652e96d7814bb2849168356d8118eabb275347ec9289fc3024b2c0f36e36b24bb55f197d247fff00a32de64fd901f39c499d81bc531f478327894e4fbefa9119045ae92cab67c125913e82eb7b27068d261da03c00c11d859ecd06953b2295530f6ef859a9af32a84ded798702b5fc40efb582c4b08e9c87df93962354f547a9b91860fa7624ea3ed10588cb6525894c7417bc4f150e349cb27e74655dd31b05506e12804285e961acb1b14ad939172d7e88ac16082b48c3f6e257f1f01f2198f23959d011630b4a796cbb3e8daa14f340ac54bbd4069c2891005d78bb63593a7d9c710c74b6ee20b16e3d3bfef851dd7808769d24cfbf0a396d7ccadb2a11d980f7f30ba0caba0e55545586ceeb8fb3e63147c3bf75eddd4ae930f0516ad6c619d959143ba17030b9dbe6fdc76b6c1b5f997b03092ce82bf978243e740b7e4077d349133f2375e73bb9e72094900160e2fa340e0f2adc539c65a413e94c3ec86a324923547b09029c898ed1f122e9833ed04c85fd262d9f2cba3ee64a38cf4bd1431c297e1cca6a5d2bcda1f58dacedbf3ad5055260a2ae4a59b6d9f84eac1663ea374b2adcc6cbe802ee203974e74cc51717cf14cc20fcc9b757a2e18122fb5f68d998643848b60de213ec97609c7654a863b04f40ea137960aca71fd3740feded13abfc9f60810642622898a229f728d43e9d727c1e9c600008ada5ab59d06c3c6d48edb107e3b5875e06b30c3812d503808c65b993405a8b202679f66efc58b3501b90bcaf1394d83256bb610005062a9ce941ec858fe0fac798908a11648d495ccbca2b47ca3e6846bbf7ad315467b4d6283e1863d0c36af4357ec9dccb05debe737bd638bc80293a2768ce09aa11376f8442a6e1842d2cae8c942998bd24409ec52ca21ae80fafe24c6a6baa5f1ea64acebb1aa5058c9821bb281044e4e44d2758123fe3a3d6bf0917f18a8fce4d879181a9b7f283e0e18f64bbc88fcaac9763ce0e9dbca4e4c56f49d6d9175e89c78044dc97a4e3a448fec1b0c3d0a56e0629da7d2fe2f8bec8f26467459107347b738a21737f71aa2b275bd8339c28970d4aac57d07630297468c00e1bb5a351e96e39a81fa62705daa0c1812b93aeccf1ebad1a21a374ccb40744e7b80c865fc47b4d7202352e2206ed297716f9c7a7c539f938b0bf9cd499d6c4be99ba655829cab5298b14bc94279f89fcb67a0445a7666032e919ccd744dc1f47cc1d47ac856e7d75fa4daba82168558846cd3869675149ec49e094bb14f3f3631dd16cfcc1098c5041534246633c8961d34e42094cf7b9f66351953a9edc92e1baa6ef24dfa5f8fde80d80cd263896a64110c45a90572da9a59540f194294bb096fc1a219acd0fec4be3047ad5a54debfe4ef997fb6660f56e2cff31437966b5d4b008a087b1cabd59f968f2194ec530357057dee9a79461f1876b2cd3bc1b82dc468076716948ec069ae1614a6abadcfba54420c629ae19929b2d08576f37bf020741908fad62ecbcdc7fa7545d7ca1e75f0e9ff202aaababd439673ae6c1bc793dc24b953e80434f08bbaaacb6f5dfad0976dc0154ffb9655232c5002b5e3436e8a773bb1b774fe2ab681cf13624b72aba1add3a549ffc56f6e4a28a6cf589e0d0da55eb37e50089e26b1d8b14b8692bf3e98fa275332728301653e3ee1720d19211ca4e2cfa89ada828fda874e2276422bfd09a311acccb3b4d684a82b2c07a50928e6898e100ea3990df06cbf77d6b08b5459783acf96b26ff46ace1e543da387161fdafbabbdadbdca713d888440b058e7c1b77b79bcb4d95e07061bfa7b3fd07a53802aa000e2723caf808743299d8476e718ea1a2ec167b6828c4baaa02a62334d78555b6af19f2dc4f6732f4466fb7185da232eae80cecc8b343d1fdae40becde3bfac65b7450f2e783acbb5fdfd6805377722b1a8b6929f81923f1998d6d44b08e789f94a00592b65eef6fb42bc145823032210bcca5911bd130cc6d21729a5b8cd4c48a68615b3ec57fd087a28accc70c9eba4bc1437b529dbce3102d1b231395796b8fdacc16fe7b19cb0bdeb4de67fbc4dfc009cf3f48e3c904122e22aa35626921f83fdb09a68a6ec86d12bf53920e94a292ce63c4f99ed4437789947cbfbd3a60efb499a3883bd8a094aca5458d89dd37a5231d11bf25ff8e8ac05585730f1145490832fa0e8b9d504bc8e06dd1ef937a634cb42e52401b51e3edb2e57d0a1966b27d2bd67c0e3a848b2c0749e3f5eaa61cdddabb9e175ae9cc64fcfcf039a184c56ea3db15e6ef72001eca9eb061f47f8e3d491d20b6016eb51cf23796b3e25e70a16cb0d295b2ea90bbfb91d62aed981f36d53ff3567fe703014a17d447ae054c546d841c2d5a06db4722cf4022f267d9d3726bc89657c7560764d4d5ab924839fb180729d404cba38c246ced22411a3ce5212e0c245a5fe83fda810d4d9d22a45d2833d1f603750abf6a84b6d5b0857646e1bcd6fac1c5145c4200a7ee58227025781318f88a327cd299717577e412a88b923a260108d2d12698441c2fbb0a0f31b91e804ed169e2d6b8824807d9d78b474eea4fc00ab37b121f5ce3b43ac857f3b07de7ebd08b5d70dce35055acbf957ee86079541a743c0683b884331ba8c7fe93a38e345b098945f0bf346e738b52603297a79b7808c451721644086dbca9de846524d116e444512dbf5f8a5b4fc4db62c288c47ee9d9d9c53f6c4702a7f1aed4d1daa36408c2e8f5c4304456f8fd23898145cd40757c4c77354bfa48817fa5ec6f9a7d15aaec19cef0354facb9c414235aeac7d7fb06f0141b44eb6a156a5172f5b16e4fe8e1181091fd842feeecf8ea61b2fccc752b40b686c2ac64cc02351a6f40b5e243a7fa798c6b49aa84bc5a2ad64d11b8470c4a54c68a122ad98a9af7d99bee952a8a2baed5015f10e4c774118ccdc068f2088640d3ac1a0f572eea54e48680db5004af2a85cd355a48d053473258ba7f584f2910c190b983d29b1b326af8dab1b452a231e048245fe55b36e48a538e2b8f46ca8a862dd5bb8f9a0667127c54f7972829812521c78c7408788974b19e2dcc855aaed5435949fdf51d721f8ab4ecec37c51376ecdce03877b16cedff5962b4589b8ccbd2ccfdfd176257b63b3fe064f331eda4b22522b25e6c57f42f567eda434effdee7508b8e7eae420dba2b4d0d20e053093b18d108c1902eef432a98399cbcd8b7154792a78f3f46d6b90f7ccd07e7f9fc6268bba45a41b1a4fcceb723326933b35845e726c5eb56925bcccba3b399d5c3071ab6fb813e16c9b519cbb97007bb0940807880ee5a898eef2a3e3e98696a2ddf8802908dc226e29080684f2c526568cbb832fbeb3204722d631702cb5a7a94ca648aeab3ca643ea3d9dbf62bf3405ea6313658c68245db4e896baeee4bbdd63772fbd6637dca109a2adc56297a26a2a32d88c937d2eb359bbd6327322360243b536af17667d3754d7f48f6b4a03d4955b63ac04c8b90f7d81931152bb54aa59a8175f2a8dcd734453f8f52ff4cf1e84c93462d8ede1baa4db5b62a6779d9a429c2d41de1e9d7854e7a750e638ea69d06d3efb94aef7d02916c92109b972d8d570b5ac5678b66e83456bbfcf43a29f65e1adb91614f3f7ccb44617b912a4497f944824fcd4a1038782487bf2ab3a30e41dac3ea65ece97d83942e249994f515256113d912fbf8c513f23eb74d40408dffabbf6f94c2bf3d00503f3a9ddeb36d7c611a1f618a7c82858a91dccdf16c08eb67200b503764c30478c7d7c2fc8f3966443b963a08737ce78b86d4069ae12b9ed3fbdc2c51a93fc09815ad740803476ab1f7c21ba0aba72955f20ca374d197770531647b011b444c33885929ef2fbdd11ee6a7dfaa54ffd6308afb2f3ed3a213726d42b17fc98d86c350cec0ff9ffaec0889f843f925fd98799f9f05dfd7611370a0fbef1dff192a1bb9be484d93f82b010d96338f815367cd32f2371bd411655fa7c9138760e4760bf665f88491c7c9ac4fb7064caa9114427dacad8cddb6650452215964afaaa70a6979733cb765fe0df2272890e41d338a9805cd6b691e45457315dd418eccb47b1937779e73aba35bda112dadb69dc32fda7e29f690d2c55c48bb2c38e46ab987e1f08b573fb63157003f369030cb1e49aa96afef9f99ca8fcbc5f0494e7a37deff5f34cac4f0813d7229c967a87c8d8c4adee60e804610dc11645dd074ed4b76cf133e29200a4a03f617c855a6bf3055cdc2755e119f811a46048a5467d285eecf4d65d2d3009d0c047e068447df63a0d6ff003d0e5966d7f8bd2a1202cfb9034917deecc0a7699d41bc6a07e83812ac2f1ec989d9ff1aef1d2dd1c4fdc4eaf96de6cc937c01e09fe89674a661645c8d0bbb826f881281142f880346eb54a1d86a80a2da1101920843c4a362f2f8a9a1d8bb212741a7b62b9eb0542ba3323d6c9e9676dea2857c13d751fa4e32863452ffd728ea0c6daaf6f71ebe09c921e3071b0ca9a9204af0997335425cf7b27de75b4e2aad7d66feb6fdb787af63a3d0d908264572d23d084ac5685bfdaf803f2e141c84d0063396d11e466b58f2e45772ef4f5a341f73c6e485ef5d8333cb3a39592b678722a30b3023612248dcebf88d6223999fa691f9e3b48b0d04eeba3d661101447b8b7a030a9a83202cf122d8bd1eddfc92d133ebc545032f5d37c2e7813cc559b6252d5c9a9986fe711684c47fed4e7d6c60ad5d9342c6f9e0b88421c69284fa8a1f0c72cd915fb0716279af87a5e6271d8147826858c71a4178b99a61f325a70659a13fd119e12be53562177fb9b117d2765b3b10b6c1587144228aab4679d7a6ffad3eb0eec2e73dfaa46ac5e9c3862ee6d8d11504df1189153173c143d0a45fb68a671e7196090067c038dad766809e96a0d409b050b49618536627f7f57c18ae7b1d99980cdfb1f0bfc46b21b6a7a6c5be9d9e6982c89d1d71557d0e68d7b94b72038892c7a005859c838290cc903584faf50938cc635a73adc6e6c6c66ecb7c0f6957950ac5e83ebf74e125f4df5181a6ba0e4fedbf222a47f4fe0af5086f041d8237bdffb4991cb843dbe119ccdfee93a5eb6406286610a5fe314c1a9fd4c724ad03a271afac5869e61f8b738c83d633a1dc9754c89ecee855d3bcd1d533ab3933d9961653e3124953768c414e1ca267b2e4de1d5c4f239e3c1bcedc611a4851f0f341a1cdff389ab9079c08f185bd2a4431e545718c732e1ceab1f0be1c1963f51d1974cf82e1d4262b5bb243929c574cb374c5a11623d8da8d76a73b5e7ed026dd8a18ce9a29d13d5c86bb536f650e7853f166b803fa667176da283f97978bbf785e7f1c99cc35c09b9c534ea69abcb19cf14470eaeda4edd54bf11b1511db17886cb67d4e1b8b68c072c52e71869e53d055487f134886d387b8e6a2f7728a916c03fe8b998e75ef6e6972fc8c6ca2327cfb1212f8a6d89fbead859f5c53be4842ab830cb57e30c54370aec3fe85d3fdf7427a30a37dfae324fbe89d80f967a9b447a269e96cd4aed2262122c8edb64842ae3d044d9dcc0d6156302a014cdfe9024e1c9384b3c29c1ed98a54079e308c672309f3a8fdf2b7fc57c08e9002ab41cd10c965e00046ca7922db5314fd56e446391af88e0e268ef24bce43dbe7e69ffb6fcae6b2cb1afc30757f9cdf24041b75032b7c4f470c39533616dc4e28d98d5f14cd986ed72639e37efabfd2f96b402d325003ae942944a99bff14df1ad877daafb58a1f4abf187f6d7d9320b0f398393295cbb9a71c6d771c6d9be331ba7d233380ce5af2531105ecc07fd9a7fed4cd6b19a0a0d82cc004e3f352bacb10fedae7f5146317eaa94abb7117f07bddb238a54ea419ffb488220f3b24f3119c6a84cfc1dd2648f03875ac02cfdac08b40b45bbfbbfe22ef8ac0c5c467c8bc12b56f812a310b6689","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
