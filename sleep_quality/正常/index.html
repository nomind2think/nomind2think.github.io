<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2335fe84819dedcf3c5d8b9936ae8caae1c7c591e3077b9fcb0de84f4e577dec4b94f02c686b7675e6c5d85c81bac70bc3d0dd0d2fbef6ddd8191578bc45d91dd64ed37dd8d870551812f4322771f08b77a092e1723977daac69666ba7bdd3211d7926f190eaed8d32c9321f0bcee49c436e5c9e636c8bd9f934dfaa38588eb9f9c9f53792baf2a15a1b4b7a2e5e4ca73087070ea2ba9d79f6848f9f3ba87c257d562d809ee2b34256180a3ec1fbc2d86f595c40d11eb876a7860bd7eea7a3ec3188a573446070c9db0b50dbe3dc997896df9cbfd3cb74d51232211229524c2db67eed2e5616095d6db2c57fda6a213b83279e312e0b16c39e4521fc53a401b7455063be4ffb272753fa8f7a28da3d8f554374b6d90a03c076a39d603b8d251a7cd18c83518e6d8290eedaf4af465d21b4f9d650efe7591f985c0d734beccc9b6d7de0c00fc4a87981e6eb53204976ad914eb1dc4d95e568d93c2802d8b03208649798c070b04af4c2b25eeb6af603ed4391abab8527270241b5823926ce4f3bd3e085ec18eacfe6e380a3eee5009e15ffe654fa3d414d17649709ec0f6482866e7b310db75a526548025d37032e2d05fe213aeb6d573dff235ca4e0ac7038c50c40506f53076585517bc3e3a5a13b8e80a34a9ec88099d23a9b5d86b6a88bf02aae51a8fa9e408b1b6b5708f90f5766ced5882be8edce91f622d594974e57f01c4f97617626a4b7e5e3e4f74dee8620740c9d0b1d4a1e0b5fdbdca6fa910248d91a97758274979ac432a795329cc9982e67897dc9e1ee1de6e1b7a04b2bb4426e347f87c64effb6187b70cc1ea4cfc49b2047c8915ccd2baeb37d7e034ad3d09c56aeeeca25b54b737242b72aa403622fefc6dc1e5beee312d0862b60cc71cb405cb57e3e31a70f3f753e98f86a03f35fe8c2fa61c9b3b664e74aa022d13e12cc143f22a94477d5eb45aeb46d0cd9573e4620674b856db10a3bc925c65dc7bc8cf453da0692b48f0721710f2a0f58538d09258903b16756373ca7b1897c3d05b2f921313a9bfa15d99481629df3587d13475f48c8c5dd9027ec921ff829d791eeae79853c7407f13a7b614b9fc25d72a563a4f02cab6c4c5030a24e3f5f03811965a3386b3c468670a3d04a1e535e47273d866d66e4603030c17494ea52634af646274e6842da7960248f64d1070716a68459fc0bc42d73d6dd3e5976e3353ef688fc30025c33ecc23501a12b864d6dc8508dd42d48737b9d743fdae261766f1afff70900956baccb8e3f7de4fa049ad165a14eaac8f04da7b51fda2e86aae4270a7bd6b16a6fadc82fc471c6b76ea37c9bb0f4a711d8abf1cedc3715994fd65f67d61d0f5fc56be04ce38ed4022f45011a5f11d5ed1900c322a51017c47ff1b03774b99897cbe4dcad3aa8c1b8540e73acc72dea8e18eabcb8940e4005e5f0912065045abba8943ddcea2180d172ab34c3fbb1701f13f3725b474aad3f83e11629d7e1d71f46c50759b841a059090afcbf99864f0773e4f1fc626ef4166324b85c779700eba7a6cfa7c078f0b98fe4ce8bd0cff39acf5757642f56e23415a3d9a7bb5563abcadda9c22a5137fcfb1e3cf78c5501df7cf4b2de896152a34f165e878685fffcd06e5548fdcedb7fb3bc4b18fbef92b46e51ab528cb78265c38fbb99c6b82e72848655a94aa8110a9f7eceef03e82755185641f3895f18d459c9ab24d20dfaff74ca30e60ca81995c5beb257a9f0fc71015833295e9817cd1fca58b72d363e4a532a4665db9c93b750d0c6809470536957361889e21a3e99bb539a7c994da1abb75a50d716fae435291e8b01477743338d3311478a995247e818de1c3c20fc1c746cdc62675060f3968b29daf8e2550983a4e3fc820c4b98effdd9c520fa991d3f8956673bd1aa749f1b6a295e402f2b7d4fbdd361a9e100c79c75a8f7649036acd58b4912fd4c372b1354edf978a6eb5146f4d5a77c55fa1ce60c448d0cc316ff69386bc045fd495c7f71751d6a90fce7c20287dabc944870848e5c0224a7f4cc0c869bed7b3938b17a3bf308448fe3559c1287f2ecb23e8c408721da67df5df677a40e2a3c0a82fcc19a62435e7e113a3fa1c9e22975d2e3c175da77ca72794922aaa8d6db28bcb7fae916d762e4bd9b41ca4b3827f13e786e3d4bccebf8b68f032bb50a1817e0636739bf00fe7242c26a7e2e111b0b4fdfddf68d06914aea5f5e86ff09ee47f525368ce308d17f61a6e76ab1eff468ff260799448e46df7ccb4b14300be3bae6132cf257085868fd73eed539b884b3eaf1445abaee79ab3e1dbf7a09a3e87674d9752eee5565d0be46c01116e213a0450350afb055541e9547e38fb4f9b1972cde934fc3573b31c122d5c3a50cec50a8ebf11e990bc9aff91a6750aae62be7fa9a6ef8da947d07284b0b0e6d49168842f538e781417b17841c4b0ad0c2548f9e1975165cd6f343265b253b7b778e4b53d8c1e771be9624ab49981ec7d2261dc5123445ed31bdeb79964c166a25cb7e3411f4edb141df40c66ce04132f5de3f47a9d70c6b82c3721fca159814be39164da3bae219315aa32f4ebeba009e6cc089f958c2a904ca63f3d2547aa7049b787c64cee222bb5bc41bce84459fd327cdcb3d73f5bb14f451a33edb11b182cfe5f59d605ea43ed6de721b2f8e86e7d088d47dee5a7ba512961ac6f0051e922ad5b7e2996687bd3f8a349372efca5d7b753794ed1d4b8d90e791eeb5e675cb582ec91ff3be7b8f1a055a67de56e0a37ed49d9511047a4bf56d8c6f8acbf8a018158d6b8d78f1e43c930a29aaf5e090b92a7e5f67e4e056477c008eeb3f9c2fd1c98c0b0fc42b0401da52808bd8c1cd399aa9d379c0b3bad4fb53bf990c6b9c50b9db7a094773406e7a3c82cc734dd9710e9dbb5cab3ca539ad7382dfed37b7ce7ba022cc6b128c2d9e7672a33b4b0ce80298ca1d4a3dcbe3b28ca79e3c162955e7f34313da2b216ecd2c4562f262bb96bbfa54cedd0a957347e06d7b3f77a1291551fe322f295eb9fcc960394da5976ed9571b6a9124521251031b80229686b8bce825cbe5e75fa2cc065608a6ee637e52bee54578a896c9481507b998a9603ff0d8963a9b68ee47925fb6263e3613b8d222a686678cabec7e13d94295be27bc5be3f1045c70a245da540bcfdb8a4dbc9984e39f950f90094ffee075e721abbdcf44acc0696d637e191d0a87115d2b66187d5f4e3753738580c9a1341fe2817d8fdbe81f9fda6bb2ef32ef7bde2ab16ad933846b9540b930650a87e3c132b27bc9c627302a5357e9a3cfae9545629c86e0ab6756e1e05e6ecb00c1ca8400732800b1ff4eda8b3f626554c3ca4ba80759b81a9bd5e5b1922ff609489d1727ca1e3b80cbf969f2eab649a0363e9c5ea369301e377fba533cb1bd2e0a1c61a54a790d30583ef9f3a6c0fe6060ac726a58acee8ca56d3eef07fa92dca82ea3e63e1fe31fe0a99da5fe252407811e1c006d2d57fbc82a7eacfa4a3241a1da95bff96899453ee1efbcf0ab6226b81057e7a33b4a5e39b58c556073086fd3185012025edbf108ab317bf5eb4320f479899468aba77f2ea158a2e63a7675c4c7644f8159c85359fa2d4e95c050cf151e0739fd69ce28f60f913aa3e15e50a8e5a9dab652832f89f4682cb427b958a865c312cc232375d719029fb96e7e638505f58409005fd8a6df7c4213586e3a09baf2061fc936d722102838569939caafd9ade29efaf16071962601307fb5c0865b3d5b2979f4392b9950625dff2bb16711c8604fc068fb19ef225020a4b87c3b4870d4ceead800e7d7f984a70506c197c3c42c46863c5b2e833c98734a98380a512417a0f7ee59aed417a7029db6fdd1da3bb95480bc1c9ec760a108d9b3044a39dabccafc870461355e425eed1faaff795b73e50dc81ca89cf6ed37ec6535f54ec60cf878491d115a56b31fe19db7387908b840a1193132e3db996f58261e15eb7692d9bdde1517793ae42fa0bd38ac71e0b083ff10816781ad0f6d8aaffa4d005af069c51278089ef6595fc81300e6a267027cdc30fb0d608bfbb1a834cc54aa710bc4a43a6affe65ca1854b5602889df8050b7d726ad570dafc99449e49b57f5bd6412c7621b8741eb7b046baf53f29b33c2ee2d12965bc25bf9d9ed83684081e867d99766085182a17e6397b648ff820500efd3cc5e162953399bf67ded47615fb6bc7e919d548d5e3ab8f0289138772516eaf5605bd187c287d396f97a379f4a4a112ad7b76dc49e0d402c74af6d66faed9c2f9cd726d5a09302a933fbdb2a7f65bd66480705ec9dc54ece72172c854f66985c323ee19554dd15937e54e55a079adb6ed968341a4448840190be63b7b2f3760a1ad472534c52592a7d114804c9fe047d873ad0464cf3d59567965891e14bb1ebdfd911b6a3ebd3c354b0e75ec2e69ca46960f68c0ea7329cbe4a979f6f00d738431866f3a9d4c247bd71c852f7ab829b9c447f55a4786b29932779ee08380d07c62015fa5a9216b887cbc0158efecd01abfebac8483791dd9794b09c0161a907b96c801901a176b0b8424dc2e5e75f510b686edf0e6de66d82f99f42ec88c7b1eac846d67d4b6a8ca154adfeac97251fc70f8c32276baf95b09ce04fc13b5f0a2b6f984925b1965a02cfa03672737d7365608b119f43a97864ce85c4a30432374a107f5c85efda916d4e94ba9f472a9bdfd8c7e1e105c6734588b47128596485b889f535ff093c3ccc3ac80f3cf25b80f7ea04c8eb196d817d409b0d63eb1095940864923ebdb787b15a611ba6036b4d15f9123ffe26084c7489e234665c56c205eef5a6efe9ddb5d8be8e126a8866d38533b1a8bc1d9649275ab52a413c31e0bc4ca2ac633d84cbbbd29372b2d724e1733bf6892f5a0b6b6f58141241e5b77256a303d4952ab31205ceb7ef23729c5339eb211d80d30d9faae7a3b2590f9ad24ae03b36a709c2478be8a17e664047c6e8d95b0e6d2be5f79f7254737d320ca65d0cfc578a2ae4d81051bf0cdbed8b1e64ba7083386ee31ccc31588cb8b9804f628cf3d11f65e9ffbe3e248fea40f40149afde9b0ce20f154ebf125d412ae512ebc3f7955eb344c458ae049b7b4f8716687da042382b7580dbdb00811f458ed8f5e1d5d88621c7bdcb167a645133bc31adfc8db0b0c7a2e53f19e8367fd07f3f70d52bda64afab43d54c30c58d9442ad7392ca9532875a0047d52ccc560bf8cae5e4cb7c13dbf392fefa3381703bed0be0755c6ffb640322e77fa9de8759cb81742a269f979c86ac27268d19dfba12af2b4394f5248e455fdf4ec93512430bc959188adfeb10b54bdecef27b1d7fb1df83e86a08808e67ee239aedd09560c636e6ef60ef9952237eafeae39d88d4c802386d1e8b4436adad1f55741e3006b3ab28b8d926471764c6fd9c6b5d1874bd7bb437a2964cb24409accb03d6ede02ae4c2de56a102a48af279ac0c7f105d73b34a7bda90f7803ef974340b1201c1db891a7e7bee63765cd0c93849dc4b3fe71af751de9fcb76530489e68bd41b266831d5d9e532ff2232bb491510626f07f6637b55e2bfe345e09bb0a14ef402b542ec32fa13d2d55f848d1a14c0959dc7647b531415de26a91d0042e8508305088ff90fe1cf96be34b848526f714de082998f0b422dcf9f638e36d113b734688c73970c8e4dc50eaec9c536b9869b686d8f11a9bdd15973d2dcacaa9b8f543de94c8759863f6eb5af17e85703cda126aec4c0657e34964676d9a2f926c2446fb461c35e5d78a8cdaa05d140ece8db6e4a03b3566c4b45835277be3576f32721b32b91fe1f26365c4abe8827b3542721f9c455a6b6abf562cd3812e9f214596b04b22855f29124916384b703cca7c47c62ecf15f276038c4818a1e79fe51faa4ebdbbbf8a759dcd91f356346dc1b6911636f1c288823b3e880c64b446604dd11a2bc303cd0657c9d04db0e0a6f91798e794ccfcadf5aa88635f13c82475de87bbf19c86233a05dd14d86326f45e18276ddd23bd14c13e0cdba4caf2d863864e909a1c5cd6739e032885ee89ee658ce3910f32e904b24de1f6096f5f35e5ffe58f0b62f0de62296752228f3610ae005a98b83258ba02f160b3729c759297d553c1e1d88ae2a4b53feb0f1cd574eae432bedccb3a75051f30b9c50a8423fa27f6d121781b07534057d83ef74628b2ea1a4b510670cc52b4a8a3b687c9d196be677670af68a057da7cba68f45d5d3c1f10adf111b75976327a109f1f56da236f23770af99570d43d21bfb5fe47cd7590c359de9ca825efd5b23f7950ea823f7aaa90f0abda74315f66be71afe592df9a5fe4051ece8c87b41156f3f03371d07d6346168414aca1764485872a91942e12b00aec3c31305b523bac9564027629b60fa64d0924b0ae09f54f705cb4727e50fc3d4f4b64ead9c76169c1083db0563ed2f99ebfb19039899dbba0223310c50b8416aed48af8f493c9c155b7363ddc5254505ee49e7bf48e4260133790e55bdd60182ef192fe3d9bf09f1c8efbe9caaab28388c2e6a78788a2de270031b397b13d8aa843856d47b3f93147cb5062d0ba33439789c7e17e28fea2b2b5dcfe9f73026e839255770bc84fd194be4d8f0ab59a1a8ef614fdf46f2173a525be4bda40ae7affed5543ecec76dae8af9b6cf0534ad7cbf85ce735346ce98acf17c44b1dcadd848a21a877a8067a2a3bf584fec507c092d1332cab9ac67279907cd4ab74e73063876d9455e03ec839ed919d521cb8347d8a73f93a4e5eae486517ff14fdf7164325298b3dde478a609517fbab5605b24a4a0294f74aa1c0eb81af667cdb3d80538b650f0914417eade6b43d08f91e070e1d8ff03906920e83fae906668a6417ffdbd88df2cc82bdc68684ab89e5cf207a95c4a7af2adcf19e004a801c498f5bc73dd52752eb8469944020cadb458851d0e4d18c793b7d3f11682099dc05f5892b6d192bd57e49cd335c5ec9260413b778c34a8726b18d86ea093b80f1883f3ed8c47753a57f7defc0e2b4d538f7bf800c81a0ef5c5ab96eb3df243cdfc7f1550f373c7c1011b12f1b2375aee1ea58e60dd09ea7f540177979650bc5cafb621326f0bed1741321cfabc0b6a7e823fdc6271499024d8d526ba873efec79c310d32079083dc767533d2cba3bec0a30f0a8579bc203cfac14c3c232fb4a773300fc85c6095c0937194047029ffda60d209a33963985a0889bc456e3553b868af3836d08821f743f8c1da2d5aaadd7d84b34b7c709e799aa214c3d094d0270461c472cb4b3b0c0c758d951b0d3e473165c7dd98697de4262b8bf11074e8bcd677f294867bfeaddd5f4c54b55fbcb8ac6d65d3856b85aad79248b3d94fd5896ab709158071d713c8fc7ca04489fcc805b1317d70ae31e298f6f8196bc743bbe188bd24f31e547a304cdd58802fda384afb486f88e5b83a1b1cf682825f124090c7e3e37abac3381064fb59171a8531d426f7adcca45f2a9797d695db3b1763a80ad797e3cb13f17a2054085e1259d3d4d7b38b45952849d215558d7c141df28c9ee8b80f6a8af15564f23cf487f58758ded3e2cd9c7df5fb8772232cd3bb7e55f41a5f12fc8340dcb32b6f85e904402b06b1f6a5a5f1a159048d2fe35e42a828dce3916637b1657218b38badba465396dc2ac9a584fcc7576c9e77221404a4b546c6cd8a81156fe7a8417663d28c57a5945539ec68bdd492c9cc26c62dfa7db5498b3cca169cd699454ac2f03c2e143148a020399098222dcb23e5c95b200692af4006b2c8b91f505bb40e226f309051b07cb33d76faad04bcca0ff8f821e2fa48b228e5c682c1d8b7dde9bb32e59234125c463879b295c0c1136d5fa087e8b6c92ca2a82be378862eeacbc0dfafbb44be7efc0671e70fddf9f07cfe9219ff082cec20b71bae334270e5800e54bb42917c6dd485e4f5bbd2f0055fdf6748501a3489b728af8ee6705bed290e8297eb92a691543128af3f39be0c6eabcb84e238a5797174ef8def37abb3399966a8fc6b00483444cf7797de6e6d691975943ea76efc0a6065feec31085609bcb5e2792272a40286e02aa47f3fe7c7bdc8ed7a7bceda0c811fb170733775844861c38d0896ba8687c0951b354702343781e51679672fcd60d9548dab89dc834eb2e9f0860b61308e2a6d0ddd70e7824898c368cb3211f9d168b503146d9edd6479f075bd0abef60154e8dc32280cecf828e59feab996275744386f8872893f01c329fee00d4eb0ce65ef3074ed8475f82dbd096c0c65c7149746c67631f07955f300eaf10774fd4f48b31e7da8c15d82599b8672031fae46986f8f5c2637d6cc7ceefc778e35760df85c36ca46af00a035c41e3da3d8a55e256a50d954b6bca784f5f975b23c8d3b1fb7d858df608cbc235ff8d3906546125c5ddf80baf98ad36769b026c13bc46252bddd3fd651568e9ebe61a7c8afffe06af98d75e3f9629a7d1bb4bb23a633d07690babb439d47da77f43d0554b827a235b231673c195f50d6ffa89d1acd9e3099981b16011de7e5bb3a8bad0718632cff7fa68a1d8448848a6ae01e3911dd1de9afbcc2757f39bc5c68f469a50abf8caf53fcbe24ac998dd6e1bfc1d61298ca747a189aac9c1345b45986b17b2f7aa1df058c302ef44cd006caad01823f4c21dd450262cf05e69878a8148f5eaf3788d84c67f8d31374446be2266b6a7ede09ea265ba3f20f3f100e1de93d440edadc66e972480ec5e59c5be924663f2aad721a51740c9cf2dd1dd3e1bfbbd16e16120d978584c9543e5313074ed076eecc9fdfd8790ec2d1818f1919af4ea4fb51eb8fc09cf7cacf04d1efe186811dbc4f91fa516a81bdcfbeaf9c2c54d732002026f2da1a9d52db681ecee677606341f6e7383e7456af37fbecc58cd21fdd724dbf24412feb5826108d13209656fe4be97ece23dde7298f52eedc7fdd445a29eaaf6d3095449aac71d7bef5119c29abfc28e5993969bdccd33c6b91740ab22e2271e68904f5474221ffe1a014adf88f9f516426bed7b8fb41b74cec306d3ea87389e57c4e155a0a5f4557f563a7dff71a3a902de5a868eee9aea813753fec54049623fdd1e865dd2212e6aec4053a422e2823072ce6676c3ce5d2afc576295584c5bcd4de546649f946996988d6cff4794d44ac9702ee04ae7d05fb2247666be727786f55472bbccbe4564137aff927e2bcc1981acbe5d6fca052e19d041a448d73fc24019f341b285860ea5ae731075137533b22dbd7e23960308519abf7567ea05801b77891c319bc2f8787d7f3d69aa2c0effe120676d67c8aa27d80a107da4d57b8b92a5288eb7aa7b93eca280aa3eaa33f69046b4f4621bb0ff2fd0f528e0d7e529f715da4e9a94c75a4d0739a4a8062aad83e57f02868575bc9f754984b1d747fd9807a2441f95902e63e670c7d064a85f276361007aa859d10c9ea8f0152a6d70c845ab062752cf6bad6a57e471af6f0ad7ea1cb36bf09ac10dd85fc1ed286cf89470cf8a4073a6f6a0a03892d39bca817784dc217ddad32c1128b41569369798526aafb8be963e32791885d6d0c424ebca44f531834e47a9cb77032ca4f41263dedd0839f960a54d4fe1b2335440ae074dfb809dff1c7a7b2c1036b19fe09c8ece2761d4bac73a03f5ec0da9ab4b10ead2726eccd02ba91f7f1888614a41106cd38d7374f6b784f246b8ad61b021f82746bc08a0f3996444f432e74a1e2a7458e21c901f5c9e7546734a80f984b91877463ce10a21c48c8bc797ee4c4b0f18bbeb58a7fa76cfed1b9d5ca42e3b1ca7d6b2915a32ba6225e7c463172e4d3e2a2d2e5c165ff68cceb332da4986552ed76240888804355c9ef4772398f63451ff4f9f10a6c78e55836605e8caea22b675b0ce09fb5345b4b69321ec81cbc7a6849a2bb754a52b8db8171bb22b93c1e20b8932d6d3e0b8662c815f8ca3dd66561e9bdf860e346b42088f031490dcb44f2f79fdb4e219dd283113710d1ce4cfb969f274fb11deb9b6e943524786a48936a9ec0fbbc55ff6a06a77f52d72ee200c0ca9756b95e711d2227a56d527f51f098e332162ec3246884ad7b41f888706e8598206811776bf1fccf249ade99ff8b41d90df3da8dd2c2f5f9be292598e4c9f10ba7009df0cf6386fdc542b4b9533d206944cc98a45af3b76a74da4079ec8b7f0162ee98418e64f72e4092d7afe7977c0bc9afbef6923b47040beb3a40629bd1cea3915a195129c24cba74e87692f589146b993e24264213214ac981116072ab0f32ce68e1e390337bb74fef033812b60b9da3c73aaeb03970fa4c224a79d6c2ab3f8a0db55ac477ffe53ff252e2714f0c8a0dbf40b9a054975d982f0da4d166fa044a0bdd871f5622df85ba98017ff208ed6a47017848b2099b9100f18858b457d18b7bbff40410bf965cefd5f4e20f0131ae0168655c8bcd3551e35201e3b0019bcea06921ebb0c39e30e3b172f248b7e72d031a7c72dcfc4b8fd76fed39f7a89f5a4c98448582b3e910a7794b2df281de42d8008bf836bc45b953c19af285cd0128799b10b04342520235bb91a7c7ff725bd8345c562fc3d8820c6a308bd20a2ba2d38cc0a111bb566955d86acfa01c62a2bba6c5ae2ffbf378d320dcf1183463c8d893983e9d79c5122e502acb6ac5ce870ed75f3594e34a977992c5f7e96182de2d78f7a635705f4125c1cda8285c198e5bc6d2fe6e4d72acf217588f8dfe6ea85452fa5fa0026b839ee92ca77063e6b6f64cfefff7777fea0014eaf9655fdf6067938d32eb4094afdf3e09d0a5b20f26","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
