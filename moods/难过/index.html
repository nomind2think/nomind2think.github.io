<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6db9a49fc059eaf7d294bbdb746277b3a6e7dae374c42b81b0f89db4e680f3432f9005103dfa62af3f238f610f5ea2e9a7e2b273d5e95361f270217c85f974bb6d227d41e1ee8b0d519ee84135c131d1726ebbe8f308f0176d066d5749c2be01a6f33a8a4b88fd4f62eb9779225ddd25a40f62e65f01e042c34d1b7a2b394a482814c594650911c168beda94eb3c4416152c776ddacdee85139cb4ff83ed15c158859e891ef7b5083da681d7f6b0c7cd3fb006965c9db2e48925726329b6d4099c9cdff072a525014a304165e6a59c389ea33d4c2125df0302ae7ea883262b999a23306f1bb222b803ec3f74631d45aa1db28e341a1a9b80c9e79a673a9580cf29b88bf4d340d8e9ec5a4330e8cf04aabbcc7d50529a12b9a3e3da64bce24567a623a40bcf271a1d179aac4b843ac0ca0a9a935198d6b56649d86766e797a1e7220cc06e9defcdca81cffdcdd87f2fe84fb080a22849cb198408ca2f3f65329d30ebd7992933e5f3f2ecd6686fe0639942b970fb38247e206a196e795d058e70102cf2d4a5f6a9e75f48e5fe7f6d85e58030b28869a2028bed30f2beeec381172286f4246ecbe8ca08fbb7997a407f04d0885e520e9025ce3df8199073692688051d279925216f2cef5f4b23611e400648a76c39c575c12d4276352be99847859b20ac820dda20240377f8d9b2275e7dad6bb254eae903594debd2a789a33d6a117685e8fd20c8b41e424e00d6207ad164bb25879f8690fb049b1ac732fb2b186c28a6fece7ee0e21ebb066de21e2ab67d535efb895a18ffa085eab9993ccd0ed241380e470a22ab0296cbf83210f4bf866b96711340e41b9fc1832018e74bc4a7cc76627c57567e9f2bb2567c98623d134c4b62c21003d97f362b8567e42eb13b9e5401be1008a20c4a6220a28c2fb793f010dc39a3fe342839119c8e08c47d4e4df45e074a852f171b6f06650f5e4182f3fafa92c55925cff5e7527d6169790857de58d3397c1f4631b5322987d008e90350e0258cb2a698175a43ef237ef00fc79a6b786850431490d6c2f5ba6f073e05c955524cbac066be9325f78a484deb4e7220abaa87e0aff79c1812ab3d59bf61e0e0f516ad0d775c41f2f6704ff26b0b80779c6d3b7981a17d6954aae4fdaa96cd19ec4f4362bc9c7234969297d216474d82e8e18344f8985bb007b04864eda2fad894b99987aef9d01434e50dede9fde23e0aae3aa8b4aa82019837401a898d3d98708bd46cd99859c1162cc06f3217f9a653b8d742892ccba5782cd9e40633429370570495fd26d13dfd64bd9d5b8af5b2a649d3d6b4bd777349f14d1ce50690836e70dd4cc1154f4c761885862264430c9ba724211e807f4bd926c2677832ee4203dd4f312446b582a168e3af9e1916aee3c76323f437c79350e3d3d6f4655a9e9f09adfc878392204b9c25f49771175595992a9e2201706e378d92c6d27396428568bbd984a63890642ff0ae0ecf90f202a445239b91a2b502c2bcc14977c4177b8848de37e3287e82d2ea3ade53e8a065949d926704ffcb4afd0d7975b0f69aa1e7f3da380482c683e6c84a8524a199ad7681edb861894e23893ab8606db84174fc729c69cf1fa0b070661fd64966483e51d4c44d5048a81e86b8eb015e10b53ba7e107ef6afb098ae9dcbc22ba89b9c147bcaac0a41ab9a6d584e934ad3a6c1cb7778de4abe4aeaeb5e6fcde228c03194b4f4c0fa8596f96dffad62321f560d3bf3a4fb7429f4fa8d5fd578c8e4fcb85b6255f944a30b7bcbce71f82eaff4c91aeaa6b0c284522451d26a0041549c33c3dd7415f7ca33f0590dd055dde8914a22ec10a11067906c2ffd3ed9df6385ca87e0a832ce151a08e3615c901c16ebb2f22dd532a7fa3ef7baf6215a2ad298d6afaff636fcbc635e2256addd6363ac683561ec799b0d28170fc7cb6acd04cb58366cac3940449a897e89b06d9a78a5bfa580bfeb6f68679ebf43f391dd1e5f891572090f6c8474dceeeb644eb2b96d18a9a8b11b173ef09744a3b9f9c6000cd0b7fc04e4684ebba965cf56877fa1ff5ea48d66b8e42e340577442ef03e848dc6053d1aae0230d9f8e234f687303c3982319ce667f9a7d0726210f44e47b36a30faef753bf897e4cafe138e8964a64f51cfe9d1f73d661192fef253187ee5486a5efad2ffaf47ed9e40609fe0f9c16e30fc3efd101be7f3e0146f3fccf2618a7583f04e4b48e8b7facb3c7c6d387d84fbafec8f2f10417299092b91844e732cc8f392b786aec128e0fe7c97f6660ce86dc03244c77cf08faea7a7707d287083a4b62015f89e55a2146f8b20387e25aa3b8513a3057316760198f1f4765f65a9f3bbcdc9ca5ae70a1f06b945c6864b7ee74fe11d381bbc785983b1a0d8507302c2b08264d1308ee9ab67cb328fdf3ad2466af19736b236bbaf1117fbd6359f16c1cd4bc90d4875a356316d89af7bd6d47b65b7bf28a0e33e911c47dd3ae803e4e8be35755deff8d8f629ca8643c80cf1987bbee46312103fbcd96cd8e78076f2258cebba0e6e4ba3e9949b1454e06793b923381e1c29e8d154330a7a65c862bb11d393d5ac79f26c9801b7275f99a8c50bd5baf5200bacb6c66290b39c6c4108b585ffc77f01a4fc7a75322f21547d714176ce0c7ccb674fa7879c1db85f02b9254b8becca29c825c5505eed648f7856904a0670543e89661793ed355c54a69b3f77cbf51430567dee29c489d52ddc4b2e79aefd6853dcf4d49bfff95f7be091cb362b3e1c7c23af0d8a4605826e3e15fa90c7d717cdf46be313ce7f1ac04aee5c1d9e99a1acead0d44ce6edf5d349b6e86cf2f5fae651152bef7bd7e2a51e4802a014bc7d9029323f47b0e747ecc03120ca95460ab2fdb19bcc7647d4545520709885f773b4248a095da1c7191170db5c4abc020be4f9daf58bcaefc7f82f283a38e8a9b0bedc826df6dc44c5a466e9b7610a98a1807a0734d0575b6e1988073e1c9462a1e3f91e86cf56fa46096e206b0aba95070c0e57ca82e7dac216f9b09c0eea3ac05267b4e86f8ed4f731ee19ddaf78e82f552bdabb366976a273d4333dc620ddf01222587790753a69188643d0cf21ad6860fa05133a7c7582b055db714546ba94eb95316318def37647520f03baf4adeabbdeafb91c305d66017d820a784b611c8d1a751d8e0582bcbea9b265fedb9fa956b5cdfb88f4d4a894b1d55032416f4db650ddf4bd7c7668096815557e60d7d14159d8f31d0e9b572cda35cb464ccdd8b0912b1cb8e31e4c562aebf3bef7d468968cf861e20b7b5e94304d8d132be2b3a1f99913d439592a336ebe6989ef728d7489bec8bb5e3102b93515713267ed240c3a4f74299d7ba43cc83fc7493db4da337f9d92d37ee05af8d4a51c9b1ee683993a92d4655526dcbe36168a4eeba9f2226f3497d7474022da1bb2128dfdf7d0a38a6604ff149257890c458dd675809965af0bb0ca1df369cb02bdfb8f59419ee7cf34962ffe097990a8e11b507c5b48a88128140a41a1709a7c89aadc57f96afda8eee637bc27adc192820dff243a5a2456b96d182af8dbc1adb21f302dff128fb8c42bdf21deffa3043d84645dfe15f9339ce1b9d59aafc711f65b298cf69c46c46213ce168c1853a85161ba98bf02d4ae54b4bcd9a8d1054635a12e0da56dfd03999f62182a3a881c0a0511108ffd3156ea55563e4aa5a4a57314afe874a8ac1946520a7b770e53756c2961aebe5820cbcfe14c6b7e97fd7aba83ecbea5ee5bf7ce0a28f5439a8e0640ad6429a186989d2bfc514b90f4f610d2542b1f965bd30fa9b587b985f4ece01e9e5b8232b50f18216f347a243fb52c92f63cdeacbe2908c1dfa2d31e8aab5bdc2e91dbe5c86fb7eba6b09967b8bb9b42335c8d370aa08d6c3b161b689b9950fdc801795bec0349c00f76950d61c37fbdd4846b6773598894434ebfb5bd81ca0dc98427ec50ca0d55c3f442c0563cf5d1ae5354310b80d8fc5880cce7ba41ff5675349efdb953643925b8bc7bf3271df0a382b7d4ce54d09d76ef4422ccd11cbf87fe97c7522bbbb87c58888ab3e102b6ae6c3daad6e86fef0c412ab933e1b65b2837c6eeeabaa107b7543626a682323abf23a5ce35638f5942e6dd34cd2f0d8aa53f6b92b9ef26465353a75575bffd73d8eee4d48dedd9c7d218f9acb94f369150b0692bdb7b069877ceb98ec6b48ad29ad6e4321d194a5fe2d3db4d398770e8db379d80563d7eea384e5432e7c4e8bbf4413e44b0b23f2b072f36c9d28ff2d7482f495bff96365b130c5eee55ed530e7cc350105ef81b838ef153b9bb65e3282666ef95dde219266f92eef4f783fcb443fd5fa9938aaf879fe4beaddf536287f70807ceb4be3f825b90df28eb201ef03f7b1a56a2a28538d3d6ab5cded4980f8d4116c25c166d17f863d88df956d2e08e12a36b444dd354f9d4947f2353cd69303a6b361a2630e1034c66ceaaea3671a6b71f3a31beb0b80633f8733b50978700166af252691b30f7642e4b739ecfaafa58204f345e2d239b808e40c664377778e444deca49ad49b4d6879660a2c406c4838b777f0a7192509ce7e5a91c1bd0833475f3629760f5e9c2eb01a566534cd60c9d2d749765c9c107bbce3aa676020fbbd9bcc086901f4d1aa941d82e366ec40d56be6335532b44087a51f7438cbed0243b4e3059d6a906fccf97b283de6bdb992f8e4d6b09f6eaa71ac2d319a4f6179ca72549c240b225a5c00fb6aa9d97dd7ae9624d52487bc15180e385bcd6f1396aafac6484b9390567f6b54a56b52675bd8b79338a3cfe288d0de71098b00641db6de14376897f1ebe773460f7bd0c25e3149ba42e2abf9ffb1d3db89f9aebcb72d6b22fdc64f3053b1d6beb05b0bb352e97ef1a3fd8e1827b828e9082fd6aa9dd1f1f38157b60deaf623115233df9ebf4d55206680bee146badafbff2b9ba400a9ab0c7b4807b199bd924bf0c3836224d7bec7f628e90a687f1f3674ad28fbadf7d9449fa0343b024e753a54a27fd6bd3f039b22831920f146085f32223fd20c2b0a208d06ad067503c9651f9ea20e5df573e9d5c4b2876c277e6d07543d78c19bcd6ca1d0aed16079ecef3191505122eecff4d7f6eff280dfb1a643d0042dadb25e56e7c7c1035772ee851d1c4cf13124b75b5cf6f2c2866ad60da20325a8778324883be458f708152a1662a7fd2c5321147d7f5c315506404ad49016599882e2ab60b52c8d8326ba88ac16696676a57616f289dbd2f168cd431ed03fb698962fd4cfa95f98266857a06fe6ee02647468c86b299aa161de79ed462aa46a6cc264d3597a8f943e11da04f79e75dd123d9c78dc1c053a34b76c0f5648cac98c6eeecda6a54763cbf6992ded507559fa8bcde0269a1007171704e9130224888efbcd7b02250490ba4e3d77aabc6caa22213c60e96f25dfe6a20d201bf07b05ee9bf2916b08a891385ab0f4320a1a2312182e2c9e3139ebcd644a0adb22696f3f2ca40221119af0f27dfdfba6a11b3e7f76baf1dee2a469c618ab1df52ace2ab65ba4edf3949303927f5ce0620eb97640f6693d340a217ad096f9e147bc89ce2ad5b6aff1ad88d1c84942055344aa8a888f578fe0a7d222f6080f7d55ad22c0e44ede39bdc18b333cfe9dc31f7e478956ed43fe71e5dd809cc62379317a05e91d8b39eddc44edd0af0ae056826017242c6d3e073040b832f49cb099cfcb3dd09e857278ad98d5979faa9896b653638774e47a7ba86e74b230d8d9298a3a564b4c36d9036fa98525a634848b9ffe80e8913161915867e5514f4d059a6e27d32e4955c61a8db6a55dd93004acd9feebeab798cf1f55caf4ac9ef0cc9fc8ac9c414d0a157f2ba6caabcea0e48677657e8bfd4bf5c4f11446ce9a85bb34e885620bca5a5110c94dc51a41a38cf417fd1f81ae1235858b2de45d9f20c94798f6192d953b2625f87dba187312502ab278fe35667a9e6c5e76889acafd019ee5a8d2baa7c4138fc7b5782b35f326da432afaf4048ae88bd4e24c76d0e28ecc8fc61db4a216f55c842f4de7af0b8e98ecbe4d5bdaeb27e485bca1695e401bbb58447e858943b1c66a9dbbb9c9fcca1969084133c1dd3cabfd8e6966cf4d7ec2f3d09b2a137d49fd4256482c74126d08f5ce89c5c2d3cf573bcbb8204dae326bb245ae8cf1dd60fecb51bc842b918e59e6461aab04a176fae0ac102ddbf26fd0aa242185980318d270d4e91c5fab6bbc7cad0765b11eac6965c85c6f42c75c2ffb0b00b84737b2e1a36e19bad130f3e0b6a1d9b0a152a9e9df287b23b6086becc1395ad374a580a7885ba9ade674afee376dc3a629a35baad0c38c2492f1ef4d361478283fa764bd1ab7f8be4753270445f118948a6e1aeaaa76efea130b0d6e3bc4dc9a59ef15d5c9deede1f3c22cbeb54d8cf104a04aea808d0d880449759f6a80f958d0caeb406f501330f9dd760ec2f2fd65eae4ec02d98c02326968632cc9a024316785f69ebe1cd2f9029dc8bd6cb3f5be51cfeea6e3219e919b7dadbb91108df81727b52864918e43ec04b94a548a0981ae2f147ede87ac043f9fb66b28150365e7a94d3c806452bc14b142a174a2bdf77633072dacb2b7002fea93251bc65843236edda85178498ae4252c7a17396b86cb03f573f1931ff6921105e76e93a07a59d6d38a2d0f57280bcc7c1b7dba5173c5e21dbc3aa7f2cc21ebeef6c56fb7920d959b624c1f047cf1af0e4ed23e541f7df6ea5141ca14cc1537b73ddb0269f2b056c7f48c10242ca2f272a5934fa7f22be7546fa2786bd144c78a8e4dae623089ef5b5e9616fd199cbdcb36d96ae6f896125c37dc06cdc9c0ed5d47bd80ee11bd05ba0231fc7efbcd85ad8972d5cc62922eaa06ebd6e603f1c9ab655e34b8ca333475ccdaf5ab2d93be3fc60e58b1443d3ec66d49657df8063fbcc4c20638dd5853efb8471a0ec6de38df7be304b5adc6424755e257153dfb83e1541a0c41fb751561bb4d8d3ea3783bd9130695bdb7f0e17007bf9111e98a72b9c95e8903a48e7dbf97fe1a47468d96842a3c48056f615d273dbac90b418544c6f90a291e8ec91be29c8a33fb312649e91086137345946f9141ed3092430ccc98ad5d93494136906b568847407e0aa709e8414ea71b630aec6dfb046e8a43939a05e88c88d48d207bcad38dbf221c680a53aa15233e397d2c3aba29ac5a9111f2c505ab91f4301f1caf416b84a11671857813e84e59ab6866a1e25e9fae223e5a3c99a2ba9ac28d770520f1e426c6fd0b1ca219ece7da1cafe605b7ee49976d4a69fcc30a7b74c0c54a1757c6b24da04801b6f346b9e0dc546bb2e1e9e09c8a1d9addb247294089dc9abcd99c23597fb09ea6e480ecec23a2eb8ab70119d30525e729ebc621e09423c76953c0be91e14ed717652b3785bc8198164c3b15d9e66177f80c6beea89d4cd2b1474b63437f0950efef909c6fb3664dfc4c452bfd1599e7a31a649aa449b07be3ea9a9f708b81d6699e617f7124c5fe475f80ac2e3ae35649f908e80ca436332c314a9fa13f25eb2c52f88db90461df27bff8b6ced98f0918adc136dbc6527755dec5f155389a9d03f824e59a6629c288572af67fe5210d63cb15b3ca016a0a37ba8925526a310a5425f94074d5bfa37ed7027da890f907666ae9642ac4519367d7bf09b72c945229586e5bbe92d51bdbf805e487f6625728a31355867a739c96e81ebc12bdec84d35a96b0a8dbde96f73d48b7652641b783c5635e66ac79c2543200a54517838da774f4aeea8f682bebeb07375706c90bd3ac75fe1d6224403e8ddaaec1e5a976f3fba1fcf2c3da06313238fd4a29ddd0afd4f6a0b41b63ff80cda9321a8637340ff997135148f12da6d8c6649baf1ce81a7c58aaa800269d9595cd2124978f622a82c278421fb5c1d02d0bcda120901d5340694124aad138393c93f697ea2733675adb0690fbe79fbe07c6b2f5a2dd64a4a505e73802e1868614d2eed2a0c6faf6abea90a4a66d91c695a791cda3cfd9d67f99bd45b38a375b8d5e61b64b17f707502ec49239ea188eb746c6b9a9540b0bf98826d42302b81f85024bb2e2b1545c41bb564edc5f9395a8b7686e5660505e4a7a6bda3b21dec40539c0ac108f5bc3701f69eec1db4b3060a3590ab9033f22ed0ab7229f497efe42d92c74cb9d396a255d4ac1abd54785f81f5792e0d6f4946308ad21af1b0d63bcf472f50d8ecd70459bd41ea7638ab10988f95cd6127a65af994239d1231c69b521ae7dfd5d9ab24ca9617c867486fec3e70fb10448e0d0b3e34adc5ae1cd84b3d8b3ab8a0cfe67c49c4a031422327cb197f5fe93c951aa29bd1b684389eea9c85507ad4c9a68c556d6d51d60b01645a68bccab9098e4f06299668717bd655a0662387ac52b87c7830f33d5878bb44eebd028daec7afca57d9b67769e287026b620d79ffaa2b20c9be5e4993da55fc3c94f673a151a6e75a11f85c134600fe867da3a69cbe9bcae7cbc650392cdeb8edc5e1bc2b4ee059b8571a9d1caccb367a83060257b1bfda886f12f5d7a72be38d50a9a2b0af8596751ea84af1575b7d7c4c9966438a602041c99be3603b2dd55ac3e04d9446f0653a34a4537b0e96841fc0fe8313fb51c144953b027ecd7c272a78d4d3dda653e0797e8014ebbad0b37fa95de7d4a6149e322042dcdf02ff025d4430eb31edf717ef6055722017de479835d0120c411165ba840df4dc3c1e7c8217cc355c132085f7767c3a6bba106207dea16d99309d2c57b8693fdd4848545bf8aaa683e943c46007317a6f8783527b33e8b377ddd994a84bd937c820ccd5fc7666c290ef29ebd3587d7ee88650e2d27c10c8fe917aa9055f29681e8c4eb749d911ada8915086a764d4db17fa6b887513b438282e4cafa444f4f7e2e3723718773f73359fadcbdebb74681c91b7d76f5f103e0dc4c6413e786f18c8c7e27b9fc0027babe752c53ab6cf4fcd8279d23e8356abd3efad3ca48b35628c6b53aaafbb7dc57afecbb387a02c68e83d0565eead5c7f3c764aaeba030e584a77090c69d99a01e571de99f7816afd00b915b151785210fbc9515f4d903ab320791da46ac8d6abdc00a2568d0194743c7a68a3f30d6734f7c6c637a4a989f124a01d0259c2255a4057f30e2c80ce6302af17799dc574e4bd7083c84ebc46cdfb8e21d35f625873ac9033dc92861aff8ee362c9eacf488e12b77352cfb5b9e8707923a0607e69b8546afd7882f293aa1bba31508b3d463f5ebf85a60101a313ad42153c64b0770973e1755e74906bfcbd5cc51d6badbc9499838b3c54c37219cdd0237a23bc1abdfbc68b64bb015f781185cb72be2f64374cae581f643fe93184b47ef2de3b1eeff9de8bd387f44aeb332c88cf1fd8681eae608e620945663ff0462ab91efde7533cd904e05808d475d12c8f0f5d6895284d199c760c94559b44cd8edb5d7ea6ab1793be19e3349a88be034ad80a4eb7efefaa8fe41c4c4edf041704b181b32fe45cbeabd823e78b6afc0f17b7d4cc2b6d740285c440df805222998cde73d22732e209e086b46132da134d340daa8ecc4afaf1d2f2e351aab3e4beb59eed9181c65f428c97ec20e155c34cdaf3f49db15b237ce3a6735d39d77f45d536143a55954bda59bbb23c1bdf25c335221b535e5a97913ec10f10ac3eff87ef6b96d2387cdfe3869d8dc52ffe5839761d93025c41531be5ee00bb34f143fead8d98e1aaf1cac7238ddeef5b1f78d7fb773ca03aa4838acdf7a1383f94ff5d58dbb2c212b83d69442ae70b466edf9a6a94ac3f9ee7198efeffc3d0ae87c2cc61874ad1f745482c926308540c34ce41629f45d0f2aa6417015ee57c32c4b1e114dbae2e5b2dd307138c9c5f772a4b2652851e7b0b178ff7e97583bc9c840a642ceb10c6d8243e6a807d2a32899bc4de7b36f7c8dd7ee8d2bf748bc6e4ec6d9379dfe405e9a9b921a705763a45af20fa3acdeece59c98bed164d3667de4b7f4db97e449e6f7b76ea371014108dddd95a3f942b8dc15d5df09ddfe4202bfdf5b1e75345a9967a6848cbb8dc9b51b857764367fb6c73c21376f64e3acfff9ecc2561d24ad82d5910bb13190cb62c83345785e51e81f0e07be45ceb18b03827e0309add843f20322d37db7839a0eea5e812220cf8d089cd6523ac2c83053616087c1edcdcd537c2286aab2882df7504a3e3afd108d5da8c00dc170a9681f7aa565791783cf662071b6ff3bfec43eb62d34c2928508198a2e1cb93b538925a476ace4e2f20b7dfeece3f223b8c70aee229973dcc5388b657467d2a8fb50c1f2bd99945ebd144fbc5534ab1e17ba4a4a105b49eaf3b63918a6570332c0bc4e6f4412027ed366e859030b7c7528872c860ecc4536ace88369544779327c9d477b82a105b3f48b4a145fe96dfb92d41fdb54568da2b9af300608090d342552ab821543bb8456591fedda4ae68ba66f209fc6abb93b695e6d63b9b42e7cafbdf5d0d11cc7f4760941f8e32d3674a7afc46343dbcc3cb3283518c870421b3bb03712c028ac5155c31c5de50cd57ec16d9dc585a227de95c0ddc77d9efb737207df669d0cb1cbf1268ec21f1220839e4a6a08bd0ebd80aa20d2c9695e109c00272aa846341076be332239282a6dbe85dd04cb3eb4801e23f42e9ea51ed1ee00babcc333458a8097da4b597e3a042b800d69743c086eeca6d02eb969f10f5227a5131caa161835c82fbee65947b04055fed257abb758feb73c3253f6c72becc2725edb86ef691373a151e85752931ca345d226adba91b5d263d69a0035b19d7eedcdf648bdcf4c3c389133d2fd6f375eeda775c46ba9fffe717073890f81941fecd2dd7eb4dc1003d018fb2cf90fc7ca916dd6b5a040f21adf901ba2263d4e1987a460053ba4c5256faf56b992d73d78d2a3286eed29eb817e1a64c8ceef37d34b4f16b201ad2c4622e2d7396b26e714ed22d4403b4be3c8804455b6e4f2cfc026a6a291a5580affa93c4ac6591df753bc2818809c3c5d272f0eea41c90d39dd24e727641da3e0b2dae83e7e3b8095c09f21e3898487de112fa45c0ba8566f9ff13a6ad89fd7290bdf3aba6f62d91560b173a5bc6e52a82e5e44fef1cdf986555479bfa7fc10907d25c9d046bc7ccbbebe30283c04312f821148f39bbd4b2ccc7406ff2ecd6d80cabf2734893e77e3333861534d96fd075e34c53c3a5fc20789085d9061b7e5d0d1a059ba5ff6da24c525409693d6620dba78a246fabea55e56671fe50e25ad8457f74da00a9d8f38cda2259b17e07ff161d66c302c01ee1e68c03f81737191955226f6e96dcf8c46fde70e5f880887bf32fa0d47ba7d51c294d53d3401fd9e42a05459cc3052335fe6c796b9a73b25407f374e603430f462add151539ea099624e14cdc2d86cd43d078995dca3e382a15816035d5f48b74ce1f6ab8b1638f569b32964d6e663c8611b36fe8c5f5fa386ae83b5539b01bf96cfa54926b4dc6f28f1ceecd3b1520f23f72e095769815d3d31245ca09fb6d2be69d2ca773aa24d4cbc85c637857fb67cf4f5709e20bf706e30ce41c86c0d54a2d3296e57eb261481a7c82b098ad33bacec9a4a98be381041c898f3fad5ab3365a842d08e9c41baf4e258629b03af0c954b007f695256714badc4b271155084e68c797f57db32b98a1281f0b5bdc730cb0a1f35488a4b7e430cac4a8ed4712819f0cce9931a00922df3660854bef0c753f0ca558d11fcefe604dfee335b26a0a9eb7ee240e20e771afd1a9fe07a4620665aa0f6549171df4b8627061d172ffdbe8d83606676f9a0449140c22a68153c8e915dab80583e3846b568d87799bffb6c456534be17e737d61b603b21add06c2a29f50fbfe740dc438bc81151c5605f2cde7d19569c5abd938c8fddc2d47798a51e60e12515e82e6b2ee4c6b9810093a47c6e5edaf65543b13ccdb4b1a1e928b5a85a275933fc891fb6c2b863e7373f0fef098f44294b0fa46a0352d1c24642e7f02b7d237c598182394b873e82a2d25d1ebfb7d1fc1279e5b6eea8601f2006c25ed9aa56de834c690f36c7557d7bd2531865f980e6e1e2ec3be91ffad6192781aa0dddc4d46536874db78247dfdd52b78538351bf395a818ea2e464ab5451fd1cb2d7c9bf3e2ea99bed777435b8c1fc5913090161afdcf394d90b15eb92dbb7971","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
