<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31217fc4d5afc32e340ae4c0dfba4a1e51354f80d777a840318fa71646a4274625b7105f8377366426ae65386ca4ee2e74ff1fe7f63454292dd901743351af33b21a00d63ce71a4ba464117e396e17132ed3bf4c6af999d1b23e9709bb7c5fe95aa6f31dd533d305f2d405c1cd5cc53ef4004fafb8f3b2654a48885bdafe0b80bd58e4045a36d5fe2da9947f3e9f7d67d75be27d246c727311cf6f673f9798459299c9d13948fa26e24530aaa8821131ba19b60bb74a2e348b0ed3dfc1ee1e60a68793a11fa8fbe1fbf44a8701a8c02edc86297908d9ff807a4fb701cc1705099529d0a0089e264d73b54e3f076d014cbda193ac02c6d1cce2296fa9faef8ad8d623668dee8ad8fd9ce35ee191c7112939635e3419f14fad467d766f871ecf006b8c48bf46ffad04f8e8d0f9dc5013aa5890429233340c26e7249c248f9a962d601d5560601edd52cb493f5d0dcc5a4f850851336bae05f280d274ee98a171ca4c96f42996dd4ac7502781fbc8e7d2730faf0e8fcf709801eeeafc143b43eb07e41252949786528ebe840de5e5f1117b0b40c2311772ccb4f59262d84bd4138876f376fee55f6c8aa44367744481756f672b03d8810ba94dee2a08d424e3890095fea64b6a1edb10bd3622a80867fe05f54c0355a63595cdf318b42df207ae2434d8871779441debf6394c885743fe69a396bd2dc813d06dc75de7a6809828a98f6ec6b4c50b3dd1403a28e59686e9e5894ae6b1a8218e2445b7782b54051b810484b96a2808f3724605484bb4f55724ec962f5757e98cc6460cadd5a38d1417e82a163172377e6d3387d3567ce86ee40737cdef572884271c3ce2f22bddcf46e06ab34f657ca1b950b8a735ea345a1c6e19a231d6c8329bc261bbc965fd9b2f3e674b3285f9be5588b7362416e8cc34941f34ded30fd07dd560fac2100a8d83701b84e18b2d0293b606c152b51bdf63f86b7d201ab5d873fbbcda5ddeee1276d005fc645b729b4c6715f5229ca30ae0c0a2561dcfe8ef538b7ebfe2c9cf6f8ef44c42583a6de4c21f2b4dfee9320ef69dcdb082c60a29f1eec960aac4b83a285fc8ebe7c4fa4a36f5dffbe75512b8b304122f94b583db33913dc04463cdf2c2eb4b32af8ca788c9c110077d5671a9152bd7d45931c4f096301c545e380c4b917aed88d46b5833cf5e80cebab5c73c848812141cfae40bf08f1b8466009a5d50bcb8674a846e8c20d7a40d1170889a9a323cd20f8372b41a1ab3fd8a6af732006d380651241ea2ca11a8dec4caa02181c90e013f4427a27ba8024b75b9e43f6482b4b80e04745dbdc2232fca61dd98eb0ffc60cacefe42ad71976a44139fdba8cf6688c40906eb9700476da864fc0dc05d59072a911ec434cb38e3daef822ac4e787f5be73a192a48619349bc6e204c3f4030db4b9ad7b91e5356e92440919cd394c0bc047f7b0db70f0f590a7c1cc6792c11eb9aae3f49ba0c5bab84e2f47d6a40034b4b9675122b194ea1cddfbd974b5e8692aff27904109d4f5dc8c23bb99d7a4b6093f2e7b9c9ce7659d01ea813262e94909ad34ec0cfb820e5995853279064d12b7e826bb3522829fa1685e259164d250d03784b87175d2033ad2abaf1df794029d80c798ce793468b53c0d73c031a8d2cf8d7c5ef98c9ffb9a46d4d913498e11fc9bd69d9e36b7e654cff3cdaa753f248524222d3d5e94e26a120e722562113eee47fee45f5b572d10e535ee42f858cf9b925e2d9939f9bd1170367ed5c412dfdefef8221bc62cfa0cac8b4e6d7cbbbf731c7c367ca593f1d8247e2f10719ddf4f4bc528b8f6fa4fb264c95264eda787418a1a6f529e74b1f04c677b25bc725e62454cd6abe599480c85fbfba9854dcee25d497dcecd57ebb2e68922a44fc315ed451d60b4489864969e023e86aebfc23a76055557df53b6e8e811aa38879ff6f6945d9aab480780595e7839db6ad98c338650f8283587ef104ce04d56852e3b8a1b13767e955cb99d7d1328a5e403ae23bfd683883e3759fadf4ea84c5883ab19d0b885fa5508959fff15c30fb4e217f0c0e8fdb6beefe99abb1841358adfada32c2fc9d9e06b686061be4ba4075776beaee2dd5b658788001b43f478855a5e737b512318d0ab3e934031018b7b0df37d890e71a5416eb7cd0ddbb00fd8fcf453ae3664f56ee03ab53b139f2c3528bc8705730880c7bdd78d7c7f9cc2b358cd01b9b81b7780ce2997d4ef3a20dd19aae78e5045ca0213e8e6b3e843169f17b815e7ca2ec268bc5e003bc7572280fcc4d14f40d148de47b6e22619fdbf2fb24f7fd437c528889390d650ebc9cc04466913623bcbafefa5b3f1f3d2a534fe369b12ebd214bdc5f2f0b90083e9460fd840bcf8ef57b21fafcd638ca1f5f1d5c0ed3288969d01c1565c2d492ceb62f89021e8d3722bb8413efc54007e0440176846a5f12afe55805bb02ba96f2e2a6a03d1859a0c870b84404371405c216365e5c6d6822ed7bb5deceb527599fdf3745b79a5c32cfb9c0151e980d7fe868de43021b652954c55fc8d989b28b7624c002b1642225d43566a795529975e74b41abb7a49173a211566de62a67c14a223a0aea926cd08b105ca4a4f07801169406a9029d3a57a6f1997bd47aebe6cc9fcb1a83c6e646873bf86cce86ea34f0854aad20d37eb5a8593322af0f563a3530724e7b1b26dd548b83ff8a8ba11d179d1da89a2f6279bb98d9d8e794bd7aed1455d95ba9d93549d8797d38155726f132c6ae43df626f51f5b1c4ced306593260a0fbc8089a5b414842aa0de77b79766d0f97a575ae040df74ed81f30689b77ecf923693afc0cf13fa241341bc4d9804ac6f51e91b4a3318df271285290f8e429bceb2d29dee8f3e601a0c32153a8025db837320ca90c3dbbef753a2b74611696ba5b0492d5647aee7ae57d2e79788daee2a575cc47b0419cf897e8b03ce6632071099b98455c81670224a40160fd6ae2ca5362be512bbf677eb6429b78aae73c812a0c5e320080e2a026f0257e16e09c6eb3b12ded25b3fc59e5c142038de4f3d0a62d91e10e365bf3b4a36651d8fd34c377af814027cd1dca299b369ee1b3ed8bae21c8703dbdb03779c79b31c25f77e5dee481cc7a8e69569cd7df17d7b6f8d36a0fb480af7e49a11466211d0e33bcd5dc6f3bc3b92cf3d397f2549dd076c7f113825f17bb4be8ba6fdc4c984867cb013fef5d167570f892691fb539cda8fcde0825e096f292ac2b71425ebcd2ae4d030b4d7b8469752212ce8eb25270f766d93e8dbf5a7f94a1b2325ddfdfc41a87e6e9cc789052c130a29e72584946d3f5dcbbd5f2b51c7fe0a697bab44b3b0efd83e83b6daf4d10a93526295f699c977d68dbe9ec276e2c282ee7c360829375200704278d1e7f2dc71889aa17c52f6916c1af802c5011a87de4936ffb5cc8ba82f7f8594c1f0351dafcd8279137e06ad13d3aee29ddf77f765862ef4a7b2478de8cf9aa971a9d94a502c0090a6311d5d19e27208611a8d657060a8c6653fa65b7ca79db429286a5f00376c8ad3eacd6aa1d56d68fc2055fcb08b653ffb61747d784ad1a71bd7c47f10c8c29af4c694861b7ef3f345fa19ce98c340e00440bcee6a1f61493e2be9dedb0b8841761c7b7a8513a867a6fc5bbc5538237adb82f4cc0ce7f63a7e67b5457c285769875fd85a6dd79df4010b9047439bfbacc77a05126abb62d9188994d21c8834ebd608576841eb7c868d620760ca25a6f296c9f3cb4477d2d29da44fd9ca4cdf0e28c71f98aa641490ebe8e8ed6ce6691db1b2071c43bd792cd71cc9b219aad624ff2bfbfc130000d195f952669d47bfcbada28a66b00fd9f6d2730d609cfb3e9a9a5c35d5294b97877bff999e80c96a3ba0fec7d3c2992ea9505e75574e924682329c9936b08fab5aab5a0e26cea30f03b730d67378f554d9e8ce68f7063e1f8cc9a25a922c604f7caafa286a895e34c78c68696306bb613bd1788cafd826a6bad649712e1de00d59e3a0e5452e61379ea2d245a75ec01f58359709186d68e48b948530087dcd98c1ce08c3abaecff318c206e8128cf8607a1c9517d443b4b6f0a760300b30e0a54622f5ed06c50ced47d96687c4c757fa215ba74cddc8235cf9f93b2826a273b54f4877e334030c2140dc34ba0c6fc4e4e941b70512f96f72b9f3ad74c221f34f8a95b33c97694b6b866383ea10b712ceaa04f755229d8efae85529fb38a645c69d4360df3708cd312cb435fb6f6012e3f49ce8341861faf45a6c7bdc1db9f17ebd4ea25c6ed2ca1a0575ac46d7e12f22b63c4a6bbf5a93b0934e6d53237d688c7149e08fd95acb8008b66fedf093801486af1768a8c6b8aba2df656b4cac24f6cbc5b27f42a1394387f6b76e9c6a864c15889020b57f577a38fde414da717cb3bc46d18ac64b7ff298612e0e85ae7daa04772cb25e9321f0e5dafa648c47dca02ac2c02112f0cbe53968efa0e8de3dbbb00370cceac47a0d8e5033d893a107f56f5eae3598cb489bde81a1a29d6b719b28f113c4091901a37e3c35492ca14af3af2bf9a4ec57ac65d624683354049fc25343ec8231e480e199a6d1c43684f5bf92405b52579936e7f00aa3b2e27bdb5b110c002d7db34ece15e9ad1f40a4bd5252fdc9927134d59a1960b60d42171388275d1bfb0651982a2fc5929d71b848ff1fe79dd623bbc279cc599c4978117571c5e91bbb02d3a1ec676d5aa2d6cdb39e887d4ed3de8561fef705dbcf1d361b912c6a6ddd55623d1e3db510787e56b2304d915b864b3d8bfea35e2fae434a8841d7ace5c57f35599a1b38449638a6e00202e9761a46551972fd0dd326c0a3b836df104ae9f61650e93dc07899f29c5e25962ab9a7ec67f82a3e63c23f021f9501a632600d5e73ce4039cc256d6581848f9622082cb30482c713d9dd8f5d11e55bd59b86f9fca73b490a6f6fcccd84c305c239b4cd6f7edddf1ee236c46420976bca6c537cb9e0eee21af40cbcc3131012b721d4a7f0bd767ee124b433d2f293efa831b734c415e20567aa9708168dda927c85ee75837fff73885956a6fd47e74e05748e92987cffa66c32c3843719f1fa73555d230266ddf648fe1c057207280617d7b454f73807aa68bd459798938a7eef527fa562a50776a8034ca86002adbf3c46e22ff761996dd8c21ec921b0a8f60351a729c6ad7717800ee01af4153ae53a56f21320f9576f19e13b809c71c507a010ae46cd6b8f79a296c9444dd4612084a5e1e3a388fdcd58e70a1a28631b836c70ee4e3ea55e693e0a024b7692751adac0742d0f90865b93a3c4e7454ee359d93b8fcbbfe2e1533119b25822cdd21677b8b0bcb539563d1c86408e4b0b5d2e67452280471f098ec15d4f0a34c3c4e766431b2aa68ba3f1b2e0f29c8ec108b411491691e002ae3e7a398e960eef306c63e0a32f59d4a9346349b71e15aad9141f5d3b04b03649fb9d564f81a925cb3c2a44182346de00ea2c34e7a38e9f06c4838c409759ed24631dd1aea3df89948bd5976d695e491f8436a3f8f2251b06b1b43c96d1252fabc699b68be3781fc8dd9a9aac6358df02448c28f4cdb80f98dfc9f02788661728eb575cbd6602f5f29004cf2cd65c0c9848314b9fc72457dafdc30622b3492787fe4dff4fd150fd7a9dc7723c168475a8eb9109133477e80a255efd28810a5e7b53307b5a534c0a119a29b1e9d0213775dcaaaea4e605796c753d50bcdc9c4549fff7c842b4907ea33409d2c5e43b9bc7c7fb161e8a897d1a77594c5f236950e0b2d99aa166fc3c75868904ec1f11c9fdbc6edc3dae0fa148d0de55b178e73cbb620c442010fe80bbd360dd4ada40b224b071e99335f20931fab71e2e29ed63b37e7ebcf6e6b502212af2fbd2618e68d24362baea2d507ee3460138763ac6b350300f34c45f2ade0584b77df99cb7ab7652199b2642c640cd002b0be7576838f9de0b325d026073b31131c48203e218f9ec8fbbdaaaef34e6bc1bf31e86aaee14f30b086e0583445872b9b0561e75311276a81c969148b2e20794be41baa7b0291b81d5fbac6ef5bb4f8d33dd13fef1bc7693ce39eb687f231422b3b77a90e684418ddb470ebe7e6fcaea74d2be6b92e7b1916739d27cf765fd5d41a543a72f7c4c1af3293d52dfa0833f3be66f8165afc862d4e799dd1aee359c736731861e1433d806b48031f32665b91b463bd64e8d371f26fd42591c65803a90e46d9ad7c4283dfe1b2269118e198a8df51e93eb06c667f03a6a6b7547a83aa479c570e700ad1c73c4c2821c78036eaa45ad56f7edaeff858c1e6a435c50d74ed30db08ba20d3e038f8a6b06a9cb7689fc18548bd4bb088f382d534c19cedc2719c05be158a3b2201e9c39255d16af702557d29499315f060dbbcf46d77c9f659679b1535b9945515ef187adc10f4bfe6324650a5d456a048d8ad463001055407494e4f07db971e9b0d5a2604a3de208e4254f7e00461792c71be937ef2536969a81d7b0191fee37fc8404fabe7bbb3ab7c3cb8461881db8f79a05d25a2dbe14af02393bfab79e4e96aa8c8a8d1e40442cbb79ffe7cfbb5423084f2cdfac6522fe0fae5d8ec6029aed5631ec9aab64f26acf1860686ddfcb347cfd997e8a28449e3711dfb4b33de51cf715e6cb1eb5ae5daf7c71bd0e39c1115501a27099f40691bcfd03c9d587f0d02a730edd724e1739978c4fb6e232b3112f856142aad0adeb550df1bf5291be865de94b298c563794ca10fc6e1980b77f9e63d3b5be649c6c960592e6a1be53c5cce87d200c376c5f2cfcc95ea4071ee9a5a9d413dae420c39d694843e4aa3c53e5d841b1bf50b1c4d6f3a67ed4ac8550dfe0acae963523e8d32a0f22d77eb3d59aa489dee2df61ff6a533dfe147bf8c2eebedb861a1a55df09142fb54e552be2b86a1e6b0c5232685c73319c64d979f9258cf337987678a17ca580aca14f2dd63535e1f0f82e08995c91028c823eade60c066b7b95eb347b6f867ed96e3aef060b4405621d1e449df0e81c6dfd1eb0acf762b69debb4ef48e71a0d3d5d68756b9dbfd3cbf6ec9a8fb337f952f436de5cd3bc04ad9b4bb01fa486a122177121a8d5face3c4c19edad2158ecfba8671fc2b9e362af7c0b79f87e88e3cc0aaf496bc120a25e0840ff3de43935a099446d45b37f127f49e8369ba3d786055e154b9278ced2cabea0ee2fe51f2ea0739c5ff981a32583cb03536d640c5b7100dec0b94b7d9126673c0f0eafc97e837a18583e37d1fb29f3a64090a734cf51500b762054ec5a3036648908efd8e9dd6b0b78e1ed4b83bfb71c4413fe5759e0dc6d5a843e9d2de426ba6decd333cf050c241ebb9d2025b2cf57aea152bd181bc0cbfcd1c0bdc0c96eb23bc50201ddd6fb9efa8f46d2c73937caacd8c528fc8cf194ad8bc0450559b0af8dfeb067537ecdd6cd4970439c2747de31b071726bc6e9c88fb520164494ed0e075de9fdd175ade5a650d95b909f5d1536989758c974911a091bcb17801e18bc7912eeb63b9ead0f624f1f51ba383234f7a07279038652c32dcf62d400d9e5c48c676e2d430cbc088f9e1928456c0aa95236faabd048ff0dcaf965068fc15c0fffb4dd8a3fdf612b76bab743c6adfe21880fd515956a30f12f3ba67297a50650cf62e787de6a61bcbc467f026427cc394ab84a027dffb4b4fd7bd777c94d30f2b2247ac186cc65c7cff77ea49a3b9b99509a57f43a411a273cd6222eea697b6b6413932293ddc6e02bf17cb8a316ede35666fcc6fca72c448b7478c94cc0c38c366044eafbf6c2d58b3f4717a0125c9ef7e91d80b055742dd65590cc4f8bf2908b1700f64c4f7dc7a957829d1839fbe10bbaf7969e190d1b9e1767f857fc3c1a0f5c34da733a1d6102b1ed07914c2cb8fa6890f169498327573703959d533be21bbbe081a0cf8bdcb08b000c6ad4933bdceda5ab42613a988f3e40156f3f76bd38e5a7fa7c30bc52b5922666d8692f50a1b35ba234a1ddb4b106373ce39d5f121469b6c123b6270102220bbbe50c0c752002b5bd25d9097a641fde0a003c138977607472ee8a4d5a08c8005064b197b8a40bbc24ab75071d9c8d41d1ab0835772e82253f88507258b0f5d020ea879bb95e55b0a8b48664a7875d1f909d8cf43567bad4cc5ff0b34c8a50950b53002a57dea1b603b20ee5ace3b8974adcc8dd05392318094eb105414dd0a18c6b8a282e52c1e7d8c398abf5549fcc772fd5c1b0f1e5c0ad3c6c24fad6c7727693a3116775e2fdabe0a2dfa931536d18039ee08d2fbde661c51c6c86144edafa0ff22c1704cf1b4778b3548cee1192258d5318e4cb3116a8247d1687e30303d2fdd350f9e8546a1578f8830dedd1d9ad390ba2e9a7c20230a40acb08a2b81d636b40ed7002ee2f0afb5a2352e6d0fec1ab117b4a424d0dce7691fc68d19c36adfa1345b872d6a9c4b1d50e5a682daf72ed7dbdd16c10772eb66affa55700bb3b480290997c21ed4d85c80b6428c29aee24854efffab4fca36fa7dea05eaf0a6a307b13e4514577997ec34804ce210f994cfc9858c8a881f35fc8db1b493ad5ee55dfafbb40cdfb88722bcd07b365e564440fe2ef9737218687821e7e56c6b505467902203ec8c524f6b4f893aa39ba9ca7b277057352beed32f8ba2d4c5bfc4b24077b32441cb4bca664e0dabbbd7883c9312f761e17f89f841a29f984f2d2ea29778bc74d3a242dbe397ae7af706c419d082c52df3b50db8eab1cbdfbffdfe78f1c5ce5b7ff1a6c65e483469f95b9e309962d35ac63c2424d6b60ecc7513f5016dd06c7e051cdd8e843ee5529c5d627993c85f289c4bd6ec518e0fc3df4c2c1d5ada954ef1087f51f866c1b9b0a9563abfcff029013e2982633850f8daac5d7ef0fbcbf9ab6276543d692fb4bbb69ea6fe947368fc5fe47377f41afa3eab2ce3d879de45d219bf8d44de0906ac370ac3473aa8ec763eaecd83d687df1e59f237a360ee5ec06c0330b441c5cac6ffa334649cd72827530aa8607c6eb15ef5a670266c8e9bff4cdcdc5ef5ce66f1885f615a7b023e0c1c931e2d845471d8e55d2f75b1408180a0cc26a0094652848ca531929949cbb32384378322bd3a1467e90d8eafdd49a59174c2c611b0d0976fcb5b095f81a4b56795be243c4c885d6c3b6f885ac9591d2a8100107ac5c1a603230a80befd680030c2742a21b56a784f3fa8be886a5d1bad8feb0a0e29a7d58b1df34f90423d8cffc01ccc28ab4299465faee4969244194892d18d731be0f4867b03116b91897019e46c6dd28488dad8ae738cb3220dab5eba198c4b2082874e8726862ba06dd778a95c284ae72fecbe2cdc413687370e5f391be03e3413cdaee3f5589fdd40701d7dc3daa80f4d60ee4822983f8a42d1ca39bacca967e65e6ecdc4a2716836de60ab117ba828bd95cd31ed2fc1348b1d2d399f67ef3a11145b4484ba00cc87d2be42164efd40042524a35562b431bbfe7739c03007e1fece8488284c23454c9ddfca4334c6a219ca888f8db09b5f95d50d393d1adedc08d56824bbe73159f71672a8ff43df845796b609ec499bc81989be593f4c674f440062ca037860dda99fb65824c73b9749b41e10c67af46092f94090492192db320d7489c4cd2ebafdcd6c504da28974eba041d97d35e2b38064a97ff38f66f6cb364adbdb9e6fee25de65a0a5439eb4b005ef870e827a97754fe739ba676e92f360aa52237","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
