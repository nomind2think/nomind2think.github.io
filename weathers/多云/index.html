<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2cc4de54bbfd7e56c257b027e08b212d31938051835207559e523bf5767843e9e6c560b477dcb0383693e421a94345a522b11c76428a3fa1a460b98ca56f5789c9b3ec646d74dee43fd1423aa7af5d6915419d0db49a3572999011dbc250584213eba39044199b3fbf62b1c684423124940f81d3a408c6df24baf145af8e04c9fd5d3bdae940d5f956593c8c1f4486b3de67100fac7b6a0d270de8fe100de4cdd23de8766c87490944076261ef2fb260718670c8093c4a0d956ae63d41d2c45ce638063cbd14382f03493efa95f13ddbcad35dfcb22771e8b392a72964fb1d3cbd1a2b77160d219f133180022b6f0ac4d0c4e51111deb453dcbbb4025e73c5d471e6598b89ab4e5c0092af69dac7ab9ffac806ea1e5e651f294e710f384fd1ab346b4fbbb1c8026be777955b2c7e1ffa4461ac57682d6a0088ed2cf6c531a4bb5b1965263b12a0eac7f8f42e5ac885fe95a68d7aee563abc94fabe5a5dca686076c20ece884acf896df916fc2e03a280d7d8f714134b186d0853257df24f561da85abf3ee22434b827bb566ac2b0840bf2d152e4fbf3f9d7a75571d82343538807d3b3d127f13c3b7594d5dc6f28d8e94bfd2255e0d3f7908849cfdf0b969101bda607c66e566e44f864567db681b4c699549196be0c1b14c40b8d2c4f2e45cfbf0650c68868b968189c1881b7a378d921c3d39286cef16af24845aa7c856d60993cf779a5204eff1765c722d6cde8eaff8d411286bf3309e839a65890f9795b1ec9102198d28781325acec4cabf5119f8231406cae6fd6db63ab449758c85b9fb6cc7a533f5e5a94d1f7395e73858b00c41e9c9261bea8933509205fd0a69b0f299fa78bb6499549f819f0d689c294acef9a7cfd41bacf8a4b1c7e6478f363e1edd75efc90431c3f474295e8dc4014e6b9206f7782e45afcc2678fde6ca74d06803d4fe2eefd4d58e42755b8013dae95e2394f3061380bd7d792a488e8769ef15eb747e9c4b60323a9ba50671777bd4e83db3b41612eb45386c73d4865f6d830adc96d855491fed885d0a0f9a9453c74f94657c0dcc61a1dd33e0396475735aeb42841133f88b4afea6bb4c78699c0a18170c8907b0a582cf6c7da282e4cbe605d240ade5adaac7bc35a15bba3fbae2b3d3aab823a4e68d63febff77e23fb2245c73ca813382de33cefe2be4e40ecf4f0efb8386d407776ff449d12592465f068a97326174aa6bc39d2b166acc93687e35943b53e2a66f53a41d900f958d96118cb92f8a4e3accf02ed3127adb9398122c86ae9136a4176291b4808eba610e0b343000546e759fbdd4fb73cf71df3f7bbf412b84542a00c7f12db674ac1c8b3fb6ae7d842528e0c574774533232a0d928a26e46852f4865ab0bb241dc2330e4a82071ad9153878081c4a54475dd80279bc45918df7486f486c0aa04143d614a3c03c5fe018434901a14eb7747e19364533738e927289b9b065fcec8c35396cb2e53292181c8de93acaf744c53148aa170fd5fd4dfbcdeab77cb5798315f3029a3fca14665450dc9d17b5f1dc94a8486839ed84fbbffc4fec040b7aed602c865942c908fbe8c3d8a6eda75159dbb1c89f0236d6f61441c0dc796df3203f17b7ce073b4751cb53312740eb3232eebd6f692547fc8c5b9449d8e7d45ef343eef9c29c7f9f52f267ad95d23ae92497b311723646035b4cd865799125b727ee03c38930c770ddd2e1e99e390ace04138c2c1b29b86277e560ccbe3067be3c7ee93ac6785dc8622f40576325438f52b64474df94fae27e76a3ad0d39fb35b51425b3059b3d61e1940ec56b4ae1dceab821b5ee6b7b55d7eca01043b5ea70f110819a29a07016b5ab54524bd41bd7ed8281e306e7162b458d47c557cd31068cf854744af4b4eddc3c50c67c4fbc4ad32db04df073b028610f6f24331efa82d536d69bce691c71df13e849e0a6d773068ed9f22084ac111532a92ee54a79f2959f16d3d442a3e156ee3c6214fbd3d560d1198611068e2f35375ebd7ac360dda7d3da0a236a3bb2cefbbebae43c8b224838a758b99b851f7dafb7f5bba8d022a46ba7cabb98be8c2d3b462e67ad66cc292205d71086c5b8236c5d7acdd1bca09c7840d8785ff28dacc86767d18f65c5559e84ebc779725ec5bcd4d210df111713c9fa89e8787411032755de425f64b1dc018d6ff14dcdd1026b25fabf03f56fdd67f860ef4c69fc86a5ca5c5a6c4f4c29b4d92d9bafb9ea525d2cb9f43b461a3f6a6652d48cf39d5e0f2c81aa3cca7c74a260374ffebbb084837e518a4e9e10ad411335635044d4d36db949447f8b4c263c72cf5162dc5d99876dabe76f472a908c4ae3d35d031dee47330d62848d226737bfeec63b0f951a155ddac385f303a1e0167262c319ebde807917337a42d5a94c8ab0a7c41437d5999a1bf55c7913dc2556cf61b7c16b09e5f897151a88745d8d517ebfadcaec7dccaa4742d6d9aaae3d844cf2d9b9ccd73f90c23db457c7a758005804d78512e76f7b0b0e9f1b580a21eac1bc605b2b9f4d0ea7a31fa52bdbfc5ac46e1a86b63719f88cd5b72b5531554d0d65b6308677970e7de0535e0d2a6fd589dac7f9f651a225b92e1c02beec84db8e0c7e162d8a81db7e86c5ce47282cc504e7ff39675ed223ac02c54c540468edd669401144e044fdb136344eb5d310e60cf83aea9a2f3280bbb717267431c99cf505a7f879a1a0932fd02a88a63e0bd8e958f9aeb475da92b227e2bf584288a20511b6db542a8b8bf8aa873a964e4eba44fd63611b774409d05c91e19fc9086e257383b15c2a223374d0c473afd5abf2b43cc90d34022445451d9f06b9666578ebb40b4369ac695f2c59e5fe7709429712aa307991f905ebb5b3516c6b6c9dfe79eaaec5a0d2a2b57e7d83c93e0c40a3a61a12e066adfdb32916b027915c1ac1120736c58ff50dfaeb0c5a843cb8bc6afd6e6c141c49c2eb515633beb460f8c3325c3ef8f09dc594d1ad142bb480f4a83f84f1eb25c77912fabc2099135790b04f3bc564994c510408b4973944ce76c42a2900f4dec5f2a5eacba2aa7c24689ca0ba9df0dc3e7b1bae9b2cbe19340e2638be2a491993548d0fec5308af9c8944d1d784f25ca88e7b57b6939bcd8857724df005975ea8c34297ce290e05065e7db0a548a2f15984dceb2a9f75987b3278f917de08f82d14d5b327320ffaaed3b4ab9ebe2dcfe8e2957edf38752f9cfdaef3a3c3581eb037c60b2bc50c55e77cb1bef2896706867d8b09c686c08517b79590dcd4c2bcf059dccab108ff14282c51cc7ed9258485f3f5967ac22f0b00baf3fe8a3f7e791970e7552c83293ab209d18a84716c35884055326f6385196530875f54f11f0abb6f00c54c8c72fdb617559078aefb6651403629578b6e08265d7d356fa166f88a249b8b907e87bab00bcd58b584312112dd2aacecbc956f955305ea64748df6fc13e2f9114878f44925d6ee13c40aaa97243504eb79463ade1121d53e0e587f01cb4ffe50a10d97378569e865c798165b25b0d9f4e8566e5ba1dfba5a8ca5feb0e0bf4792b7d21d29d1dbc6a1a3842f82ead70b5a8ec67ed716bf9623c2c64fd9abb0ad09be892c2ee53d8ec2e061f32c095d78733b8d84e77abb7456b02852fe2471020e61cbc7474afd622d988ac0b69a7648765c7e157d695890d2a5d1ba861eac38aecd46b43188850ab81cba4b583cbd744b97060674faeadae9dd5cce1fa05c33897a05662b8c14b8b73fea069639ce0fc36c73a102d65f301ceaea25d8bf2e8f15148f2992de7519254fd247dab4c185d840f0f78a0ad5a309d3bf0fe96a827a033fa3818bcd5df9e73889ceb5f3eaa848c83af0dd58ddd94f202fd0dbddcae6ea6b962d79a584c8621eeaf4e60f4f9c2d939ebc813c46eb138679435c3024b730fab6e14a140ddf534768ae1218c15526207930f6f0c52d814ad2b5d7cc177087f45a5bdfbae5dd67cf14cd18ccf05240e956333551ffc544b14fe7afd22d54be1f6599f371e6d2390d8ae0c91789232053760b7b9d389465032c6c312dd596d11c244273433b55d6f37f6dc55e1c5cb6e15a55c8c33cf3fd95e1ec646f2099fa36b172bcfb23feae4292ed86d120e6a497c588dd32bdb786bcbe2a2d71fd42df2b03b98a7bb255392cadac6605f8fe193fa977cd73435c73f04ebd46a4fffacf318a0260c2529a530e51a20dd7d14d04007c988596b0f0b0a8ea1acef7602a1b125ec7a8f667d0f05cf85a6d1cddb16da23ed01b8730186402a307ae9b667f9bbde3b3d65ce8993bccedea01c0a63ab2d4c460a97deef9e3d74de7b671f4a089d8d13aaa80fb0f9da8029ceed2cfcf3e1585f2b40df9af23838519ab2413199433f5f5aed0c351ed95fdadb66ed643b458d0b818b1f034e8bcb1be71b8a2c262c6d4ce4eebf6cac0091fc7fb8f9ee36bbbec2a4ee65a6c2efa9c92217d0fe9355489064a2e7ca3b16eba3f0d946834e425e577b169d2d4866fa041a3cd062d38808e4408ae1cbe00b7bbef506a2ccc71033f0f5d032085e7a4f36000daff9a1fadc5e5cf6c5024cede09f75035dd4bc288c21a99bcd666d15f91b3e7a0ed62b075ed8f3c767e0328753c447185742c641292d087649d2e399e849a22a8880b11954f28d34fa3229e6109387becbc1ea7c0acf6db55238462f41a5494589b413935677a74fb98247d11c5c8fec45de8cb6c605efb97524e0407afa71739fd79a3b010b49d3daa53e90169a8f9295afa476254cba740b6ca58f1869d103add502c46e4bdc5ba0d3a1f002ca6df658e93fa8fb4e47a41bf5ac9d497e9c7fe0460ff239039418f6ac67313c0e33b23e56a8805911020c8ede9739a699cc749324830fe27d18ff3e4b6ad189802ef0bcada7d35a6b1020c8397da65104a0fdd6cc441eaa19ddde9b1280067b86919a77e43e3d8ec14002fde7e8db2a52896649d60e863449ff1f4caf78cb29fe6c2c5c2a557a4ed1183e325120661079d62dad38e82649c46de01d325be8e9c72a959aa600cd105a4ccb16bd9dddd5e16f1943bf9448130d328d7ba8e0c2b418ac38bce49c82566a65d7bf2997d63d24f0c06bc32175402d50545a26f052fba275d2ce615ceda66d09983f3d1bb9f066772ae468b2f7c55b27a361f146517629febc0a9d7bd961ea9a8fdeacb704793de30f594d804002dae890f75f7da3eb40c829e287397e9a6c0640d015dd20087600109043f1db8a1f97f51cc41fc337399e0935ac180d5f26b009da1a3fb1bed32fa2bb5bc692bd4f098410ba4f97c37ae38ff787593d6d668ac3b368b2b5a638789cd74efb29d74ca3db0bb31d783ed5bd9fa60ae7ed0d8f37e7412376cb5a7fe5d3882df5ba6335782cd9efe81114f4fc0c3249ff69674c587374e4c07a8ddeb055024ed8c3d961d61f08f50aea22438b2972f1c0e6394b5c302034cddacce565bd842f4d63c079ff9dc0df9f6e2e855867c532adac82608954bbcdbe819f6fbceaef50f32216eb44e060215196ff364f29a7f5ab57628289dc81c736c82fa36660ad7f945f907741b125bd6ce942cb751f8064bd5e95f91962c1f9b448d099ab544f5ebac7b20b4f1aa90fe759d3b44e8293a9023c0ea83a7ee448dce5278e6f889e78cf78d7e820990f18335ef01b7650ae579953f4a7ed073c5e6ff36563e4879d681ca4dc21740a0ad74b4a03e00bc971986e01b9c75b30f8bce05999d9986f247e1e00f692a5174cb0735f8a7dfe71b588de29478250250929bdc234de55b6841eb363df2ede2cf3d8fd6d9aa1db9c5f4cfbfd3386897e61e45b462ad280ed4ec36ec6f4b16e6c0bfddea9e7cbd1db3d1e13219513fe5c3448bfca6949166e6acb607d0441e6f0eb1ad5f9dd61c5361099ce5d8230da07044697f2583229d406c6acb92719238d58de4d6f92c4292c1f913eda0b47510c744e060e2c05025c22d47a44c7fc65dd60354a01c1a6bcbcbc3ba218cb217cfd88e4375e18c1505df70f765852306525f4e361cb375db66829723234e80be14349cadc32ab328f57117b5d6b4193be706436e4ae1e132816ce24ea6ffc0982b24e907d9c65a47745fe4613ebc76659596fd7ce8c7ddad150eec458f94efe8219c091117e6004abf2cba9a59013eaac3e2eb42aeb7413c7811c068f1d148cedff12e85df4b637895f1f6339f378721ec0dce66f620b598ba1ea832ee9018ec02e2aeacf74b47199531efb0d96e8f72a57a2d87c744c6d28d7cfb4c4f9c65fc531552677a30dc2be673f05f160f807fc962e254b2ac6e693577c31c325106e3e1b8cc17d44d8e9dafd68f751807bcb9e2773178d9e7efa2858474ff420f42c4fe1ec7bbcf49eb6c53dba7d87c43b03cabad1d42faeccfcada2556e79bb0bc25e1da507a89ec687bf6e5e7cecdcbb02698ee399321eff97331a1cbdc0a0b8fa3effe4a1aa4febb2f6cb215e93ce902976215df9356f160d9716a284192fa3887b93c89afe449756fcf81059fff532f9dc5016a19edc0909a58cf2f9806dc632d6f0547adb94b6edfbe9c173c6f6028211d66b0dfeed764d761a59e627e2d8d1c0e06369984a772ed020a8b49ae2340edd9423036a7dc76ffed94f5b8a6703b6e33d02fe4f07b24eed57687e108beb5e82c402c91ca61476d19897f661e2dc0ad186ce4fa4ec5c0cc87c166c85753d0cb81d576438ee9c5527d447ec2c5b743b6f0cc74a27474748a96cf1325d26a0f785062ea7d675e6bfd368ee1a5729fc0d42713fc2a493d9adf98e5ee46a93405f9a565dc233ec0a83c051c3d5329387637a5fb5fd1629304e94ca1888e45190873fc28711da81d68fa3fd61925a820f1882b2277bb36e949061ae862e5d09b0cec482972adcf7e2b84ee3c358885ae232840870afb2d444e26a4af725eac9b5dbaa98037b6995ebae1269d7b2eea643857d3918f1cf3d703d4df4605042afd9379f332d1128a91fe939e22fed72fa26fe1101d32b51a230208d02cac5e2cd61adf7fb4d71d969411b07914f60c0f1ae9c1638a1802d255e8b914aa5e8666e80c76b106a5f9fc787cc354f15e579cf722f39d2f048698460df47750fa997ecf1af2a538651c54894e408242c92e4ac846d826fa0c6cb333e5eee544db68bda2071027bb0943398e2062311a716760fe4bd4ed262ad6e52e694ca3c8ce6e7500d3aa5b4758c8c7218af704e25e42355d44f75cb1e42bdf4eb8e7674fe501d0019bc9ade26c842b4f83ca7c54e180e8f8d9091f36769106978205ab513cae2f99f0ee929671d428427458659e4af82cec382f589c0d4d7002ee2f0a8b549a4519d6c684fb635829779dcf1fbc0e5e76838b651367f86a3f0fae40492f395638765451e232da7c44805017f56f525cfb3abf427cfcfc77ed618f52e1fe4bd711aa112263740c707db9ab9c42b288fa63ff7636b5e0152c1ab06a2af640ab68eac14c26512f3878722d641c8d2f9579e41dbc588bbbed3ce8d63c621181abe74eef9d48f3f33cfa589b61a702926f3d436d7cc9dc0c33a49b0e8b9b5ad6c211c10f3d14813901f65d3d071ebf8a445cad8831c3f7419a9f27c01ca5286bb116d92aaa731d3117e5589c9985aa355fdb9fae55fecea7126a7acdde61360413082b8fc2f8188d3630cc51a59461bb25356a3a7acf6626acf095a6889700179bc50e7faa5c0eef09cd86added34bf30a16517a36132742ab2db95c1eb08c25bcd9371d98ba623fd95872f011ec916a0ed8f820dd3eb41c9013ad66a8fa8a1c541251097435a75a3c1c5d01a203d6f4e4a21a3202f2d06f51e9239739e0d431595b6e25f85072f9752dbedaf5b28628dde94d5c39674d91eacb87d4ee6a4948cef066bf277b7e10c23ce1aa388597a9f66373034c6e7da672c23efd5ee0e7b4a7146f9f58eaa67f78c533aff070518b1207ad1ddeaad76b16a490ea61333530493551a3cd3f4cf5dfbafb0ae3345d7052d6f3e28ed6b4b58a17b37bf6b45960091832c8d3c85892077114ba0c0a26f9db8449847912991b8b80d6a0226133280fe188669b26e20b3ea80e7864709d5cad9e6b5876c7a516abf71c79fd259fde21b45a75f1d4ba70d267a39daaab151574a0ee37b0ebeb1f90b732ff2b25f77ad1f35473b65f8228e69390094505b5eb1551b0d7ea9320f37c8f66155926e761f7e88931f4bf3547f078f4b6b88e130a6f6f78a5699351e76a182f76ba9cc3dac8c64334e07f1a3cb3d9e529845205adbc467b90aafa727bcaf9d6c34d1957db1abe93a331cf88a9fd3b406a1af00b98f007d8d984099db0b3b3dfa206ffa18bb38d50dc444b983f93093e3d111ceeb56c93c6a42136d7e982c81e20b0a8b9f027dd88ef92efcd214692057cc47f39bf08f2577e573f21651e8b45ec93687ef01a68a942d6878dd4740192fda07d120d8412aed628cf289c89821ee3c244bfea5c2a91f411562c4e449385841ad804147fa97ca7473889792b72b61960fd18420333a05d3de16854c7532d3217baef97e3d7b3f13b286e040db6e0b2c3d0f968264b3a6c520453fb02caabd1377a4ca566f28048c6f7cf2087be8f188999f88ad97da3d1723e78b03fe838bd26cfeb5bc4f119f02c0d66772e39c48931229a2f1f29846aab8ff32e0ff20d87f229f8a3c1e0700ea1bbef940afa13ef936fa160875dc0107ab57872d2e2a9707d6d31d4338fdc2570000303c8fdb6b86a3b7af90faf3a30be826e8cf84be5225f638ac48a011cf47141896e906e0e7752ed205bd6916d972472bbe8306e39f2b64acdcbabd41e888b08c2d4cd56914fe5b2f1d182c74edeea59f87aace95cbd56d29698af6d640c59c794d6b103a5f99a5efdc6edb04b2cdb1f5e0f8cbe56cf6ecbbf5cb355323954e201e1a52befc978849c4ef8b1a5e6acd167a7a4dcb6e39051414e7cde573a6e332ead9e0170149b4a6858721718651225ed7a03b5408b517fdc38497ceef92ee751faacf3828ab21aa02a693e308556d03c09fb765dc9601de98f8fb15c41e44de58ffb51359488071bedba6456d16d476f7814283e42eee333b50d6e77d658659b1888b7d87e9d7db1b04dd77cb57db17d40fa1970ac7f10317aadde0370037d0694639080f1dae35c4ae71dc0f95af29f353e9557d93452179f99afbf7c9cccf3a95a379a1e42418c6aa1761cc039280a5870e494e86f829ad99b65640fac66683eda1ef05a9607f2420ba5921caa499f9d2456b662f2abeef9a766f727fa273582aea723553812156f1b7785bc225ae42a2df986ec64d96f72a4940de7b89b0b614a103bac4aed4c038843dd296eb60fcf627fea451e365daae1c2917cc8cfac81b497bab1f1b7dca200e1d3231ff067436bbdd038e09f76b90331461c655083e44962f881db8701f0d34d4abaa53ec66f5f84bf0af671078090105737af6f3f522f542f695443c8f20d3307bf8206845df900ce85e1de1241337ccf9251abd32a67f8b74892b96fba5db73b342040c30545fc0dc86ab912a19b9c6fb0b7ec2c29a577f11551c84247d0d5b6db6a8cdb91ee0e9dd61e7758364e639922c680af0ea4aeba91c54686870f07231cdcc9f32bac32a64c46ac04361d4f135d01fd50dbe1cc09a2bfcb83eb4dc0aca11b4cca4f3e702abd8474f0037b860fbcdd28cdc7eef1d5ec80a4826a38561f3421192797d049a6893df08984072b2d209ec81fcc4d5a43ff559c7a6cc191c844bb42ec4deaff76f74f270f5c9fd956313648f71b1cbabc8298279be02226ced9b2ee57fecf2e8ac38f879435bb2297266cef6e90cb9e7b215c524cb38f8a2ca65dfd83f90c4dac28a4fe1eeb32bbb75bd75492b079e0a251eb1fb17a3344f0e1b5810a889cfbe66e21aeec1e9bbd866f3f0bfab494f75f68174fe6acf0e4a5f34ac1f85bfacc2a16581c391c7b2a70b4f1ba1e0f0a0e5eb44f594225a92b38ee8432cfbf2589ef6f374dd9d2a0e947f610d1207fc9552f93ecbbeb2899500240b4a46e03c6af150b7b2e39197300b220eb0e00389a3b55a28945e4d947cb667d625333e2a4b685f9af7854a340237c70acf81601151ffe13220e79c45baefdedd605bec03e261e676e0dbb44841914b34dbaa245576a389d5926cb7e3ea8ed8c2748dd91e2abd1b19362e65c193c4d813246c4aea5e42b8f4db291be873417066058a5d77a8d6a34a11704aba79fc5b4645c1121ce0ec40e15ffe616fda9a1808ef1679e30d0b650daa12f69ea3eefa8b3f8924cea4c6bfa5f5b55291498643758515d6f3470d1c6115a7de0886e65c943cd0c6a35d5ed473999904afa3f218b8a425deb48cfb071d97a918a3ac6dac0f4a891df86f2971a02ac16b709d68835d1325cb6a81b7b4af4150c17c678666656516a37a2a45ff614d9588b63e5bd101afcf02a6f7266e33a43fa979db9bced658af9b52b6848dfca899c4b365aaef438936e63477e540b14d28823973a62b91346fe62d73871d28753b335af07adb6d6acdb3d27dd855618be54b753318940d257ce5e9d83e878621ac2a9a05077464aa7083e1bc72ba31aee3a173b492d771f9f10a109192cad3a74b0e8c2b1774fd8ea6cf64320c3847c51191599181155ba68cbd69ed0ee4b39ee1a67a60c6e5113d800f3fbf58e361519b273d5646e3b45bece7fb480d284f3b0f552e651f13e0b12a9186ddc235af75e13c460dafa0a9b2505afcf4ac900d4fd037d5219b0b14db60a216c0c009094737e33968ff0b093805a6817e83d4cba5b8cb4c177fc123caf94ba0fbe67e3ab40495f867cac39486269f86642795e51305026304b41a9910c8067ed7dc3bc250ae43224c3aae6d3bbfe440bc86ff34f230fa503fb7fd8d4a5ea2613545c170c2cc2503ba970458b0a527ae031238d17a423ef7fd7d8267c58273f8d3eaa6e61fb93a8aeb19910102b0e5a2bbb7eb2998a4ebc4549d09043c41778851443564df6549dd72b73ea41e5ff905b45454c73bb48f197e0b66b4e61342100a2f5a62b6e2800be394eebef068b1b7f7d4a34e28498a0f051e1554a2eadefcae7b92752b8e98b01b71a5ae84ea165a099dc1c5a8b853a82cba5bbc8007897bb3fc0a93b6b222fbdbb18c27f6900c9b679f3642f74e0155952d091b73c6504f0201fd482371cb35caa3a3f3f8238f01fb7b29ea4a8adaf419bfb71f8492e64517ff7da15b46e2a1342d791ba5291caacc616a06d1ab08a7a23ef4da36a0c54aa22dbb2ea71e17de3fea8e6bec6f0116563b4194b839192023b5071a2fb378564d4784f1e57cab38fd204d54dee917d0a1c1193d65b190b1e56f9bf445aa552c1051e985b95938267a48fe70b95415aed126f14ac19ddd3b949c3b493c746d0c7bbd6eb23f9c83cbedc61ac28152fce41fe75b7b1955905ee5640bd6549754e2a21a1f2e4d1cd04a1eeff9e859cd06af4c26d8c38f52d9b26bd493dd8cef88016fddc719136bcbdb75e6265102bb0b82666c56c73238bf7b90cd02c235ccb949a60b6c81dd8ebca16ab8e72cf6f53893bc234bd49e08100f4fb40b0068636b8647d158cf531dd80c26ff5261c00baeb58a28467dc1ce9a5d674be8380eabca586944f6e1300269177582a7d8ad450b50ff5bba73055c17b2954b781ea9039255b202dd8344fb649376e8673d3bc705d3f323d0f60c36742df0940fe61bdfdd54d90927ad2548b8f00c3b8b7b58a305480dae0469116eba6206feb9b0cac1cb39ab58d07a0015d332ebbfe77cca1009a001f8d559385de84cac218a7bbdbae3881f88d37acb410a8e901be8b6daf93f054dbf746586ed334210b6192886344ca1395547acfb0ed977122bc81ae02b5e925b0b440cf39316aa69c4dbd68e16c27cc1995a04b24ab42a5ab4c05d6b90db0373ae8707dbc67d12f893bb020a1daddff2b2988c7f347426f311bb2f31dc75b235b3dd1cbfdb5e58a0fe6301cff1c6cb53302f6dfdfe71bd6acecb3433501ba97a40f4c4c344b928ad223f01b208c3e39834db4310847c3244fe93aa669e5eb99750b4b36d46bffd7e3e0208e524f5e453e1f67a63499f2b25922ee77891d17f93c39440d34e6f305621dc9e6b46045972f538146d6616092b141cdb8bc33e68179a0fa585703a36715bdfc4bf649df2cab0bf91f7c2f55870a2f257d6847ed374d205b38aa6a2e77d14fe170e170f8e6b306e3c32c34279fc0e83ea4243202bcc4e11763ee9c2daab11eadc2644d3ee5abadde50387d26a8a7c81aed5dbd66edd5df8ad616994e5963536529bf1fb8026e5c7aae936172e8ddaa2b9c8b5339aa47888eb8c432a9929095ef254a44f6df8ffec265aad68c5a9bf8a9bfd1dac4773872e1ac9eb18e8bfbb6a2e32ec0e468ee702971738868be805dfc6df900fcdb570b12450221a6d45704f76f9f162c95485527cd6eb8587966f92feec6f5d5a1e87f3c3e951b3ddf50b677670af0a0e16a229c5101d88f73f0abaf88eb6dba74d295bf3b3e7ea9ebb5e4687d3a8834a92834a9aa59fcf4642cbf8394fb2406f5810b08e6d96921556cfcdeb5447466259fb2887597d598bdb8acb4c7bf89df914a048a1a449e98ad2c1ff7768a2d4c00e975e3cec9a7a725c436e8df9be425b7b815feabeb1462463cac238d488d6788a289e093c1c6dcdceb5647963a1f9ab4d7e07a74cc3e6066b8b900fe7e2a37c643cf842240d9924e06b99d7f792bbb49b05d0c3ca380cb46e5c3d51ca2c430b337b76bb167c464e35ba71a9b1ff6cb616875b1bb23b8019ce19edb8f59a5f1050f8158b7a1de2f9cb630baebbc6bda2d8e8e9aa9e6eb014da64b29cde6c753c22ab0797bfde489d1c961a78b274dca400d1f363dcab409dc2658ed1c930b8a02a609bf92a06369893f0a62c47eadeaca9bda8515d061a254c8e8079672b3ff7ff1387882564790c43f67f59c4b80660bc510d55ec11071ece5a7428c003a037ad975978db2eeb38e9e789fb7a0b7038708c05f86fa00e7efb6f4fa8dc89d66f17807332cbd8c2557bbd9b676291d3f11eb5136ae56a35df4b9f084b1c317851f30707156054bc212f06f2a24e5e1e7785e9e248ec5a2524307da500c37ead72048ee1059e855e6f402364093ef33192dfb98f91bf20045b8276d415b4d13016dd4f24e50bfd2a37d04f3beb3807fa2f043a5bb659db719bc806a1fa31ea1ae5b491e3b12d7a116af325398fa1caed4cfe7f3fe619c80c415bdc0de2d6f8a89e3aaff6c01575a5e217555812e29409821bc56dd31b5500163aab57864292a628f4620ca244406438225d6ae03d4b6c672c38fd5a28f3321e61dce6705649de91ad8b84c0562ea9a2d0646ecd1d025b9cb59e96a32b551fbaf7616332719e1288ee15246334504cef5a6d9c7f8b3d20e25ed141e6760711ee458c4987e007e0db60fb83d6e4e9d81db51ee47dc5abfd607e1c986c5e9794ffef5b85c16c20a8814e568f0cbf00e3ca0b4d9c6f9099d6654f4603868de6254137b6f2cc9aa2ecc6347da9cfd75541c1a60d7fd5d4e0042bb3bd2627eb76098f57cacc1009b3f57c4bf6d9cef0ecd308df5d0f43a6e1911e90472e1ec47d4996c94393b4f2953822fd0311588391a0a0042c670bef1a64b91ca34cf35c85b59c5876ba18994e2d3083c8fad31089b258afe19bdbf993341e7c3922abfd47dc6cc3548a675a3b7bfae7beaad6fb51c3774512cfdf2da6606106329d15e88fa8ede350db2357c18ce17865c88c8530fa3daa2440b6e5b6e1358f57c766e5262b30912011ad8cc264547220d7f2f774ce2e79f26dd0241d50c02241fde1379de0777e947720fdb09b70f961bf33dc398db0b8d8a219a28790e4982711b1baf97644798bc828b8e3d380843413baefe53528cbacac5f7cd7a1f21c0d226bda9851468c259db533c8e89bbceabf7d592b4537b174488ac5d79d618b59c9916a6af6b7f99c14c997326e30ac2c96b3212cf93476dbc5c3f34fa93432658f91f6204129728d7e3482e875dce124d2e71e4da96960b34ef717c71e2be1dbc911d46807f8ba6f51ac0b0bf023aa448139b80aec0a901b8d2c767962c62bfaef197d150a9a47ccbcd681410d9deeecc4ec7c31bafcc8651800fac2616329a93b6faced983db81379f98cb11b16d49dff239843361802317bd57f4e69e1862d5c8a4bb762359eb186164edfa46519e3577271ac8f4a1fff336903b0739e54887a610378d7e0aca380e591481ef9fc445461c4bc333bd5f18d1950eb6ee155a656267af25e9224a130ca459830037eb167c8efe3896e1c838b66b7786daed79b6518ffe67623ab756a14803b73af4ed78115515045a31b936a53754865ef4e144d2054d5e1c6495f6d889f34209f762eed96b9589b87c283a173a166314f821671eca92e75af3b3c2ac8b187629f61b6e20ca95531db0c7224c4baf92de97e61e3f95057e936153ffe8fe98eac901d0a46451cf422de7f8255e12e8eec7bd1eff9697c9b16dda402d5f29da71cc7f549f808c821824875c4473ff74ac0033044cd1d276826951cc0620a652d863d415a2a850f2ab0f28202c259a2f01ef39c6176d48b8d0421c89f21e9cb1130e52d657ca6af021ba456c4bc241b1d29c30657feed878c1066584eb8cc9976e60ea555b14ad78f50c98293a5f4a8b44fb4048f37bfb54ae3af6f94646f668c4749fcfb1c079e76da68455b3d2621c29cc8a74df963e964f920cee7d1b6c3f419218edd32be9869441d22d36d797d1503cf039d1126f240173b9c9082fa6a4d08366a7c65207e544ace1053c9cd2b324f542ce1e41798c9192c2c2d627b78a8987299e9972732f49a6665bf2c70208b349023ec456744377e123bd7855b92c89c1e04f154eb1ef4f582273aefe49890d271a172171248a77c3c6d82a922c7ab44732cf62b784f0f00f322aa57849dfee3daecb49a102d1edd15a3a209bfb9b249db5e76e08a3d7f5e683cb124503bb1b9fa0974d8c70af958dbdaf391646647fd46531d9a26ef240d90f3f6ead8ca69b0d7bd2a9ed084af514a78d673eceb079e3186a5a17b77049e129d18e9cb6e87e182f6d6b105071afafe4b2a11c3a2755d2915eef3eb0ff6bbeda5d4044b70d42a4febe2ce77ce37220cdd89df785e7d33cfa42067bc066b160a164df325514a3d94e64cd662d160dc43abdb8f9d2bb395f92e88cd33a63772fe1eb8e4c4030670c5e5d59dd15bf8eeaad210f1fb1b8cca41a931073c2f77de3b20a2b8b5f8569f5e0c18b097e2f95745db302be62b2594f1c0e9927867bf6cd47e08c8ec8b710129e5614f7d1e797b7a824893823bb49f66d489169a956dae395b636e4cb9cd9369dfc88c5c0b46f39ec603a8ad86690d003b48b97e9d6168ff9a32e99f84a8d161e907e6fedf76ef4143247e190773de66cb72fa41cc1f23e392d3cbb34ce0ffd8d4cf34e8a20462c41c69e9a82e0ed07aca9ff7236567546703b2f0c50f8e5efd7b879e41943b6b5b6b7509ea464de36fa5dac94e00f9ac4e8725845a349b538adc00b8d7a8d1c73f930b81304d93bbfaf843bd4d5e725276b4637774d397e3a52da1fa5ac24b42097966ea8fbdc5ed135097338f45d4d830f81e7461435d5d3439cc5944c6bfd65f107c1eccba4256c91db050f0be6f9af78d2690124e51763b12678849491371ce076e5117d817ef6d7007e0a01e1dedcbd81e68cf637b9d2f4e42a5130b4c0fd989e70d9f3ae5d9f62ca9b78cccff55be7d9a62332996cc8166bdae22ff25f097a495578291a85e8bed88b14ef7123d067b4aadce33b41dcfb852f0217bd35f8b5652fb1d42c7358be3f2d079d8b6ed5917e430304f9e2a8dcb7c642c2e66ff943a08450ff65c74bb37cc47374d9cfd8a77dec866a65396081debbb0c0c250c84bc4ceffb347e40b5e1b7dc4efe23170a88a529a538e1d110a46b48661be62cfff060c6824200c4227a36a4aff3291f1d864fbb21b9ddf1b2b4e8b9548b49fafc890e3bf7cb03e35af1e52e99d7ef6e5ce400635c36b66f27afc036c2787401d36cbf24ba0a105bacbf9bbe989ef0023815796ab32a2cecc58b1a17ff660529af80c6e4f3418cd98cb0833247fc038fccb620c9d68e0f97b220aed1c75068f1fcc96a65e2938a5a7a21ad65210a21b18e0a5fb873a90eacf4c04105d0458a44811437ac6513265794735c07bbda72e67000947b35562180967b611ae7e0d126a553129adce3da3386f579775f4e4348dacadf7f76434aef508fcac8c1b6abd7e9796ef1fee6508104d4a7a5202a87c7a203794f51d7e96e9d3f2b98a0d7e2159a376dfab2cc91b82ee57520ed143f905f9771cb9b34b0dd5eb3da2523ccdfc19dcf658ed38c44cfc0697e38379dc0050c863323e1d5ec213f107011beab9a63ff6dc68aac6798d02121a66812fe1d1beb49feb89539cd20ec2efe4c7adf36a29345473d4c3643f89dd303d75da41f48a1557555c70246593b12ba5206afd2577263ee96d27f51cc15e1140e4c0648cf00818ca2ea98eb8eaedada849e0937dc283551e6b2ef6c359a7a6e7c9b39c283de2c7b5ca5751b3e3d087ff9221cc21aa570f2b3372fbef419501abc88f562bcd0084015ec8d4228eeaff4b2184689f9ac116ef4219dd5aa16a6e06e94d77656b94237c7730b6f06d2f1a3e1ea248b449e94c246c75d6d271f75e95e1915a60e0d875f456bcf20f4ccaeb1f8db4ea62d129f0be8b9b4a0c8ae4010b0a3062b103fb28cccb11fd15c9e9c5a19f558eccb25d085f45264f1af688f782141bf085ebb9b255d67add906059c696c0cd7353a48e5287b7c9ab610c634026a2b6944705ab7080ac151ec85d67a2d069838c21dd285e42b17af521452f4ce51ef2604060f2e42c3623531859af07eb1b83b9429ab422f2a04c13896eebe1f55bfc34d16e7b50bb4ccc028919d2e70fb4533363895398030434b90944f6373fff1230df94dfbb2802f9689ed2ffa4d0773e1c9fa9a59b21c1a472105ff6790cac8425e650bdccbc68e12a0e17e673880f8dae111b23532aa3626ec8ad231e1427a595203e53a68e5e6661bcbc4527f3d193599e2bb8c94b8df00d55c353e92b2a7007a1813c1852b6749fdcd59d84c05a51104874c97ff0ebacd469ea5f5267a63da3d1b43b54989235ad2c253cf4ada71dfd7d92a63c8ad4f22a58739fe6f7075ba5bbc60bf3d87a732d3fa725aa3f8f500035f4b196cfee0cfc50cfe52bc2fc65fad40fac47258f6c503d6aec2786f49ee9b61ff4cb463aa9c9fc90a1be61de19db84e896fa5101404b3bce7ef7306710242285c6e4c28d793aab8d87e30e972efe6ddb5d723504a760da23f8187e4bedcbab51431ce8bdf97b7ea5fa724f7abfdbe72c2945c0e0847d2cc3759123d3b8ba6ab4de73a04debeef7016c21d805bc2313c9f865ef52ae1c854bf77db36505e6c0fd5f5aeb494e860db49ffd5f37566664030c07ec4d61638100e07bb52c11fb7fab6205e73e22b0717ab5533c3631405fd85677d0a680f525b290a5d3d2e18ac8ef15068cfb72a7aac68da6f5650d120d4cbd235d0d353ca57f5e36c4d4166fec79be4ccd19e177f9e8a76f2b8d77b551d98fe12ddaa4d4b77080f570735fa40ed9950cdaf8d4beddd683f07224b88e31444d07d9d27e6299815d2824ef3061b9a868f8e8d67c64520767d5a391f58e688a9bdc00a8e60ee75f003c9233feed382f0173d820cabd5c92363a74f1870564f9af0d11e7680c984fc5532559f624a1fb4801aa4e8d573bbe6239a89cad185eb43271f81324701c13211401823c3ba017b9942ee6df27aa1531114401db7140b2e4d00270d77780c37c1985e631b6cbf00e9c1a2a59c1f7053c767e83d8cdf3b641baa5e1e5989d594d1d2695ef561da65f7fc0158dfd0cdf7ab2e0714e96e034f59e65000efd0a7874344aec246993b7946bbcbbeabf1e5799e875aff7983f40b21ed60aa1ece07fb0d9bbd5abb2d6b5fec677f7b3cc6f47701a798061e03e6c94a5d1c39edba0e87e1e65698b5f8dfdd0f056814209dabfd05c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
