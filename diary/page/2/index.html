<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c31d6a2d4e50ed8e541346d8e7953a4229b91b0cbfa92bd5eaa71947b67e2c2617324258233467949cbe85851a1357f60cecfdab0a0f2683260b031c3f4ff7505d51ee413140f74d958dcec1f9d19b901d1162d9aa0f90e34902b60752f392f2d081a556435599cbc6cf523c75ea1728e62ffb9ef4e6491683e2cfae526a0158f7fd154d75cd59dc5027c769579f6aba1e83e9b4fe00aa31963949a2456801b114377e108b4d0ae76bbf0979a025cd761c59a23e0b17dec9d592ddc6c3f91f8b9b85a1d93152be6472c283d5b7b6b70e3fe1777920d93c01ce6c0d7d9cd1ee470a264c77f620e31fb211e12b163896d1d2de3308f6029c1627fdeccae66ac16eac21885b8fd828ba25495f077016707d4e55ff1605184a8ae4f259b3b290812c0faa119b0edaa36cd2634b4c98222dc021bd2478b1730a846662338dc6f2511e115e84789f66cd616d55e6c5ef30ad0dc8c315f9e5f32ff040e17b9e841d7d1faea2d2bf4c8a0d37fd16844e1b04480acfce73b38edc33c873d2d4a18ead6ff7e8b8b1d5d38d66d515c2fc7dc2b045f5871fdc1def2a476f0d4450e8623b59522e3ec4b441837105c2b1b64156255f48c7d0c2f7beb0597598641ee8d9f19d563e43ba77e290dd9c3f79d70618dc489e285687e7f1b3185b842c5a7cf60c92c56ba9a7efb9bc9d692e095a14d6dc200c3ebf175600d8d1b43055e2e6ae100d380a38e9b6ecad3cb55a0b47ab30994b9bdfd03e6336817a0f913ba5ac12ab53f79a17476187727f73483611eb490f26b4aade2516eff1a6f3d32b0d31dad75c2abeaf3137ba5d27925fc4788f30df28381ee02bc53ccc6768290c96be8c218e79aa8f062e6479cccaa6a7bcbfc84f3785c9d97acc0dc93da2b7e030ffe629fbc26767ef0e61ce32ea14f88ffa08661e8b57ea0e0ba112b3f27f4c8ec58167f3befa1a41caa118773aeea2d7c435a864ab44b90eea8c40290d76b1834fd9a23619891eb593fa29511f54abdbc419590eda09e9aaea436729cecb3b0aa658c89765c6a2bc2bc0f8abc84430e68f04d863549ec1633007428622cf575ac6ce0e89dd734dcd7b0716bb11d4ffe86fcf384188452004868845909766238928395dc211445e9f926b2ae1d6fbabce02f671226da2fa07748d11261960171560df9958783154b7dee6deee79b67c46f76b949b3b095e4f2b07a84d701570eedba3e4b83611bb20b29b37ad6f3688fc5ea37599c0cf45b77e2a1a6e76ed4eff52002e250e6b2129831c59540ea66086ec117b87a0d5225e0c0d142bbc5ed1403aeea5ecc80e65edd0f618539caf6b5400459f7f3aeb9dd00e29f7e9bd3ccf3f8be587b6f40a7d9352e2fa27ca377105cc7cfe8a556144035820855fa491d3ef2d16b50bebab8ae011e13e5a7835574f23f7533ad31e27f943587b267a62ebcf63d97cda1581aad51a3506b1c900544cde2fd4f0c43128ff6db8c3f43e461747cc8b8ff41be9d7785a8c3344292a993033b5ae166c0dda931486d568fac0b0dadc4404c78f6742af4df8f75692dc6fec6e2924b5570c90eafc089b4920ddc6a5ab73cc4ea6ad21a069209ed337df33084d9c543709b46568cb1e8dd146afbc6cf4b523761531b2f900066b67323aa7077a808fbb8db523b381022c619618c281a5266a1a9bb1d2ea83721a1b83b1cdebc292a5cff63c5ca6e973f345fe69580329282fd217fec1d9d0848dbe87f059096fb3f8d091de6126e7a23e6242528d7bba02fde0e8fe8222ff64c6c161ddda86c36c0a738b7dc710ada61fc8fe8504160c044e840fd2aef0d9645b78f428ee7fd7255b0233cd031cba2fbfb3dd630f1789b2c9303496bd0b20e6595f78e57bb0019009a085983cabff44275a3dbaef21410057f159a0ccaaf2c1f5253c7c65217ef604fdc7c3639d1f854794d2b4d56df5b4da7c8ff52ae70353dde8028fe5bb581f0b06e3587e8ef977ff259eb29f6ca9ff958c4c1bee07b52b6a4de41fe26a680e4d71db2e782f307ebb066a9bd5ab2fdfa3011172020379b5f3d7e9f2cddc2a095dd9e8a6ecbc670bb63b57f7ae42d1681a66c9e4c6c366a78129b11d53caaa2b2e83c94838639b8d75585a04c1ffb75ec8c933d18dc2cb723a58585d4843bd6cdfcb6c9757a2fd3690d0cd933e69525c4340d79a6af84d2e40e9df56be560674a56ba18647e1e8fcabcbb8636f4989709299c6c2a1b8efb91d88d2b43b2504fa560d0f3b6ccd24cd76229847e0c5c6b14bbaa33918ac661d8305451f669cfe6d8e954e29dbccb7c85b7f97d15e012566982f80bba3d3da69d74c1b720c280bc1a14ad407a922ad1ee661a871665c0d18707ae2ba6ffa009d9709d393a3cc59a98abccebc818aeff5d7e9399e38a54f50efeaea5a5a1f2aec94886621d066a030ccc572d5442e67920a4e4ff94519be77d555f7e09a1276e9478de12e4b7559fe4aa0b4f282d9361f6996eacb5a6ec41e3d03f0d1d2a90bb37a32c8c1097c63fc0952c82c9efcae2131816b26b3913eb041c327c7a6edd67609bdffd91bbe9b5ec43eb6fd57dc9adc97e5c04258fe586814693d3396a6328fa1752eac36cc7becaa53e377c7342d2a7ab323bffe4a1461fdffccc11d4558f135c779d2076e0801f4bc11e92639bf64b2a294293e3186c11e7b70514f9bca3c6fce629fcc8509d0ebac35f73ca43335b9d18bab0db6cb25d28a4ecbb0d520e08e65f41e2ffe5a821578e3490f7fb66e27ba14330e718cdc5ddc0bdba45177cdc071fbbf875f6d448d468f5e6560283bcab824d67518d95462fae805497ce8a08bf845b3aa60ba613494d8d70f1e46e816010528e76e8a4b2e00ca41639fbd4cee8f57af98c6d0927e347d653f230b70aad06a70ae706a29c84134014f1ac22fbbc789f4bfd7cc10ecc65a3e13acf3c806c8ac7680b7e8f7658e2c63083cebb3293d214a9f87938d78be36a1297d1246751481f1483935a4289306f529c835021fe4db23ba3407ff5e7ceb54b7920c18f72a40db3eccb3c16e5e8de78ef58a06e240d05ad8716cfbab5b81668c1a0b25dfeeea4dc98be50c8dee150d5007314b457de95f7330bc8ba607c9fe39b2a162feb01a995b885858616018e6b84f86ea1512b2f40fff7993569f89aad8bfbf3efab4526b3315ce54f2fcc61facb45f03ff467b29face45b17c9f9842518e968348bd007a9ae5dbfc174643fbd6027177fc6035877522e36000ed3cd6b4a7b69f644430df1b1d506c084d9923d897da580b928f1a1c19ad3b39460fc61976ab04b32c08d3d46f1c0799fd1e15479278f31f22bb77c1a6cc770f25a65d215de3f86ff89b6615293ac8b9f066982673f8029e348221ac3c195ae5d8fb3ab85b5bb343933efec411b73d885ee08c6a3a671ead0d2438a15c0d30fcd0577c76fb906280b5d8620fc20f2e371d607ee124dba801d2478b9351508352e8141706e0920b10c2998a3126a3327302229dde0680707de02983851b3afd85e7bac87e56c8b29582057ea8b8d66ff619eea86674257c29eafcc20192a9df0ccd8a663aeb814699d4332d57de8de474c304f9c0ff4747141247209029bd1c90fee8a9027ccc83092f9bac2a12adc3b259d5b11dc3218758357537be3578beb35a32d649017521ea4794ff362b22646690aa429b5b6b58a9526f8f4c9c49c4ac320d91c2bf07463d5680aebddfe78e2db53ffc8487c0687e19150021ef74ba46dff8ced998de4612cc99a8be56f9d92bdb41090e9a52088ef38ffa6b91de7934fad3152732601f1e159ea3ae84e280d4d9e7a1a363228887bea166618daea2444b06fa31ce1ea6d47bfb343f55e58cb0a6e6a41237fdc40fb410fea0acc0cf2d1a5a991aa467af1d878224442825edcf27d65b2ae7ee7e95662ed6d42290226f80a65a35f39b73450e33031adc2f7c2c27010c2371799cccc7a62238bd2bd986a91e438bd7c7aa48bc6a57f64c6a2cd16a6c59d1786b1c5401227c30a03411ee7d54c2bf8ffb10785178fcdc7349c670b02103d2c12dfc8839ab7f509ab7c958bfa0c02e39d919db5283cf48e4334e308a65eba06bf6d5875b2d709530518d8edd4ad3f0f61468185cb7f15ad75f6b72fdfcd20a9948b9d2f3bacd5c141595949b3dbc0ceb9ddbd6c2c91ecea7d4805acba4fd47091c311081e4371ce142c314ebba16e56410979e677a4a16e37538e5ad44492bd1fa52532fc39c988280021dc56ac92bd3d909ff490e1ae3a5b6f7f0e278664f648b559a825716914c9d3f71a1e8f61629be073a617ebaa9e0312c941704618c735935e16c6f0ffe3793c7f6ef28e22ac259f5896446289919597991b4db5683b45a8469f068e3f77976553d0be411385e9528ea61b3677028bc28ea1c82880aaea8ec5bd184a2a5ad061acc03cb1b28f2a3486366c1bbf252eddea62a8f7951843c393cbba6d5527adb2663b7283e181f07dedda17337057e9af763e17ef7586f774442119f9bddfc8283e62d79aff86c25dd9adb1a7ed75683479766b822b15a2fd77a49a78149b900e56754bcbc48879f818c7364f84f1a917be75823e7d95834d6db4d8e1b5a0b16667b0ba68b4bbd1adc91aefa9057abed6ecda93cff28912a46bd0cd4b691b7267c95711c860a34bcd4613e1d4268f5b8876144d63b19dd47a6c3b65bce4141e72931f3bf2dbc077451c3bc3e2de81e4b6f68591a04801968c393266423d4ba4338f2b3e508dc9252f44083cd5b8bdf131dd257398c9a2388a3002cbe17e6274cea7151c4e28ee70aa270746009302b14c7ea086443b61816f98b3c915790d6c840b120d72f2f5c2e3ee3ce03254da1bbbd7d5264556a36c6777c0984a76ccb05a6364053c29955ab792963e27ce8d25c2fd1132b6278ba80284d9541511af75687eb4b27dd2902df945859f5bc8eaf839aec2523d60ae1f4b57ae91bf512a07b4c59542d6e81d78bfcfb236c5b8b7b176b4f1584d0dd70205fb55cfec255878923a38e1523a4fd8fb8e1e268128f4af9c3331f47ad0b8c4170573c9b2b1defc2e36a4653e7176e15f805f36944b426781c905922d8a75194e343f61b65b9c5296607b51972b430660675674d8f125327cb6722aa88ddc1c2a1e8c09e69315f68bda73c20c280b19862e4567a2584e83f3e1827e9a904b04e943e82e3be8f3a57f20c1ba8e2ed07ff3e71d2577ebb504ae2626eaeac8fef8686f07a19b60c23c64f4174c37391de102c5b05fbb31185881313eec74513772e346bafc28bbc543ca3d7f08930ae14cc4ed9272da1a81f78669b9b5dd4dadbd1d4ce9e7e91300db8a353b873af12a00cec1675d2c9f13a97dc1846ca3d5f8390ced5ba1a886b38b7271f9b56f176c50420718e16aa4405bfaa0a480671683bae6019825a7a157e0a527ed7f9e6bd39705ad8db6a474309c4417dba49836acb10a548338c362235fdff8cb08ea6563c0375f347b0eb9267d3cbcdb1c1cba0423d8216045356f4c23156e23d6c765f423d918197daf6654224169a6f6b43c86cdbee545d470c4383372fbf12377bce874ae48c309b1b9144d6e05fde1d491ef29c288bb2ee3ff787f74f9d3d1170e6b7bfe9764361998a329fb950611e173e630599a0353173f3bf216ecd337c542d9ed2fb37e3d60183f5041878223791dd4431e1ab2db5a59da2678feb3d0b5aaa0bc128ac3dba8c5170ba36c7514a5fb291dd216d60b133b5add8e0f52bb1cd07e0024b7d39260ab61f5c443beb46a0ba183d528ec4e6597044e200ed43d02215c20b812552986991753329faeceac57c7993a3a27fcc6d80a7293c91565b2e78b003e5a900cffa793aa5cddbe960586bb42ef41429158f866d892d71b8e2964fee7d9402936f73c50122889bae87f6345714bc22b727d9f8c2d9e4e0076cac133c3292e82090f238ebc0598077d1d28dd86a4f06476b4c91a636eea494d0fb792bd3c31475541f40b4a8a9d29b61b7b4346c5343f31e06b3541700133e453e6b3d49331e79834ea52d9dda3474c1a5478eed2b5caab11fcd0db4331e44933369a1e49200c00acd37d7eac7fe5035d1c82701e74f1f6f5b1d46f08dbb96c83283dd9d84a840a68bf8378fd776f0675fcd151c17495337fbf8829961d3eb7ae1e037923da20f6857e82de942292666b4562ac5ddaa697bd6cfabc635a9e7b1205a09f98e0d3d7fcadbff0368f5b8c074624bc7c09b6bc336c59d1f2562fcef49e03fa27a02f42adf3cbbab08373fc44438bc4a2d20bc224ba2a58c738db2f16563d182a1641a38994cdbe84a54de08e716bf72726d1a8971f942bf6abeee9566b4444bd3697b9d34d7cbcd0a4873074210fb638c15c612c4159e9495e6891cfb7227e035e4ef1fed033b037d482858a6d1d3bb9135f43b06fc5626383b3aab132038407f16cafa49d18671414f1c102bd395449e2b7dffd82e96222ba65700ccf73622766961a238885cbb2ad6ba64ff7b27022301ea0a1582e87a3d0536e237313eb1bf6952ef4f93cd518da03fe7df13953ae9fb9b240af82fac1359366150dcf8c8b79a9089d2ff5c766e7d640d7469c29079dd02a84e3c6d7b6b311cc1cdfb43e81492c433d4d42fb562fff2b1f28f012c709f4fc1bd6a4a12e75872f456d329d11375411a048c87dc846329a1d0499f83f90aad87dfd6fa7c09410efaccee74d6e2062f180d26ad72aa7f98cbf984796ccb028e8a5cc673562faf8d18f67fe843a999b3ddc6acd9a5d8b9a7b1737249d3ab4459ca24cb3d83d19278e95ec41a79a8c16d05223533c21dd2480543e4704f445dc61c29fa451c450b53e72198748d3d47ef9c5eb47019cffffd27997981912b7abd2c0512bedd66590179b9b1bd25419fe6745ffa3bd0e00c0a0da4d156970be15e68ae7e4743317b504cc4d056d48adfa7d78bbe506cdb96e1ce901fd1afd1c188513bf11c6d174959aaa6af6f010d569e19116af04dd373c04cf23b219260307b1774e05f16db43f51bfc8a3555bf85834e04041834b97b8fd9f7584921d958e784469d794e6b58f8e987bb72e8016b4cb7af017ee082d0a739410babbfc4460ecf101e162b0a7bbd35f85dd643196393d3546b998c66ae5cfaecf7680b873d56d6588ff2949b654e553808c8e15df54c1b72d721b9f6433d342214dcb025696bd600e59fd6634b14baa6071c825ac81815d4608e901e5a2e29c7848d997d9a5138c86c6ed48c2b731d97421e05ac65baa6b2933f4f014d06232ce3d545b35318a3830e6bb2850075cb3ce122083b18e1337a88ad9cd90bda939bbe652ccdbececbee6a7ce80fa78f2e025bc305e187313d8b454cbd666f82ff317d766eb312638921f6459f0e9f55a3e1bafe738c5bd678f0ee43f7a8ded5128fa7516867208b054c68bc6b3cd0e7982b441ef7b24771ad333edd36b18ab8848e0b088531ae6da2e9ce124ffac9ef236638131bbbcc1ac39737536e9e076cf6385f11d878311a93bc58c59b41c779bcb03d30b0de0e9f187efd4389bee0b73bb3883642989962c3b28edaaf4dcc0674a7eaceff414a26536df74ceadcfc792b861dc92b0ad9c3dec43fc4648b189b3dd08f26b2a9575ec757d068fa7f7d7251553e1f96f90799319f45818c6b3a52751b6f0d803758ae9bc030b9d555306ed3788bb27f9a102448b652c6bc30574bb0944ab6925d399e4ba5a7d5569f87b678f502f8ba96ff51a129aff339c86798f9544e4f934c7d4af0acf04bb7b4149e494078f74cf520037c13bdb175e681d91a5c5e9174a5ad0c3e0934351c8fbc821101e85c2c1f57981c55aae48d04e64ab3e84af7de1706e1613337f2c98fc6d9640aca7ba78bf36e4f0d4c842e6722606f32b03190e819695f9076d9449174b133838054a68a7ca640470f3f23213957326ed83a17a178758b30550fdd89f06ff1c1899d9e1c62c08007c675f6cc1b69c7c350adb934ada09eb97e0e88770a7a135183ab2cb36a00e82db101e8d9ed6b238e69ecb0dd475d0e95d0fa8dc21378cee52c54c93c42eb93d361e0e6a36424780280b7d360d347080eb75d6d4245aae6ab7459550decea13bf54398a30d01e64256efff7fecbf89ebb029de92ad2395b8406461b227dcc0dcbba8f97d6adcfced9e150ca1a32436ba3e31835641a4a7c066140308cf2947a94d7c1b1a419aecf12fb766647249628f71db4ac50032cc944e4e407d2654f6a98a0402c73fe71a28bc32cff666e0c518062adcfeaff5e0b45e70417d583a00dcf0d4af294c76e4bcfda29d56d76fba997e363a7a01a69a1674eeb1663f4cf8600dd664755dcfcae254675479d20460435674635e945c952d579cd3ef3309526dc7f75767b12cf9d29da269a961af25732313e780c8930f6c82b52d336250acd9d52ac44a88f7375725e8edaa9193a36862e831060818b721d5db26f9deb6a06a7436dff01b13f7989c0c5302194557b690534a39f6f55d4de27a669ef2bd672c400d90716d5ec242155aeca43ab3108c2c34cd51de96a1f261a90762af8d701151172317273842107346a1b56e863c80c995b87e0dbeed9c837fe02ef7a3fe172bdf6dff83b627b9ad31f7025ab1af5807c34d27318d5135908c438add7815eea63b7d5f41ca37b413b5078bf71faed86431c4ab8bbbfb3a4d85c10f0f992749883deb1bc3ad378ec5f8acf5311209c9d23287cd9ed8776022fb6fbe569c42dee7586286a5258f618462d1b39785dd2dff77db9783ebb4060319f6df5940a5c7ddcaf53f4b0e8c8335588e9df5f89b2079afd16e74d0153362aa7bfa1dde3c151a3e512154d27fbaf53c98c513922797eeb6abca7490dcd64f8a82cf4a9a8d39e56c0b8568db1bce40056b80900f8001f17633c2495eabf9b29b713f08cf5a1c35421b80e21b717e16eb38effce19ccfe5a6ffcdf3c11dda4e850719f1290fe77f0c65556d867ab245809265a853e69e0482a72bd3e39d97233e047c4d9b1cb9adbfa6f8e7d0e83cbc4bb7f02bd0f74fc0f13fb8bbcfb58d540238c12335d7d4142f12e80f74a75b42a5f8999300b9bcc4cf44e5daa8bcf8a74188844b527c751c76bac94148d56f6819cce19bd70486483486fa200003ff1e396e069ec74f0d245ea482dbdc194eb6458efd43b176fba4eb6d3e9586dac04339ef132b6da66bd7a803059123a272378aca70d6d5ef79f71319b042ba5a319960aade071adefd34e50997d16aef250cc11e62f52c9c813abe675027caaadd0436c0d074d40d266a482bb40c8bf83980f888bdb2396afdebd462a80b85fd2b55691f771f85e8cc6f6882844be8ea351c0fb3dae3afe6774f9489052d37f5fd0a0e4ea14f3743c81daf0a5013c9b117e76ea2b91e3034f67c82dacc2bc0664a6fa42b308c9d9900c795b0543a2d326641a626287e52deee6e1ee7def3b3ac7109f5be16905efb289d92e401fabf8b705ba24e017819463ec5292f27265333335a8a339fbe9b4e751a217322ccca8963e53b9083d75de3bd17faa9e37a9aea0d2ca20f9184c11ec5054468b99d751d386290f15975cbe783a97442d19e2eedf73c223b51250ecd08ded14695c81beb052df25ecafeda23ee070abc11ec5cdef6284cb410f38bba6d7b628ec3ad5c59e4dc3bd96c24d26715316425c916db310732537559690b1e3e2e5c36d10902fe128a5f3bc575c32c5feefa6a277d18d26f3c951331550a795b7325e1f8c6f243b5600a4038e96f065229a5efcfc955cf7351184634f9fb17a329f37af55a1705c9bf180b916d0c05996c3bd3c88217bda3f2b32ead843dd8a4b0a1662e71498267ba59bce788dac12f966b18bc1bbbeede632ca4a7daaccb1ef1c23e78032bd3caa00ba66a7c44a1d84adeccbafd9c64c4c45bc2e66279389ec10ca873dd7825ba88605caf22b3667076358f6db5780e6fcbf4ce9ff0845d5b5b15bf3b2d8de5fd6bfd9f6250759e4c7759c0017b602051305d64813c70c678c19d86bb79007c0bcac5d1caa7ad350ea7d849e4554700db1ab3dca4b3cd2d05859667766ea76c30619594cc8276660449262206322986679402ce8a49eededcfd22615f32c184a1dd60fd016ec1f7ecdd5d1e246e10837d189b64c525f171d0de83a12216556eb001af431196ec0296d14e13e8b397e8c38f677f6da551b10eb56ee8ba192612fddb102f34a2d3b8fac3bd36e7c6b3e5fd917d49e16eb0f57aa36ae0266e9ea0c9f5f036327d53db869fe400cf7781855ab243c48ae28edb3e3fa1800c27f169c79dbfb9c8c0edfc0e827ea307b4ad254774b2321042cb33dfa6e2fbcf0126909ec5fefd74782c0cf4bb9a97de8ccb7630125965178b7a1512fd0a8133a721f24bf870fc098ee6bf25625e4aec08e4dd2887ae58427e020b79490befe3dfb4f920222021bb2a72672e1e6c67039fc84317d9ad2167e3ebf80449f43b51a729958051be57e44c70bef59b7e8702124fa395ce109d1c6e5aad36edc4661281bdecc63ff5043100643d39452f3622728c02f89766f3c0cc0d0d76515e87ed4a07d5d33cba843e93c587d3cf525fcc50f338af20523dd4de4951174536eed2520ea4deb915cd65dd68529346efefc738d0b87391c762602b454f3b7940d6f63c145b398ede503132e08d58303294f7314e236349b404ada6e48a92af30865858161fac907c91e37401b814d8e7b512c67ee1f1a78adc841f482e308183b4b4b6560c3e1e024d4f1becfd5e157575a83c6b67e74840dd2f82024d012309d98835682a85d66a8dbd1f5586fcd475f934771ba7a846dea2f28d878e4a8bac4af886cd7489fd8e3ebb3b517acdcc6ddf83aaa336bac15884a9dd13d1d602cd9c626e8e5b43c54d8d1a87ea2888aa4abdb9427d396f4e4e83071518a226425723175b407deb76234c78be70447a7d3f1fd2b170cef7aef7d48489ab84a3ca0aa423eb32d7c77d5e74bbc80eb4ca544243db2979928c910bab589ffadd214274c10084a884a03499908c136d5a90b13981780f15e3494b14a7061ce5c9032b7c3c1d997557a84ac9eab13e8cda6ab265c3038ce71909d930e7a81c699d33ec89cba33e81a058eed6ac17a407b3934d09bebf68a3603f143a0018e4514090e8f7e956bb3aa05d9b59b2f03542dcf7f0531e8081f2a79f9fadc0f78d8dc844b4327483e0c2e5c5268838e880d55aac9968c0b27634629e8cac3737047b753885c28121a9aeda4c002110f1b04894ab07e0c8c79a9a08033cc02403685c74062dda155e7139964842e76ba4c3ad3abf5ca893c95f919d4b410812a6fc6c6e58ee773cb784e23e7bf96925758d33e955b44dd27cc7adb5a18b48f071797807edce71b3eed775c80fc6967253534a0b9364fb2810dbf1547ca5374f45b057bb0e3af05d032aa69c0e61f4b3cb3e9282c25309efc7e1bb5305d2f0942c49697a3a5d84392bb4518ac8b320073a5f0452addce9a0943be173778252a7378bf4c98ccf30c0878a3c2f9624b16c64552f84a082d49b2a9427841294bca4252ba07972ba0ec9c5e2a4dd248cbdf6fb48ca49f091a77db50e65458c5cf97655d57b9151124791086ba794998fde4ecf9318a5714444de739f89143baa04c06fc538e0e2054c71671f703ab70e217d5dd5844f5a1af1be2eecdd6e09261287f74ccd7c6b8d54fc51b167b710efc1e2d3cf96057a98194cc60ceaabe3fbd420e23e58b4de6617217e469e94c05b36ef452084b5d4f6c40fee0fbc4784eca57830a554a072c8c6e72e6c859e552626441d641d126ec5094b4cc390982931c781d1aeebc2b399c7fd4a06dc2b958a70846f0891297d04a7469ff863e54cab594e0d64ca6e417cb1a42bb764ed57798e96197ffb95544c30260cfe2b3685a95904ad1a86bc8ba8a6f0fb444b121779cf798c9099d29be4fea7ead9d4b660ea523c755b1eeeb1bb0b58daabf03d668c1126613633e94af8a882ecd520a6c491ce1625d1c3d09e008916b0ceb8a41b6c4022c2a573cea5716f8f2ca00ce7a8efd2090fc5d82992b682d512dbf56c39a66dc5739e8e93addd20929de8dd651","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
