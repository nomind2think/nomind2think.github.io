<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2df9e64d9b8e93e86acac1907c7eec0f372b8bb732b39598eae594fdd5acccb3a7595ee91fa1df3019bf143685f8184b966b9a35db0d33426e2ebf0e1aa886d9af9f74b2acac7e3d9e54d0f412cc8557658b328fcbd7a25adc8b2f3771921dd4bdbc87972f5156ef6943a896fe384b891ed2ef566207e42208e3f0e8f4c8687b61b5c689ec603b94b8f315f3ee7ee941c2eeb60ac4abdb2c76f4b2b9a1f566d07e36a1c10053066c538bea7343634f008f1988123333e059e268d5557a798b9bc0a3e0fd1cff163c11ebd23ebf73475f8448683abd80237f367f07f7c1083f913e4e03866304c76f687ac4533394fb4d7d7d7d732ecaebf1f1e838cb1a39e4a621cad84b13220c7e75cad405681d306a7ecd53a16dec3a44b8264e44cd1bd6f3fa888ccd7492805c0799336f853f7a1ba229cbc723d72a2f5e73c7644e2e4695453fe000dbfe09804f077f16a46218d70567940ae6f0a8c6008b45bb942c28cb6a5e262735fa6859cb9453681039d5adfb55215ca834e7b8632e6716b1d5638bf6c072fbd9716249bbe276d1c6b63c05a23c1934dfdef0c053bba8416846a00ee1140cabb99105072c39a855ecbe133b96dfeac515c84ca09e29e6dc5313d2d7baacb35d304e40a4af2102087da254852b70bf40f0b4df2e62934587ce76ae76d7ebbb0f9249a229fb944b3538140bab86732a3e441e19b415f852bcc6c68a4da9f40868ac1c943eedb1c2bb29261da260dd04f8f082bb45bd58443f765a49223278ac8490fc7a4a88735d81020bfe4e78daa6ba10d00760274b18ce82b5d4c6c1d07a893e2aa5f14da0f08fb217d118f8ae50fe11daf3a50feb2a8df942f3ec7319966b1575717c25ba59ad9e7067e98e144c36b2806d1dc59f42835ac7275d0dafc188a3069f6f4bf6a34da9faa815075ed5f32ac6e6516a93704e54565cead0526510e613b299be0364a6a52832a7997dc98e51f6f1a47b3434f3b610ae3e338255066b0fb3882bb593d8b053f98bbee7c77012270de128e534f224d466436d8520ba51fcdd215c17a0cf7fe26b54985c9cba00e7db2438c4bfca6b0889defbf92a19f1486f89a06271b51d6bd81b85fde9a729a422c14608693167957bef0ea35efd6b0681191c2250d3aaa176c30e2d81821371d37ac4415ed861dc3fa3b89ed0eeb507d3c20aa957630389b40c727c38d7165f81bc89f137eaf712578251446664e0cad3ff3c00a438c7e44e8b0c6f46aba3e87fa5c41504afff5f0666f0a0cac65b8bff31ed14f51db9993a3797dd84d0149e773aa330c8cc2ffff614359403d3629ffcaaadbd3fe0c989eb34d993a5d36a9f5fab7cfc4d4564a6edd5d5e735d5e0c419d957023837b5b1bbb685e061dadb545d551422c2459753f2fd1fc6503d5d92115d00dac0ec33f3694014257f8f6eda11f63895bbe7259f90d479ac52a1b3d5f8e4d1e1eb18509b4773f9aa367dfbf469c18488b5b53a5054013a973edd3f3a632c3f29036dbcbbc56b3c459b9ef0d0d4b7207e0e7a131a756b3e07c7a9d9b1fbf50b9e564910960608a871a2d7538e54c5b51e22cda74fda101ee7b08821092fc839884a87f0b3a98a17924dfc1ae5499210cefd9f5bbdc44e7dd2b366f0af5bb08474f2e950fa2242141e3f32c337c03a067839fd212f508e4575137bab85f098ca280433eca9a94e564808c462296cad4b92ba141e3f04fe8d0c7d9b1856958de7c22f560468dc99b925cfe1fb14eebc8d4055ac3cc3a572f390f1cfc58efcf361fc641b9a5514940b53a3049c884e6ef075fbe98e0764fdee021ef3b4a9188f9a9bdc3af1fff5f7b01c8ac4041fec58abdd008ccd7e46d6cf580262f78bd42bbac9c6c4d0ccdb40072a1982f4cfbd5aad4ce775dab4a134b38f5b68f6d1a2412cfa3c571cdc43b24a6eda1ab6a32855b43ebf3655508f566a306d7bf75ca86b6637f40a6895c981b8a368f13bb25cb88041b062e274da03b7bcc532fa5ad81a3e5147a9c5b83eb6c5d16a34e9fc971b6f2f2546365634da88ae1bb37ed7577f5e12f92475c23e22d2d8e672644ed473400fe9f16df75857fb60fa7590c76e3672d69f4d62883d96396d40df9d762a632ce2f41770609fb53f26bfed59e26ccb2e15c2eb036fc3da427a669b1a62a63de62ddbe99e8f6e03fa8a79365c03f488c8adc97afa2ee9a9604d48a540c12d6233962042f231dce79cdc8388b6e9ef709b0a3b9b38286409d625d8d2fa2c817592d53ab2c96fd0f1a6c53ef564e89f2396f840656e35eb86ee9e486a3ed6ee189c2df65daef580b161081d55f9fc0acf6dc8a60895f6d3bf5031ac84da446eb613295469baf60b2bfbcf64683ff963f46979302acad1b3648fb9dc93786102e694507cc3d57c2cbe1eaa76abb56071c793eda92a06d27b38723ad87ba4b0e7a4b26900406267e70555c403750562b0898ae3a5fdb3861d76705dcdad700c804667dc3cf21aff8525e4a01aaad8e4ecfaf76d3cf7599c667dc6faeb2c617761915fcb211df2104fb5b3097239ec5db471d9f9150d3d16993b7686e42394730115976859fec1027ebaec8af877c2dfd3af9ab74ab426f40e4debad9b8ecca5fbc9f88e48f1946316787d7d7de9bc0b814ad5a567b203f366b6462bc6ee9b031868faaad738fd55a92aba47caee2f0cc7c6dddad4dad420c53ed769ea3fd7b28f3787e60e51e0ec5766f74fef549c0c52d611296aced6ab686ddfe0ce72ea2c7a17d52d22a7686e89a66f35364508567f1d85b9d3d7773bf7f8cb7fe46be9d56bf44ea62f8e573853fc04abf702245bdacbf3a6496d954c1ddc39ce07559ae889506fa94e93e537e0583ec79fe37af3562ac8a609f581ad517105ef6f77620c73aa1377904e46d0591c97ffd6f0cfac0ef137e66a643e2f2bb6f39ddd88422cf929ab5d6d3a830413ff8116c69d48a3b38d89b2129b127d9d91e82c24bbacf0bf7678fa92a73154ec2ae80d222243892f77ee1e97af859bc7fbd01a734c884deb464c6238d340a7b9a8619f17e4b296c808639b2776560536c31b7db09049dab4a9b4eb20c0715f9811211d7de17998f24b0071b84032be95a3fe2a072a26d1ea89866d5ec57f02991eb48ff1306c02c6517f912b778f00bcc0be46e9808d4757d4e4ac1444cc1b2c4c5229f2bc30d05f491113c6ae378f4972ddc6bafb5251ab827ecf8bb51611c324a7aa7a973d04892ce7bc1ff68f34168a37c597584a5734e9057238444c8d1ebf639c8d582042117eaf70ffcab56ca5fb14f0bc68af74443c580aa292fb5824f636e15147882341e8362013ed7b7bb4436d658e3ba4a9b2c020b9b23db31a7e5c9277ee82e40cbf7fdee3596e9ce5039466680b6ecab5b299ba6613db1d5c65f3420df9527d24a68ec493a74c34978254566ebcbdf7b4a4135966cd178ade5987c2c366e8e0da1a9a88e7329e8547d1c0705674f5a532498c3d869faf330d2d79c320fe566c70d055024e9c5ee67f15623745b416bfa36f5961eb31097b39832d48e587202fc00e47b5b674d70d47b3971099c4d00136d05292ef2f6d83fe15fcf65242a00a50cf9092c36431292ae8359b55b9649886dc7c59ce637811f3babdca6fbe05accccbe85d653bb3f9b5e2a775ae217c2640ecb1f947b04fe5bb78c24462c7843dcb2437df27fc147d0e5ef54a5c25e1ebd6e903bc898acf834694de9ce20a6d6112ca9a136790d2c89816dcbb696c86409b94f66dd7c2a154603a2204b69d6074482679c1987efd404b85e224e0c41bcd4b740078443077f52821f326e8a69381759d48fc479cf829a1e49a723668fe6185fb178440f45e7a67883478f6deff2965febd3c419380b897c8b26c05d6060ca5df59b497e75b28d4e4d4ef5dd406a9e44a7de608a436f090848c49cad65298308c911c2d3967b690d3a5be798cbe8e20375ad652495c6b3a9d0b8c6315afc8f679508829dd8ebdcc6195283887ea1ad1376ed30b7af7ccae13d57feb607ec2c58395cbc202e4f675cd32179f7b37609e7a6896f2919a1bfe39c065e66307605268d52399ec991c02fe5df3c1aed3e81e815fb2c5ae8980f0c3bd96b0b676d91ab2dd8a43cbea8588eed7ad51207c78d18181ab9f7645409355ecc075ca92dcec541ffdf1851dbf405e7f768c66359ae3127b697d9b560a20a9394c1681621195b0e5ae3c9d69fc9347bab9e65368ddd754c8eb8455e9e0757eedbd5f6e1834ec65691b1335169f626f95d73d9ee64ca21cbdc55b5003f30a7cbc77337608e7faa81d410975139a3ef600e9b3a3a3db055eea7149482368cc0e1393044ea273019855cfb3330d6cdcf270620d3af76ea025b4b8e9c9437a49105ed51dfe5262f9c321372caf8aeee2631b61e4407c6842272f753829621fc27813478c31c7cf1470577710102ba81b4d3dac20912f3522a14f1a642500c2ae346b2b5e91af37546c0e278ebdb3abd4c289da06a35fb0db6f784f4100aae89d404cf0057c036919d8e6b55c750f3fd9ff77dd4f559b4cf2037c572bcfa8c7284d31878aa7bce840cdc8fa02b9e0c8b1a584fee3ac7884b0df6fa98442d183bdb7daf7b2af3cc3c4a957ddc9450c4cc4d188eac0608097f0200cbce26d4505fd357d2065b7c2877f831d5d5bb5b9d3815bcdb5e3d04e5d83d453c82286c5df5196d57c779e9e155778938311936dff1551534681a99284a59d6df98e3e3cb584b685e415dd3614232f37eba0c3f1047db38e7a29f244e9cbcea03f6c2d7b117c2909ef3cf0665c539b5b25fbb6b4271f4b536845521374e10bf22d537dfb72d01d3c1af60f41732cdfd2507d11b723cba2d0376bf0dbdac41c5b1b85608c5968471e9c1ade6071077e66193002ca89ca29dd77dc672cc5f32a2df5c1c4188fa7f24b4a81eaed78589d8b7690e83a15edf9430eb48ab6cbae90fc37bde72ca340e8dde334c9fa92ad6fc87e4ec295d77aa09a75ca342c81fe7f8315b1ae43761d949e6e145c4fd088c1e2e46930f139707f5fe88e624a52c2b2bccac88876ec80ba82bab745c612445fd4e4854fb626cf5c382ca7604f6f4a62d8fddf1f7dec2e7fa02494736d1ce9ccc20429cf1aebb0d785c5d89bbaf5da64465e36ac577637f79c0c4f3bb34370533559db567ed3483c7efbb42d63e33521f01d11775a7400b863371dce8b0960ae352c6575aa7a51f4368075362ad7d59152e3aa2fa2363dbe250af573e6288e652337e29ea5c6f5193336864168ce25f39e7f8433c0321913e1f8722d56e21da5d043ef481ffa766664329af08d891e9aa824158e8b6c3a2b0afd2c7c90c141c235baa3e24776d173cad5d5ac522c3664b5354a4c6151cbbb4f738ce7460b17f1642a25749c8fdcefec6ff0deb2668b3e1a5f10f24226691cd752bdf5208c325a3c593731107bbf1441d1648779cee5389adc8e3a3ec15a662953595d8d317117bac10316eb7b9eb91b210b525c246989f4c1e954565ffa95bc266e9fef48b9f5793a5b33c82ed51c09ad4fa1a9c5599d57f00e967f9aa8e0e213009aa9dfe04e858a3b2a0a869ebf20174db6ef8ddf0de1749640e4e111253f6bcbdeabcb66ccdbb09c2be6e89897e1f8d3d87bbb5687bf9a22ae485d71565d1302413fc4cbb10d78f3e7f6dc3b13025ae07534bab27e354f983b1233342f63a99d26bf9bbfdbaefeed7b0572a596329db8906e80b2b42e4cc7baa7c4f88863d4e79b88ee22c531d8a3ca0d5bf0310bab18fa37b448e90726be4cabe44cda5c0edde59286958c46d0156b32cc80d258c48251fbbd7b9b1a08b9fa508dd9a0d40bdbb87c35094487ca4f98a3bc91676753aa1dde7b35e9d582ae8583b8c6800a0654980f1ea3bfbba2384dd4f8684273038dd5ebad6a8ffa81626e3166c1640d1a779a1590d2ce2449d95a9b8754a38955ff52373f3d19215417b37e7d776b0f8421acf84441a618bfce134f270c8f13d69a48ed11677171f44312d4cc1def551bf8bff655da5c2d9b0413cd6d55c2bb4e927cdaf44c8d2c07999ffaab3e1e72f3fe3955067ef5f3bc5e7150ce6de2d83bc510ce79cfd87912f8af85101ccc0443b86a7a7e1340f40c796c1cd84d896eb0037c5136c5877af80ded916b2a3c11c292e6deb0b27902daeb908dedceafafcbb5c589706eee3eac29bcce02005f7ff33af652c422debb1bd3431615b3acc33a8b76f102fb155de54ab7fafbaceb08752776d01b62ea168f8ae632364bf51c60c9a19fcb9e876b72cfbd4883314372bec56f9dbc6c16f85c170bcfd6c3ac8427d42b79d39962f594e84b6165c606133f549d2a223c8e0e90611c4ddeb26eb43c2689192fdbccbbc9efa018bd4ec3770a1a260ee6fecb146813e31eebba9df3983a365042e34dc572278b96f698e55b2a4295ffbf5bd9369e13c56983a6a1bcfc26c2a0bc224c20f2882c7cc6d73113400aa159a73a36c17aa9d926078243e8906bbd3a17ef775418800802a6993e7e4705dfee1747f679af318078d3a55e2313555ebb069dacb53b71e1062319cc9fc68a589688233fb45508d6e09cdba6f693cbc94559960ad9cadc549b567e44cd5e605fa4f6c95faec30bdad2db3967edc951524da11e9063f5c7f15feac71022b66e9437a0b1bc154eb133243451f55f10f6c8e8215b62afcd79a910ea0673ee6a8fb0855fdb13c34e960afaf29d275eb4720a2761b26765c80efc7c01169747f3ab54178255821cf5ab5bc4f0a07a4b7a0fb51264338aaa3c0ff547fea101751aaef78df53365b2df4bf5fdc49b660ca2ce37b5c83dc1c03d6a635a671e94231b5373b54503c8d229b78a29bbf04bcfb1a54cc89382d3b1537af433bccd052ff6aaaf93f7950dc2b345eb6714ef8d18a0f8c1c9a198de6ac8c05a042b761f32a7bfb61c21c6877cc783f040250b8f441788f7193ce82f714e0662ce85e6a097ff5729fce2919d8e5d38fd2cb6bb864492dae4f695b283ef050f0e31d13172894d0b670c318f86e17ae4e85a6e14ea5dfc28e5285a5155a248877deabbba0cc15fe41c77caf1eb651702b804c351d9a6ca67a15c715d6c036e9a19a9d3c655af6662407a5bde01279e1cae8c798083b2bf0f9998344138267d12af5f16a72d0c72fdc38e9673ad376459437ed0c5afd21486ed8dcf807711531c38bf01f714be0b1a2ae781f659bd2300a7340ead762c6f6bf27292486ff4853f29dbcd853fb3f4c6698d7c8cd7b79c9d3f998a9ef13791ce113b081bd5fbf902b451780dbd9b1d9b7737a4035d313b876853ad1f14e618eeaeaefd67bded76f7c62544e40f49fb45ee67d2c9fbf3b8e381a2b733e97602953c09a2e3cf79cab92a2d1677046682942a40362fe9ada9c6f31494293d914ec425710b10911e4db9ebf9ad4ca58573fa4fe2278f189c54965dfa901973278795b21183dd563b9d88a356d85157fad7fcf476acd5d162efb8a6d75af951227cb420317baa3120eab08c9fb7d1b041763b181319d1e118f3eb7098dd05472d38aac443ce4b8ed1b960e71c25ba44c0900bf37aadd34828ef8b282205969f68484302b689567f2bea7278dea486bfac103216a7b4c803e036b49016a35c040142b93c60a72a9ad15d7c7a01dee0adfcd0ae3edc45ab960c68249726a0e88bdcee510683ebd860260b2d94d23d6071ec714e59f4bf168936c12087accf3b85f24a9acd984dfd23b512afe8335702777ea138d82e981c5b618c182bdbffb6a0a3ea5b51fc36301aacbb8cc1ff38b56f20350022d193bbc73ebf42ea91faecb722315dfac84cf7a5eebb8015175fcd3117322db910172c8f6bd0cb735942bbebcf073c9019af3c91d21c7af58f7ffbc602761f1a15f374a9a9ec9066f1f706b73c0afa7d68ebf2df25e19b18cafa8927aafbfe3bb4c180dee2a101d43082c23ec2e0f186c63de3ab13c30ff85127a38f535225268555eeca9e866df004017524a226dafe67d2e6598a0fa4b63c2a56cb0b330185e6f4cc6f296f22e02a1fb6cb6b836c89a737021e679cef2341cbef1bd3c3b6e898a31505bac01f10248fefd6831a46c4ff81df57e116800d12696ffeec9b5341345430926e932fd8e4329466af0231348c17a5354e1e54a9eb2f566b7d9919e6b5dab10a524b9118922d030590e261537568a453dfa4f8e8bdbb430ff13bc016c72958a862cb66dd68078791c46f3a32c26e6a8c5293b03572b6361576f353fa249c7634552ef25ce07fe43a8c2d0281462b75efc0f467352cf222248aed1db6c825fdf6a0a6e1ef74643b1fee1067908385b3dd9daeaed11e9bbb76889a8b05ff5ac6cd4c46d584c14cb1d2a396f9bc414a61d9a42286c8a5a64889fb34a9fbc3dc115a57c5bb90361d45b037a5dc44801a6d3d890a8b0a74707fa7abe1c71a427b66d7f6be8e3aa9939a62de7fa628ae04a84905621ff662fddd3f6c621c45bd9e54ad5270e9c0da78c66e553be06ea37d04efc6a5ce22a6c02e0bb45352cd26145ec2338794436a63d489dd619ab00e5c02184505e232b0bf9d1939cdda0028c52ddc2973cc4ee884a645de8dfb9f48273f3ac4297f7268503eaafbec2dda34afa7dbc47c4410903a2b1040da598fc1d936adde68b2f97e55b9fc0d6a4409fc69d213fe8bcb84b7c7236aa6d45a3c1f0cc29b7e0b7aecce866f720cb878c88341d2a18536c43ee69b2dced749ad01c9f3c4cbb16776474ae01876ba39106e1abfed90ec4ba0d6c259831314e8f2647fd98e8ca30cd85168a5b54a4c23a062b3f32dceb8009aa395e3fede26ed902a70433d0a029c74222159ceab507c44d8ced1c417797700c0e221ea1e47eb7fab4867b6ce1c1ad968933a0b215be12e8b6b27992a6fad542c3bfa718fbd7afcf7cfe8e0441b5d0b6d457b6e3577fa278cea4f39746435949ca8c8010b1ed47ca42d12949c903c985473aa90b057029f03b34c94e5753d277e47430350ccc1e95e28a358b8030f378a2888f9feedd0abe6bb00931a5e6f106dfbb73fac7050edc2c39f2938383679c72af628ce459b50e7462049735d1f74a3f34c240a36f7ab8c5448f5d176991c22b496a588f5f15b116f808d46c740a791f4b4785842249b710e6f4aa2a7a479b194a3c72b1bd3a18037926cd646267aa1aae8543e77e27c0edb6321444f9efcb724edb78f3f2d90b10daed65a258689e8b7e91bc662873c07843227f0983f6335d8d7a7eac1f5f6907476926576cd78b57326587aca57f45e6a55f98f06b9c42bf6b19b8caf213868f31ea6fb5067da297425ce8c0a5b32eed0b0900b16ffc6b6453e509217458a033aded7bb96301ce419575774b89ba21f14f5220cafc44d07a4dcc8f4a465e0d588b6a4b502dc97a7cdc73cbfbed4fe891e32eddedda7bb8f712f048fa6906235f73f11261ddff437bb1526856019158b50d7405956f2f11da96245bda5a519268399aeef11de8b8692cc7b3c370bb80332d8aa5eb29e10a80e1db05dbfe42591b910b5201208c42b3af578f313be248af3c757af50da439f102c01dd6b64b6097bce4f566cb7f0fdd0545d96e087dbfeb77677b39943cb32250b304544c6d9f72fc3ccdba1aab12f8bc8a80d3f4abe8ab9cce81e2041968b896f6e600a6f7e7809bb13d00481fa9f3ff3c42a7afc325f817444db867c7b6f71af479d73a33316f6a01118fbabfea28f93b8e3458e6302449a812e55b7e99ac986778fca34e43255d47078d6df9cf697635fb8f30a13c389d052a89c1f2f7c137887431bacb19925ad81a4a7350c02e9762cc5c01667d7afff6566a9368713ade47003c13e87bb6808c790f736bf65b91eec69ddc9fe589ecfa9338d4029b69bd31068003fe504af75380dca2f5945cfd9f586f0e6b7803e76a4c2868356ba89304df01326eab5ed16b1f30dda5163b02a99e8041bda12b20e478c0a9ecc1573457143ec2bd08225f785921fff1d59e0662d3c7ea956f9ca9a22dabc5357aa65f457dca5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
