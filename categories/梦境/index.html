<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f66815df3fe91e8a6454b6542dd09047792123ff5b618dd2aee8f16b990dc53200a5dff6c7711cf6916c5f8b51612a1df44cbc0327d7eb13f0b63ad5a9ff9221b690b47d25109bdc6ad1eb3ad9a87faf8ea5235b04d30b7b8804fffd073cc7225851e0ea28c9689baf4e3b34126ed5eff8133e854aefd4ecd6b6d48c97f657c641a5faeb6cc0d56060b16fa5ae632e3fdc23eb5c99fdb4fe10218a08be068b66d96e43b02f116ba6cc685a1e86964a21e8db734396e3cf2c70083cbb2b11bad19d0deb87bf40bd29b7866ab5be78aa20e2a2facb50909bc80884c2767cf83df20b2a0f80f8960d6b6539f7fe3d25d64b9b7c0dce74106c544eb1593ce42f8231758e4b1af88610057926a64242173ada416b22621408e089dbb9ce2800ee69cfe0de9c790312c870682474f9af5173208ca59847fc49c9718c8374d2e7ad153a5cc8aeccce3f3f3034d1717ba795e14d70dddcd71abd8e25512a20002d9a64934b451e948dfd81362764adffba70184d8c2abaf3d490e37567d464f2cb59dd63f2b3408295e9e656472d1d682d0b3d8eb09d3283f3e49a852e63ed8923cc426da5ba42c2fdec52a4793c8ad13af769afe949c6d83ddde679519b4d7ea825c3c3c346045a5104686c1d5050b851e93ba763ffcb4e7180bb36f2542e6bac71effe0d462288a90756fb03f10b7f204d85d89fdf1cf67c6f4c683bac634f2c4e76b57f1bdb416fb234aaad8df970123e46e8e36ac8e16cb0d88d0a63fb57cdfb2b25823d92a87224e7e6395cf5d5573eb2179a19142f2ec8cb4d02007ee3720dd576d4dfb15f0e077121d23bc344b9667839b6079fe4a706acef1abd4e9fb02ad9bd78cb2fd45504cfc3e84352c3a2d683503a41b185a26841a405e720b0ce7a3f7e580a08c76b2f125724d0a0f570d89a57ac658388c1a914dd9c9a76f693241ac77c3f492d5a97068d26dd5b3d30735151345653fd1b33686781bd06a9ca84c7496e50346269b1028bcd40cdc8423da73384292005716188ae84f5a3b44815c2a0359013646fa3081fc9b21f2593fdc1b3b18a08a19a009f9732c77f968fc90f7431f336f921c2979943b5f5d8a8a8169215a794681dccf63c0c093156e30b49e4f82f3f31133f789088bd3916ce407de372170fe4a0c53e6bf19b98a690a572f05a206eba7ac649d7b03e0778b77b5b09bdc523fe7db68410b00f7fb9b71e0c16dda83f103a46bf2dad76a6424154d6511ebb615f50709c6a228bc45a0e347c189ef1a1a71eba998766779b07cc8e317823dde406e43c3197dc2f696cdf9cc79fb168d488bdc66c942b6537be5ac6f39da290f84e51c28827379deeea80cb8caca244dc8742bbd008f38afa2bf56cb672ed2b9639b985657da25eeb7d9d1f14666b285f7c1ea94827e3c30689cea53bfddb7854aef6b5d0557d68866c19c3027c62aea4eec5f4e6fc249c6c851abe795cc552f75d5604905bc5a0fd038db9c232f07fd97727ff5ca91e281b374bbd7072b61002a46dcd9fca056c8e308706bf13b7ac9b9451d23b50754b097811d05c1ab5753f2aaa95414cd88314237403b1f844ea4ce3637c5741cf9ed79c8e9421777ac12d81cdb38c999ec491a1b32299a4fb6543965db85d67abeab5bd6a187d06012382fc2636076801c1af640cba4debf7aff9f8b1687fb27c8af908b935b0e387023395ec0decb60ffe8f7937ca2ca83877f86e53f7c1827616c5144c4d8a8768b8f930e749085cc01479a47291751994fce78351f2a75979202666c79bdc45b719d21e7cc61ab85fdbfa30ec73184102dadcac8759e4c4580d1fe70c1291eae5da6e71d1a17d2a001acb183d7f365d58503c293383b30f4645aca6706a0a851562ad21150d4ed3ba93a03d1f7197013ea19121a609fe5aeeb9402705939a94e6526e403f0075e6f3f782898af30e93c19b273529b872375eec334e73703ba6600527deac8882f1e87e456b8917574e6c7a361b9b45585e318ded39786b6c8e15a0feda051f2f3a6e2cf9a48a51dac35ca5d326a601cc058c81f14420b0ab0728ac40538b7e8c96a6defd3b236f7dcbeb4ccec3b8568701ca7e4e787758209969d66ec2c0ea81f6975e3ee59990813efa836256961047ee86ce73bd9818fdd209543ef5f0cc11bc8165087f1bfccffd7e411c438fea118b8a2e33219508ea1a24f1efb729eb139f7f5f88095a68fa026c21784f51590a06cff9bc7a13613d0066008cdca170d4d2085d4a425d2312a10148c7ec643b4032a129cca29b675a4fe60014d1b293056e1928afcbd0b4fc4ad4b0870f36bede5dae2d81f021321e528f30ebd7192dc2a2fed25974acca92c214e164309f5f04642768e3fc98d4340e5631ded23ea925420eb0a4cc881982b661c9a068e0ddeaee921996f9d81ad765a09e4f2e5c148d9241bdda0ef3aa19eb37e0edd73c55ca764983f6920553eb71fb3461807205cdb16d6d8d0d14d62cf58ba9c79ab64769eedae81c592034898c670ef9ce34036011eae1f8e1d0b00e38ee06ef42ecaf97fb42b77fe2a8cb35c1c5408d26c50add98b49d433e62fd4da20b7c177d27b1a1ba105f6a06af40859f2a20d5866c51c02e7600a425700a4caec54045955b950789e2b714902125c5d9cee2d55a87b515236657d5390b15fe8a14bd771699bfbf31ca1a08b8020d3c521c89e3bd2414a3f7a21799ec5d058f58527d85880fe4ae32466d401d1dd841d91da6c2f16dbd6d33d3d7ef9750313362158951224a47d4fcab17277c985e8a992dc77a3cd187230405014454c16f8c66c45dfc71816a1af2f899e2928fec8e710ff172448890e9f7f3cf50ef337a2b563c4cd40186c2a4c27a24db764a5771bcadf96a6a92ab6e8703ff8fd51ed77dc81af1187ee0c915b7c6d16c3b273d9d1bc09e37f4f909f3fcdc0b3776b57ecbce4b24d9d6bb08e84aae0ced6e2269c002c2c7c845893b5a5efdafe6936e1be0e184823c4f7681be498375c1881663b77413ce97cb45b64996b4a3d98f1be16d6ea6b9611b5f5ba4495b4a2182203fc115d50db2326f5d672910cbd68de84e0bfa8c28a7b72622a8e7f247d28f758a6f03a228b8cdbcde4ee5e90de42a007e12ddf759355adc022396343821676fe757fa1c1ff60a2d187ce3fdfffc32207b233c28b89c23b5abbc0dd83e8720fe1a7462c590ca1d00c5c8bea35cedfe765e40eaf75ca94f1b6cc8e933bfcbd7b59841bf6d4fc8f5f88b00fdb0ad2806a42c3eab23adcf066c1a02b4f7180a2269fd67b9ff849611ee5d75b6db8733b082f10818bd39b0562cdc9950ffa59df31c56b737f5d3bb3985494b3bb2258268551b1b3aa330706d0ea0aaa498c02497bb53946feb2d6d908a8e4ddf8044b5029f42456f064d824404db041872cb2402754bb7f58c3afa55520f4b49aefdba32773f79f4ab15b374581fb7e47db9a1c2e5a59643a3cade610eb780e02b6ceab28c4a7665f1c38cc73756f4ab6a0b9327a48ead29699c314f209502a0ab3a108f6dba86072841cf1c661e733765d1f5adfb9de6762c0fff6fea683c08701a13c35b70d53bec7875c8ed9b4672a830ca8694b568588a380db4ad6fdd6f2923db08704214230b7b0b567dc93694d0493ad0afa24ddb032c7a0a8dc95ec2dedeebbd8cf7d578374e1b4521b9726c10092064c195b448497c568286ec2184dfca8f561b95caf53cea0a80e5c1295c7677ec0a5ffe60c2017b7c264125bd3acc49980c140755acc79da194ca85b86b7837f55f5357cac8d4188772abe1c4a624d01b9ff62e8b62e0455f86978d87c749a3743a983409ac2ec35d54bb709516da73f5e784a5216e173d692307138ff56639baf8d73de836e479c846ff5f75638b9f58e8c0accd6bc4babe8e167a22fc655385dac459d24533735880891d81e73b00bd58f3f247103cfa6c3355f36d8ebcd62665f361b4b16b3b7c6fb726d81492f73351a6ad06d0e5dda78bc7cfb5896005c719b5f1af560a2bfec8afd5dabbb0425b6c0d18cb170b3f03130eae4b9aa42b17f769811826e1926de796e856ef3e53240149ecf45642a6a20b9a73fbe1918c1028042d68fe59cc26951831f97f2fae0eed91706917ba62b3b7f202f9fab25b0112e1df5dbb915cb3ea2acbab6498aeda6ade188076d4a8facfa470bc59d45a6222fc7b082d7d77c1098aa859b5b9a477580cfbd293b3be1ca77b498aa382b09e1b0ca2143098949b1f52e27ce61ad3a790e4b9bac8aeec43c6068de113a39fa6a754bb19a894f35e504bd21666c5ad0898943341e7eec5cafe38d33b4a4b1229608397793d681758794942c0d51e46ee22b37df78d0fe9cc055131e96ddc58b090211382ed79d53089d9e22edd20629cf7cec702be77b61da6a2cbf1c461677e1b0504523a11bb68a16509e59f099623de5e82e6ac3a337463931975b4c4bc1e71474aa08545674d308bd39fdd47358c3e466796de8fa6fb5fe119aa349ccd4232d74090cac5baf4f5eb0670c602379dc919b66fb72aa2af10825e45ab19d1be39377d485ce4ac17ec9031f7e153e798462e71356d865d5b96c50d9cac3138a66cf9b41a96e7cfdf33aec70a426960f361791b454aa8049056ecf52a559c9fc9a6557369e1333c17c7e2a7c8eeb89f0648484291a4bb258801117f95403259849c9245e530dfbd62ba1da99c21e6aad98cc0adaaaac13dbb5a262f44efa3052210c21a1db781908005aa4b328be74fb65a03e6cd94b373b926793916d1cd7461dd2fe870ff4c6fb100fef7234bbdc5d678821248fdcfac90d2908de7ac3c9dd10699f4ebc29ac54f03b17b515d6085792777e0f32b0dbfd342de7735fd5e4b24e7f2073b24b54ac5f95096a248acc0c0dfe6fb9229eedf53465f74fe7fce764c67279f272f2a815b7c4385d24817a541c3d61f2d77d8230f57c26f2418146ef9b436370a359e1b78a7098f245a75090db1fc8d9c163ee60db8993847d745bf3aa732142f59846e468df1860459a1f9e9dc9d84c1c76c812abf4f2173b80367898ec8ef141aae736c002445faa9bfebd6f421335aa8f870688adde108fb84dd92bd23c01ea19230fc00f02137b30494e8c60d65648a8bb7f5ae13d56ea61ec0a0bbc8982bb47a111ee81e409f6c62a7fb0ec0bc09fc59e337a446121eac66b2fdc5919b5c4519b1eae8f3395d436aa734fc752ec096982cfe23511ae7cca099024d58a42901e8bf9560877df93bfcc71e3a4d834c8936e7bb39438020be4e7f4e678850e9f7bf127cecd62aafa04111ccffce293c147350ebcdea2ad4fbfce54bcaf2cf7adb0ec024c3f4efa3be99ba5367ea9d5de49ce5dc09ae83272f6089e839c49bc659a0936c7e8e65db9fd78db20318da51fd79ec4d49eed361c8446bfd203882a776c331ce5ce0275e2c352dbc359a00b6496ae5056ef453bc53bab0321fa39f8f493eba365b305bca2a66765a01bb36dce509d28851ec5f5bc191b8da4ac6dfee742814732745b7808fc523ade3d5519cf1861e918b077a056db2f060771d57dc1d1557822b38d86b45a03b6651b1344481fe1c3f3d1bf31412008dc84edfeffd445af283035d465fa536b660dc6340554697534b8471213539c9be3cadb367e96980ac2962f3d5a27a21f2fb0330b8b608a1fccbf62efb0718f4a4850937a709e8e329e6a7487b951f83632279781d49f942f8f2590a86c9d15d513118510f1d70cf03f594b44c9587f7da9be5767e1a0c07840a37a43650850c6844e279791b9128be85c19e4cac85bd0fce06dd0b092b2174a26945fd31c10dd6db5aeb7ac444a103f12234d528bf2dcd19df31af330e6085080ab3fd00e061b69bd6a5ca12344b3cbe9db6acebc9051219a65744936cc79fe6117c6640e56a503ecd34390348c76f1a105e1d1a1577bdc9c82f45348a2c5985f86d1e6cffae7838a65d2c6ae7e866969a5d358dd6d420e4b36d8e166c28cf0fdb0c98d52c5f8db5e9055b479c5e7b3af9328e2c4e277425fa5c20f5cfbec963d3024ac254c77008f13ed7721938eece53d5dcc1121b250a6f5c3a846913d5db0a9bd6fc7f8379b2ea5506405d75cef6c8e6798d6c7b944e470b322815a9ee8bb7e354a883d84e998f9b6665a4cc5ffc3747ec202a4bbcd95918ae8b92881e8f1dc6992923870ec572caa216b95c2b2ab57592784194f2242072795a850d7e38f40a2b1c73a6d47765372e3187439aea5c775b9410308dcf416530136cbdddd27519878a160339be2bad929b0a6c142fad881e4f443f7fd53c47d9a687d6d1e435a1bd4a319e5172c72004b864eadc65c9a8c02cf1eb75a1f2b0ae8eef234ff7e7104745b94a1f1c4d3330da8123e1a66e52b9de188c8b00ae7a06856819f48a765a4c491507f86f71bb5eef098c8a09a6f695514675ed16bc625578059ff2266e7a0614fbb9d921ab087ee1fe523b5c0d2688b7ebd575f79c48dbefd6f9b4b7ac25eb69e584a4e0a99a92b7c407e7bba61c7ad99c2cff9d74d0de0a655440ce1ea2304ea46dcfd95e8872ae44873e3e7af45d366ff1c649de2e4ef2f366d6c4c959cf87956c5b4b355cf26bb64f81743b01bedcf7df49daf5b8593be301ab18cb73e35a0ee005dd749447c61992c77e77f8aeff130c66bbc72befac4681c964b6ab9331c0fb64bff66db01e4582974695557689e82caa282086de4abbd71247d0103aa01b05e01569e0a321f87b36287899582102899abceeb394b2684a591cdcca14cb8099f4fb1df7f036d05e7b668f3d0fec89e76336c3e27e6680f7b1faf7cdb2cdd2221cb95e8d647fc608642cd611f58bcde0135455ae5b78c903eacb53c0a28b4f05fb49e93a1b6ae8b6d031b664c584be68146b2d30bacba532bbd34e93c285b0b50c3a893a82bf7c3f45aa8cf0e2187efe29f85d1246164536bc4200ffaaa1b33cebbd51f2911e0caaa2a455301a735307e67b507abfefcf5ae68644e5e66011708a45859ebe815fa7c4c7d99d7c5caeb2226f149fedb7be151dfaea1311bc3a0849124cdf150409588b4b43ed9ac0e0e63f75e89c696426793533d5d8b763bbdc29d55be81002f9121a654d0c31c8084e42896e9c2c2e057615dbe209a251b1598bf665abdd45d4582cf3413d2607056905ef51232ccf8a5dc366c55592dfb6091d65d9aa3a8a31bce997a7cd0a85ae1c82687507e382a1c823123d7aae692b137962893bacd436e092b342a172028971da65024cc2df15d6e9a03662f18367d8bfed746a688e563952b416eea3c5a665ae968b0dd3093e093d6e9890f726450ce932bf94bb7e8c84c6ceea68240ea6e3727d3d72008d1eecb521a5f6da8416fd4b2db085ba1385e3de39835202e0335f7b9d108cf15efdb73c404cfb0ebdfa7a7b134c8b05b93187543aa1d54d941463fec8e774cb949d852053b17cd8692b002a4418316cbd903fdc5874354b873c0b881c5db4cca9b6e23fcb2ee59538ee9a66510b4ed6f478df00b0284780c840a8f2cd284e44241f21289d07e27663c3b92b16bf5beb7c32d8fa9228c359673473e997dab1264d852a536e71a060d4b2c4593aa2bb8e47faf362c8dd8724d95f8d09b705ddfb7640ef91e61e4f33fa534419e95f6aa604cca22a2eea532acd405542883ed5d74521a13bd38b95f9cbef56cf96dd0d8c94b39a10fa872f5248697e3f142afd915e007e5d8b0aa1c9bb016083523df1bc4a205d19d334c426f4c35f2f4d5fbf3e97fde46035e3b7bc456b86d8d76c23f21b588627e57c59da9464207fa5fa27f9e722603a968e0220230d7c283f324fd4bf7f2af23b0d603756ef5b053ce5aed9cf7bd4908b53d72093e7a1325a45c0915f192fe6de2b87133e1d9c91c53c3937c4b1c86e78904efc553b42abecb270b575507456d784217103fda87e3ce86d7d0dba3af15dab4a141443a64f3f2e409b074635f0908dfaf26763ac45797239396e3c52a15dcf3a47a3d949db36abff57cd01f094a3b040a913637c8e18e90ae97f464503c94147377598363464c533e882f59b4b211b2982d5bc8e8a4e433e63e4fe8fdcade2c4be571bd1b714622a3853d5bbbd69e1bd1cd8149a84b7a3bda0fa3db3c90093203fec58c475811d1f07a4b8b8151484255088c97cd2ecdb5fd5c3610528ad32d325cdd719c28b45cb8726734b2e44a8579473eb3a6174d9f524b198abb2c9cb62c06a9b9417a3b922dfa273869cfe4456e5208f791b8443e78d0f924ff3da763a5173863594e9b0944211b6a89bdd5e3069ef6e82afef08f2a199ae430e6de3117ecd10cac43cd02dd8717b3a49d52cdb47c9416282a2404a552964c5795a9acc71cc1d8250e29e104757c81b55168ed7e1ee271869e495ebce0bf637df47196055e56d967b68c696bcf7a2fa84d2d73d29dd401f938a1a7408c653de237add5cd51d986e55d2e5829202371f5d24c66a0182dc8b4b2a209f40ac631ce10c71d3d2deebc4b6c6a507f96444dc0383b3dded6f3b642eb5c8a5bc1df63340b65fc0e140ca0d63fc676b3cd2b8c5beae618910431369252c5c1aafeabb87ed39bcdc44f1182bd1e4591e50ad93bdac2a0df53c90e6e4c4a612e512e54a0aa7a129d859d7a9758eb88a52568428f375c40ada6839758a7ece444d7cd1b1db625ef6213dda009a71ab3b121f6c0a2e9a8aeaa3fcbae9c65582032543a863da4f4a7acb2f3ee033769005bf96e4ce4bf85064ceac9988a14807a45cab39ee5d7b5d30c18edfa1296dcaab2c82e0947fc19e1a4d31c52e3343156cf9f30f3d40317a81798c007a810cee2f6fb2856135a1f89a03599e6dcb2507328deb993d702afd6bb51d1ef45f374cdd28d1e598eb450e563ddf9431b4319e58474350c9ea506fcca9cc010a7b3153efad28082d6cf547f6dd949a549af077e973024c68401ba2aa1ae11d1df7f129d482b6077f81f4d34ae4f1b29a6553dd49bd0e1971e359d8f6a597c2a6ce5b4c7e8f1278dded1ced330e01f53b7e1bbe1c872872999b08c1888052a2bdf3650b732c87ab2530fbc684e14627fef0d2f7c2efdcfbb5231391c7f502deb0e97d1cdc2337b644893f7187d496337b75d74b626c56a1a2e29409fcf83ede75eda70b295087349b45836ff418de8e05635b29cb57a40788b64537f18a6f3f3c6a01e414d6868f5bc9fc745c56f654e8d68139f0a789bcb47ea9ec978f784156d5a615b17abe6ca8730297e3be1fdbfd9fc98367be634ffa07677514119c4de5f56a9bed6bf1af97dfeaeb6c8337d025e40dfc96a49fd7634324b56efcdd4cead4ebb7435dbd81e182f9e722eae8682cf051c9972fdd729cb69100af75fb70eb9865fbb5524e9c433e3344e509ea85d2df2f5b91b035a15209d427500210fff21a1a4face17d9eafc8b097c2b91d105cf614151efe44a11aaf6b13eec9c89ea283e65d8e3cf8f4b4be668dc6a97ab0beabe07cdae1a9b8f310082f98f421974a23de7698a8b26ba7d3f58d305ccc37a51da14573c1d7f2a173eb804436934975f066e2445f4f7b416808e30b486f7ebdb7427503311dfee8ebe2a0b4cbd3402382cbcdc43a9567ab0d24adf7ac1f7663d97f7ac01964e07a6050384e8337bc0d996362305ca8a7af3eb40b3b7855f966fb42478fa8c4d221fb75a741c3ee297a44f4f1284f9aba1dfd06c2fae0de9293363ccb2837c145318df240e5753fa3940bde7ea08bc9a23c8bf6b6753f05bb82b4cc44a7b2e2eb11c86a6b394b0107522cc133c91659fc48d429aa2343214553dfe7c925241f22828db2b9dd7cbcd9d82eeb217a5d5e415714b20cbd3865d495281b547d8d48f1e606038718e1853985d5b211c893217b7df818bb77fc1bda130f5322b40440d573dae5e0cff6112c4afd96dbd6795952f91e6849044b391216bfc38b7152b0f7142b12345f123f8a2beb4a958c2a8c7eeabdb3b6c467c17d8ef5f0c9ad97b12bd253e2d7c3bfda16adbc78dcee738f761de3a0f8dcae0e4dda71da237daf696909af1cad856a2b4161bd233db32ce7277138b8fa3f0ec281f5e5283155d32fa6f6d427ad2f0e444a41663d74a14604b320ae44703655926fa3f2b5d2f86f1f837be42b89962ca44dd3d055e347f2ca924f3230f69dce3ae2f9b1727d44c629a961a4e15a98ea72e4a019361c54854c088fd073e95d25a9aa43f29bb719a612976d68688d0cbf15394576354c9fed1ff08824773911b3dbf5313d3024bb70af760fbc3407c0e97bd20385e8e9c4c4957169be19e6c3ec8edeb95271140efedb992043f69ca4be006b456b8887c6a0ac6b9975ac22dd8b1ebf04ab378dacd3928f28786472d037eb92b2f3259e202f71e5bcb6101d6ef528a97f87a115bcb906e7bcbda2c4145a12f426605576bf15ff2d68cbcfaf4f21c45e034b25bbeffc768f770495bc74cb00b0fac5ccaeaafd6e3a68662b7a3327ec2b497ce0013d0e6504bf233fd62e2bff99cb6fc3b22259b1d55ceb42fb1e98db11ce148177da28c427589aa98039fbde1f4966149bbf30c9faf88a794233e73472671690a04de41dd4e9a1a2f2d4a60084e2b2743a45c6ab52e6b4aa3599f3e0c5d993911154484023eb525d7cf0cfbd6c7d9997c0344e7f07130257c7fdc951b183c9bdc69b9ff9b526f4613870c0eab5d8c9c9bd582f9572902e5ddb5213f839cd39fdf04406624323bb586fb42650a187f2941fad8807bacddfb3cb29a58195e3ce552958a3072d2c3318c80c11ab2dcc320f87e084b7e9c4","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
