<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32b2afe65ef57f7efa0cfaf8ee84bfe67298f2153b26fd216d2050cbcaa3aa37c519a426b1adde1b89c7b76bb3f8c407ad1fe5f478b51e728fce2dac13b6069e6cb7ea72e9af9864eefea64e876dabc3e363d890cce0a73ee24492e6f7e03ed6101befd735276b2509938dee0833631eb042bdb2588043be99fda03d098f470a56f6988bb79b716bde9e29de5a0c60042a82e973b96d2a040043350e2acb4d49e0c265fa8a863377a18f0a7e4ced577c70d5609e54bd7d2f8bbcf32166ba2f6377fda284b8766837bcfb1a73515ae4a9c90d1b3d77a5b45d7eab41aa65fe56e07c4bfdae0974521d49194feb57ec56150570c940c5e37d467bdf0e547b5e8875dbcc607bdebbcc33adf9775cdfa6cf6e1e82c16d0bc67438839ec39849afd76645ef024c57da2494aa24f593fa6c36a1c1c25e4fd1f6bc149648615e0c8bb83a78e26d4de4f22999fda2f2241f7d336db4b1db1095fcc30def849d918ead768f23079d34809092972642726038f405d3cd04f499ccc8a14afa31e88b18fb2ed0f27ec8ee7532574dd41c75c83b521297220758aa00d31d6a3dae1d26940eda66b394a0c2146986b0c3728811c330ef07b9583a990aeedd382d7cd948e4ee8a9b4f808c91aa05971147a81d64c9989a9579803d11540909dabac6fb59b853274adce9d8e8629ba36f2db1a566af0457ca6cb2819b3b9c362ace9b9ab5b2188f7f306dcd83c309a6705efde4ad543ab3df8da764f0ceeae3c2c84bd428ec415494ae3a997eb7c27e76663535313b198ea50afb3173d4fc5b4bf3e48c0b273025e38cf6d41c28da6ba3c4e5b8cd0c15f497a2811c80605c7c2d7432f35485d476d294aeea23b0eeda83582f00004fc3bd4b345a2de774b1e446fe1989d626f23c36b35df5f9cff05f1cac0006029101c22dd70debbea0e77c73f9fa9a6784de109961d94b4f65ac0dd859325b411c9324cb30904550bf54f37b6409ae042de99f80762de84d1481d6b41d7c6ac875ec256482e5cd59301184a2adedae12fc21ca5e8388ca73ecc6e4d705f023844afffbe466e7005654db3eb8e23ab37ba34dbaf0e36d11b991a402150d1d1783b9fb1c20ac6e94bd7941d26c832f9d026e6664db66c4c955da30b9c10532a0162605da39eef470c80539dad551d069072ea4bda940d58573b64b37b753e09c30bbd6a74c3f831a76ccbb5d16bf342cb3d039fc1f5ab46d7afa806881d3e91e16b23011912067466ad4323c41a210e3a3efc64412016afed872f789799441085c66ce5f82399a9419ba5b590e3ae9f554bbc04ba3d85f00db4718daae4da6aba40ba8a13d84d5d3d58ac7e0fd02d357eb9bc1593363bb8f1fb74a406698511d32fd12fb84913ad3ce508f1e1fd725da5ef26803c04191fec8114e96ba3257108032986633402e5b7b20ee6f6b2a9ea31271fcc7af3b61087c6bbf47925c210326c3e659e7fb7a9f4f94984ed2be1e962a66b9968b0c60672e92f643031368ac8e8c55674bb2b3c7ef96b0e8cd279e98ba771fe3ba7ed8087f1042517be77e2c78b1db9e9a9c8854efd3e97c94bfdd4f8169af89922fb89804fdf99b5b6b7b3fac20740b7d62ebe6ce30a72c4b7bfb75a40c53d252f7eff6e5be5e6ea555d6ab448742932b2a950c3ba467b6e2688803dec433e5eed3ef7933838699812387f5daf1ec41c166c05f886927d1ba9c21fac345029476c77526371d5e834f20fdd5c8275a56697f1e44de0645076ee074ac7368e809bc9b9ea0d11db4c2da3a6a40e6b809f47b385114a744ae566b7e994c8d5996246678daea4e1f2a9f2c7d2518157da45d195714c040979f8b16fdd231dc1e01d446e4d172b359205e734ce6d5819eb03527f071f7302747edcd843fa8c9aa1bc39366c1253e8b7f28fabb640081bf292b6b3364715195a6e15a66487dabd3b4a98ca539f8243fc7755b41498f1d9c410985043e049db87d950bf5edd55d6c6d84e067966a35c44237306fa32693707ac74a1b48b585f2d33f565e1181e7c098f82a7e1f03fc6168dbfc75dcc0599bf1cb805a11069c2beca0201b07cb13c88c47b59aa482cd7149e50b99c5046e90eb8137053610197eedbc196f47ff35bfdc9fcf2e42bdd26be5595a0d859e90d0a12a906effb53d86c27bcc6010c0624816d980073a3c22c304f7aa52537546d08de85e26c401408fd9687fe6a86f84ce3c834478a0c54ca9b1fdbefe2ba8d611dbab7544acdf5163007c57a50df2196224cbd73ff0527e30f02ed3f345bbee47b04551750a07dffbb4e887eae8a6da538c80624bcd925ee470846a95a0b80cbef3adcfc7875992d61d90616cc9af707e7f52df9686d5967e1848c180f288a02b758ae39baf8d507dfc6f64e037cd238ce9a12b5bbd04893a30c893183f869ede94c3c2f7c7c003ff94d6291e88dc1d6e36da33df7871f8db1faaee5856064fb231310be5ef260bee5758bbcc084aab9c01e744c7345253ed3ce510ed63e29089e99568ac046003c549ad1a2369d71baab0f5b594e2a924f1a7f084a0fd11ae12dc9e7501b06babce1203e6aea12fbb554bb5e5cdf35dfaa9a0ccdc9b68fbf08ed3392fb62bec3cea61c8682c43343705c2d437fe47bce7f83b104e01304006ac0b2d6ac1e64895e230d6d7d32dc4208f7f18b497f2380933919c9ad831cd058c8ef444902265b11f5574b4bb1e43a16e344384ebaf9aaf40f012bda3f7534d3b4500d88f438c29abe0b69f3dc3df35f657f8ab3d39f06bffbc0c992110c484cf9804735e8b5dbb257c04b75e3f88551f5beadf728f2c430150d87f41ecd1dfa79bc3ce77b54ee63f546b241640216501ee575b9d9991a69867e02f62f0ed39de32dd2e143784c776986ed963cce7dad5a3145967a07655cb0d2ab7b4b18ac4fcdec89f0c7ffa59ee210df3d8c09a19a5fa568e862064eea0dd2cbb9d8ff96282ca65a2b88c01c1e2c06af7bbc213e5e5d8a52b28941f870070ae0e143d596daec2cfd96f43ff444849626b5596373fbd9bbe2b665368627bd552de81242d736cc71a72d57db3a83c992aeb18346c290ecd00a7d3c1cd9ebdc02160045008010dcc52ff9604bc5d08d0b7b967763075251b82b1165de5f608d5404f2f96c7b060f0389e323f4fd65f1f66236f99e7f6321da0e6691cb2798d418a2808d922dfc63c62177fa494f3da9f2a5f526918746d01080a989f704a5ef6f17c15cf15284423301da0fe1d4e976e5628bad028219b3bddc05c6bacfb1c98e7dcfa32e478e8c50c5ab0c5ccb0d7783260ebc3ec6db34c4420071a7fb1fea4e7a7bea885e47e45543b7c99456c0cb630367b1fcfc1b69c2747aaf0ef8a8a94a7329c90d2f104352ccd55f81444e6b86d799712a26bcca072377fade09e12f1a89be7e7bab837862bbfa922680e094f1858043defb676cacd34f0f9bd5747d68b52090bd52c95c37f305acbe76fd7ab80bf79ada6e1953b2f1f828be31c690a3cf214af81b147102275d975eaaa9459b63e22cd201fbf88038104aa9c889121bd55a59209509a7bfc5b393212f6433714136431d7e714fd5d451ab1549fe2720921e5972167d11bcf4a9d674e4aeb5862067fc8c47eb2719ed337b379193597ba874424de5ce98b656c87f061a9dc8af17179a6ad583715d939f57694e90ad9ddf6e2ece1f517d4fb3e15631b957a2d4f996523703f96489f0fe303104838029132cfea1255d725e67cb783d6e20804876f10d292c72dad2a2798f482633d55ab72556742ebc6a9ef6248d467a9f6c5ccd5f72cae87624d407d7e927a18c3f2f5542ef16bdfb2d15c531d51b1893534b3f3dccbce9c4e74a7f09fb4cf42f1c03646f04cc8ba9b2785bae7b45053626e78b5f529a97a25f48238e4d97457976bbbfa91a0ac363eed2aa71e40c426924f02a9bb9910638d3ac75b2aa22881415602a5b78e8c5df16ebfc5891ad3ececb8a85d659f0752ff67dac7247c9d6fac8719bc125d2ca8cf11cc2f4987854c97afe49c87f727852680066e9f9161aa198d867bf2a3698ebf0e1c563a02489e81755e159848044b56e681467d1b0d8a1e632f4b30933854c359ba234e73c12575f0198f0257f6b420a7904a1ec350b42f1044d2c50178cc5271fc2ab58f164e89dd639b50728b95c95aca44ce5b8b88474345461888cfd120d9573d713f34406a090e90e2635edcd12f198dd01d9162531fd378b5503c5eb9bd641c73599668b08a02a3df3356da85944cb63824fc13da72ea8899273155fa210a86b3a89f4bbf9a2d5225b1adb03862be7ceaf2cb2507b7e6ba8b59f8c4452acaa797a3806a929720a3629ee59737df01073646049bec153129dfd870d47048bb268bad67a662dc537adbaaf8e6468da56ae0e9a8702bb05c2f2fa310f527cc7db109bf4ccf52dc1ffe5e79cd9da5b9e650163369e9583a3e2b58b4f7cc420ad397b4a227b1cde3f43c945989dff2a4a733e27404d7713b88f1681e7759416eaa36490a78cee023023f107a697e2eba3f11f1612c973f5402a406dd1178cf81ad120ceaa1316ab7e2a76a2d27d2757e75bb35ce724c64f8b06800b256d6d13f99b5dfb87625e685ff6d518680cbade97cf5e6c2abe02e06e792b3599534e09e32ddb84db3df52161325ce8c28b1887fc769512241bf3ba28f7cc2093ba822ce1ed378fc79fadf38bb88e762b1cab9658b1e2703b98deec52ab55a68e24f52da1275e079c6b2ea46e097e99707cf3aca4b4c3b729ab125b30cd76b5480b279d40f415dcdc25fc399a81264a6f0831c2cff5bd08f49cb3626a7d9105324abc4b344eaa50ad7bd97a93b7c6902d729aef7b753a825f8df33c7850f23496507f39a168b4ac554b9fd6c0ff714340071299443f14fdc6e8402f2f3e3fca6acbd478d4c2af4d4b8a147b090d9c801aab42822295f630c24580c6a2f18c6ca72da4a4a9341cf99da381eb2f85eec0a42162acb2edcc3cf7e7443b092c652120fa413dc29c6b6caeda1c66281e4c9df8933d19caad5660185de38dd166011fb9c832dfb7198911b87fb41116e30cd9d9ca91e1f64860d0e2b2869f14e44d9e8d85fb979539440194de4f2a7570b0997c7ab003a1011abb7f26ec39d753d28b9b5f5783a53d34d8bed88ca1680d0d5c8757a434665a51df76274c7a36626891555e60947ed975c7511ffd42a175825aba1630b5f6b7906bff4ed07868576e237cb5ceea1936e7805b46a4fbecca0f445c8f9c8f78bb787aece494dd55805f4eb83d3d2c51a42ca6ae4ddd75871675fb5cf88206d21c8a8ccab3cd204f7be5ba51cfa04b48c8dc6ce887db788ab5f6775710df9d8946a9b8da4924f067947899c79ed8915847765c64958f19b8ebc1a1f1af785a86d59445af1cdaf37f92df72aa0f8320cd45e248c7b0fe569482a4712926097b5bee042416a4806b76d4fb39c60a916fa02a29fdaa37de389e26b58c841ba7da68dca018ac9d459a1cb405e52bee32ebac1328b90fb60f66687faea71b042e263eef6b8e39e178c723f46afcbd38252083bb7316b675c4f14e693b730276bc32c3dc816ea05f596b8710837811420db617b40f697f25f5d5983cc5ada6dfcd903c0ebc81deda32ec0b55acf4f6012acd686a836702de625b50855f363604aabfbda5743ccc72495c9761547503d10b3e65ac2046fab7e937f6ec8971bb732b7963d7579cb774e6d5bcab0a6831e5e530870c71a08a9ae9f8445206c35b191c2c460587cb6b48626def588def815e076506311c2ea23bb8a74fa808064c08b437600ea8973c398b74b8362e6f8b95be28646bb50fde1500ce505b18d79927c3ceb312ef597e69c7476ebca4fbf6f663bf548e34acf11c509f3abe31f088717b055c95efef9f1a68754643c94abfff63490509126d3ed164df8078103a9f9c439ba6a4bb69df56e6b92a61777070a2b84a0a50e412338c68854f612b0a5527975ae58f31310a3c80587d9b748b063597f177b2b88b2b3dd85a35412f194bd2649bea15259d68b409104137d593feeae46f3cd2b157228f74d3a373a496ed2f471aaf02985546e4d3e0449993c721148aecdac0275fc70fcda0d6ba1c5cf1806086184f231c5068955eb59c7792641d9ae08b81082830c5de2ee44e3ff416912571afe263860ba608df5cc26cc3a00c395da38ea013288e65b9d3006db72a2bc6a661ba6cadda73338f61d0a9eaef40b30a2fc4c4e1feb84815905be1aa8a91744a81b4eedf75c52c54420b874e02b4e1f2523d22425b502f2d87cc17c70818d1d565a18874ae787c23b02c6f578f31eb6a2a884acaaa968d14675993046f3d1e53456eba333a8a39fbf365a65107fc59a5bb0d5040daf64670e337eeb036f8936042f5d71c0cc761c22c6b4fa09017cac6eb7af98fd7c2b645b1a6092e429e3985507319916a745b22e2660cf987daec7bde3538fe1c5868ca75ff31d6e7fadd4101d2aa9446a26f603307834e2a6ff7ccb2802782ba7a52150fdf27e5b98f3bfc31cb719713119cd0da7f4274a15db3ffdd7944e8081e6aa7e418cec3b9297e33b032a8fc9aa34fbb05bc99774a1348675a2fa3b466423a73b76d8516e079013e773dce59a9bc6e445e069e0340f53c389c5922a510f62c2ece0c2dc5800a10f82ef63112a6f666b23359c742dcc0eff01d384d5e550ea543c6a171920da0ba3b416a9ca2975b31c21f9257fb411b59726c313018e8316f3b634dd0f4deaf62dd0ceed1a88ead3f8bd89700b50d96c8ca5464a86541af1962fe10f52015532f6fa4d10a0a4d7b73477a76ecb3897641d3a1e8effeecae25917b51d0bab7ff8e77ead8ffbdb04e0bc75bb88ef0fd94b6428300de7830cc7efb34efdca425b19d413c3c3fe25aa21c22db1ab7ebd717bba7b0cc013a5b735675571247c401d52a74f70e6f0de68a84f68e978e69cf00d201d540495a9f2dd6f32c4dbddee1b5489463cc8f64f88bce26fdace65b9f42ff18349c416333cdb25b583418c2b70e84c979163a07fb50c0bd45bbfd1cd40f43d336408c60f0049271bc80e29089652e68af77504fecbf6ef0df80e378a8374304b7a89e6211e5ffc123251fd11dba54d47192e257bdf5d3c37e22ba86f66dd51d066429a679cedbdb1defb502dedceba1e130e6f976e39e92710bf908194faf9144dfd0fe2ac6d8970c31547387cdfa44e872ac0a6ba0cd4e089b53adc416396561a710685e8df4408a9bc85ce22cd730c29036ee62b300669b148b542b5e51232221e710203959589a3f4d01f699236f1cd9c1a6a9740a782c69ac1734ff8a56efcbf0ee96fee0e357a5899e28c73adedbe22ab2ed2172e7e858c226c2fbbd92cf99d9081d3a3f1ed4ae04e00c167e3a83027de5c086840c4a989af7d15d0f764b4b54e1dbf9217410f475b9a54e24ebd6340968f9f10af9decf32d19b362ca6d5e0287b093cae8db4692a4ec94005cd162846b7ee71521bd85723d1883beb35967d7b527b6d72bdcd68c8dae7faf2e3aa485ff5c21839238cc3df7e508c8d68a4ccfbe19847af62d645ea2d8cede8d0bf7ae01bfce0823b6ddf8c4a901182ac5a62e5763774dc0d99c537a202c01f8d89dd5bc975836ff711882492732e8c65c1b05e30eb5eaa7ca6a7ac77fb95da7aa80b328653f49c6f0b01e96c3507a16d6558a04bab23dba174dab5fc0784c39ceac2a66282aa0a687f22b76d3be62862586bc013fc0e8eb7db81b7ba598d7dbdbd6d786c7acf88e47ae35767c9eded1e71c5c01a594541a37ad31ca4b21800dea57d6777fdbaf5177795c8991f121d4eb49f7ebb52fada23d4c9eee14a161ae4b0a81d0e5b42b6634ecb61026bd455d5510c046bf59c4c91edb4a7e49f4b23e7ad57edf53474f33ee2f3008975ae5c40bba4d99103176a86728ea7c07e1faeebefd4799f004b0c82440557bed22110e31fbcb129d5c791de90149f489daf23b3190847fcdcb65bf9ffdba5a92f9787cfe9e6f30fafaa9c1814346ce824f9c4d892e20870d0574dc94b18650d95b4256720721be60d847be8f0e7d8f0115fb380deffccdc982a6c0c5184fec08559d3542f0c3538ff5aad90857229ffb971051201a2b655265a1c663fc8fcd38d9cfb4383aac7c76b1be9bb7d86e550af1dad427c10e7cf84e2ca262ce6fea77a76206afe4e4b9e4c9c8cc0e8f6b11ec816152bc5b84fe88e5c9051f94332cd01220ead3dc76fb302fee2258f97b9a7af42f00aaa6dedd8814ee73cc65dacd4298566053a2ab22baeccbe4577d7d6adb670e124aaeb8905780b63c6a7c7be86ac18c3607a9f411b602af33640f742707ced75d614b77e07858d6782494610febd0b52e4a3c34eefd2b182cf5e9d03801861a8ba3fb72abd8614f99ad5883790254980ccbaaa8de9f211af0d1f828048806de6ebdebca60523be01aefa387bcb4badc01204c0ec3d417d86f416d8d0396a5c144504337fb4f195bfcc4cddaf4143eae5b9d41819c6e1e13d0e33412f2de0bd4b1e9f6833b6d3d3471628792c0ff92349ebbdf6c28762af253be715b854a81964b2c4037c11d642480b55678c0610420dce091ee86b8baac309b96017677658cba1a1b2f879e1d4516c1005a783d81cbb0cd786496bcdf4fd263a0e6fb8e4c54f5e474d982843e2a51e034a1c19f5e23df35724780751bf82bdd2e780acef07f9bc1ce0e77810c609b54103749b0565918835ccc434a6c128dc98ee707c1aeb9d6536e090a161dc8c225ffa766f25d19160eb6d3e455c7eb7d5ab33588975c74622bef7ec437ac2f178de35b87ffcc7fed497b8d2ca224b8851ce492d133f6abcbbb77d515ed5971b89da0433b155872c23edfe916f4d3217fb9bc2877840233e69c8c93b60ef047e92a77673eaaf0cc773f24231a37622a3fd75c08d42fe6ea56b109bbbeef3a8b61c0cece290cf825ea35bb0807e9e37a770a1c23ea0b34f06b153b1fd97951508c89cd9c2eea5647d474d6f634434f5a32118bd9f5b31eb8380a396e51381171363b971eaff36df0d2e7afc23597c0081e06ea30cb9c9acc16ddf25b82bdf10bc37ec24db551f7d346128e8fed5428c3b43f64c8e5a1b8d8018889c0461afc1b380bc965dfb551588dc4066a394e4717660d2c3592c1938e005dd69fe5f01c1185fe18c0089dbe5cffc7c0aae4354ad4046c2955cb0dd969ac62838da613305b80e9c4514d574ee5ca346676ed01afa8a7d3a0b7245570ff9a7bf03aabe14cb103716e34a324ced1a9956a2e04bf0ee766ec9e50d92aa7535d727dc065e8626ffc26bafdc3a102fd7e0d515777d5c8534c2b6b201e95d6acbc2aa7e8347a7bbd5806eb27c8516eb630705416e4c24b35d458fb887cad2dfa91130e9c82b75f092d647902cb5efc543eb9ff7f8b5b4721041ec11a681d3f5f182bf0232978bf52d858710234ef016e3c17ae2f48eb4cfca6a01fdcf246356f3413218ae2eccee10274898e5c86f789e5e3f8f4fd71b49f4b9598d81067b045b116920892c462639f29409689f4596d5521911c530d5b60d1c6fbf8a3f8d3ff65db33d1f510e3ad869cb711bbb88a39718c83ae289babe4297dd76a0c0d85f5cac481a2623e74331ae4d7a1ecbfa0c5d724cc1c3c09046669f136976f3919e5ce4299bee905271735a90616ddcd135d0592c27f771c8b2dd9eca1733065dec5caa93e2b5608f55ac484e75952c75f1069b36eadbc41cdbc6f8f83545994adbca1eff9db7769d91b4d317f0bbc5be3dae27315bc726aae316f3ed6b60e3084d0961e750dc42c9a3d2e3430a6279b764e07c02fc7682b8ca7ff970517408387b5b92d51e94b931994c97dea52c1628ae06703935e55003e09f0266cb314e0522c9f496c28c60a05c9d28409b1f9c0791bfd7a5382da5c3f18dd22e2f49d1ecf5eef87584e70256ac92a48e6f8d1f2414125175766f947a272b42bf76391abe6857fdeeff231195f9fcc433c43c15eace6e250a9d527371bf6aee2cd6a393c22bd9d5d1317282de6ded2368dc8dc7d09996cc64a8c19ba85354391fd7b19ac18cb3d15ce3c1d1197ae7a969197fb95ca081fa049879e3f32053684047b8723af21d75dd4dda59afca5f562c68c60b76ce70980cc308e4c16ee03b8b05862edc667552f7baaf90d637b295f8a245a28531d257ae8eb40a8a987905e6af0af259dfcc09169f604ce5fb127c7a5f3001aba46ba07304024f57a86dd25cc27843007f8648ead7b25a04d3d20ae551a4a1b8982db1de66ff10c995b00efb3559bcc71845934a0d47870298f6bab8061ded32cb0e64cd243f1b6a76d02efbb965462a3ab38f250961556ae811e49634c3c2b53a5bc326125a0d98aaf5e6124779259330dba150d7da8046835be201a684f0778a8fbb22e02e7df8df3ac058e89f920d7dd395700b40695764e3cecd30a56a9206461a7273c10a5c1bba9c344298e3dc5acdfaf864ecb48bb989757e0aa8a07d02312fafa9731881603bbe658c55a9adfa196ec62b5a3f610e2b32e15bfef4d986f1ef72d49290d3a6e2314d8c2c4b5568937cab31acfcc1a054f666c1bd68908e5b8b72aacecf4bc2dbb9b7a4d0aa8d92c0fbd4d0df9df3b820e410ae199df40cbb273e94f2352a6967799c2507c51578526d252380fa7bf975b4d42f175fb639a8ac1a6d14d9b7dbccfafd7973f91cc9eb3e1d08a753a47e3d0a71513b0bb606bb942cb8bba75d420119ea9bb68c27762aa4c06804e25bac7b6a7d903e2281041a42111a0a85ffdb48c28bf5b55d371a797c1aaacef3bd1a211b0e799a6699c194c3764003aedd535b63befa95ad6bb51aafe1833597286a6ea4cb394043a146f531278fb2c4e9678fcc5727db6b958014ebb5747cf6f7ad964244ff5633e5b518f9ed3ddcaf5a4098aedeb5eca140af928b4ed46badeb3ac95c297ab0ec24799d263449841ace850dcb2955cc7a450549bc57ac575ceab352afd4c35cc46baba29efbb5846efa19fee79ea930c4c19783afde2f4d6a9d46ac4a3da0765349c3f697605d2e6ef3dc4edbea3d34358ae2534d2600e03a5957e9c05dfb7aa2caa37649ab182b31032f0dd000fa659f8b8d204663773aaed44355b5386b4be5cb100df08829164a607c7598f74bf4886daf49d3e5dad48ae09ce19446a1a9d3fec3d9b94b3a1f3ab1ebebf7c48261f61cf2378caecb090313175476a49b8d125fa2a4525d8b2ca73aa63bc400ae8f2bdf55cb076018081c6d1baa427eb9488fa1c65d1ee6075a38d3e5b714bdf7a1c8793eaba8b8cdd2c0b8b1705812a2ee7f38ff70689af5b1d399080f035784cba81957f3a11adac7d2aede35ca51121b43af99edb63fe9d9401091be9abab0ccfb7f129e3a86c9cf0b09471a64fdb126fcebcb777e912209b78d28ac7cdc08ecd2e4f1573c0dcef762e06f3878908b99307b7f8466325184a0e938ae1fce4d1a64bb6901117411e32cc95de85169f61316df475287fd99d97b82faee40d7cc2a2a4778c98c8778e3bc86b30c8f8a15a0b4a8d778c017d5a3087f89d89ea7292f9037fa6d51c70b65a3180b7244a8e10335cf5dc5bd477af61115d4ae99517d68b29b5f5da254514770c9c07eedde0e67f0d08a2938ecdcc5459e92a18a7342fd0fe519478b7013c19f32b9091adfdfefb53ac47d1d468c48b23bfc3dd91b6db1686bd413154dbc8281f4ba982d28b3c44655289684ac44a643a9db85b86b573f87e0ff93fd3a52ae7db37c965118ddb8a2de8f5bf93817164dc13f836c5854efeb559fcabc1b11acc8a9aae402259c33bc237752b284e53e8234c811072bc63ff1b7430882a17de0256083fc26f81d97cf07878a104e13a94736520cc9073c9562e64b142f7f2234af33087e20b04fd6710f041f983a1fd6994472dfd18ed56f732cd7aa68e16a21579ec41faeec0838dde92b083dc00e5e5d5b70592bce04a61d3025540fc98fc22fd139f228147d33080039b878c7b0b960833eb03995618b78f11b34ce856e89eca30cece3ee73b524d7f533b8d47284b6e9db87ee1fe16f1226b5a50576e1a5c83ee0684ffcd7f870ad7314f2f4e13693199b1223a032ed2ace75bac7f0f65a0a3da23d5af806e69a2d1a7aac349fece7675a0155847f9da83a38c62f96376a87528b551b2adec48b6523badf45ac3b4af1d74039f69d831660a5f189cde7e1b262dd3933833891f8e260de268c0cf1d211bab0b95b607165e33a14ee1d9e743007e6012242968c525d4e97b0a533ccc906a1e7f7dc8284235ce4404aba237b1e879756cea26fc83bf294ff6b92025eb69b9e01e9c0ec4df6200272c7567d907b15a9c1450be6a0b595f73f34f74261ea78834d13e3092dcd43a58ade66304b3a046da4a3c8c2c9c0ae41dc264c39382659ea47d22d4b68ef213b606188f75a6d98d9e250624c61fad801589bc3c152d737b9d4fbcd3b01906ce240f74f72d696066fa4214b13b56f0364763900e16ae1948ee0e2df89af19272488c44f98163d978bf59b96d9a075807d806a97f9a42a907063d00a21b4f14a3567136bc9128a8d85b651b7c817ce2abc84b61791733dff3a9e179bbba0149b44b916d1b8a5bb4c40fcb1174601a03ca45e34caefd18c12b98b11f8ba0a58edc89f82d14f687f2b4e911a79140c5322aae6f52eb88564f5a1ae504faa5d07fea67b26f72ef353b60e3452af508aee22da6fb2821976e7a98dc00a6666c088fe7ab43b2e67b28bb19101cd9969c1861f7631bcd83443721910f31017826db9fbbd4ff8e6b0098c3719b0a582b5da6e2bf2a81596a8148c49ce5b6774f88ccdc71146d8747b8a6959eb51ff2ec6e134c51342947ea5d3f21625379050b83163e5721076e41f8220c6a5bbf68084dfe20e6451ea7986dbbb0a34259642ba5d9eafc79200ee06f9ca23610b381cb329ee71674341b3fcde898ef09bf343f40fbe680c43352b94ba7c061f102852fbfc92ca0de4f8720d938bbe1e1d7cdd5130be51d5208c3e6021984e06ed331479343fec2505a5cf2db00933d27eb61fab833b12f55b7ce243f089b3233cef9112a1b418714fd301b84df064493aa44a1887ad5ac0e52951aad61b7c5a43e4b35cc6fd346c0e3165bc105a4250a93a081cc9ae1b715be69314c91788f68e3b6d4b93c5942542e4ec5d901107f0aa3df6128a4fe028dc34f975e5ca8e34c6e6da662722a9cdbb215c3fca90a56f4287034fcb5230976d7acc27cd0db805cc3e26993a946bb49c92b373f3ea2c3e8650d646f04bec3ffce958133dda3122504b7382db0950b4013adc5698f9b4d8f65db3cb331f474e0a37b3151a7161cdf8ef33fbb2c4cd93a116084fa4c8bb29a19dfe37762fa25b672b7d41396593e5f79a91748de97d845f120d2122ab4f4b6fc41fb01c3798065969598d660b412a27556ee06bf010dbf92cad170f232d13a386b4d6dded1e0c149642b71ac5edf102100ee30dc02259be926f901da3f1f432ce722d1cc4da062c52983d8ef8b099da7472862494aeafc93ecd9fee9ee0cf65745aa7556e6d6896ecff255a25d998e232658975be13e8ac33da7e21ccc3f25011d5c21a66fa0bb26462b0364707eb892bc78f7ecab017ee4ceb3ed3c406fb14c97eff06974a54086c84d986aa9b1bb7a94a2efb3fad7459238d3d020b972cea772c0fb1b3340cf3f60fb077bb09db3f3f878bcc4b85391def125f48fe82a52525bbe600e1793ffbb1568533bad03d15acb6ddb621fd06cb013eba0942fa625cff36e99d47507445aded7629fcd311faedc0fcba1386f1cf9d4563b0a651884c1ac9544a31a4f2d1011b3a806ac3b738b322284dfd5b0bf6892064f371eb3b206ec6a4c8286ca10e90437e0080b11811d50966b7b0828b9fbe4dd4150a032fbd86301d9a345f9280715d2f7300293c2f6e512ecdbe032088fdb3cfe6c8d14a1e50956ba30b3fd5b5d9cdc0c2c5c79d3ac30da567b82f3d7010f601c9f14f46a306afb8936a4cb64706d6cb73999684e5329ab5efc7c4bf14a18599c8985af53b6770699332bad8a4756364ce3381bfdb3f46e1f439441a90cca6995e041404032ff6fe8538837d895805ad74314003e68337cdc1fa37d83a70f0d41fc63cb0ff963e7c5125d8514be483a2cc6ff6550107f9a97184327bd64abbc869c806d2a0b7df0f6818434cbaa747a7c795745c577a538c31f893ba6a827119debadaec2784d13126c13e949571c59db71582d6913399b55db47d377b675bdc198fb50c4e2de5842ba8f807f10b9d3e00c300df916316965e6000275543b15c5954c58dd95c70618bed19feaca27157df08b2655e60ffd5a51ac3df25e529df18283e2e7fb41ff7bf6864c134da5fcdd478861b38fdeacf0f2acdfde129c93468346af7bd0b74bb51a736bbfce91d5d54ed037dc27566da43ee776421348da5ec7280980a76ddd83c73bbca308cc250fe590635f3d373216d21f80fd4c100af19a6d9d5cb1c0648a9f0e3c0c6f889c5191033dffe7674a8a5292eeb7314aa5a9b989e624008daab620714de8137a7ccebd94be0f6fa5b6e363734ce4327e942c2f715db259a436a711ea0ab33e60be02ad161828235b2a4c1822633fc5e3eb19c637bcff936dac65eb2f0edeeef5e40b089200edebafb8ac753aa0600db68daacb088aaaf0fcb350c56c53f1edb67453fa86bdcc8e95857fe7c46f19dd7bff8d2fd135691e6406e05860e55fdbc25bb6847884684fbc936709d9813c40fe3de5151480cf692e8123a0240bd622a6cb67cd8ef5b4df7a6835d67c9f770f8e2a1f02ac0f83381535a3684efc0d32dd5ab7c3a58f756ac1ee2a0dc3122450dfb783752f57020ee82a7cb5aef41186f8fe08279553c6ed3e3a56d5a0b4a0c46ee183f3190da14cc4d34ae9a0dc01e5d133242465cb002e29c30e9e85dcec66a27a94daf3a6507974f8f8c04f273abd442c59f5eef04b689a536d7d4fa26ac9b21f3c0e40c59f33d08c63eb1282d89f191a33d7bae2486cc142a581b1247cdb578f45678301b96207a2d406d11da75fe9aecccbf4c19156bdf759f6721fbb5d92156d8d26134ff882d31c8c92192c7bab59d76f55ac722e6f44df1b038a70d195cac111c8f856405a9361ea3b10813c94a736177566dbd8d65a9cbd3349b105a3b2475516760c9f09ba29097eedd46c44745c4bf5cad3191cd1625d9ff75740c577e1db1da976e03bc6e9d1f580808a96289208e0a4081b5b981464d15b2a6b40f343a2ceb1d9dc651fcc298b766c02015a47fc0fc64b62c19bf499b0d104a971f9621a200e742047a5478fe4b5f21353037bbad14e01b962ad8e5285ef597a9b040b8673e5167d3ff500e272781b47120570cfa4f9ce267dc6ee2801c6e96d54618d1d2fc72e19f2c1d7e6b029bc4ebbfceefa08e2b9b5dd8e92a414e422035b318d886b1bac40bbc1e00a2dadea8c60239eb16b6d88133dda7902d910b9ba1b2c30bfeff9c7536d99828436d77de13795731fa35e551df08c46a454f0647e7c96fcd2a838f6cc7c255e1c7cd932e16e8ce45e1680acceb0b5cee7188125fbea70026c361db3309749c3357d31b7758b0136924b6adba3650ab4094f2fe5594da7eee79f57be6d01ca9e6a7f4b926c27639d7cf043aa7837b8182611777a49da2e6a8dfa946abf18b23610c6577be31137444fcee881a351b537dd075be2f1eb853476d189ccf4e45fc73e8dfffa11371946817d165ba281f78691367eb0d5756a95acd589c9d6118fc3eb97a2b9d54957b1378162339957b0b98d4c6be5643b35878874e975f0eef4f1e1cd4763249f3a7df56889c4a870c32e8d149b3e1325d896be1bd7106408dd7f7bdffc3c0164d9774de6ee3584366bb6a52d3d786c817fdf2b7a8c1593eaa525351ee319380af2a39334884d527dcb212df2c78caaf96a06b79e40e01c7e662339341f8db6f9589516ca15871dc001c879254869f8b6cd944d6e49612a1dd59c4c1b0f632a00854adb781878ab612f1755ec15bf91f289f7fc678b3ab5e14cffdf5ee8c303df15466a5159be4c7dc5a541cc240ff3277e4b704cca0a0a9300a116f38ebf7b7eef640ab0446051722330458220168208e1078ec245904b4289d8e46f1c5fa7a76014425f3db552d35a91f075b87c8c05b406efe97b11a1a3350efde9e835b161082cfbac2f05f12eccd700c0c68585b41903d8aa2907f3ec4db2ce489c448e110a23ab7e2e3a9b055b78e086f17ab693f1a4da9d5150999b3b13a2fa7d5fc1165f7a01b9f36ee13fef34e2f28d94d65677e1779d1f36a634d681f2db17013380b040a6f7fa2d13294d6809ecf63e040f8b92ef543084387830ca3afe9259309fbf8345ebcde8394adaec6ea6b33fb33c7fc1bf77ecf9fa7224e6c6feaa0eb5e029f587093680df61933833f6c41ed04fb4fca0b26effb72a0c858ca65086e0010b985a8d87ebe18345bc5d2efb30e1f543e3fb0ff375035a9fa1bf6e6d15296c991d55fd75387a2806b2c7ed83c0fcaea18da3b6442e227e395cdf780f5eea8c4ff4b4c548919441b927aa4145e9e76ddfcbc220f703f7ae7f00861199a8b99fb00f2977c2726fe0a96dd52796a51318be99c514680e79694a83a13734935580993edee267fbc92d216b0eeed0cb8e86c8c01aca27bbcf145e309743de0eb2ab440ae5122b35c541ef3aa6c0b1d5e2840a848f605c6a79e10c6ce687a906ef4c9282e174b4879c9dd1e26736a2631acf3d8bb0d12b207abc58b83cb8146a4b4a6af77c594ec790c0f0486eb0d2d0918cf5436263a5f6369cfb08e5080a73d7cdf3b71dca01861f3a8d15b727508236fa0a991e64c24378e54ebe0b76d45cd8bbcbe6aee9836932a172babc33bff6d1b62ee55e3406067f19dde328dcba65181f1228ff32a13acf8a432159ead35b73f5732a2bad1cffba1169330331880d75b24306","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
