<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"503dab71503933fa4cab66263f903a92fb662c6ed42fccd802fe3e5776f85cbcdcb2aeaf1e5c08112b40202927abb86125d2f4f4755469835dc46dabf8471df0151afbf39abb1a5164e283c2b67d4b1612fa63b8a1c7ce7e248a74d8a32f8c93d793633bdf4800670900b98a1a385419be8963a1bdd095229d168f18e7983012192aa01127d18e97821d569d07914c677c85ff884647abea3236b4ef45f5092172ff21a91ecbe3398001b89aef683226c4f2144e4d0f2591b9de9612ed6573cb35c8c521eceadbd70ef0cbabd2a5c826914cdcfe97d4cdad3d669dd17477f1f459fc46b097beb0fa39a0ff73cf93c63f61100c91243db7a05ef7c4ef2d754c8fed7d993520b5c81913e2f5703b02fa95d094827081a9b4b17be56c06a8ec53a9d33ca47bc115ae3d73c23c7578ec3745d173e6720359a1307388d6911cf0f06d72386ade590f2127ac9fdc6a02edd11c639409599c24d9fcc24d99f2686c0db7ffa7b5f0db323795e8d7af45e47323902278f1bebf69a399e72861a37a59a8d2b1cc722b0e8e04caed88bb68bafec27aef5b9e6e680b2c20e62e5fa256d51bf4f0d7dbd2d4e38942ab544c809d426feaaa6d0d3fb0932af4ac5f7ccc5abac86f5e61590db81c3c4bc65d0357ef80d9e7812d6bba6bece42efeb07e066bb7d116bf9d43f69b8d6ce3dabc32d8aa48f078d72d934ccd2b659a1b4f56978e6e07340501a0c6fa315555621f2e1b31f5615d7016604b112be5ce505d548701fc5ecaf018f4106912b5495ca5cab578c0e20ae81bda5faab19e63efedb2f66f8ef7e1dca68a7f5d10a2b1fcfea09c1ec8264cc6a888b08cc8d19a6572b938ea67b5dd3920299c02ce774257f2acea937a23aceadaba8c91469c1877993b612a5a6fa5eab2c285940badf77f858a6550bb9bd2f39206c295c4aec966d22896ccc2a946544d68a3a0068ed29141e163c12fd079f7fc5db4ad4caa64e2eda0086f8689d5e4efcaf3d2dd55894f421f3ec7ceab7cae3e2063b9468888dd6bce5d5eacdf8ad299fa8af4c6aec930934ca9cadb66e9a9783658987d3822240a7d6497987c593d9cac4f3693d8c1f1ac586e7cd722f7245e440306c8cf5850cfa14a430571802373a961edd27c8d05c10f60b66647c950657735664bfb0181ee0663a687eebd01ee8d2f8b74afb56a805e8032937ca680cdf74fd32375a28ce1b4fb4dc93d8395c7a5d6c974238512e5b758d4e62175f55a8a4bb4e464d4a040d1be746dc38f3bd518c0a915e2ed4e18a180c071d06a14a43adf346017b331c7d35c3abc276843e77c5a5ed2797139022571399d5f5d3e49ea8b76d492a622a2726552ec5973effb464bc0247540b20fee3d2e5f278d7f2bb9bf4b592245c1aa081136df43fb333b6c885e67126154c72c2fe4a46fa957912ef18607b78d239fbd04bd51bd10ade0a5e468036ccb2b589a7cdf6774178f7defa4a2920160be4c1cf20515b48db8b66b5e89443b213f46a6572baa0843041d1140ea7c47b0374d65b03d7e356876bbd6247879c887f89a6618981c568c17f0f618f85fe07609b82889fc49476654fffee242951ef4398b9d8d946d0d2b39a00e3201650c9b4fa55057b655c534658b63b7dd45b6af49255e2fe867ec1687b8b38916703e102277a2919d2bc975b6b917a1a56446e1515d8a0a5b4cae4364090bd4f4884e7c0e0197758842110132a988b4c819afe461dca7879aa3e9d2f8d910e25275d69f6927509932a3a09ef8173d957e4d005d2caae775fa8db17b70be37054e34bbe0b406293172819c18f9140f803a9b6604f957aa09f184485da6ed1ddefbac39b5d7b788b1efd38dbef6a9ad5f328751d6c230ff81109567c5a0eb4662cb5c954c99d057240922651d322fd8fec2bf9793121fb80522ac8fb00feaa09be7554ac400cb5739d9d2ecf8d58f974a9c933b002dcba2548a192e329604e9659a2d9503d3a116c48c3b16e16af280994f35ce888b9a7038c412c5bfa96018e5b309c853934ef87c5559bf0e2ea2af73e695b5c1eefac7242349069d0968ca96066df9c971d0a9065bb3b5f908d0880102852fcec50b9a79e2db9668c0e01adbdc5457218cb4e5408de88860e8294b9bd0246d34f94b214231ed268c7355ece88bd6674853be5a4b7ccc9410e1bc513f1399e37132530d20787e5066b9274199b72297045db363f120b0f1e51ce606013e8a5f8c58f92b26f77e6934fde45baacb26142e1c00e2b5afe10f987f11ae1dce21f5407fc732c5d67f755e857361e7e355f21bd139b92e37debbeb2d5ace8ea074bcb3ae6d9dfc30d8a9bf54ea690ebc8bf76ea1745ed6e607261eb90d0961f0f7a26a4c6221752a1b473d0b82a791ed029680e6f693a9704b5eb15b97be22aa8733881e4ce1ed92d5bb57b770a035b8882a6a4ca8c7a3bd15a3db9f460f5a4a14c2c06acdea161d945a80a7ff792f1e10dfc72a607547cf4be48cae5d133d02687c3b5ad90668256b335f1505586dc1abe50e6bd22abf08333571c62054c7183ec780644f1be87cf0b854c84488085c1425854dfb7cca767ae376a77bd1d8c1d95f3ae33e5665df346932f9ec87c542dea5d18e27ed96bc8ebc1a8a43490b6e8c09c6cc3a822c27fb4f2e7bfd82fb9a94d7ff9772417c38a8f5363aab3886bc4c0a91318e8c1fb530ae35fac48045626aa1fd615250b118f4b213c9f0684623f4808fbe7b0c4ad5aec4ae8594d3a0065aef9c9c0d9892b4884e77220b221e43fcdcb72da0f963e0166680303bd0c413bb0e6bc26bca7e66d5775b98aed2d99780795e6201d90bc9aca2d941dbd446a68960c3023cf112936107de6524912f4a31b963b4681482705c15d06103d6758108d2e8174558a45da1be965bd7329178f1e8b6acb4cf4f1c654cc0c743f007434ddfa39d65b24f9bd8002f947c82e62ceaac00622e6451c2a34370c6a5ae98f2376d8b075def6b9229c8a32876e2df4773f7cc958bddad33b0aac4b43ad413774da429b0ebbeeb961c249eb53c1ae6cfe76f24c59609410a933e7afcfa34d43756574c384d4c4c3a977ec781aca62c2503c3d7e6d1752e5e5d00b80f91cabf485611306121b0c29b88c18325547198affeb70b4ecb9bd73297b96845bdf19b1ae23ffb5c23e4da7724d5df8251e2ce49e68aee99d70279f8eb080cbb6d140d91fc168c70aac652cb7936679bc0187f0a622540070e2206aa5c9995386e4a86ae7f0e5425433b475c37a3625a327a5665e900dce571f83f32e5a4e3a8a480fc59b5d80e376bc5888981f20a84c4bec54254d4274f084f4422616a0c7322415cbf11f5ed1600ffdc04cca952ec1efbb2c2d10150d60786c8c9b3f27e6cde6480b1cde5f7b4d75098953e02f98faa624b4f6aab314bdbab5fed5624d568479f0fd16b29b48ba9648842eff77325dff809e2b9bea35b4d1c35f11b6b56444d5db45c69d45683a5fa5d470358945aa693eac529089dd5488635eacf55d235c06b99ab4d4ad40e8f1f71c163eff2c6cbb9ab4743714cdf00c4a0fbbfac0a65ac1417b52fafe4cd1486946e3d1534e044698579b866f34714c95c7e53137b1ec725178db2cba4f0219cfee11a5d29ea4d97fb8314ec8385921453de43a2cb2ee5d1f3b3370ce53b92c8582af2f0cb7f58e59e0ec64ad7f4561a63701391deed03f7a90c420d53977185e891902b576e4d7f634a3f6c471971ead39e7378c903ffe44933f3179e9df14075adc2025ee2a5a0e479f8b8e1128fa652e9eb7bf2500e90ce6a8f695f05db0b9858505068ae378da76228ebe76c009cb30e89b7ea0924afe973b1b54f04dff7c7fd799face5e03102ba506eb0b4f28bfb9c7aeae7f645b9eacf4a09123b3d7a23c25fdbe5fddc0fb8722fa3425d4aa0d4a8171b1d1a487dbeefcf7f906cfb6ed85cb2198f8fc4d3cfeb8145086e450dd37e1ad9039d4d1b6c146602bf4ca6a8b4dcd6f7a0c915f047d21aded259b6f6d5079287f1f370c3f1f10d18c1261d43bd470c222568097a73fff1c3f684b608eb5a86aee2ddcab936176d50cddbad3241f2e4bef260340952b41fbd8d7b95a4f09b19a58bd651962094edf0ad64bd2790f393a66c183e917cd0a2a3259179e5d73bb8fea7f1edbdd0ddf240cd726dfdf556e926ba2edc6c9452ffe50f38635e638dee2e4744d5ba37b30cb23cd3e9ca652239062ac8197fa293c68602cb5a39c94837c06c6545bf731db7a7f86224d4296a2592790acd5c1bac71537fc441e458b620d4f17ead2224fd80f109b8e5b03b69b85983002825bf70c68d0c2da47cc565df308611a7210c188c96ad26d22d050e244242cbdad6e452bdcc3691d94d0da05671e4ce3ecf86171aacbd7f1f2ae142345a858ae98619eb92aeff80846d8f5b99dabea1fb9ac19884915b2b8161e99172eb52860afaec98ac5b67ab162df46024e0576e0c884b37774523e417e9cbbcbd394727afbd7fd937ac1fda8170a8ddc83dbf3a1d4a3a53e1a98502fbd8d86f51edb03880cc8f8e16d949b9b08bf2bffa0f259d651fc06956917f9e22047c9afeef6acca4ffc21fdee75b95003f05009679268a244179dfbea723be87f6a97075997488030aeb9547db2557503c7f05356ce783a3a6842a0da04e111e621a37ede6e97916a9ed833beac706234c4acc7df6fd66a9ebb80b52a33a69b70eaf288c3fd432c2f72539c8cdbef9e463d4258910038f49c9801d863756f60a1ba87b0703c0909490a54894c76b451dc1b860efb1c2faf4336448675ae6afa502aa6ec6cf7928a99c9ee720589169c413282966d38a602ccc34c877c65bd8e4368ec443baaa126fc6af9dd6296b6851a230e96fc6b4a9534af8fc80e62e15221387653f70bee91e6ffc4ff2b192b43cf333fefa4a1bfbba02de30b05259756fa4059638e8f2834c4b17b440d6b8a76b7942b94163001282d84502b070d08c1aad1ed1a7f007f4eedab772e9544bd79c04a1bf06a6db46c1c1c7c15fa6439cf11fd595d89bbcd376d629db0d4dcf4328d9a4abed83b835b431d8d24b53e0d137eb981b18864d5db0e801d1d081f23b791b3823587d78a1315655fea10870364fb89989f2f87e957ddfc9e6f4126b4ecc828fa9c4c9cda697ea79c241a8ea53f777a2df38ec6d799a843ecec3ca9bbd13a3b039fa204eff6e14ad95729899d75572d4db1cfb816cb212e020d818a62bd5ef30a85e6ddc7c645c7a60fddd09f7d44c9b6403bee8a3b1abb4f7677fe48f07b664f32e4b0618f53e10960e565fb6fbc511123d8716304e0dbaf3c0b096d01773a9a3eb1fce706dfd61c4537394b4e804968fcdc8a43aff2b08f3a18f21fdc00b83dadbedac61c734f203ab76d39d7d4a751f2cccbca84e16d485d4fc5dc7d2092421d5a23912351ff59f395bf37119af87910862f356cdb5367981f7c018678cf4c49ee0daffb4f0986a50e0627e1438561bf74ae9c5a60f478f5d86576a3c9dcd1855697e0400a255331c05a4ca4f3ae75fc46ceba50a278ed0a60aaddb723c3f967c9c82066d1856d4297ea5213c6709bc225b651d8b1b0de6b48f96203d544e2f6871a7fa3f67601981bda0b638cff48c8b361b3aac48894a5097b191ff1920f27c55bbcdf91d52c19cf601edafe20364bae2935249c877cb64e851c6fbbfbe36695c0ef0df09fe741dbf24767e3a85946d2715fe10fcd2313d04ee92fa3bb70fcff902c1c290fe0c84d9fc3633e031d7a2db3d5a7a693bfeaddc229a84c0994b1ecc009871e0331283805556973686e52cbef63812461000209d65716fb6311822a3ee85dbbb372b106f386bd64fb29743787a61570fc63abd76f86856862886ec9e2309596197045ec11016f415c177130b4410e97fa745b8b7efd08913ec3ea45457771aab5ac85378783f1c9be4747a31442133ef4504536d0f18637fedec6ab5b380f0f0d29df7571b069c4c189c9cee8c948636787e73b5707ff391196df5dfaee2dbecbaec916a04759a3a64023dddfb4de9be944ef8d4fce4fd75a2aa5e712e3a297404ce228545fef92d8592ce27564533209f8c2660ae3e7bbf58f48c868066fb174736ae7d66340285c3e578392b0e62ceab217ed0590a368b8ca29ce2059a996485ed1eb5324824639c9e07b66f6a2f4548562e28a694726490236a3d05dbb0647b2cdfde7b9b2890cedd2c5b58b03f7d792086abfa409186dd306295ac0997badcf1977da566fcb033ccd5fa1cdd5b61ee7007c545d004dd020723a380b06a91e3e7aa879750c001a7691b0f74e25f48d46e5f6c55ccb5a4049dc56e1ab9d779beb3ec3610a59557c488687dd50fe4a5d9bd166d1ffb232f14039235342903373240f55b1c1683f9f82e878d3c852b2b88c9eb3b55f87c369693165d1d21d88d17726df0a4a1b4b17f6cab4ae0d712f994031c8b900a633b632b073c78033b7bf038718092b41e471650fa8fe76908aa5d26f07ab082963dee13ce261e4822f7d19b5ff9916db8100f3041e804ee30438bd852c825fe93bb4baf9cc29ce4fd011a6bd65cdc505cc06a14465ec87cd046f13420ae9c415b6d3637d1bd98adc22c60c2e1b0bbb7ad13d57b790397444b8742cefa03ca60623162fef8b3fa9d8b31fcd934d037bb26e2e95fd9812b83703a408b1d1f302e8c7c66f74b74a4de83586057a89aa40bba91b9357a41c753a293914832923b999f6e411be79b771c50718caaa2418adce3e1c1fca19f22da755b8eb841c7401fa43c31affa69757015bdf94ae14ccea6197b7c246df97a1468945c377cbb09cdb06a131ed0697ae002a944a4cbc7365fe21a1143949594dde6a0b9b433ef4b67ab79f100f7dc6aa7ba9c3d66ca0813432550eb921b89c2c8b36bc2fa47dd7af7f6a43bead39bba0021f9502220ccc75abad58524abac15fe6d3f9af2ba66a0cd04e6a8d3585c5342fd22204cf858a4799e1dd76fd90e9f49b9e1e1ae36c815eac195a9f83b2869b342a86c550000563758717e66f83dd0c1874b10c1ddb84925ccdc15aef693b084d6ab627a82f25639c909c1a6ff0886916607e6d951e40af5439c9e210eb1121be158bf7f7795e476d36f9adf9c75c9e9ea67497693f9aafa887d8753c2e9e4c3880c10f6056ab2161f049233cce6f1b8be9a2040d9f5277758b4e7dd8a13d4556e2396935184fc34ebb1f0c24b48bec2a8b7f4cf3e468f2e0b61681f463649f3503c4a8eb9139b803049a89423c53ed45eb0eeecd23e47bc219cf4b309850bb52f9c0256f59eda3706be292dcfba3d92b43bd48458e26ad18034d33ecb1c120a9acb193f5222b9c19d1bbf7e4d678efa36e15e312e445e382efa98272f60b9608b2cc3c7044b8e3c56e07185f5d14bef6e81a2730d51f1e5076ee946f1c608a5372f57049397d8a743c91436157af271aa6d5295e14352d4d26f967d3624c955a8fb733b915b5fc92dfa8a7f0be3cf7338388bd15085aff49d292ed9b5e771b9a749b7aed08a32d89a55c88626c963e090657f2fa768362a8dee70619155542f73fcc00b7561f493a9a68ef21d57c916a99890c5c26d03c7e231fbd532db35dfa065dffd97fc46fb7e5b08eb440d7a17e3a7cc7401c101feba4aa8d35c26606eef1b0871b2d8ebd88092b2806e5e822d3f0e71461397d46e0620cbc1c60d8160ab638f03546f18daad466c062d50ddc1d84a89a882e432e01c752383c1deaab2e67f1ee89207e7239587d8904f6993f94ac3bf06c991759414447d89f6406b94100db0500fd0bb91c3428df19e21004943103c088106ff859d0db7b1f1560dfe289511983c31071a2c485c128a46cb8297f73a6a066e87bae9a1452e080353c696575a62a91932893761835a7c5b541cdf73c6792aec93e8d55129a16c0d64220e75748c500a2a946e959e02a0516ece3a445322e51986c693f21c119f08e536c16a52be4e9ec4eb52f8df5248e36a573273a02a1cc6a9088cbaa0086a4215f5b941525a865b358476fb524f47bbc6f8a25f97560c774354fb66df77e1f23fcad335b9471c783fe351588d749ee08d1e48ab454d5e6902b20abc3ddbad4d5786fe9d0b061a0157356fb90faa4a1737b3256513d6441cc2831b6322d981418ab5ffeedb5fe6b0ec323be31923e52d91f9803932d3de7da28b2c12cbe15f815b98c4311877cd7e0b696db33fe37c078bb9e9b2236673d3ea01db86dc0e7682fcbf6e620e4dbf86a985a47c6d430c018a217e2c67a3e75df19e273a65cf12a535da880475f110155c6d7e55f231d0b089a63eaed0d5a0bcf1f9c2f80a56d35b546b058def7b8a28f901e4b18a59d86915d700510964e462f7aa136a25fb1db561dd193e76c77bfad1399a165d8f51cd196498ecebe59c38ee456ee5b4b83fb2f55857ae3589c233990ed77402e62950483a0bc5343acf0afccc1d78faa55b5abf3fd30e80e91e0926c86af0801ecb25ef04e1482624b01fb3ad95dbe65288e8036b7cb1bf1e5b11dd253a1d3033957c51fa5c71f812873c05b87b001554be9689861423d09bed6bcf9ddf870bb47c3ccdc81808989a0d80e07984066292a47b47e595ef76f9eb77f6003ea609b504a154df3296e6b5a3e1a65177bfae46fc74bd51e87d2a8460728ac541e35177a9601e93935d532395342f4908aaa368bf6a87b1d47ee9ef655cb5488083d4de74a2849c530275dd30f6f0fe15973a811739f5ff0293b7fe471c62ae4b4e64a14262cfc097b57e08504940108df3a5a1527d1b513a14f0bd14eb08de1cb78f00cf221b1b6c0ebd06013c4190d45e1a6fd1300e9357539238341f3c234372282017c5b8267bfcc03326c477061eb6d7acb0cc3a5bdb517c221848904d766c27ce51374aa0753d55b635a0441a043340dd6729c58b920f8551ca271b7e5506ff55f13343f0d07ca8220edd4ef0db5d5381341e8f7c6e9c22aef926325bf7e0e14a1619aace9c10b7f577cdd492cad19f3b792fb0ffa8e734de2b0a324c682a6225463b3626a36addfc1f20fd231e32fc4a6aa31beb80857f4360e2bf0371140fa42c65a088be81ac6e8ba39fd825a9b252b49066643cc7f018f59fdf3d709a782050fbb1ecb05dd34d990f1f9c2f4a4825ee6cca5fe4b9f210036ed04b3b338f5e4bab9438688195dc7ce32d4dcafc98ea9efcd51f0ed686085d2577c627eba8cae80716e7b7ba250fe5dda887aa699abb6114432f0dbf764e2b5787c57f8b2134f1f8fa1e513683ed6c83e5ea077f9460a091090413a326fa65aa91a9cfa8f6213bf93214a688f503771b72f38621795b8ae542120b56f9494c4b0e3997e366ba1cd03b488cd4e357bdeb5f2643d61333830015657de770130234bea3c74e5064d30e4f0ea9d247fc63850b2fd1b780d71062726d6b4556c5984b28dd63e7a21d6d7737d90c927cb1f3e78e5e31e7449ab9a7c31a38840c0004b570a05e6cfd7e443279413f2ff8178d448d7733e6e823f82ef55db8d7d17d000acc36bd512f607df9dc8061f620e7a6a304c8917ac5cc329ea35bea110c61bc3c472c243a271b1731828418e585c3fa420d0c404dc049c78d765e3e3e9c238a185403ecdba86bdd9ff29e628eb011fd81d4e232cce22de4948ed0feb7e4e59e03c10de8d884408ddb8500388d01b746968f629d1fcf7bd1ece09bba302c19ad41c3b619d60e0790f0f83df0e53a0e73915c35ed5607ffaebec3651ea0f7f5156c609ac09dd5142cff1b18752de4718eb43d07e2cfadd2f64be545bd96dc3a093916ea7e0f99857112e53a2e9b35b0bf3ad6ca0199beefaf5c6e4a7fc5bbfbda1e010f82a67411c412804f0c2198669a64241a0b4e963c615d65e71c7532783a7ab226f3e9c9a4d4d99c975c760947562ce52fea026ba6f6a4b2e1b0f2dd15cb678c338ce04ba82100c64e27e01828391153dcfcb26820c0ffdeaa8446d4c92cb3b31e4d702b69ebb144a38985d2a052372e1b61a8a2aa9f9a2e92456da570c5616ea096e14640ece8901beb0c4c14e9be5cb1a0b28f457aa70d0ebce50a6f610f8928b7518939da8d8fe4ca4736d86f4b073b5c8abd9608ce5c5f43b2a50c63ced4e1a440cb82bf7063f40cb664931bac8b3275c6f71af8d14abb5278524d249868b16986012c530c0ed094eb5ed0a15d845c6183db8ebcf5119d32de9b5e8a0c9c4ef65b2e5a79ecf185ab487924f3966aa13c42a911d4f425a837169e70dca025c2258b2c9320e8595aec864c5b1bb0185b730b889eda8d61805be0f45d3ebbaa7be615175e68d458c2f2bf1d00a8c976888c5d815d3b03da70630888ef40093908b134f2430a6084e8f5926eec008cc7d7b3c4654112c8dad5764ff4c324ebbf779941f710b7a02e3e3c141701ef7d54cef746da395cdb73d4ca5c842e32d2e4bc1ac5375d6f5de93f0de7ea7976ad17c7173286121f835870eabbabc31afad4d0dab7d93299b53d9b290976800f80d7bf2444b8d5190922d3af6b177667f3665e0607b1571c97b3cbde75d3e4af3f849ec4836531b51aae9a3a21b717ea58077d9ec42d5325fba4e00cb0e705ff7e3c2e44886928c3dadebd7c8fe03eb5d323d96a51c56a86cf8adf5048e03302ab2517d6b6c2ee50b12d0a6ff77759902a4117f690de6624a97b91c40dce46ba68026b3bd2fb49bb53c5ed68d452f63640b0ce80b15921620d63fd85bbaaf5b00a6349ad0a5302bf25228b05a4388d716a6928fa033df3f06e6a330b91cd956cd0f55da281951d087fbaa421b3f117214948fda5c978ff81772d0fd7afe1eb21a100be82f13869c7558738337be30a208868c9c75c35fefdd625b4d27c09237c0247fc4a8005422042bc6f0de86b5d8b2d7d29e5849c4c9b57b94df1be8710c8a5d9c0bb69e6929e2304c8abc7a4089e0ff3200564cf0a8078afcc6add3df04a873019496a4d761f48a7e8aebe321a28a6b15e4b883eceb3a5c27a5a472be73c10935acdfee3f72a8e36f719dd27373505ae3ff4e7ede5985412737a604582f8e711b51c82ea4921c2f1bb2e10e674f146a17d6f2e7c2548c72326b4fafaec576ed2970c2da33f65b9cc2bebee466856e103585fcadc98074d54c0c8a4c13703e6f5c9505c8b2b05e9b89f55e104325cc5824e647757a2144c7fe9e4e88fbcc2b5fc0986cbfb269facfbfc0076c79f3baa8b07086505d72c77428d10af96f341af669a815aeabf0afea111d2402cdbc1b8aa7dc0e12f38457b77de53d38a047392dc82578ed8a2041e95ccdffcd6c7467ae95f87ad1fec4a4f31d4b363bc15834662df815040174bc89bd06707d2c2b5aea289e962c723dba133212d5510eee54dd3d6fbfc7084198a847b407aec3a5da36608d40278e3616fff8ccb9cf2586dd03144d5820113105d69f8d621d4f9c214539530d1dd2aeda5653f7f6eb49fcb5e73c8b4e83885aa8c765576926007c96bfcaa0a020ad5d71277dbf57b373652ba3afcc2f2bd6fe567700c5b9ef27303ba215ea8109cd34c8a756842b579593c6e13a28290df097c9138fe62f676869de43ec95a10a41073600bc9fdb89c89083506d02b58b4d81c8323753332832b1963a4353037f2244120183db0f957bdef3586ead08f4ecdb45c7ade8ca4e83bd033d7ec6606e4a35315422a9c8586900b87636619a49dec5eb8eb3b834dc27822d1d07a8013df58ea5f900f329f2218f69af964a46bbdf1499625173de32a0560ffaf74e77efba66d1dcb6d575134487332417c70ad00d1e284958bb77dcd6f0fcd2cd68496b348ff8e85a177f4cbc07c318d532cd6cee83ec8ce043ba9b2b12917ae85e44c791861e9fccd97559a3dda27e7c887f1e8e5c21d0965952c15463c253d4ca48f0051018f0bb021009b448470b60d399f3853198826b147c705fab04690fb2071f48b07801d46e824019f08c9622529d6e268cd7182d707fa9a3986d6a3c439ff4e7dea6eebe85120fff5a38f624b25b52aae0c0ee2ec8eaaa90b5ed413915b6fad33bc138322621dd89fb652660fc7882d07c9815ff0c1f520219ae2e29e563aea88e4a9d3d61c539e332d58f77897eb50eb35caf2b4ba080149af84bbdda58bb3acb1ed7bd2bc0811508eafd116ff64fe4eeffb8e7e12399e655bfc25ae2642d586c99f5777198c98615677fe7014fd84c51aac6b35ef39fe2a441ce46a9bd51a001a1b17d2f798f6ec97d93b26998d5481addf6e397d053925ac059ebb2f4876eeea979bdb16a3e54c23b5730e8ca575c3cd400709e5d1b094c60ffea0a3873c1c9fe76587cc483562f9a8d82ac792935935f69e3b4b6d5d930b0342c0dbafa83c1353a71b7eae9124a6c452f87bba0d93b4bf276e9e7e9ab8f651f65e79d3869a067ff6302a10cf3ada8c137d14babed196c594707c853cdde8d07427da98f20144780fd16ade8352b5881425ee690f5ccad3913559049637e211a065a15973a2152e95404bbf3faf4b4309ff71fe9088547092f4622f7fe39c9f5fff3801165d5963950286b0b75bc7c74576efee84f4f17596284692e51dbc6d917ab1962a815c05996e64c3ba55b1f3527f7aef4b18f5689d232e3cc007f4e8de7a5c176b286b2f00ef4f4348f1b575737c2cad82ab0275b2d5449e5322d85d0cf2a700322f88593b01caa9fb62073c0cda974ff56a49c3a907866810f1913ce30a93233e786e8d5b8d3866e40284ac47a2fd88582a0418aa1d1b54802e25019d8e9454b8c27f6979aa7fa6bac3cde6eed9c069fd11c94abcf7fbba1f17dee45e2f008b295c1dea17b62c6fd41c5679654262d21bff3a9f0fe9e0d0f48910742f485bea8c217816ff058d1dcc05f8273876a4a0d71d502b02ba798d269af30811a126ea5c10b0b1f15e606c73d265b07e94a51d285a9a7ebe87b55ae7a4d019fce0cfab4dd8f1922a5d46d0341106e602f5fd24ee3e0ca150a43ee352e93f2d796773b092f5584aab2524c6e2b8d28fe618515bff2626158a50d93f3d83a55420ba9911d5398569fa62ea9c6f00ba6bee6e625ab62a9158793b1beaabefc1909efdfc30e5e2086bb5f7eec51a24ffd42c16a5ccc3b692849d1eb2519d19dae758417692c845215e8d11fc079bdcd07c1d3192b4e7d7c09a3b4f19cfe2c0e9ce578d094b248b13579bd056bebde23284cd3e5c70de5d6d2dc1227354c573daa0666cfcfbe2bb33961d73717175f3a2eec1edcd3d78c1f9087d8c322a6f9df9811e796ee48aeae38eb6cded69ef0f88dc45e77922714a3b18a0c9f792778133baa6d7ba07dca6b4bc123c49f8eec79f1042eb65c7e413394e5e560a2e0eacb18fe7d67225bc24fb62648334e8aa3dabe8928054624db224415217f184ba7ef314c34dd8e41f5a68611bee34663044284f2b403058f433b7172fc54a782dbfaac5319b8de771c3a95617d1aad6fd6574a48a825bc997bf1aa132dc9b00925eca0dea14fb3ca6c0aec7e2de704777b8222df60321c86f9fdd66de6c1787ed92e455945cc75168329965157e088e5060e852306c92a62314138045b2efee6b955663c2c81ca54594a6694a84b806165aa2b166e08f2cf0f7407761642946dc95be07e49d3ac34ff9a9c6c00d6b4aa73f7874bf25b6e359d48b847b1a03f736477872671c8cee8b6360dfb7d26eeb9a1b869f1135bbf9340e1295ccbdbe005809d79cff4c5e126645195e4b0421051ea9a5319a9f411d343f4de312bef9403961bf2b23d147e7a58b41387c251ba967081def50fa1c42444ac03552b37f3542230ff572da59822fb968b1b576590b8e02f674ed61d06f55c8c1dc60f0a326300ea9bd4bc78eccf6001f26d3fe03f5331511f45c4e7699606376e93f1aabb237e0fb29b41545c5682fea51b311caf6e9a706d247cd3d46a604bc3c7184d67881e7f0df2c7240d9a247906d348c82d68d34e98d9a7e214c1fed8eac67c2a49b78c84bcea6056ba71cdc48cfdc32caeeefd52fbd3e1ee8e1438065c406dbcc2d55d32d01303c079253364fe721de26e7a93204a45161cdbef1f8423c294790bd2d89d6d423e66c50e5e7a9786460fa5633b202e1bdf3b477de2f41bcaad5d907af83acddd6f2d6a784054f8ef265f6a42c019551cf122e47f5f0bbb96d9095af323b4a5124c627112f71aa03bded85fd3754e95338a3dd4c8679427e680ed1e066bd29e5535ec5b83a91c55b435e7b910aecbe8324b765e0b2889a87720d784d04d1e5561fe04c28e4937b887b2b97ac907757511f9192fb5f3e0854bd5ad126cc74df8f7b4b8008d8f44a152182e4a2d6476cba6d76e0201e310418ba2cf2e0f7766ee7fe28ecc4ba371425238a57c0901e4a404c3175c21044202224c9d8be1561eec7753cc442f532fa6e76325e7693b357d49ffeaafaa27a0a12cdd3033733d434484a9874f159b6789cad82fbbeab53eaef5deb00b3989ddc665f47ab9ae2292a4e7a254e3acc62124867d3d31c18ca2d7e4a5ff51c14309bd2a7a7fbc36b7ab49ea14b684fce3bc39143c10f6c2ced9b444c269b3bc36f77d86da2b221d65956b3b91be3adef862e93ea99126ce94326fab5ddde191dbc99b19598a950a392250ddd501a4171ca647b18515a76c476c912032b8afce0b8ed9083c837bfc9786dd11bf593b7de92cf6c57b2e96137154ee1ff5d371eb6a2c225fc1083d1f97bf080ebb5380a93f3e11f29acc1b15176fec02fbb41db13aadc5ccb1bc24540683c339a8248e585e0f983304068daa7946f4116ace98e4696e96f4bbf35464db17d151850acced2e86f43dd5fdec19ea1fd5cbecc4d1751c88ddf8eaddf5bd4b3a7aff0729eadd6b883e3a704b8f5b596fef614fcea7985509183cee3eeda6ea53f5fe25ca4dbb12dca6f6e0a7240d0e556db46e816d662a3c5c201bc18a3a1edd6d3b2188839d7d6aa5f4ae01b5c87cea997b50a45185f2f95196cc20150ccaca1efdd468527573ecd776d1e98402766ab6c60aae8992d4d1f44b77ac2c39f2f44f0a8db626f10740641e72e4cf3c7de5bcd8ea40f68f6ebaa86b0fcc2bf8cd1eb525e5ee10b1b1d9ca3c5d090aa71f7951c260318716ca660567dc97c684082b033a5316f03c3d5f0fd40412556b53f037e970d8d5c1eb66b31ee49f8924119d4a3bed4fc4ea5f377cf1b3cf62a1a87eb37548d6ec10f0e177f545640596e22c36dd109fc28271443da557aade4ac4cc7a1436d1ce6ce04a15f48d0c852fb6d58e6ad75f950846838c29582f7c9cc1ceaba4f03d6f6d34273d714bb045d9a5c3788917588ac055e4e4662e455b972cfc421d1e800b14b3a6271c3ccb19689ce334da18cf26b274b63d25de1aadd7f8b1b129e92e3d4b3cb2515596eee994ac313c542ee7cc8392ddb49f00de1be35d70c139ffa1199a89aa0655e8ca5c7d442c8ae66d7bafe2bf08e39c7be4ada21fe60fc84028568f9b0fed1f56318fd399ff170433a8f381f2c3251532beba3a0eb88ed68c7f08e1fc79f0e5ff18b7f97d8c91fc01c4786d1f2649e68dc254aa48ba26c4f25fa91ef44071a00f15711f3a21a56592f6f0811ca92a771020e4f6045266387517d27cb61534256a84ea23ee3b191d558956e4268f1e33145c81cc9a73851c8cbe12f9c1d2b3a3a3c1b510ecf046f815b9df62ac53823d7a380872564f181a8462b04262beb667ca3211277b18d5534fa5b652b25fa0cddb2a8d89ba279ac30b46dbce57bb44680414a6f91d74042226fbfad2498035e1e4b7f847c96a516e64a6bf9aa714fc359e8f5e27afcea6b72155f7cf9487a3c61e3aee044333b8b6b8db4d70ab0615ea11c202b39c2dd66f71254827fdb041037408bb1a1367eab6c697bbadd78f7cf876e8a7ee0405539ce9a6984fca17e86de88e95eb7ce90a5d54a1fe278eb2245f853ac367f2cef765f0e4abb02d1f97b828129cc99f1d81968a411cd3de2b67e299489d26a63580694f3331f9eb35e88bffc2c1a96fc782e3adcb309777e0a8f9da5b845a3b1e9497bc394fa48b5053d72a6b61b9cd325f0a6846d379f08cde10b07e4526115c724749f8b4c1ce49c9a7176be6c8f2f9e060365a9bb018a064a7d8a513768f81f8652a12d09da10965162fa92ef7b32922550cbb75d4a5aa22a06122852b33cc1b6f5898a59c8c12c70d8e57d4b132e576e78f23d9ffdf8f2ece93c145cd23212bfacecef38eb4e11b1d57e02be6cc701b32a1fd82f1b995f149b12687296c18a6627a5142b9e1983c87ec57a41b96efa7809e5cec7b5a3c305f004e2335e7a1b2ce06a125350de476ad46b07f576768680595e31ea91343c0465ca6aba7b473023b0aa29eebf97b791c8288a6bf8a3e1c613cc85095142a85c6ca779c7ea9b1db15e0b5f957306f6612c2a19067fb868cde667dcc25668b40a10999e7bf84687d9776fb73c20d30013556cd1001c9d6a4a29a04daf1d16dc45da9b7592cedeb666be38482b2a77d022712ec1e6434676a0f9a747502ae19467c8f08c69fcf620e1c7c02e7395f99d1077b4a1023826963c69efd836b27f139881e534f88f422a0523808d748f94d7b53bb91a7fcebb53715c584e1f402e618973aff791a0835979d4c44d6def1343fdf722eaa213164f6e989eb73a697923a382bc350a9adc79c019281f8ab4355cdeacd5483390a67f1f074527914e4a2d3e2fa7593455137afff32c9a96abc7576c0b60b3f6681056ea09530f13f5c8fe47c785fff859e48b047a688eae5679e7bdab27b998be4b2d1d62b2eae205298377198f663054a1fa6f84634815ad2b2aaaddb614ec9084a05e5526e58eec4dccddc189a04c7e1f79f768217d5f586a0dbcf75577b0568fc087cb9344b92468fa4ec9eee277fd3f9972b7594fcdbba91006d10e670d96dee2bedc378145821916f78e14a24f57367c09f17186b246ac6a2212333c6e532964573a0cad1b5787d82853144985922510c8cf67fb0f50d13df826d37ec1d4e77fa7e0d6e2d50d9a875b0297528cd04405b32e04e2c9d395431bdc83a660583a6f86d6757fc847580ca44a18f8d1344bcf7f937c88a7cdda8074525de31bc4c1a3faab3e8a8a2a583ebc84d397767587371965b3f1405d71b8752d9c97ca8c149478118d74f391cd85404723b0f51e0356e4191393a14d2f5935c8843a79c932c59c704df68e75be77457c436c4b32be29d3319f1e2c54f281e3c15b6217012a51ec90506651642f81e3f15bdc50eddb1f7cd48ac342d8c45a7761b73fa4195513c46517a87ffc6d18bf40d975d97fc440a9481c2923d1c21f335d657bfd3166870ddf5abbab9a7d6381ca02f3897bbff264056c2e3682459473a910911314a0f460e922ea0c151ca6f13378ebbf8fb5f6f0f0ea80ccafdcb360561d51e064b8776185b0ea57228df669bbfe67d57cde88e0e3391e02bb993b41f20fab96798bc0c32fb30e504ac78c9417bfe45b51371bb1a4d1bb3baf881461cb8588c6a4b618d62e7871b63eb8ebb317ed75d71f6857b02621b49a0f6fc2ab5a31635960f987a655bd13354e41fb2abda5e695a88c141acb16719145568e039b4df1d93a5ebe03c4b4b1d73cd5a882eb48597093da6c6bf6ef0c0e369a68e9b2d538160bb4f996b78c2dc1c5544dec2f1cae608b6fefe7d3258659162ac8eb29626991051b5c11130199ea247a864b20e1a24229d99f4ac654ba4df29dde9d224bbc690b2b6fd107d574d6a28e50086a96b3a3304a776281a58b8e99d2c5b12bc7e3a0e26feca106fa617b529549baa3148c78c85439e2974b0588864663fc04d6ab2d30f18d8810e8168f351e532f52a66652e9a43958dfec8addc1845ae620ea5545ea2bf1bd5734aefce8b7cc3313b274db7ec661f1f4cda76c9e40b57bb26d67a84b4a099fb37cf63ff6871ac946c5c310da0a59c9b472967686ae7182ecf2103f1bbf1274b56e94ce58b23543c902051303416f7083189ebe6b64322f5bb9169bd798b6268e39ba4799a5ddfe53a788ac8bfac51cac006a4346a61315d0022788d7284c9809b2a8585b608e21e62ee2e61c7b55a494adc2b522612bba3f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
