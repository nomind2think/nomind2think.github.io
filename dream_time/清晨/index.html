<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd867db98824887b5bd612539ff04805b7b452685c5b8071bb0b0a89712bd05338a71e94eadf23382355ccc9932b16249ff36df55de515d94be1e9eac022f4b7db8bf6cee6dff5727040d61c638a60db5e2a15c038b98a5aa857ac5acd7da087fb5d241e7c990c794a175d57cc1ea6b2edaac52bb7c766afa14768127ce32f277bd1ec92d6d28063e4aee040acf7a51b646de1221e0dece9718d0d000e835c9e95d5e5525cfdeb179eb5da34a6315f9d5f141e06e88c965dd16bd8304306a86af957b02c405af7dada77d28aab50b0f895169893574103675a72b11781e3b350d4a165a4786808619110571be9cf318a5a6d1a8c96cb20d3c7908c911ec211719d0c7a22c34d5c39330cdc1b6c82162d39b7707bd218327928f1192aa2b281e1de2671836d5a7a1597111231987e4ef31b3f91d7a86c882e04d965e59e1f69e80d2c158f2e6d8e53f34fb611fbd7b9d4eb166ef190cf7f7f62af84bcab42271ce1411d88886343a6f985768964ff5faf84e2d661c7b5249543401cfb28fb064fe204dc9c7c83522e6ded4620258cfff6bcd6aa6b99e74baa97ff0fca2d47217e31eee50e7b1f775022fbd5b0d0266f8af4ec7b0fbafc7da6af714b5fe0599cf9d1ed9a19733f83a62ca5bd1e71d3b9eb4cd3c8359489e2b3d0d61f063722de61600ee0d1d1c64ed7fe6f6bb1baf8f0554ef26627975b0425a1b18227943db9be5a39ad3d169e3a0b00bc655fd78648b0fcd7716e7c0c84db97fa53cbb5e335f68924b5907ed5282906220576b9b245d8a13b1c130dbd37e499679bcd2540fa6c66c274e3b2f89d119fb216b82879327fdd08b6695f78c13d7ca4974af394766e9fffe0b0913e4d8edbaaaa3ea0e0e5c596a058b31504f513ddff79d40dd4f01e3a7c26617703bf1e0af932209584fb528887e3b6ca38ad4dc50b7b83ab0b1712714faa17c43b1e772b7a31bc5891ca37274839f1497d826b4d7fef6c776bf6848b4c6abb0992c6f72f6190c635456b0be49240de9b255cc57ecd7aef1aaf36bb8afc4813edc570f1e465db667ee60da2aa1a4b8eb89d2efe19749b1d20b4f21cc72edd5aaa07cae8136483152f0684ff182d99e169f5abbb4f414db590ccdf25284b50c5f6b0b76769b4163127f24b9841f7f16fee1884cc637de35f2112900a706b5770190de63c25382c58dba05589f106c3ee72e50f96de0cf691d158950e8ba755c480c1d07b7cc4cdf690738662139284651c3561e4a564e06ac1d2fdb9a3a06e884949e59278867f1008a4507a348b9de72c37c7f2577b6e59f851e08c4b676520d2b0f6816b1365df76100c680bb74581afb02019b44b3856fdfc245870bcce81a73c646388ceefcf0999a76778d65b39c20da1ca038bab4eb21a20fb2debb758b37ece363683fce906419d0fd0f56d85254b7fdba53cefcaf6f40716dacbb88f023e54ade56c834085647d53652a9d29ee9fa3596824d0dc89916243c8b5e9abe505ad161014c683accf2af16d7d05da157849b73c0c10aca753ae5652d6c512a5f62e222c8ffb19b2490794d7591fb9dc8940a93b1c9b36f13e0975256f480209b11bc296eadee4e5d4e0cce06c1abaf92ed96920d46305152d58bff9d1792dec01429c5ab2e5b23b24f34231bb3f638871311501bbfc529df595fe4a8f45e6dfd1872c407f417b166bc7beb6c0464739ade7e52d786722dc8eb1d66fa62ad394d3d78e31f086a85f2bd221a198b0945970bcbd0e6a8cbddcaa26372c609b5af0664084ec96a0f7dca046fecf2384d5132cd911a2293f5e6fc8ef16d00144d4f46a0e046b473f98c5a1cafd32ae195a010acea2420bafe6984861462017e870685936cb35099409348c71780cc00d52b12c0ceec915ae4c2350f340cd10dfba3a11aa55019b6eb3f60a491da4e0ff9c150edd8ab3791e94253c7ebbf7e45d00c9b24097340fd8462b5988f2b72007afd37b53e15df3b6fd6fc472ee6faeb5997244fe0e9f74fee3dfed0fad233e3322918edb1786c2194829b6fd6acdca2511bed4e53f855cbff1f6762554b5a4c7275784318f687895d31dc4b2d06a85ee2fb40a37077ba737792fa3b3def7736de1a08c8773cc19ea0e8dc35148f03bdfd54c1161c909ba29fe0603519b32c95930cab22a8c58059a5748867bb470423c2fa6a8d9274d0f222c0b79cc93ae56ce44dd0304c5d44383e235bca0510c6b6af3edf51253b43edf9b8ee77bf95bbd2ce324d93d61d7ca458756a64c0d3c1bdf4ffffdf3044dc585454136b3d770bee4a2990a23507b6b6feb74332a6d177fb7b82f76ce474b779709b43bd352f13ce516877dc2bfb855d277ac22912020804868e30bdc530e81d6e5c095ce30cebd44375248fc642262735746bec5e971bf2690e370eb0b46ebb46550f9e46308e655c85547b422da0511b43ffb2ce8c67d6f78db55c6226350e8214c4793481bb1999dbdabf047bb42425c8aca805d631347e05018c798e7a1702dbdb837c281e688a6857c90e08065d3927359ec7067e6ba904383eb2c507d8215e48f15d33169a5243cb9288730d2817bd2fe8adb0b77304b74a5b058fa3da48f520e0e311d06df9d62b069516b932ba277e404c4340e700a7a347c0eb83a46c1a16193e797c9cf80ca222019d90be74fef664ddf96cb8911ea0c2135b31981c18acfcab72463b1261c5c12f32753ae8a02b10993fd706902bfc90cda182bf3499854ff04569a1cf8d9e9fedad79edb2fe33dfaf57f58a965fd19fcb9a94b5a0e7c305284299bc219866fdf556bed812524e65a4a0f809de8589abcbfe9f59f8e78cb205cc17315b3a128c1fdc7ed5b462bf4e8e70a5eb201467f76d9586d179560ced11a1463116a0b36235e2cffae097853a316dcb72344d9dbc2431988f85013ccbf1e7f8e1d2e2ea02b1fc8d8e55f8311b18eb715035b63515decc315e83a841578f025e100d7596a494f0cc855c67787e2b21d189979393d01afe6ca94b744b9b7ca62fcdf4fdd7d8541d39cec203828e13ee21533d09db73c4d8960208cb0fa825bc97f858b56be72452d55fbeefac245422aadc603d49fa4671c8baa2d80fc4575d0c2701c4e6b234672fbd177347596ceba1deeee02f5ec6e1bf6244684269f797b7d14bc0b1e2862cb781a298544686719d81fcf9f276936a0574bbdf9f64827c6701d05a2585819689d0fdc181632a2dd38649143866e50041e2c05712d65cd24b7da2d058134ad82f56e84c2a833dd4c94f03c9e0ae5ba48defd2c458712cd19b1be5251ef59e94ad955ad45efc29f07652285d669718cabc90bd0482b0fb1639071897192b1f1abe0071f86f098071593b13ebfb1d185eaa0597f717afcfa5b2f8136c6f86c242073aa0be41d823b5199367f86bfa081e8192ba2f82eaad19ea2ed3a92a228ed602b8826a4020347102fd90e6b60d050791a216f2908de0637bbdc9cff4bc4b130fb5fce6c057982923e628bd2beabb5361ff3f0f5896826eb0b084390f769692f48cfcc4ff1827d11a7b5c9a3071232ebbc795707a3ef2f12be9644cd6d6cae9e2bbbb8dbcc08af0cd0d28c026c5516724876b5d4d100e98063fef63d42dd5ac5b6f299d45cc6db4f6f1cbe9e9818b389375ace8d44308b50832a5dfe43ed35cf7f2122762b53b3d013744e9be0655339e20c4239f436e2b014f906ca2a0338b2f792d087962c248f4ce10625df0b3bbb1700b61454203b434abaddf56b05cc1fe128445200ee61186b5ce9de5b4b1433778be6f73c8a1fff0ab71ea685275b83c94681fe58590b23c83b02f4c8fdde7ff3b9b41b3857608c266923fb933c6f254e1ae640560903a3fb3611837f71a68f946e7939e893179ba30a855149a1aba1ebeb48b05933e07b18b01ee0c1b6ed580055313160104db070262855053e93cddb5ae4fb9bc4449ee4006701b4437993d76bc8a6b002b5895d2878cc99c60821b9c9df7090d5d51af846743efff2733ea78aa29f2ca0ae47346961a3e201c25f1062475324862c351bdc33b36ff38ad483600462b2a17d150ef88298ac5b05de073a2c5664510946c2dd0ae8e5e3781aef3128908897b692ea13ebe5dfc4e8e1d13f0fedfe5371995100d4e9b241bd67dabe8466a5a2372a538218934224cca90b4527164cba3b5d76d1d0ccf97ab5acc773c11ab250e1a34db73f00297c9524523245a50171fa39f0a2036bceffc8df78ad6e6f6d45dbd727107386dd82ea13c8df707b0247a29848750fced936df071a8fcdd836f5cdf11c946ee5c9682ee2c1d397bad13b9fe6827fcf0bdbecd837720c6890d98638f39c8452a60189585c511efb147640ad82742cd99c2a956c070b948ffaec336e6d621981e33a6fc9246aa465e73cf533148be8a101add231f8890526946aedd339345998899af633827dea2158bf7b515736421e01ea4227981f3172d4f1cd485e7c2d286c2cc8c3851414593a5ffb025ab287ec446ab1c14ed4565bd4ec8fb6dfeb295716653b532555eca6cf10eaa3617be0924b8d8733a2bbf735ff22ba51825b262d24a4df05c8d7767cce0d726f1532b4a025fc7b4675e62647ec038b036e7a3f52bf7865b0ca500d8cca9b1ca129fb659f0a03c96b982e9c784422273cdf767c42ed6f6001fba3c40fccfb0ca8e2984b934e5628e8b4b2c6150f5d92985be6bc3490ad40d014333d03d3e008539819dbf12b8ab2bcb552427939c2c1adb31bb4f66fa1e3db11ad84f07a854f93aa9bfef2b5446128059a74d7e9e31f59383a15a00e4d336f7b1eb2eca79bbcbb5288daf6ed94358342d2c83f12120dcfabea57166f35508fe26a1f4a7a0d21d2fce47dd7779691dc7baf7fc8600df2c2adf0c6fdb4ab7c21ed8ec355150990220228bd8cb6042f405bc5b440dafeb85a1dac0b3e8c55b8030a10b8d676c4044277767a9f097300c09d7e77adfc126ef4462bc7cbb758c033254f2291de372a17b79c906d1d40f19d592d1418f8f20096c80dfa1ff9a58da72fdcc204d8a5c553a73cd400f1c2f78fb6761bc08ca02214b9cbc74218c5589df154b6de39fa29ea7594401a89cfb2945bb726b4bcfbd9c62f9d797cf6be9c6a39cc5d846e873db8a3229ffa5db5973c884f327b8e559f66304304b70f34dc97ef6ef3ac7d0b1dd42d96ed62293568a299413055cb51b215f032a33f60a968ada8257cb65ffcf826e7d785bdc566e36c9bf29db3ce3f9708364fd85f616baf7c5ffe2e0602e9ce16efa427a7724539b1a972a09fc63f8cab72730d9c72da5b67ab46bef6350406d55f3cb56f33ff8c6e33d0ae388dbad656332a92dd4f7aa5c41527dde43b50f6ffb49af3d2a00582e353315066e25f6a4fa525a5b0a4a289970f5f39ecae6c3b1fdb7f4fdd938d39084c67dd0c81cff437155e0b49690daad905ecf216cfd92b75dec1910c9ab8358f4e22445f77502f950a14cee50563dd430538a1b48d0b71d2607216340cabacc55b8850cd66dec61e7ccc9de03c4cda00cd593b3cd56eb1656c8121fbe977b441fd00e5fcdf8b398305804d1a80f769839b2461e983c1ee8d63a2cdd4a775f762870e2f5de8349572d7d482ce7fab5b37edcd9e40cc08edc3d57ece204784935baff86030074dd5dbaffcc7d9f24c86040c50aa0d19522417a99cb633ba48ccd3d0a4124a82825092cd832ab647fbed30f68f133ae2392e0dcd981661b247a49b8bacfbe2fa2de3d35385f70239511f0289f5d55f72729e1c9ec438afcc94d3f79b8f81af41584bbcd8d804c967697be56e47ad4b23437ca7abaf232878742b81c29c928aba2a6d35b0b0ea300b1880face5f4ccfb54ae6315deb2bf209eb139baa3ad5d5eca167f876a9b604f61ac69304f0c067ae1b4d853b5b4b8b552c34b43d08ad681e5ca99be217831699e5836bd9460a93c199f1aef750036b99ab7873c780d1312b785254db81188d6bc20feaf1721e77ac983765da67b92a11e887854e61f780b5750c464a9aeefb53f3b7338909171756bac3e595f2e0c410696fcc93dacfef3571afc18b6f8572551baa827bb2d67426e239eb08868189932fdf03dbb36f8e89dea23571f971c48f1115819466e37cc2c5ca745efaf620fc36f2de06573249a6d82a9cec413b8cf3ed9ee5ac717792cdf31faea50aeae4cc7283b141d5a0e12d09a8c419b07cce9a19638e3c9ccfae53ff32cca748ee13c6fef9e92356c7048c8c948506f4eb20b85b889e2ad66eecff7a37d828f04ccb1024029881be740892cee587ab4998648d48762be4a2e294729c4cc63ee515ee8fa14aaa9422bde2f7a9888d9af7e35f882f7f4c9537cd33644ad4d1cb88f6a1132c041ef5ab3262c638b46f16ac3ca80c4f2b20eb3966e678362d0246000d7b8263155c253ccfc003f1758d7663ca442090bfb0a95de3f1a0fda3d9eb6aea84345c5e45e9c6ff12867bc9708e29c1215ad5b5a55ef52646f33617a5a6454ad3cfc87427d3f52e5c574fb17e874c0a888494ec5bbfd4baaab940ec0f84189824abdb83a7ae023bc42e519418055d1d87ecc3e7a9a976f4cd886f46bad8c1505b1db3a23cc7625e594169b331e3bf136b3dff1f21030606ac258c2aa8c942e45b56b1bd878972efbc74bc659748a73036811eb50dbd0fa4e64227dfa2211bf3a3ae2822f10a671dd0038d6f8cece19aceedf83074ba51f4ca75806de3ae8fd684961631e6a8071d9a091d536df7d94b8d0b075d180c5eee3f390d84dc6490a12d1abb73b8c8481b9b783359a14fd4af69061d3588e4f0434894e107298971a31e584bc3352f73893fca8b7b167e9639233e1a914824b970362fe38ebbbab4f366fde81ecdaa9ad44a7af632003fb62012a218ebf651cbff04390285d1ef990239e6634b8e278b241b621b423320e946cca48e6b416611ccefcce7df74c81ce4bf903863e79ad166d059637e09de00e44d48fb3ec5136e54e27a98a6deef798b4158ccf8911fd5519ef310e73c0a10e0e7edf1e85a75e91c89e77bccfd97af52a810c0679b774af4fb08931b973b39d9f6e6d75298f8cb732173c37098fc948e370edd405c22e74b6b6f3768078888d79ecc292b364dda6b431c31ec673626bd27d30039378c77c301fc60278159ec88ed21447ebd4b30d225d531833f49a672cb6330dc02cb7ce663afea4e6eebd23162901cb17e2a5f1ce4c67f33ac82c8904333c2bb4437d15d57885e09cd2ae1091975f3f584dc837678da4f63cd280fc81d5e57b1a6a97956b370eb17672ec3e687d0dcc6a44331b3ed1f54908399a92f757ecb91c92dc421444c955275f108e6be82fbb9b28e4a04cf701c561020ee3b79211a81afbdb889fba68f24a86923e511348f3e2981070d625ad3952f29ec21e995b531c517d306885d280c42fbbd651e0405cccf62868a857836996bd33b530bdf7711cc1bd39dd5f48da06d4a2ac9190ed3f9add7d93b76b6225212767dc44162c1a729bd783e505a94418500b08db9fee35dc0dfa3d21257ee31f1c3be4524bd156df15e4f543c73f44e4c550bdbf3413befae7667ed8b6735a5b1e388f0c3498396db03468960990b2637a694f965cd61daa47b40224760f63d2185165931e700a087466edf44024d43b06bec882e3332bd579ef614b3f99a2d0982471033bc4996de212ffd48595eb84b340a60e09845910f686fe515739ffa1a40c186adcd5ad913ebb46b06737582275e1d83220fdb3fc3514214bdf2261b45744a37aeb17e68e19c7047628c4a803dcb4997b980ef19294779fb529fafebbb1f37a63887b10cd66b74909697bef16a8cf0418b3b393f8a1d7e1d19b00c6b3726cfc375736844b0a1c084d6acafc27a7f5c3ef6c82d7ed570a0b57bd8ecc8dfc24e35f0f8322d1a5d02322b51a245c67a7054be7ae49646191fcbce327e26968c29c0ce96c4faa2639736fe261514440e2e20ee859bac2d7d6d8a330c716903155f4acc5f066009991d145e31ac74cdbd51a4f6e86b18e88cb966b95e579c44fce76b39936a39b831e506115fae89aabb61a4efb81a417d8be23aafada39f111d7a7443e8d43114959a91a5e74024172c320eb2a29b079c12c73221d3b1a53c803490484145bb7d2d72fdfe554fd4d4ca9f74df52df74ccdf892c2d9e84ef0bdecf81796c75ba653a3d74b3aa49f05660ffd907d7da32dcd0b72acb50d453666b667a12fa836acafe278e156eb2742301bb3b3425cced01b05e86c31e6fb34c1b671fe1771a2e3b017c4b146197286fe501f7f34f1b35671be2d13d1c54c35c4e4fc27a839cfaf3b1e37505062d370d18ebb21f107d08d2e0b633fee7464d0425afb012d8102b53522f4dc85fd94be2160dd1e57a4265cf2833474cae84c477a1413c4e145043a08989794dd8fb177cbfd8c538ce5260465bf4f13a02a12f6c92e07d93c21f0e78f52461f8d71be1f714cf0e56ef93296c93bb29ce19d78d9d822f86ebf3d817a1f44e2f98b877725eb9ae5914ad8543b92cca52326ccbb90623e6c939de87a61195e612d84f07821ef76443461fb3efff9079c688ebaa94c9ff29eed4b0d2c6a3d46016a8badcfdd70acb3aeb7ae9feba64eda61d3c25c9c3f418cc38fda1d1eaa60abe2d8634075f79c86a487684658c13bcc64a4bf91420e68f37e41120e5fc3dcb6c27d00fba7e5c6b8877ef1ce573d94ca877fccccea765e9ba377bffbfba10a84e589f3a34591a51c114c5957734a1266c121fa2eca2624f005f11b6ed78477003ee5c0347972786ccb1c89ddb56acfd539017fd5a7ce03b610f4483d0fb7fb569385b686834451f95a17b836b2d8e9aac5e778b7b8819ad8ae93cc9758ac6aad240368a0f7f5e1817d161f66952b013c0583f7a7c0fd1a2b88d36b18ea55281e413114c5eb295fc5584687fa081c257cd181f87c5cc5eb40171a42bab4b9988ce98777c9a43ed63e874f53595c77a883e3e5e8266edc9e030b46ec613edcde273b52561c07c89560a3a6172b2693b0c7bc5d18763280b1b7d0516028f59dda5461ed81ce9185ffeb6812a1383df49768ee30a96ffcc4def4a2e0269762bd0b93d91c1009cbf4fcdbb79bc0c43d4398acb0f660f04fa5bdc6980d44b49922107888b9b2d6a71aa7f8760a85e082c2da77f14898ef54f6b8bd3b7f9b8b2a36749676a1f1b68612d01479e313178e36912e80f73f1a8f28b54deeb4287aa02d83eb53690eed5cc935734a9c9ec8ddeee15b5303089b7b20d67dd4869823b4c37c9cc396212ce30e0222eeb8746d444987596e13235b2d1adf98f5737f05daf467910a9c5f17473c36e965a7df834717a6c595201424c2465b3b7508962fcb5f4f5d3f5b45718abb7f54797db827455127bda440102867b88817c72d3234a3698d9571869908c160ff887c453e5de1886b5c0e92d69698b51f0428c8852a4ed0103cb5b44b0719a2e151ec2a0791ee669102f3b8c7a16dd6f7c64510cb627bdc2564731bcc2f8add512569514a8902bac953141ee74fe55b9e243a0fc3eb97c174bf4be3da0cce7ad3f496206ad43ce6345fb9343866742f7651bf9742e3c4249bb6b8dbef51120e8e658b00c24b108d56d2033840c456706c955116eede0b3cf0caddd4fb0b1742a53a37ae6398e3105b2e232044f0ee75ade1f507b3266c638ec39b626ac57f8fd24590793241fd137fd93274b38d214e5fa6448f82dca3b14ae79b2423ddbbc644c75eea22b88ae3531f736acc9cc00a832462262aa6de9552467b9ce6203ff321c6b03ff60da8b05fed32e5cab60fd3058a18cbeb53a5c06a234a1e7cc51feea9365266329334d082760c4777cc6dd6920e2d11614366d5c8be03974516da1e3f15d1a76ccdac4c562fb43cc5b828b7baa6a373c0ea04d04fcbf8b93a8be0195d39af314a576b9e5b53712794c8ea0db2d2345ad4393e06c242f6fc86ab1079e37c4e6fd6e9f5634478a513bd54a1bbd7cd05e66310d8e7605d16cf85361e9957d2041eb37ef089554cb34dfd1ee422b1a65d68547298803a032107e1dbe66aa6177a04e31127b6b5ae4f2be0d406631471104bdcc8c93bda3681b2baf959bd59eab9eeba3c8cff2567330c76d9abc2db429c58abedb3b17860c811dc7f992d2dc210fe73ec0a0d4cf3e8cdf3e9b27d407019b523f80459e52abc95b83eae76703647c18d8262e9bca1eaa3bb929ae64e268a84a36df13389a8a687437f407a89eeecccc08400d7096e7235d21ec0d47085630fd26f8a413f34a02882a03f400ccfcd574232280e68824980ea4c48b4778e83592b74dab97c684a6b3f5f3d3f4a9a41a01db27570aa16c21e4fd111242ec7eaa13c6d0974c9a6377fa2a271751eee3c9e7f792c97d0c78146dc9d3f7d282dd567422718819319141238622801fcc7f2257e8f63d2a15aed91d1d96021562210d9c4a182f2546ef64409f09742ccda746a919e11f8a621431db45405a2c8e8db8a92b963e526d1f6adec042d461f3fb010d2826bfe90e9105bf2e80fe6fa8c254174a64d83aec41913e3e680800cda580972615c139899b6e3a8eb85b8c44e4550510b8563dbce0114a2bbfedd1b6c3ae66e888a1ee7a7d0cc253ae9beb44ae57123cc881c55992e2f00a81db7b681958ec5ad095440754e77477b51854590a1a3c63650c6e95972c7ac491a055b9ebb45b908c3b089aae870b52c52b447f731bc291c9f8aa5169de6e0dce4d324f38771cd1e5884deda356582e5b86a4392598ae81a8d5ef2806d81b5ad12d767a783f4f8adbcb6caa73ef9309d9d7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
