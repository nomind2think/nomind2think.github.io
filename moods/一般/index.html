<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"820c07be41ff2abd0469250f6fdfa2b2e3ae2dca91a3d659728c515a16b83cccad24c74e10a52db7753ed5345e731f4b226b8509fe6b84514e067213c8880ac4c67941f42f6c0b05bf7df425139450a61ebf17ccd2c09eda4be33befbd5a356b04827648a2c65a8d1a47ea64cab04575616dece03940e0ac5320a1e91cfb5c5e46ee2ef3a0f1bc97b111cbd5b64190ecf905b68150d52e349b7ccd1df971afd04de7fd0556cfab6128a51a0247e5049f046537df9fce27670239eb2d0b04414849c804ebfe20ebbf764916f926b28348a2e40538d20298d0998ab81eb80940d8e44f0496d8da9be55a723f8d76765d5343359e9b79fc5a4e93648184f3aff15ef2d7b893468054d186dfde166a25c7acd9c413ffc2ce5fe032aa59bb30b445655b0386124b24ab39aa7e480592f23b440dd02d3d887b7163fcceaf0d12aaa598b4c9ea0849ab1ba9d5cda4e62df0df9d23d3c15ac4b5b1f2ac76c825f49a1aec93d8d5ffe13f5b2b2b20fdb23a5bd8dbe056889b2adf069f8dab3cff4c65b21cfb61001637be75d0745893fdbd6d5067e1422ac0b04008ba4c3e54daa3a562088801ad6fda0a2aa3248b3c0ff0259de5e8118413dacbf303fa4586383ff60c5f48cbca63cc56f89c4f0bc5d698e60357663ee3921bd8753d2ecbeb980ff6080f53535b5578015d7ce2745ecf497fbf72f62741316f7bb5caebb7c1e90b9d83f7fd6436f0733f74bf1432af6e1da9021267eb185f85330d4d2d6c2153fbe59f16aa7f909f3640db307437a33ac0a5ffffae308815740b740313d8da71794b27cb3cb79c3c58ed1bbe4430c8e0c68c1112a0782e341977b5e06698b85020349092243348dc87acdf1e77ac931179eedd1ac821ee1d1fb4fa5956adbf0e7cf8d7cfd2e8044c8074518a29544dca3211c9d26c9b54348d9470b58af2d5cf0148983c6c5b3482c1594f593b613a4d42b9ccf459efc0b51992dcd9c788fc9e5490eac05e9b3b0c8698ec5754e4df03dabc6f8cdfa02852527970461d148acdece697e06bb359fbea4c4ebd1fbb90be1dcb83a0285b33a02e7ba4ed73d225c9b264ec2d629e640116b51d344546966e09442a490b9d295c79758629247042b0f75998cdc7b01d41bf7c284b8ed8329e10e7972b0ed3e0a817fa1a630d067537da99217e4988c5867637e58d10ddf8b7a93911efdde01ef58e12511735d5386adb176a52faa9a97a4b967af31bc1c6edf6d3306632ff1fa6fc91b4ce2ba7de31a9e0538649a5e8c841f44f551e9f3290f60719fa647e94edaa3cfd552bbc801007b7f70684a4eca12b7ec99014396bfe3a52eeb228a2e065629fca4b541395e753dd70d49e2706393510b0af6f3465d8e6d41d9cccffa48d972f3635f7a5081d7af089f35837730ea7f004265333d2ced15ca431b9001b356ad80025c21540b0ca4082b79618afe56bd7da7ef0921da429963c56db71e47624b268de8c713651b014979dd6a07022ed90f09166d1db67b0bfdcb3996fec271209cf89a435ab097e50525ec72509ad844b92f265f8ef9cf519ef74845c1262388d9931f209267c150917b89614d6e00564d6d169625d7423bba21cb07a7ac2521d5b8d5ebcf434f4fad24ff73f957598f9b470a766ea24b7b404ee3b4dff8692f08d8e0466e9fc0b78c79579c2b65e0745166daa2b32fb7bdd44d6b553c52c144bafa0681f80b9165855aea70e209825a8cf56b77cf92b72ed638b6ecc08698f8c83de5d378437fdf08c3fe1ccf0b2f5b59ec50d4acf2ab9e4f4d6d49b38a35e79314dd65dbea78f02acac8b268f321e7e62bb2c3a182fa394b1257648075291722fbf381d821b77ad332b5814a510319edf85eee94ee2fb6da43d2beecb580bf39c15c3034eaddcf3e95d630ef65be02c34d6be776e798908fc6271aeb4003c15290de669fe157a3a8c83b4fe2198951b8e3ebff39ab2867879eb4c574e0349242167bee8f2894787d1a9f76801eafc27d2cd978b429f0ca42508a0ab4b15764758a5550cd4c7dd786924fbc34474cd269dc2579d0c8cdf2a0a7159abde8d00eb8e696f343a4f51db34091454448e9d697c1335c61c4a5c1af7b3f94874c0ad6c0e781b578aca63c717b4776414e719159b2840d0c2b544932612d9d1e2e25cd1eb2569bb2b303c46874a5e1204967f40db6542dae65575186ee7e8acfbe6640eb9cb3fedc6387268a5fe5adc8350265f3254420bfee1e651498872dc3d0602f79eb9f1dff1bab59df52ea67a07fc7940f81ecfb8acb845174137f38c6588b0d9a77da57a88a13b462ba0e325d6258d49f3b5cfaf5e7abd11ab32f54b5a9e6a0fd4631de02fe9ab3476694a6c1c07a28e7f3316c725c8a0d9efc0de1e240ce4305a3588cdbc085eb7968bf6f4534db1fe282e2c8eb6af25e309230b8680fb1ebb3d041a342643b97bccc0672dca5440de8b5918f43128a5beee05cf6e5e772861e1f278002fa2f182e0244aa8cf0f25cedb39427c81600cc41ff1f9250bc786a9bd0f4ff18dad163177c5a6127580319c164c8a2083d5f5f28ef0bc3e8919a5dcc6c259eba4521db73aa9bee803b9c937e3a2acd00257d77a7411f63c5088f30d66b0bbc8ebed95272902909a5b613e6875cd63b147221b5e62bda526d650fa9771d38ff7ed09275fc545cc20d9c38d6797fb6bbf8fcee8a2c9e3d27d8ecf7a754e53c8c1da440d3d4fdaeefd9cca3575a407084bca5f5956d654a25165c0cb5d761eb616a08b58930b7cb2bd20581de5e6993a352324aae733fbc7994495d1436701d62973100380c63d3d0c2b760980e69b7c77d3e970bfc1ab1938fe5baa2a66284ce0f0003fcfe1bf2f353224d799b60a8bf45dad1d365411cf96995fd11d88862134284b8e8a26910b21cba85e078a94355b1622e82e50e99d013b6b4b0c77a63abb42dbee96003d5133bae38f6cb380f2ac067c4e8b96cedfbab96125a1b887315186332058e789e7348b79c8785d479509b0b8488a663203502f145081633887fbb174716121220271dd1e524b449f372ae795b35e39055f7c31d4a99929b6a904c3cddc4958173406756d8d41a6750c9aa883a5e8f2f25428f6f317730949edfb1357d107f9a49817e06f31a99295bf7d1179b1d91a82111738158593f3fa54b43bbe2e26eeaf8cfed207c892988b06990003b7f93d71cef87b9826672d743f2a509780c23f330684b307f570b5980b1adfd2faeb849a1c4dfa9f2629d76a75801dd72dce7de6241c62f94c8497f896571677b2dca35f113271fa09a4021d267b56ef389fb4d5460b0c39026a40dfb41a41e7f66056eccf51c9cb51d61047d282954a5ef4192c0537bbc6ab62b0d38aa0f52dff09877ba3cbcb3377e917269d6e2bbdf4794d96678621f5dacfd822529c08175ae59f29ce9e68535d50ea8eaca69e158cf8c5bf9b3edd70faab9854ee3fde849ba8c64173835922e1bb1b925ad6dd2295fab1b352f778217991d51187c5248e8d5a0575bd505bdb85305f264b7e21c7383bc77d174337391d5fbaf554423b4bdebd85928d9b8fb61f210e84a62e4d202bb06fb5fc8e8828a82808581f381bc2e397fa1826e35e4067771a9d782a4f75bf31cc7645fb16e67a4a779587321d79525b131cf9f1c4020139148118744d65458bfd1e4f8e153eb7fc562555eaaae9f8085c8fe2e04f508d218b6ffe3166d8f19980168bc641c89a37faf62721af540d78e217ae62f809a5cfff4b7bdab7ec1240037952af0508142cd9985466399abbbdfde0fe035a912c33a31129a6335850bbb5becd56a792fb7113daaa77a132eb57670d01a192c2796b90a6e7d7a4157d6fe825e5626b682a4339288ad60ca791ede82a3482aa34ed446706d2f02c3bedba5a162317ee8bf4ee12a30169ad61009fc5712582da1a93c89846c949c13dfa921258b7bf45dbff5e17ac9864ed2b899d5fc847ad1f37bcb015e72d7805e07faab022a92b2a4c0475f0d75c7597d3f2c4acde1dd4421435b046b1383d561642ef4371eabbe13bd382ec7fb81ce1693edb5d6096fb8cf91ee291284cb61ad13ebbba517013099b19420fabbab325e861f0569dd5b1d2e693d7aa6994be92ad257422309136cfbe1face24848804254f4f8f3201006e5bd46d86c4569b7604c72c89b095324416d1ebce97724449a386624ae4e3a935cd7c664ff5691697f644ff2ae681c13ddeb1838a24ffa765c436ebfb5c16ae182eb7dd5afe2f1a8c5532ec6b879b49a640617c1b846580eb5608e275ad9b3038e678d32d9a22197409cb4516e0ad452682bf8b307ba3e9098c704ccde8c257095ce2c7af5b4a08595ef5a9148789e0ed56ed1d58e9535d0caf4fa2bc10b789be3c81b8bec4dd97cb9e8095f6f163cf88a8e2577826cd04f926e950c45b3611e837bda2d1527d603e25729c0ab62a24d1d057f49e9ca84ad851f97ad4b758514fc1277af61b4e0d4693b72125a34dc6bd937b06d7258bd5956bfadc5d89b89cfff24e172d8ea133c607d6262506c26f7710c2f9b02d888552a62bf63defdbef3828f99025c3b99902ef0d82fbccbae0fbe7c5421ccd039f8093a6d3c022d02b2cd31c3a1f0cdfbc5246169b26559b89adbb2285be82079cd75a575385c8f47c50945bbfd00db183abb7bed8210b8aa42a45885e8f9f9141c1a7c146720a4c4b0796187270f4d140faf6327166e09543c5202c0062c5c422f2c202ba47e6b0014132a578a970b48b26f864963713945ced870abccaab62b5b781529b7a1df292906cba2f1253179b2b55f6e5a2311809b3be2c2fd341110532d5a82613195fca892b3b44fbbb03c5dff5b1ff010c08fb2afea212e3aa99a1ec39eeb8b888f00d73d79c14cc24855f63866d100f08f7770c343ab1343fe5daa6ff4ee433b69f4abc21250b345cff8c6dfd640500c2606c2dabc4bd47c1d62e6870ed4ea279c4d31f2390d45c64aae66fe3c55026ae4986469bfbca1b65f143b2a322d3a7ab2bdff425040af7d62c8f5b1f8003ec8648dde6588c6275a67050521bd0ef530591587eba6a493bd0c52bf37e6f33839d07fa3d6604e2cf9d47e5704282db1f6ed8b4db40baf19bebd4b5859cbf34c1aac1ca5f8bc31c940db121aba57a1caa8ccd06b8214ab4bfb68d5ea07afaef6cc9e65a5a5c0d2e5f52384edb0a27d4debfa3754891e93a2c715829b9505985a01e6ac2b492fa25d2cd16de569d33504bdfb81a2fd3622a39c7367542bc3fa7c4b3bb5566b308fa9d5923c9374fc47c1c9ab4d70edcbeb04b476b4ea4dcb8606c0f4122d24eee73ea53a2206d013d1005cb4376f2d65cdfe61fbe051fd810d3a1b5c398b6eb452b71f68a578141df8c11c88d8d51feab4dc19e239250a66beb4c67f93bb3e8ac48dfc9cd5fb940b3d1b9796c34e53c7f6d6e9bac50299b98ae9cd5adb3724096854448e6cadc9a110c0c17bdb764a69fce2fe8a0ca878be86ee70158ecb001e725691a22f3324ed6c6f8e0f5fc7fd2c3dbc15009d636f769254fcbbbc15ecbc885e5472bf054847dbe5333cec227d512df6868be5bdc80c0023a31b5b2a5054bec6ac5f8328e631e1f2ff28fc4fbdc9c4f27ce334fbef784589f4a929b3d5b048175426c9096c33432d90876282342a3122e21dc8555c59f4f87cdb86eb8eb316520bf6839eefaba38a0476819f000519955abd7f9c6960f018004dde1abe6fefaff0f3b48baff82b3d17fed43969fe574a6db6711e6472e289f1d9c308bca1347231fcb0654ed4bfe8372eb91a61f5bcbb80edcf35f2bf128c2d9c48d406879d41609a2c271a3dfb3e832d86f232fb1ac5a122229dd174d489c16021f7b5e26f1a498379213da282961614b509031d5f0670096fc0fd050ec49ceba502798a8a2fa5be93bd5bc38dc7ece771af0f2577e777be9aaa38e54939dced8e945c6e0b8e0f0ca24b0ac6311cf1c4b2df8ada8f04b3d47535f81466f91986126ffd2b7bd340acb822b514f35b956d728bd9257c6cb55b60fd9b420793a1a0954d71f9fab2e8c1d9e5e2ccf6ff9cbc6df938469363ab703de33d26f7c3c8326d1e88209d41d28dca518b1cba6bacba35c1efa8391165a970eb258a5b8e5ade17162f15919fedfa9c1917bab2260846996e8e772acb357090bcf45f5af826d96b58e1e9ccd95f1b441626194cc959a38a79da8d0855bf5c10a0cb460dd570fb75971c3765deba830c12bf9edd0adb6e87ce480417b2942d7734f7383713819ff492367e50f79ac89eaae372308214df529c7c8d6c4ea3bcaa73c3103e6a7ab53797a252c6f7529c0d7187b2e9cc153e8613611dd22672fc75435242ec5e29412d55f1c4ee6ad4beeab65747e130c7c28ad2eda2c03c77477f66248ea697b61d83b262a663c25dc7e448dfa6e9a888279cffa18474da1af85955f0ce8963753c450fca48889c0dfa2ee87a421ebd2529d9e2fe6f52c12bf6529f60b9ec515b5ca8d174138d0a01f9f335f160e9d3ba153fc513fd3ca3d011ac71e4c5ed917c9c7065e8891331fef681eee408d480c4b8f411563de99b042c6a1e2a506c7ed6b19b920ba38ca51d9f1f931509f5c0306c2f68c528207a5723497f0278a58b9b51adee27b4f68c6b5e802d0ec48ddef983b7866a7c838784d3d546bb94bed59892937a13c5ccab91d59b16c56190e90c2e339fab833bfa738c88f1311cdb0f73159ca510b6305fe8b1080222dad30730fb7f5b53204267217bd6fd13b936abcd9d121119ad1607bb5facb3f36e5a3bf16aaacb9078975424a767d941d7a656b8e65f7f0c1dc5de33140f36b8f6a2969bf2abd1e88a05db930f555b5a45407cfb031b6a169d7cebee118382fed2237ba035aaeb45f068bb195df89cba37d7d62482c1b138bfe091fece510ad3a5a682f33150137698e426476c59290008fa9188122eea76ba82fd89a2f1545a166fb2cdd5a00f89c1519d0ef5acb18fdf2e2cbb3231bc9329f657e7215dd7b0b4aea2a812e44b270b288cbd9c8846b299f6e8fba44a925f5b1f8d6d656c56fd4b4da378f32a7d685ca0e278b2c85ba7147dce8b82d5ce06f39828ad4414cd91fcb7dbd93d2ad74bb5819eeb2420d4bca25c3dbd1595e47009db21c5ee162fdfe6ccda200a7ea6093a444895a167b937d8fa2f2d72dc1b8a1bb4dee09a56952260b6d3095e62a41da3165a7d9023ab33518cc5f1cb1c08e57355ee7f4999e0f8f9c6462403f097934a9c37d1d3c67e0fa5907ec0be03131b65854f64f5ee67a7e23ebdea1ca1ce4abdc42d85ff6f03b9608ee075462c267b0fc3c88dfe61189009a10a5be3c741429bc36d23ab649efcbf46bdbd9551e106aa3b300d7af50f018291ae9fd00b7443f5fa68ca05c5268fdea4698e9f3d0bb725e25a60c913461d63c18ec6c416a937fd6d6d295bd166c8f8b2f5e3e0c67787209fd8ca889bd164119a1d86a786c67f945840850f365363a5acffe29c3906f925a64cab4322ff92270e21b162a0e4e6767be4817ecbec9e5f5058b9eea3b8ed59e2c6e164d388540dded56019e1e085b6e3e591961a7684ab558f4654c64d35c51e0ba5ff567af25e614f8983cceee0fcf0eb393efcf4f233c48df244025bc19a665c27f2f315a4ca1875376c30946e0e9cf01316ad851f15edde270206d253cdc7a2b62875fafc05cf027243f6545b2b148ad1e5c44b2e3e6f688e18a85f20dc22438f791e6a351f795d3bec86839a1fa4f09991f1a52ea647faaee3c7b5d672650159eabd195fc9fee9c51aa948480b20a73d6496794208518f06d43106e4c2b1a4249c65b05e8c4e8678db810175a8e1b424249ca779cb2a25672c2c09675dd727403323b57da663e498c334eee6e652bf5a2ce23fd506043064376bd9a9a607d5b6b374b5ea7fbc14ec84d3c40e8d0a5ae21a071cb0c4ce01c9b6c8c5f4d360349f99c08cac9a71217e40eb92340200c7dda1de68a9e90389e418c83ef5c1d720cb8972a132bacf8ecaba34238a1c20cf9a721f25b76098b42dfca5336404a68e8958787af7c130b5f8ba15e471be713242f25726c23b79d9939e0b7b63c5e7bbed0bb4be38848f3a0cfefcfcec26980fc4154da96fffefe44c2663e6b86d62ad44de5ba541c4cc6298160207e7348bc19dc9e632d86a75df92e8e7dbe38162b271366b70c49ca586916a0251f7bf06444db9a71c639487cabbe6847c1421230471b55b321f4e4e292e7a25c0ef1f14f4d0c84f3c98e1927b6dfc6a5d5c41daa222d1a9afcee23025e0ebe522d0166ab64407349e1e19ed72c294ac3c6a4606e2a232c71d6663cab69c33d5f634eaa442d18098f4c2ef1ee33465347bc569fe26113eb2067ea1b2ab4ac32ffb51a2cb1a69d23dd7fd5fa0bf6328c2bdc75898607e1f3e89842bbb6cd10ff120610ca53eed9ab2a9c5fd1c40a82c3f45f0d87588188c486425a3b1bd0561bbe69997c62fce63038a3990d2822171584a9ad1e3023395e0ce399fcbac59bf35094f4310d9290e90cd997bcc4e8a0063ffcbcc0d94dec972d719370b36680f5c0749fa1beedb2d94da466880470243490afe778e4c64d345c3913c4ac2eeb4bfea1703e732bfbc1fa189a0219d528b0a2334b5e5db4cec8616981ad6de7d0308a885d9294e5cdaa9865ae850f1498c0de35e190abf5f0f14cd6bbab1343c2fd9a3df1e229440ddeb7d7dde7802e29116cc933df346f2f6d08187e374e2f43f5109713bee017f6dc252c5ce8f5ba2dd5e15a795d1918d1c5862b8936026847e4f84a9e279c87bf57e9ae4b54d1b460137bf93850dbcaf572cb7a3dc54dc42648933fa06cc71ed54103b3900f7021bf3efcc3ea090efd50e73856d1530b5da6a5cb2bdb265d3c0f85e6ede41cdbc5d8a25f2b6e317acbce96a2b986554cae29e5df2c2ca1d336e9777054c2d1d42abc64e346c4f028c495d4996774f646a060bd4612b9d0800d36974db426c18029715e88e045365f5090905aa65267f5ccc902ec4ef45863cab87337c387ff4af24a2fde68a0bfac69830ccf2c473989503b60363438fc569d0eedcdcd69acb46bc44b8a785dc9f3b4e017ecb494780b512083ad68841e304e348b7ee53037647eff1579a41226e1b495af02521b0b5dda67276a2ae5fe606e157b721bebc41b0c4982a51c50cfae103d215373ebe86ef454af7b2e7494b7bb0d1d693f2a326101928618604ac0554656955405fcaa13e2f7ca1ed239d44e4357d675a3d11caa86915575c8e6c5bc7dab55060e3e654347988ff9a14b51c44b1e4b615db746b42f3da41ff10d7815a30bf4ecdf1952e3a1673405f5116189cd0c500a2aa88bc434b7fb8078a373493b2017bf7ceff138d8e47b094751bbe7cc222469346e967951804d907ba2b3f977ac46c20290843ace917eb8758088aaa2a7f072be5b49b5ae96daccc0d96d09e330d255574c2303a160c747fcf44beff8972445a81d5326ba408e667e79c6d72a92ecb2524dbae5b6ef39ab632642645f7ba90ce9898f177cc3ec467dcd0245d673cf40161a75f64b5211b233d85a7b580cd0a7a3c3554e8986acb96caed891e700a5872403d7b9e69e841601e81748e89198b5f08c93ea2589544c87bfc7b0db57549fafb77e45c1d04329e8c0d715abb8a002873852e2a5f29626e0eb14ae965d26796b8f67c72b1566723b0edb50aa6727863a90ef1f699a80b97587d220fe30e94e81603105169372662a72cc7fb81e9188106896446cc679754adfaef5dbe716c561174f9ddcd06182d82e80412d2757006bf380d92a0eb3c03eb4138ce5b3e2c676457505ace661d9615e714897be0e836ee0f649be9841285af1a55dee09f2ef42d6f9a12421bd09378f9db6f72b4a2617bfd78e0b687faa47b2da4e16da0f456566899fac341c392f7ba8d5253b444ba1e5f0f4f697b84d9b767a2543e329eca02423bed1d5574af0636f3c49ac45337c2e5bb2b05dfe3434ad427999f93849f872dd879029847fd8ae9e49cbe4e8b775e48d2dce5764ea8326371f02ab7872f1ac8eab63c8e4a319c6a3c39b20a68954f3834a238ba224cd6b1da2b5af10bde2cc019f1298b978f18f6a70c29a557c92640829ddfadbe17bd9a645fb2b2cfb04ab50f5b313a0729fa567358e9aa0c4cb4ef55d9aa7e278b3331c7110ef08dee28bcf57eb1a1c2b3bb4ff8d488bc7bb5039f001921e4f05afdf0dd862c3fe41ca626dda98d51ed30f8e5b3b89f4ed8d4324c263a5dd5a48f6596609e9e0fa02252bddfab73f9f3110c279d988224a11b64daa3aa12396ba6937a7dbfa95ed6c63ff87eb7ee57979dc45381e9c32477bb7a3dfe55b621540a67e316d2c52c5f98e5734740256763f33e002517f8a74e7750b115c8de9c0f79f23f71d032e4e86afe1e7009f24bac6224f90621be0ed56392ee963c19080bcccc2792373c1826b5568dffc92de7f4b22fe08a9c8f6d6d1ade673cf882432fa5c06eb3963d8009c30c3faa8ff4a57761502657985f4f0e318e2ebbc469a3a2cd54a0354204b937a03c2f16c5465be793466127e0bf49a8319195c764fdae2adc92d545828363238f384b7ae1b8b0c93bfaf50a85bea6eea527cf890bd5ce0383b584ef1408b505d9127dce5253520195fb915ceca8c79f94e85b7260064c78461827aeb849aa1a200c93d3c9f5d2dafd2f25150f4c2494b024e7088958c014c6a7e0eaa4b76f8ba19295fbe9a45079b1ef0e97fb57a77f1d04519baa977ea625109e3577e3cf635e1a2c3e0f2833a1673a3a83a6c1086dc73379d6bbbf87c9009ea52dbca5a075b3f2061f3f05947bbb7ce45609ed55ffbbb75f7517b1d18cf850ba35f2535e24964be9beea3f6eb37d2fb3fc0cd5d7ac289071ff77a8a24c79ae4a3c4930dff619a59ef87dcfd9936c1966f26edee3e9dc2651ca71eabf7ff884b6b36b9a3be370e97fac1a1993a5285975c3e8d993aeeb3c9804675f0adb5dc17f1475cf87a7e99081829465f355349446f4e67846b0d3ee082def1bf67e490042fb964f82d1595807b69ed18bcafc9f66f3a8b4baac5c5e47b91f486ada23f661ee6110ca298810d66725042eb6628972b9ac76d7fa5f117ecec9347c9b7cbcec1f7f1df432bb781fc7ef4229eee33bfb8f21c8f67c0ecc681e973314ab93dea0b5bbdcfd35ce76d71ac39a290686a6f9831adb160c8b4a0c65136ce70a3f918a9659ce5c4c659b688c20260e9edf0576d86273474fcd5c662befcab558a599657cea5a3c8fd29a12090e608e0edd148e6f93345519cee3b47db2540f119e4f2c57a60c801cd66e92f8c7395e3a0d5bcb0376e273cd25c41d18c2a0374bf7e2b4be070deffba3fbdc9669dbcf70b36629d2d4c24c39708fbfcaeda52dc5320012ca23745837285885f5106beb87d387c126885926af29b1fb96fc18bf121629ab30ab3808a4861e9c1ea28888297596381205239668ca1e51f841087c7aa9e36fc999a55c65c8fdf02f63f77f1603c1355b2798bc1106b9cc39d2c4844d98fdebd9c95b62f6acb022688586c638c53baff7fff1cb55f8e08310be7e19af8b8a6ad3393a944970b8d361631d39bb8791923e03d5324748f2d4330ffc0684abff67e17c963f4bd2321a09cd2c84fde0de9711f33c33e30b435e9ebd3cccbe5855af433652964cbbad90fd8bb4d2f9772f37dd35beb14a9a54003b3ac80b81dda956128a13e993ccd26b7198b85bda5c1fb433b01c0eda007c7baa9b18d2f6840063380beb833da454a1ef0d12604194ac4db276d94747f3b6c2b3b1055544bd519b1a047ddc4d999ed94dd68f9eba3b8c3c34945b71b69257e3205e9147ed984db7ce3d1e6c9e204eea7aee6cfb8f73e1273e3d84ff3d9b600d4b3cca601608880d8740f4bb79e584ab40819a3a7434a5d36bda98de20ed3e12f81fc1d47c67e001d4272713d5368e5cf23148f4ee888dbfcb6ba2463d824ffa7ef7b2efc7974c66d0e5aba4b21fbe230810bd5ed46ba640800a684b5d49dc1407824d16b39ca9225b7d03267303856d79c5e1b51a3fac6822d5dc01233ce44ff2fc554e76252b2106478bd39ca5fb51e077fa80ce071f8f1ec32ddb3d40a8f07fd80e9d7ce4ed41175f2a858272628bfb8d638dca7577e49968f1567a494072fc66c423a419943bac4fa52ae20352112ec11312","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
