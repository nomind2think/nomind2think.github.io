<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"392b33f2c78f4aff5fa2e9d6842b8ef3269705af44e2d8bd682daa8a49591cd3fe346de7726ada6089be56f3e1650648325dc24fb7dc829caa64b77c1bed7a7d5ea509d7d0f13aa885d7c9ba76bbeeec3d355cdddb74e1eec3f3409f50e576e2ec2996078cd22db7bf98f710af74bd531487976d6deeb9f04970206467bd80724070033b09704b18c1b8a128f60fe086d39586c103e66dbcb82a33cb1a79acccf88735425c3298b9c26ee4485ccd2a538f9742b49f93d6ace572fa16ed7d1cea35590ea9b6921a5ff56b515db3658c4c8ca6c11edd08091cf987f97d6502ac32e5d4e23d503dbbc0ab9c8240fc1e02ac3fd329d6db9d9096b095259524ee9c74d16fbc662334de32502574d6bb51246b1c91a3eb983d2074c451440b921c48590842f4972085c9c4b5852e96234c60137362c28bc288ecee87ccd242025a316c601eda702dd9d5fb6037b9a3616f78a5ca038700cb4fd836cdaadeff61819908b439b08580d19aeaa5ace192d62114327a6c57be38178eeff1a7848f10bf71456f2f78d427049ef1ae4db85f547cbbd2ef8f15af663e0850ee676ac01edfbec1baec1c836e6b9a2674417eea251d2ae8f6c82d8e18d1d3be8beb86588f9973d74fcc44b7ef33b1d6cc7cfa0b424e43bfd5dc957d9162d32f4becceca42f913eaa941d973bd52ef4c56fcfffa11dea8f804a7a74c5d55af76224835b5b5bd904acdb2acf8454a662c7c62f87d99e9933cf36a84537779fe48dc44d994ea52b12f5f959c2ef4018e30bf6f8a2112bfc28ad6869f372dac7f0faf0abfe4ff26f8b4267023b97db3c25f5f9051a3122204d3a1b4df4165d1285752d4e3db80522e619b499be852dbaa49c9f97c59f40a4d84004adf1664ad9025db31293d9c1d7e4643a18f297d853ca8597fa249a795a0e5308e014459edb28a94576844f171d93b59d885c2e60e30c0e7b5df573afb147879eb83daa01cdd1e601dc04ba89b82d58fad7b3d8db3d6c6d118f7da70aa876fa0f42869dcdaae10980b64e395e1ccdc9f942e241a6f4f5090886457a6ebf4cdec9766246f97c45b8d3a7401cbb112083195ab2c7c054ab2b22d00be2387714e1e6a3826613b142e3b116622e6a5d40f721614a225894b20dee71f10ca93e22f5dc1b5628dcf011110666cad056c7bfbb6fa6e1a2fb4264c9899ccf1776e995611e573c0236528bbdc3aad069b0a4092bf00b43ff72d5e877199d8e4a4ffc51d2e2d3665f2d21cb91a18bc791d49ba47c16cdd6e6a2680c92fd56a857ef6c9bef6cc6003be98783a3fab3521408d24501cfec4ef29702079b117b2fa89b28c01694999ca530b7dcb5ddc4fe48c0f8ca40280d38e9ed6b89a45fc293209fc2053b38bf1f2db50182ac6733970f4aafe598573308eca003b8090e2163715c3b8e28cdbb39d15e0438ee99389812f9d4d9380f07865ac35e5626c1321651afffc64f0827a6c8b9531dfd29f4f468e4ee2f1a808c6cdc93a2123e447c40a76e5c9779d552718f02490a6df1d9dab31ddd5e48b35c9199d3677867dfc4b54b4cb49196780747a8d8533b61e5214f5f2c29f9a55eb4b637a29b265e5665427b91c453df8dc9ba7d859870663b747cb548b0a2cd30f9a4c4068f9c99d0d21aaf704f798ce7a9f1a2de330ba2dddcb4f82b7855049255a61765167d7e9760f2ec3f895007717476573c0f81cf2b6b509cc2287590326f7cff9974947c8c2027236356e32ee142c0f629717f73abc3aff74cdf3a486a19ece54faffe378a4776c297c375842e1834b203ee862dd2483d1aa33458e04e9ff74f89f9e92bc1f6dfbbc5b6878c447b859aae373aa4802ed7007536c48287537e4d86d07a9c021e1983db98493732f91a74a2ef9dfe01f456aafee810337b7a140ac4694bdb76ee464dc7c33bbc7944817ef40144133b17fc8a58c20e908a3b6373e1b4f47e66f1487cf0c13ca8b6e655ae9f3985943b4508a46fe89520c3693f22128b0c0c034963f085a4375d796fa864067850603f95a8899a6159a1f7a07dce0bfaf8c6ee7a0c4a6a3966f2cd432271df7700ad26eda417e8b289e90db9fa00bf6ad91c97e1527904ae528162523aaa77d87e0f8e407ad155c6f695d69b6d73cb4cbe89be669c4aef9909a5c19226a2d7468d1c8d9df9fb9ca519c44c3e0e74b8f9b41bb9ec2555fc699e0d6b758063404d5c0f2cee88a5b9ba576b8db6f7a6f3ff6b9b9d11c73f0f9869599ed153046a8a8d598d255fcdeaf5288c41c3700e06205a5eebd7174cee107ee6f08221c912ddc85fc9c60e4c6e393947b726d81a3fd7f242294df17c15230f6fe523c86c15ccd55d125df96a3c1b49889ab1d601eec5515447eb0cb92aa4fc8a848279ba6159b688223afa4ac25534dbc4a8959e235b1565a1e59eeea524d4f0097c2859bb3696ccdc4ac12582e43735c09372f8332a5e9442f8aaf9efa1407cf5ce0e96bd73d28a9cfc077d68069ac5dfc04a2692fad3c03a58d8115c0e5d68ed2a727d85086cc693fdd73342898d077fd541dbeb3cc870e871dcc9522180381d4098a835f0de48820dd2fb8a0a36e0cc18dfdb6c7a4f2e59392c54f0405ff71a67b7035a315b779e01c6584e8857114490746d49f201ba0c9dc53e9b4f5fe11353daf925ea4fdd2138f646598b0be1d14aa0090d8f5334505384d17c4e608b11e0359a0735353209d8950d752ea01d88a19d0012419e32a55ba94c38bca3879000316fe058506d4807b5b9f565ca258c5ca9cd595c98be8bd43a6416208cfa4c4ea7f51d64072cec2996003369fb2204ceb13195773b0d1dca8f7c28d71d9d52c7df8c5a9d0358d45ee59c244531b3dc3005b699727177421b956cb6ec19aa789a98f48cbab274498a24a6c65d8601534bd241df5970c3ac47caa1b75fad394f96a2187a78226814d5ac3d1c0aae912394f063f32fc296b0f2ad983d1f0c94ed7a63e5d43e78c928e29af6c81061f0e1bbada46c6d843f2700861664337ed3bceef57ffb46456915ad5c9953804a7a38fedbd74b9c4b690e248b8c02fba9981d0b46349f285d678cd5f4e1af5de039ecafc7477e50f9aee3d83524ab749456e633b25e45c7cc4ca30b2d87e7023daf3944fb0277379473ea22b28d5e7344c188bbd4ed03ecf4f4bc3b8f52bc85d3ae41e50f23a89ff837ab88b82eb80e89b7ec83df8419f830897bf744c1f394325316eb46c110639ce54e74561b13105f7f0eb4cdefd374153f7be27eadc2a4cefbeb7d44567522b2ef8f868944ab6aacb0efc0a5665083791842a579867867152bbf1bb9631c0d44ec336fe899afa8d35cfb5cc7eac553f06820dc4bfc04bea9375d85fe608fbaf2a6135d32a7a7be75fee498efb0442adeea9ca6c9ea3a8357ba211fdb01800a44ee60c70c131f26ff105af5e5de7e333e752b6d2736a2de0d5740daa2aaea65af75f01ee65eb8fcbb0febe9ba5f7712cb2813debed79bd9918777526114d06406fa52e7144f513c065f807f0554ece50e0a25842391f064c9291c5c31ecb4df8ddede052221ddcff96b40e73736a0bde2ef62d373fce24d27cefe5abe567f354c950849c8a386902bb9ac65a890c767d9d4215216b31a30eb09194338ff6ad3b5c7468200a41491b647e34eda1dce38aa4c6be23909a8d556dd1c91fc893f67b14013302686703f86b587d56c4ba66bc7105283ab08b5fb1a4d05623cc51aa3fab360cafa50b1c6f78218d039cec63230fafa4ddf3c194277d2d5bdc921586affc54795790e57d27708d73de726755b12ade339d8d9737944b40109c97244abce3a0fd7946537c92d97d852a43bb52a93a89289442fc5250d39e2026c0120a985066ebf51724df378947886fdc38bb2c77469287182bc1e769bb3909f12475b73ffbf8128dc9003c541c7540c66c322d3dd73e12f1e3317ac447f85a1a1d9a14c9ccc056ed63d8340988e0f6813ae4f9d097aca0ed664eaf9affc31c50d40d6cecae74af3997dfa25129a82332c95523cc763bf8c284ee3d13f6f70525363b9a5a71d59673d3116aca499d59e04bff54e6a8e3abaa7d7cfcb75b80fb394c1e9c5c5b25c8038459ef986e79ca6154240578b13692bd1292d5623d421cbdb5d9a623523b2078273a1b6195e95d7ef4ae2a4c510f75baf2af58f03820cf920f3efaa3f9195b399704b9a8d1af19de844f223a2a7842b2bba63a99b1f9e96cc896105f492efa2cf78550ec683d67d38140425764793af0052bed0bf95b9c11dc95478aab8998f64de135c2847b66fbe18780ba165fa37ea3e23ea153abe3441f325756282b46ebc3653932fed63694e785e314a433f9bc44251768ef5cdbb8f15879d69c921265a3cedb2cdc87652f2adb8c5fa556bf4d81c53f49434864ce2366a6f286e0416219660f32f980b7f2312e2ec6aa89227b8fd08d0b54210c0e327ed0986444db560f0ee1ccbd1ecc463a9e3454afeb9cb4d0f44107370559eb5c113016d27a67f7b141607cda1f6757ed3f0bb54835cc7341421b62dbda15f338eca9f62e175ad5157ea5030b67cbfc18739b853d2a329c83f601238eede6a07156e224497bb2ad64790be8658cf263e37532af5af625aafd28248fea73489094b9a5b8e2e1a9cbcd1ff72110ed89f1da7ba469594dc1f9dfb21684fad70254e35d9b2d87fdec452b8dcc7617389ca93a2ecc4e584cc111cccbff121f55b90af96717f4ab36d2e0871c34dc1953327394166fdb56177783044876369b9313a6d9b9b5a53dbff1a5fe3568d1331549a03e9227a6dc88f38f6b656b314be18ad2173dab3ac80d1f0c20d57fa5f12af0f3168998dd4aff1049fd52685f8e02fdd18a15622cb80cd8fe6304ee7cf3f41679508607980c078aec156e03b0ab59d406f043573fb1983c68cb7618eff3033b32b8cfa6ef19f8a1fbe756b4e1dbcff5818a13edeed9992e3d26eae6dc0645b69997ee381f9caebbd55e670064accf8284c97db9d4117cb18b4df5a08455a5c90ea5bea13767bf38cc29f23c5aac857201cb176515c7b2fe567260bd80997a6c34049168f8282512a1be467482e8a960d7b24dbb33a33b64e68c5c27e67fd1df2c98b2064fc41b2c7d4227c7900080da6f797163568bf12f15a9e4f225fa2daea7bcb0599411fc9ac798508b0f4f2ce41fba007d8997669f8601bb7d479066a697d9866315e808a322fa5a800a1caf1cb8df2efec27c1d150e41db2f9cb65d3f32a850ba0507039dc1a20d4964da01b5e9c54d8116a62a726000bbf6a290696d7a4d3717a6d53b853df8b1c7a2a15b6b52915517f526c2cfeb11b268e48ef83a33c65b18641992faf64f3cf93c92dd781cda422c80e8863f00cd4fa3e8dbadd1326329d76ef81327add5a7faeb494cc021ddb7cf1910c67028d740835f0cb3feeb95cdd9e0490e244c37e34f7e4c8a2b22af1f11fbc2c1e1498f0cc90ef3556b003e3f0a9e4a60f7e55f51639ce77268d9abec10fd3c25252b935f953ec93ccfa3a607901bde950078dd8d5f081ff4a7ade4c8b1cacaf970aee0d537b4412ace50bd63a37af229ef1c0875940900698e92ed3d21bf0e7a470c276191198e92d99a443a9ab994789b355e0f9d311b5fed65a6c7f829e034880f671f1ef457b9b04c4b5b0543311fca427fc8db86c93893c44095ed1c21572d94432b42f65f2fe3e7af928b488b7887c33e9becef71944bdd550a4d536d00131181ec5c3d3aab924231529bfada9e0718906a8d4d36d64772abdf54f375da8e42dff12464a3ecdc126424d6801643e03d6662514e752ee22624d256a3bd1fa2fc5211b4d2d7ac3c17ffeaad6ecf8d8a0b900423ee35f464aeea427182b877fc37f1400cf8b3c8350b83294f45ffd84b1b424d2ff6dba9da210217ad34af971a5d4057c466565f1d52160ef2570fae151c5162b7ac6acadf74bca16ddbaa36ea5f40ac1f4ebe6aa8c98eb333f7100ec76cf915919267c7b7dff317c441a047bdfeecaf829cb76ef97d6c6a74c0878d3965b01c77b98b9a54c18b5c21baef359dd43f141f8821125bcd48e6ee42025526da6895de2f49b8c1e7c3c3842ab2e5edc22f9177bfd5791ab358c6986a386e898ed57aa83f5a215d0cc18830366fcb9b9d8bb0b3a9c3206a3fbf812952068c732afa1f6a2e0d634a097e3c6ad76db28c8573a57a5fb9dbce195d76b57b397c7516144f0caf8fa4fb39df5b8583c2d78f03e0c5645374456c6c9416d80004f3e2aeb05c26a3902fc887b97d6a70fe0aa622cca7d4fcea2428716c4333a67b2e3f9464d53d7b52a22b46c17c8109203a2080b312867c28d886ceb8682b8135141cc4213e878f85be52fba08f3b9e298417661ef92130b1139d7ffe73370f01665e3e4b7e742b7878e5ad9742ae499be898aef51ffd489e3af303a1ac01289f80e1450eef26e5475f140748cfd636dac9a6209e4e3a23211329cf4ce743223bfd4bb6374b08c6efc984f0048dd7f7173a9503841eb4cc7d6848c703b65153484715b1bcb2110f09e888edf29541cb8b85daae8790fea990acc7f953dd95e6eb2dfb19e8f1a67e7270dcad7b5a30548d93b2f17ff1e586cdee7e6ce2793c142c29ff034fdb2b55421fe8e26d3f2363c43c234459d188a57efa8d8a7e83f84f042864493943e79acb4c1237c931a489bd013415c5a25da0b5b642868d3aa28d5ec0446525ff00c19a4cb1035a4e590c5bf012289354d594c67b5dd9b1f554ce8af97c74b4bf8d49ee6209ffcba53fdb3564390166a7858405bf6a886dee423107f4b1a2b8075a058555110e4c02eaf1e23330c093c68ffd7a976dc71eaaa2f34bda1a2a67d358409e11e239cc6078fe57d451741f7d025e8538a99e469e11486bab2c69a4c827ec8e7cb5767a9e1ea460ac021a27fe162c76d829cdba1f55a37d812d07d04cf184890e838d3c94cafc16946121048ca7c5943de938bc6e6119bb0b013c257443b6ae4a1bf665e38170c3e3abff6429601f0b11d87047eb055ff07fc86fe4580835cd17a14253edefeb0f9306a9c7d9b8b67e19b89d4d11482826ba43781e06aa9b662820b414faa0aeee0d1cbe4c1b6eb6ca06e03ab9a0b13d7662fc1bbdaebed08abc3282ce4ba8d5883a528e4c408b418cbea33c7407b8253b8fae4da7cb8a0d8c6de73c6b1ab87b2cf5034fe1215c5378703d168a3200f15f0c3840eaa4758b2670d30431c9464da6d943825aa0e4ec186fe8aa7d82d21ba3e2d9de72ecc2ee5203474e763a52e559b7ab52ab362428890bc7d7d31d4c0ed634b2a08927359135218569f50a00f08066c7b8d24347639179481f636cb3a1b0011584f81e83f376d3c5527da0062b8d9b8a97d8eafe1133a4c7bcaf8b7e8182b42ca02fb86ce6edcb5834e8ad813c1cde3746e8a5da6f3c8eec0b21829d3b63242fbecd776336aaab665d1cbd90a73d2af2665d9e4508a4ad0fa323ddcb21dc80d2290ab3cea165429f8804eb07c8d26628687f455a06bf7f3499ad7236ff1da6ff33698069bf730aefc15e0a808d54284e63e71a3aca476492473380474373dc31877949bad8752b6426834cfecda189b75cc04e3b4a39b3a13bd1da3081407e4d3db74f2dc5c90ef19d09e73acb3282f8786efc217a0791932b1d21ef2db741da4c8d2e3eedb0ab5999fb17e01f678b5afcf032cbd67d3afd07e4ca729b3778a0ae007281e878088b650f755f294e47e7ba8c5bfb561a6dd27eb215a6ca635442df468c14248975592a785479901e7a58ef5fd23fdacae67a1037cdf10674c8dddcd1b9a9ceb72280012822a3748128ba7057940f25addb8495079ee5a64fab8765f11bb3546d61fd736de5b890273061f41b6415b59bee90054e5668c3b1de71cec223bd8aaa97dda6f1d6d4e12a53693943d081c1365d4300c0d913322bca81fd481e0046fdda66ff969994474468ab8681a8ffb13c0be72c78248c07d70d4205baa8d6ed50645aba84d36c66a09a09937e74acdc9975138e2ed3ad984af03666db02ebf3737dafc4389b9d4621916784d7ff42dc8e4a950865d971797f02afdc84c20a27d655d91791b545c5e88d1cbd0c01cc0ba53f8e44132cec8e922ca04d3c9094bec5d7b4a022ef8bdbca1466c2b8d5abd82477ce92e8a6ac536c15550a4bd87c564afcee561c367ebc2ebeb7c3c01201628fbbb1cf7130f37e69732e5c6cc23c3d4002a0271bc3687d2a82369ac47b6df8b1d9f09613d8f35d9cb00167bda851d14227b97d1d2513d76a60b2f4e386909079ba5b3b14402948f0f919f3e361631bebd74ae583c853ce57ecd21cc2b8b4d04eb99e622621ff98b7aea6543533eb7091935427f82407714d6ab672e1f45eefa681081f686f1a0c71ce6cd9f6d4bf7b746b1f67883fdced58b01861b533b617b1aedeef25387721a74c0a85cacc203ab11a7b30b0875ddf02f712054b04cd8f5ce3121210dddd00a83d99cf69fd813bd7dd7fd99e622fa2006a2f57544fd0a5dc18cd9b7daaff47f9773a1d2f714fd7131fbcc18dbb10102b4debb4592ddbed7567b40f05609855be5c1ae407f6d1e5f62eeb339e47283d04c4656978a7a91cc53d20bea07af1d1b65c2c48354cebeb5be22d0fa2ca079de719dd7e51edb0ecd52cd4bac82aa84dc66cc30fea72f96356e1a5887c7e15f640997a9ec1883757c47afacef61a8ac57ba90e58d0bbc507981e81091112a88e1ce99d19dd44c977787376e05d1810eac475604b222bb73e0c2d727235693b329106a5f8713dbda4a87cb26cd76a9da42a671daac4dbac332cd457162ed2a073da1d69d1fe0af1812c8f9dde63c2c55f055d8527eba930defc03e2c120426a9594cf7c29882f6b30817a3a43bf1d9df71c0f66e6198c41dc3919c951480d359281b746a71a3a7559c1c7851c0d3577b4e02baf2519d20d5a532882eea5c8065a106adb1a2ca3906dcd7daf7e53fc42725945764ea2a7ef3798c2383ece59eca93fa99b177bb0afb588498cac8d3041cbb9dd9549d441587457ef203e0596696da1d697a88e5bc68f99d95d0c57dfa70746e100b25894b7a7350877ae43ae99d1d00523921ef91bad3279a41e44a0d4b01701ce96e5ffb73f56140b3d1c2f1a501b8b3a2296c7e3734e014b42216d981d13e494dff6a8d08fe81a560ef69f3f5f6d9c2dd6a65b8dda4d693a133d39a82e34138ed634bc43e49017acf5747a9885d8fe984e3cfdcf2de7800ff957400999fba4959de229ecf01b59ff67165ae45ed69b4cb70db36909b730e615f39c34df7463804db68be7f6ead2a537c1983323963813ab1df335e7d0bfb497ced6afe32bc8b2e31933e76a138c52e7040ef7862d243e5727f1e8d332f7cadb8c9b6a189b6c7932c7a0932c91467a2fa4ea52e8cc3522de47ae304aea55ac6070eecb52b1c7542410516134203fe1a55590f322616ec510e1a2396344cbef852f946465609ef04c76b7f675cc33c859ad319fcbdb8ab4713ee23236d89bd252990102cd9615f3f5c1a2f6f35cffee4e156a274587055e341aaea8fdf18ab8e0c46678cb0f1d834be82a7bed8ce5bd6c4a70453a783a144bac6287428ca3ec9aa60f433cfe975260e95170f639e8970e01e540bfd9b75783fa01baf0f1537162d939febcff103aa7b5755081eb964bf36c9c80127b7642ec2a634b0d098d18d84b6d3d76d2353db2ed15a51a377ab2eba2c1c4c1d33bdca119ba41ca07f71deb712f405469f9ad31c583c5b1ca33351ca853d4e42aa7146f67172f5ac170c05a86b7fcf021c4aa3c29fba660877ad9d15ee815412b6cb5583e1c65fc15c4b6420793c3b5279ca146e5bf9b89a5da61cfa7e9d256c9902c07852eb6575830cbfad1ddd1708be7d5e11790cdefb730263773e204fd4ec368855d1c830ca6031a08d4b5fc311c5da45a46792e7c1f0ac5b54db2000dd9edbc76361cbfa82bf0e76087746e7770643e2f7483c8b6be291cd34e847d1c06ecbffa506fa86b726b44fe1e42c09f01ea7af64fbbcf4a94abb8e4848ebcc6e127e933f498cdc61ffcf42559ec425b9842b3995393c6597b499951118ecc90835eb7687fca7b47bba8123715add4ef2634381fb53defd0637d1372cca496a9abe9a4b935946582393da73f5382106b64355d83cd6b4daf79770880d780c9a03727820212323fc7738901d81a60b238e4c6ddbf07ef93df12c7a85f29f6b78c737df05af0dd7cf3f6781f0cfcbde49713c5011b8dbe51733952521c0a15238e8e9b26d13dd18380b8335d5d4b4a39adc58a25eb02205465623c7cc1946357cb35f8a5874242995be4b8e2e978503c02037a6ad24bcd5b10be246df65c90abff078981ad694cf0b9db749a9ea1b21cd382969435eca08f53febe79e48c1470db147a83d1813d150505dc5eac5de80a8312ef3b7bfe77079ffaae62cf20667b0dc9d5b8dfe5898d39537a082d0a30c2142f9eb2a873347d892af679efbb132a0fa92561d22da069c23fc955919df172f0a301721bbfb373bfc53e64db94eaa2febab410bb6a46612b19ebebcd364f25f2db40791e96b1596cb85b3eb51bf3efbf82eb4cf2a6f14c967ef8a8b39f1aac2ae654efc3996418199206224fb3d7dd26ac40935cc5d72966e9303ac0232eadef6712fffb85f3624184b00bcafd1e884fe01b8197f837669c1179432910f68dc71b4bf70c6e78b89dcfb5f71ec830452edbb82b3fd08b78bd1c17beaff6a9477a40c9b27cd9c9357ecbe0acb0e1a02921287debeeb18d9467e5ccb0fc80baa4fbecfba65653716f22","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
