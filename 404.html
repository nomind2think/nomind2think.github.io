<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b33fd001b73a1a39d12d2df8487713643110ce4a4077b117f8cd1e811bc60bf5c5decf19fbfc65e393f320c1422aab6910ea8105c968025552b5593e52eb9059d6ee2b5256e2e770078caf9d468c95be7db6792c1db66ee1edd8e1740c3a7e0ade40453a63c848efc0716d02dad179b6373e02ee16622967dffa872366ee1b10e4fa3a8a1c0e225dbcdeb07ae62afe598cdda0b712a5d7d046144a662cc64171ea3dd5a12b4accc7f5953003e9adf70adb193a350b8325841cf954a0744f2f14da8fe04c38e931b6b0ae5a95eb36c917ac19bd339a23fc6c2ab6f586d49e56eb865add3a40b223dcd12f23afe6bd08a67cc49356af7d48cb1184cb661e1b88c37ecdb1280f4306eb9da7c5cd4bd79f8308580edcd791acb96d557b7a728f4aba5c301d717819d79d7bfb243f9ba52e61595c90987056faf030137cd93a2024da117c664cf0ac4d07dbad821553cad1a1ef968f829749f89767be16f8376e37649175ab116cf3fb7040a27c7c2642744a3f2fe4d27f18e3a82a0ac590b0d1fcae3ce4438b692afdece3ea1a4a21766fdd9def3e6d203bb4692e08269e82ffd077716799fa1542d405006c5c8f92dcf8b288c423e65e74cbaf83fafa2c774c83dba3a62a70e4cd0cbb8dc38ee83b2b181b56d241511bf164f97a751c57b1bbcedb30eb021a3aad580cc2c1ff47852ae809ccf268fd2ad49e340a5c9ce20023f97cd06263ca4fedc1f59661f6f9dae6d4c9f8eb63612c853791f54398710d790181179ebfafc67d417018cb284ca3b65484e4dbc2b09a66ee87aa025216a7bd85e8b1ba1aa619b22fae75d9cb8ce3af99a832aee2533f9786838765fa188e8108a9608940b5cc4e796ac079174ac884eb5f6342b4da8bbfa33e5e75de8e7aba8ef4d46d3c9c92a01b7e5ab9d78b8a45a368fece408cd2cbdb27c7c2c3e5f25aa61bac3397f410a1645b58c5a5d1d5a4f32969a2e564a7ea5cd083d32926fc44917112c6bccc310189792430ca0131cbc6a6d640973ec9d0281e50ab85003df7e3bfe786624745d33c58a2f693d79211e6b8018f3c6c1363efb9e7a47e492cc71ed6394ecbe098b9ac3776592785b06c4f6021feb14d89f2a19768461ce4e037129db33f487477c389e409cc60213877404738e34569e5337c74f5231ac10bb8751e3354817e4e587ba71a1e9876a8581f5ca625d1f21d6d15cf00f1b3e896c0ddbbf056309e96a40f14e123369c564d8cf2c8d81d9f69edda42261b000a4455135196104c7053868406f6ed74f8d0f56b72ca215811200e1e9de90de25d62c979c1c8413d590b4af989b75d4ac2c57cbd37b57131a35cbea6240290593a1660935e1c300c8404d99462a35c2e3d9bd875449b16b293d7974c925f390dd0d4cfbc37f4a5053d4b9be358f37cad1fe064238cad5bb57955bafae86938443fa82cf9ab0a87d2443dfa5658daff85ed2c818f23e9692468811d113afa5be8d3e0db13cec038588d8323e1d97fbc409dfc58f9487774735f5829a8e2b3f492aa90c6060d58f506c41a1b60f653b2aa783b02de12f70e39dc05fa4ca8d173c8f03d0f17a2c52343f8663054022dab2148d29ea71b666d93627f031607ed42d97467f5979df4898beb28bddb84efacc7f7ccb759e1f77f776d5ec05c27d1fe95b0c064125f5e6282e3ca13c36eb9fa276da775a15f3be004899068f8d54ab3df0611211fc42a8734befb43f3b3e7adbe32adc0b149df1c6a1cef77f4c39a9f65856b5a0aeb4417f3af0144531e008667c76b01b0febb24150f78761b2a9d8bd11e8add0d170775abfcfcc2b400b41a6dfbdcefae3b9b555299d18ff584b3d95e610f275cef7741ec5540c5f0f7bc96bb67774577c16fe7057226b5a942c40898eef78dadff2be9819f3e7c4770c04cfee7a7edf2d94b11e52da70205331db301a0fd2ec87929a4a06c0f73a80197eb8d584e532f5d3e46316fda8da1e98987de57a62b62e1d4a69d305f92a3b05ff54884c3818dc60cbf6d845b9ccffd9d6d164876a2635f5823471c0427f0b815bd9025f053581c9632ba08fac2db0f4c6a669cd51730395a61a067569299f743f7e7f7c9aaa1a211f16393ebc0e3ce9a17564b9ea55753c1135ac91911a06d58bd813541a975ac4fceb872f9fbc0eadc2b142143610f4033e99cef1ed14ec9c9de52571e4f96f53fa7032a6e99b4cd3ba5139f962a7ef19716b64b5a5ce7dd1535bc52f84dc88abbf6e5502cf2677ac95e8a06bd24d32ef6c943cae700bc142086fbb18a0421d38f21262afd3c5876c41f4209d832f0ba2e134e6681ad50f52f7b82fccf521c3d6f4347fa17efe8c8a896d3a1032b7d9bfef6596a698c5482f7e9368502a51523689491494e2ea16d625f2dfb73b792dd7056522df8e787d6732e787c0f5dbb30ec12fcb8f182b811a3cdcd77fec6ef4d54dd55bac8749ede43bc338f4f2a037237a23389ef1098094935c2daee7dbb3378f2336826463ae495e5d8c2635eeab4596e09af2e81bd3ce760663667eeac4639058d85b3f9331ac2e277037bacfe8236032e009c5a94bb49ca3f8cdb0b599672bf28da61715cf984a0cfa279744b767c0c2fa8efbfd5f08dd92b826e40962d05ac1a79ed31e2d566c08d251eb517d59ecb3a5d2c287a7b5578daa66250b32a015cb4e6398b8a313851013a7c0a8fb58207f98a1cab6cf2530659f5af66250c73873d3be3900c41fc412c19d4d70c10e4d319517546994b6de3fd6571ff1f0e2c9a063600ae2779b48378e9e7dffda4b21dee5792bcb3ecb750545eb5025299652fa56eec3d80f596d82497b6dd5c4669eca8439a3a302c8f76094d4b148c399ac2426fc1a1a550928acb89b910c35f8719639a0a8a5761e8a5abb50143cc323b11c1c4880b97ca7203ab483627f2c35e5d959c3d66d57d7c2a6c5d2bd582e066047ef853f55de4758dfc9d4c11f0339f23c0bea8cc4a3fa0ab981d01f157db0e85320983f67ec82a9b6ad4de9fc3d9e255060de9cd9ed3b30d857f2a59b3ea74701970856520497b79a1ca0a1a7569e0dcea74c2c134e59b126406a2371112e6c7c1253589b305445d1f79ff821cf178eea466151cc4c9ff9ba42703ebb598983d9e1cea2c57994509a96189294e3ff58963d93611db28e35b7d2edf1873fe6a26dbd59f79e01817126217c0363e438361395af8c9c0e1e7752b47ed74b167844882f8fb9f116f860aa5779962d5b30dec7611a7d2eab5aeb71a3c0b8387fbede457a6b428d5e57acaacdc9f370d0d7319fdcaecce81dad883059fdcae3841c5af3f024466de1674dd6232fc6aea120a825e6a3e86f2c5352db8da9dad90db6af798653460fd7c0e9a7adc4e17c9134fe74981f8deca661f9687a6337b54bc264703be03aeef7b72204af8d07f4cbf83586ec11b27a6b6e751613dca7d832e1977dc1c169ecb07a83d5f5a67ed2249f0c20a1a58aa660e20d6d444e6e90b6cfe8d9a5b781c070139a6409ebde33d910003f782df196a3d7378b9f9df593e74253973bcedbf8215b2b7d15c2b4c8daa06f5c531c21065d6ee0cf633914ca6c05a4c68abf919b7d4496ef03bc6e1f415ccd85f3d1e8f56fd191735bb460f1c1990e99832954e90a21d5d7a1a900d58737e997bc0691eb8d83a0bacf3c32a62ee147ca2b9721488890f7e0267d0e7e1b108e2cd020662cc75008cf26e84a1e98dc62e942e50a2797fd5254fabd2957852cf8772e86307aa92f66520c7612399b346074565f3f5dc7a027ad6da673a6372da33ea746a25e1892ad78c3c3eb37d93e0de3150a2e4b43c11b34a64254b2aaabc1adeadf10f356601915a71b127fc80e7c2d70bfb96961bd3c6978edb93cdb338513b0648de4936cbcf9fffc194d23d434802b6654780a5442fabf25418763214866dac961d7810ba297b0f062617d3f7c515974aeccb103a2aed4353271df65b9743b6bf74f8934ccb8e73c36685b3cc95423912d211c83b7d3bbf4e8f1fe5d8fa021b58390935046cfa10419833639299ee12e875b22270a45e492645036f5789627b2014d7061a347566f0ec32c62c163cb35ee5c83fb8ed3018be56e86b1ccde3b01110968ad83ca6f8f07c21c2629e86cba03625a6b258b361bcfeabb31e63dbe33e9352965639a89024ee119631fc42cc5476129d391881e76b75924ac98ca49fd1952df613393e08dceef40ec0c65b7c915651d7e584b29670c117477fbe072a7455cd5a270f1522703769f5a8407057ba02c7661e55612b0516b1de97c2d269324be0256c44b61c812050c10ed0aa6cf2b8eb07c10021cec70678de81b31aaf3cea9d421831af6ff09735055463b9fe99627c378b9341853c1c2f8b93ddedb893e2f4aff2f3b1c8aa7ea9de97711c223415e7dcf50068c68d3c5d6316a923fd89f4b1c306abdb6a120832933d0df7b4f12f411771e322dcb191c651511a54910a946908468282ca7056c6671dc3d900f4ec6ddeb87a7772231f4c4d6de949072539c66ccb15966756447db87e81770bc83e37b3842c19c1e9113f18ccce9529843e9f1277e7a18f524efad0b831dd33407d4484f968503569861ffe6e30bc8bd2c1ed584a662cdde5efc33f672c25bdd16f5375a949d8a69b39a9cd2a630a70570a8bff4b356062f9ab72866ebe96c27b59283adc2a73326d1b6293ded5babf664d7327683c5a95275a10e45c62690d6c7f269edbbff0ae6d93bbd6685f19a0bce5e9afad1700a0da53f115130ad6aac9d7e3e7ccbf095c81e9a31b98544f5e435b67b06374315ebe8061049088ec4d66a985ccfb21ab0de691951d92d8f66eb84576b1ebad5b992f809814b004bddd1be84c91c2b13dd54438f55bced2ade551fa0a9c199de1d582478a1b5eeb6c2b2d45a1ea94891079c41aad834b7b55c9d97d4aadd57e1b039c6d62946bdabbed628653de11dd847a6626cbb207c0988a959ec1ee15bc143b7e61aabe24533aa77373756bf1e99dbaa907d098e9ffc712ff9e76870c6f07fac635fde32501ca0986b39ea0c34be80844947e1b784b67810055060176e8fc720865e2877bcce125bc069848b4e2734da9020d8caace4df1eac82f1cce25bf396b8187de775bb5f372f58d679f2944b0096303c4e5b8bdab56130f4d154456140f7ff26c9bda67cc85cd0b8f86cb32714721c0ec17ed05acdd36e79e47cdc4ee4b9b93376695183fe5849a4b1134aa05622fa028339275c086a06f761b3ef45ffe412bfb355f366e35b61897ae6e0e907dd74c503f8861c2a2fbc8fea7b088a0f3964afcad1543df08812d4b3f67dd5748724a689769253d4dbb3213f7cf1ea1df589913bb98e38aca1d953069de21788e721ad5041799c73068289d5fad33d6781d3716b13b7f16674717e2c258ddb814b3493ca007e85b6f4257c60c0b0522e7e148689fe1ac32e7f75461e6c5eb7903ed98c9fc1836a252363c991102cfbf452ac6625c6066fa5e6c18f9e815ab19ad2f03e4514bd1b7abd63a2caebb63b5f088b0c10f5409624ef7429de49cadfc2ad5b408b0b9a63a682300aca23e3f95f166da0ca0751b8f47106707689d6ae7b833afdccf0349d6ea42a89e95402d55a44c05e6743297779fb8ca64e8de8d382fc6a8121cd9a0cd5ab003092aa49619c56394d89b2657db5d862a53ae00e50d111279ad56e2e5c0ab1f5d5fbf5f35dd272fc79d74951879bc2bdff1b2307e8649b3c67f4bda6a9061c186561b09bced7c9b479572084e96fc418eef84370f95682c603c3836fa06ed4041461732e2697d7c799126488c599f89c26d67371bb90401de3697eb2635ef104fd3a4b0027e107b4aeb94c2124fc0eb42540f3baf459a8363ecfad1b7fb2d2e5b067be248fa819ae7bc33c97969389c06ed5aa4c758e1010c671ec8949ba4d8893bad35f454b7cdcd52af0ae7e8b64d78c2dd557d6a8ecb9baa9ce4103949ce87ec05871424c0ca8c2c62a7d1bde42362718d00a0296a81e2f76dfb751fd5e2b215b251e6e30c0fc36bf39796a18a5ff0231acee7c896ee79941173724bd9a3b6c1d5891da9a769faa8140f19936123f723fd9cf9081e6fd13cc5d3022652e12ffaa230dbe41005b61344cefc0833770fa5b5c8818b04184ede628ba6f021b3af9a57c0936bc4ee987ddfbc96e04f8737413429e762a089df5e657f2f85cf3baa110b1fb582fae13619ab20e79b7b9609a1394b5a002a8750a1bd5d76ebd1f185552d7a49b63c9e6656832dbed0719c38bedc380174327aa9810d1636baf1294f4539ce33038fe0c4fd47b58449c1ff02a1a713af261e1aa38190da3c9d3870645012eb167e2db8cc5ec5b0763199cd6468ef475722e48a74f2d091962305ea7503298ad9353dc6819b1512903cf4e16913c63c27defc8ef4a2a13f63ca50bd76c2f319970f3ad0d69f4666aad15ebfccbd4cd2f5c347b438308fef4e9415a6592313bb79be4bd86a18ff57c4474af3164e6b45e27a1feaf91ef7ed41d2bf6ff3f1affdb159f82c4d4996d9e8023f89d74752c8e7042a9c59253c5c3628bdf3a4b1687afc70819fa3445f53194758bcc7f4da732793e7c4d93f6253e7cc70956fe144fd1b73dcd1a48c187fa935b15d308d8238923814bdaeeb712dc0728df1c9d731ef13ab598b407255ef86c609e5e6dbd3f82d9354f930753d133c155b83e3cf4750085da2b2b9d4aab07b1cd56d9745189a28eff9b72a5fddefd5b937b5e5e100a946e7c2cd92dda9cde00a67aa156089fd6beb88f2fcdf6e917c66cc5313b1e54db7766100821054da1880e192466f9992bc5f92fdcb895cba8c9a8a745d9c1ed81f1ec6c6b09c4f19a81c968118b868c0a784cbb13a55c5729dcdbbe8d46257dd987648a35d02b432fa17f0c9d5dd2cfc58737ffa70d304e179999a6e63d8ed76e8176ce3053fbf70c84766dd215b3c5ee989b477402f870894268d525bd5a4bd5b760f9908f6fa39cfb494a3791b6b2813538e061bede680be809406b7de79e4d2e0f473f3f03a5702e288b385930982ec403ae9fc0b60b1901dffb128a5c02eb03fdd4912b04f51d9d10c781559be02bb39043edb4ab60582cf1bd3ba23efcf7373f8c5275026ea5f10893f539dfa382490b5d6b4e52231d8575ec5315f94e4ec471e5e846b04db469f937ca00e8c1a0b76c1ee78d8a83fe9235334ecde49156c33c3597eb982db980414b952d7c180bbe6b9c0bb5194538d688c8b186b5f964941983b5fec258eb61e517663e5eb2733d0d2fb8fc69b9db22fff3247585d392ad2ca3729638c8abad0513d8fe487d92394a02bb616f31d05b9ef853dbae9a07fdb47448491ce8b223387a40d6a7dafd1027b9cde12d83abbedd762837fb4dbb3035d8b0671a9970b93dafdda1fe77d14e8bebe54812833a52b1e1e4bcd88d74a20073f4af792d61ce9da786863e58c3d0690168ac66d364f59ce3d2caa647eed458d96309ae925a7e263075dbf4502d9fa7dde3c4d4135d79f332b5285f79d02aa4f1a9c62f56c503479883929a6e98043ae72bacee8c77aa45d3360d203db0716eab1d8ae6fdb7ab3b42a54872ac801cf11eb6f310c3513e0742ccb61497eece65c7c2c4d972af432103fa4c71c7d970d958a2f4ca6d290c384896c1e61ec5d7f4aeec16301c4d9b15769c45578c4bf56800350869d0e3aea97c330272603f6888de02a0afdc8872fa7dfc5c0c09f5a8f6f34475f0e1b9dd65730a492a4e42611a3f41b6be0e23eda461b4a1c965844b747d3ea7cc51f9cd7ad05379f1726e26314ba8e6f53b2e0d4a408bee8dd576a3409db3c2d26582695f989c745ea7af3ee868cd910aeabb3dd573c8fcba6daa249a99ff5d8bf9e9396c834412939e44bbc19f466c0cd2dd9445d4ba9b01f030e9833b607cc54a961555dfea156a5d1adc753775f2d35e406c44884d4dfbd4daf1f29f16e273b99c84ac31685eb502ab28eba96540d400dc20c5cf6a3fe36f6237671c2b7e5e79dd54de7ffdf53b562387f327ed697dec9a3193aa13fdd5c4b224c5b9e530ba104e64e017901c6e3d5673e59ac2423220c4ccc8d08e6d4de501668a82b8a791e70cbdfa48b48356e4a357e238972774470cae4ae33151046008c7824821612a43630b894f04cc30507df2e4edbe2fcb261cc28c47ce09cea21b8eab1d74935daadca5213f0d2c7aa5ac4c9816f423c23f791953698cdc73cc8ab91f2f879d5c4af6bdf8e137c2c96d895d0b3bfb5904060dc205d9d9d04aafdb1aae1c19a4a8452aae1e7b3c7a769c9af349abf3da283e66c732771cf0e5e943c2ae2a2a2ea59fed42fb2e29b6c6f048451b1203078936c7c28f280900a3e9e763363ee962bf1184ba92f8d64d82d95b71fdaf6cef21a38627a2db485477650a6a9c1fe1f84beba527c144cdaebfdec1e9c52bf6353316d514147d2b8cfc62f2c9399486a140a6690926631fcf85e80f6dd33dfae42877f1780db05360cc9bea63ca33c9c338a52df24c3b44aae0b4d7da8eeb5e09028e5f4f31bb57b5fbff9c1aea7870f4745f8640e51e7a29edec78fdbe9249ac99cf161c716861ff3655c0824a0ff1e5f8a56bc51b4884bba40e7eac46a7615d9f0e4cb6a8163e11f71f40918b4f1e3ec59879dfda97e54a41f91fb60d8813128aaadcaad93ad5c5a36b8b6dff5a9e3280b7ef65bc504f10ee973391bc18368404ff5cfc13969a7321ede2f0489ae48de62b799441453b3efd406e79d66683677e467e3b7f6f4a7aa6d5058d04c6ed66481735e39c7b319f5a65f241e6f5222342d5a277ea8e24ef2cce91e4acc5a43f84670e2db428002a0b076f3896d7f57b6e035f7ca08213ad122e4d74ab7d8276a0dbc69316c51b247611076be4168187918c55c0d8f541a527c4a17ed72386ca55cb1a815040e6366d1d39ed0cb687b69","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
