<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f901a0b7e4145753cb99dc5ca4a2abd2c6d1ba65445c85b81d871c1ef07486e4f853ccb942f3b11e95a4a848dd17a81103ddc2b1428177dedd213ea2c832846a639f42792ada9805ca362e5999b2abd1c94e111264b4e01f83cf9dfb67d1c8fe3c3e2a33372671df0a4a821d37421eabf6fcc2c5f4b51fc86b7772de6faf42e33c8d06e12d4fef78657943f191c3817fa4974599c9e1ea949c43e29eb8ddf87f14736afd834dac9d7b811f2de08785914e8638465781f99761b83b89f0b64ae875bcaf418e6bb8008ec8338b0cbab11668085e18a7d1883c17d913f815f9da9cf46887ef9a7df631d8d9e62c3e578559d717eb370e7acd4be86e99d4aa1fe48e681802d256f86f98ce5d1a40676e1823dea5bd9423c21ed0ede5b3fb28967ee1994e6bcfbc21c471f44335df8c174e9a2ebb2fdf39b2149dbc80479a47ff577510ba39b6a70dae5f43c02c25bf914843d5f4648cf1fd300700ad6d1eaac87ba050773a73e9e8d2f45f30bd761dd08330756d9fcfed9bed97d31178780092b246b66c4e368a1d50b901808f31fee37325f977e4bf29b023688fc74531b0b571c327d8dcfd5cfe705ebfbe483d4a6bdfbc6546912a82690d0fee7036690c013de236c229adc3ead026f3d6051b79bc8f6efbe4a305434667030b56d2cdf029b56259c85898e5d5d3efc7169cc546586c5f5f8bed24f9193518315668be06e5f91d131af8b84682ece2b8bc7302d8decc771d8609640866451e697e1593a8e52b7791c7d29464c1f7c5d58cfa80e6097d74920c41c9d7a800e0e5006978babd77e49470339ef57986b0fd2d861170e50cccde3c6dc9eaca2199e7eceaa9b24a7d990993061d6081a49d6d900da427c38ed531d2e53538713cb531b8d49816e8ee1f2aa561c90ca490dd090597b9fb8142d01338239c924d8887f52587e28dce13fdb9a280121f6a2d5b160f1370ea0967476549137e838fa2cbde910f594f5a730b566a87ee72dab225702b4f55c1d9edeea70d70191f0e46f88703b836f9b7439f8c10b3bab3f6850ed2f075e86ef522eb0f9d9386cc7108d3911dea047dad522084724e12da5a1cc01a97d3ad7db2f2197a6f6757c631a1e70fe59ebcd98ee3f7dba76d1e294615e3cc993f285364f32500f2f8a62433643b258487d1a173ca078dbbbe8989c526c8c2282f3276e51b2de1a36bd16d4d54e5dbd6066f8c1f9bf6a72ea78bcf5e7130e7648019d7d6e7c223d95c5e4ae5a4a0f0b12623c7c8f5c7e89576b2c4cc07147ac0fdf58eaac1c0178a5fee85ddda5083b812d1cb879c1bde56f6e1bff5e075d1f8c9f3bcaacd8a10693c9f247b936440be4aed7c296c2c4acb7e4a094bba7de62f8f6df3aa50780642cfd997d4e53967792eec7843ff25253b24a09ad57d30d5c37b3b04372062ebcff912df32123a6795293894e62576cd1547e671c4e87c10f8cba12989e6cacf2bc78a282f8348bc5ed733277014289a3c0b85c4e3ddccbe39a37546adf1ae6b0f772bc9d25b303b08c4ea97cd4531dc8546a2239394b821c72d9a069da52aa07184a182a7fdb5bdf829cb0f5d79b8fe819c7c5cc0bb1d8983294b0f03d3f4f22c5fb673e6085c7924af6f50473f4d604febb56a9200216b142cbef2125b0ab0bbefbf38a45d40cc6553a10a1b0e9cab476f9d2fab9eb8d9af12a99d84e7d3a2fd8a6b59fb77ff62184a498811a19081df9613631bded085c9cc38921cb335611fff4cf0f3d2ec6880fe997c59767107ad0f4ec73c45d7ecc138b695a9ac7f37b4ca90511c97638e2b99f747bac9e3ab8264fd9ceea012320ccb2913d805eb1b6a6f9b9688fcff2d86e343cdd93d772ff7a30d3129aacab15d83292f951dba9ab837f43731aa8e3ed687e8c456d3af2583f7a498f61993b89de73c66549d6b72a9d002c15a67d6035fca46218d32ef9c8ba64759976286de3eab5590c4a90e7b1d1a5755ea8ea283a11efe3b20bbe0544f1188f0f1df5c5fef274ae473bdf0c0f829098571af2b276847560ad588981aa53577bb554c598f3aec9d4a80b0b014274977518f42cadf0fd26a4a108d58158bed463549b7d14d004f1b4f942ac2e21179a02f720fdf39966a1e0bad9c40a4c20693c18694da5b34a165a4fde31b652af084bb62126f4ecbdd60de862a45b94e02265d9efefc67458350d545712a89ccb7d1a5b1fb9b228954e970cbfdadd5b7b0935e462b87e060c6af8edf98394321667bc4fcdf694cbe7b6d8ce87d4265c36f5d516bdc3bd1d084608b9694ff610eab151b29ce33a43f44be1a5c43da947d966ace0010eacb741b195f31c434fb44c44da92a75df6db2d2c7080a5f8d9d928c8b7e48bb3e8c01d9dbaf67c8288559529bde53370c7ef68e1fa16865069c2e097fe09027a617f1c635a034a815e257824d25512a76b511ba97115fa065667aeb17eefe5a84f3ae6cc414d5b8ae60f1321f65f5226ef168cba52f9b6bf2ba53ea887808dde077fecd4a88ac22b127c68557002921787c1060e1d63072b48dae06d33c82b59cd6a7b16d58e0e7f13f929a7bdf1ef62116e46fc6b3fcd2d7b6efa2ba66b606f0f63fb324643561c3f859c4f84aee7ddc5bca071472161a9d3336727dc65db80d6f76fda80e18d2c2d762e0ba7234dd69494bb4de53871832367e3afbec06eac0ada6e428ead29a44b0480fb655a6f4393ecb192b38a892a70a2cdcfd9ecd446964d5acf1ed47dd613dca8ea46af544090deeba5738ba1223b7b85306ec09141971c948b15195fe8bc230d20d8b1c28a3932c87ce67a86133eb48f7311543d11354b045e20a3f6f28e677e28ac54b18651587713a71e82c4ff98ed9eb416f4576b0b98cae648c03b9dfd0d1a73d943eed57c09c4d34c8cff7ac439072597de6b3ae698696348f5d06619d8bd415320a7dfe65cbd965dacf8351bc8564941cac16b407ec9e48ebd8399ad0169ac7be903dfc77121f05f18eb1d51b009db0fc3084833053c1589e1f82147427c25fd9fd4430d554679fdbc57f6fc8ceac4e98c9b2c31eb3f75483541c187919e6235c9d07c27f240060b4f1db28d2c5a1197cdd39c7d15289b73d8e3623e2ad7ff7d4f85df297b53a87d34156d7c26ee131f83ca0c76ed93a24b3af8029f4b7d7adbe138edc6c1959b2e966d092a7a08c961785060c2472deb24f77a18283936ca1d44dfa23b4dcffaf95f4adfdcb08bd46603ec45932730f3423d8fa183de036e30ff7e56c2029b03a2cb0972c88d808b23eee376c886c4015675449826bbba2273111d5116493bb5f53d88f07aacc7f369b4f7c28fd8fbc5ae3207b6556112ae29a1746482de9942b40cc3654e22e18a5d93667e6c5d76608bef9e9337c29a26af7bc948eed2110f62fc6b35559d0f7e38f045daae402eb1100ac0fcc5db7f2e3e5a34c9263581a3613cadf24b6cf514df7866516f863c384d4da79e5e41b595b3d745e497b6862dafd25f65a167cbfd8bef0f38b87d699b4a114cf3bad0f4ef43e7d211e2c22a0893960c2758452bb425404cfb476fa1e53e45e33c334010e06838cd6da13f4ae5496a142171d2eab87486ea0f088ceb904a8448238cec70941f220349744837288d9b856c735db7eb530b0ece7afb931c1909a17a260b491dc4c1fc4c52dd92a7898bd22403e69c2b5584660b50206073eed6f099f7901266615598141b68747afb4f2fde3ca5ed7c971748af9557e2ee1cbc1157fdbca57eb1da1252b647b0f33a7960e517c74cff851b90e6c0bcf9b73308e6a6175fd493e1603a3ca609fcdca6d50ccb00fae8944040c1b90b01e8ff7b9d8bfc55b9ab3ac0d3d82b08dfde75dbd7baf1ecfa892f85d3d8bea34c0acce529201edf6d26adc80accd6ceba32a0ee1ca0b6bf331244fcf35fed73c55ad1f7d1fbf5b4b649ebde5ba7472e7c4d9e7f91e398b2002784766e563d6b4a52ad87958f3ef95c7b990b8df792454c98334329d26f98525cdecc0078b72bf9c1ddeb01d2c6be81be1844e8fd009b26a338b497e5c2c15635e3fdd89f71b108d9bdf68779103a7e2f22331aa926deab7022969cb34b2ba80d01d59d73ab2192fb87e4992761b25d35686fc1a613e958329a95b96829a43aeb33f6054548cfcda26f44a6db2805fdfddecd5d3f17461faab93ab172540ce8f7d0ba7f28dcf89c420a2ce93d51af2b59a823630aee403a24c4812eb4a74343c2fbd0cd94f91894360a5b9dabfc43a14754a1afea7fc58a9cf4ca4a17130a6bdc07522aaef8009d222c662b0a5ee67f2c79a5cf0d7896db68fba4589edce354b15f85fed5766406f1a096267d0b07572aff68fa5f09f462cefb5f76c7057e4fbe137220ee6cec3e315a3b80c5c36d2685518c6a402fea4ac218db3614262dc752c95b5c84ec6be6bfba72c3c8ef44d7cd9153824b4f8b7a488f288a108b1fcbc33464f0bfa56dcc060e89baf80d0cf8ba250ff552027233275b77b7ceab91517cc2fe9bf99bd4e845987831b8580f7ca91ff7e2dcab984bbf2c0e73df307c76d6d29c61b4fbb9daefe9d9cadb93d56fcf9b1a146f8cb0102f3615c493d77fceee9fe115b46aa90d38f9a3edcd335213354437b136cbf9d65cb61731ae792d31d63918f1310d423e3fe8e97d10ee0deeab955a12f1f3699c7de826736d1fe6017e05b07ee1cc50f24a910b67db7d142a5c3f53cff86a307ca2af6c1cb52b0cd7fcb877a280feb764ecd59c33b565c17017f5a01f499054d9c66a3ee840869977300cd45f7eff46882298642cfe69d98cffa23e88b07094ae34f9d0243b61467cc8a848942d7c48aa350f16b03ffbeb7e1b29810ec90a325e665cee2b3625fddf70eca55ecdd383617cabb43868abd636be38a918f270d7dfe62f230ef8c738993eb503e9a54bcf95ff132ad7fee8444b33ac0f74886d79f9ec56533fdda411894786abf1d5f9fffb306dfee2697eefd17e5177a338095b6f68ea8b55d7748b87a61a8de3431e60672c25509c09161dae638f95329449042ca1b62ae082babc6e9052e6ebfc505a0deab6c2bee9a5b91b0630d8ee57510f41f5bd1d62e3d09b72cc772c04285e9c876714422f76361038ce6c0f62bb90a37193340302a0c0f1030132367e057b511424492f62c91f2054d05f3154459604314f79e1bee13a43459654830277e7e176aae0efa85f4084df5ff72333466d551e0be0d43a2c9b7b37b84f3c45df0d12e4c7d840c237eaf7bd552b3689f370963b022cf52d0c932e6d7595f4e65a79718b8165c886ab8f3671654d146b3b6863d9ba74524b19a77106bffe97553125e3e292b02a3557c355b3e5b71b72907489bf592d074ca1a5adc379fe48a89dc53123b30529a095d230ea8cd5eeba42897296477aea87a9dd42eeb24f69c8b73e9b3e149785385c39fe24073eeff3197500f37cdfdf336a1de79af9742249d7f5aa8e62a3d3597d615d8d0e6383bb04def7c542d7b40f360c5ebd098645c9eb2cffed962e54f2a51b6bc52dd17251333e9fda4ec874a147e03cb2d45042b43eb2c150ed6513e0ec0b9187331c6868138f17201b2583509ba5d24b669fd2f01a49d78b9bf0abc70ddec664248b2ea5be2e9418e3dd9717191f2d22c92dda5f66292b18856fa3bd52c827c851a99db9644e55187f2b357ed78ba49a0b621999ac3750533157bf932357174821f4214d71472a27e58b23cd913ff01a30f25b83bdc2c8b8a156d1793f8f2d4e7c7bfc9f1ecb95a3d749b4901c50e843283be8299f5b312aea2bae8d3e8a866585f1477fee98ae690d3affc57702e6b267f7f654217835495a4918605afaa5acf688fa41cafede0dd35b1a3fdcd603339c8d0834cf3bc616c52857b4acfedbb1de4b5a3b3ae20f58c8af788f3381807bf464d6dc51ae51ac13538c6422436c86743bb0c92e67f5d1a250d6abf78c294ae34bf21a80b591c670fe4dfbf593d5206697a3d620d0dd2f4aa3cbbedf4d1caaf30c0e6cd82e39f22843a44b3f299f8a1a5fdc5861e0a82b6f0b2b4b1028b9794ed37ea9e6eec04e6eefdab9d1986cf96ea76f51dc7d4f9b8f1217874e3a52db380c03d90122f791b1d97c045c8c367ee17e8d5e2033b78dce55d9e914d6302cfab313fd72fc4c7489b0a3a36d28ab41ab4fad7c3ee07fb3a3c03c1ec325e842af26dd16ecda4d24f7657299b6583eaa8780ec2dcf7e4752e9fd2c8905125a43de68976bd780228afc4e02951418ebd858d0d1ec3af4713b4c5c502f339501c3f5bf491b95031f14cf5b3215e03237c54d370db5e3ff9262bb0bc6dd2fe3c307e69a32008d6fd4516663453db7192af18e83a237261026ea619fed24a1f34ac819dd1ddddcec8c8caddffedc8d8a9e52b5c157b4a2a5d3b7b95f16c221eb5e695967dbb2f70fea19e7b478e801c7271d10956c72c05c9d3566c4e7ccca080f27c14eecea386ec98015909c88d3152fb2a7e30bf4365601818949d2d34ae06f4d3a20a8191fffc6ce5e65bd409240dadc3ae221c50b08e7afaab788988e7c88b0fff6de4bd0c8e25751c77cc3819f290456bf3e41ad31f08180261a13cc34e708ac9e88a3c246f55f632c7335f04ad34e15a239be9b6f6ea26f0642ff71757fa7fa3fb5566ea91d3f255f4bfa9f60fb3902bad076620f29b434a8acc9553cc5515587beae70928985546bb4ed710665a939824b52abed1fb4d99cc5b7921345d1c59eb0aa594688a91c95fb7c1241e145ce621912aa04825f98b12e008f19b927e3c43777c43767e99c05b7dbb3038f25e76046b066410efc01b638b1c2c14fa79f8a9de5d0e10169110d23c8a464aca495318fdcaa8cda5abc657b6f4c0248c1919ba75cc610618e36ddf95cec9a8924a69e5676fee4a105b89b9bbe3991baae750c76b2ae69b8f874788e9c8e43d1654e5e6b93bcab8790a16d2f2789b1b4c108c88c63072408e24cfb8fc9526d3a70e50ee2e21a42d839561b7158b5b9073e64eb13c7dbe1128995ced399963d27902638e6fea636486f1b4bff59425f208c168fa7be6831b23264eaf8d0035fe306495e632da75b1f1dc5482bde3462823248a008b7898df18d8a168617b9c85659aacd8551bc01888c2ba912a55bd480e25b2eb16c7c3c8742655ec5d8ae94bf664f5d7908bc89cfea279e38b24dd0f53b8adb0e5c3b3f831097bcdca531e2d315f5b3e421f2777470d2f609ad0930bd4ac3484e44ff3c3404eacc622ad8f4f5c1cb870a7718efe6ea60e3e1da51d18a68f4ee77a5743d225968573ebee3e1b57143a817bc57b17e8891e0e2e0eadaec4f0ec6ce8e3039710dd7ec0652f5fe2bf9ec71fba3e0f970ef8fd97c3cef94089e35cbdeb980e31f3b74a3af926cf1d393923a0474f8f011733241c3530c47c441da19bef08c779dc8eabcdb9b254d0ab2a3feb7faf50dd02b1c009522eff32529b9adf4149a485913b6bf636bd14952c58dada4405b45b16c3b2240655af4a0ac4f97e2f905e0d8229de1fe1da575717134e47874725f53075d90dcdcf0fdb64e7743668112424a6f8d1c98bef2df82c68264410157921ee20f9318ca51ca2223f1c17dae3be3146f9fec5c477c2a1203f0b913bd1980e4f45b7a95abd7c4bec1e9bfd7335156749e32516d46eee1d3f02bba2f9dd36542cf31481ff9adb027defcdb63d270e77b9c96f92764af1e7bbc91445f99593d66a3287fd59535267ae709ca6d413f1572ddb7aa92656393a5af018d14f497b0ec7432225f98a90596cc2dc5101b89760eac9d4ea847698413fcaa637e2f614ccf432dcad95e214c090a18c04f7009432f48243b791474e6bff6f0366607c4b9807ad32fa1eed5045eec77990c7f8bfff9e247ec2cd4764e342e3a9feb43f447771580a83e39f095e60351f2bffe6bd04d86d8228ea65c179acc5d9d7307af6e049fe1259fd8a3c9960f5800fd517d5b8788e38cc0df232c4df07fba3439c44674cd5dc010316f9aa780e2d5739547024a59848073b4200b25c98937a1932230ab2e39c336f59ee5b93a70933663da737bc3a2de73b8be394bde083f520d8d6086118ab1e79e11876612bc8580e31efafde2d6927c0e125fab6d90c4636362af3d25a75327ff60557676a131530468f9a9395ab79d8b3e757e4bb589445a6e224fed0df4753f2d08c4dbbd4ed0276ebc88e624a86d459d2e748636eeaef3e0bffac230d4aa6588e6cc1ad45151bfe6509e3dd697fe9eda4bf1c02abdf142dc8f6b2420c40ce15b856298bc57f6eee10d8e08a8a4b81bae016a499421a8c41bdab2ef1f038471dd4d08dc4d26f64c6ffb95e1df5c23cd5c9c6288665aed8c58f61446844f2bbb8ba2f60a768ef8a1b0aac786fea1def4732d6ef48951fd1e85a66f2ec195a1c9609579637266e1f55c65008c06bb7217ae052b6892da9021dd6cfaa1b0a58aa0d7bca54354e49d7a60bce71e9a37b416db1547a7cda7075f37f4cc1c8de76f559e9a30b17c5857c51ff0eff1a9a90e3c1a64b94ccb04920a5ccb2899d53829b91b19d5cb527d75204c6f8b2715a1752e7a16be6dc2bcb885727f7141d4c9bc3cfcd1bf16cc12da1fae4c960908f85f750e6199c7b60c722b7fe1c73f4778f4921a4eb7a68dc383a234414965c4de4a8fd2537f97bf57ed81b894b102e778a73b1066a5fcd63ef9e11e84f37faef7fb3fae83ca4888e3bc397ec50a0b1cc3b2321d6d23d70c211e65071ab228c12ae7cb4e63dd363dc074f899b40aa5164ea258a5c0f4d7b15dac06d0f5b021c27450431c96b58a9949e25da270600110a621f3c5b88ba4de80cc4d1ecdfee9f08f52e6dec2c7c0528f4703c327c5dff1ce973c783ef8b79d40e115f38ffa11a17127465eeacc943c29836057c9e23e0e240e9f9225d73963c32c057368de0a04854d8d5b17f918bedeec7d7c79f61fee0afceb7bf5666c3770c9edca71369e074db5e80d05256d34dd144d5cefaebc6e4aa0a5195e64946e38abcb82c5d12de4a2cd0d7b201312771167ad25abab39b0b8e2d98ce62835ccbf395443aecafe55cdc68f6beec75f0f6c30f8ccfc8b1925bd41bea9b7586270e9cfe4eed3033da34c1319db4df38624642459b58f5c7945372cec2ff8d82f318e410c1a9feac60f8ccee854bf46d98491313ed2ded6bafc3a810641d8326dd55b8ab39a9a4bc4cedef9d5ce14660f951d52334b79d0dc2b5604ad9b792730c5258528509b77402c3a07efefd45129921ab90e932275cf577c0c538605fb311eda79fd2b7fc0d24487e9d5510ac5f2968bb82a26788b58817c1dac032f44ef860f0f3da8e3b8e60118819e4f1b1b52bb89a62ec5a1c7c1ccc0d66375662ab69c38218730e36fcca1b28484e093593aa9695414c57d1a51317dbe5eabfe8328419ebda8372df3d36088ac40439fe2879f8753ae9dfea37b57e415f8e906699bb9c85cb87ce963ba85d8ab7529e2c37def7ed87d1bb65be2e101b7855ddba9a3420c0b34a952bc8337d794237325f605e514d742aec11bdcc1251f8b663751be519b06392e0efdd06d3e34dedfef34d60a1a176d7e3809304552aef78b310fb3eddf3952918219126cd5dc6789f6221f91f0f53964162074c3c81aacb70001cdaea34e44dd54dc29162d2c4610d9774c594f9356fc12109585fa6e05979e774de99cfab81d8d3c224e30c761f1cbfac885ba0056f0c62268c88ac1c5b9ac8054050310b6526f72f08a6a2586dbba9277c5d426774e7bf1c4cc7552b8aac13e2de0f5c75449068ec16ba987dc1b2fd59d593aa295b141395d524d0e42bab5b6fbc2938788638b1298785119c7baaf73fefd1598326ae2dd5f80da4d958fc3c2c56369bbfc6dd17efcb676a619d287fb2e772d5747d596b19fc4eba786991e9995ddcb05ca6ed5f04e3f0641e1bb09f2166ef0734645c8be761e42e9af4746fd49821caf3ec3dcf33de0bdd5da64ec3279fe196f4aa222d8ea04f939d45b50edd841fff465081fecb1ac26928ce3bdc90b01f63139d26c422f9f096cca7bda7e8eb00382cde08cc9619892bdb84750c19615e804be7db105b515d8c8622db3776e52ab18245b9669c7771e5114d07bc936b019be7240584ab896fb8de6efba1cc0b94e445a102aafefa92dafb3ce7d5964e60e4bc29c685bcf7a16df0a0f34b57d15d633f2a1101eb2fe0b5f9621dc420ad9e11f875e81e4661e768ae02ed7bc779a654caa30d2bd9e5e88583447e105e97b21cab2d20b47adda2ad15af1e67b49bb56714825edae10431a91c9d9a54822006f2b6dbf8a750b434b6ee07b18830bd4fc2fcfe453ef680bfb519bcb73691d090428bfd339ce0e015de62b9a19c56f022b0ef1b3bcc8bc8577a567e51d062e73943450c1a1dba3cbb11387513db16afedfb1d30d0cc792a82a6e2a5b5dba91bddd8f10ee900d8e7715569a11396c902a30b176179aa9c739373cecdf9d4a89b0d25d9ebdb810b06149fd53515ad8086e3ed6170b598137ced6f65f5cdcd48cf9da7bef03440a74f4544736a82f80b001a4f9e012568413fd5e3ad7b471e46a01408401498182a9bb444ee9d10d2df59bfc640fd050a9a75657b0766f93b3ef5fd589e83719a8dcd3b6c01b1e54dbd3fe918a43e413b35c9ad89e63ebb78e493095dc5ceea1233a8178544ad2cb6aaa60fe2eff448db32d319b5aa21ee9d9a1a4c92d73c630f30629b65dc24114c05fac8a57abc36dd5548d102ffe809afc4187b18ba67ae577a05efc3fe8ffbba9a45998f287613c4e85bbe19d98228015336cb3169ba9be83d0d19239d23d43d4b128caa9bb4cebc32c966b64b56affe4a6fcda6e2956e31625bbc184e2cf82f9351e38989d4eafc6d0c17187f02e31f4f34af2049f856592cfe83a72d061a49be3aa569c21da75a83526f0855d67b75158bcb1fd8a1dc21595ed5fb0e9af0db1579311125bc1d17507b6e3e664ba89e9d4a884b73f2c288e9cab5fc037fbb238dd57a868753174d97b32fccf20a8c58d4a65f1cff12aa4d171a533522aeb4bbe6d742b6589378d8cd391795b804290b2966b3336c49c9e5c63f02e887bf6a03d4839910c1e0bd28098cd2b931574edf5b5cbcc0ac9384a53a50d34b11e214b889fb855a4b317dba09bbf33dfcd7b9041d9832e8b646ab9135493d7b41d2a9a68e5e5e656dbb47c11993288c3123e56db7a7baf40e856eccad3fabec41d245d8eb78a5ae21b4c21eb193d8c06d020199789e738a4822cfca4640a926191bdf94b3889756d3c831f7a88b87eb3bbacd8186bcb76e297c750d02c1f6757310916b614db1f92a9ce9e62b6a87775280a529cdc23a5554bd9aa08d48326f28a2de631e7f8a6c4d56cdc33460a1ffeb1e50da7556334c7ba4166590685ffe99eac1b907428ebfce56d457404b6a8f4796007c97251c88b8326536cb644bc48431ba82641fd26fd7c59a7b943e1198c2496ff61c7ea0b281c3f0635927dda94eaff9531581617068ce282dfb218e31985c1ae18d23b8b0efade93f3f046cc640f2835016d4aff50087e02c72c7f11f49eb4d6647589eb5633ec75f24da546c219ca30f964336b049dbed00563a84c287a180d540e4d3940a56e40b2719420e044b3531e435bd55936ce4570f07b7e327a1627e719a2eafa24d0370642e7cd088bfd041e8a5e391de40cdbb4e2f919507cc9cd917fe1ae69a5bcf6164f439628e57561057cefd9c02cf3e44153b6e3c0a19943b68b06e6e623f35e4bb06fbbbcc72cee33116904206583a582340f09ffe172027a6bfdc4a5136cbf31d5cb189050c7c21b65c9b0f3e28ae5ca56295b701f07e5b306574dc540c950d3a04f0abb44973dbe54cc29540e6e5e48fe7b1ce475693ef2d824dd1a4b66f3989a789664c676ca1edfbdafac67b1a40e2f5a9925d8109","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
