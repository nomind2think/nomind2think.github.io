<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71f3f8a5538501e439a4266c641ad6ca55d0d92e55f4ad9d6bfa2d8e53815a4bf4613b7a44244198931c8faaf27847ca5ec1e856f38e1ef5e4e6a18f9a26e2756c50ba97be1bc9e9361fe95d38ce44b78cd9599f46f343bd4df63da9fb00448476625509d7f2e46fdd9133d5aed877cd804d699ebb26e23b00b14e8f0aea80548d180a49542b1cc92724426e7d49fe87ee0356a0986a00a20141352038f4a60202272c0c3de24751601f989e3d64ffa23e7e0aa0f422b81d0f8471a1c674bddc598c5cd3ff4f186555ae107657597e93d29bc6d3ea8e3eadd886321bc52d550fa1d93963823d01c2477daeb68688340b410ab549bdd968b0eaff040c487e86df45917aabbfe00b834d6cf9a50abd4d413b4e6856bf8e430561709a8026afc8060ac2c27f26c3e69bd0fa95a0d4ea8fa63aabf4efa60cd96b17386a1f48e0ed343454073a7bca38b81e6d87f15c71affa22483466548ef58e28449e22d42558327726041841374da8025aeee8c998627c8a5de54a5c9302dd42dc82370ee3a14bf89e133dd70d986b2b208c1d459a78b8af7011901c787d972ee6f7ed101c498ec47823ef244cbe37488ec17018d441266295e759d9591623cee1092dea5614636af0b6e4b2e3199f7b03264c1eab0f42ba0a34caee2d782951e2e2e18ba891a4387c72b3136b4834a55c34d6e4f3e868c91250cdd10c38296a9b6f81727fc1b0a9fc16e5a02db422974b5aeea59a077f5253c82031f239477249770e4c7d3ee117004443d90f719a5f2f87986446610cc2e5b743144a1c706952b46250976201cd9426d78bb660b7f4eb7c7ced3e836378256a61989311c4c868277d6e38aa2ec32412f7db696424cfa4ad69258a65f6b9908aa6a30a5ab6f4845019cb2780d21e3ba51b83e24e1ddd4f56b604fd03e38b85fe2f811303361b3bc872e952db8034aa8f5570b4490caf200149b507bddd4916ed4b90bedaa496f171e040409a766c8da2b165c11c9d736fe20eef06a59494b07ef4f3c257463834109ca6063c2b7a41ffd8d6675a362b29df4d6f4b817524530cce92044e08aab432765f29c9452ad3f24477ea2421218c1793ce9a353f92a1961c442df5fc22a1c600db0eabcfc23b0327523285e29bf40b3662f1e58998f63d6a95500de0efa701adc7f58f66c7f792aaab82d807a3c55a7371de015bd10feb31573ede2aa9ef1a23d5b7c4926e6f50560ab6c87f48d392c8d20f8037a7937da45382b8677bb2d2543efb144c6621e1c0ba954a57bbff39b8d50333cb0faa6f12a7c0a8f4d2108f0affcc58920e6ae02f515ea53a3acb9bcd7fe6dc5f483f4f17baf79724875d5c346f1da5e1883703b7bff4a9031e87d001dcd627bc39f6baffbdd63a519521a12fd876ba7a918f171f22b56f274405d3be6728c91333488ec13219cb876b4681dee695b48fb9fa5d4389c4c020ea947fd312f123cb646c5a800e395e9b6fa16930089efdb1c86edd5808c4e29ec90abb2a0eaa63471fa5ffab45c3bb00fadf0a7a3979c7709a238a30e9140d5e6f65e464fb4949d8ace4f20309859b2002ac06adc204e5e5822caf66c30f1d8041c19aa3b0f2171bea65d09e96e32edf13b2df0ef07b48545a1ed68d9792949d71483378077ce5b4e15c5f7f8a40d85a1e359b559d74f5f37cc9973cb4b0d64a31baa27b8a0d3a0cac655d34691bdfbe930fabd69f29bd73c4153409da714acd542b0351bc38dc2f5b9b8d3f3240f4e4859369c748b03bcd9fcdca79dd36b40fe77ad7129b5db63a4c0f3bb52e4820c0ff8154c50e3a23e3d8ac8af0d095ae82067c120e6e01a7dff38f9313d286afe7bb09281bb8bd08a51da573ee101c54cc38d4f09056d20fee4cf1fdd2219ed9e98714ce0e82a3cd8deb877c1ddf05ba687fcaca12270a004657bdd77dfac2020d4f0900d52e7cc091ca7dd4543f717f29725529eac142950eb923a873ca514a8e5f3b0dbf8a40946007b0718c87f70a0ba80caac4acff584edb2c72a56e17bf2bb801783312ca1b47ec08d9a331e537eea4d9ca8487eb6e58252b05a1e332260fa7f3726a60949a213db00afe76d6c3c78e769eaf7ad5a53a7a06d7846aa685ccf7ab7de7856530c4c97738b5806739128649d82b293d46764e141a9643dc6b5e144d1c4ce7ce8632777b7d7f5ad88e867f832759e971a86d52d32ec9ecbdb248ec003952968bc8f40cb25bf3cc8c7a588fe1830a8fa0cbe16de73a4cf8557f113ba810e9f91a118fc7678479d34a3d22c0cd3cd8ddd2f09a730384a6e2836a1d8cf278d42a94cdeb484877abac9e1d1bf70b9331fc6039cbe33b384992895e1b35b0e2a8cef2fb37a499d06adc8b9bc44598d5b942944289dacf4cef7ba0e47f11f1f5a83cc73985228d3c13ebf9c5c6951254845523a2bcc9faa6481edf6c0467a0c5957e0725635256aac999a9902f5cb4533530ae71771c68301b0797ef1f735192d13b355cc4290312ec519558313dfd484410ef059969bb172e7079e3b10a714af9e5cb9b80ba07a6526e3e8f7ce38908fb68affe2dc5ce13c9b4792063471b83eaed4b77c8a771890bcdbbbdc6f34333d9a7d6477cdd28c4a8304db2acfe4e12c846fd6ba1aef607f9b3d09b68b7de5dac2fac0232f09bd4bdcc1c3c6ec1c2006dac5e079b46af9f59417573d2d1eec95bfeb355c0450459b67c82c2157419abbaa031839232efc0d72f224f8f983b1338aa1aa77dc56b662776d96fda0f1b569fb76df7ba0c4df9ae0f111e80a968ee9f8eba3c9ee7e50a6effd7dd1cc4391782352a8fd9d14707cff426f52e80ee2ea0e6ab1f050754ca5065133471b3191719f5eff0ec85157f4e41ce2cd78495e6f8a28244a8500e90cb6b75f1c89445a39d1a6520920b624bc00a77ef55c032a9c9ed5b1a0d5f2b3dae4ff3eb797ebb277f8ba6f02020eb354bdd20a6b2681f4bb0274c8dda67ed508e5452ef9baec5b3a2da0ec7677ecab9c1ab52e5e9697ce42ab0a8e0f9dd9e6a2ab6428448d20f05498a66575e4ec986be5fc4da737f54ed974913909a548e70aa711e7788cd9a9d728475f2ed48379327e7556d07b67c80a762ba1758e24d901deac328d064c992bb7773224263a66e094f429a477c2e20a881118084fcfa9e225a689367a83836a5762ae516418a3d1815b9c0ec818f1384afa2fd2030b8ee230ca46d5875b819aa7007beb92958522803e5bcdd01681c5b344e1d61edf13744b7272f67d3640d94705a1d2b8cb0d182d8a82251de0e3db676093a0f170827138bcefb13742cd6130fc87eb3612d75a8b22ff0ac03c6180cfb191cab460d5153f59c512968f6c7e13e755d9bf76b641af80cc0c2eb26ce54563aa2c8e042949232af9f4529e00d85c04ef2ea4c194c3d945d44af0295be48d24308a039e599fbfa57f308079a96625ad1c4fe8fca77a772ec725a44ee73d3c4d7ccc1ba57506fbbaa2c1a6a8b81e6a9c79e13be9502126354222223729ca26294a322a6ac450339ed809a7d61f5ad8211cabe662cf249485b29a794a00516a9f16aa25a7449868655adda15279de320b7211a8e6d8780574c1e5bf10dcd148ddb8b2233b89e15b37c3450e4cea9272a48a533b7ab636c11e5612ffcb4bd073be7bf9eb5d647cf43675f8680cf7b46e4493b84f1a359f4b9d86bc89e7905c99c98d7a94f5fe4e2b4e0a6023c112a2d78a440f2288b81b29565493410ef5852fbe5811f239b57bbb6a7ec35570b7ebf67daa8121636bd8e79a20d425f8a055ddb958af2383d0de4cc9b365395a09685b8d9a46f4979641a72d72e66e4be0beb721dda7401d8ee991f9d383dc490d10bce9d3e6cad57e08f3804765efd9d9e6fe7d8d6a55bbdf6f04135f8b3bc5bcd9ee242ee9ec37c3c46fc2eec6fcb2679f1fb66f2471f3025aac19524af483d441b9b5e9cc332acc4b43d02e649607cbbacb8556f1f12175232b1d70cc22b561603c082c5f0dfae4c9d71ebcedcfc0e0157916b40c462631aafa4b5d4718aeee9a231a151400bfe1d232fba2a91148533892e0aea594a19d5b71961f188499c00dca7f8acf21c0acfe7e366940d272a5d7a1ee5f63ef6ccaec558413ae187a33cd6cb1fda6053156f1763cf958b25eaea6448dd30cc50eb2f3e9559b60bc653a44a48420f4b3a7d7cda78bc95ab55f23385d205c66a746d193cab62524bf0ebca8dfad576020a33b2213415a1cbe773977f6ef690ddeef7815284533fcfd264324f94b9f6b3163d55e5e5066c7275a22ba7d6375e235aef14806e81cfe54d21949588cd505bd33f428aeefc5148155058cc9352b7a81058773090ffa5e629a1eb7ea74553dc66d3962555443b24b641b29ebf7ce620df2a994fba05ee8fd0a6d3254954a58caf51f8813e736d1a1888ef15c2127ed89dbb0113b899d5e9e5deb8e8662f6d8d63fd596489b1c934ec4a11fccc967bcd1760f1e19e7f5584ef2f3a805ae5e8da24f5cf6df48abe17f5d95b73b75dc15002d224c533d9ce497567ea15d607395135e1c4b1e1d39d90f8ee69277a9501a183a9719e1542ad542837d52ae3abf55b7b2d511d35187e742312c5222ec207f4b8b3ad70378d86f4bc8b59777233284c2a6c611966770405c6308e48426b663102169903da2e13716e9948a6d90c4d2e93a5eac4a731fd1a982f7c2110737a630a2dadef39acac695285d49f9d1696e074ab3056201bba369421784960d1bc1f86aec5a912b989ef77a4e01bd16799b1872a9acd405baf4252fddc8ad410446c86b0bb2bf2f4fa3a2eca671007160d9d5f715fb3383ec957a2881f5c8b145025db860feafdc4fccd1f668d6a1c692323f1a5a4cbe3eddb655466b93d1d55b232b1a71f51b21a86b1dcdc1c3bf201ff0a2c2c31a7a54e5b470d1a334808a0abf3993211047d3bb2a403a600c9dcb0ed0c5322dd9a3e74e324d966e0ca9a573cbe40336383fa10e4fc2cdb115cd9349141ce1599bea09f60331c7619f526ef34937c47fb5da2f446ff4aca012d80e6f0b349cd311d4e9ec4a141949c50d2230548cdb6ed72c4cb07fdd4cb5c5afa2cf081d05933dfab60c0c8f4c4a81eef161c18193661ad2f76e3bceb311e21a15bb1d220eb1fb6b8551375084a6f38c0b095ce764220dec4784e9733a1accc5eff4c46a4f4329841c241401f5f3a0497ff54c8fb3d3805928cfb9782045ad650a45147eb6917629fe2b030cd53285db4335151f81f5d2b907b7aa7e3dcb80e8fb0d3aa1f4d29992ede010e130275629b9aca61305884cf0a711d91ca6f3931bc58e3e48c7205b83a8657509906eef86da85c80d6e0b593322415b5f641750ae052c871b6a2e81f1621aee1d57fda2074ba279227556fbab9c5ea0536d6854371a313a5483c3f6cfa820e575112f6069f549ee4c49f3547975c8a7596a9f30c33a73efdbe423948cba5bdf3313070b294d194561c673a8d5b7b3a91d440cc0bc110fd3b488ad17dfbb4c70cb80c5857beb35fa6303de763c2a9ee4e7b41b2ec36b65041380ef60075f23e1a042011e7e2ea42e92475ff921ea530f551908b1d6b252dcb54b1dbe6cc65afb32f352e3e1d1097a25854cbdc46aee610a6fb2223754bd1bf3bf03ee22266a21f58967a656daea4a82a2cd6322185e325527352138a17af2f6afed739f1937c6b0a1d5b21a308f099c8fa864210967ed63ab038e4a55e31aed7ebd7b74b068276d5eb4c33fdf93b08a0d4aded2f91cb3866c4367b93a18a05a112d171ed3fe3a37452ae9bd99fb06de388d1a96ca3ed32ecc1027dce042b518738aa634eb88a39a4e7814f5eac5a3e016013ae8521abf8419943d545ec360e6ba3b36faa6de851f20c26c826faadee8b73179664f42aa152294e068d0d6b9dd9609a67976bd9b1b0e4f3230fad2957bf0ff28898b4416d3c366bb1446455c9769282da72a6f74e127bb36a966f01983690a97b307b5b33514d19c1c2daa5a78a2cb01a6b5467e5c950cd98eac92366b501fe14025987fadf128830747bbfcc83beef8cf4b70afe11c1d6cef076fa9cbe4fd3b988bd48fac89f4949c52b2abaeecf245ecf0d6d7470f4ec1d8af1a9075cdde76fbeae3a024dad94a12f54ba9cf7cf4d7e547fccf66c608cf6399896e985247fe18f63a2bb1039ef6f77b97ede7480c2404387f6133967ebefae332eeba8a58fd68d29149754dea43ed71f683e343a9092d8db620c7ee43b7e64e5b0072719aa45145a47648ce3337dd1ac9d1fa4db8e0a73679438f73a905df82bea835abbe6af28e4ee0f92c5f0d003a2d0a97a3619be7dfd06d916fe1960085cad3d0cabea2752b001dabb8145b0b6e8e7141851b868acf58e2ccf02c7a9524a5ae7b890ee3a789a1da2214466645b7a412e65faf39aeb5ad0369063a0dabb04df5f1d3391a15a39b82f1eb9d0f60dea59651c3cf96f2ef5a69c52d32bfb5716f578c5b13441df2be4fe1be26601fa57bd98bc15ef4077ea10a807ad5dbd6c6b928863ea640425bc82b4f10d1e1ebe7c0a3c06b112d4bbf6dc98ce8509eeb079e5fb8531e72dafba747d62fbb2928c98a7e8dfc774b2668549e700c6723f04e14d2084bc2075f5aefcc40cc9b9ad3a95a8e4f4da24dd3afb673221631b13a10e7fa222b44304f5a7530ee589a7e5682933c91c644b5c01535f87fff4aca195eda988f9d0aab5cce3089a81851bead74a8e91f8bae46a70638d7ab8104bb3b7b6b47654e21b4022948f73ab7e30cd261aa80015f712a0e4749a87d1784064dfbaef9202879c8e0a4c8d08aadd80b47f096f5fbd87a51cceac35cdc2e863fdef5a78142b87bfc8c41307b165b290437a7b9a123dca848d9b5d3a79835bec34fbf8a48871e250c0927cb0755ff3694fbab6024d74ab69840b61be0eee08ea144e3d1dff05ea6a48f26f6dbdc2d4b5ec83a288ead1e022bd9f70ea2470c7784beb5d752b44d5069fc84464e1b2671dbc1e9683c588739f3829f7ea9336b09244256b6289830236a825927d631305a17f8236a587ce280e18793d13106fc7a86788091ea00403e195f8dba34b6f9887fcc1c255bddfbf991fef53d1d325acfc093163931414f798e1925e04b2886a63b21b59aac0542efd7cbabc5ac356d5dcc92469ea197734e5f3cb3aed96abc220be8818ff7ef12bdd7177efa5fbdd9accb2108835e7cb70d6f7bb996e083d711b9afce4825b4e970da183ceed07a586a1ea0a23f8b133695514c594b709808e2ee69df48d10888ad213c3e85932ef334b3992fbd3220c237cbbf9e94785c01f553e26fe9b40fbf15bb00c00e48598966e250a823e3841d0cef7dd301e03317e9d88b6d445b9649b6816d27eafacdf8ce1faaf0d158a1c0d719f03fe5629f5429704139325a7d135a39e58a9ae654a3fa511829bd30d7bb1ee6b25f28f86ca2630eb04eab3fe2447a460f4f0c330e87a5dfc6059a0242805fb18576b545c158f94ff0d6c76c8e12ce358189eceea82846ea2d21b6970185312f5edc42e4fe61588368c6072bb407024563e1c675c82954078293396817d679ce9eeb8949bfa1031fd9d8ef5237625b65d2ac52b4bfd9ac6eb975df152cae9c9df7f478db206f77cde7e7a2cd4b9b7925b58a5b7bb80ba6d294372483e01ff0c74ba0b57fb07c154f781a723e9816ee0503b83fa4444a4e9e3108d74037d30446b5fdfa8d0e796d1a92073c5ff2b5b82753d200dbbafca5129605dcd189688b143441e81436cbb6b7e9a7e7c2492e70eae6c54d1459cf0cfa6c600046dbe1722dae0604a16fae7e594f12d5ed8f533c582b4c72879dcf12ad17a8df97c6893adf5fd085aa0af1b9af42243fc1f27dd6fe07403b8abae4ad48d6268bea4de2761cbabfecba4528567c45c57a519b2ba8a7a7a44e42e3644f053b9e5fe2229a92db5c77a17b89de3e9786e5577fb36adf773b905bd53a1684a8d271eeff36085410bcf3c3745a49135889f66176caec1ee8e08201e4541db89267935c74a6118c393646c53e46278f8766eb84b6fcccf55c2bad840518dc193aa9176bbd3027af8c5d89df6fa9b57d572ebe710b4d340d1ebadcb06067b26d3ead5f5e85b02efa01170161651e3adb9e13ade60a541ca63e047d37f3c1a009db9986d36081f39d3bccdf792981fd1b9719503118f6c0f5786855f315b93c2f5575a6318756e03c2cda34b0c2fde2f818dd71bc6d194712442d647f12fcd7743bdc413aac42d7cb4b7d41532fad3f6123b9d284fe5b75a50e8fe8b7f9c3a57be91d3c83ba4448585a2534b61b343ff4e52ebaf3a23702685dacce862d301f7c742d3e4b0928fcfb2feaed5ae41972becc5248fcfa9ea7339c04d67c415e59a2e60d577c5be29a1d9091c72e8cf472d95da8f0943a014007325a0e111a51aa9d2ae050a654aaa2aae70b6dcd80d3f2235196c1fb43e99063f39aa03921a23da944141f765da960b0a75884804c93ae63dc799be5c2afa8a606535d9d4d888a415605ce32e0c3e2db81a3392387b0372c698bf5d2321f745a77335b853826ea85b26ff9c87bfdcabc6c42952a6957d1590d601b7e568804eca139e2832b219f717676a65f39370589812a6ed7238a255c3ce5fa74485a51741c906ddc5a9994bfcb644b35c93b142711f2091de7cfda90ef37fae3a7c2dadb18ee8a079000e6d499ce806a662d7ae1506a4dafa6bd71d5ab086c64af3fa6bc7bba893537cadbfbe0d984fb4d1f92c5118e2b717c2ce4e87c9bd1f23434756880be86089344c6016146940bf83b6a608d2775a9e426b72817b3d77fae399ddc703abdffca83999c4a9ba7293ffb63d8dc890d453d3ce9ef72be26018959648e4eea1cc508566e8c079fef73a1551051153e1f147e83f1ed7f28e481d4f9cb53bc8f7eeeebc4b8872bb87e04702bbbe01cf6f770e03bfa82e1a4aa6de0c16bc2ec9e66572ac2bebc0ca68ee52ac46bc4f9c2c6b5806e21218b7e56ddc0244b82f3046506e91dc5184b098f0c8904ef44e6fd4e4c30c5d196b1f7e314e466e67e8a16d607af73e571d0b3068794ae2c015563c95b8b93a45138b83c8744fe62e23a773ba4f28bf839c7461f8aa7e455ab95cf26cde072bc43582d9a7d542e069ec2763b03e1bed78a8526c0cf3ec2c2edf348e6e6e9a47be89d79451f76a2ae3e79ab172780e6fc1be196d3c2c82f82e37129d1f69acaa97bc3c8b960a289bf6c9420438f563b2b703ad78e856caadc50656e2dbf0e08e247b2b0881f751e7175dcc7e27c7c50dee07fe3a296fbf240a51c104e570256734ee1585a9abf5be81478448d491fe0eed817fd41981329650ef68bfc03d9507007d67f40f3dab281229a6174303f0ad6a83e396479a5c5f92d452f509747818041f67ecde89e0c3192caae1c19d5c96e5e571945d0a24ac26292d30bb7d25052685fd7643680574a48a23e876ef9db200626456b65dc97bfbc5d55849a4f01a4e95a48407a0cb4ea68a9402e88426af34a49508340e61eae57fb0700a818347ab1bbf1de6c26997325215216cb53f279bb6082a45ed489f936011ba3ed6f340072c741e2f967d8e9709da47ba7aa7bd27b08fe7e6a3f9ad4e5a769da0abf221db67d7fc3c8ba2aa845c24b14326d6250220da8130be08532386d4be83b94b9add3308661bff3ed976f532244b2f7a0da7e32fa256bb7895eb4723102e0a9562dfeba51f894b7154c18c9f8324a7371ce03271edb94474f497db29f0df462cb10244cedca8ced5fea300b82f92c33c493a434b33e7e339546fb7f81847d06579506815d1f96f1081c7bde326fa4fdbc6c82f5a288f906c7557acc7f82adc774c21eb7858f17133b9d180c9d67d3356f77400bf9e1ffa7440f0728358ce5d50d4c1a08aa0699267b3509630a7b0703e77baf812c98ba1daef64f2021ae597d8edf2c32f0580d549a0232a512943126f84657488061a57c59e468dad193630abc249ea8a0cc3f3be53f9aaf0a6a090e0d06d3c8bb766841a5573a3454b672b710f000f2461f0f66f1087c0b918c0731949e6240176c18fe38ae6999a59bb36fe67c61215249db0feeccc44c3a9380063c93fcbd7c7e7793c91982cdf20681319d724c5b502a35c146ec1c6567e7d4a6649688b42f70cc522661694814e937174053805a49edf22ea8fc5c8858014714c4be578bf071a8296e2844d813011b3ab25720bb723d2e9d6f333b80335d91dbd22f6f6c49c0c5c888e708677f2948efb64608fe8b7bb1469f7793c37bc8a46c72fcdf7f34d1d7ce78fb45468f41f001a3ec50a2ddd210d257a84b1efbddf2d07f549c6a3d44b4dcbb5a98e5aff29b3f9392a178e8d07e353bd3d0073744b18e484b094509f9c286a82a3f42386f6db3d1b16b4a5a736c32602f109db62c1ea10dd6c55e2917f785ea03f2ff2829d1fe9b5a4d2d4a35db4306236f07ba0331cc38a6a8deb0508295f48c61d8016debb35ba62cd5bfb92bcff60ad01fda30787da0e81bfc16fa8da8e20b6167199fb757e5190b9ba4f5b923a1aa276bdaffa1b6fa2bbaf34b9c198a3cd15e1c21cfb9d7e987c2bb1237cc5a3185c2eee84db508deaccceda983ef553143f16742d6c6ac54e745363ed2c8336e02877c9f0c75d70727d522a1ed4ea5f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
