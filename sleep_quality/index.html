<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8b08ea374aeef260da24daa6ba9e66f32714454c480ecf6336c474ded92c629d92052dbbad3700383758fd9168190482f2927a142ce5cd9acbe62acc9ed881994e91c63db4611bf7b389a189fc02bf57d3a36b280f7b6dc3c5a2eb002ab9f85c9d65941802e0de731af8f618ed95e96289fe255ebbf58db4fcf4defe7371c92903b746064e324bcd56182189557f5030dfe1fa1494d9f9ab2a0c8a9f31ce2e3409a84071770f7578f9af861a537fa2ca9883e38151fa35e961bcf93ed3c2ead33cf9cf86c4d168bbef9f757d329f78e4683703109838b13fc245d9e4e3a0096997057ba3eb7266e0b82f5e4070df2666992d682f3f37849ec39e9e78ecb5d8e1aa422e67dd040637db2ca9141a5b7e35ff54ae6e3e5f0e7b2ea3fb7c763c78a71b33b35845c30fdaf93a742bf186a4b015eda8fc95f9a04ac2348c4c2044a5ea589f212337183b714cdf3d3fc8061e36c2e957927ff4b1968057d667425130d9029000fd6c846673f4312f444aaa0e263163161232e079aa10018618d24522f4e7c319de9f5cc9e7169da54e9c70b9ca00ded4fb2568330219155c2ce657c920d2883a2ec084c88fd830e3ef6422d2924ef0f6edabe999785fb29c6bc80d710d2ea0a928717fdf2a6c108944d168bf14ada961c1140542340bd2797d0e00ee120de18a37aedadf8d08d3987867136e304b8c7ec6e2763f9b4b662a5d769ea0697fe7fa86f5d6e1d142dc245708bf01d511d95ce21de7ec58e6cd1e35b61ca0e5eeb2a98b7e707c485a15703ae4c9a926db697a159a9ab71350088cc292cfcbb306f15c35f44b709aad0978a0b4bec7fd486b10ee0056fb66cd1813be20f94636818465d3ff8e6b8646bc7b8282b4083c84e5eb553888022f5462a8a72ce78528491fa44e0382507e36a57394a3d78ac7aef23a6fe6d8f5a0ac13239841f99b1095da3041c2346b4d37bc1cf58a36e0b25da62997f79bbe2798628487ff6326c3d0fe8f0c8df8eae44929cd1e9e9e87f2c45bb12681dd47ca461267fcde986084ac8453628d1df4619632b04d7b1bc64317a538481c4588e80d8f3874ea26c3ba0ce2bce87b476c73d31f9c8ec46cfb2dd09d1d249e356ff15e8e54b79fa799d57dd4ee12598b063c3a312ed2229828015d7c0ddf41e0b2d2091552dc1c85e1059d62ce938196f54491e5e6b43d94e6df58274f8048302a022b0bec59de77bb6627c63108639ae14be0032cf35fbcedb9add736190c4ae094402828ce0a1060e57874b4d8ec0c2cf1ca66680ffee4bf5292600ea096226eed7b62de6aefb8d6ce1e6e539bb90494f3eba6712f96367130aff4a45d1ad6342015622094c5b9368d3d6d3c8c1ce53b182473de7efd2320afc3e508b36505d26bdc372fca46c06e292f393a2af5a16a80c9d61cb1bb7571c76afcac995def9c87678ad102f812288d0500bd4dee6c8c124e0470326c6426ecf143e76e89cbfd60ecc7f41ea63e471e38f679478b66807d502984fc8c72bd1b9a7a1a49e2256f66826079932e810f14ee2ab295e0b6dbd66215d06031663a29766f602922463646d106784527c614578e3a8319500b760cce1c829a31a3cb648200952683efbb6f7191127efdb29c484ea5e0a9692af2e7ef56fa17a1def82932321af1e49521634ce106edcff1263395dc2b18fcbf83d7c89337833b2cfabfd1d2cbe7360254f494ecf539f0a22a8672a55ca9717ba51aa848421496be6007d126e78ef50e450c605ab92e1077fc8d3c7fd3412ca8b10f5075fa8ebb9e1a07f5e3ec8bb703099c3038869d18f5ece756aedca2a8e03735405c3e249dc6c91df13f0faf243626e4c0c8d64260f2b13573d2e3016d54840b6cfb4123f6cb83cbbafd29094b949e64bf86c9cb7ad80342008844fca9bcea4c8c092eac73f90c3cc981958faf8db1362e9c0037b1ad967dd680849c30cce71dff759f1eaf686866580bcbc252aa7c53a8d349ee5f21dbecbbe28ded9198697d666b1c2c96000fbaa49ebb2e2dfe7cdfb76d85fce6daf7dbad2222d31e579802bd904c0e9706580cda64a0ca0893a7e381f370cb721d03a28dabeb0a902d9e33e84ec8bde60eb623cd1240671f194256c75cd464599bb4a9bdf8ab6306e92d20869c0626d0ac9e2684666ff1256f000c9dd8ca66020313b31939662dc07173a6464afaaa40776c5a0865f2703f5e68ca9fb34a6dc51f69d9c0cba9c63a9cbbb205b0fae3daddfafb2826ab8502b944b9695c62787b5b8121db52997cefb558ecaa781ee6d4c9524e5651da6cf29dba3a7a6627b54460f59e0fb87814be2113fedbb94d74023024eead3fae1fa38773d7934d49a2ea000b1d7e96d7ff1e3181a23dd87d1b92e45d60578520798d7971788e6e81754be1b5b0674a9522ca933a1cb1f084c10dcceec6a08ce2e584e68cdd3f14abfc101c8ce39ab21b58c96e625bbd6d6e33e198771526d0422310ecda04f3c71f315b0157b7edd51c27d437286430838ced70b79d2afed3e813498c6e6aff88998e3957969738612faa558dd7c5e63d11088a78a69eae76f64946606fd6994ebf1160c3b721da6114909b417fe790d1d7236f4f25dc4e98d015fb533ce59bbf32e3e5f154eb1c555b50cd1ef28807c8fb72838b7ce6662aa3bf939a107b9931e17c1be0d699ac43a8f1b5236744f7c9bbd05ec55c882f4b3480e698a29898418e0fce32a668af111b4f001a1874b0c60f8741caf837639a354aae8edf43e34392dd5d3e6c08068ab62b3afb5d333be90e76015e9bd6ff01d1a1f8af877b4156633cdf726ec52ee4d222386f9d490ef955f6ba127335b416ddd5f37eb4465c2ee929fa5161d04dd23c202a6610950eb611826311076e2ec6e390addc8d5153ad517d3cb0665e43077560d73170d718e93d93c96c7b87d38bf2329e3d167ef4169fbdf92a9ed94e4ffbe3da03b8164cd95e22d6f1e21718b65ef8fbc26214175579f56ba81312088eaa9c68934903ad8b59204118faa0bd50c3e9d4bf17fb4bacf5c6ef6a097ba939bc99304412e514e570fe977d943fde10046889d2ab3a9630ddb267be3d9ebc75f50375ee9fe2fbe118042234cbca9027148dbb10d263f8c578b9904aa22e394e5e4357dc0d539b2d219a2a4de7140c56bc3da675637f9a7acde0fe8da38d020555ddd8cfb8956513a90258c1cba73ed5b7880b42424ceb50b6e2cc29da7386641c2003e4a6de8318117619372e68fb950465e6cb9502b182a17e798a524cab98aa829ca7fa8c98317e3a0970bd99b3e2c37127bbae6f9eb8d76f478f068b06b854b4a4310fb3e5101aaccdc982a7d7e1ee518c194577a6e89a8da30b20250aab509cbdfc829a892fc1707ad7fb5db63b25d492d2211df802ed40581dc7ea00962925fff23a6ca794e58185535dcaef49f54f132dad1c9902e5dbca9d119ba81f03e96d5816ad96a1d2304323a74cd6db2621d2eba5c5ba4823b6e5e7abd4012619b3f09591a662de86911a1c26ffb3d0de5fc7a04bc2aedd507dc1076d166573e6b29e6275e80c58355c71773a806d1a376b0f1ca5d06de4048dff7bdc9e3181b7aaaaff233d36f7b2ada27ac2f5485ec6f312c69188fc37a89d8570da7eff8dad3d10a0131263601a416dcffd40dbe4933b558d06c2f9c387fd2ba1017c18a74aadb32d77baebbbcfd812ec623e0270a58e5fcc7636dd129802241b53a94844a5ec48345b65e9ed225c5d47074257f0a010576dd86b47b2cf9108b09b5e3bace2f35d9100ce06519fc476b1a0c9003a98480f7d70198380e6bcf6de2c2b09f7e7afd858e8f73702f3dbc1830fc628fee07d526a689ca2f996240877608497287cb516e6b51ba69c5592853d688f9a376edae7ac2b0101f6385cad9df3ef09fc475a376fed6a6dcf4267ddeed8a963702fcacd50df9ef188f28dd441e573fca72d40f82ab5579de4411df077f0b17a4c7153daa8f191e88c564af2506609865f1745c6d09ef463b1414652d0e87c6fc85f348da27094b161b051a804ec58834b5bbd9293655a1cc84d7b26b6fee4e8dedd35ecf042923907e28dd66e43235cf4d9cba59e17912a58f1ac46479cb895da7df4168696a5accf366de927537119fb7adb018940d561cb8615deb2c832902922b958e9729ea67cbc7b58d775a1f2cc38ea7ba9b29dfb45bf1bb51a632c3bac4b9f367e1a934d0d6ce729bec4465617c873bab007a0b2dc182127570279d6d5a58e60c36cf2e3fbb08164cd5628fd77c11a85f79730f1904fca95ae8185b31582cff91be8a4534a37f4b3c69018145e11f0cfc5cb944c3fdec88c0e908311415a84d0837835360b112161f2c23642471c2fca3a41f786be1d704e2a5c38827efdefc1dfe29708a7a9b522314355dc2c0ea378c2f55757edec0675726379813fe5264bdc9f79e7facf804880a31b31580b2524fdf2e8ff8e6a813e77510f9488333a16880fefa5e0113f190b0855dfd4120e86a01ff27831f3267f224cf883d51411638ec4f1e4acd0e50937284ee07bed03ef7cc307925371532e416f2055813b8abf2e8b36e9c42cbfdc5e3ceb2bc73b336606165f14d2d36deb13afd642d8d9ed5c42b63fdb69599b2c2cbdd4f4ad0c7e874f7f813e31234919c9ded0fb487c0c5003c520374fda3e1b41e653ed0dca0038b74f6e1ae2f80e902938ee23cb6c581abbaa1fb0c655a8c312f7c4af02cdf7ffe3cf19fa8c864a3e0a1b6e4e069f6392b2203ad2598ebeea4a0434357c6377c909aa2ce058849cd132f70bde85698b04c28704ea443cd4e943534e11f72c817ba35fe077f38b7cdf2e101aad551c57b969a28080cafa5f33756dd255ab059563891638f9fbbaea105d50fb336649ee766fa2f5cea45963539b10527f030ec981956dfa756724de905fc65cb72c99e296c7c4274860cc122ee0d7be87c458f4ce0012ea6cd73e1d9ffc1dd24b9f9f77bfb7d10308d343e85b77b8e9892a0c05b6cb4981a896ae2c43640d6dc00db2807614deda53119373ae2e6c9fad7f201cb89179fdac0b7e0281f79a7f974ae6a2bd99d3c98b202fa526961b0260771c1da1869b4d13484859a82065b7a95162d7aed19c15d45caf9ce3469c744a2eaae33f6122f6da55f617df11a8afe4f167885c9a87364f1a925010b50f852240618ea1eeb350e7fac862205588b938834b12375973575dbf72b75a59bfed4287f91fa045e6cd0e09de4fdb5e9cd85d61683bd13a0cf55a528f4847ef67b819abf0d1b851e66b24e339ea18deafe25af75a1067ed0fde31819540e51d7d89644d3f91352a71745ef9ef2f83c613a22067924d2039b6176431e936ea1c9d25e0689c04b92a1b24129cc10fd85a84f95067fa04de31263dd296107c277694fe4086150ff1d341d58d07468d0109fbbe312cc5847ee7331a865e2e7ed761ec3a4022ef4238b3ac9c283c657b154371a69fa019a4b9fe6071e12a3f2503107b2eb13de34bcdbc5d0bae6681820ec5740eafe9ab7789a9f64a7ec43078c70e673b1e5a3c03e65d14aa7e4db726f84776c4877d5045aa7d14c8ee0b62092281845dbfc6ffc9702500c50c657dd4251fb7a58210676f5b132c9d0b89a6d032e1f6db82a8fdd108c6b42b56eb8205418a484764bf8aaae37a9adb1861e3331b6a4fc2565387699e9525c2ee70774568073f7e2941167b4b200248196f754f50e1efcf3787edbd0714ce40831d7cced4b21e820dc43bcae72b63da90ed9ee7bac9024c294edc08ae6122de94a90419e1e8176b0ca0e60815cc70039a225050d02daca2d60a5966bf121fe68e8c5d450da1b477f134fc816c50a1d3424038c126b01a969220737be1f8b4d4cdecac875d057f6cfbe17195a9fe05d9255d6dd005c6db684eca685ed67edb274c5ff6dad07323ed74a69369a9f1bb9bea7d4ef38e6bc3051b629ea971851e516d38f8d75379067220d2b4d85c7e945261dc40b02e44ac16b8e314ec5b64a0078193f034aa74a264ae2e2d718dc715ea85fb31e175e2bdb233c3c8dcbbe7ac43cbc16b2471a6cb85b8fbea5d254661004ffbff39fb8c9253ff4166bb8642a8f14343926ddd0235ef09fbd38c0ad5e7de6a623eb112d7fa750bc0b477aff7eb0e4177d81f73f576696c1d1723653895ef8b2cc2444326e4db961de7a9205363c80b1e4b9325da5a145b82a02729d5beb8d07c76c109a7aec20fe9da3f9b98e0ba4dccd38814cb9c00934fab2f7784d28021959988eadb3b0b0f3979f5ea173ee57d81f91dbba8c723eba1a181057802142a1e77a0c150bd00e6bf2934fade4e6b2ac4bcd3e83e8fad677974cf5fd5c4c5cb40855fa42670f9191795ca1679a092a6acc2845cd9e5f1a188850a711d47c59c35c6266ee3b8b207325b91584872a00596db1b9ef6ce2688726526717fcad7dd7ca131f416aec1aed918a6b773856d8bb67025fa464f72693572c73374d8d15be27f4cda76f1dcc9599a8f1ff04071d3d069dc905f79e9c4751addc6bd6fa96772b260bf56978b87e07c4f076c41db98704d28162f50255bfcdabbc2945c15cb0a497355d71fc123807d89fb4511caf42e672219f024730a802b81830adc14a9db9ac79698df5a7c65f1628951f0f21d78daca50ab1bfff472cf2d0a71e84d00eae915b7de31552e2877af9de572414b566bf37735952916af44b7caacefec3c6f4fee5b8f1069571da4ec48ed512c1085b1dcaca32a092190b58a53f1d3113fdf06ea0b1466eeab610de5f21ec9a3db066901289887102eda5f5cf936d66140877327001878cfccccc9e9d5ad4b54239c161c5495fe2395aef137c68b2ac74290e7fa623501a23e86b659a5f4f4d0f23562897b91ffc6981edee8f4ba1d607bc9b955d87cb09d8c1f763ebac780686c95ecd59f5cb3434ecbc082dacf568c09cb5c9315792401e25d970430bf570c9865711269a3bead7d442bd8eeb9074ec63c332c6b4798c9e0e0e7c4672b4c4ffe141ac32459fa44b45d2df679f1aa2e9d8d4b97b15822d3bff20366b9c14e05d5f8dc9a9301d3b262a7439528be4dbe1a74b7dc5b0f1e6b761491963ed8ab0369a3d94b8d210c8c816b5425e6ce1b740a6311ac3901188984f098fcae41758ade567676184879f65c055ff26d2369c5296e02592f9e79cd028e09e73b5e9ff41a524cd05a27b70d203e5c5f0b50411f876710688b80f83dc46cd69cee5cb000c08cf7596fec944b61eb0ee9683950117948afeb93af7743a7c15f0c39bf0ff39563215188b6929ce8947a5e56d79dfb77dfff27939db22049a3e65b65628c6ed245582016a0ec4fba0810a6fbcf3770373ed42ae507f7e302d0496ea75f0ed6b4b36af94bb8fa2fb5bc2f92524d01117515184d58e6afac8810fc7c34a3084d0fc1d75ccd6cf0c57e360e0572f82eb5d33b580919ff5ad4c9ec3b37517524811653f2e4041ac33eebe70e4bc4ad3c5c940bebadea1013b0fa374a081e34c47c90c5992bfc4846a6b9ab444bcf24b3c00d78e6c251973ccdf8df9fe4a99442764efb5996449fdf2ffcf1be1d7fbaadd8d373c3fce868edc16da903af1cce81a9c35b959b6eacc6f5714761a650ec9b125bd12a6531fcf8e9db0e63a6ffc3396564206edea7053f551a3b1d64425e8955ef5a65024c064fb7d774dff51bb02d6e94f4dede1c9479a760354f9f5908b61704c805bc7a89cd40a1017ff6c5cb3ce911ab7a1450843868ab696d8651a6e1a82cc6d7657f20f3d9761c409f17e5a4163b24bfdc835f659478bccda4ae1e43311fe1e2ee1a4eb65b78216231da84b1bc4a0e5ca7ea024c81c5a58c9c8f152653f9ee78c78b3f8828bbdde88007c12e3e1e74b9c28d5e677a761824678f7aafc17aff3fc17a2d664fde4fda31b3621c82eadd0ce9572861395aac64b1fcd18a964148d45c1ba26403f6321d8193ced62a6bcfc19cded2792f17eb34ac1c646ceac14bf2c55379a6878b56429f448e10c775769c72af4866a69eb198a72451e6094a71539c325953994c9e1af68dc8b24c68b45d23c1792cf1ada10874fff049b0b1607d431980efe75a0944e535b6345430e262bd46d8e60b03a5e4dc4ddaccbae06c2752d51becad4068550e7ec180706113f4b5e8cb184e31c2ad35160c3ab94b19937235c17fe1e0d0e6b3f10541779d2293ffcfc5a1492ec660c34968726561be70d1b5ad5e8736263899b52f22d2279980c228f53f527ba07a028e9c9a105d7089771f7c12a2affeb0a9778e1bf02c3501a64ed17b37c7dbc24fecaf70247dcf4d6b944de3132237d9b6bda1a805529586eb8f946882cc1c937a460669a4796e9a828996b1f982d22a104f57b300f55be5e5ae4a5b7daabf06bec4e3f86b08cfb7e22af0cbd15d6f5046d2516583f8f1370387d7f58b33121d56a5a9a1e3e150890b0eb3e0d25792de671ea64422fd1ab9ab6a9e9c9890ecae2d35e620d87ce22b442d4edab221e600d1e2a0bcd5b702614e6970ffaa8f34dc673f9d195fde703b9256e37f454d462c3c7845500fb23e85909dac03faad30259a19fe3e1c9565b97c0f5c1e6863a2b91e2dfd20955f0fdff7b030a16e1ed3c01d99d17cba16cebfe3394b4093b9dc9575708c1b59e8bf41271d30bda59249ca4070a6cdf3b30dcf3ab5e6247647727e67e79858de6bb43c687c6f5a53f30703bc23cd0e7ca2f12168090e1a809a7fbbdbe950aaee9016e9a3c855b38e11dfd3a2007c977908a2acb12fa070cb891b96fcc5123b96ef2259386b816ea30dc7382c4bacaaad7348e424f777c0754eb95140f0d71d6a5fb3e7fd5c4d231cdbcf3ea4ed41da8df6d12b3d8abca2295b41650f998787efbefdaf3e37060745a6f7cb61318aac8996cd8dc2038754b52be35052113db315bd41d7a7d63ecf3594a74dd7d5ca0aca788cdb06818ec57694d898458a995de15fab884c94ab20509eaab7bde75428e63cfd2699ed49cd20774b40d55c2511293a11578f39fd722bbb97732129ba5667537c8af1a0aef623969b9a6d645217c44cbb2098155cd2df6e853ccea1d195df747e60555f6bbab6ff160e473d702a0cf94db9c69308ee6ed25a0da85e6b33937ef3c1dd984fc0c2084f083b517a5fe17764c21390a2ff51879fa845be2171656209f439076481bd08c5015ee9f38395818b47ca902caf3b40a8412ef473e1215df13e0b4623f792a9f7541987b5e56650c873a70a9e722bb7907d249738a353a44565205d140fdc1ed44b876f4ca6b4dd3029f7ab821fc","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
