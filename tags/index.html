<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd7b8ed994028ecb80db70de616605d66ed26e04ba2aad7e86bc30c1282861d1a353ebce987a2f150d8ce794a3425a9144d6bad854021bb8775059b09e63e6c4800abf4989569ff56fe0f7ccfdaa772783f41453ae4fdd3bcb09693b07c63dc152e0182a67e0512246258bc3b85cfaab24d625c4c374e6dd72ff84cd0908802b876beb7bd1202f3a292db5c2e261554d093b9a2be8fe0c1dd0a2f5a9c1547db43b4212dc5fb874af3a5bd609f4aa12f312a235bb0faf3a198ccdcd1916280b892b7b45b8bf45f7acd94153e8e8ba2daf491a694391052d788a082e8ee9b033794a6e0f7e76d090c31a3d76f59d6ffbe950f2f74c99da10966399c372e760e01fd70304734c92ba47f35fe669a31886fba71f36f9bac8f89e2ca7f68aac807dd81d8071aa4807fe9a5033aa5c02ee0a19b77d314dfbd900c74a068d069ded05dd83679eaa40e84c036da9614046a8d8d13e3d13b39f1771072a9f03602816fdcc5722b19b4c30c6099b55b9e9a8907de6b6c1c218876f99a5b11643b12949a281036e8139402e3f7876dde9262ebfcb48e5774a38c7c3a27dcb1b3fcd629764924923dd047c52b6034bd1b4920e2bb0ae74f30cd57e2714a61d1efead6882c746387119d26cae708e918a1a09a7449f022908b14a42e88b6f74f3b74f172b374318374ee1bf9308d17da2622b38ed7d2c210ba1bd87deae414e241565f23bafdf67e63015612e8173b9d2bb457effcb0dcdd70e6d835a0a75865e63042f7bcbb875ad40f695f70d8748726d762f36a3396b697fc3216392e368155415d923dbc0080a6045dc6532c739defedd13cd58967909db617357840e49e78e246f32d46da367abf438f7e7578dead3f5fce6ba1c6933d1187f7b4e898fc38eebfa84224cc92b09c145e6cedd576ac23ecf88f6fc90100d0e628c4e9e58e197f7e6c06e64a8f0f08a7954076682a1da07134fae2ba6387aa9cc29ff1f2a851d2d155ac041d698c711bb8eacee2a32da31f3392fe0bb88291eecdba31dcdd0b3823ffe24c47f07e72dedd3046757b9fc227e4fb821ca7b3ad79ff4a6b1a347ce5656cd20932f149aab1b1310e5ec38bac03443e770dd80417a0be9f612552980f679988134ad6ce065f2ef43284e8426754d3fbc230f11f85c80ba578d23536368d7728ad94e36cd478b4b3ed5031198951f2cd55940b4b62dcc31fa9a6a71799d7554b3dd51088ea40b6314d9b10191ca9669830e40ee7d47c54534a7a9acdad0eb3c942f75736441fcfdd7b62f148754c4c50e95bd051982318e621963f8b23014669043a1eb6cb93bc72a7ecaa898241c39141b52bd9451d611d828eba23fd323ccc89c22859d7b94bf0b5f1eb412c8855f298a46d54445ca70ee39442b2aba057c02081ea5492630f042f50daafa4559eeffc7a2d7333765b14e90ca288f469ca85b912ca27f22225bbadf3f2570ce92b1715777a12533eda111143b322ce2c78f53f4807dbc378052d68fddd2f82e55b89c157c6c12de4244bcea0915496c389773cd484b590e735ef7715f953c0e58a9f5ea8bcb26641a0e2d6d2bf667ff43dec3ea42f0d3afc49cb31b4120830b75e8608562661cf9711290bb64336c94da146c718d218c3fb52c017be9a38ded0a6635c026893ec18717d489cfdc0e83d42f04df3d8a6c035769b2355bf3033639c69578ef4b72532589860b8b34a3d6c61aaf14ed9867af35efe539b2f209643486c2d9ea53419fbfc72447d25c7be0924f681ac5dd26413b9dd0c5e14852de2647f080074d96010020f41439d22f0eb79b7a98dcc31829b247680cb39180949047beb5682f23f24f828ba56e0831b332588730caf3ab3b0c9330a3186b412ff516d261612d62b766323741c68e43f0c62c4c58e06157ecf3b2b2b4a007547ac8721d0284cc4e3ccf6861cc950887f8dccf08ede3559018456a0cc026fada81657cedf18f4db95c40f00d60741b7832515a647941d6534db6500e9b576aedbaf23e59afb6d2db6f7d51a9eaad66cc868efb23d02c0bb151ad976a12351ce720fc8747f1c14e0dc185cdca779ad69e3fe0a64ebaa26815b3dc0566c6049692403f2f7fb6a62ea435bd1b1996e1de003a280e48de83a6d6a7fbc358ba97c07bc556099f0d41c312a88caa25f10647177c2398d8db871689557741f81c5872131f27f9236da3c13066ded179424f3ce127a4ab76ef3ddcaa62329e0d7f11a956d443758bc371435cf84beb6b61028dd56f265c28da16c5f36813b2cf05a511d5a713605644fab1237756857d4a490f587957bb344223bec47cc57be895da529a1f6540909f4be7c025685e871fa3220f7f4cdf4db9bc40029802b9811fed24e756b3a89047224939599166ca79468eaff2fc1b354e007e1ec40c1b81974d5e2f56d54eea2613c868451f76680dfebeb42eda86392f9236ad10cf181bb443cd20dcf911501593b1c55e588c4c70eca5fbca40a09444bf9d8e160ed6dd23c7a64f1f65c07c28f93ef017f93ee4ffe36ce1b07f5786990437e4133cc19d9876cb0b9317c5ba74f76e32552d26e8e6d6c3f5fef1c814091ce7ae1d88f3b15209ac932119f0197c2ef9e285d6120b608c6e8f24ade47ba93b3b7da028abc3089d3b2f56cb23aedecc9b025c39a8b8b42beb38f78059d5d62f226c585ebd0b4f74e1bfc8802ca4928f1bc525668d9ba3d9f71fd6e3d4acdb539557b6984013e611d99ae2fdd60e54f4726e85a2fe9c81ccac41da010c0b07f29869c8c40c8f8f27e334c2db75ff22347ce0d10b4c63080d41d116e46d5ed8ed3c6255b4930cba20abe8186721f5dcd4c8949089e223a41ec415876d0874b6a6e7c2cf7d294264bbe20b0509c549730a034e65057b9e0dc7c2b477b52f4606ee1d743bad5ed1a2b577d8d941438876c3e8623548772901ab3f013032571e64037a869475d490ba32bf212aa2dede9e4280e0175fd485602a05f300b505d8c44a1d5bf1033982d52045aa2326d14a633ad93a67af96807fca7a5cae09be00aa0d342c9740100aac95cfc7e6d1f5bfd88b06a94c9c4ae7e77aac30c7b25750f80ac3518d60db3f044f14238418817492722bec34e8281aeab54a2db7dccbab7ec179ed825cc74a56895eea2027e7fc113f86c8559af372f812879815a4ed19622e1ca7d4c149b34b563dbcf4e97ae7b44a42909ea4dd6195155594e0e4a1122ac0de33c1dc6dd1eda9d4b9140ac3e30fd9d82d70925bdd87de54520dc8d0778350848b9532e6d49a0ad8012db858e8caad8a18dab6f34cd96705edb47a1712206dbef9a148c9aecd98170a71990d6003716839718b1248025b89143a4ab98666b7e20d8fcc4176d75c87a4fd6f2a4248cf37b6e8a581fba1b51f881327dca8cab3dedf4cbceb89113aa70225849c619e39f6190908146b9334cc879e4cbdde2a6c5f4d3f99ea6cfe9eb6f43eceac4ac4ad338899fc47dfa95ebf1eae7b07abca2672bbb9c224ad2f7a83a6561400d8bdf0641a3ef67a29f11bf267ed828a43e46d9e14e875502f22d0800241429dd1c1b4c03910d6bfeeca81d43e180be77ef975d404cac974abf124caaf13c111002c379fd85415f63b2a71ec3cb7e02682fe19634d5110abf1d592f3fb975443693c7c3c9aed9ea36c3865f3b006b5a1c26b54e1d83ef3ede061fb722c23aa73d66cc3faec761d8fb6bb9835358666b3a228e1b65af25aabebe7ce1a8582765748314ea7a91921e6d192f1127e92e9554119bdbc68318e2785543d78a0d320e040804ee4ec8914c9c1e7df92c74f33af9a5f9af6a788f39ab7b70b51f23b31b997678e305d040f6a598b99e6c33d575c6f63121792db00726a31741db28c11309258dfc10a4cae04d9d50177e60996ec434a4937f969f355f5eb5c69709250b52a8dfaa3a721f7fdbbd90cffa8006e0dfed6ae5df81778dc900b3464bc32249cc3da6291f91eb650ee36854d3190aa2297187c5fc427f32f4508b6e6a9484bafa66efc1e7f7a46bb252f84e395887ef4dd6ca196e39e4bcbe4c874179791e23c1bb950bd819c122210cd509ab790af8fd15d4957c4e1cb1d26e577226badbfc0af70a6a582edabfebc53697ed976b0bd42e3d0bf28c06e2dbde7881ec970d9995b25d1f84d3b4ae3a9875761ae6cb781382482c8df485b25255c8e1fc39e440e751db631a68d54da50073a8beeec1d8128a56ff58d769d7988a7408154a47edc208fa2a1af0aacdd7c80dd7fac65d4db2b6ce1a83b6a82be9a28d8455a4cf3a0521b7d1ed1e932327dad47a7afd5099729e61ff06e230039e960916c758bf18a4f44795a0ed52e38b53d086f41031297fa860fc8aefc00846b6cbd15a4ade03fb9adac6ab04c47657d73597e0d91ff5b10ed497b50c8b8f7cc944d6e4000867c9b412f71e26e266f5fa70251b1db37b9385663bda3da710ac6a92934209a7d7744db70986f3343bff0527a5beccbb511aac0d78a52c992cf785c7df22856f8218d44e5eca3f4ee33179cda08676f734ba5ae2d927eb2fd763aae3a84ddf0e548d7bfab268374c2c7f0e00c6124844f6146b20320c03b08a7515186466667aa294dd2a1fcad7041f7d1db71809930514ba9f778a4baa1b0d457b458801cb254da8f16f7982dd31572203aef54f53053096f7717689b4e0b060d658b6eeb627be2cba82c95ff1a2d7071de7473ad605d86414d02c100e4cc847e4bb7746eb52f0af327f6784e29f068bf4352db80e3f760719e1005acb1a6ac864b6672c627779789ecc67142968cc7bd81a2efdbe2682812083229810cab50097f1eb56e932a71d62ea4bc818d38b4c0c1b3debd2c839734f89662309acb313a20d091d772dfa42d88f72ce06ed1955ae5670809b6f27b206177e7cb82550af1bc34e6ad1c9339a5fe5ac55961edbdaf36f6619ea966ba588c47ed4fd9ace46a9a513cb2b3a198adbeb2dd26858bc27df0ec2b71dcdee5229f55e6a0e33214fd8f072d51c7c582c2c1b7aff6a34687d80308c12e45bceb33bbb2ac55ef9924042d00bbc005b208fd31630360f1b6a4632629ccd402b7ad750273588d14099d4c64d9e36016f55bbd43c2d5b1d7fe14b2fd7a4b6c84fafa42f37579515934dce703d02e891bd42c497605acdcf9b5e45021dbd582f900cc32db9bb3615ab2885109a6de87eaa61057bfe8460eff70a10bb71ae55499d50b1820b8e30ecac4274eaf95b956e12c701badd26d2bb8c164f0f63cca751965aa80366f0cb55a7f986db05eb2473f6eb939474507f985643389a129a1ad9e8a4c72fcf169297d4ab4fd6de96d425a939d709f35a42193c5f8a168d5b0e11122849a9ea1bd139035b338a0a8f75fdca96a015bbca581816a79bc39d611cf1e22eced9723974cc518b1dc27f5b0a05762c0c246f9ca6c6f9c58c8ab65bc7f35f91a438375a710e49cf96532095ebb1f3b888b070fafa1886c52eea784c8479e5ebe470bf58f6ecf8d7531fc927cda3e80cb1bbf3f5a123869562ba441c9b30c41f53d6be056f31558f1b2111c27a179bfd1d56a646a60e96f4e20736033f81b4b5e605378da124726ed392d2e56d31b39bda43b2c6a39704bff11ab6d3a5d50c6ad1142d177d54681b53d33637d2a74bd2dbda7037143384cf8987b96b09ba08eba12c451152d083c45959a078ddf451fb6208c7c84b30a84b8f8797a3801030d4ca00c5002d280bec4f4625cb95a7acf3b1f1982c0f1551aaf01ea511eec87986cd4b01e892afeabd242d0c24409440935a4e6e29676aff41d78425f0d59c7cf81727b64b5fe7df5b1447369ee45ede84d2e219929c5ecdb5db2834415ddcae357db3f74bd2290f72468e9def389a4a39bdea710434652168938a0734b28b9e24b929b13a73c341eedc71b171c6edd1b3e46a84b9b8143ea70dee9d23ef5ee013b83db78f50fa9f09427a95b6216be46ac06d48815a5dd5b7caed1e77aa78f6d203fc072505ce8192a1677e8420da20b14ac6ced02ff54a0f1da95016ddb87c82fe3d0a52dbf0bd9b298a0696c90f3d76bb003654d226994eeb2532503c9bdfb005c38800f16c5dfbb73d669920ae0c727790a6834369e1d364c2b1b96c3af4bd757aff4b0b1f022e966adc40fc9f499caac34cf1ecf4286a33c532e44f29c0d4f511cdbed8316a67da5f3e1be7f819ce991a73f412c77e7e5d6d330827fdd8822900708ca679e2df339d7ea0f0730bba611a0ceca3a3a0f321d379655ca5ca9a1d06f97759ba6808902d23003abc66ccdc87daf000e7fd6af0c5a3ca46a4b9c501f05a36199a6de38e96f5852e9c35a9377b0dd1d64dbf12842434baa0b6080fe275394fa32123b1c55106411a326d87164fa801ef2c04d8e9fe76e47311afe5988b85bbe8a7943b6c719a6d9250e21e3985808e136f46fd20b2c08a3ad7812bd75b8152aa69b344d2339978d8ad2584c8ccbe2415e1f17c54191bccffe2a06e1ef9b3a78be5c57dd1aec9a10613e82f19e658baab36802a5ad76142305a1b5c94e5feba2c4c004591b2b28477c30d9d6e3f9d0e4c48f61f45e0a7dfe6dedefc1c69431276e040a6d877240b091c45622293a61bd6f7114a6a18614f42b348b3d5cdaf6b570a4fc8698e6de99371915d1a6cef1f441167295b5d1c89c7793a12f02406c6fc0f42b676ca210cada9d81cff5362865d87898e6b5b63833495c063c17330520d87c561df980825e66c9bd0fc0fab4c80eda5fa304760ad3fb68860f6f63f80cb2c23a2d19436d9da9bfc08979260cfd0cfdf8458e8ccf2206b5ae7bf336c0c0fa366bb27e2fdbcb751bd397accad137eceaa5322741bc97e1f6ae921e9dd5f182cb8b8970f36c295300a042b8762d446053408d6b7b1a9421d7b547ef55c7456ece220c917668bde0903d9d84808a04114f616c12d8ca4f4a9338392c9c36a8954b1e1188605c83b5a8d7651c41883a16653d83b5a0bca7d43180427e9d09333f6e8e28166fd49f1379577909eb574c8b6c669d7b066408dbcf7036d64a267d771afc5b4c8c279abfaede2650f9c7c3326274dffb848a30b39e5b1c74ab8244a7081484c68d32eaa8cadf84f9a5093d6ac243e72e24fbd38a08a80c4acf427e99950153a5fafb60a9cf1ab3577d6143a26440b54513b01f4070fb9cb3eda9745a642ad27fb34a0518e2b4805728a0f81cfb86c2902cb732398e3b5f37d8f296b7cdd40788f3812e9ec696da792a1bdfcf2f92276b3389deedd2a291b8f686829e4d896a593f6f0ac02a6dbe98626a5d138ea0616941e9b6f78b1cd52249d903c6589ff7d16003dd6de9b8b7afe9e7852576dd8f3fca53750cc1233b4194919102af8f5b1828f64130799954d67a0bf927da51646ca397eed4a964c5a590a1ed2f9fe2bc00070fc05c6655106db83f658ef54433b95f8ee109e3031e7325e50b8460084c319582813591e95612c2389e509ebc15e5290f2bc20599e23440cf25e900e3c98ea989273b833dd5cfe7fc14e39bbacb742406b2f4823917daae85e59b6f6a87192efb7c8670f810cefe329ce20ffb20c01c414f8f1b8f0834797671b9b293a03eb6225914d8eaca14339ed7f368f553a92e9e074b79b0cab067b377a5fc496c3f1e84585a25cd7f0b40be9e5dda6935a38a980c699cd82c91c2e2d438c34c7135be3b614ef92c68180451b971c05c30ca63cd45572ab1c93fd4a914342fffb19fa3e6d78a1b6a4e958c2de23651da940cde131db7f344c03bd0defcc0782c3c64ec1137d7f89719cee6a6045ef3bc67400e039425e9537ee02a016b760e0f2b2ca21b01c075d20ac875b5d49edabc00dc2b21797d36be7ff2312caadcc2975011fc32fa1c1d33a6841eaee52db4ecd0d248296c819e6b20acb53432f3beeb97d52b36a3c504bf16e6936a6555efd8b8395a2a459381413b70a3a225a38f2b3a7a00d94a291eef8554b630b5f08f19cf13278b8ef106ba41395c2da9b2b49d445edefd161568a35bc04814435cf4852f5cdf49c369341fd7959ee63ddbf550f81652bde33bf459646425af9f664f496c7798c89229fb7890ba5f58197bb6e296520f4a4f7ab25c6f59579b18362538dc15cef752e634f5899a0500fb1c2eed308160347ecfccc58a558f176f10ecf4e6062f5ec32de81a60da9c0ad78a025b21d0715a4fee4ee820bb45cb2afaec3e0a3c063723f70454945f6d0272e389349b8608f87efb4a03a09375e97d8a7753f9f445e974397bf1bd97f6f12876f4a3984e0a8fdf399926431bc9d582ccbbac4d6751b4b96a88432c520c60c57ce7898991b3228888a6e4a002a37ace57a43a0321e2809bd6b5f84ce10406c16fea773e3c3ae608c5908da31a406b4a31afda246fd70edb391a4683e77bca5b82934ebe91ff1b66bf5c0af210a283ddb87b8fcefa46c0d546151d73bd6ae35d3be6c4c33929f153e3321e510f22702184053a2732adce9b9b36b05a5dcc8cc32ef942e54a054d3ca2e685e478537e21e161c5ff3eb1ae97eb26f2e1e4e4dea4d98bc42cc510366a02f5097fce4c635d209642963b37b38e5ebdc64b44ce02c699f92b7068d1dbf27ded71a103a08cb72914bd508d5c44ae60ce7b6a9e4799de3dab7f29c8141d577f43e83573759baff81cf3556952b8e251a4f3d367c75e9b796f876a5820904ac184f35782a36f55d4e2de3d08afba57a6c74f787460ffc4a3c032621c55842a7aee4fc61a9de72cefc84aefc034dd603593cb71243b6958ae1f42aab703c35723768588d85c1804c9b84dd6202995a47cbeb86ee11e6e978584fbdb8956f3f82210a86e9dec1b6a05d9c3011ca0aaa28e7886a57d6b0cb7fd0587d719011bc299fe58b6196b9ce938ab24ab1e46a703e9ff9cc816d9c4213a127f5645225fb7fe5385cba93b1cae4f27941803478dc3a4eb1c6b3af96f736a218e25e5ad084200a272456be021745a640248f4933e1e4b578e21c27d6c983ea91178d8a53f6c9f69268ef1eb4b5a0278a283ecae4b6e5604baacb29c15d2821573762571507c0b1240a3374ee5953dcb9bf1a85828d5e6428b2ac8c51051d76952cd222c03aa51589631e26d016fce15be238e447e35c75bb841b1987416d7eddbaa689ab068a4f9c3efe27d5351932dcb4f44f8a2f4f6b443286dc656ca0868d97308767ceaeeb6be8fbc9851839073bc17a9f437ab35b957367c5201a1facbacfe05c6947a83159960cc427ca1b80943dd42281316c55c4dadc4118501c0d78c52551ee0dbb2e18eb74db23cc9825e4209c97f142e5dc2c2a88f70849a1fe0229ae00896530871f45977339e7af36a6c9f3d00e3c6f6581faf27d9274e4efff93ac51bccef15c0a97b537ad33f5f925035cc40ee0022671efe5bc27305e49f962109124dcc0584b09394427457939bd438a106a32cc3777c6759fa56c84b8307b72019898fa24592ff3415d67a0b6e4957d6eeae2750e7fb4bdb23b341cbe98e6ec024a0a28efc85232996ea026b1bec415c2a56faeb05b33422340923d0b1a30c28df8626a11cf06428e79607aa5cea9c706a2e43487468cb9896d2464b19bcdbf005b64910de527d6fc87c0e943d77394d7f47ecdd44b85f3eb8b39fe2f353bf55502356bd605cd0cacd47d05708b4ba555e44adcf6cd00c4a25bcb3590468e34b37c249bd1a3350ec09ac613b7fd324e5ee82f094820e553a729cab69d2d3d5ed5011d321617885c95dd2773b6ded3b3106cc947687a9f87e85afff48f94d279054c542bffd6e0fff5add7e4f90bc7e9f697fad2cb51b2ff7dc1831919e7640b178999ce5b38e49423fb0b8f2d5f1c1802b0c321cf9477e7448d2407c0c4f9080e472bc3b2dfaf27688f98a84ab770fb1f3f771d5df3e9b9499730e351bec24abd6fbbfbeb48bc665abf195f4933e33557a46dbecb994b04f4fa4b8a022627e2e018b1ea19bdd1124f5e08b7d28366703691c1d9b7ec8c742427572f6ad89e9b13ef35341c4732ecb64de9f394fa112cb49ad7fab2f33693e2809f4e7ffdcf2cc3eb9875b1d9a7fed10cc8ef192dc8f36885836a1e4e256c10c5923eea5af4f1cc1f4099abdb4532fed6b5b8fbbc7790db09eb6411a04d49ff8c66ea65eaaaeb26db644be818e5fe7cce5e8b613da1dc5fc749cf51dea5f26af","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
