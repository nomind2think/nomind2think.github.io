<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"811880d8a6d0fc3e72fadb368fc12bedcf54b96e0e6108ad3e4ddabddc81c515402c7b967b9962e2be6967266c22df7dd1add602fa8734c323e32130dc7db74fe1589edd5253b90553198e91ae9879bcee34d628985e67663ee8676e032d949d1f1a0381dc2d2f11d10a381db1bed9b369dd74db324eeca08ad6fe45107fa993c5e128ebbd1fee9164d92fc023620a6df9d4bf6406a698eb9f02db817ce0e601e811d6fc2d09dfe878e4b69c19e7d087ff52f9f5f0d15d9ff869763c235798e8248488b1d7a5c1594d00ac65bae39b2c5d1a80e5a0d0c402dd341e8df4404d48aaa87aa1c9cb6ab0ad6c25e72452631bcfb24856d54a0b4b9c092c0e4395c1af66afeea99b8e568880fc9d5d0b86a3242a79b76b1494e60bdf35134578c5ef02f2eda45320ac67a3c3ed6382603a606487463beee74f3b4b5456f0f91b6f826eaf1f54d5b9c81e88dd64529b99f845305e5360c6d6f326e066c65a33911456e705cd8f39200e0682ed581673e71768756da46dc81637683b44a26bb39c46527d65b140eefd6f15f9231b23ea5c0790c53521983b71d3c0bfef4d2673967d4ce07de1f0ac66667b89d299d809f0b8adda6a56257be7c4a0fb02e1ac9d64a437f053ebae9668b5c36518afceca34be1656f25ded74fb1e6a87857377cfe702c37f00479dcda4f7cc773bd663b64d995eb316099901ee68f4cfbcf9620637cf6648c7fefd04bd3e6d118b62614e57337f9c93a51665747a1d0323c7717fae7a0ede430b5a693e6de644cbd28de6c293b58cf23cf39d87279f1238fc0504374a07c42ee02954050bdb53a6c1ab6185802b576213ba3724e3b7b4f40d4f2c755784ee5d842420ab890565b344660a38567f818654b5509d9a9a3f7d25efb7febc9406bfe4bccc438cd5c009cf33f76945df52bdc608ead556ce0e4c474727983eeb82d6e41a02ce84deb05bbb1646b80c7e2c7d569f43e991872bdb60b44ebec9b2aa61467e56df97525e278ecb6cf56fec52917f40b3b19959a0c2d39c69ef47c0f196083fef80f36e0f135a3acb25eb559f4da33e43ac0a1f919725ddd8be211c1ae92dff24d00fa5f1a45a11b4ab954265aebcd9a26dc63a5ac67eba4b3adee4e4ad3591d44b877c6ac32631eb736c1ee4c62b4557bffb9794ca91572a68a295cc92903c1dab3df63a91eada0848ac46ec14bc813676f7da5425f083ecb9d638558dc044e58a3dc05d9f5c4cfc273117502e5a528f0699d913aa2b15097614525ed7a23b3fb3ad5cb1abcabfb1719f751fbc1986e02749a4a40804bea9a515f732671f130942485323aa49915e833fa34f5ff28d790a1d05c876491174bfe5a5d5813805116a7e42b2d346cf58df99ed33a9ff89294788b4ee5938b59db1b759eac2ec3d135ee92e658a90a9402caf5d9405a4992fdf37a4b49c45bb8460ae7847d7a99cb07af7134e4c422d899231f616ef068bad21e8c67c585581e116f48a9f8658d15bc7bf234020ef48098e62094c2edec6fdff6cfe828835e6ce5f9a4364ec373ace351150475b338109a9f72739455c3c068525ac336724a5c7d410801f0dd0fc1b6e2cda3e7efbb911859c542bf5e51ee628b5aec402cf610c18feb447937c946c00b9063d64c24221c342970203ca3690101f440a0ed488c7786402b2c69623ac8befee1c5d153521291d4e13c1c3a7fb40a9110d1cec95f9d0429e6bfb94bbaf844991a529c55637d1a7638b90a6aa7e18e003cce1ed0e015072158c8ad54926bc2783684c769cc973f5c7a3d1ff8439a88be86aca060b602b47634287028beb1321c29b2f5d2665dbbb1e11e0c240b4769a707a3ae38be5aaa22f07f889d2201c9207c79430482f70269246e5d926c5346b8e91413f912045cf0de26ff0e86932141d7b811ba201d5ab222e2b854730bd33d31b2753271d3ec189d9a103ccef0f35efd25cdca004cd0a78ab974985682bc6d5d8d8eeaa4ccb0415eebb0ed0cb119a563bba0f354c1236d01654711735954f7601aa4156d9ca1021c2fa480b6af0257a9b4dfc89004adaa282c14f35d3cb87346a5a646d14810ddbea4c9c8a6a4f0f2e92b449097374ee5dfaedf1bdd9fdb7b90ec532c4e4a6c0b95c75c8867dd5244ac1846d9b5f5cbdb18d8cb31dfc982acb85ca88b376d1eb5480850901e3711c7acab1076e12c3d2a0e8ac664ebee4d561e9ad86507795073a379eb3aee6c995375194d1c9a73940bf71257c7d3d1ce1adbf99359a77f222ac63e9ce7e1159ae05c94dfc0f98e79b23c6fc55351776b4a6fd50bf4cb18bcfaca0d4e98be8e7b473284a7cb65cab90e0252db7363dc020dc814845fd7448954b1be40086510c84520ee3e1c92b3b2c542e7e985b4c87e5ccdead47e782ea46167ed35483f0f85449b3fffb885ded32b82c5e9c5f37325cc3ed579d28a0701aaec8d10523ef780829a4a069506cd9449bb5d8eaedf71c00a25c2d6b160f4c652e3a43edd822793cbb4d1bc223556a0c0d33c85a543fb999a44927ee5fb98e0051e22089644a2628c17ea9daa0f842331ba9ece13d3547c13575c14fbc5897fc93ad26b396fcf0371df4815832d5e61956a0bf599d4e8413c6e3aabb56722013a3abb940ccd60cfd5349f6f3925891760b69dd2e7a087e00477bf2cf68eaefbbee6f73c8f48cc6dc4d50ee8f0678f3d14d19772a84592a640d3e46cd2554cca03681b212134feb7ddaabede077aa587bafc17f0c487323311145b5f42f62cadcba184b2f8c38b052e4c150ba5f1c6c11286ce126345c3360d81b4c0544657bdf48bdf0ff6ef9d718bed65641c1c3dbafee66ca01a4b52f3820fba37cdf7dc2c58cf208f41995e9995005a177a28b07063af08c12073783990603782c44eef77e312837154ff2f70b207556d8efe7f2369036f5445f89123d12c14e2af25bfb9778c4072f8321f04bb08ea4083869680700f55e8ca53a5b55ffe0a3502cefac89839ad54cd191f5cec79db4899f1bd316e3a58e4978304451b9ff9b7baeeff01bdbeb82f2d074018228c20f632e0c1530f92e3c151594818d84876815d7bc0b2a8316b417d00954c41321a640fd46680ddef5f4e873596ef4bc236367ec7ab2d620aba2ffa46f8544d75bed04c5818d276b6ff54c9158fb82a21e5fd9cd508c135b45f8599f5d9866b96925cf69e8deace3f85226c960fc5d81195c8b681e13a81f4dbffa8a819da7a7c0509f94c789498cbb09eca047d63d22e610ed6293c18c726447190b00117ae9f6dba83fd7e62aef51ca271c7dfc475bb73f6f22163902af7d46d3a4bbedaa8ae6f4bb87e44b69907e8b6e60e11b5dc3172506b153b88c964cd7e4c3067853347879eeefbff0f3e6d5dee6565ba6a0efde168227bf7625f1282f4bc9771ffa1ea3ace9fb8eb4149029b15734fa1d46c2524f4003c918cbd29a365c586a0cd96721cb97b837de6ff5d289a35f3a5dcd15e2184629fe616b3636e8c72a8147a5f63a8493ac67ef181f13f75c423f8942372f6b26e2d81526b84a36b9daf8efc29aff63f007dec10fd12b8e249f47ecdd2362aed5d15a7d5c2deddba11cd39d14a6d70f88bd6e30c58fcbb19b90e636a7deae8d8fcca9b293d1fd03457df7a394c524c63c53a46daaf9edb97a3ecdb4e32354ff6cad8931178db1096e70c5319f452298077478a128e37b6a05f9735d7da34eb0aba0b118f1791f86cd3f4eb1cdc7ff1896a6a82bc9eb9b2c855943f247db23499f017a21eeb2fb0e80feb3d9737730c7df2ca13c8d3f61e310feadb18aa4a20abc46ec5dc4922ba40a1344674781b71a5765c8c1910225c882917f3b63a077c223098dd7d0836932bbe587b9b7cb5c7f1f72535fc44b4433a78142f25834d93ec826d0deb6db4ed068d51a2cc5fd132bcbfd858ee7b1e5b028e3586d4a70342c7bb65898f6729b4405e614250f86070a1dd0666911533c84a45b675c2999fbbd3bf7671b53cc0c84f88938cd5d472432aff8873e0bfe1722e3cbad305b5c6647045b86619263c303d85a6dda8caa24fd74e3a947811fb800a4e8fa780736cafd31bea09c4842b7d389db6b51e93f95c13ecde807f0649d9869f3e4dbeb2e79535a361db0e1f8a4abca3bf24c67b74e95a785452352ee656173f912323189d0c2eb093f809d6c0e0936fd50ebcea2b692e8185f348538027eaf41cb40f0d204622d2beccb34201009827194726b60004631bbb933839d3591c975aef4285ce8871eefe6faa28ffc450d800b40e7efd75bcb886f8e9b38f4acfa062691356246663ededeb47d21647c9eee8560f70a4dd8d84b54edf72088e052db2d28d6025c194cc78296b40583f2abd3958ad7e9f3a9bb3a5423abafbef5a5435d6fe84c322234dd28d1353d38cdd77b51e75bbed24c9c38a3f3649192ab6d9c205f62be7cf8d717d64c4cceb0142ca1ecd3a38e694921ed1fe7c4578748e85aacbb86d75095eab916760b68d7fa0309dfaa1f0935e7cfbbc1f814f4856a4984ce43915559ac40505dcce1be88e3d9c7c3654d68c68dfa1d79e63058ceafc8489b4d0b9918e27adc3f59725293d8fd5ec0185e693d2279a0cbfd661a4cbe86be82fc411b4282e965411e999be9affb93c7b694e57e3aa6215479228cd8dbc67403df9d3e73e0496aa82ac04c4f4690b14800c2ccf3f6025fa13f843ed02876958f4200dbde865c881d031817424a0f22844417dc40c0ccbfc62b77480d2529cbb87f0a112bdab1ccfa2c796976856ff0e0babc1a04b6bd1f190844620732a4fc5067c7afc636a0c870917578332fdc4ee59c71c36a5c9ea9c90ddad361648a0d7ae9fdcb4f49b4998bed1b6412b10f40d72a5a71db5254d7ca109d58662b868cb2493c81b1b5e9560f92bee109ab9805bd92576fc15f2ae03c9c928081f168e32c95a9a45c0b90e349e9f86ddf89196d9105657037ed7899e9bef8dddd38ca7d68bce23ff0591ca1cfecf66fc00a66d6e42d3899a3c84c3be87cdf3f14440f908e91f37d3e59c2dac6e21dde6e9edc90e3ec18114317708acd4aa93edc79e2c36185d2c9904b3d8993babcefc7841a8623f966730742d22a9a224ad41dea4077bd2e3eee35644ead70933ad4249295672d61414ee708742f9e8e6af2b31da0a7470448f5ac68e33dbd57f2d4b829ea8a71df58d214690dd0bf02f248b0b03a08c5f2b6c4a0dc727a89b84e69897376e74d09def752f0c4ba264b05a79fc194e29d79bd375a1d217408de12748388b737c80cad25f30819a005c1a71289195d54be8dc1700a4c82e67cf87fc4c938730e07810362ccf258f615c522f7fd215b6bb9fcb169cfa8e72adab65e2bc2b3374c6ffff1f735dfec34acbf1dce1d8e845d0d91f5721495231b1678b45b956f47115e2f190ef14efe27c1b8b31fb92d41734db0ae1df644117ca3f54933c9a51988f24a20851d7b66cbb50d9e47e26e45a45f6537de44f4051f52fa0afa4945e718ee838c17722e5d87b312d4d18d68ea5995516569a43b4c1ecdcf39529f02284c845349454f7927a6b32a6c75063618e4993128d7350f88ed3dd47fc7670308892c1b40b092a8706b3192822f9867ffba4375423767dd661eae25f6eddadb0bef95314d8e2ec7cdc3a9070086ce790b210e026c7606807d14b039a0ea14d89fc3f32211abd1353841dbc762bce21c05249926783ada0b37c78132b587652d58b4138ea54fcce8cc85e01faa1df8f6b6314eba01c281b60a25d3b80522d2fb5525158bd9fcec0ded9299b44ee262023e70a20205a4ac21b8f243de23fcfec3d57cc33f784b448d050172e8451767458ae5c657838cd1f07f591c84586eecc8c88adec8309fd2c25c7e4bcf7cd19645f15ddb3b39037413fd345b9da74bb2bd58aa8e1ad60b311ca4ceb5661ac80ff43d1475b22578753553360825cb8423a5f1237b96f9a6b8d3155a70e36f4e3e6deb8b6bef73dbb6fd90a198003a92d0b66404c3eb903527dd1c3e13610433c3ef473eca055e6169fb5d7d1df0c974aa133beb7936bebc4c48859deb01e2697bd00a0f4bfe3a8f1245709ddc4af19ef94bf8171c836b3b55d6f42a0849f2477cc67fedde8c3d45eb36a5098d93abc0ffb59b8c9454e1a0568ad0b0c4eddc8eccef9fc0f6ce95ac849c3729692ad4137afc1c4a00fed09ced4160d5f18ceb26c7a87d636c31553cff3585277d34653ac8e238179af16cccfb16d13a3fc041379505bf8957ca2652da9f3006d3a87bb06b2add1db30a87faf17c77befdf30deee0e0099c462be86391be4b40c539164d633d756bea1de53391cbc9b19c8fcf1f36cf866bad81696c6c615d46806a2e32a78ec3ad4c6bb97403ec1080f311c7064c98959df6536b52f5a6fbd85105942be4e166f6f5242efe68020b4d2f66232484b87cace08e9f2bd9b1cd78e8f624657d556d749efaf33bccbcc994a80e0e3ae5de02225ae6b90a57a37c6a08d29098ac1dc534c8f920029969b542e95eaf11068d4e5b3919ae549ac33813381c819590d86a7f09aea3d6aaa4bae6267234b4dfe0f08da3e3281647ba0600734e2f61dbe432446283afe69eb76e558c876f24461dedf8229dd04bd33c65cd6f859f394d14b56b57c67694da2461d08e51cc87ebd96d1c7cc04190e50204ab77f071df8f9ba7e1214ca447122f09af9777d9a9402aca7f47fe2c48439758d5db4e9b024fb565fe315cfa2287b7a47cbf791364811d7fbfb327d56888d4ffa404844b9892f321197aad82044cd3855266ce6dbb26004e03511b7957db0ce9907de91785da546f0341f02b928abf2fd79835db1d74158ccb91434e9ddb2dde410f62608229bf72a1d9972301164824e39eab84433a7a8b1f17022b87bf97b227b6ce2b8dc7d2da787b493bf779b634b80c127ae5cddb7adbffda366051e7d3e601e2765c854a39bebe8aca58ed0d40f9f62b4c415d4fba3e9e73d7b2281779bbf9302bcf5b6a44de72b74bce77b6ac488e99da01fc1c44b5a5303e5034b9ce6ce82bb4d30bfb800b71ac1985ddb06b7137db0f4b49391f7a13189ff3ac526483a1471e6b7af02a0e2219ba0ac2da5777b3fbb75a6d2a33e15f0fefad9b9b6f68a8d97199a5d7eaa6bc347788ac2817bd2e29c388b68b4edffd7243ff373cacab071a32e6b9a5b74626455156517f2ee653c16fba2e49961208a70a93f498e0d2fbb83eac3d0d226857f7206baf1a71f9af8140d1c6913b993850c5bab4ef53c7d0ff5cd2a03f7517adc99de3e179da5c149d5f9e5627ac290046645838c1f22b978d0f367622828b0ee7f325db9b834df0f23615a372f2c0f7f53607514d3cd5626f165911cd0da532c9e9c1d9479a0a981afa50f5f321cb0b8e63c24c252c0248e1ca49c7355bb7d89a2579f9b1c032cf3de9a30a3ff1061d65305000ce9f213decc7f396ab9648e1b914923eafc9b29ffc21679e91e9dd303210b1df24fba75e263041145ebaf60278677a899443dc833b3d5e8d4f5f0743fe2a3ff4f74519919adffdd2376d82c7bdafcbe5424892135b61deeea51938fca7c2c8f427dc4e72789d658a3b793a332f889383c0aa9c59cec3086c05477e45c5934fcf952aa6e1c2396f9bec3b1e7d3665e789b0eb9a338cbe6afe99d51794018fb83538b12b1ffb307e5f38a8ea577132b5ea220dd2343caee28c9793ca69476a53668f027558c85a916f3be4652207584ccfa9f952ef9fe5d25636f0a18ac90b2644a35480afa12d717556a9d21c5bcb325b0a624064777fe83f0c4a09c57123ca6161802157b19215d6094a6c3c73200e5a31ef2ddd1754e1fcc796c840253aab6745f50eaf7a845978158caec90cecbd5dcb49f122b292d77a3f89f9fe448019f476ee69da73641b2d5714af83b23efb51db90d4c737275d0b89ea7745b2c0fdc003cff8d0d8e2e30be4a5a6aa21602a383e8813dc41ca75bcecea20076d0d5bf3e56f52f1047f32445e361b8dd18361621871670deed78bff3927a36d4ccca0a9280a706d6f580445c17f36da05ee24c489894f81a7edcde24f43c3632074a116651c9af5920fdc960ddf8757d53371e4764fb547fae2bd98d2d946d02f615512268342deb8336a7e7b21efa0e787fdd81c1bee3c0857f5ce4335bb6f8480f60c4bb75d25c7f9c05b92fb5f891c15b6a31e06eb9073f6d95f86f7339f236ab913a17d6e1462ae4c7174f158e1a0c19e882b71061695b719c51adc1b8b71af70e287678bb5bb24b484653c6d360ee309d75a668555d09aac8bf5fba87fbabf8a7d2bc28a0e3f1718a3c18b62889e9553454356fb28a21e72eefe282e9a36353afc9e28659dd518cf1aec1fedd90a4402ebabb35d4f68cf4d2a62a5d71baf7ca65671bd00df56e2b0622b3ffe6ec9d3f7906e9908c59d347a8572e2efdbd98e465226638bd96900ddfbfb977bc54652897bed5f9ab207c19cb8e4abb224adbfd9d61f48c89c720ef1b04eb1af1492760924e347bdcf8dfa9e738e9173f1e9e6f9da0579e5af7cce7cb214a7fe54a37cb04b09364cc4304e217da947c34a3a7fcf8f40dbeeb8625fe7db5803d2a180de1346e2c8331151a4154f1ad0c7dac9837da2c9d802afcb7b14e487773058cc4dbc1400b101b1f0babaf78f0c4962bcc8ce985e573ef30ea72fe3b05a0a399b2473221a09e4b1b72957cd74cca1a990d4e685061a52c3f0585dc7d5031c223df74a69e1e68b9b33b3ec9757eba4ac8b87d5e0ccff6ae5969f6703dd5d30d9a03645ab7e797ccae2c5fccbcacadb49dfc7225c915d4fda950280f23d6164f421cb7e590b705396251df6211eaf2e3c6e4d9496f14206b1a38fbe1db8efcc4c1a45723c5d5b2eacd65f81fe4fecafaac0098037249b32aee7ebefbca82b596c8dac52d3cb0b1c60ec276805472b0b9db2d8f80dc80816a6d8b759b68ff7f6a96822c5235666161c75b3c1aa53d71205233a835beb2bb303f0198303a02f4b1ff1e00eedbc32d96c7907f8b2b28e25fb5b2d9e4d6e696c0a579d7f19643f094a9f24aee0b5b5c1b099b1fd5eb868ed913022c2af944027832bc9c58fb4b4992a857a30547770a7eaf202b7bc4f37a5912d79086c07a8eba17c0f6f2fa9c39b32ff114c3980f39e37f2e62421046d796f21dffdd0a6bc43088b075caf605a7bf2d801b1589bfbc79301f84d3f3cb6a8460c9d0905a30471e66e50bcc0330a0bbd71db506f4d612e7e4c6eeaf770ccc207b96630cee319313a3b31346b49b59ab7858afd8a51cfeef223f7f2085ae36ae4bb42375a74c9fd79024e5ea90d6cc333df99213e821c0e7100cb33a6e45b40cdd80b967dd923d14affd0b1f2600f1e0704334ff89d9febdd4876463e608b683d65637db3232e152820e0d5d077e2bd5984a88a94705df1f4dc3583173e055f69241b50bde582361a6ddd9c825bcee6a006bfc772c845e2875ae7b666d484e8e7c8dc678cf7c56e4e6164ffedc27ccf67ddb1ddbf56b765c7f2abab1a3bb46b547c36c5a83785c7ed6f000ba2fec9bb3c62899a452a639bb7ef9303ce61823e72e8bd605300207a75b34ad5fd8c0838965fd4665dd5664d03346fac900cbf399278a3a97bfbd1c31ee1173e69e395c4570ddd761d39f633db9787704636aa4efe21076bac516b2fe69ad8f8cf805dad6f7fe09370c2bc6c4ebabcedf6dd8752ef1af8b4f77bd6ce393ea59a6c6d1dc0f0eb9a09fef5cd3a3961ca7e7fc9cb5db148e7c116a52ea4399f5b9ca8a40e55b50b9862ff9bf1e7cf84857face5c0e71493070bc64e4934086a098aae022a0366eb211d5de01f85d473f52dfb5d0ea40a1c2c5d43b06fcc733b85623a4e5358217143a98daebddaf5e6eb3b0b1a1e758433e3df1a607201f9ee4935b47899bcc3e3317aaec5c46c8f085b3183e18b7f6beef976617e39e41d0d95b7460e8eb9cc034cabed4e1cd2f70182ef3fdf2c432d3cd08913f2364801bf3846b0a9bad50670f6a7c46bc0965b7ad340af75f588a46f47abef274d4b361c9687cf12b916796eccd3fb43dded7575354bd3051e1860c7bb460af8a5de0fc6c5206d75d80ffb71487f5774203bb648492ac12a60163db3b455da7c08913fdb71ff98939d83647fb5e531799b66bc2125149b16ef1978b008066038fe7c06be418560eb1f4b4d92b2dd7f6beca26e2e3ff0a6161337f06b87f8ff756c97b6d01fd82378b57255ef464fac3b3fd1d6d09304a0257ddc4deb01c9e0ff545e3dccf6bf170aba067c2e2627bacdcb052ec73ef01691526be5f8aa4cd293562e925f5fcd338a7e240b5a706030bfaadca6a1da6040489763f4dcff18a15d342d600e4d88dd5d1b82a05a23b3de33b5d15e30cdf050248a0ebdb01ae57a1615f75c92322e844d0c4cdac5a5f846bf02703b55f8a8ef50d31fa70b2286d13d87ef0e431b2b3b45c1970063f1d896bdd2a7760981060de71087af806dc51ab7e5e05fa98abb080d2b1af2aa8250ce42452ae50c3b9739f289958ea0f78d1acceab7a8547dfae203f1474849a0e4958378143ecae0d791a7d86c22d69362d685b548962b52a98b9e3ffce8e77800db8a5ab9036bb78602275033c85a544282d8a44d63d5cced9b2942683c32f347e7dca08b1e89079168f46383d6ffee35c73016fd13beb8735e971bde61ef9f25f4d0387dfb1162ec6c92a6d636e2c068e346c4dd0f7e7e853e0ed17153291e0dfb1a06234620eff1eaea58ef2083c4f2b90d2a6a082540014095756384b92c87cce507674641a2da9d09c9d71be1deadb3a47591ef46345569b63bfbe6664dc983f295708c9c48c17c52ae60bfa3c6138fce3059774cc2bdd9e1b0e9645adef033e2df989490abee6f51df887cfda40cddc8d4b112863028cd60c5eedb554980b785d765d30d5da7e4aa2295a2e38d62eb607800e7205000e29f32d5045f12db2fcacf32c88c8035da784eaab517d2ce55c1095d320faeda1c50337e9ca475d2928b085553f0eb6e3f5cb7e7c3fff20dc4c57b2ad6426f28c677173dbe812cb1fc2efd0641f77df7d45118ec66b4c2cc39ca3f66efbd8c669c4311179771be58def7be10f0bd59cdd961ccbef1564e0183e973e2abfe2b3a4efaee127d6855a1d05d02997528d4d552e0a556df4824e24e194f27d217aae24e654a912fde3882d58eca551fbfebe0eb989dba12871782b4f605bc835d59bf9835c02dcc9f51a10435afb6c2d4bdf592e931aa1f9df821205fad9afd741fee52784f639219a4ab5e95d085ee1bf5229f66f65fefe4253417e354872e0ca427bf82b41fd0d0b2924105ddaf7d1847ea781b3eaecaa01b6f7200e2bac593430847890e553633aaccf97361e507c14483701f2af597f6ad8250a2438d83acd93ab219de91f45c1244e35a69278d0cb5300d8b5ec600be31da9be47605d9844da7bbc4f97ef09992ab80bd77214b3d26ef731d7a0873ac354fab688e6c06e2bc71af494f8f5a24479b92b9759c11c9a2b43dc2fa252999f803b047171c4ec187accc1247af509eb0e24e43547021c238f3932a598231cc062cd81e11585ec9d571e7730f4da6f131ed8fda5d2de8731bb8429e6b6b0861647658e2eec045404527865c0cc081b7f547c0cca500f5fd247f7e7ec081e2be8369103bfa27098bb080d1cd49e62aa973ebc47bdcfdbde3e32de5ed8706f9af5d6d79c12bff39ff44ba0c1eb45dd4b076d74da15512afa53debcf843cc0005842b98f767e45003abe77dd850dddaac235f80abbee748133c2cdc9b9a03baf8d6707b1f3b2e8b417f6e31059128ce7b9816d791cfa3239ad980ddcb876693d446a33d74f7448d69b687fad0a30b5c6767b1051df6662ecba4ec258c26190070de5ffea50dfd6bc9bddceab41b1d1f8601a3077377c12719dae564e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
