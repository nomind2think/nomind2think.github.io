<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38b59a6bfeff00d96e6053bc3e6c5d89dc7d14e251a54948b0dfd4dd3d62da2dae562654dea9721293e454fe5b2e34b985f87f49672306d628e80dd5978da8b819a5a8cd0e737d392a278947bc6bd7b0d78da3f254e5c14a8953ae40bc018596cd17d093b0ba90e25498064f2e5debb19829ba70d32b677a2071ea30cd6ec5ccc3f56373aeaf8e4845d1a0e1dc27ec5174b17520f204f56d238d9eafe39ba04e754051fe7a7c8059461d607cf0e88b8efd38fe75e11f9809e0c9affe4ff9681f70cd753af1451934ad3c7f0e2df73031adc5c7b3085dcf2423fc2605e57c8cd03dfb2338265e10cd3066ba88883b11b0c419c502c7dc1b69ddc609e510025576b82a381f5019bf31747e7c5802e6e7fa3e212d2b817ca47ac7f9addaf531f8ef9960b6ea70f4b4667a66e2a6548e075e522752b0c5f9b0573bdb26699a1f63aeea12d26a480c27ccbfc77c322a07fdcffe1990f9bd1b041c17e5b286d8a83fc34324f9e763eee05574cb6f4b5551c0154fcfc69367cd516276f15d814e5c9b46160bda474f80a92b27ee4e8a73a6fa13d0dc5e41c9b77f3b9f7d98b85d9c2fb9447c7cf00bdf4273491705366f133440e10a69a06f0a7844914ffb1029c28ea444133589553fe40f50ce3e8c55130631ad7a018d10c4c11d1a7529a0c18eb5e12a54e3078e7745d2c5ba626e9cc982ce95e70eddaa49f5bf11e5692e684f87e8f369339c6f0a56ca39dd82babce7a9d0302ea1dd99610bafe8e438bca9503e8c0deb91767c079a94b7c6887e03b3e9c6cbb63662b13a6e8b462579c535dc7856b81b76c201f0451d2c7c3e67071a4296725cb3ecefe9288a3fa88c633e8dc2818798491c43c31c9d99fe4608e7c60be76eebef7dfbaa595224ed42b461ec9e22c7176ff8cbe83fd6b59b0f58dee44a83b2904e5f4ed52336872c911dffdd8aecd447022815978addbd3085a5bfc51ecbe407843b7b7bbd44afff596cc0309a36211d360c99a3e00533ef03d625576c194b2621a48f572ef151ea45d20d5424807333ee01a23ed920111dadf409597cf6f0313483c9f50bb493ee645e1640448c46755d2e98339b7dd2656efabc6f08a614029bd12a6201d9539b72deb578b6b6c3594cf0a0626d4f711388bb1399299417a21407ded09ad16571032cf43cf8e7d92581f7974e42d49d07b62fde727f942b80bd11de102b81a65463a2ca5500258580fa9793119ea13b62517f0f7135ba988381ea2f21bbae7ab78b3bff42de993ab17b779d7eaa81cab417cc437ee7f96ec336c32e1f9eec605ab3fe41170f5dd272a3e4006b88c9060431aa5f7b9ab4c876e5dafe8235d5b2eb4e9f0ef8584c36a8c2784bf489a1930d3fc46390bf16531fc053a559907c1f91648ba6053d1d1860e875c97454e9d60ab84fe0a073b9a12eb8d5a0e05c7877766cf421f015a499b07fbe0e8acd22312eaad75b70df60113e76737b33a14d46f78e8d3164bd21c7ac613e582a2a73fa3ec702667d4c9b94e51952bfb7d0b6fe1dec9ee4f48c860d08cc051f5cd7d4a306ddf3b227ae66819ef96565999f18965a714b7c20f2a8d875acc4fe885ca1d2ffee265c687c5de5b3cc7aa8ee560205ac58fad75937e314cd1760f2c0c7a81d578b6bcef56c10168ad26cae022f689c32bd9095b55c15b8b1631b8909c23eb916672f188c5364ed7015680c104e67ce99c87e1b69cf4baf07fe87d4574cc72e9207009efb6572fce9dbf036a8a7ea531a3c1ff96bd8365a2ec06e45ca4c07990931312ac811112e7122323556130330e9e6d035a1847c3bfff90f492b8a151e8460c5815d915350251a4254d9f3b1f3c76cc51c4e62c5ff56d8804c7b64efe3e046c177e2e16387086920ce87f03b91bc68977be8c53a6f20e2bc665be20d210aa9933f7cc470d67b2766cc1918ab59a5296ad7795cec44e9fe66354962953ed91b470c68fff351a6e7e2fa6f3efd88a2ec7a4a53e5464a514525193bcba5b17257ac45ce4eadcd2f5d9cb752f3549d95470b14d71541fb38846e6c60320c1858c7a3f6d803f71d41841e250140717714ffafb4aca141b291eab3d579ab82741082ede8aaa5d6e05ec43b47e1497fde503c5e4a53aa0136808d6056035358a17300e3b4c0d23ef8882248a397156a7a802330d99a7f6f68d4c82b66be9ac6c059e72eda50b8d00572fe1b6df577e263d1425574b30f4d9280d321cc841f8bed5218afe9a1661dc6ffc4abf7e27963604038cdbd8217d229a97890b989aa7aa1be982537e37ab7609125a9391cc1ae777118d2fee697b0dc53f17d49c4c40eae942cd3aa0424feb183fae42489793676f54e02564e078c4e42d9f0569682ea6eb2733ac40b901f10b017a469a2b73535d391a276fed1e7d3cf07aacdd7bbe9395a8ba38068ec08ca54da91aacfbbab69d4ad5686eecca82e92c34df7c6cfb58d16d132812eb50bbe21df6bc80ae467e6864253974b77a968aeb46c0a39986845196aef2130476603fc4a2ddb4a465a4f3a86fbf11cb9023f1f5eead1e8f8621e26278afef3a9d76eb0402d20227409df2e76ad33d8ed8eeb21a892a754df377c9dd7a3515177c62c938924afc58ba0e6a0e1bd53710b1f9f5b76ee0ff1933fb504c4ea8e12ab29ba11b02af266b08368651c158d71b567b1f633b32d3e6f463da55b3dcfaff229fb8000c494bfe1e32af9578304d49f485f378a6847b4ad9ebca48de2ed172f762264b72611b05412afa7a33748689bf09193e9a10f88cb5efa7c7721289d53ac0c7e4c669e2a25639d3b94adbb4edab957bb868a13ff0d48fe3783bf05cb041e65141a9c3a56ce754dfad2dabc5d64fd70dbfcbcb8d668eb3d35663e775247f57467254ed9bdef03df3ee37c39c3c7464c523ed01e3ce090c5cb421a380b56932810a2ae0ee0fd1f7d505f44def136ce7644042a12434b43fa253e92c71e9aa6d76df48867bf2ab4985ad3977edf42310b1b54e9cd0af2879b841eeafd57e4684a82ead2eb44a9fd7aba6f4ecb254aac769c4656d6e03613da2ff21c6b3c2ff99cf1e1c84f85e3d5790819cceb4d6a3531944d6ac84d7c81e207f528bc084c38c77e9121f2d918e4faf80f5b049a0150c0a879ff701d292ecd67508a13c50a7f79f69b2fc31bf5819ba55e7be93875325a9d9bdbd869ef934cd60eba53671fb9368e4ebe3581008d17cdca3bc8a91a9c6b6f3ff1370ee71b570fdd6246672cdd578e5a1a452ecb6359dd7f433677724bb1bd2c20238cddf9587b816dd48165feb89f6dd4db487995583ca68da344642ecc35d71dd1889370212557f97d6d520751023f04fe145e17f5ed09a97152031b5574e7da7df2d23f6cf7e91b6a48a1924bdad8c6913bc1ee274e0880d720779ab6cd7868c1129f8e27d90abadc9c0baedd33899f023c8f6d761d0803dba0d13660bc33c342e3778521052865fa40336544ba09c993778dee88d8b3523a0d41a3ced98ee2a360ee158d7e96dc3a5a4205c400825a741fa28e8e5566f47df966fd289a2ef8cfe87e80794d5688dd7301896a3501240732e2640750a9d111027cba0b20ec48b15af0de6abf1e102150e1723859f372feffa3e706dd67f90300904b630b0d87723379a6b898971d44404b63122188049f2900bfc6ed8cef1d6c4ed6283492f6e05e17393a0b8433e2f6554433dfead7368e7356723b01a3a252040af69f4dc7abaf111bf638c8cf8e252a02f7a56cbe96e0b4f5f3a5d7533884ab120d04ec5620629f40e8b2e0a5c0554d9d46145dcb056658b0eb1437030de1878758c901afdd6bd85d32aef9b780f9a9616dfe364f82debeaabc289e36cf09084315b940a681d083b65835cb6e94d5c500ebd4ea7c5f84011205caa626a8cb1c258314da8902e92dfca3280317a7d794004def2dae5119c12378aea0c04d3131d52dada19a44599327f95f96d80b93c108a781ecdeeadb1a5622eca1dc62ef02d8767f38da92aaccdd401202f2fb5be5928c7e7d46b7004d4ce3b40674d1f5104ba1c8e464ca6c0d020a97aeb73a7610d07e5dc06641616cc004d8e0ecf9371d369e472046a1294350e2562dbb8141633089a309f1f3a87776ea0de5170c696d8fe2673dc2f6806af88f535eff1090f08eceba7d620d3368f010bb45afcd1a9d64c33936b971c9c4cffd35c1ccf0f6bd1f915ae5408747b139f181be731b8dcfbef93655acf5860b81766d3953ca9cae433776f7930c56e00a10de7ac4e47f569fd95dfffe45d9d400fb7d59dd913be5e60d576a9d1b7b0fa7eaca0523dfbeb8ca1c5f2f9cbc90991c3fbed06f4aa058a216ad4f847cc8b729dd210eb863e206ab5ee7f02655d0668ca77b34eb6625d2a7e76d816e1d5916c26fa39df23ec8fafecacd585f8f9c1cdacb6f72285b9098dc2fa7978d1a07b6fc94ba7f739a44102656f66bf5afd6df78feb088e469fd257fdb861e6109a1fe4dc86d7f160fc0cc5ff6558cadda2a90fb74f5c262f0d3033e4a7ebe99971f48984e916b881db12113dc0c802612d3472cb86e40621012b50590fbf38b0e2ed78b9243258f16ef7968b55a248b803e69e1416dbd7d9b315c09e49ffff2af20182ba8d02f9e865630211bb909f8545304ea915fedf05dab4e0118233c6123cf719d53c49ccd5132c876700f344ecf6fff91b51c6eadd17ef022407ad5150c8f3a9ad024c8ed70c014e840ff27e317c43509f4f11d773d1a438715f74ac5e6d464be5236daf24072dcb767ff26ac1474164b25788f05eaabe626a5b2de566fa6f7506fd0af586577a7460268f8a3c13f223dffad76e3ce08a9069b6193aa0177eb52d227ac60fdd4716787369ec051f25e96ffe4b23e28b6214947b4e274d2cbaba8c4dca3338ba5d1d37ff86ab8cb311d52704503c82ccafa9df5aa5a643dbb04653d6fa01809824024f6d3cd24b386a60f11a46e15b4e47edde3de83a8092813849a5ef3f2f5e15c69841ffd81f885b1c95a1d903cf147e5109136d1501c61f0eb8f7180e8183ba9535553fca5920f6d1b14ea06ab5f6435ba34895fe34a630adc6a6181893fb9f2b197abf0088d7ad4d77c693dd97eefbcef2dcc8349b9616334aadc3e2027a4b115281771a840d5f34a326157702d517f7a6bb8cf991b696b2c32231a05ef1d812081e644e77ca57892e47406abe7b9010190de833056c369c4e52aa21040d22f9b297451db0829fb66b6247125caffc5cfc94249c9b239b065ae3430301f1e57c200c672d2f3ca272548d17f9bb32a88bdfc7584866657cf538af0dd6d7da1fa4691043d3b8e30dcc12944ece8ada6c5ddf4eadce4fdb23e0bbd17de3116d261f866d01ff04bdf14cc8dde0f07e89b534ca293772a06cca223e409baa108ede66d551563c85ac71b4fdb13e903161008cb03e3103d28d70e46a529da14c6a2d8578d658da7dfe5a3d3857d88208e64235d144fe7ee00e91fb539165fb64b91e2bafeb16caa06a39344b6f8a0ef3961d696225ca323e8c82defb7d2886e0481503a1fafd8b3ce49703d3f77699fc61f1bdda2ebdf4b328905095eb40d18f4bb46fa5f0e54b31fc3fafc15ec00994165226c598aaef9acd7e55a0c1c5c6e50b1b9496d3579405178ffe7655201a5037972b8f32ded276908321eebe7e178ea831b6cd73394f6d618410b978326a6ab87fbd7faa8d84dc8702e6751f9a87af159a1d2485268e8b9a8a41bf7bc14219176c754e69cf7714e90854883ead31a0a52589cf30280ce6cb6be16041ebecebb0edc037d718dd05ac7c06d8917ac1d9a77e34bb2946a77253681d9df65e6467bfd1b679bcb6e3ff702d80a598cabfd2d7329db2c1d73dbd050c76c3c8728e4cf8571632ef28592fc349f0de34c9de357eb71af087aa9db2274f4627d3cb167847c26915ff2c619813069137a57bcd8da010fc537268589b60b522e512756117b0461747e7032f7260bbcef04ec7f781dfde13ef6925b0c7a8296ae2abbd002983276ec10c0c5e35df146753400f760c7583fb5b98c8a6ff55c953b6534ebc32572eb3a0791185742b37f2f387894cfc5f6e599e81070e056af7d740ac46775810e9710d9e3fcadd49318694513a5ffebf60180ad230ede63d6e26bb75113b3c0e46577e9d09ede57163a42dd72a10cf58c6daa66002ccfd490cee4e14c94bdc167798c5b7fe80b18eedbfafcfaaf6b72ca2162591e1e4887e1749ee87162b0adb6bc70aecb23261891128e15a6168ed292dd6cb03fe7d7d5f76e0dc2c517aa37e49dc72031461ac2a10f34fdd63c574aafab0e642dca1efd38b5603dd67723e1c21f5f044deeb49a4586e70069c538353bb85af2ab5bbe2bd8c187a20899dd15f56c230680ce25908c3179b461686ba9dc8db3bce2b0b6ab2b301635b97ae2b45e748f38e18e3d752bdbbabf668c62b2a43a86286b3a31b1a91265dc22d6831efbac00b0f2b41a24d6642a42623394db5a529c38fe17bccd8140962e4851f0beaf213315cb7a898ac2c45e427ecb965430582ce92cc8a128dd3132ea59061d7842fe641bb0dc4166e7c9babd24082fc877e605aac8e69c06ef680f5b831258a3be7428a8e8450adadf1d74cc65ac39db5e823372b12e208a71cae490c58398d3ba4ee2a5ebf02c9aa417e8e6c29ec34503e54ac69b439071a7b4ffa0fc952f5e2bea8f7850059f9c1a00a0999e0eda376f0a6c50caf0f60f48785b93dc9c01c3574bc6fa84f510350d6f5b0331c4f1505ad3b17c05133471e29f8057da681f92983ca60fb59a3e171321a7f759b300b8a71970bdce4c9fc7266419e1f6a973989878307304509cb2b1dd881f5e810971c689bc261778f314551c9ea5db596b8570c4775ee39a34cc471e17f0b5450ea44d9221f82bd3554516aaec79cfd857e09fd89a9eeaf020e8a2c044a9d62d0a9cf7652f9fdad3e4cbfbcff81e0f2f704a2664fd8c0ea7525bbdd147fbb0b638625d45164554a8e3b497bb98212179fac20a37693f1a9df9706f86d95e3d26473361073d2e6f1e423368175b60a3d201cc9d61dfc91c9f0ccf7d8a50fc9d2f1ec16f9dbb53b0b05ca4cc50dae60c3067095acad7c8d730e0dbed07f519fe079251d1937126e3bf5953ca1d3ebecc1120e448f568dec427b9911ca6f63e0fd9665d0488a6d750c84ff944a6c2170853f7e0397b2af0f0d9819b5284825f6e55225e3ad8031fc8896d09b48cb40a0107bfeb06f1f4d29d129f55f33a51ccb29187b832e82b85a0613f8e56028fd7ecc1caef3b5ba8aba28ebb2e9a2c253b4bdf9b7a14b702bb50aaabe3a571fbf05ce0f2492ce797c395ae83082f75dbf5f63674b7a772a95e32fbe3afa41021cadb7026c6784b59ff74d783cce8ab68cbf7c156ffe8d38d3bed98005adff0f1ba2f8493c436016409bdc0ba1c97a35d4fd90c57d3589ece746c19e8c9af56714af5ce2f30ee73685f5e478ae34171fa79788d2f1ba999f96511f3334c5de1c14bd61b9b51ba7ec06a521c8f26a68b79587f2767cc851913ef15c1852e1ccd617493ab959dd9f24c9ebeb093cdcc3bb9efac49a2c055650b9711dc22614d80fd7f390f72dbf066fdab89ff234949b0a340086568074c542de8c52c62cc36e4455039d1b20d24a810a64ff19b628b59e07962c24c34c604c6f61d1adfd96bd0a840c87a958e7569540f19b23122539fc9b5e8bf41c8b76c48bbcb012a2acb843d70163552f6eae3563ec2872268e69a000bdce3ec7fdbff00435a3643b659b563478ca074b07e62b6bbb6895edec1ec7bb00775e33ee5631d5cdbf3497a8f124bab076fba38d8822774465ef45246ee1aa397184d6b91bda305c14a2699d224a1e55b7d7eec23383b6740152ef27aafd23186817e28f03788f7f44dfae7f3f3445bb65a2ccc2620524e0734843ffd61b69028ed34462b0046e6477523c2f0264c0c9da058bc451881fc24160556e6bd45ebe8c01e2ea744a94b6fabedd62c779406322cff240ca00ff9a3a1facbcd55af7edafeb3a266e2e8c2f39f8b4bd7d2fec60321d4c59c6a398f185852eeadd16568782145f27306f4da830a6a747118ca0349b0b45279855c12c8a1fcd256fdb57df712f1a973ab2974b1134c2e7f7b711ef9aa6e22e0d8bc480b34f0ef5267dd2efa2bf4a902795c5c0d1234025e4451bc976efac3f84e01f5298f8d41ed9bc5427c9290ea95fcaa0491892aaf039fbbaa185d1d519cc116a112ce8f2aced669efc9e9f7d752c4159cb281ce454183998e9ab4a6c416965e4f0f11d1af16118eeee189b235494b348bab8188be79b714eb6b07222c5c200c1ff13f22adf73bdd7df0ee7a9d2326da1420c6d6edc1cf38ed6ce49c39a8d0904e51f681c4d4dda53105ddd81b6a8bcb16f39edb3deffaf67ee7f5e9ccf4487775d4447dfe75c665e9865f82a4d5be918d8680ef677754902a4f9fcd2f625b8518bf0d7d32d48835f12f5f465f279ec12996302e0921682c7ff904a747146236c3830578ee0e7a7833eefd35e2a39e95a633561e05e350b0f67614b2566c238a46b757db863d03e6311778072bc21198eaa02f3aaca706d466e3ed69f628a0a104ffe52dc9d977f5e7e22def8f4f95fbf4cf35f24c59a7a2b8d165e238baa6da81264463a62ac1e35500ea15311606e648fc2362d4be1e9c1eee36e776a3a83dca1d17834d829a65da4af79f0cad1cc7420ac2674cdafe56522a0236f678f72e67a0c9ea085551a6916df32b2ac7b61dfda92259a684f7f80dfa7ccf463a817bd4a0f8c4032dad4d98d5c142fe5108335197d53723a33d877ce501dbfe5e12a96b2168e0628bcc9037e71c828b6c66f10be681bfadeb63de73cfa3608f3dd6d490a074bf6f938c75f6213f024d81c99a64600121fb49aead75fe762c46ef04856ab1a29cffbe657d33bab05aa605e0d08c4688d260afa1e9cc0bc475ec67360b10561ecc54b15e338514d20fa3370c13d93751f16c5b90e2ef1e1ecb4c179e0ac922fe6d67df65bdd2078d03a2f513375c13dc328fa1051ac1b160fcc58997fb240da0897fbd015323f1f8fcec62e8598dac59a6cb6040131561a31a7838a6bcda63c044f9107c0187e264997f4b2eff63d9e5093a826eb06ea54a8b9bcf6bcb9c9fa2240216c3b55de6b26f2c2a7eead4f3630034a8d7ac7a47d4ce792f6211c6ca6e8306a68f1a50027268f5d43ed4e0a6914369ac04245271a821039b6fde04b16ad279963543cd3871b8398a629ea8907e08186ce5e6c7bd5211d5c84e3d60954ff61476e767e90df246e93032ebfce2631de25f4bc9937ea670fa8934d4a739515bf8cef8222000c3d2e689d71d1481eb47f0e521f2c17dd54b752a77b760dd1346a20fe110da47069784dd8cb40d294ff7704c160c97855a384c9be5e1b916edc59a1ab761f08ee46b6a6f289ee6dcd5c0bc7db31a45dcf89cbd159d865348cfe72becd517ce0a2abfc89a9de97bd5db596ff0e02b8534413ff4c295ed25ebbccb188020dd029585f4d17a4d088912a1f306085c869147c3458a13fb77bca8eda8ec8f543c5f9953c812e7cb04c7970ff2beaba2db387f0e90bae6bc3ed8a9e0517f5ad3f4cb090939a8887c650a73ce16153a4062f65823ab3d5db382b517f6905dcbc06a257aac59a67f5f4af6add6b02d8d7e51c7b4a349b93ae2fab2054564252271acfad31e5ed92b3dbf7473518d7a2f5ff5b3923aead6fe28df5ecd080cf4d7a047f44077c482d6616758ed2fc9ebd3edf476027bce1a630a895105484b9abd559be4918995d7a5a3ae828c7d75e88ba75dc115b42efa1933757f92042ed4fe2fdd000cf99b776491f6508312f24c6b519773cebcdf748fa06efccc5d8c3892b915b4aac52f81297a6c367fe1526ddd9f44b35526ce9eba292bf67971cd775445388ced00027b71cf071398da0c1ca94eb07c385a7c758a3f8c1b672bdd45bc5c1e76742854466cafac79febe2063a2619bacde16e3912521e03566ed136c928e57b38d1767505284b56e5bd7a5da2e0e5a57173fcee0985be0b122071563b660ee7d21895e14b6aa7ea4bffad730e5e6766bcabe84d06164698337056c8e65f8cc3d20f9c961dd38601283b96df84ec2850c4b717557178abd15886187f6fa89685cedd540b1e2d3cf62146d77f69f8fe9e64ea0a216a5823ed9ce77b75401989a114e27d7f203ea732f3baef2a6f5c88b1264cf5b9dc3fdcd249436c792f9ebc630e68f8319b93fba120dc18453c94f91d47d152765ad4a408df247810c1c1108452f8f0edf11b953c41c3498a127eaad1bf60b8b824077a7774677325e10794da6dcd79bb43cdf3d147744facb87280bd86a5fc8b79fbb2415aa5afd80607a45b24ccffba05f21d67ed82580e68bd838cd5e6feb1bcb600741bd1c74804f81c40bc867742879730b21686e796328dabaa34899e60a40c1a45a3548c8e7891159e644c0f978a8c47ba3c501cca42037fca90793329b24d7a7a5534d0c2bc9cbfc939a8cc91e5b9dc020b34bcee987f6eaa94901626daf26a2fdbe2ded46b92ede65f3dfa41db436a52fc41ac906e3bd4715d2bfa7d4db8886bf1514e8994d51ddf41dd3a52e159d23e5c3f45cbf556c9ead7cf9ec44b52340b1ea8c31f7ba296c81d53e34a41e1b9bb7032c9045fb775d1a53bf4ae7185183b3fcf50e1aa41fbbebfe3a6b1ffcb3b9b576ff42b421158d54fbc01acdd564d993212428bf3005465f821d400888eef5bde7eaa5737b43f2020b3f61f1c5aededca756d934eb449a991843aa1d3ad1614fb53577af35a4d9563db9f1a77833f0a6aa684bf7a5bd401f3a232adab464aa53bee4a6f46912060863963460a7d5dcef18a270e25ecbaf77ca35e89435f95cf7eef26d5b88d03b6a06a3dfddaecf58eb3a85e0d890d6cc36668a86a2147ab222515c5d8febf2a8b1c14bcca1afb23e259f1f50bcc38a8d6180d86dac799823e638fb502d04513f9896ca28be7780f507485130181e4365c64edf7f569facebbac5f58ed1844ffd49503643427f2e381cc5509a1595b26ab02cc720bfcc0c6862c8d67eb2324ba218d37c87280c94c4b82e782a3564232f943479bd51f7951e5788748f7837be40afa81be7bb952597d468e7c589d08c8e938ab584a02026349ad4dd6a58555d429c06a81b3f1ee83e33e04d5f485a66b6a200395f4c733ff1d4e20f7859294a8536f597e76cb3184f01490639a4d365f1572810032c9de43fa787534c79a953b17e4e7923e1d1d4dff0c7c5167f5dbb469d2a0aaf378cef67d4eb23cb729e5bd449015b912ae5181d5d07b3cb3eb0774b4c4012d35c1d519a3804eaebaab501f153c98aee329bcc8a1ecfeb953333df8599c6250464c97886347ec88de32d3d026be757eaefe53d2e4022685f2cfc08974a24f656ae2051e4e8c3d8999531a1e00e9951f1c68e4dfcb302ec5358cac386194987fc1841d745eb66fb6c2d6de39f05b65430cfd73f09611a5d88d139cc85d4bc36391b76a33c93c6598b95b0ec4995253c4fbe86c2c5ab3360d140e66d0b7152d37e9ef1cb1f8c0f4f8b85357db1c34aad62e55f367a46f65cd5ec18af27428e64fe7d49b9a59978bb2ae12cdcdb379ba8cce9f17084f33316cd66998d3b7df484005689db95dbbfc278a1c27418c741573399d6839ce50d7974277961860bd869cde8337a18452417a0d6fe305ef991df50d03242b4e8141a9d07515135f3c13e23d36ae42f65752165ab0cae18cb949e3a498608122e8105a2c05394d3b13a8134f7b7689a057afe678e47ce9411a60a439252773625223106b374c6ca73b1069d15812f77e415dc4e6134cf82327167a244606a4494983a4d30d500a0e0394dd74d30eb3dab2abb6d4ee1c318d0d84d79a6c0f9a148ed0246e3b60950607ab02bc1bea7f20a668de5c1eb598e8d1b335aca824cfd8e25acf4d06f689631537cc7d9817080696648c6db758e103b8d3f564193680f38bbbb1b941dd9fbe565f215dc8e431b1776d90c58658e49e44e6a1afdf148d8fb5c3c5b35f24debc31e44ba0292f3616194acc5f9011010a05f5dae7a229bfcfb1c10162d2bfb022b4768108e116fd018574e78999474e0630b3efbe76f20897498cc4cd9c57ce59b4df14eccf5f27f7185aecbb0ced0326247b6671824286c8cc9016f6d483d7cb4a61392aeb818984ad99690c68c2c212a73ff6bc1229305428a7f9e3c195795c949d539b1bff8544b490c6fbb279b60e343a2a1f0cde7e3e0084468b3881a6f55383c2c12c2290968faf9070f17908ad175cffc8f976ba0be12469b38c95f4df3313684713507c7a14d4c244759f65fce7392835aedd7a1e9d057a343604f64b9d165a467eac9ca3df614cd6d19422f1dc9177acc87814ae248920ed0c143205e0e5deb7a85612951450e1283973957774e62330f3645855612d788b588741b8b05fea6b50ab673079c5db6a41d62272d1297ad40c4d8762933d6141e18bafbbf6c13db3beaf4cac25b24ec5877b9eb513c30069960ed25966ff0abcc240534e9bf61bf8888810e15d212c9acc8fc49fe6901938d9ac668f3e52f9e4547aadf21cea91ce37fb2bb180d585e9b622144a4db583cfdd1aaf02c209ad0af2cecf3cddf19e137884b22180d5fece60451f2eeb43ac46bcd2c44e7c818fa979a5df2556263c81f1d7fbf97ccb78216fbe0da360e76b67cb985f8e430e5bbae47035d8ba7a03c7d26c72cbe7c9d39f8865991568e579750f7270dd00abbe89adcd133f43addb034958e19259a29d5590ea6a5ac656355d78d56e32671540c7babb9efab13d037d200716177a1530fc4179a83fc215b7e87f0dd1b34409e705c5e32a64d83e0223325adef42849a7dbbb4cf8d6dcc0d9eb987b06e68d4647310953b0cfff05dc0d3b9b94bb1a718a45ac2252e83b06e1d8b0f51915553c5641117ca4caacd2d6f69534301d0c09c02b6cbece64eede972ceb66ed5de27cd3bf04dab1666d7f7a377cbde9af1f7b249f5d16cb0cc66f7b03953cd3e68f4d31e12405579f6f2326c6ddc0d946f7141e4594d2f8453b41881a41583edcad8bfd67e2c6cc3396e352680a0cc80fb85c17e77d5f84678161c2518857f0407444ab93849b599fa04898276d6ac1a7b9d297e33d5c9a60705b2e736623cbb37926862bc1ec30c81edc1d38975eab3dfc788922bbd25cc90fad702f20414988775929cbbc60180ca4a1c4eca1bf7f4cffcc0c0ce9a6bfece5b18e462e0d2a67623fc98a2e438d214c317e6b7e03349c110adda78d8e1461ba6332aa39784ce042495745779514cd17e4e5bb1d2c8f8658b859b52cd902ad896d7a302333919895e5f272adc48df6c1266d0e2c50eefe48c8cdeb20364e6763f86d57d20553481cada360143fdcc5d4c555113297c2a1de4a9825752806eb7b827420974de8ba78e2ab5e531439ba3407d75bb920420c21baf0e8c68829a15412cd9fba9b9247fbb1af32ac6b3c636e96d434548fbff893657a8abce0e30b9f8fe166456344d01e68be48441113385d5d19b2c91a435ffb0a7f8dcabf39a3baa1ef45b08ff84536a77a5e18aeb02ae9f540b962a8e0b4b2d9349baca5123276f393eeefc4713df94dd540e9d0e4426e443fc384974b29b86351ce9b17ce90236e7e286acfb13624dd13503fed8b99d5e9016258a94609d07eb5b39c5eb3c2d406e388cbcac30f26d1fbd3d0e0d2cff6c1799e841d3f1569ca06665860ae19e561c415e821bbb0c1220d8cc56c7d5349987d792d2f224e5956b0666662e2a6260db7422a91279aae4eb5ddf25935776bf8e6390bfe498ecbb0690c88e1e310d400dc4d60932f3e2092853bc7771c5527704e06436d91b1fb78266e7f20b4dd95eb7116a476578591cff252fb0008ee7f4b28d6142c7d16d2cb678c5ad45caeaf964608e59d4d356e17792374a4aed6923976671d3fe70451eb54b36f3fb90ee45fe4cfa931bea6f19aabe8f5422fc13e83a568c828c9b474d85654e15adb31ceb679d7e15f87c954c59d1fafc4800a0691ddb4db29265150cb9f6fe603bb5e8b4960f3779c1cedeb42ec1282537af6509a3c24b9af17f85a3c8655052f19c88381dc9acc5ffc7bfc5a3ca71a7d4b2931dd41dcbde03f53859322505a41be053cf8c27ab25c427cf01ef66dbff7b74ac6daead04d5f595c258a1d966bf75c6d84ac382c1a29f7555343b28bad6efd81a011f9306ed5c8d7c28f8df01f8f1d1f785dee73ed6d9e0d13dad1313d47f9d115bc327acdd6c75475205413a5599de46785112495dfb353af0e1762b928ae4fe3a08b903a79ddc8f9e3b3666fc94fee9e8b8f009cb9a2849c55d92eb614fa44aad9f19cd8fa17f93c6dbeda8cd4a378450612984196e092244f10ab065181b3eebdf08fd1d69a2d74b666d62c5285421cbc4e3155d76ed8bde511e245a065360d0ecb696b1b8b59feb11f748bc2aa4778794423724f4b951739548bf7c3b59fb216085146b5ec9e1c756f880e43840ba9a211cb354e7f49b8a06a34e663e2359d98f529a9deabf5e30c87c0253889f4c1877850687bbf11c57b554af2505d1f62e728011ee9b5f7f03e33f86c9b74fca75fbd554f6357a9144b0499bdef901c00624d2459b02fba40679c350dc8b021eeb6d783fc443ee18929a56d819c3c53c567a874831927caa234c8f254f14ddf4e3ecf60d73194bdc078366f462e7fbb335ea0886820a0fbbfcdf61f5043b649d1a6134b02cb0235d48065c372ef836593445490b0b6eb675becd4e3d8a6f66a9db202fd2de9102bac1930038220f86ef43c0d59b374e263420da43f03430cf39880943ed8d97abfbd767a553ddb3ec457ba1962d454c0c019d48270c4dd79e2ab46f93f69d0d63b9c964c7b9c9522fa298e0ea26fe25357fa271b32b3e6946b886074bace850fa6024570a77655773f743e4b2c8e1a2ac30068856180422534239db6d5c23c1dcfc45c8f8ada323a7aad698ba1515bb62bc6c1ee4721d2c7bf4b3af287f11392d33be1000ea1fd7f9151cc6b13d99bff0451eb77aecc793e28982e0d8feb657cd519e655ca3b2c8d27672c1ff8b9a96101d9c41295744ad74bb67408cf7d1678015b185abb26ae8a02d9c49d148352cb44e3e71758b95ab833f9951f1a4644960053c8113b3c0563c9572d780f619e09112a320c20edbdfb571f54956d6ab538db41e3f9b0b80e3b22950c6771542eb96dee3c11087618d09b7753def42d88a59c91e33873ace445c7217d825aa8fdde7958fdbb937b68d681746ae26ec6ab3249ad825d9e7c5a5a36f6b869e73c43ee26268c37c6c10e45981a9ddde5c29eed724fa476dba11fd355c310d944ba97fb0366cdc0256f8f40eb3b938f95a36181f0b4b680212a85e2c33f7a28cc709f7b5024376138612fe51213dfed34c0b2b292ac30cecd5b27d19eecf9562728d5b3814018dc6751762c014d729e52c2a66b7ee83a64fb6b39ea352b334eb2bc390e7d88e11ce22f8ff54ea58661c999da818913fe6216edf6f8aca1b5f7aff7e1b6924a86fa88861bfd57ad3f5c02b003a3e625be7c3d12eb7dc959163cb6e0ce4567da454610cb6394c7c50712f2cd0c5b9ffc10b849b543ea82bd0d9be293ba7628fe6ffb8b9704828997f27a892690934","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
