<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff8b700034e84f3bc1b01d2acbe98db15c8f50a8c53feb9d88578064d29922d96964487c3f7a577a51fad29a3ece4ecb36fdfa9012a306eebae56687a8860b53dee92d958393fe548b1d425f82004e3034abd7b6b3966cbfd5c2b9f4f96c7c420bd927d34ca61eef8634fb0fa668829bc6915f188c2aa02f54e36c1bc76d9e5a7e2b682f1bb9682e30847109c6c27c3d99a6c54a7162189775000aa40f8a3c06352bda252245b865e79d711cd74a778f3ca9e01d659a171af6d63fc162ab8d5bee7178b436b911e54d3effcca376100a62641a74362b8dbff6b2bf60956777f3dffae1bab938b3e620a58af9ea809773aac8a79385881189be815cdca4d8ffbfba3537a1c2f13eb6d06b34bc23bc531980ab40e697f8d3c1c76aafffa2cf5ff96d6bbba1115aca6e1636b746e58ab90d84dc2a4fc147d6693100e6cd70b07ca4053650715a85100d8af913cff033712322921bd9c3202f4eb2b424e7a2694078d36472cc92fc01feab11d0db21e9a8016f84156bc32f14482a22be81173660758c86aeecd1bec004289625c3dbd5330eea3be7cbcc2342091ac3d9561a6f58a10aa7c6cfc772b2d47966732ff1fcfbd84ce8a9fb77964053716bd970ff753189a977746e311ca37d5cdbc7803157fb1cc934f9c8e1ee24d6f9cb55a063bb1ab9cd3376b5f600cf1a9a2d9e6d63a759580733ed598a308495414a21d3608f06e930a3ba9119e4f2a648d9777d5455341791419c73e4257355e8e8bc76c6d7ce1af43c6a17da9f1a5b0e6e7ed322539bf8682c2f4ded029619f68126a18f79e749c3264f13a4c6c97f5839fdfebdabdb5373f7e787135615a77a8cb4f0fab116191c548b09a532c01f63dd56e8fda442ebbe267675b323e83bffb0eb2684f344019ed906a97ca8baf56dde111d45d5130d8dcb5fcdd5901ee1318db69ecca2ad87b34df9d537e308aa9fc8ee5de64469df778d3ab9e69e4beb6b8865a62b82ea0cb575b21e7eb883a12c79453faa5bde95352e92fa4f522b06045be49b00d56de68cbec669982c47808df9692af95a103f367ca3e3ad76cbfce96f54d49c19f5db0252ad4a63cc2e1e0a6805fc1ebffae5780f304e20aed94cc0ba799fb45776cf244148143ee5c209ed4a993f57d959ba5cf3e425cbb01b51cb381a1567f218e794b1c5101e33c4e0c44a70942446f201123ab0b48502c6fcd7ec6b0606aa7be5ed687b205bc0883914ceaa74a710bfde998a762ecdbd29e6b63d195b28c4a9cea4aea5b599469ad71c66bf47338f39eaf92a27fa4b3cacc7728682b906466d5d17fbf14fbe3cd223155bb35c967235b980d7d50f5683aa6732bdb40a5817cd1130beeaa2391934d789552a59dc4638a1fc5877fde774eeb7a83cff7d4059f6de4b2c7c31110168d0c6a1d36bf60b7d801f261e26862527d889d017afdef66d841addf5ab000c5a57bf73d34bd5865d27b0eb1f9a931d71f4adb436a535ac338dd2cdb6bc09d89b4f8b35bb0ea478ada0205e5e2c5d684d016e576951b592a84470e98315869a510160d78e2a86bc1dcd3f0512d63860e190c1d64f8999bf489be17474e19a149bbc34af31be25212de2d00829a9191bf0e02ed0987d5e88e6ffa65825f4edb83e495f1141fb54078a824defc876571e943024454a75bba8f0e4b3f9c4bd214a127f49ec4f55a75dca45e9cf2c9c044dbc483787985fc863b625acc38e9f450178c77d2d8c874f08f10a7e4bad126968712e935081e6ed779cdf25199d1ae05b864a406dd6b054c17ec284765f4b33f66664a583480c4e3d3145012fd63c18c2da16b9fcba8893b10b6002fecb1f6d2c98d21f667475efc7a17a9762ca36adb9e1afac589ff302b7e58a663da561e3d8e0acf57500117cc8d7dfa7b1f4f07decd9f45de63d629ece56311ecdd706a15b3349159b1858da5debaee5d842c7c619377499380971eb4e91d0d2f6c11b4ccab7a5f38cf291f97d4f7aac63733795cfb9a353f7ffe3773235788fbef40c7bf47d1b4f6648baecddbcb784626d337004c9592f35eb30b08d4fabb74917ea80bacdda0e182dc1e7ad2c3d9868fe52a968cecb2c833c894fb5f4d9f53f0955417912b4e7ef448674e66236250a62232f46ae801dfd1c478d0e2cac1bf5abfe794a0f81076b0de24c2d368d99b2b9d3e2febde5f1c2060401d0b4c953289f29dc3e831e37bccd5e201098269001500ad6ba4bd6ec995e87389a0c9f08fa4a8dd26da70c859ac7e62a372b04661f83a8d262ad18bc3b0a3a567cd0c98a8c0e71cd6ceec720c82281cc84025ce474504309a8b548732bb3e3faa26539b21fd96f242bff1e9530ae4bb92d8081d92d6a747a6e2db2c40ab6afb1f615eb5563c6e144dfae2d2f74eb9f3ed92d61227e75571520db88ed6fd2ca52062a0b9de9bdb41cbf2cdd478e2ac2344c5ac0f2197a399a836ca75cafdf7c559a14d13c3dd30d1e1522e68b220daf6ce4158b493d6d04c2bc60af9504dc32b1a078086783b6bb2e136bddcfb624d6884f88292cfdb25bb5ad8b65e42b5d9923529f8ad69a7d21d32c0b06d927ef565d67d0b83e1f1fe590133570e7af235fe58ab2a4e65f1cb15bc1cb6adda0e5f75e262925879bbb3fd0629c43b239c7683e6adba5cb5506ef72c243dccfab4a4ec8889896cfe71a78f37d592966b22842be36c1a9e91aab30dfd9e28c32b9843f86c9b61e37e634d4914d537783bae29922f624fb4bbb49efa4487acdef784ed2207ea11af0c72b62686d66289ec76adfdb73a17a21ebd104a8f2c843ec1714efe4a711d054f7c08e5868eb9fea5fcda389203570bd370cbcf44e96d8b271bdfcd75714c8993dca1e564dad990b17003d52216377f068f1f041112f4d5d548ea9ba78a1f201d948446acc4160e0080d7b0fef833b2e07f5b31e66669997f8ad1e01588942532eb6181571a6fcbed639e53f3ee1c3a3e418a40b1261cc1742cae869ab11e10d643f147cd94a6f2611b9486a09704f6f422d05f9169e179195d42f36aa438da235bbf6475ac3c095c6372f3aca9da431d7c6a8e29e21384dad432fa9edfbb775836f2623927ac6eb48ae473ff66516db304eb809543c6cbfd015413e03f2205e6af1bdcbde09519948c6641135c6681fca04f29dc7cf507652391f74b0a45537487e22d06eb59b9e5ff4cda359c1fafcb08ac7649111cbae6d408248ecafd294ee97c3f281468054516310c04d16eb2e3b19ec708422d50a90ee8a20980868c6c0cf4dcfb25576c20459123f9ef26f462077038a0af999252fd93ffa0cc01af3caf7280a23525d742b537377ba35d2425c7682a45c3c85fc2bcfbc2458be733264bcc0b9e6a2eb33ce5a0d149a706e57ab374555d81f7e5cfac710e3cc495c04fad89e01e2b21602d5a960cb52ed6a7bd9f7665f2f2165418401a274095c74b614c68d852019c23978af0a5a0b6c0775b1c1dd04ec177d88757f9178e31b8d9ecc2cb27d5a76257464fc3685b51fa71c97ea7612337b904234ac1f5f9fb23fcf64a5d929db850de186c8bd72f2bb54c8f239dba00b924ee9fc17f922e48d4e6b956025109acdd54410abfea18a5f9bf41f77a036816d425aa245a919767ccf1cd4564eb0b2e03e1d93e745bd1b1a00a3fd68f26f8b0d8603e231b661e7426999ab1150cecb851fc22dad9d32b44bc3e47adbaaeb61fe7964b0c9ec5446fd1b600e344acf9671caea195a579c0cf389798c98a7a633d2325e2f9bdd93565fdd51749708163dd0fb139e408d082942e157b91d62d602f86e7d006a4c8a8bf4f06da0074b5c6f58835c9207ad17244db23d5751221066d0ca93cab886e7d373941d80f8d498600e35426e0bbe5876e3beb018c9871dec69c2a64dae2e6c6021454c2152821a594dbcf1d6c273daba0374bcd36402b8b8a1f03f3ef332625de38a753bc507bf741705780dcde28bcb112bf9b9b1090fe8856b6a11bca2dcadc4c2b43624f07e5b0a3ce7a6175e024365e7b9daf63f7ba06b89bab3a5b7d51c61e4881db0505860bca52dbde4f32ca48085e89d73d828eedca4d94a210e5b9ce59f1b50f7b508b546e3ff3829fc893c8c09868a66c29267089fb0588b747cdc3185e37385b1fb246344ed833769f8f77a492ecfc61dcb178aba2f512c0aacf5e9b788f6c9d74d5defc16f75bec0808ad66fd27254c67b8ffaddb27e85d6736bdd7066c6ec9b14e8f78ad5922f80ed0bf6087094927ce8a6e39fd69d5720170afdac6c4676f375b0bb8313612a1d65dc79c20ec49c7d348c096d26201224392e71d84e2e142b136cfd08e302b895d74dd5ecad6fc351618873f2eaf62e62a6283df50b3de08e393801f1e5391e72cd5c24903aff2826daabe762aefbac2181d31277b4bb9ec2aac279e136fc1c3e899f93bf3fb64b0a203b5543ca76ee0952b1594daab3d32079b87e7c14108981d28952b27f0a1d9836acd40ccdc40fda301e8cb74218083d02ef27f1dd54218fff01ffa416960d48dac058e6dffb70400522b8e9d85b95f0ac9640b5971857db48089f0628f19db56048f4bcbc9fc6d8abdda5775ea3bc6c1c82286faba997b8e2eb0d202e50b90aec478963b7195e76ba6fc0bc81e2c4bdefb081d05f861eec35b0d67cf11a80b44605fdad761faf614c569ec4e672d45e57eff665a83e8edab2ab3c0ba3a8df702fa215da584cac5654014557255b562dda82b9eeb1c701cbdb672755c086bb49f6d8c5b23c2206828d1f01640d546471439e7ee885ed6670565d51ee498e5c4bc9e5ad3fafa4a7e2cf47c387de8133727cb1c9c00cf73cad31b4c2e8490626b5c54a814195e12a204857530587dec008b70d6524855cc79dd1bb5bef593875ce2785e86326457599b008c1faacd2a909845bbdfb6bae06da6a1ccd8cf84d9427a93218af73ac68ce5d5b5aae27b9eda25fef8fab17c239d49269d34bdb22bcfe7ba95de2c6f129c642ac22315d81da9d435c339649df5d3fa492ea64226c46d0f0a8cc07a3c6d8d8f32950f60d681c8549273e7a405889b0e891caa0869974664842dbd43f5194cf92ad9c522d8e0944d6e58449f1a36fa9b7b2ebb079d8bf06f2e664d4ef35106613c81085517b756b28d258b0d5ecc5886822dcb85f026854103118e1668957dd75c9dfe667d8298172f486eacb9ac9fb1caa83801b9caefecf2d54a8180b16ddb4a424f4f24f90ebac958cfd37468a9f52c89820e4d65f3b6cf9b5f907e06356aa742de2858660fda42710c47e28bdb89e18e16fc0492e2d8558382d605b2fd526fc43a95e040a3cef332406d280af2c048768f09cd7b8ee16293999e87bfe9baafadf3fd0c0c585f3405fb1a322b6365aedf4262a72137de658e463935482a1d047501072df0ce3014cbbd9c3c5788ed78570d005be3f7a5147a7c6998ffab2995e408e4a29b569c7f9e7591c51a1cff8089b6f41096f9d08e6319bd1fc8996e227af52ba80cb2c83fac817fae63a7cff1dfc20ace574a893db85ed7c02a89f746acdf43241902586ec0a17b87f0c558cc774fd3c1511b7c78ac62fb54754cc57990679632b1a7b0fdfa0d9b8a3136f655051030a58a640be53dc13280bf6923cff3dd8bdd6697b0835aef5b6420db49c44bb813fad29965588d9562658498cefc61d65ea181ccd9e488fe2d500131e7c06625f5fa63c6f1913f604ae820b58d4fe9afdf4cfa06dcca70897141b732af9ac575200aca7ad4f301b1a85c79398216a4320ca62f91f694a6afde418331b37633647b26ab721725cd42b0824555d5c25f27f3d96b02ee2b1bcc409ba281b648b47f5693454627df903fbf5e9223d834dda4d9a13b6a0026e2a9af3745242171ebe203f542b26c5b48fd62147c32e75d4cf8d5c0c3e151f1ff3062c371495d4a716f162f590b661538f51c3f86619e40c0ad057cf46e88e03232c1387d3d331024ef357518a008cb46cb1802a5cb8038da60ab6b85e61776f8f542fefec5bae6880999e17d18a38ab289ddf170ddf473abb1ccbb0160fe2d6327fbababa61ee51497d1dd7b045c8f20780ef251bfe513782ca8e0737b117f43fb0534808b0deb88e6a283e52ebb0acdb7a663cfb9a6a1f94c1946e5bd76e4fef00293a9005480e1d7905b938b8a4e17af107244beab3afbbf34dcd1c038590f84b54565fc254a7e8d4c1797bccedcc82cdd5c300bc31d8f544926f78369f58686bda8c61d0fc7fe0bae971ed653cedb7f97c26f81fdaaa116e5a1f061ead7efa0b6b27bf2e0c0dfb00d95547090b66cbfc6c4e2082f672b05e2a152646374bc59fbad49c3eec1b902084f359e716fc78764d6761007a3be13788b4d6fdc8d691f959a3dadbf6bd141dc11ef4f92a85f0621be7d15b4151d7ab4f6e68a5fffb693093cb806c78c236c85d405095b2ea4c03853ae58929f6268a7ebb13f4b942ad259098b81023ca3c67a270914dba2cf2c9202c4ac2f4226950b2ec8ee41c39624fee9a09ca8c06abe1cc798ed33e7fec662761051126e9411d14760e31e40e5a15ef3c7b62384dbbca2041af2eaa89d390430f7ab49d3570c8edd5b42c163e136aed53c78871195bf1df7ad942cb0bfc5e74c21e7ac928c195748edf28fd1ee9878c5692e1a7e28dca454c3ebbb5b667bed3e18178a9de7c7a397fb4ded909d181348a686d9601588ebfaa5e7b529ede51122c851efd169f2b771fc061857553ae263177a2406aec5db6e029b42f1f23decd69864fce77ba7d0b9deba0fd155b7975184763f9f8dfb2f46c1e4cb274ede98bef8ae164f72fc2e4d12ef02c9a4e04d38a5427cc2a44afb89374810deb2e51943a80147fc35b33e5d8890581be43a499a274baec28d2f76fa84d758df4b8ab6ee1010f28ed255a2174fec04a59c0696ac938b94e3e720984c4144f123549c3b17913fa2349ec4a7619d78ffe79cbf63a85f8440678807dba8101567945e0ca6a5888453cd961ed4825ffa625a993ce3fe31fd9f9f61ddd86b2c9c3b952df9c8b8308fe09c2146aa43716291da5b3b20e097242c7e03c806607fb79c0e7a2ff0d1204849b0c07e6f764dbee153d2112f68ee3c5aeef345cc0f4a314b093925345c918bb1654463a15344ceb28d4a7b269fe4c96ee80812707a8635a2f03b06d24e10def0d7a05ea70b50a44897757db168636ccf3c6ff18f76dd2f875b48d07d648b5a84ca92bca438d9e5833e1b28b98bbe90bea0316f40cfa4d97665a329624204407d9f09686ac27c252cd373ed531ab3ddb682284e4d06b90cc127dd8ccd4dde33197805a4efffb2ed06e76a2cbf8f3daa56327a61a7409921cb0eb95b025964eb9b1d1048156c1f676ba08afae0e2fe76529e416cf139e316905f2fa82e6297ff8a66c71e4cbfd8d6ab969a1addf10ee3f16246dda217acd2adc29e295c122ce6ce24438d60f9063d375de7c17d1453f301d6298b1bd26b8e817cf0f9f8b9ce1bf962caf8086eb5a9d224f0b164fe961364b411d24ad21d5cbb214e38b96273cb8e1760cefd6122b58af8bc761d2c8c9d70d833f79b291c8ff425a55be988af0e5a53a1ef05d128ad220625c65ecc65b1a8dc9052db0b0296877dc1373097fbf492dd29c115e7418cf46fa92017b82babf9577860eff735cf3a0c27eca907837ccd0cfff19c52b47c70380ad9bc90fc7954a540e151f7965f891d2106495c8b188ecc3794eebbe95d1c2d1785812291bea015200a6df6f1edef81f3939cd568cf6f70068b71f4cb13050739a8d57a54766707c9e976b219067c94ca24ad7631dba0ca94fcc765d8759a0ac77c4c91005f1d9576d955bfe305230bfbd9792376cfb43343e96596a5ed0610a9056ea2aa6f1e23087f48fcc4fc04b434d349a8b2cf08c8f807e763dd0f4bc379d9aa4c4d728ec35e2a913825bde0e07f0356787b0a53be5de508d57873a86fbf64004ae120ee01d604ecda764a3bb2793defec7499ed1e763cbda6e8d50b5dae462cbd81e21b968a7999bbb8bbd0b3ae327d7c9e9c00cfef093d926a1f7fd6b6cc19ab6104774541b6e805b9058b33cd20809b550a3e92ffe3d1cbaaad49e2ef2c763a0035d37e6534313d2d53cef0bbc54a9dfe5ee25d1b560467ca7ee23ff736dffaa4d195fa6a86826c589a9f6293ca29f8d243148e30f14971ebca6bc950ed967aa16cff61e61d3a22cab57745290e5e6ccc497663a66cacff1556953fa362d171e11abb507a604fa681062fcd93d30c3f5df316e33329317de57525c4a04001eaece124edeff3f5a036d75f11667d61764af0ea56c770e4cd84379bd741134e62bc38d8d393cf6e3eda976dc8056d4ea83db6cec6c68cbe4293355e84d12f95524be993acaf945781cca010db4591a9e37e8f9c194c708f22d5e56e4cffc733a5d9eb207328e661168dc1d10fb22cab241abf00917a465602a29b6b686e99e93172068233ee7627af05418723d96d3e2d6ae32fbeb06a8d613ebe3aeada72b392624cb965b4d1dac0e58900a0baa55813f4775bda24907f86d7b21c7d7fddbc2951df1627d8dd11e55c6a90a93b5a497a72262dacaa98e0c365796006e59f1d94bef4cf39b4b04c185286fc63dd7f6e5a4e67adc768441271f8e3d0b5b7646d60e216434c52b44db37cdcc3ed5fe8c7c8c5ad902369d86e0ef61946040fa3365c2529c5abc8a0ddfb5452206364718a29b0751ebffa6f50e0d41b462565455135839af2e693a9331d82a5400a0c5ea6adf0a7ae03e22b62ad01c69faf450030292579970120efe32f6a5035c5308755f40b13b7e1d49f70ecdb3424d6ca8b65f2b7fc5cc71bfebd70cfc97beaf1740791e6990a772a887e9fb0f02f0337a19593dced3b47ea0395ade2c244efb780a6cdf8428e3998cb4b54692ca2be858efdb1f879209fb30b8cb6e56a5ed0afa2e57a7f44cacd19740774641e90c387dfbf47a35cb52cd1e87785f3d7e4969a6b2250495f26f9600d0507dfd793cbfc4f8f58da4fa29fe5c643b9f273e34daff6d192f2b5273727fd86c497989893a27a07d52ad3eda21c6a871a5c69b7f0593db245d0d2fba3dfc4bef0ce69d2e2b850b4e9a7a8b2899876a07365c237e50db47a8860903a0149a8a83dbc734098aba891fbebe7cb8cfc28eb9a2c264f970d77508d4f0d23825995e246030706f6bb8db82404a79633c54029fe9c585c6916aa203ed93dee60f7af6cc4a10bb08ff81b921e34b59c16eb2893bc3da0f07502d5f3439f2e1d43d17246fdf325ef82f4018c42e734a87f8288410251abeb43f8abf348a10fefa2eab786e71b518504b21808fd0c5b9d4b475fac3558010a6cd89ddf197368ee4b17fbb3df27bfdb38832a29e743a95dccbea423e6580cad138dba7686965c4ed6b3ab723e4b51aa3cf7b24db1301830742d7a2ced33e04682915306de06ccc5a7e789a27bf3176c66b20e5d5db3f2f84732d801a351e8fa5dd01f967d1923ff3b0c7048f595939636bdcd814ea670ac8bab465df83d2ff79061de5372ee3d194504c228995cacccbf4eb2fcd77b49e0c507f65084ebe5e3d55034283d588e310b29fd0355231a940171a042f4e127fd271a6c5997640de539c806d51819fb15acc93019ba1fb339f2103d6eb03af339eb580d7bc2d9453bff9bc9f8f73bd4a13dda93804c8d23af552042cbf6dc4d5503be8ffb141f7b9d868d107a93592717d5624e4d859db3932e1a8d307eac99447f9e205a8954d013b0541490d0567f283c4f04690b1c14d8f2c8f4170a5ea4d0a2c283636ab5c16a1a055246fc507f9e1b37c3dcceb6841dcad4e210f54c46faf4237f597ce80872627468698c6b99dc45531316a433db5488b1c2198d26b927878b34d19f38c96f342f05ad407b93e5b514a9b7bb5b89a36d467f63c4eea2977a1dff8abb77188cf26e9d37d4026ababc4058108eff9a7fae68d90ff71de0fe2846f362ed5e9521b89ef121a8bdb54631bff9073b28392f5ba598eea9bf6376b4eed16d889c875a132a4201e5eee23d0e33ae5af217537a26c88eed354e194b319718b4ec41eb5dd2f8a594a6bb97ea1831a633af758b6b3e1309af60849b716faf3c90bf18e823957394ec909d1c5e232816c832fc84a36903a88c135f03326cb47285bd79d5eb22dd1c71932f478d6aa4c06d21650088321dc39cd1f592c9a3c21e59dff249fd7b0db93fcef22b669194b12feb9cd20b110f9c4f938123cbd456d9763db20e46e551139496bf2e03f00278c71eb68abe35d12361ecad8e553a69a8737e7dbef95b9c968a5b88aa7452b9db81808794fad933e3d043804fa8a6358a2aac2d07906134ed40004d000cb49ec277d700d5e81e5383666f7c206728293fc5aba699c9cd64851fbc9f7b3286e151b108da9c73f31f86937458e56751a256bdfcdd2f69d9f00a327a2eea854a0f829425b3726ff2adeba5790ff03e096f22997839504fbdb657e1f1ba55496e8bd6db3cb6576ea1b5a07bb2fb2a4abd096a229924824009972810943514578924b99bea866de17f942ed26baac807488dc096af1cfad24fda5190a21524bbb3feccb9bd05110f28cb2f764cadbca3e3e21a55e42062b520cf7766144f8984aae20a9bf21923f5fa94e7d42df2af2aacfb0804b8d8736d924e2ae3beae487c5e6026a5917ded7f3092888357853053c6352b3b9df6d58919c3b5bd2984824bf8a6497169aa6030768eefe1e0018fa617d4cdb3451ce82bfd2e0789001e76cc20eec0613c7fd427005bca52eb406cb675a093306d0f84c07ef8c70e616422e838d7acb63bce6d01dc6267f991e1e3e41267436d99ef594344a0f1fef202d8396a7f430ab8295c0ce380399e7ff39f6b6899e5781c848f418d8fd8adee82a503724a2bc91acce745619309ebe8d85499e8608179ece2f56b551bec27f5ebb0f6652b2d5477d94b7dbfe254bb0d8310e99e591359dd72309cdc3db084c06ed5e60cdcacb3c8b822308421634b52b6a881ebdf86716afb10037c25c22222dcc328857bef027bdab4bba544d7102180ae967bb8ffa57e9229f0d3da42a1e0d9d3bc94e927287513dd63903a71bdbacdf53e54d1e72f9738cf38fb6c5c0fbbfdc549b73a228a8aba23db20ba21db5e4bae35b85b0fa087dec46fcb7d7bf63708b59c60d1098700c7b7fa3bdd81aac605b63f4febdabe9836e2cee5dda7bc3268639892d5553befdbbbe21e5b5bf1f155c482cc4e9b8465ed9d39a99049e5993a9a3beb1e81d2048c02972be70968e6a5ef0866a90fa94b731f5ce134ecdbcdc56d87a562d332711270d5a664aac0483e8a40750552d080472d25dec304cff58de6344a0705181ab7783811a1957135a0b883bfa694465e06a1e2f4f52ecd6ffaa82fdbe2c1cafa706f95e896b7626083d031145132402e5c000ff8d85af3459e4091825ba8c83fc43541cd93e09db5cb897b7f8ce19764e54e71205cfead63fa3218bfe5dc5e9b344be4f0caa61c78a6980aa43f8618064af6928e6b3715cb520a2c4dc3615068abd9aa67734685511d04666680f4a37530bbb30c8ba543c8c911b72c1ac2fcc1ecbf6d3f48079c4102c0bda66ca4bd39245264df1c262d4efada9623adf345cdca3a9637c54d08f1e6393441576be37fcfc8b01e1d4ff335d676b8135aa7e2496025e7f5d6518679587c6972d6236f3af0c1b9a4a0aba4f82a270827b8a588db94ccbfa70417cb8076b01bf3aae5aad9f5d56dbd02fba1ba12cf3dab10220eaa7720b4cbc571fd226d6cb89eb3ff68f1ccd9005c537acbc2296180554ec0728182af7ac7d83c6c924648be1f32a931ca0e1f8ea5b48f5a531a816a91405cdc3663baa33ab17115232891779e1b3c48999d7c8943d41fdfbf8511fc49f041d5678bef5e4760558adbea028e4ab1e763324917e4321d7866b660b6da032c827dc7a8145eb64f7b34aecd2e157c58a080028bc96e4b77fe1c58922cff5a2050dbf4a8766110066431257fb648733e2fde7e287f7df23642ef792de3fc676c7498210ce5cb78691093b6a8497abe81c339725c420da37c7f62a4b480f8f37cc7c4d7c2aca84975c6191fd5d3f4cc50fca40ea3ad570231b2ead0d12bccf0961435ad48a9dfb9745704f92161bd09903fc4a929a1dab946ed784a9cdeac18fdd5b288b77e849cf9750bd044088435fdecef99071e6c84c4ccd9b48067b90b86c2be4b3cee127157b3daf6e6cc562ee24e5e4bec9d7b750df648789023316d312f3a2c8f7fa18eef9e0a24e3848e6b19126121948134aca12a0d6678d59729017a9d5a4b84d10c333dd2e560f1d26cb56d37a77f01a4c45733832045923547174bd43b2d6b1c0f2b516071b9794e2e90280cff767123fb7a6b62ae11aea50d537c74bb336342563f97a76678bee20e170ebdcce86e6e7e40a8c74590f5abb4f0f409513543308b78c9e603766dba6114bf0bf0f3b6e013904f354b1d69f15220b2138df242da11c794eeb007c67c115f2601e2473fecc219cbd14a51fab121d81b3e9fd4a9bf3e66dd0025521fd5f4c5bc9d2f26062c1bfdcf11e26ebeea57aa40a056f0f3438d738d5c02d4ad60a5331b06fd39a579c0a87e45113461b96360667acf3aaa9ba760eb3282f0fb1288029efee8b37e28ecaf67d762a35fa725468fa86ab8420851ff6638e4f6d94ca90a41d74b7910f8a83f5a73a4406edc4a1d55d635b5ee22935cb8a93995b6bfb57023bb685cd458a47d8d0ef9435b650d9692026d42a1e94467b336864ee508ecf095e203fe040ba1ec6f71e6782b272a98546022bece947234ba596b37eaa0cbb4e99de8362d76f617ba740863620801d516abc6ab846a738591ffe19517355c45b462f23e012631f39a4561d2cdba6d3d48c71e3ceee0d38889af8216572f1cf0a8694ab16ddd300359983e417d9219eb34e07f396fcc1c4f52ec182c3c36aac259d9fbbf3804992feb32a92c05bfbef4345671652cf3adcbd2917ffaa74d1326dfd921185cab46f05b89c9391569242c6ed3f3b89b02df3b8bfe0a1e8b877b3130858197194fce1b44fdfce3117c3d74f55a16245479e53b97d73535b71b25f09957dbfce23ed8f5851539f468498d0098210f7aafb303c87cd3b2e6d3050c6b3b1226ca2c6b995b5f5aa391f6ccdbb0ca65fe5e9fd98fff63c1f2da1d3f0140953f9101ada353415f5b8fc0bc1cf3623de44f3ef26e9ced1e2067bdb8e1ae0ac112b20045139219920845758aaf85369f6e744828395b912304ba21f9adc50693d5337808d4e484d0eb7c5ebcc99e52a2a9b60224ee9dfb4a8212e94e454c2ca6b2ef460a6fa8ac03c36056fa56e9c7db010653d7d867080c3f8f0d661fd3b4d69b69b59acf94976b42d4318eb3380f9d8fbd6cd357eec80ecab7f541e7a8153d9f98c5d23a900996ce6b3aa3ed45dcdb4e24f18a0a08a8a596708bb1d8dd0cb98392cb7e54a9ac87b06b2bd02a2fb30a7c3d82e5200a533999a9439fa48a04459846b5cacda0774cfa619eb01389c770e2bd8be50bf075058ab506081955f12db6f1d302262bce064a2c771f3f8dc40b90d0e98eee911970d4da3423e104c718bb75cf630e0a6c69f42efb4a69942d49fb62515cb6551dfcf96d38d9d1a608f1057c54403237363ba563f01f4895f5d1bb928adf82c1c5be6c0dbbf8824941d3c2fb4b296d05435372266757ff5a8bcb74fa764688fc0e1e622029b9d6b099bfab62c83ac8520b4dab5e362fc850a8c4e7b2889d648894446c57812f009a7dc5032293fb1af3cc3119723ef583a64d3f83c78791ecefd0e74af3ac24184de4fd113fd765f2efb3567feb10119d3fb9d2090134e2ee30e9b0dbd1b36113780c4883285554cb0af7b390267c6d630395b71134a93cb83ab464acde74d54ab70fc6970bc0dbf24adfa8ef310fb2f065f8dcd806467bb1466d00667421e53e4cffdd66d17d9b7ff5374dc9d572c2fdd5d799bf59796075110ea768c338a866849d7ba105063826600718d2e0771a187092191d60ed8bc2b0a8ecdbeaab0356908e0f3b2f25ac4f26eed02d8a8d30747ea91fc7a246f7c9d34956a59e86b8a9f5eaa32fa4e8173be9a4aa9faf1880389cb11d755fc01f8eced1fc5b77cdcf5e0354189fa195c240b34048dd6ca9333bea99a927edc17ccab022da3564b8fa3f294ac78a458dd887b82d9c81bb44742fb9e45bd64267ec944313c95d83576d7b60c2abeaa8b758c0fb980a4a44cd1ac533e99c3a00b4f5e9839be25800ad3ca34aa52bf4c6660471a39cacf81e9da76090cf81c9378616efecc588bf0ea4453607e6b9c27f5e49f914575598fd58aaac3a01d17ec2018a16ecd71591273d0470d32c842f17788c4ba51a374bccf931c5cf49218cc948b7fb665492187d3416991c5699d008eebecd49490892dc8889ce9a9ab3387cdc1552df84ee50d75078fd38dc62c545fe24c4373e24eccb23b7e73c6d56c58b44d5bac6c29ad071a0bcf9c6a579e81da32e0a83c6d46690a6aec59a261782e54daf6c1a673832879f962f1f45484e4f5df3e170807ef43dc02725b977a2c4f166197a7f8081a0faa1d2784845bb20a32e78f1041852e4b745e98a44c68dc70d889bc2f8f7a76a654a0b1ffee208a064628c99dbb7b2fb23e675edd34dd4f99bb44fe7695cf74ebea0342b587eb1ada8ff53d76374bb18bc4f9ba90c1d88c0c83d0cb3aa926ea28e92a4afc61d1443682e6d9f0aab9083f326a142d5e08047ae7edb0717e49d817452ced0a77a3d3aa5a6f66442a73e5d9a78a9e470a7e0331353d1be390d5d1b87b234ad513f27a9cc11c594a3bfcc788e2d76f46ec63c6f05b40f051e23bc2be33535920adf5b147c75c61d19d4b649b4c18735689c455d543343d1f72f8182e0b1c1989cac8370e0d5469a0fbfe3750a7b8dedae57541e37243685ac0dcd89308e8ed34d8f49e38c00864786d9543de557a54e550c29309a3af7eec1814cc639365cb113e9e0c87f93465b708aba6c3e0f8b05756921a9da0790af3f20d436045c44db6b64f94e4aee21beeff1bfb169095a824993c3ec895052ca4f88a16b11b9bf3e6155efe1d696f5b80e72c52ee5e38fe50e94a3767cb63ee1191e167f292f1219925263f2c0c411789e90c3db13b85654117c84e004b95d4c443c171da46a81bd525467aedea9c4dc78141583555c5dd4486445e1848077c3470b51553a6ed8277718c321350bdd46b2033391f7dc1187cac51efa5ea05c04d8be0ff004ecf21dc1a458665aa91f0b7b930821649d01a471cbcf3a368aa90692288ac78410d4f4af3e3a698af52333b9f4adfbf5cf1304f241955129313f2f7fcbd89b4ba9f3970eda40fdbefc462e292011bea9c61fe22f5d321c6126796494c90e0cfce66ea735d9eae831a51354e314a9c36562703d3f02c3af9d8a44ae3795df5e50ff05c629eda07c477f6c2bc5ce113960075dc77e36e822eb2e7b9b7686c6a1205b83cd3c6ca2ea1f072f1b2664158714b63bf5fa43fb420506df881bf1c43f1bdc00931fd3795dbcfd725f00e3df5a9ff958a351a5413095c63b608cfbb188a5c959f208648ed1f35f4dd0513e580bfc2808f50930e77720a7b30e88e279f2a99e8408fd4bcfc1f375e04a59a59f83a389540f46574e11eb59853015f777adf769e182c9d0c22f2e28fe61dde875ad0c4ca37e5d2ceabb2baa0c8ef3d52eb5394239eba767b0ce00af6ff59e4cdcaf5a12e294b4c150208ab39540fe821706754da1420c11561e5a44d933d0296714393b8e10ac9d1a08279093f1f023b29fc3111b51441938b9bb6c80e6558c6db0092e323dc4f1cd51cf14712722bacf4c22bd7663f1faefffc561c8bdf3e296c56b603310b14e14cf3c2ff9f59c748e10a53688dd0305e8b08909bdf1d10a41c7cf0a8893d136bb1956eb5a509c6a16d8a11f4012bf1a2c285aef44d73e84db87c45fc94546f42051050ca82afe3bdd7629a5a1279ec88c548cdada1778f2533f439d1fde03787eea64c82f753966fb6780760f57c637615edb3521ff91fafe981907e0db1a90dc3df97dc6161504af98e00c2cbcfaa2af0a3ef95b54693e2061f12a9a59e75d1a0fe6ba1c7679a67e28be064a23a44dd1d3bc4dd360310c2a3d45e64210c46058902958149688427543c5506937ed4740a4c4a9e3df4d850440ebd6314a3f42f96ceca67dc43ebfd7317ccce6784f6a8c17973e04b0056fef2448ad12a18474ea4d782f33b41560754e094acd4d90b891c8eaaac391ba99c80f8bdfe557a4dec2006751b15907026a82ad602ea822e74aa8b64dc0e6b098d0f60a391157eac90938b7c25c0060c003672fbd191b9fd7ab42f8fcd5bf37b76d902d0d5c1953f132e98ed548524994ef3015c38d809bf3903a9c9e66230e79bedc404027f2f5232517aa5dcb008c201c834c7d914d4165a4d1475a9c4cc61b736d0022ab378f5a328e7b91a6b63ccb1c2963d46e31ee7f74fafb0bb177c319b5e7e5ec38924291d99dee46a5a1febc995bd1152088c0972142b730a46241efabacda38a770abd2d172ecb70eec3dada65fb8df416bedad712b676c218d81ecc176f6b0b4557b5ce1cc355b7869d63bba064485e1959010d7becb25ff0a6d1b6913f9115e31516cf0b78fffa0e9c29e4d11e0c8ca10f9db132a3767b361ef77832bd235f5fb131d8ec64852346a13c94920dd05227e8b24b347325ef723d950540950721e44eeb5a2f7f2757271403482fd069aa4049cdcd1cbf55f8b96092719745b4c3b61f5913bc5fe1d25eee1ca677e0ca7d60f6e0b1b24e9456cdd8edfbf22f0165674827404529fcbc5c19615c8732e7bc74f5b423d55452a30cfc6d7467aff31bb32ad5f99a0eec75e84d3ea5854e351766b100d14c9c2b3ddc9acd052a06d6e2f27d035074328d3537817a46f322802c63daa65975c51d29f57dc8b9110b87d016a09681bc452a163133f5d4d877840f4b18aba14913c1e6580fe10b4096afad20fe1d7f1efdee034f14496059c9a03f23a9d020e07c46817e01f33491a2460392edde313c222f4f905e60bba0b890a8be735b35e7df1903a47c694ffa8ea1605c3ac5f0cb01c6f134fae076319d7931d2c0933c9222c107040b52411869bc4dbb4e9f4d9fdafa23fb21c4fa3dc85446464a3fac3bae63e5e02ea525db0108617b3f35a34758ba0daf1e09c3314a81afc2f62163040776bba66fccb6f05d6646d27856bad32d64415adf8292534b22f7ab609bcba53ab1d5f8faf0e4d65e13d1a6a554616eeb8573c2284991ce70ad265763b6ab99ee647711340902657895a79893fd463bade0346b3dbb46e538aac93d770f1666a0e6f8b4250d94b7e3ca3492437d842b4e5f6e8526a401bfbb30ea70b2c20fb4588ee5a845587792324d0e46a3f8d3cd0c9deda1f24030c56ab9cddd09b0fe08ebb59c007b4db8cebf0e41e3a51213c42192a4667306ece9570374ee72c36f3e813ddcd4358e78805653688a066290fc0d452848121d1f3056a4198cdc3c656c4b309dc6aa8f72c501a5b095318b7ad73c6b3fd756aec52027ce078b24529071f9042eeddc3a9046208c11541f2e324cb05229ea1175db197de6d9d9ed31730a70030f597cd7f05e4225215cc24446c07804c4eadc44533ed10359d0be2c45189caea71620039eb7792795294f988463514a461855cc4ab6e54ad60edecbb8d1035ad755dc38102be4eae52c7ca2ca67b6e309e7e32a00a1942123c290cfa7d644b481947b543873e296f0b14159ae515329a317eb851f7a5c74c5a8debb2348c6c2ca907fe1f299e374fef53a56e978798240394ca5e9a9df7aeaa6a308245c4503821cbf53068d30f6d0bb19af0812b0420036bbbea62ebbed4f703f74ad6cfa494628f57c1f97a24c2b7461fc7bc38eb2a6a9b0591f489e70795cf74ccefabb9ed5e7f818c76f486920b808fa33a7b67489f5b085e918a13743ac62c884afd3709690ee68b9b04748b224101f2a4925b86f2b0aab447c5080480e46a1b685355b2dc557096844ed90c714ff2ec018d8a02083cc2de739abea2b03954445997fa7a20467ad4b9526dc1c2905381dbf658810fbfde9d77439532ab702fd8a085dc71e551b14a689230daaee5deab0c87d25e3ba15b4db3f2aec6be2bf54ab37449f70fb9ddeaba2b0faba028b9f97c7d3d5dbf8fc80a7b961fe7c6e3630438129def3747a1e8fccf47234df68838056c6b1b2839163c269b2cd42aa4243bde51292b34eeb34b95c67ac0368d9ad081cc72f35f4e48fa465135475035fddc6260c63a53a70808e8a5ea59d178286281300f59ebc6ba1abd4ae77c42982db2ce5a815112defdc7f7c6145e39bccff5ebfae897a93e84054c95ea694e8bfa5f732d00447c2cb9eac523a091a00de6344036bd033efbe1189e0208f2a2f45e39422d614f0c66e37bf6dcc41b335c0031b306835cb85deef5c4cce211cceb87d5ceb1f9758c87977bb32444b55b3e11e451509353b1206e111ee522bc34f99f406b0a3090109c46c4073ab22a2be8178f9f59506d6e646ae35f45d01d64b6df1e7bb9e705b97f633ef93942fa984a0fd3b85fed6b813c410c8d1d936f89a55d87e44689c44a1a595792541abfe81747b71053ace6b74d1601a964694ebb6cd357c74bc8608972379d83a3d0d4416efd367986f0b61f9b51a471f59cd0c83776da53e7bcc20fd5373f5620097946d502efc8c8ca34372c57e987b3ba52f81278a92ef248a7c4165cedbcc214f06600c7fc18a826553c7091d553c1facd32c04958bcb0ea5238232eb75edbb6a87a777641b7265785b798c28dd4dd16a2124e2403848d2e8e9ed1fc68428f3f67d792673d521f11b7be814e8b6acdd2e21a034dfa23f10dc2ae4e21836f8e271438c83268aa00801d3cd23c8cde702fcadcb5125b6ac48408c7c6d9fa462191e9baa87cf524ad2bbc4695f9232e6a2ea22241516af998d54e360448b58d4ff3cb544f12a859deaaf22bb79acbb5181b0daa7c3510872985e45f96f3a698dcc2cd1d7b13ab3706217145aae581a35ecf27224c37d79d9a30f1372330a44114a768c9e6a4eb84d18c5229723aeaebf1d0c998947b75103263f007a1ef206e26dbb429b1bf34e7a2b54194cadfb38724e1f5f40590bb9a94ce0f5d361469f66b81f6ec2cd91fa36536d9156fe07c47b5a5a1d8b9183b2066d04d30cb9ab6ac20a1f7302d0f64205c7482dabf72abec5af0b9cd99b8580b347ad039e73b7fd8636431819d62d04f497593d44005f2ec9bbd44a2bc05e6d66c30325552869ed8dff84f3f43be30dba615c96f57f801b32827e19e6f8550acd6b7e538834d8d4f77c268fef9a9c9cf8d64a1c1fdeaca4b7a5a5fd58014d102a444efb20321f21f613f07b818533b7a52ef94c88145cc676f954c5945e3f02e6171b8bc70630999eaa8c162ed38985e611973e8bbecafba129e22d2fad183b4a09d62f28e8a3d13dd1a06844020702f05a1ddda1baa91ba655bf04b48175671c26e0a4e6fad5078e1392c600d75c0fb0b798aa84baf06e9983b2667dd3507f5a0056def6f7c16e0bd7ac5b15bcdb7daac22ecdc450bd6f32a594d7ef5c345755c79b6b4435e1984073f7cedf80cf8ecf03bd0530ad61c14388af355f19fca59f28ece28ea779de364ca4b25f95c96ff8266d2471ba2d48bed046a59ef192b8028389290133c2089ce057cb4d75f73e67d4462d816f1373da1a9429aa6730cd3ef4ad78986cdda9c79919c209e1a3f31996238a22ba7de06137a789a4822db4849fdac4f4a812166f7abb4f1f8555acaab4ede5b85213dd5a63bd3b26965d25000b372ffced53d55d3f36a03a830f28bb032f15ef27f9f6c301fc02fb646e36dcede28e9a79046a6d40993119ec59f6f7c7f1c7e7a73fc302d36fa4e3a7ad91fda7543285909063618b1628e7dc035a637bdcedb01bc77cd6853a515b18a20b1a9df9a3da7a6c73e69742e82f44aced06b55251a2122f80a8eaa161b6316a3d86b7c61bd707cf5a2ae9f7c97ae04ac302ef80cdd8ff82b5d7af06a61e266698397115fced114d7cb4dce2d13848f3e4b4d9cfc24cdd3943c9147cac730e079d109921e8c18b1deb2958804ae1b5161fe1d1a1e2851a90a02795519ee9fa29f1bf362149890b40f09afca21c85b2e8f9db45796d8f579be8644c920fdf6050a6019bca1543315c04729474eb00724688dba4cfe7c6d5f37b9d27f58a0842fd26cd197f117e7513d51134329e220098d1238aca38f685024dc8cb8e4cba41988e3cc5ee704d9533c55f86f9c4670a06efff3c37411360c80b26222386c90f08d52e4b5db1f66c0f9bcc0f9620df8f4b73035a20c219286c8252a186fdcd350a4f695fd11362cbc2b055435005009ad4434395ba97e076e7a2edce6deb95bc1f37c5349dd24cdac1184f096b4b85717cab977cbb9e0d0d26939c870d7d48d484a8a4c2a2c60741a4c35df51a167e0680efc542e4acab93ec999d7defc4fcfcc5031078198699af3d1168385c718d065ecd7183f22dfae7632cee2a1e99c6b37a6a3df3f17f7954a837ae47bdec82392f7277923c83597b05a70ab16aa9931916fe792f195e80163511ecea5178f8063ba6358d17bbb701a5e8d6593d3dcf7d73ad8201c9106ba295dddf7d07c7669e6e4607892131fc990e3a11f72d4e12fbd94617179ebe97431d87fe2f56eb83dcb74d66eee4049b5e5d08dc15c32f502b54e0da57772b8365e4c3c3efac879f1f1738073e45edc734583ae8e1d229a01e2b75022026457fd3e583e8056aeb2e14a785e6a161b8d713da91b7e904eb4e65debd520beb829513ad48d5d114165ffde7d7fb73b943e16ed7125b89451ea81592dbbd9ee40bb8b263cac5dcce791962400c827cfe4db15b4f6fb83e373525f6a56236499a07e4da92b3b4023c790c669a161910eb26d74fe332820eeafc55ea570e137ec11c50fc9b45238927ecad463b2de38782f85ff22acf8cab932af5add61fc04436163bdff139eb0c189e365c3207d6645482725ce6cb856142cb2f65e4129657dac8a23103644696cb81e97f68f7d987521d16ff24f68437e6e2f52760c8fc794bad91c15de538854dbb6c5e414ef18cbf6ff2256bae75b8d576c9937a2fa06ddca5cff6f6e6da5c24f06a090d6e2617ec95384dae2724a8c18a3c4bcd39b9f9cfe67ab877a070cbd3eca330a05a00c0a2812dd1115196bcdb5b3f69eddfe050243e3eba3c553527e310bd1dac6eefbb2c037bca1c03cd2990b99f5be1f784e6445a3537c056a91fb1f206300106cf4c499a440c21ba227eb0fc690301cd2a83102eb1c2fed2ca31ef2c3210fa2a1f37726fc4f8f03a9b7ff1142b5468fe13fa19543c80c92d882e18969d68e0ee0aef3f40c7d7baedac2ae2562242d3fefed252feff89ea7a9b146b6aa78e1d6aef55b29aee4874a3f13461be914c33b046e14ce300170940efcfa75b00bbf1671a150fd29183a4c5f48c74844285a13fd149ad02942f6e8981eb7f066e2c38900646c3cd50cb3c57289f01bff4dfd4f598b507839661def1b0ca41a8ec1702321c9906d57fa98427cc203233381ecaa0df68d96cb3d5288a18e9a6831913d55750","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
