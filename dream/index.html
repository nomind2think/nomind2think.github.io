<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efc8225312f08c4c9bfe62327b01afac8bde101b40336deb0d46c392a3ed654ee361904be89a1b2dbdddd35244b8af83b3546778fb463beca626f305411901fb25a05edb4154d595092c7f77ddec42513396e1d24f1259fb11275c6aa85123c25ee0fcd6093757eecbdbe79ce85a115572361bfc3582a4f09842c172007fb178970c67de8dd999ab8670e4bee9ef08246cc5fb8b6c9e91219dd5eee2001c65be47f01e58ac61ef87cf5a73fb35d16a89cf09cb27ae607f39fefd339eec98e3e4057f419ef970826cb254bf5f9f2f0fd0d941ea705c784d7a984b564b026c9d6b3fe46024a847f5075c48f0def8bb1cd438fa14368995724cabad87628bbb23c5a2669fd66cec592d12857cfba07e5624fff93db94db5d686f88e24ce5a308074e1666665e44fb506be0d1d01c79cbc6b99cd7a07c44f58c2f98123879b26a9d236fd40bf6fc90f7d404366c26acdfe84ff7e82011bd8c5d741b5ae04a358649e050bad3fb589724c6250383aa4efe973811752a35b8bde29127112b8c3d3d3ea0e66ae63ef9d8b2e70e2190390cb89806f8e59155ce0ff62469d16ee08950d446dc24565b14fb1e8a883468921963c4c211faf634e8af79d33fea79bf6d471e10c6d9e849a8bd4663ca5875f11598702b5c23c4bb2988e86b9502e9ce4c5fed8adb8c366025d337246fdf7e14da59012dd8fb07b83c589d04b1bf0f3a69f3af78f385a56810afd4af623120c71d94c29f254d564dcf5af46186ebffe1aa88a2de735abf3fdf254bcb9797110c1f5e24bda9614f56da31ed8a60b5f2d8cb202396f57d478f52f9b5c3af577c9a93b5b855ee979f06022132db326489dd46562e2b378c7358debd7876a789da7a455cd335c5d75bb7c14e5cd30d92158ef3d3d4a04e0afd69a066e0c7b2f1403a876093bff3e4d34ab2e8238c9cd4d3e045bd8deac23a6da3fb4623a5862edab5742c2c06634a2ea2c849948e6d87ffd5e8e29b7ef0d9f35943f89f1e1e08585ad35bd36556ce3af0b4fe84876c63513db977b3c9bad0943584b43c17b751953cbee88a1769c791257bde68dd837c718dd029946726c7a62a40cbb1dd2f54b6029eb0d249b7d1dcc6d2ab1f600c25544cd7e433c44cec86a38b209e910ae73276eb6937097321fbbfe893228a337cbf706d4f3954bfda37ab42983f9751ddd2f977191335b00750f23ebbf7519b37d9174cf8d49df13362bc8abbdcd30188d10cabcfedc01318d77ed3b2c19e8b373d32200b9b55be9512489e7d078a1d9c298b476571405c36906041f3d1ee1994b22959a5adf141b417e8a0a86ef0175feacd59a2056dbf086cec3c7add1af224d707c823096fe5a7b949ba0280519fc07d850958248d0fddba739be9891ed96efd6dd071853649dcfba6f504edd5e2b0e71c81422ffdefc84d2810cba817e6c21979a442ad186e4065adba1e5c6b3b83b662c98eb84e17c3532d5a1ad9e6a8dbbd84085dca67ac75edd49fdd03e2e943daa18ff376011ee227f4a2e188b36d6842e94a6d42f9e20c486274d36a03f65a8e274d7f1352bb59c4bfe11b9d215b06761a89ce93bfefbd359b22f3dc38cdb3cde924483e19b068e2efcfd9e7d8898d4c62cc0efe3ac4cd89f62d7702b5478275aabef4a7120df0d734487b7ce85e6d4f48d2c53eeaaded0e360ed364c392292d173b3cb737ae163bf0e81313aa5c17ce81abed04d95508867a12f1a30c72cfd60531bf19cc951f2a2eb8632668d58ec560b74c46ea55c7aad35ea0a8bbb3470d7bd3a9938facce4f450debc063f763ef1d9cca18f1a495aaee1c505d518baa5eec43e62943ef56f562ef51da1ced10ac51083f4fe55aa36ff9ac49afc6aa587619c4fb4e1420f669d7976f7951bcf108245339f92cfe8eec3a11a3cde67f989e3b457f36a4bde1e3798c1bf7cb539abf1b961da9d0e6f071f78a39d950cc23916a000bfca60f8821243f9668cc43854d43df898d04031cd3b7040643331821aab27896797bf2f98669a182e86bd5fcda1ed5cd4f54c8ede80252bd2c745fa3557f852f740e3f5e9420b8812f5b24e5cdfeaf5f4b46b865f75c37449d70cfccb144e72152c5c558cbbb41a6678fde77550c550e05c050e6ffd8b9ca1cf93084925b852d7ef40cdfadf5993beb80ee996f797c3e266b6f9650d2b816b2f1f6716befe3514e6781cb672523b1610435726499af844a6fa0f83d74abfaf5e75d57d79bb1a2f391a12f1e55db2adbfd7c6d57799b91dea8e4eeee66a1796d36b30d7f9cd9a9f875a315e16e62cd9487cce45bc4e3970a98a8d4e9ceb4925a5356cba07fc405528b1b0e943ad02fc439b19b10eafeaa5ac74fa89458b5d985e1657b341f9aefb9984e551c71e2fc695b6f3df5ef04a41eee47a8123bc809dfa56e4dd7523a7a273fcb452252d01d82e3b02b22152abe32ea5672eb554f04715ec8972d0294994cc87a9b03a3d2aeb1cf1bff48fc5d61ed15a563ae11db8a922c75806db3097b6cdb946ca665a1c6a69432d1d509f7b0680b5e5cc8f356a411282ba2c5b17d85dde296c29a9a9d60f7a4b019ab08f2d565d9561126951730c9af997b8dc2df2c4cd94840ea0fbe0d06bb6d32895ed1335317a7c6a204fbaa1787589eed2d41795034ebe04b2027a38528697e54de3a8fc5ae5d92aeb35fe8a4d32e9582830a3c2f4e252553b4ace11358bffc587b5025472427554b1986aa793a05bca85ed2d9fd9a95ceb60e429273f63a425a90469dda912473d8c8251cf101045b2008d5ced8f5a6d9c9960247f554924d2bf3ce69e48fafcf16c5550fa7802d44efe6c128449f9b18b701d6c2cac62fe2c6acd66a3b9209653848ec99816e12088b620df2bfcc11fffda07e98fdc8e9d837dbe92e0a7fa55158a0d7126eaa0b5a1354ffd0ed62eddc52b3f5c1cca627995233648469df0ccb8c5323484a438b1388a7e0481ec0f66541372322b46c69e6a189714cdea048f376e715b06be5c3d3d767a331612ea969722668c586537964986d877918a2a3cdd1a1049792d7feda929cc818f1be2cfa30d288eebff3cdc8098f7e6be8fcb05246cd2b7bb0a77dd59d92282906239d8f2e971163eb99b9dc94cb2f6c7d773698bcf71fe4339b703fc408c812a1a17cadf1ccfae36d46b338b2b3fd3e0a0ab0723a1942e28f811d04965ca820604bea814b4cbee09281d23c3924edfade9595ea6df32382aaf0b509951197eda18cf3f4dd88095ccc464e86127689c4b08c90c0bbcbc46b42e74fe8f0292524360b5a10d79be97fc0c66f924c42d3c68140be318697f56ca497110765f24f809f4804361c83347a52a3a691648ba20da021da882e6e60387ace17910079ed7153b002152837485ddab4b4962de3276c40181da694e2fd9b8b77563328b87db4c538bd357db74b90d13ca2039d6d2ba2da7372644f263f5d56f2f254cfc8b7a63eba745960cadb6fc1763402e5ae892f04ad771bfb4f41e0da45dc94b85eb2185d050701667f9f169b0a7ba41a604244bafcac15b02601a5537d8a96b24d3d048cca2c60d2704accbbc8a3b3134f2892191da97c30fca8932f72a0f62a325e0f804de22af780822a9739ed0e10c1f6c7c1497162918a66a78092976cfb6af89be6823f9f46aa36faab1109e7d55055159ac1698b65e6012b67837a3fc5ebcf3723eeee5c98dd7c415f64c6e576822d542d66e3a361305912bba304261f25e3d03a6c6bacf7331c9ec0b1b4f1b44260683d708eee0b4843e3a84a6c5ff7965178bc960288b2b49c01fc270d0a4435eb13e3b361ddd96d38795af95b520e4daeb1174995edd2a3e7dc32be3a554aed33e2fd9a02ff510690c0d852406279dc3bb96fa663742d3c27d27233b5d8b475d5509edd37c0f0ba69e52040747b3d371d160a563c06373be2e7a54a12b486467e4ea9b1a448b0075028f4f6f7541fd232a14d523683efb7719caff235c55bae1c7dc02d1f0d23dedfa8961a20d949d4dc3eabe59c65acac8931a26691e50b6af7396f46967729e15555a9660642e93b579814d9dd62438441cfad6c1842c2bfb5d69e5c6d221720b2d018a4d76a671b4d8ce726678dcdc1d0d7792c0ec317e83af6dbfc6b54fe3d4768f0136834c500ad06ebb40cfb5b11235b5ff009db288d062d1ce37fe102ebfac1e0deaca0c94d0e8401700db53df7d1d7996763fae6aaa9b60f5bed51316b21bce190e8591a4c3c724159bb4e5fcfab0a53ac5ceec66a2a26a58deb329fd905ccfa1e777c398a502e31831d9cd6cef4bfcf2d62d86fce16fc04bb1b3b2a3d6a7b2328979c686d5f3e1855b3b2ca510719d7b3082b0c25470dd072da08a1d43ed75178c6de32ec9a066a534e6e2daefddf00ef54c5378fa05cc622e24c52a0d496855b4ad088b8a96d8fc4e9a43afaeaa9a5a4368747585f8ad6281fdca43aa2c246df129542e0f449777d80e10c93821f58f9a59c294bf27f00f40184a610c3ec7cf5d5f4e9708b7804a940377e3b3137f885fce96d1c2a4ba412dbebb3e5e3e1bb74b0dc3ee909445a63213faa49924c847dc7bb965c2d8632073a54231077cb3715b270a562ac5c46c6075c3e14081e87e4f568b3cdbfc3bc27d279453dceb4d78a8b93aebe7275f089cba880cf99de9198b49641b85770ed3d075acb892dd6189269fed8b424e79b2edf8c7ae8bc75254c8fd59441f1902714fe4d1350f55ebb1764f1528435ffd17c7353191015342e3d1c7ecc62e800d81029c0be9dfbaaaddd0f7fb94acca5384f6c9b0531ddb1a1929eb34abc9834c5e824a3884f1e70c1be226f02d1366894b8ed9f03d65d923813af9cdec4776567b0569acd852cb748c299626c6b06b09ba8cf72be632de3b19d149ab63e1931d2df1068398d4349ef80700a1f7b69494b2f760a5e8c8e49bcb7af04ddf24ee8a712d91b8d33265df583a8e3d2dc2f1e081de9ce8f37bf547ce85df764bbeb937ec5ecdd683786f620ab500e4675b3f2e57b14cf1839e39066df8713e3af82c4289976c4ed5feda2110dc12722a1f4a44ae26f921ebc9a7e749c5633e53200a932adbbeb86deaf06af5f504ca17a34562c01781be4712fc3879c48a50ebba0f4480db25faa3254b66531c2c991b9a278fff70892b028b78647e5db806560da94dba41b721d8ae9ee9b7db15aa5f40b0416a5737932275f1544d44a3fd90974502a0c972c2e083a3b6f04ff98383da0f9a0d0257d7bf01632750552752c16ee248658b331fadd753d8caf0393a6658f2fd68cda301c6572c24e89d355eb20108de5cd0b3be36895ac5bbe46c2eaa52bd6bd8073a63f512e872aa2395305c94cdb2b279be644f1ea808653b7ac363a2eacfd6fa86f3720a447f87bc6fa90addf8ede5d2b8b0342422da54f360a2b38fc99875dba93ccd8a639c2e0c3c7e91a2dca17fcb92bd454a565ec22ecd8f48694ba657d768c9e64fcd9154c3361340b6181ba0204ac59d0394d3abf521231ea420aa9a18586396bcaa85dac366a391e72ef3fd1a402e4a8a9d4cda9dcef88d721a8445cfecfa4551fcc7b7b63ce4aaa6c4af6fa735f10a5cc84b965e274f786668d46c969cd7bb973a769e8ece461912f24bd031fa0d62a9a56070906ad999b24f2ae3e7be83c3b144afae7909d88108811b6dd32145e4d4f6e95e490790fabfb30fc50eb636596be0efb87c19f33b131dca4bfa41793506b132bc29eebbdf4deb5f4c885f185adbcd008cf1afac88fa6a15aa40e30680213136411af257ae320780633f0e64af24928f14b3f94d21c5862a338f2425e44b1db7d297e51e69c6f1bf7d78b92cfc4f460a7b76fbdfc1b93b25b03d041d6c6634610fc38b107ed3cf5bc33e8015a3bcc7bf0cd6df5d540425424083218c3ad5d0e20c4ba1b4f69f4d7c29f7733d47571a7cf83f747befd41a4384a6e9596c182f7d17466e771d6c4c3e0d093e125ed1e701062b0365af77d07c1788e8ffb40747a454dc8322b9165665c4f9166e892fdb06262b2d1faff778ee0d1c3d27aab58b23dcd5a247878530c3e906c5bfd7b38df75dbe792c8d054eff8eabad2b2de218399890c8bde17bb43e7f5eab8ceef72545abf1c474d0d86b5d036d1b878b36c7cfc7d1cbcdbf235ba560dae32a2d3194f0c54c12465e1f4f92af13bb99dbdfb67a08ce98f477f4f11899f961b1dcc97056365a3e995818bcefc8f76757821ffa8e100a11cb9a0af36de6df4e9b50fe3a5be42cae206321501d30e3e754987e1f195d3e3ae9e3067f1a2e61b5d80f336de5c070b0b0e7f476a5e185cb60d8bd167c31dca9364eac0d17e6d837942911bd2f5878c5096ca09a69eef9daedc9a2904b15c1ea81e012270297d2d427fde1b87f53f262fc39e7d9477b2c127fce95270cc9c831b62ff4a1f673e947f28880e76be066c5ed9ef220382ed2e35dccb3935f2511a27a19ac861ee51d639ad71ec757ea21579a0effc4d125738d5a72de557e4a39cbc817d81ac7da0412647bbd609ba68948e23a4631a1591130dc28fb4e18fa23587e7235cda799f5d8c4f6714f3ce8521c6a07a3107d10ff1e33d26d9515122d5882584c8de444ec861da502c37cdce736cbc5bd3915961f1f0525056e1897c3d2eb86adfb9b5beb36f17fb6c2c097bed2e238674d410f63c0b60cc38c411a0bca68b484d3b48d1ad8ce94dcde5c6af30ecb6d76bb825921433a11bb2776a5c574b2b39648a18b53056f8927930a0a2b65392095fc77b1fc7e87ae899788437615349ab4eb20820238c3ab0b06fa3f08f02fdb7843d09715012baae3ac59d72ff922afd77d479e275e205cee15bc899c7ead546a05f4cac8ba6f4a73fc92ca9b090866a57e044020ec6f4050ac0a52d06ed38f502b3defe438d4bc850286dcc255a6178e861010102d81f6b0b042ac400235277f85281c93d796cc68bf8ea71a894ae392619bf88c9697e69f329120dee3978089a850380dc46d16cb8f74f8d81408605c3f023fa72ca40477fe3cb85898f9d316770bb6ee10e79ef3533384218a7cfa1a5f853f5e878faa57ed221d7373517852062a9f39ba65e9a545ee9a84f8f8524eaf960fb0fb768891a9147ff9bfecd6a1fd4d6dc208c9731c0dedaed035c7bb343b20e8ce82e5af71dedd0a1169c2b46e8fab5450395fcf3284eec763980f871990f2f5bb2087bb2c424983fc70b6614fa408bd81064fae86fcbd9ec8dd2f3f9c7ede756e0d748ccea3603b399bea5c12b6f2acb23b239702a9f8e667ae1ffe71f6eca72f59f2e9fb7e3f3a7f2d2c1be74ef6f7cd7f249ee7cf7f37f8bc9032b7b93a236d306d52d40d5c9090b19563df539f61bbe69b98ed9315cc19ce399acff3f19a3a6b1f1e27759987caa7d2d71380a84c65cf6b661349146218322c86e492f60c22fdbee6addc2bdbc8fbe74d9026ef5484b6ed695617b2fce64490097037741f6740502a53a6197b8ea714bdf69743ad71037c57f4cd447a2baacf447ad5e6298985ca9b5c37ac1f7235c5aa8e410cf7f2b6eae79ff7b16c5e1cd8120ce39fefc3cbe2e71941d812b69bada161592f2054355d20c8e464b8f703de2aa517489b017d38b6919551c1eee2dc6c29e859872939eaa46ae0fa72550911e9e5780e94e2d646f4790662f25ca5c1519d25791a0ec3b28d1ab9437a125a6f836f99855298240e9affac0b7b2468d9173d1d978d3bd0ad29fa1cf3f4a68867812499e4c8f6dc5ba46fcb7f0406afea309d3b7a7e071cf17ade2de4fffa3f3c61e4811eabfaec183afc5842410661bb9626343c7882276ce56c2dbf65545cf4d3fba9813438ffc2ed838d04cfb4492fa69cdeb7dfc4494718451f9913aa3c83951ed4ce8e7247c2c5f903e8cfab7bd1c6e71a4215f1571e69d6af597817078692090cc3ffe13b37757ec4166e66e9d568fce37419d80efad36569b057187a9dfeb84d548a5ca2d119cfa316a3025c77f9a39405566eceb8670e153774019d0f7bea2d6dea0f67cab76968c75cd7207a30d39742687ce790d60fe7cc345b30f100ff34388ec457886de9233231eb562138ae23b83067aa7fac83155444428ca9a278b190b8e3b328d4536754489140953d0a433f6b17478b07ad39fc4268e3a8a53364865c2992384048e7c6c30d75df135d4aa8dc82257d6db8361bebd610354ace0d3d571647e063c5079614acd1fc6502f92f00e26b912ad5d7e54ac6b324b1a3fb090aa50fb198742f0cf38a9f4587bde17425657ff8a67d7b4305b66929a27c31883644a8ee3363f9d4890c6f830f49504a29763bde75e84117b1e2b5f34a57e66285b65e8551e7c00d886bcf306f535b1d84e96501cbba477d134b9bf625611d281feddfd9ef7fefcf48c21f96df4bcc6607a6c7b6b98fac4cbf9f6a3223330fe6e5ebee5b6ae2792a24848e846ffc3ec6278b22d0edc922e908bb0714d711ca533c81b6bd526ebbc21b97aa70784b4802e6a651e282802d1e691467ebdd8b284c8869dbb679312b9a8560dee25ea3894802a57db24fccefa79001d31294a49adf128e875ca89084edadead77e339bb4166410c0b048eb3edf89fdc644477d11cf3b1079195b3e289e9b799402ad9b473faf15e32f43e4e810aa1198567fc9f256f9691af150dabf5bb92e7f48010302851026e2d0c7dac8a417b73e12faa2ed3eaf9c3f0966d19ac676a652e3d947c204e0cfa969ecab1ede1fcf6739c7964f34aa4cf74bc2888600f35d60e9b90c0197532f1af50fc6119723aa327989ff901ad8f1fbf99a37493306785387ccc61ed2ccaf8d622da0901ed1709ea49a3221d390974ce1d8ce6dbba848b54e42eb051a38d2e03a5723d8b124408620e0e735f50359e9fb33427dfe77caff8b9f856f71a1a2a5e86c9196a1169f66357905cc2421b92fb66f7e9e07cc1f635aa5768c52cd5a78902161dbe3edb3034089d1234d78a4b71abd4dced9d2aac6b6e4bd9e690186f58f14ba86722617689fb4075f23c8845387032b988e7819f6e656fd7c3fc3a1680d463531b009390fa69977566d2ea81587484b561edc7d7cbc80ab35e7f9af36c2503bef19fcf8e8b7af729bbe3d69485b66121a070ce7817ee9fd5fe3aec5593b0c756725b1bd39b13e8c7b9be4910ebca6d5703486d09644275df50ac52be630844f9d7be28580e050e0ccbb499fd8fa3182bc2bf0737412c237ce61e826a2cb363d0ec5c0e9f797eeef1195bd305bce75694262401c5f6c5fe48445ac8fc6095cbd00b61d59c4a10ac57d35973b3337922710e73cc242d0e5d14454b8fec6abdad8a8fb99218a98d11dfdfbe44e6ae802930b51638d4efed44f13c3b41c0ec7f1302c668f91df4ef527b2c7068e4f32ba7f8507a858868981c179378ab993920b325323c137e171071804f3a79f5c8e8e854df59850966cf7e60ef439d5a56ca248af876afc89c9487d78f57177a14af7211c13f030026c7ae98b874df4004f67daf58813be5d91514256cc20f05727bca2e599d0b8518e5c9547a80b25388e2893e3ecea63ecff0588d92bd6b4206dcb67da7642b428f8806207810dd875e1d9b78fd65f9608e8dd0a5754650d48d82059fb149c03da8612a56c36f11cd94f2c565b142e4a3d577fbf940721d0581deff1a777df377328b56e9d43a2fd17d10b83f0f9de80713eabb7958ca621bded4a4b30506c1020cf941461e9c98d9508cfecaad160ad166bca63b0aa7500ded396209c37eda683dfcde3fa4c54ed2ed73a4aac217f97b21c8f1496554d36d626e0fa05b20e0df9823b778beb773bfcb81c111f61330312356f1d07a44ba2015769f4d27bcecc6f7658d6f57c6fddfc198d455462d3f2fe025998ffd33b031a1c7d8d10b951b63afd01f6dcc0e280776675aac495b390a1e98a26d1cbcacf2d48ead65c3d2b3e4f37033857fbe84bade2177a24998f80b740994a56df81b48002d2806cbf5d9f8d93e2be1dc4a4b5532da3df1344161ea34dfd0f0c37ed5ba87bb78aa07391a73f84cd5c95d3d6bf666b4c5136e714c6840e2786120c045c255006df7a7a35837b3298b8b743c547fc3e33fac1686c90405ed1b7fb8d30e30757e21c7a5e67be9c63e6cb2d2fd34a761d021d2db31515f7b12d4ca22ff46071f3c71dcbae991e72a16f66df46bb5cc69069104525d2e700dea8a28a2a2f6ba1acbf8dacf894aa3948606e9666d8128c012f96484f68e7ae68415d069bb9aa1e4ecccd824481e7d176434a49d8f3edca9f40f5ad09d42e465b063e73eba4837545562d1823be7f3a315f022a746366d98f8baa940e8418a5c4dc6dadf3bb97fdc8c553cd40b67748e604fd4124553c3d636ced769ee0fa6b2837cae40abe149fb1d6f5d845dd9414ef8425893c01a92eb380dfb9af71aa6a0c93f324a969707c410ee8bce41313baa1da5415008f3807e744854aa5b70b8002f0fe5a7eb1ba02c4d27dd1c7fe472371d452b3c344fed5c24dc30859e7bdebb9a88e1c28497551874fc5871837eaf9c6f3933ca1395b630f396ce0ba41681b52d4170e72947f2b3b5bc5493b5fa8dc662b3e1d54af12c1dd45900679e17b6f219416edf43b5df8868b0e9d2134cedd574a7eb6195591d19a8cbf0eb335ace96f0e78a8795bdccf706665edafa3d3dee9263b4da3fd7ddfd32788a622d21590c42919550c1d0cf3ab8ba71c8f611ed7934de3ba179401df6d0859a217f3d533c66a7e0e2469589359ed0b6a99cbaa03b389ad2dfc08a92b3770ce27763211e98f3120446f260878c55ae2daa947aa10edd40ada66315a08ddc49f34f9095b5da042c5f2d06c5fadce3cb1835a7df0747f4c40c30dbe2a9ddd296697bfbd239b3b935cc9c61be64dbc61042da120c516de691b5109619b65ac3d06bf025ab646e7dda73653f5488b446fba4fbc475f97b5286c7731ea8f74d94bf2d5561fdca95c823fa4fcf32b238f0c344d3d25693d34c5b425d0269f23988ff6beb970b878dcd3ecb62ada","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
