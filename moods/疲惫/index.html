<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4607d7291f2727f9f134b3dc1ecef21e63b47137719bb62d3374653d06c7106a1eb32d734025b965f7df9a21af83517479b5f076666cf5a80bec41ab04f84be8e229a5f6fe6d7be9b1b6101ef5c89149f9134a94049f7d7ecf0a166c3d8d711e29ecda76e8b26451d9b281d239fce035ceae89911c8f4ff8e80904338c525f740f373073169e882266882bbfc4c25d821e8a9abafbfeb6a5acd02595148b1c49a82c690d9238bc75304f420c5f407e8d8252f864ec5c3cbf8c404faba2dfc6ce666ba5659e32e255f45e61fdcb701c2161c4e91b6a78bfb62b75933c3a3c5f6ae49fc18a351421de774b919c1a25f089c9589e5845bdbe3fec3515f9c9ee31accfbbc66c7d7c83f52ff2e322085a86cdab06261683b18ec8ce819a0df72883848a9e82c7d7a735a7e9c9d26be1b4cb4d8627fb9b3c9b35b752181974cdb6294194467b7170baa1acb685ae316082d9ea69dff52e53ac0aee4c9520b496c12073b44f03d785c81829525c0d54fe41f2f9c0f4965ae0d299cbbe7a1ffc7730987a22d1abaf557f2f63863749140dff253bb30c3828348c8d256bef3dd292463a0c56be6c913d0cf8506d60c11b33265e2e31a64828b09f5a3a4dc71c121b8e8b3365b8bff1826b38fe4d82020ad5bee89095d17c55b88a2bccfdacaa982fed749e485e29dc79b6d76d71639f36a8d97a342f50648060c09418995b826252eda735f1a5229321d8b1dd037ab195e1ccb8ff6a4fe5e7d0203389203bc1d66712526f8bf76ff7087e25cce62343972e7c4b2d6160d8c8a026543a1d7c9a396549a110266197fd246644a446531f6d1ba02bb94c7ad12719baa7d8e9e8466ff7e4350254cd52d7eaa157555e18ff34059ae88eb3c0ded99149bc5dd41f43fdbb8e63124461ef68c9b334e43e642d87c44dba469a5bc12892c08ec167d9947b9262b0321a801516047b7647c556b8bcabc15c6d11d9361e8dcb60ef01340886f7b6da8ea18c721fba976435b506aea8d9ad697a8aaa087341be81b2c7b206290b12c2bb3b96c64b1b6d480469209866f5b2d7b3e9f4ec3033d56b99ada9db437d89406fccb1b149b7ed35652054fe3b38fac3be07fd5a25e31ac7a2acdf12400c98e567990051a5528a109dc85c7e15519972b81c8b74172210175f48c7165657e2c49843496b715ef9efece0baf95e22338cc13e4b2de9fbf0ce9f9a4c5da2d9d64383a4ee74cb55e06a0d07029352dd7a2f8ffb105d64c89d3bf0880f8882a3e8b8347bbb1c9f2de5120226f42201becc24e576bca39a0e828b89062c7061ed2410fe87db5803b6b65a2670584ae2ebb642540ab1461227f43f01eea1af1d2f92256d463360ce769fc07ebe384606eef2e0229773672a547a06919ce6967d366dbf65a823f6c20bed56e2343e2259ed9899fd2ea3cc29b6f62acd6743c538bfeea33170303e25b33512c4898e3b3d87854b14a3193b1f6a278decd1f12900701a75496ee7a4be40bb8a3acd1df9b4abb90942b0d1673e2af4c916f8ab2cdcb6340252820d94bef1e9b5221868fb289c684d491917eff0a0243e0fbf5c4c1fcb5506b8fb1e0495a257bbcb76d46274318e01fe7c7c25c29ed7f327f5560f85fd4c6ca4582cdbd261a7140d956d7842e3829c74c3b9864ef8c85faad739eab84f7d6a787b29ca34938899003904de5728c2b557d7c09f15fac5203840a9050a3a52c4862fd813c16bec135d2d1bc4c6e0dad8492b88a13613f1ef027144c3d2ace13c7092eb2a5e5f489d433de83e25ec6dce54c02bb3cd58c69803bfd02cc8492ecba2abee1017700bf8e7a7dbb0102ff50005cd087e09d8fbabda29302f90c1b4f21779ffe33cfaf68d0d4bde5f5f55b12f0cc5d27e2965f3b068fb2ebd501664f2a1430debd244df747855c3b52edd2de1aadb3661103ed736319fa74cd8a753525321f4aa766c47acd0021e88114b446a0bc0ddd4455cb698802e9c271edfe79719564b169f495acdbca17fbca33984ee14d0f0f8e3a81fa86350f895726a35b4c3bae4b608289b68150bda2f3fbe933e714bd9824102dbc5c7b1f692dd84faacb1cfa58b24d5421f16a50d76061695284a8abe26c9eb2eca243dec2b6e6aae3e5e42520ed3b1023925d3e5ef07e0dcfd65626c974ea575dda530dea5d3704ceaaacd4b9fe3a28454c99868c97da50b5d82485d4b22fd963ec286ab3a89b6aaee8fc0ce1430af0d2feba6aa9133403476a5adf2bda8d01489e27a68608a11f686ec3539338bab6b20e63c2b751cb79cb86c63b5a06a06afeb73926a5b82926758ab774f3dcd5fa01dec7ee9ac217ae6cb947e3b70a4b4c810ad528456a324069b154ae76a5bcc25010c7c83c7a175720a4e0211d79a99c09f1db8549dd522d6ae690aa65b61bd8c72cf9457b967df9429c13fc8ebc59dfccd0660d5296272a19102beffffa03345261a01c0ce4fc027b0a13e5e038800b7aaefa1fe8db7980adc57ba573cffd466d40643d22db0e9a025cff0d6e5d3a4f4abd5ae1937d9afde68a3156ffc94502ab274a8887d1c8cc6f7fdc1fa98a8838a7df01db413199b877a60456a6c62d4cddfee9b023eecb687a0127aefc6692de0a7a987dd93b8d8de83ebd0bf62b27aaa1502dd15340deb16cd4b362e5b625cf336c70c58e06258eab72400c7867399f51c10be8fd8bf7825bde7f8b7d104c6ae889d080558733b7f4d3e2de7f74c71d1185e956989576126734e96d74310edc9425066ae054cba65da87c8679428192d6f8226450fdb0b61b270cb8ebdb6d07cfedc0a5fd3a320f3a6a7ca5721f985fe8214dea4dbe665e190a829423cc48c7428967ebfb566a3c7a735a3fd382c4619616756ee1219d863d173e49e3eb40e3d65b9a4c6a66942c06044403ef837531474e6e9810fe8a21f06b062bfe94e415cdfb7b685d57e401b243c6f740d48b7987564b8e91ae02dda91e9f359f09e9e644a279cf4f7d184dfbb6d7510ce0747ff9080ba5eb0f8b117c70a4b2ab5730d506fb845a13d63a41757375c7682ca1627f2fca0ba81154675a50fd12904a79abda781999e28791ee73fe40745aff56123b52f55a8a0c2d333756fb3d856ac5b09a855d27b36e12d33c8c917d47c6e3872abfa476600a39ac0bb63d042f6fbf4567a146617d1fa1c0e0aafcbf8f1a61efdf53e010d923a94b7ae2e7b4c298a38d2055ce9fb84419b85f1988701ed26a52e3c8cd9898e3381f29720af71d21015cc74f8438e696801f979c8a787c6a436fe7bbf7a2428ad916e17bfc4e5c3b458dc33ed487cf0648ebd8ddad942a7f699889a5382234a5d2a1e433ef9e1822b387b022704f70f9c59e71954786a4284998ebf4541507b48bc595b0aeca9f34d8a1e62875afa885f2d47c4d890046f1cb9da227aebbf338621b5377d916461bff77cf7ec98a4b930a4bb2678ef52b4a7d2779e15708085222c3b6ed5285aac3b148be0f7bfa9a26a24bb713aa5d356f94544cf57552ee850d83152390111f8ae3c75ea7545972962392b61c6ae710af71dba414ab62f702eabe94659ec7e9b63930b68c0a59195b26dbc87212c7cb28d0a8b6d1ed4fd5784cb935ecd3a63d145bd67e7096bbba5a30c17d67a191a375bbd5c6eb69714817e7877cedd6f8e99c7c9254b5c3b27a195fdcb1118cdac12bfa1851441c5d3a73ecf7fe31e031277611f7335a5fcbf0ea88d68b25d018908c6025a0400970ad846af3ed1d49a075d5669d1b0152056eaa6bddc2bb2e7089e4c19c39b9a4803bfcb27f993375204d88e6487727a40d270241b82a9c82fe1a045f8da0da6a26fd80f67a4dda90b0fbc5a9e1f98b1a9ef1ea293546bee042c323db16aae385f8701232ca189c73128b2525e360d32c9bc7554fd9f4b2e9aaf66f46aca799c62abb1cc2480925d67cdc48a7510620635ec3154f8e92f079e92dd56ceac033d77cb07e827b18922d9bc21f69ae4db51bac6995bf7f9a24954b800478c2b89115fb1b24fcb4f0abd7842f5877acdcdf2e31f14669dab2283d2eb106d2b2c8b2ed1dafbf4be3666c81853be6164954bff0dbae0d8a6a1c91404acee0fa843d61830676f7fdbebd2dd90466813f2291e019860b0e7a4f2b3bf2d038e65d3ac2f8dc2d4354d40c80a0385ef4ba6c76a811937ca15d140eb97e95ff6b84de49c776320bb7be8e3210eb93c659865bcc5f03304b7fa4c46f1e3c46b49ef7508d75847cdd5a0ab20594184698799626af8c3ef59c53092794efad1284c6eabd1717763a6c25ab434b5a50ddcd138883fdae84899926b5b4e115e1b19096fc1428300cc2f43c9a60a701a0885454d844b98ddba7ea21fe7e555c6d3434974e30ce38686a91b479db066dd97b38caddea299a483db9c27cae1517c0d0ec8a00dbcd25f31c9bad214e977095d7720f9eca43bb3b2aab75a302c5c7c7c587b6d4818329ebac2bc840950a8399033680e74aadf17cc7b6dff3d480abcf8cdef055120f142ef36417bbca3bf2b00139a6132ab5f2bd9c982edc2e1ef4b3e40dd661ea38c90c3a82efaed266ba4ba6985a00ba812e3c836fe5419fc74ee61419c1ea3879e765e61080aaafdec28ed2850ce2ccedc124f0546507ce6b19f40a1f6396719a3b28b067b525e93aeea84212c010376c04bd1a8f10fa65b56f9dd4816b874fc56a9d7a3752acda5333f31d4f93072ca0734956c6bd466ec3925ac7dd5ab7b7525100c164df6c58c5827700383723a400b5cc265c026c3b8a537e502c37bc7824e6d62ff0c401271d4cca0619f6720a7ae2f8228ed35ce83f053e07a25d206a1f71a67c743aff526534c96c6b58062e674dee366ec7e592aafad68a1591e7b432a8b89605f17a32ce1531810a77e78acd030e20b27d54f1c716243ae88192189af00d63bea7b906707516c1c2c3c0be2b73bcbc87a1958ceb9fc4fc299b7b2e0102c5fef681da52ef3f3998961237b10de34f19cabd267b5e4d05e2c8d63c9d2ea81b0c10a7caabe7cb58ddd7ad8a4a29257f148e0a816bf1b524468b1aab7513d87f4edc51cc30602e54f55e5ffd7e9ed038c2a523da796d19641965a86c6420bd180db73e36eb8d006c5d1d238e8a0844640ac19ff71f88d4518c1ce47aea27e2d2412ce3193a65a9dbbc3bf94c1d5fa2c59fb0b472642ef75ff183c4c46243c9e389bb1c0823f759d2f3ee3c7a2f648e86a91c725b229bcf025ff3f92a876c1389054ccb2f9cb89004368b2047f35ca518ecec1da5fc4bd3185402284ef16e4e43d01eded7b476edfd3b67ae2c54b83a8fcb2979bcbec954b2524a156f8b0635a72ba2e119fa60d2aaee7978d82aaa88575df1d89ade633e90140f18d7c866eeb1e1c9a5eba6ca3467cbe3ce14da583dc560334e920952abeb7e8f00cd55841d7608688ff7bdcf796674417d6b7c381caed0b0f221e492373f7bddffb262c9e34d259d0656a2a24387f5dc1fbc9dfb73dcac24a78f7609ffe6a2e3bd47435831deb18ffdbc18f6e9426491fd4c23938c95f7c51a6777b36359d7b3535793d608993fec51f685db9119478f4e436dca58e0ee439868edb758b0f6105e9a2768886d4b8287e7a56f8c1131a5b60fd00c72be1ca3f8e9e1d85925211504c9dc30f23c099f604c7831c388f9e974fbcbc2576e4047409ccf93b5cc7b19c06700a9f806e553b74e3235755a7980171a11ebeabeb5520acdaf87e784dd42c410e86bc36a37a38689098b4ca6b07b956124e3c2ebae6c7991937f94a27ffc113f1779a9fbc14013bebf9696f3a1d8026357e85154dc6a05edc0ab36e7740846133babaf5212865c49c4c9bc9f458db34426885198d981d0008353282c9a3cce09c2317880f4762ce702b4d73888e118ac1d958d7f9671c137cb367f01806b2355f29eef9ee3d40614a6f86faea1f45f2e567b071c323bedbfe7fde92eeb9ed3f75a67e2bf9a69095b27521519eacd2cae8cc122082ecabefe73ba1d44601b9ebe923555a866fe08a3f7c7167c752c5780626443a462c7d3770f6063c9f75299518f0ffe54bdc9e7fc2abd516e64cbe25279afd2628feb879e3ceb6a55046b8a71bf20f076bea23d322e9d7b66953fb75e2e1a79356ec8697d0fed24c81cb69d7ae1c8b152170af81fa40a68b6e71bc6a6ecb632effb22ada2946493e35b5ceba35d834d3ea9f8e4af26d58cd394700cf1b47a5d4cbd3fab93abb2ec05aa580d1972a3552906279eb094ff92c09e5974e7cab9f1404c2af3170c85c770928455d64d2c99a85a97ae0a9c6543ad57a5951f11e9ef0e605ed113aa6de3489fc747dbe2e91effbbb84729287a3030080b77079272786725e17afe7121f3c94621ed6365c6d0d522f42b7f395e69af571253ca517c518403646f70c8eae9cfbdf8cc5e4aec922c04696bd080343677638d939bbdeb891eb117cb8942665aa24b38b646d6f86b2621e4c0f405c5f0b82f68013ba042116ba90ab80a2b3558e44257e135b1bbb8abc68db59f8f9a0aaaace4d5bd045b7637c3b23de036c193c7f335a1f99ef275336cc4ceb06f157a5382afeccfe81b39d6028fa31d9a12c60c3eb66982663f878af0a158b7864871ff9403f7c326c08484313c03be57bc8ece696b34a55209e92d9b62708f6da5a64d89ab95a47532a2ec265679fae2c4c314dc548793a28eb97bd48bfdb422b5033a6e93b4225c075d6ea2ced9cb60e7237b607ff8d878e37c33c6bb7bc24421c23c2e699cd5f660fe63e957add0e37eb62af1590ac225df595c7db131e76b889c23177059ce5145a9617a623aea4f5b35ca48acb6423b83b9d7cb171ada9db7938236e8d6c567fac524e75730d3d3483d143df046eae88ad9e9904d1156344df47869275081615c245d46bb046184c5045aa31dc41c44dd66825609cccc92e27b82e123b9d2324cab092f531afc12d5a16c7c216b6e34cca3433fa3451ba5e75cc9862c36ed12a92faa06943bf540901f80b005f112dea74a7405e767421887ad946ef5889be8df367b31f8b6c4d9239973b23fb96939587ce0dab4b20392c00c885cfb72d3f984e103444b6a63881419772007ba1b498e6303d924973c9f80312dc892764241b7ff229c05217d7208bb5a8658809b8f4fcc8d8b131fdb7f9f493598574701008eae4f8820984cd862f3556b9b3f56eab41c46376b81ce180ab7df20b0a679417d5ba11b9573f7d254218a9b383d30e39bcabd89ec1972672c125afd69839488dde692a7ff73161281faff6593ab0e85fb3d57ac57fb4b08213991b383e4530bc2020274a8e89340b83ce90f7d72c7ad3c92f5582e2537fa3cca0c6b82474c3de132c4a3a3987f884ea08709cbb21915e5463fe0b3b23275274002c59a65c33f4e55faca524e34f78160028d1b1b9ffe50543566ca84810ac91ebadcfca34224e030942c673c6bf1ddb65c2ed4142119451a30770c82ac9b1e4c07c354d94cc494e26842591afb3e21af2163be5bdf11690f4a392186de29fe89247db9f547527d25a0776deb998cb004e5c89611f9209a4583c62126350ac0acbc8352a14b9f4777bce6cba6314b4077856eb145b056daa87424ca228ab6746ac6216e3754f4f971cc914665ad16221a36cd817b37739363249bfc0319af6bc33e60a91ac6bf9c76a41e95d9e4066f131bf9332409436158e270100ffb2f89de08c1d82caf86f9ce98f15894ce20afd74a77931cc904715a354481455b7ccf25682ba5671c62b184fb66a2d5c4a4d053a5fc7b4ef41341209647df6cf4f190f88b9fda502797cc73a85a121dba40ea361795b246c481ace15afe0241c6154186db630942bfcd09c792a29dcb4da347ebf33bd434d1453e6b9857d4ad9fc92cd9f2e2926f78b9f867541f882f07cb9d76428e78e0fa3e1d64cb99bb3499f18e7408d2f1cab6fad1f8a038bfe620493b14e6f1d602ddc6e9a58f978390fa8ad9f07a688eb6be019136135e6b4b559abd637895c026f6cf2232e963ccb3681fd9d9c4e16ececdde72779e969c4450ad8198679f69d6abfe07fbdf425db4978fd6e0ffe23391c9767b71f2a01a197760a5f3130bd40f6bc67e1d3d1cec1585fbc7fedfedaf992154fa7b90bc1517cf8e6f0754383e20e7d4ae4a939b4ec2f1756f335becfd507171ddde4010c129e0d5ffe6c4db4a044cd7999149f122fcd16660ce612acd16914203a13322fb5796ac38eb12b53ffd3c80affd5f771b9de75d76d938393c3fff4b8cea5a53b425222c9fb42e26777b7ce31cab59c2de33abc93cf2f4568e17859e3f9f7e67ac7cfe3dbd0a2113578cc0b427fe592ead6b7ff1772b3f582634f757effdf495b59f488f42686f70594ecff546153a58888bd7572d11e8e7a2bf0651883055d78a5d5b6e3257ca32afcf29962c2ea43e537cf640188a94bf0f969abd52e8ceed475ab1138678670d94ab250c0affc8ad4e14d84d9855cfc8b1cbac4a8973611010424f43b6380ddadea3a5e5a1abbc2dbb1dc159457de073fffdd0c731fc7de11d0f1300fd2ce4aa7da28f5da66df91ac648ecb38a1cbb93553ec928754aa77fd121772cb167484c4feef8f536c10ad00935f1d4ca7bc0a5da3c5c36dd1623aabfbe804de2290a2e21e83bbcfa3b40a03a028ef6c8fa181711535f6fbed318b87dd5d12a4b1b9533dce6b686588bcccf91ee91ee5ead990d3ab0e586659a055c7d92eace3b5379390204ecca787355d88f9350a513e48cf2589774fb13265a9eaa06f58db315ef1f39e1df7c570e265c18fc31bc2adc5a7bb22d71511284577a5a733e05a1e5c2fa18c3b5e345982d7f1749f6d02ce41c2734e15eea33a4b5f7b812c1b1c4b4e4812a751e64a0f0ec93b78c576c1ad118a935bbb58537245a0c8d12f120daeaefec823f410c7db2d5f40bc769e467fcfaf8ca6e94107e8642e150f2105c30edf816be38c19ad60ee522d701f36f23a184ba6593adea3eedd82c28231dbbed8937d20bd78e64c7099d76a92a35e9cf8454cb419ba5431569dbe52e1c05aadc48455d14eff47cae528016fb16135f246e905b29e0ea8e1953e41c4b219c01a6bc6c1da3481a7b345e3ac52e64139b559c3ed69119e783836287935f548facbe329892f8afe1bafafd270b402ee2afbd0daf099ccd420b09bdf72b429c9b622fd5a36b38388ee69a395e62a1e83891ac9f00c598c8bf0b331001519e29af6aca59462a0b3b5ad1c2585850d3485e69969ba7d08b223b46df5d43aa8faa57c2163e4afdf8ea9a26020ac29dff125d80b7340084d3e66bcc5917c795f0ebdf2f2694135abb52a2428b4b95678e53d9bbda59740f89b49fa6c30b7f577d5be72ed41884b699f8c623e2b6dc9cd3f40bdce6b49d4dba150959f0918417bee269a67beefb5f64d6442b7798163f7e202b2c493a281b762a3c0b7cfd6faac29413a9f33ead003b78b6538e3adbb25bd6460da89fef1abc2bbd9ce35a20cdd17ebdc36bc01018615e41f3d194d6800d87f82babeddea3e8313cf23dbd75bbe0aa4215370edfcb71c33caebf1323b13046ce3b335cf2335a536a9aac282796b6b5efda9e3bedacd21980ba9cc9ea849bd97da8914544be423619ac021ec6fae31ddc093628ba3508b4ecc745ae1fa354bf8485abbf168594f82edbbebeff053bd3c2228d842e9b45c6d0c59c4a89306d49ae1bb96e07de5b261068c03f3c126891ddd44453b541c716544655221b4659a3f1c020ee04d6ea8c9011825f721b54ee7e118eace7af26e9cbc440020be3fc3345fd0d99b9f6cc6b1943f5bd39e6f18de833f03f9545917691cb884aca90add9f1c41389eaced96db75bd038872027e28081eb555ed0f992fd1440f679fddf2ed38c3e48dc377db1de7ea127cf77368e9cc409acb0e33fe7dc346fbf0677076d32adfabf8a3e4b1f28e79a37c6fca2819a8834e1e462fe48ddfedba767ace8c0177cc5d39431eb89748e780a28c2395b0adff42bbdcb1ca4bd45b1916768968f98810df02d0e7ef4c8ee9817e5aa2f751bde03ab22a09afd59b1997fb7c88f526940b1b418c54c7c0227ecf6691f640789c96971b65319a76c905fa6e27aa8b6b73b5d93f41258c2d18e9bce0a1cb8f678fb2b2d40cdc2fbbf282b923b8fb5508919459c0f8741a398d0db5ededaae50940f352709cfd7044a789efba22c3cd54341eae65d8635519f27c29b1a902f35de2a766162acede1043ca9782755bb945c9744c4036ac1e7fdc3e67817fd3e8a236ad80714af7f60a3fdd2550d63ff518ccbce081d42ee41a1f08a1afd80b6fc424062d9f67575b98e41583241c546dcbd5c13a20cec9a1420b61d3fe1a6908fff1dbe5dba23107ae0e9046b69faf2bdb27deea3c94d9a88313beab54f10e3f74a496de07a85af398b56cb2f0307922f0c8ba5160754a52cebd0e5d35c3b8b2464c2f5e5aa574d86256c660165b56ae7ae1962a04d6180ac1c2e8c5a59a390a24265cc5bca9f8508de7ce11f44912853211202474875680ccf486f9cc796a70935d607e435496315ee723ea14073b4af81e7007c3dad58940f3d4236209b64b2b81b1c8f11f1b299696ef71761bbf83b1c3c58ec4eb9b88bb84bd8a634dfdac26b8ac8d707f26edcc577e29350a35e89d4d7ecb9bffd2e7a7937da3ce9ce2b7d66248da3df8707b56e380a1f3114bcff2f47f4ff18e92d6c8b4a3ca3f679515527f369b12a7194732ed5252ff67d34b8dd1201f0bb7c9e6fc819ee3fdc39807ac0176d968a1363d9f52e73fc5e3432b29ad27ab9c09d7ef0d48c00dc4c821a2ba2e8c4f2c63cefb6c0a51c358c3acfe45ce542b2c9e9ef1bcc958b55f2bffae467b042296b505614c98d0237db67813face16f57c8b66255a09ba0435e5cd3164abc633cf4678937f7f6eb5e1f7d60d5966e48fc2828465985ec4d2d83f0a23bb36d709c225b9468b5b697346861902951cb7e0acf9c17523e368488b3ad2a2870a717613ee901293fa208dd0b9b4768375cdfcb0dbf5acf4729cfba064fdb52a6dd59e355d464494f3bb81f85419efef13ecefe8f43cb0e174b49888b3c1568329c56b5ce71dd4bb38bddf9a65cd26ec8c4e1d7a26203aebbe03ce25deab24b4431b681ad48be077bf66a2533a790a7e5925bfa75edb8544febf44b0c26fc502cef3bbb1629578e79b2871ba7007d1601996f2d2776dec2d1fe2af3f09266c83b0234a45f14b4f6d131342c3c6427b78acde9675bc71f2d2663aecbe903eb143196c20dc6cf049d439a5f209f005e2ad5b1407b3b5aae92104e8a20467bbab96e66d2005fe950988e2c18f5f6dc15ccc0e8ed7866c25be6ca59a2bb4a90e38b6153a63106d192f5ac1020b38aab8ae34dac5279afa77bf86131980a33e7f8a543757e9c705c61b86d04100c5957c004ad92be2fbfbe56145d83addf286fddb240b6a2518a118612a377c7df08e999004af08fa0bf1e8c371b140a76032be9549c22c8f8a4481bd9c9cd8156cbadcf03fc751169276ea11b8593d456189870dc18783b826e4f3cc83bce06abea371ec48d2d3b1aaacc63404b3a005ec6d212044feee95b490e342bd7043201d81b1ea5dc698f4869c8fd28ff50b5639f0c0689904b6b17bc939681adf8a9a55057f06eace75b119b6bdc227da9c38e386b50f1e3fedd5a8aedfb44b0a53f8fe825b399b76728a76dd1729344e2d65fafa7bb35d664f50fa435217ec0d563c029aa4f4f3cba925e0580da271839c95d515aec6c2c4fcb98a7981c44583af8c45fe1ce91e9a947ac6883c822a67d391e608cca8de18c112828bcdff83e1c2ccb65d052b08590ac66ed322e18f01e3ce76d13f93882c7f127e739af53b60499c18c9248f0bd92b858bdca47b7cd3450f4c641783fc27ae5cd6454de95a6913f39d1b6804be5eebade95afc57506f751807c3219ae19b58d3ac669647385b255b17ef558fe08ef07bb754d0652e0e259889868262bcebbea7fb5cfc3380275c73874b3c94e3c5684e9be9d213d52f25452d3629363202bd0a6c44ae46c2ae0881400b24e501c604fc331e2140b29907209cfa62fec4a4cac3d156c2825c0d0afa3b9b042cd610b960e69954586f73c3aaafedf738325f15e61d05d39f6a1fe7f48d6784e1627978ea506cd0f6d344179e643222e8da2c154784a4b3475d338d25d9b6fa0ea32dddec856bac51429d38f2cabd2c8b8b839cab112bf90310eea7bf31bd652c56a182fdfe887b6bfdcd9f10a354fb03e38833cc020ddce1732f5e947b6aa13c3ba1fbd9ebfff6444d17a29db7af6df42526e964f4a0d18f5f9a9e5bdf0c292a20db9c36d4e4ce444289b3231996ef09e52825ab8b5973fdc8e6cc367c895bc2a6bfa97eaeb5316905611a601b071dec3976e95257bf823801a7d21cb309ff4f1534cf909ad5618e302e6184f72312dc3ab3c11b1245b271237cb82a8e558107fc3fb392dcf31bbc99640b8055f495a534aaf26d1f9e718c04a024126c22c339cf9a9f1acd3c8ba694c5e516e005e57771cf68356bb39be906cc0a1498de623aa48690167bddd50b8cf464de97621f996b6b72b15a0aad0206504a8ca332aa6ef33ca9391a5c616d22931201204aff122e4c72c783ba0725cb35afb6e79cdcc415087503a60fc298ae5e96445988d325581e015e5318fadf0acd7f22e96fd0a3e74911b539b8d72565d83a17d771cdf75ff0dc39301db6a509c245b9f2ae19917129bc9711ffe41fa6c275ce628ce2155fc07c1751fb9a40b4a3f64460820245a1e2c598350743ec5918c4e6cfd6559522c308dac90bab449262c9316b36f22b317bb99c5b180774786feb78a4d68944ed84dbafdddecb7f79940f80ad9035c435d27a63f49f36e74e59841a541f19768f2daa8ee204b9d391881f136a2d7292d7a669d0356140eb7724b49afb1fc30199c167d39f653bdd9cfee63e08cd4d13e5342d7eb7efa7efde79b392781d1629ac6b198e18038df58c2aa12c4536fbe95b06e20324ff35190ae433c5fee42a2aac5a44f1f7c902791f974da0e9d829cf3c3a0e99894a867c85060c577e1c13e217a673e33b6a1639609f069775749b327caf86c2bfab4459fb7a563d1698d06c183d9c64cee2de0f82a8f15eea547a538780b5ea6f7bb37edb8a006d86edbd9a1f2f16d3fcc6d6166250509d66ea917c646b4000acaec7f206f359149bab493a7eb7ed485de23081f7c4cb06c79c5d5dc94cddbeb0b96ef21f1d070abd1b14f4f96aee160fcc93662e02a249f5702eb08ac1f9395b3002af030fe3f633954c3829238ecfe6c34c8a626a3c18b195bea152b4706ac9f5e08cc9ad8a1dc68141f4caa55b76c300eced31ea5776e26c688c1dfd75cce584dfb34a115915f97fd2ef2e0165fcbc501f27291c061cea5501abd946186b28b3b68c342776fb837f86a98c926af3a561a37a1bd3e4627b77f552d85d6f527b8e1a6a98a73106bb84e73bac7c6b66390a3a764c0556b81c193b44cd4c54228f2fd74650e328603336faa046a1397d863f02b7c6ddb683ff77d88fd91be9cf33782f0b38f88b56b84a27da58a099d9a0f44f41f17c7e46697e866d6d93ef8ed90a52eeb0204109529acbd72fcf1f5c37caf329e9f23d635835bd1c803340df46d70a3eb1f0e8cf5b91781a6b30e70e1ddb7c3f7b2a13b5d85360504f8e02b08548cc0bda59b31dac8ebe3c74261f6b7c48d288dfda9c61f9fc4ea7c0a8269a73107e55b1eb9c0d77bd60c64e461a4372761951489d284ec3982a48beb36b4c4f4b45d4456f6e9fa57fc6d6c2cc74c226c831a7424bc9ba06a0dcb89f15f371f7541ed85dec38a0876acbfa1ac64194377714a8370e7352dff457eddb1c4b823d2ac626b41865c98acc327c01458c3095078b4b6371f9df6c3897ae3af35de12f4c5045d2581b871c1a50d83e78772ee6acb3dd405f7ef4921d4d1804a5786216df345b5d13d2db9d3d569021e6548bbccac60e022ed6b125e0e0e2ae55d64ab133956b054af2df7bb155da4f70a2166957809ff35427b105fc31c4d6e1e6a3de9c9431b6d51a4f9558936b14cd70aada7099b0ae8dd88d6ef442d8b88bd30d3305fb9765ea7a8f1e7795c993f7d75555cf1495a032f8d7551ff110fdecf6436733f3ee5a4d0415df7ec10ef73705f9ae84f984e5768cbdb77ce8a66253428f9d7f8c0230fbe4fb89726a5cec1a6eb3ed323f6557f10a036f8543af4086770d55264ecfcf3bd846a478d1899495e83a323ec420972550e6d76184b23f36d58eb6803d4380c38655a87383e123560e5ae99af416ff2d3017553f75784358acf6059cd0db09295c72f5ea8556e08bae54c200f8c2f7569eccef033ba86b8983162bd7048c13a49088eb1a863acc4501edcd46b5e83f19f0f755431d570f0c9165f33f76c1c49cb79a0792b096c8e73c92d3b33fe0c97ed1e138dedf4c65d7f7bb833637ef310654c61e09fa0df58264c4b49d16175d9923b239f33398ed746db3a1b08cfb31606fb8ade13eaae8271d8378553e2912fe334cccae662049ab6176170a319ea75581350a6ce1649f46e3a9f0bb37c19c75b63ccd2eb56b0d9a793e9d544178f0818786e1c69069417713f3cb3b6df333dca9c2bc4b508ff347efce820d4df14106db81f6c3c386dc2e3ea1dfa44a5bf083bf59d595a5bda17b22343a6f3b73ae90fdff8ea115b6e6fd32ba0fab08104872ba9fcf88848d656220780df3e03ff6bc8c54981bc63b67efd8d4afe49560f077525557d9bccd64ad6e463bd12883ea1000b4706dcf9264d986087633cbf837022250545933561f3e6d268eb89d74ab10773944f18b80196782c55c0c10e51077a8abae0b943f44700719bd89d5d52bd858d4d7e91bd4d1f17445cd469b3b91bde1b115701848cd3616a923d248999849d11610a5757fbeb9dc3c4511245d644d22e1758962d96e954bea7ab5f47c0808ab373c5db148adef2f81d7df5d3183465c2c2f7059fa3d399a630a60b525f5243903666ed1a0ee39084cc7abe61eabb0e985c98c3ec76484e2bcd063519772edf87de704cceddb28a674fc90d826f37c5624be6dd48b5108bbb6a6bcd9bf90345bcc56f8c0a8476393015d20668145256d08ee63da805a023d7e7e544b567341580090bcb63dd36fdfb76b588e34e1da798eb5fc55a9bf05e2e83df856033acb84fd8d22d95d14bfc505809009fda4fa47d2ebd1ac67d586b8d59a3c1ff43bcc7c3532eec8595f5465a1c2a4ce8fc429c84fc9a8a0606bfefeba0705bdba424c691395d995b2df3cf52bdddad25b00348b6bb2a8513ccf7a2095230638dfee06264adbc142b6654206318f644c4e127cd5278f50556425b0dc234969fd3ac7d193ff9c0234b1cf477e8f7e9e13fd902cff8ec2fd10070927de7f482cc4015950cd841d0fd1dd8ce200bc03f28c1844a7567572f9000e03791e74cc2018cb5c9704a59defd123e6d588eddaefedbdd9e714d7dd0fc58a2c2113317be60c893ebed38d57a6470e948e17cf97c436046a2b52239c761d7917ed07318881da8c6981bbb918a8dfafc43e807cf87bdcd2f4c202290b15b0daca3f5644303bf61072d8450897ee42d29b42e1a00f80af7452de5d3f063d990fb745815add76c3fa8cfc741dc8d1d7e45d3e8b6671a0bc69610fb2875c42a9c65ffd5fafeadccecaf76d681d9279524400b186ab78d8f2d6dd9352c56f08aae2a0a4e39b489778cbc0dc1a3842e985af131f6acb906c060a13f136dee4d8ba407c185d3b92fb2734fa1e8cc5340b8b630b3b9307b25d1732c860f1aa3a7576e2cb63b51a1f45aae2b29f82da50f19f27d0b2325bb2d545e38201868e4a2d84816e0d971cdce318251caaf7db2ea4a9ffa7252736a5fee4ecb0e8536156950035a8490f889b0e4b48316fe55f47bcd40e3ecaae08fe331d768d904191d22e6533eef6222ac96dc8707b5c024fe56915d612cdcc65c32cb6e582a157711a49ce3b91bb61611846094159e7fbca1cb376d156847659a49d4fc6018e3df0cd6ce621ef1b994de2e4b1759b4e7aad03bfbfee111f50535dc13d254e5f263b4dd8c43036251307b2ff27359518c81551ff7b95722fa483d74bf6255a764656858627b33f30d96b0579aeaead46f8faadee511942f7086286748db9bcc35a8149fbc0ad7354093882335823fa86300faa88241fbf46c7b8d39dfee3133bbb079d688acbde224a8b6ab05dae42b30475eab6ea19da0ac00f59be15cc3694dfeb7b688e103fdf54d0c75918c79e8459ffb1622448f874a449a454adb983e4c5d6d3879ec0259b75a37ee987b0b6ea2b9e7c8c4a98e61a2854574a639a274b9ab0a77295c523acc7249bcdaa5070f8dfbd2d426b5122a9150524eff97cbc9f29f5bc0052272bf8eea456a2309639d1669d7cb8d0ee5dc36d318c3c8ddee39acc589108b1d511a1b52137c52809df624c8555e0d4561d79480eda722bed43ae3cd0a28debb86b2566c08e861d410717dffc161d4198b41ab30eeb5db09fe7f50f7c150c71647a83379161e54915464bbf36875788287695577d3bf9da1d74ae807a43d118067a72abae22d06a411f2c4b0e8b26b9e13582c24acfc56b2dab45d5ef1bef812a1653c1e0773a8bc2cda362954375d3b69cd8c6a837db7d9c0bc73d9e03c4b4c8281073b5ec6d264ff6b797d1bc812234b1a760bf3b3b2bcedb0bcaf6fb34fec5685f96b4e2bb4124469928c3662a98f9ae8b6b56eccde64d4c967b8514722ba29af112cf1fd74f0a0a2d2dd719c2276f9a4f17a53ae8fa82072cecd1fbc0ec63f63bb0f0babdcf0e02186ffa7d94077b952f48f8fbcd058173194ff5b15c038897e963a67fe5cbf01351467401148db2828672aa5352ff0b8ea8c1e958a3d3b94771cb556af3273dfdfc00c6761842f98ec581ef5a45b7e1ebe627d9aa24c7b35896183381f46072ccc73f807fb8b3b6f45fb60b042a7b2a0ac2e457254bca2fa8f7dd658fc8983091adcb026fcd60a0f7843f7d81b10bda8c6aa47f3635b89a1a0e13d7dff3ba4cb43c06582ec690381500f2f983703619a455e65b5e76f3d897e774cfce04e22f768ad0520cc50ab3e484a505853dfafc7d051c2cc6c8ed639b764faeee7b295f6fc0b87ff10ce485b346eb3c0d75b81e5579c1e37631024e8a92a81c2361abf263f2e4a463890010dd03db46c5817e815abffa6f519e92e12a8eb74f839685ce357af48052bdc444b8bbb96853976bd77ec751c41ab0277f6e297881ff1bdfe38e51478715e90e94ca3ae6d0764baa1d6413487b7967cec3de0c90918d6afdd2e8693bcbf00b53d89640013ea90532bf12974a290a69f6daeca31d419dddf34bdd2ad916938e08bfeefe554a73595a0fd616ab23b6dd979a65012c94b3b5c09fd4f21c2cefa5ac28fdee28a662e00ad9e5a89a0cd1db7ae56cbd62ae9f26003ad95481572f1023c220bac92de7f45e5dae3927b9af9a8a6ce1e3d653d62a8088adefad220eb044db305685ee46a354670a5539926222b768be415ba120864e218d74541a7aea71cd05fb8e4ad356f84336e5ca7138e4ac8e6c2f6c6ad26708b06cf6e8fc99bd439f061af2bcd00bd6457ea535c1df95645db7cf73020a8c96f7ec84a8c87a9fcb86c0e461b4567be4d6f09901c674ea5de8b30aa2078dada9b1dc4f922365f108617b00e870e9d9b2d5fe86ce751fb9d2753982c6b4e9ecdb435e9f6eb3c3032df9d6b4734da132200a57af5cada2aaf811234c31eef23262ef80751d09756ba3df5f4b5a1469feba64eea3db5ef3e3f764db426c60596d77415ca31024f02476a62ee98a5b6b1618e8cfbca4075eceea1262883e8c1a329e8fa301f541b3ee83fe3157db440922580794d33797922a22559cb9d7dbabd394726de5e76cb35b5c977a4b632d75d26d598c0839172094ff56a4f4ea3a71c35891a10adb1dc0b8215f83b99124dec568e70bea0f34a54d92411a91bd7304bc7ccd04ddcdbbc71885a4257c692b7cc8264ab284df0ea3e57e8fe254976aed452580d146dbb27469f4580360cfe418718d7cfb552604c3e1c3973897c1325e1343df09ac82218a37111aa7bab5a7c9196903dfffbaeb7bf22cf61700b01e9ff4bfe0cf9cb25d078a719121449043363c8a08d7faeef17ca7ed83612df4b6d4947f4cb305711064091bd0d172308a0cee04c70ae34c990ec213382b216c46bcb507aa5cdc0ba972eb146e156ac708bd81cc96c11cb748ca3aeacaa7d7d4199d8010d056a0160fcce265b31ae47e0805f36c71ef06e94750d65ba78b2efe5feeb398abc2cb6e2e15d7c5483bc8f7959cdaf4c1b47c77b12393ad78a8433fd93f0f44af2af97099a6369c926a300fec6c0823c585357d724dcf3f0c45058705d879e8d8544c238687a2e61024f6320d38909db9eee022370ab7c3fa696e66096581ad438e41f66e1b2895bcf90db604723892b2aef08c12f9b659451ed258f5de544efaf5f7937ab956b8264d4b7ad1f41f04eadac19022d5a95f795b86fcdf3a0b74862c238891179e8e93c664acf134703763afde124625fa4b25af34e3e7ab215054f56b9c47609966ad8172bf8a5d8b2a6288156a59bd00afb3b81e28702e30a3379b95c8e07a96b3457ccd46f9fb7a599f699087dbd0a5038124b4373e3250c228e463aacf30cf7fb92a2110e4023b243af9bf203a3e924f07621c845e46fa79f7e8b90e67423cbc528bd4be254dc67b65c29d9b55b9d7c73b12922a01ee5ee18be2b2d1f7722dddd0ced42484bea845ca0be65273b26c9cc1aee04a8eddd114a23b657c02fcfbc260ffd569d414b1e79510906b8d7e649a302605e05e59a333eb215eecf179f52dfebce5247a411","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
