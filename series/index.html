<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4113abc9c8b64d6ffe6f42faa22dd12b8ab84b303e5c5ff0ef7d715d3d16c65d5e572c27f0ee4df0f574929da966a457ebe6fc383bb68a7ac02558f833319c0cc7b1a809308c02712cca5eff3711ec5dc381e88075b4f2a356c33418b17e3dc41f86d4fd1c325cf82283ddf08ac9792543b94923f4971f217121d57c931eae85e6ab5648026af6a54ae6bd30dca1d13a5d7b6a3b3f69f7b70aa130ae7083f8e3e3ba47112f8e1f31000f6f92056805547cf44cce14f2e135ebac2b6418d21f4f406b781fb6fbc0fc3f743e14d90aa39b3cb868a390488c19c73bbf9ae51442c3e378c3f1a163a8240f45920b86a492fc4cf4b4c62616606cded10bb1587367434e96870144aa4b661aac9beae260c1d3ba1d922c42979a66b44302d8028613af001633093e486f1ff34a5780c2e4ad370051366566865e5c26ee9d433b656ad32a35ebac5b9ac0d4e1ee4926d16e42b8446343333353d07b3eeb62e2a606649de3bb63fc09dc0a80d437e7a7ac856d8720e60779132216c9263a48559a912120ef6bbd98f4a661612354e6b1910a8ac05629dac73e46c4870c6ea1d80eaf8dbec38aaf6920a7686ce2fbd9fee7738597d6f262060b8ea3b50b97c0ba91eea67f0978a21a7cb19419200980d6e73cbef20a03b281ee19e4176a458b89e1359e54a8f123e53a12e68cde92304dd99d4457695180fd85498d6a3b39ebf38d8b2df28dde59016b42b1b4e77d8bdacd43c6853954ddfbc823eb1164a8fa02b43f2b3731ab743e1abd4972b6d72c3c1bc143be12e644402ce527000a015196dc8b56ba10d7f65db965bafef2ebbcab0e7c9b84daab1b73ddba22931ebd153a21887b07e46e3e85141c1e03ef902a7cce96284db1077c17635c9e30641c8a61b12de91568685ec8807604fd416bf24c039ae1a177447a492c2f7e5fcc3860fa22c24fd0dd511e207c71c3e57dbf164eac5c6cb2c9adf2f12011c25931110dade30a006a729e53f99dd5415442af221e4bec5e207cf7e039feb0a955a564037c34f5716a4104374ad6376f2058202c658694e9658af5560bdf0590e05c07f4764099b5e63557e4c0ec9bb45f7cd3debfccb89ca08efd647c6f9e8e22ade4c9bad1e92e07bf071ba6536faa920621079bff16ef1cc4de7d7b194688ff511cac5fdd2d35534ce40437cc7ee620a3a8232f9f3acb3ab39550aa99351a899ee1143045feeb7aac88ee5f1a08359eaf278d62b090e54760b9a3ec323c0ede8ba7c4991e29bdc6c4533693952d8579e60bbcc68c57c5b83b8a88be9b6c923e695c535d069558a585286305accdae5ac7a25de14997265681019c0ce158b3a8f964aed438422b660a0b7a89a98e3d08ed2d3158bcc9ce448199fcd32d797db865501ee0f821383f90025ce45269ecadcf892b9daa2bec4008269456ec7e0577e514400c78b41b578636e6c7f050511580000004ff45fb7a752700b36b27c51388aff86d351988a52fcbb5942de21a3429bdd4b42ed7e8cb23f9174a2f073f883f9415a6122e21ecbe999f29dab93b7d27aca9b73817cc2f54be6e632bed8b40029ec0f50a53a84bc8075f4c2d3d0d58a21ad40ba9049eb1c5cde08121c0468635124167ebadc9804642ca69ac10a44eecd5003549315adba791fe4916f00d4689d8d7cdfe8cea21e8511ddcdc1a63c9f6fbc86b84901c2cb66298862497c3b432334b99e5aef99ef06bad894e9853a1f43674d0c9b16228a85e9575039fb842c7e4a602c6ee8a50da3ca2c3d262bb071917f418754875cdea668126fc6ce34cce5ab5677e4bee3881ca3ffa1d4f458b5b2b6b582c8e344c5ee7ef9b9e3fe7d56b21c0429c6289b36ac6aac3c42da5df659e38e268a765116bc8c95b0f425eb01de4d45d4f9d3262487c9d9b9a20cbbd0de231d636cf1514bfe0e0c2655306f66d73d988d4dbc6ef74ebd0c3d1c0c3545ce9cc71250d7db7530886f39a741e992ff3919a02a03996b70c54c24d7fdb3e3d9e52c72ebd14406131a0b37726f3b246ffc2deff24359824c241a8eeb66b693836ac60cef0797db832dea30bb09a4f41bf70fb2105622af271ebbd61b081b9c25cb3b63778e057328b95935f0781835fc57f058fcd99eb7d941a8b3f81cc177aefbfe50469303050d4d724c5f4aff1a46d141e99b27e7c9a15eb43ee5157a83d7a5790c816fa88b4f483e3d60163fd92c359ea19b929e651d91525c64aae17209e3447f3371ea27ee99ca68c93acca0eb90e9cd393409c20e528bc540e6798dd104f7b4b712d3f463625597a36d01385965beb340ae5e195d3711799a5e0517760bd2739659ea54871f07ef499913e12f608ccb0849c921d743ae8af92c62679e623dabcbe0bb983afaa057da356fd35a26f83430f94ef66e2e2c9f05c3a51111b9caf97d874ca69d0eb78068cc710850c6449f6e7101a4d61c59bb3277f3ac20d572220aa7a24d935171d3a7f4098b7d5e2912847bba5512f0fcc1702ca373f11a6af3666409bb908db4a8c4fb2c1e55c1f4815a9873de6810ada31186044690788ab66fa7f4a43d1c3836c389cf86c328df78a163047e6714b44e6c6fd42430cb0f83e89161dc0b5294c68d00596d946d97eff70693a18004ff2841ddb59a412cfbe1661f5acfef63c4da9e64dab76c9518f23e5b6b4a1ef0c3822d5c909d854a80619808487947d563811c8a7ccf5f18f1479b641336c623d6335d319169fb51aa90bc15703b40c2e50c5e51c3cb538ec5fe00678dc60466a5c43d4fcf0c85f9b1d01abdc4fd6c2c4ccb667d4624b2dcea262a2f5158a7fd491a7853b94fc30150c17a08f04280f5eb1688fa36e38a902835a8675982122491be21b600f1c234269864e932136adf66bddcbb6823da0bd897314796c38c111d3a05d0726369db498b906e8deba0e22ed1e9da5b1c02bf2a273538f12f6f3f5a0f538e92f4644afbb7f006ec5a7aff35cde89fe27ace705d8122f9380872d73bf550ffe9784d712b4a0139ea77cdfcca7e2253da6de53b1150126f6e86bd7411af5455d0dcac0cfaa44c4b3f278030bc8c6670ec3ca9cb2cfd9458c3967d743b9aee256a7b7eb1af79e6ccc840a47714a525ee12ff818d79919c7b31e66590c46e274dafd53103e96e0ff8d9c974d1b6ea4b7e2f72f2042a71c35d31bbcd97cf0d5dcf793d73ac52bc94f168d816d9ffb89509003566e769bc40dac29443e6fe75821899657b14aebb04575ef3d60d8b286b804cd1f8287854e0afc5e73bbec640a96a67dbaac91371c6f817467506412a7c5f4045e7ea787362e44c8d9421dadd1d571d1eae4645f649045238a6be397039c3fa5c74793fe6572fa07b2b04931081c0a87a7e54291fda7b0033689921be88db0212176fdb3015c47b16174f48ebe294403c92aec3492f542117eec2c8dabc21c931bf54b21d9db81f8776b3ec165622eb596af4386fe3c0094380ba8e73315f0d1ff178bb9a831184d6bb88d9efe8a2155b8f07783182c724e1c6c1518b587ba58e441e87deb62b9076b9258c11f3371d06cc33af2bc417a28d05acbdd9e4468c36027548bcf37646ae86c33f18434f0cf0be78469416a13f52d16541d606267c3ea8517ddd910ff18c57f68351c7ba3e3ecc7c385ea3317eb203dfe451b5e15955d76a4d8bef4dec9c57cd20d990237d4841afc37b36e65209872942bd4b1903f5084284845e21bec3f2232ef9d5922becd05833fcdf79ab46e7411b311fae388a8ecb1088f05070ccbe3d0fa7f71747b2b0229abdc2920c4899ed92928c2f2ef9bb79ba91a0f458eb99fb140bab6bc79c201f3ad67e03bd38070fe38c25acc0e8e69a2619b9779cb2d7c368c8513831a54216dba1aa45e3a626d494a537a61fbc810c78fe4f286eac6b6772b41cb4327e4bf4e5a9c64304c7faddc6bd1ba9d7c7c199f28b9926cb053f2e336635c02f3cc220218a58c6b5f0045906488f1d2a9765b101db906b271ecd0edd99d59ab83778d8c9c82f5ba45446165a4304d772b8f6a86ab4c8bdc1c6b5d32194a794469ec3f128ecf92b50271271ebf891df9a4fe2d0453b494bc5da19616f2c24ef28797089ecf4ea2497154d69c76d42c756b2cb58dbe0f6a8c15551147875195059d459779f50131811759947e2cd4a9aa2be60608dc8bf376b862acd514cfbe2ade14af826020e0bcc776497e3bb6d640337d6f8b126957220c5aef8eaa057c26e79530fa52ac7bdb1f722033261dd3d2ab6a2be56150c36169bf2d6cdc1972272072d3630d2888459f68f5ede5d34545f0ae4d6c34e429e2fe07156ca070f5e2e9ed8210e738d5271601ce0100accb88f58b174e066f4ddf330abf2417c452dd1d1ddc9909908d64a5bcdeb9b04b4b61689555fab71bc5f4adeb247db26fd7e4e026d0fa912398783c89022d3d50635e17ba0c3b482485c56c0a726be76cce6d7371600c80ba0caad56c807273805e0bcc0acab5f60072f42c63e57a6d617134351b6da3c158317e6ab93a8a2be76b790cb2ce42e3dcfe2bbf264445c38fe9d2c211deb40f07c46cf871f71c62a3079ccff56c03df921b6ca670c75d5ff675b38c37b660d723138e6280b1babf182b01826d54b30d7fccc2ec95bf03c1ee5b812b4f053c2ece28b85216e03572b8c30828e9e0836afe0cb0fa8470a475e4bb786b956f0289b5a3b93dbdfedc6d5fb2f87a51594579b690565472f2d2af014766f7751225a063f05d902320e577c99e2753cc4fb38eade85751f9a8a735f9b11b2c24d66e71e80022be8ebd884edf50b96b51b0b815dc2f9968f3a4f72a54ab49de993c2f5cd22f9651116cf3a1c0b766d7ca35dd6feb6e5acc34af189c9780cbac4d1152d7820f512aa812f123c8b52c43d25fefb9eff75f82f582daf13034164fbe90e6179e2897cf7c3d086829c1cea826adf1ea0417de560883aeda1beeb369af4981f40a86b37eb466f56a8a2a2cfa10782fb20cb683809468c8f6ce54743df209108c9e28c23cfbf816fbfcb1ed1a8bdb0b02433fa6c837faea5f427a8b2a894959e7bebff5c738c2ecc5f56d11aba099aba469a3dd5f1d99d300f4677a130d1f989bdfb6419c3d82c195b604c830c738a0bbaf9b3763f1144fc28cca917097877e611afa09d5c13ccc7e7dd3548e205e8c3a63b0a015062919072477ef9f89795d98c8959a4a4c7aefe71f1a5d2707d7dd53c4b88e4a84180836ada9158b2769ae13121212fe40af512abb8f6823f25f2dd7d2ffd73b5695ef60de2a7804d759e6293d51f5d9524141467be1e24e6c272d45478156366fdd962733e8d7ba08e517ca7effe7650026e69135c27ae5dcf89684b00470feba65166ece454672ce0694ee8d7acc2bc1d357705824efdafec091bbd48ffd9f382913a051e6d18dc6c4c3a9e5f65baf97bd16d4640e2c1adc5b67ee9efc618cdf3275849d13c1c444b7217d56d0b21ff879cee4966662fc27d7175049baa424a3cd97fc9f785fb1d5ebc891f8033658f9b3da73a21041730b2de4bfa3effb804f1888951ba92fb60b65903f81f4b1fa74b61d244eebc7f3e661e291652c2dc78225639027f289acce77f6f25c491e6b7c4fe8f747137987ec4dc917fb54b6ff557f565f69d4d237df6425218278624cb9c1c35f5c818df34a8ee7296422ae6263e9ee9b72762ad57259e27b11da7ad41dc859d541afa96febfe6e603485e42ccb729c529a86a63b2d0e5a8d1380df7200fa0ce033112c23bc3f0c9284a653a8722a1a70d81e7024ea2e20831765df1f00030fc380e5845cbc60624353769504d1994cdee9aabe6efa63b8ecda1a53d323b34c3cf87a26c2d2cb1a183620005b9977b4e6fad5569f56946ca98ab3a0570625cf92f0909532595b55b1e92a2fa02166cde764f13e4fce7f66662ebe8e13f98e84e0e1d3eaa810ba7dc3c5037c724d9e81f0c0b1086b6271e79810e7cb484cabf1771e6c9d55859bea0f6a15b2fd84d81f6f922f9738d4ecf231ed784a244689ccfc156c9f984ec1606412936e815e78fec6e93c3db248ae16f3e42d47e0b66ee6c8d2b835a13f888c0439640d5ed607884e3d658bd6f498b8063934719959e2a0a7f72458d6b62f93d1bd697243c49f5f244b54bcdcd4c221b7cca95f649bc75be08d6e2d72d8e9b39f90d57fdeb34026d38166bca5660537036b7e0e326dd3007f885ddd3e4fc054c56cf80e8b2d3612d082b4d723566ffdb4c338d89a62c661524ad79d11c11f3eb9048c30335cf3c1d34f8171fe9984d32d55f8fe9df7fe61285cfedceecc230a380d103d2aaed66e1cfb06083c4045a1d6f44f255c1e4a77daa8cb2eb41afc7432b24a1d65ed365ece1b6c8dd188cef7fa8dbca2d2c6f8d8b296c0482def08c3cb94af805eaf385046524792f9496050dfb418e77f5d1e0e4a6bb02b41877eb7e691233f03a0869d29652de36e0d0175523eaf8b76d0ab6fcce54824e243c865c885764290809dcc915b6631045f53ae2f8201614d6ddecbdbcfa2ccc6b3dd8d038de6494d9a11fd43508dfa579f957305fb0d4eac76bfc985dd3f15cf51edd83e958b7dd899f52d0b14e2b5a89c34bd577d92c068986ae18a7591ed1841ba95aa5f922ae5f2b94c08012faa023e976713c4c7f181547de16a011f8e85bb812fc45b7410e39e24dad12d249f319acb6163c1f4fec69ea1a037bd0fdd6d86f878f3f35200a44eb4ade1e8bf88fa5ea7eb26ad60cbb272e643e32858a50ed870c44085922b8537449feaa312d0cba9d7ccb4645054ac4719d3f11f4da91b949b0c42aced16c358260ce4d638594cf712b84d41aba382bf826f14fe306f9a50d26fba63396686d55dba0a644a651315693c70e0acc70a8299a58c018cac1e5ba9b88390846b0f3f5c5a34f083941713b208b1ac9ab7eb448e7448f6cb0a8e3311edc9055725a167fdd0120ac93d49028a9b4b9a0adf3f6e996c7cec40ee8230a0a865898c512e2f1dea4be640543dbf9e2b97a45347420298dc8977bf835a5a3e553ec7df452250251624007c9c55573c46a6c9de83e015badfef645bb90dd9e8f6fe0e44d1d60d1c848de603e84d88c9565aec29d82ff727daf7da8a7c77bc2500c26560004afe720c765132be5419b3f5abd8afe6593570d8f05059bd5f214a8b6864b35bdf1d3c5861430bc9ba578243596e19fecaa13eca6da0e4c7463ca44bf671f65c02d151dc180ca119ff865426944c3fb5a04a59ddc136c6388a270f3c95eb3c997ceaddde19fc17b3ec87abeb3311d9786b1ede39f9819cfb18d60129daf7804f0fa5ae3244d955f9cec0ae7a2909986e7c05af4e3c363431362a8a33a96b408a1cb14af452946b75971667585217b179e670dbc6f4e47db655a11b13c6af90e490f0908f9366372bcd4dc8e8c624e56b0805577fd6d305e16921adc08d1ec7b6bb0791c27e2ad34e3ddf83b6ea7b4e385aadb853e84fd4e722df36ad223a48279a36644428c4c462153ca44dca431b995727011577282617938c8748583aed8e9f7aa440c73a61a669b6c934f71fb62133e73d5c405c9a0b85c706198406704e726651b64e2fa41190e4e86596319a950f4831cd7cb35bca4f902017ce8114add6d7500f535dbfc7eb41c01bf3e895a10458b22bf84d4403b55f5c07dfa1dfec4d9ba9277d3c5985cbd0c1cdf173a30e03beb7ff1344a8655c167fd4254be4c81497185c4d5ef0c6f77ab2cf674bd2e65086577dbca5ddaab6b2aeaec4d8df7f5f58a650aa8a02f8910fdd71b33027b21061014c64df6dc05901028e9b2a516fbe8e0ec5da9af8fd96eb10f1c64363d2af16835c93a79e0996adc8ee901789a54b366090af9839d2ce15f16c9023d82058174068a06357313a0a685fad7c7698ec7a143f8b6cfdf2f54c85d4b6808e0a7a98c5f44caa6050f698b4073921e2b00aedf5b643d1a12ae901ad365bf27586038ba584c30075469d1e08763e72d0ad14d144a2310278982067508b21e573a7b547801bb9a81f18349c1a55638c9387374b6a70962fc861c589aeab88d12ab349d3cff739fb39d026fc5d01c27eda6d2638f8d914dfe1b0e12e6bac15bd0108091bad315abdd409520c32a9350eb189bf76fd225cae20674b4cc37890d0215edf3a8c917208818cc19f7b4aee852efa181b3c3f27cc46c7971f9d26264cfedf986493dbb1a42b237e582b7fb099d5b2bd09685f96c0f5d61fa92f4880fe0107d43a682dc672f787591d6e9f429b783a7962ebc1942c2bb59cab616c94805dfdd1c45d1659206c64728af9bdac6951def9fa5f1997ec085101bf220be5a7e23df21e0b61664693e7db9b0c992d52266c120e32ba0faee94399d903cf56f421cc74ee227647793c3213e5c9866e50430d15352b49315dc5d05507ff5ab2dc33e0e64ca96faead0977a0e2804a9ed868b3117558b30aabc38017bd6a0a5a43ad360ccdd7317f231379038778453580a7ce726455d26f7c132ac8afe9b8ed7aa149bf43078f2dfbf679e761352c7334a8e6b2eaf5ecf0075c1877ef83472e4ff001027cf1cc599f6a64c6f825ed6fdf60388b655f63e0504d4cfc113af3ead38b752a7bacba92ad2835809a8aba4a2e1dd6d648c3bb136f4f852e5dc18dcd1212c5d72e26a2d2f4f255ae3c269c2169b3258233c9596a4c69c84e69e12a31befe11e4d0e853c7d1436b86af008db555270269ecaca20116f8a37a68e970e2824016147fe37d1eb991e194871533d5c3d24c960f9ddf82e5dcfb58bc988f67e272016de4e6fb7c46cc69d3b9fbc1be3a4995704c4afc34bde929d480fbb4ad58620974d03ae8578a49a8eae52612657cd938ff2e047573c10e9bc0f0bb2df353ae5c1c06adeb9fdd68943b417b880871eb963c53402210870f0c4ff9c8dbab58dc6903d585cc06a4444b9b91d2495343d69ce11bbb961722f35f09a4309af29a1bb090826e44ed80df50e1c1260813f8d5c15d8545a0fe5214f502fc6a07235638ff28ac8de6cf566987747a76a4a54e80af7e6d0b6cefbeb8792715d20d38fb1eca18","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
