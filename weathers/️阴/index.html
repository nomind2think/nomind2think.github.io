<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eadcdd9210b1813bda403460ec37d6c8d6a22a7ef2be12a83bfdf1c87c4d5161c98d1df2e13762184cf5f49e43130c5d84a226f26a6fe20645d6d53c20b743f1eb6ed6b3ed6e918b1476dc0f384e7830748901f7c081b10c4aa6a82d96fa7af4837cef1ba53efa4e0343a2de2b091971b31d06b2d8419704ab073115b28f6138b79f910a514b90ec0cdf4107e1f7afa19402f0482be98b3f08ea036f9a106727aa0ff9ce99804914107fdafe00947534d951fe1a01e532b33fdb9022ef5da74eae6e544de5a7afc62a6ba9b793b05d5de994f1cafec36e87cb904ba54abac6d89c2790dddbaae59d72df171f96a1d788c583e607f6371e78bbcf6a5f8dc1b93c9fcfcce2671b10f5bcf45dc873e4bbdeedfbd0c80433be3c0e91267d8833a518bf97c857ee9aec53b2ac4db550c6b85c2178f6448b05a8b16c97128b6afa8f74fc033cb52c06757f3e685a1e675fd2a1b640612f42018ad6012ff66c483c84251f2b28f3fac44da0eafe7010999ad2e4b51436252ec6db06d70a4021872b6da6dd599e6f4b20e5d12d5c01d0c7c4c9f5a10444804a00e8d262ad4ee40fd39fd8fe02fcc577f2ba0bd126b1bed25219a3b729ca72c167ce2e6bd8d9bc3a2a13dd408dd0c0167af40d81dc6436c5fa3b2e52c7cb0a354f2245578301c3474505c1d8dc8fe61ede09207a55abce9ea4b4bec588728cd7166927e23859ad3a2a0238ba5fe1e80b2ea990da57efbe44e18cdb7f7e57db8c53b24fb07f44ee7c42fc75ee71f9cbf4c6e0c64f41bc567de3101c2b0103b32dea045c5a7d614e7deb4d56dffee6b4d26a05f62b4dae6c6063dc900df4ca09bb81c3f31985a0a7f1bfa7a8c023b53f8e0b7a1c71c0b7c1ed4f43a81305b14d28fae91c6610618d6b63527f708acdb8d6038c5a3666f7b57b0d0f8b5ca04bf2440043b2dd68edfaa17cb97ba2f5c8e35e6e2bd171fdc828323cd57d7e3ec38b825c35100f4b13b98b2d5841dc03223d7c1e91815fbcf1b1bc2c7e5269c948cb9dfc302879b4df4d7a9c2bd1c5054becb2453474fa1e45d732edcceb95a6367beb2a362f69ab0c7a781032fc387d46c6f4e6c5855d845eeec2e64dd9452c0aa9ff8b9495d2bf6ffd8b495d3b1b571e9d2ec34b8287aa63a40bc1b43695647ee8c9a6b9ea561b7a95ff9d4f28ed6ecf82c3b0294addec61a4102c4ee55e7f5a69a39b085923105d41a6152f04d465d8e175cdc9d9e39b707d7a3a1002b8db0e74c933a80ca0ec976cc7519e98b83b3991633f166459ee837fd6f208f98459c2d1e0c46f45eff1e1dfb8d6857741faacba103140023da579b0a72d71b7d6c37c61fca7225ea01e50816a3e2e227dde54e1bc0915607ddf49cd3eaf254a394dd8b97f88641bab154d4774f405131dedae38ff29813e37c3659469a70cc2f14b0230be9e2e73a3166ba3270cbb51e66e1111bb4c2dad445aabfc9890ecba85dfbd5fd96b8f601689175b561d32bb95d531a5f4b553d80b7a08a796275959c6618dfda30d6842d86b2e46429298f7d964c0fb3166909744fe389e659485145227363a2c842d6d85312bc597f0b7d6cb4efa2ffb51d549bce1581684f4cd6169b1b088c4486402706a70ec05d47b4d5280f82a532b9a08a9dc7045b39860317aab087c02de29a6e9b54c47f17f61558e8160196fea18bc8236fbff235ddde40d7e2e15e443754029bd526914889cda8ab240dc0bf8042e325353fd00c27c72194749331da25f40f38920238f0055f8815eae1c35f86a7e02b0f7948749e0753211cf274266465eb1c9d97ffe97f7118937cfe7cf02e479ce5ad958d4591cf43a1a6290eb6d4e027811e317ace299d2b79aff14db5d028a3a84d68f928aa327a87beb70c8a4b67c97f2411412fe06f5932fb075ca5d2494ec7550833e8436784be28d32377f0c816273f08515525e958a65f9a6976f542f16b94cea1749f39bd1b8cbd1fb693aeeeb972fce72273ef800a6eb5b3c7088cb140910b580c37b1f0d426b0a104ec104e160c450030376ef17de64cb9965c803f57fd7207e087f8c654c301bebe981c38c3e9456cddb10a15f326a57b3824bbb5f8622c1e8f01db1165d6b7746894d07da3dc9919e52a0a0e1917c70ebb69700ab34c75c8a5a2d8611584e0be40460530e243fcb8e53284fc1c0987a11bdb6e6a4574f06c482fbcc55573e787cba9a079dac6a552ae4d8396e028cf46493339294d97da8740add53efd918657b2a8c5bc180ddcf2c066dd447655ff527fa6dafb3388696eed8968960c0e93bcf5ec02e4768b30f535e1e1c96173280689cfac9fb37f77a2c26c7fbbbba6b00d37998114ecd096553699f88745fa09afbc581bbbc0c72cbd96bfa259f91dcf51d65d4f5976fa69e651eebe1f335178fe3dc85d926adc17a53de262a3232271c05c7966e6bf4206cee3a6c7d986709d2d9b38c3177890097f6ea5d9593260f9ee2d17bfeb6aabee5ee1ffba96b952657935cc74d73ba120fe71d4a5bef9fde37b0e1f400c36e8d0017e96b9e7e67a7938f2621ae0af5133cd0c5f8b0ed144d768bb1af65729bc1cd2af60365e08afc4c4936fc46f6661117b8a60311497df7764f33f51d18c21b917cf80aa0a3bc4fe5b83394608844a643cb6e92fb7637d8cfe69be971c801f4237ab62d8fd9cb7c842be70c03de75efb2c96679d113bc0162b0ced2d6fb5a1de21f76d4a39b841699f525dc1b1d9534ba4877d7ff2a93328aa7cc0d87d078c8fd31d6b6079b3aa1b4a8df7ac9fc190850c8df520937d5ac0b45920066a0f464478a810f845a1bd2291a021e9477d192fcdbf9ec0a54b04f1d7e7a4ed6c913775f6ffacf38b37f37bcafba4029d62b6e1c86d51d76fc1d811a62f1d01074f44f061aa0ab2a5bfb6e36c4b28fc679a956da58506bb9b5a3ea726f71286099ebc22c4b8340950d2853156016796324497ce6aaf14eabf0c1b63079a656d0ea50ec36934eebb830702492b542a38fffcd4400788ff94f2fe858c04f182ef46ece62187c074705698d60ba3ace0a01bbeb269877940a7c94fb30a80b4760581a0d9b7bb93da7b5ac840cb287ac2a4e9329e8a1d42b696a6173631e5f881ca65de5c5c5f7f8b072605f37e220d696b82025800132092b766c6c46b7b843a6d891c008e26fce7ef7ef4b9de8d639a3a1b175656591107c559cf7bfef77fe0aa178bdbc71f36fa690197fa52d6158d45aab8cc3d6caeb6768e1d36a6156d7444a18d47aefe9385892a95f5d62739131d025860a0c812b404d61e88fd623f7f9b78a3f0d01072d183a3d39c379b394fbf75e665438d277e93d48a1247d555ae19b4a3ab353a7fff8b53b8b98ed27cd7eff418124fc2b6f27b5fcaad32daacd1ef1aea481adc1c05473d3aaa9a88dee3375b903349fa27d8c3413afbb869eaf3b02f061eaa682fb8a256a8127ff5468a69fe0cfa085ef21032448ec0b801dfdf68de2280c45d6152392cb824a72f6491a0cecbe0ca4ce076f4c45e9bbf8be0c6f2b8fd4835655a56374cd25457a622144ab867ed252f650cb8e2e5179663ed7b9462489f433f16f85b2581645b7bb272a20fe9ea55fc31f436884867b1495de787cc429b32ddfc580602033aae8e14ecf51d300b7cf7433a91c7a2e6cfb0d117c7b55a2687fac02861946a4ab6869791bd79502d8b8618a7bb7dc1ae065c040f932a174bc6f1c776b64c63978fd743db6aa913d27d63d6d191701852b1cb6a3ebd2e806de5b9ae3dee2fedfb7dadbc188bc54df7985a1af71c74865c7b948e263f6b1905c20180a68f063eba30f648184d4eedc4f8abd4844fec745792edecdbb3ad41f71e9dc3d672e5e483c40825aa3992ce7dfbff4f395abcb4628d4239aeb65d94ea7f03d4f20dfcf43c87edaa9234acc24a7871523beda6c1db234c1af7d6443011a8560c85a8eda8c7b87143b4d94f58dd925630458fc955459f8a14a5d48cb2fe8d477056b4b6d06d2595776692edc854d71bdb5e632baaeffff61081851662c2da502178f21be07eeeb7e4b22b797cf54680a457ebb1d55c519a64b3135c983a36a82dd75ac89eb77951cd539d1dafdf752a52fe3ba9f3e6c15f6fb5020ad7521672012069ca6bd1b587f6b539c84790d1e103b6ebb6030b744f3b7d3f01e760a12112133cf22af2133c24a2ee0ac156d570daadc9b6a4a165774c63511fd3e7359752f225648746e7f74f6dcc5b08cd0cfc3a013ab0c64b379e23ef534d946d74ffd4b69ea9bf9b775e753b99231c15142c0c084e8aa449adb1e0763e60e8862d73163c1de4fc9a66300c5114255c52b749ec1ef97dc7b09d5d6779fb4aa289c020beb1f20a55065ad1a177b26a7cd348d5ab14287cb4bb6ab12ea73c417129130da7ed0ed5cb190ab692cbe377940915e35294ca41e1faa96d2a67e46c265af8e36dcbb3db7d75411c4463c7711eb265aa7a14785e4021083ee21305b9c8a58cf4a07fadedcde90200f256b2764e86d68dc4f516088cd0f5a7c9e29b2f63780f82ff81a31cf183e027af6218ce9671c2f1530572a1611e206acc327cc8c7f54b38aeac5c9aa49d30b351615fbfc63dab672fbba2e9152ef79c07e805df78ff6a9ad74ed264fcbe2ba02f95f8985a8d9c117bfb8e3313ef91dd5dd61a9d1f3fd5f87f553b758dfc49e246520f2261e214bc303072d66d5e9c921ad0a6adb00c68b64d1c9db11c199060b563f8bae0f31f38b3e374450fffbf5bd44c2307215766ed835d8f01cc376c42372a4fcaf61333e63c66a6e5138dfea9caaf1598f48c3883adefe79699bb718576efc3b9b43a9b5ef7167ec1868f51cd6df9d2c0a93aee5ee832389ea41048f35d2f13c30d1ebc77b0e1d60913bdf410e129d996639ef2e6ec54f3f27c867d8d6f5077b937bf48cdcc5cbf01714fd1a4caf54430f705b6dd81eadfffef7030ac509379a2d2e580c8d8ea45b7d1308a4eb197394fbfa8ed960397945b0f8d6b0783046b10bec681812bd55fac82492371d3ec044208d5bec6391a18b3e9064d7d820f7856baac6e11fd04c8d466135d5e4823b07d1a59be07def64d616efe95985fff242b0df35e64682036fc3558c310a3c7ebc722f0005570b28a8a1e507dc714de172b1ad545981dc55233c2ca232197bc073de975a3b591750376c5e4881b72f7c46696ac1d2fc3455d01030a0f9e6ec8aea87ed8fbc4f74f22be22f25fad7746bac9ce522841f977bc41337fdeaa8e76f9e21d6e0a0c90268f57b960aeea2871960f6efc6de51a3c3c617bd46d6f4a450d38512926f6c13451f616569f9df94218df7569aa5a4fa4484af06be5c64db6fdf2f55beae6075b780c21a3de625fe9d806247e501b6c46d800544b83655e5160eb5a281cb241c90266f67297ba2abe9e86feafbb440dfae84e528f5e3d7b64e12c6e1743bd2ed654db301fd7cfd3b2e81078693c20222d868b90a6fd821587b286a6aca075e640b4ee5c0b2c8d71edc8be5ff46ea9110ed7e32c89ccab256c9eeb75659ed2e41b12f8e77d2bca21e1545f6b7317a2cd982edc53822ea9b9dfd6261cb189922eed555faf5bf9c1047eb786b29cf44e21f83565147306244750ca440b125f1803ca5811c8d54fbc3bbab89b58b17d7e9fb5cac630196e7eaa1c288b9416728c608217e559be11db895dcdd6bce25e014981c95ec0fd7a4449c91ff168c74468935e3fa4d6ac686ebbdad6f5dbca32ef17f55e66adf1100b1e6224239440187df8083c1e249790ac377b950362e9167ed06af35d1d8af3006a97932395234f5d7d903c4862fe817312ca8a86943e846e9eb6279d78fada1b7ee158126241af4072411571e4525a8e2efea6710e20941c4b0fb5add6dbd7ca3b3f2e346877637b2e4526376d1b210e04c7d9c5e78d20c1014f3a163445b983eace5adefc1b4c7e7e518200cda9079644e8c7a74bc6c4030e4b9c5b91f4add506298f60e9d85e51bbbffe823e6dae179c972cd226f167f95046bd5320f5c92787e8ff6dd2532424c83848cbe54d954b7eb5694617df7e2b8329191ad6e3dbadeda87f8fbc4e6968360e36699e44a6539d9528d57bd983fb353b71d7db027ac215aa9cea214d567aa4bf833d0a724a3abecc87eb28b308b0de689afc4bb28d0ee1dc21b666407708c5a3654afa75724dea1a101b8f8bed65e67ec9562063a79f0d39b01d40bf61364e0546d63f10156383fa5b6d13d9560ebc747eba3515eeb8c59ea2436ecb18a137f8c61df692df3922eba2257e3b5680ef5e60e7c3cc17fbbba7094cfb8775003d2b58f607f0f094117921d6fcdeb7042d77de1d5e6780971e4097ec7ea519a5ca0b4899e74400524100208d65a53f3c2a791c67f2b3b2e70efe8af57c5826f531d8a5f33432ddebab5c55a7d31cd900bbe5c70db1c81167fd129a258039cf213b2363a9fd121b75300c01315e6a9283b50009874ac89c2e8331c164bb55ab20b6d389f0d61b7e7b246a5f4cdbc2adcc3498488fe0992f450526b8bbcdbdbe31786a806d08474c7f347e6903b7e3043a00e022bb94a1de6c7abf7e4018f56bdb678a076f68c3300b05cd47ceff4699c81ec15ae3f101a91a397e0a46312ad8791c03a7bbe511419f23f75a2542a92a2ce6accecaaecf0534195dea67baf8098f86394f21303365ef82086d4a8906fe6bc21054ffe067f5d2bfac2509086bc40faf7b9a87efa39b1de9171895b97f72f4ecf87b44e523dbf53fcfc2a82d3f39c0c27ed29bc15ce70e8581d18a04c85a79fb83dcbacae32dbcf9278a0b1ac0dbe1d6d7f9fb433f3f0fa2566d3d44e5549181794012e383c5a8c50163ba7dfbc7fdf72e4d6112d7e37e5cad8f6a9432018e2bb0ac10d1e3f549e339ff972e824d886a41392d3a994e5646093275fa77679bd183cf2c8b6b2d64d897687f27850eb23597ce250266df1a22d80772f4684a70c20ab4d8b0aa1678c2c1f34186bf11675c4eac63bdbb86d50076231e700d50dedb4c167c0a6224bde9b46b7e5a3037a3a20c94283a4b59ea53601e6923a8dd0f9925c92c2e996c8fc74275679c7580cab72554a58de37ebc3109ad84c56147e57194ea2244eba4388eebd19fb8d263cfc1114774da6e08a05c8906184011dcb5222731426e79f52350ce09cca687894b03b3822eb25c98f11bf27fafdd37c968f4f2d4f1f501550378c94d32ffc634d3b2d24456ff5428f8b942f646200264649c5fc0458d8f4fc9e4d46e3084db766cc5ac8bc88e9e1f1c64ff850fd988da168c1f4d015ccb074a61601fd4cb4e4441daad99702f62784d0f35d787e2f8557cd0b9feb9821d94b5cd7ed3c7c2302db552679b2ede13a3faf660ecb7c2490a5c920b45ff01bc68eef5fbda68bb8560e8c34a05267d77db7b2df7f199de68ff8ffd84199f3fc788473ce1c3e2d658148aeea86f4abdaf1b0897e5af12244c2e176ac7f0a6be059ec7244722ad92c4f701f27a1d921c75a6958c451d4412d851f617fa569efb2d5f55068e0505d2de69af3677214758832d2fa39b945ad9ccade310d0d4f73e66bff9a54528b169d0921fb350a7352e4a7daa51388d326f7ba58a663bcd3a628468fd291416a170ff6dd28b4dd0f0b81d35e40a58554a198ed4baf7c486ef45414f953449d8923a89c27f5757ae36fe4a6e4bea4cd11e4eeb928a6dee2aa7fe3428a5301da330483a0b54de91a384ff08ba9187ce51018a4cc8c3016a22e6640fd87072e7ae028c7b58b3c7536c3088c27e4b286c7ba8d973cbf43cc2a60bbc15d86e03ebe7e9e39ed2216a1c624dc13a237ccdae968d28b4997924989ee0cb58b5cf180d8169f2acc79ac99bf773ccc8aacfe019acad168eb79bdb33dce07352ba70ffebd109af447c06d48fa1d4e339cb1151e55cdb18afa64784666cfcc89fa6d59f4841c0e73d85df08894446179ac3e779ea514986e884d5cf6f2ddfb73850472044130733e3096f4bbf21b8dd8ec9941f81668f8436142fb1271500fbf20f3eed6ad4f6e76872b2515437ff989288540ea0fb684f0a4b93be7b21ef1ef7c04d7407db0d5ca3a47b2282e961e33bd942e0788f9baef2ddf639e6eb98b3af72ec270046066bcaa38bc5ba17ad45e33852149a64b55e81ea28ec860b5e1a2198d07e9d5d169ab6b843383788ccdaaffd6944801ddf7e1ebb21afc2f67c9c454bab1f8397bb182da7e26f89268ddee4a466d447dedb1d4c55ac4219aa061cd7ca51da77581993311b5508604d73ff56427dbb3d0cec0c8529e4fd9e9f6b716de84bbcccd2c03ac36e6b0975aff61dee15217161995ce9c60f416aeae3df12d6a6d964e80c7bc5821b59c0c199bc1e1a33b14635d51e6df08ce244d9ac37804313ea39b8e284a68372b60277fc3d4acddb3dcdd53c9b9877099afe230d060d2c8db0e6de79d350965e8199e7b80e5965a028378ecfc2a3ed880c1052e240a974f5ecb6777c5a4854ccf0a9a4d7a60c6a50c0e25c8756a674d7da97d46814e1ad1945a5ecc71115f29c54154f2077e823339d6ce585b9973807bcdd7e7f448dabdd634bcb8a6a2207d642dd9bc0d547eae4d1b1d0f574e5fa7e1c62e23cc7872d8b305339228e02e592ff44f7e783f459d5507e05baf7005d1caa4087c841d358a64a31c889bba961f75098d6c675ccefb215edeaecc4eb1253b80550d56ec045e2eb9425aa4e098747f1b5ce6a1d0033bcaa375a531d957b59bebfb3df33150295b68d6e11acf7281ab88d923b1e1dcfca4641a038015cdbc1763a135c7ea32f28941b1997b9ba1dbdf2e2cdb644fece2f77052ca3063c072dc6a95b2e3731cd4443c13d77fb8cc46669fa5a9892bc532d100d232b4676be91c4bea277ff1e6756365d641ed76cc781eefa24b1f696afdeb448e8cd8f889e77fe0d881968073a03646a7be8b3c0fe6a17a901165fd48f0e9acd6e2a6e4b82a3eab1384488d8889b6428d195f2a3e9791433e0b9b967c92c053d1fae4bb2be923a055a5d660e8c99a82d0936797aba9814ad19159ee9e1ac083bc28554c6d60a8063a22e5318b4183929502bd901e8b497ca5099a94c7510965bb85a279bdf3c4350941f906fbd68b31fa17d89aaddc400580326ea219b99a187456800b82e2ecd90ce0cd066ab93c9601138bcb0e340036529af372e0fb4b06358f6a596fc52c153c6811d40b54134013911ca5aeb3a3a10604698fa6fc248694232552bf5af017ba7ad6a89b1fefa88bfb9d5c11ad7261f673399cb7bb0ac77aabebb7cc7296cabfdaf814f83083e32cf91ef41e73a008d384f36efe1e459738896afc723f1ff196dc763b08646bbfbdd711f1a5852c346e58de63b0aa505315e528bfc64c83e6539ca66b0d96f1cfa22c7457c5e4a18ef62e340819b23b33fd1a8c73f52df4d7a2b440b78fdeaeda27586ff1c9247d129e6eedd5434e050224479a5c872e6a26c271bbf71478e8e3cf1856064aa9f42edbabd917c4491c33e87dd2d0f7f3098331b03822e1589829fc8506f4cc6888ed673a7fef2ee5e12e8044c38aea61d0c87185ae6412c69b2dcf86102f68e7d407e3d26d5a67f30df343aeaa76563cdc90c9561316d4bc22c2362b44a7313f0d780fb43796e85da957d4067af2e104d2e9562e3ebcb7d22711b84c999ee8120f5a775c5a8447f166462b9fdcaca41d0eaf94dc6abc4beb25a5850660e6f4038ddb1a4e5e4a59d5d51eefdedfd13043b04e1b1c1af39689772b9d3c6f2cb6fb4d9d226203e440f4ea57484d0f2e3022e959adc31e276870d312d69f5b195b4c445b804b9090b77533e772560211f84f07739bd7416af7bfc736fc3be1ab6ba43d2b920dbf309775f27ba13858f4fe3e5087fe7fbaaf174aa6bc52df7736df46e94de02f072f666bfc5011e0b2d870d12ba10651ff68d42820995539dc297852a2becc338b0a031297d65908c8e2ce694640e20cc5595358cae756411329fa280135b5f1699300264c8fc52246008dd81a1dcc43176873596464c6cd09501072a1f990cae31f372f287ffaa1c48a6b2bbefae0f3136748529a859e3b709398acccf7d1cc3d564bfe61b118c411b81f428a1bff5f5fb1f6c4067e87bf6b8347f008fc4dc1e2ac6cbe88b0ab292c26a627dbbc8194313526600d72b4f19be30909c613778c489075ce1b083e9654e8ebe5bd26b742b68c9102ed79d50c2b6505ab123255b23e8d4a62c8b2bbeef88001244dc8f15e1adce80087abe488ce7b271e490b4543ffdc1e680e9ddad129ff788017e5d3028b5db71869bb6b5d69cc06d6e2b4e3fde107a5369d9b58be94e3998edd8d76fb4b77fb9babb961790f8b7c51e1e9eee46b03dece982065ce4b63791dfc182d9dafa9c2d9f1965cc53176818be9389e1d92906bddd2714ee5d244555ac3d46f89fa2e94c23017d7f094a756f1e08d71ea53dba85cd2b9791f4f32232c85230eeb65c311d1e1e1cffb1f3c5c39b8a73bc5bcd0b5ed355aeca5dcae640d644f0ffb509380c9b134e571796892391ff5dbc155d553a5e1915273d8a8cd839e404a131404dc6e70897f12126206a3422c5b2364234c6eb17e7f504370fd6c71974e3f038ddc3b658383e540cedcc7cef5fd90806cc700016642ef84633ec90c60c4526fadb4e1e83525adc072f0a36de93ee8768476ecd7161cd396f140f676654f7ce3458e577a4b0e9aa0f50bcc021a9fbe6ea60d4d67c642d27906c67feb79a8747af04672ece9647819182dac95c123b231f2d58e7905870696102a1e682a0e1e29b337acec9bd5fd9a6de5fc27935db0daed3f2ccf9c06487049df1bb9bd37c8ba0a47f65321c35af913286d52c8cb6791690e1684379a97e4a034a5daf61e51cf33b54c4217c27d1a2f9856d6b04019644e7e6c603f8709680976a97737ed6e16a9b1858bc21ff93b542bcb1fbb44b53cbb7e22fdc55a803ee2f7429583e4dc80e2b758543eab0f43a1bed5f76c0fa6dd9e9b7d656753761819689a10d59206213150bf8fad0e268f4924554a2b3a4958e8faa6ab9bc0a18b5d44646f2fa3e939b84a00b35f86ef3f54ba85ef091a169cbef2a0bfd9377c7860a499141cab8d87c9e668525fad889897fcbb08d7760bae3bd89aaee0a595644248bea01e8dc1177a0e89bf85253d4651337a2c08355454f684396f24f3be25ac1c29ccf928016153d5b2e311b797998ca3d4ed66c16bd63ff6d659363ac1b4e7cc82e87f546a286f66037da035dadf531d05e8791c58a5a3b45fd0b668497b630d948b86def23e69f17377259ecc62ec70732ed91ef5993cefa3d6a8a17e26125fec868ebfb18287fab7de3e0db69c4f239665ffb6856d8e7598c811b238616418b700f6c2249b6269418c7e90371f4a6383d2649f8413e95e82e55c0f8baf73a9ec2f33a3024f1ef4b0f43d2ea27805a309fec5eb5c2c454e66674e4658b7f0eeb47a58eebd2da8f323aae8deb0626b074f0dcd97517332f3590d17a816223f6f3aa1f4ac1dd15e4b15f385b31d7de766286b6d0ec2ac1c79ac5fa29270c12f3a169d8b401cd75714bbae2da284e30b4f5bcb81c1393599a6c53d0a990943f252b637fad4d5e20e99be54efc6d6c0a00d14ca8d17cd05fa3503904cf2a74899ad89dd854f567b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
