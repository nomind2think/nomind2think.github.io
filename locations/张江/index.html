<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b368b4a61582a36939e8ff533bf8fa34879469b28e373f444c24349b0fdf030c0662d594003d0579855789fb14b0b1bc11341320f299bf006e6893a64b9dec57c0df8eba569ed5b96450aa81ad7c03d1a81ac70a3f4299852d66190fc957d0cf67408b87425c7467b31dddbd141fda65c4f8815a2386c711112aedb2255eb8944e7c484cddcbc0eed507488c80de33b9142d7b949a10d4f1ffc9b4c685e424839ef91cc026ad006e095c9f95902c38c7e2d4b5173f5c00d38e0eafa0d705fd555f2e14a10051991c1c9f85845df870fa3e7535bf9b7b7ed610eef15fbe29113d170c78d2648ce13e788efac8bc1907ea48090fe33516ba78618541b0a4db025144859422c53c2d287c8853c3440f892487796cb1e92043a0252190eddb5aec70cc25a790eef44e640fd574c0dbd3d58be67025818d416e9d50857906b133fba46a764070eaf664d3855792e71eca0d1a7fa75dc6a0733c10a3a7f64caee6ae61d14f16b117a8e3018049fa4c609de4a5550425625074a5911afe62200d9479f391e65bf09e8779f5d8a564f3d14b9243b6c7bb1f982c2d8a8017a8c88a59c4fdb2ff9f2d15d4f0df31e83179b09bc41f729719fbbe61c728b6d48710f8e3a3a863370dae3da1a77ba7b3f9612bfe4ed3e8c5cf91c31541f4c6a4681a5e79c9329303c864228cb393bae75799591086e122eee7c9b7774b509d443a846a192f77731e151e4b60d91e9fd71d34aca3c64ed4cc2ee5739793479ed3b6832ff906bea59b37990878050cc86e8fba4898162f1878ec71a2018d60a1cb889f9f63caba7ec31937e4228f3567ae7abcbe0df8ebba91ba3c93f328d7d702037e3e3546b15d986a7d0b60e041f887d77e8636e273fa06f6bbe7dbf0ad5026e2ccd2cff19f2b20296790146575e99c7576bd32c7a11f55a8ba037d8ef42fbfb80aa9c52e4af8292a77b7b77f3cf4d1757d2d27a8f932bd311c1b305eff92a6897b70ecd2571de6ef0c796d75107ee3ae543d5dc05920e3d08df4cc61d1fd39fa0d4976dae89e0d2b7280860992ad9f55d16ec9f7dbd9e90f468ae844223e90ba807ad91e62cf5937673d442ce1bee1dbb5278836cb950008b46a9f64ffa717aa01c8dc744304acfcfd03be97693a6a1456a6330453e30f3d483bda843a3ce87f4a94c88eb16fda14eb277b033b63e9203b1bcb77211d0966b44c8736da6b6603836396d4383f827da9e795a5d81f2b22294eed03741a75a239e28a79a625b7084f45d20a5868c1bf0acd6cd8cb17f0c960f07518df251d4653d7d1557fa731024cd52f60abf87b0c9269bdbf18d460802c8c2f655c1b8f239c6d1d20477c40b146288892dfa29b4434f6bd7093ab904cdc241f69c7b0cdff5e6d2e34a2505a9eed7940e5f62ee385f73c51e4620736fa7c76d12b30fcdd58d0cf816cd759188fb665a616ecedf32f45c5201e8fc3383ecf568ab672d0169d32f278c9c136ace27f0bde600d40ceabcf573b76d94dd6227d852d740e2dec505a0b73ec408accc3915784b6bd3f12caff2e8783d16f5bc05a7c33f38f002f80ac0fc2d7119accfbe7939d45cb79d3b1555217dee479394354e5f18dbb7471670625adabc15f516c47e5df48273abf52a6cad602fec763ef5c7c566a4fb96810816b1f2714281644c14b75356982465a61635f9efa5f22dc7accbb0a32e64491af6935bd2196f4112ab49e9515692eb3e4c78280872589bb4a318005c656e386b13ca57bc1e4e8a2bdcb3957ebcd52d16f0d86beb50782bc6d50b5771c0cd594c9d07e8e77c42ae9ebfdb497a25ea4773befd734316eff5e240a1bb71755bbb418a427fe203ccd8cc954dceea08707b88bf5a5d88ab5c67c0911abab0bbfc32a034077c841ca2962f118c328fd8955b1239e9a416a7c059e9bd30d05f6bd6fdd12cbd4024026534c05878d51c76b3029b8ab452e6a0fedab60e82f327f25d2edbbcf91ee50af2f6f1fb030126ccbf41c7581ef4baed5c9269344215b494aaf1dd1604bbfc290a283736e2e2e65bc551f1cbb96b6eace603e092b49b18b916eaac020a594f5551ad6a172088e6a22e3a557fa5c7ddf5b5db9c8a9fb11e1f8856f927bc8fb16ee03e2a8ea1eb94e3db9ab1f12c2d959be33f03e5633b13ffa0e6edd2cc101ff83a898f857e4642753206577907201b031bad6144134e3c1822a667acf4e6f065432384c9ac6664b966eecc7552da3219634ce93b12dd9643987ad859d1427c726dea99e345d5091c5e476f3d9e9ab2c5580a93d170d0d355f771b95bf4276c24c178b1fd62df68d4ae41918c247806d5933c8f66b4bf6ce17470e989982e7f424d00520e4a2d5a328f07c42a7b9cabd55a5558266fc50129b178c075958be3d39a3043c7377ad241eec90549304bb0e8561832b6cdd5053b9eebd507758c7bf1393d6645f76f4f12be6377d7150fe8f918fa8d929f1b2d6ac3738e21861e5d3e57dfb6ac93decaea7ee441fc27a0028813c9a3dc91be313dbe9df9ed706bbd45148a148bb5f04e7220b60b7ab7a0cb25444278b73ee2b6d476920c51e4cf6c182766a9270aadeb7bb7ad44080f3139ea83bedca9ef3ce75f95796987a2bb49b14d26edc5648fd0072c96d58e90739c6c2a7e3134f2aa663e74e69285684fb60347b454c6cb8d7ca197c1013dd6cf67b94dd6fa7f974f5bfd3508300048b765cb93e0a0223478b5981b09bf1c0598325d6792a5cd6d59058dd81def33243260a1bcb22abc32af75e3339671177cfd1cc2ae43813b1c8eb4d439371d7468bb8a214b5eecbb020abef25a0e6100e084107f92fdac3e02ab1bb9b0b7f36702cbd4f1bae4b6ded0d603fc044dfa26b485e53c69a0ac81efcdef21bcf9bfeb0ac0bcf0a9b1b8052eb9101fa72d57280b3f7f49e1f181fa086042abf479f41c192480cdbd6f81b25893d3597dc453876db845052586f18e67a173fd9038c409dfa579fe1a2900a19e09e9d65919deb80deddab5f16789663d6190a9be432cfc7c9682f6211cca7e57ef14cd3afff25b10b34829787ea0bd844cb8b3901b1e854dbd329d94c1609cd9c6b1d9d829db27b92da8ca67c794d55625cff418512ae7e99e850c3cd667ba65ec7835025411da16fae45c67da956cb578f387c02e4d01d6c71aa0c8dca188db8df77c8da45e36b17dfb2799aed85c8005d1661b6e0ef756db5a97f4f3c159896f43b73c03d1f30993dc8cc0581713bcd42b917e2f91484ee21f9c947aba34df0472cd8754fd5a9eca559f3aa13cf04b77e7b67b375849a47d5fff9dd1fad604f9b6e3c453d700e45ad5cac9d8732c9a7e342007bbac1899d92005283853b7cd2ec46a4c8afadd6b91c9fe8e0571193f3c3ff3ea559d278a0fa5466a2026e5e5bc6696126a8af31100fc58401943205b904f0ddb1d4bba7016167959f92ab016659448543b296ed51db875a978bccf5090dbcc48d4df999e5ef805bf25773a72c1b862a8f749861b40e70c42c60f9065e48dae7a9c23324002d4a9fc83bf67982f195aef6b97e28f826d0001e959218398f2a9a35bf9f4e1852a3debafd0fe1300998fbdabb7a944ad09de602ad5c4ee035c657714efd34fb0977dd8caa28a758f465e2b09a98be939e4dd154d4a6571d3078c23173496bf4f8376550adefdf07f231c6cbe169703d87d154f7192669f634699bb0cc5aee2b424123cf882edbcbc2d5a389e0b0bb12696d6c2799b702b95bb138c975ee648e8dea60ae205be1ab13dc7c41ef2c4ae106a321380a7288b1616870318e95ecf3ebfda5f25973a3c253c7b3697521ae5c0ec195f3d4ef1c16226be9b97f5f51cba81630ed7dc8f2d36a7576539cc15455ffc383f32ecae7423b8c9e246e0e8007b09dde4b3c836577ca0e7a811a2f9337d7f41c2f056ac90166a602c70aae84d6dd76d5d3e058ba7596c1b310af78cb5b64bed96e1d11474665afed68c1666943581d7a45aa3150f217ed88ecf4037430158bcfd34a66e43caa352d60064020e34ffcfe24b18bf4aa48046dea37f61d3b073d7150eef20cf22721c17cac243ffbc5bb05756f79a71f8410e0f5fdbad27fbc55d23a0aaff3205801dd5979f3bd8dd4940985890afcc0cfb1f081d7d37450f8dea62a8ccbf70170d5b525715375ef75e04659c0d1f87d853dda89de47cd774aae3892ecb902dd0ed81ec9a7335a528fea38c51a0cc79572536103a2590d458008843ae6a9800732119fe11d01e7316d6504033a48ffa7c46ba95226d88d30a7e50e7b9322d29905d8d5ca14f623db9901c750aeed1cc9c66c308e72212ff09f39aed1b04d27cb3a831cfef8a32a061d6c184ec82c0bc85e845999ed189a10bebcb2953999d3a29d1ba1afc810f3aa8f1ea66883175056d539aad1a1b8a36739a90e6e8bf493f5dbd651a88cfadb9c3492e16de1ae16c320b557eac5b76c0040a2734f92d1c67e6eba01feec8fbcfa778ca7726beecacc71c21807d02975b7994d3c25db86bf94f1aaf70c061bd450cafc2c7c5297894de49c9a220c99361f1f828f40f7747320a1185c22a8750f4acd55e8a34abfc887a9ee8c53c1c771089e8e54cc2ef48276bae65024e2bc269824d79f961589d66cb4b233cc30d2f50397ca5129a292ab5568aa7f676255de416aca37b9c0941caf95ed962b94af8d0932d511e8ed16c31d217952999148053ebcd2d915279627fb0a9fda64cb41b64a251526b6bd51beb9df3e0d909fe23fa4c39fe2f54b120cb33c4ddc53318b94f09d022c0d5da40f98016e62f905bae60b5319ffd9ec000206ce903e1b3396ee4600656e1baf98fe0d785d1846067eda88aaa4ae457c72b91f07cc31d05e84cded3bf6f8254381dd7e40ac639fdd69a52a2d5fabbc2c7a7ebaae93f69cb36e2eab17f4fdf1b659062fba481c99e2138f943dcd8f9ad27d2e5bcbfd9903a742003d48ef8b43cf7c33490c3034695c7f63ab170ae531931ac15afcf1ff20a3ab35cee8c10e91aed63a6b6b780355bc76469cc2c84741164dea8647625f8f1f17f374e3413ed609501f0bb40dd1199d1e9c79e34e237d83494541a8fdf76a994cf824d30747608c06bdbc2a4a74212724fb4e0072af4c927f637184ae85f8a4b27e13655c310e7047814c0ce94c982342f8f723ad0b81ddcc32ea055127167eee612a3862e5413e97aa43d76b84a8c6719b071b1bc944f85f13d7e04d0bb0106b0b8d39bc509c916807f15e3b4a70b1b2e3718f6183ae50248db560d2283238ea57e481e0acf0225e8180e956d0e4b9eb372f3633062cc0e23b3c495e8b965c3d3f839cb939998da063eea13ca939109173eaaaa73f545f9fa4670a1ec5805042adb2bd56fe0631d0b9c3bb528e50891bf0d5ae2e79eb51fba543bf6a16252b0c6e0cb2deab1e81553c049027ea929bf33afb8c270bad31e98034eeaf05a0849820636b23cc2f2ac3588456ac02460f2d9a1a047109ab00126f0baea30fb90949cfa19b16a3441e510d5a7bf5ad83aa2c24786b5f1d6d60acc72919804de4758c12fed461dbb80cbb049956500df160286a52c3cd75abcd35363c56ac178d27dea531c24287315184a930736940f77ad8ea4e466323bcb8c6c66a2927a93c39f9522a1db999335c1e814b308c14fa92cf0be9ab9ba754abd4a581c2ea7fb6c6c757087bd7b2fd84a53c6d504eed5b4771b191fd2fb557f92f063af6b55bcccc74e199cae776b28db442b7e8b5897a399dbdfcc3bb2f4574540725f87f2b196aa80003cb940f87d785da50a42fdadba420c9d9b2054b186fea306efa9d996573d2254868de5ef5b2d47e4a095d7e14e480303975a52c489cbd409e90d728f241a09a67a9dc7292be06e01f6ffd5622b7fb8db0f09828167a068aff7c02274d0aa3212a22a75f0a687ef99834ab7699662670b862c733df25394984ab411e9f47df370668fd64087df172c30cf0c8d02d481b62c32b240685e0712d5c9368ac568f5ea8a2350a505d8cc007c22c662a9c1d8ee9ef865c2ce62694a9cb710d5c61853f685933216b18b8a741da4f0674cd103b9dfb632bf3edbba362c2372ff4315c9c64bf1c5e0ca8ea071a34ba30a8c6030a45728e13d72f46b19cc72bfc3420e632895ada3e86d4161c4765229a6d58ed725c267b86cae1af8edc6a924a0d97f8408a3f7e7f697367eb931203edaa870c1331ba156d7bbd8b08f7da90779c57d1af41db92e44304a1ad1454efe19558b6f9fa7aa4285551527eee90852462e132041b0a36d552fe1b601040b5988ab094853dfbbe9a500832da43e6bd20c3a29d37dcb5f7f1a8d3cbcc57051cf73cdd88014082f201c242c9b652ed98c71bc0f7ec5df4dbfc36102ac32e4c03ce3dfa1d3a36ae0102d9b82c94ed7bd9f657d19b637500343a7b7487d1bdf9728bbea3b3b4fe1204cb6f1efc77a72b62056274abc4d067b64b70a7b990d6b177895ff77611f56273b5967266bc3c593d49d9c68673bebc5daaddd7e621ab4233ed97ead3f96688df6b30009adfa456d2d26a836f2dd49af8ab6e60722298b504af655c5ad24ab12373926098bf88718b6d4fe219d05bf74587996b60eaf114c7f2155bb9547c4a54ea5b1c799f37214f606482f81857a4dc006d649d1eb68974bec537435a5be90840953939194f065a3d77127133df3988419f76da2eae1192d71211d043ea0a9d52c5867bd66bb731e08b79f522e63175df316e199f15475aba051feae1618e74d1165482f0c3b906c11876ae263a3f8972f8e21f5bb36350638169e6001088df734fca8fa3b97f2af4c2abb999996430c782b78df790f987de7f7a680d3baca3892281bdc031646b498ebef7f2e0e5b57b560e81d7ad6816d8533a223cb5409c58e19bde30f4d381eb75dfea3a84aabcb5271e99ca6343555ef73bd1d058ebc2ed3daa8554f7985b45701437e10603438af47a1fe8cd13e3edeece8eebae41c33ab0d1a6fcc2fc41705c1442b2f355aa0438aa26509525d0857631625d00941cf9ed7f1ca5d29dfce66f5c66b9196e1edc7ad3802713467ce98567a6dcc3216559c4fcaa41cdba5805422ec76c6dcdf03364aa9ff2b3f892ef39784bec897a46a72e16f92b9fe80d4e98bb8795faad18af1005a2e5afafbc94dadb0c39df88e360c8ce0a69bff6d10a92acf0ab455b3c0846d531b0890d1a465bb29ad8d42fd1aa9bf7a09210dc9562bcc48c9b005853ae7076413cdc3ccba393ac9ef53068d9e82cfa03841ef9eb90bd37eecab3e08050206347c341d61fc532ddb4bfabdb5b56d46d9a2be6819c45f4a97770e5bfb2d9f7cb0bab21bfa0f8fff887c05a84f175b2a98dae3313946a322962dc0ccf0eeb7e40ba8fc8ed35f29d9472b9a8b8c9ee101bb35f2e6b2b9aba180aff68a7480e6175997e3a067d92bbb8a5eb56e56a5222324eb2c71f75ee4d364628113b88bcff7a6ce26c55433c9216c6df241ab369ed25c3808d385776d2bd23c4095e79ef8fdd59eabe24065b07c206fead6657965da0562556b7accc03cb3404f386d61c2411200130798fc388cfafcba993e541a5e548d93e0eab91bc5c091cf9e13f1eece4533b9a0b9d89254cabaa7d1ba59b0145a8a0831a9297b0fe78b98a9d08c6723fbe946ea853f974885812f6ed810ad2b0d1bbdcf77f84e6fe04a693d1957b00a2bdc3549fa66e0167afe50f9d8c47f5523173cbf8f456f3e2ada7abaa32481bdcaf3d4b769842cad23d6c12fb55f0530d507e61741e2802cccfca1603c1d215fd4c39e4210752dc7862fb8347b4d7b42847f9b4620ed22166505a7687d830b0a6b0f1a81a0d02afe02c9cbeacd7fb471ed25630bcd8281a471193dc9a4e75a709bb472b67ed0d4b660af66004214efb9caf4952a85e42f5cb1076bcb8528296d3afa54b9918a30a2324c49099d8366142c32bb396b72957660f7ac64e9208e80ba0f6d6bcf03d9e14bbaa2c91d9926d467bcfbe9f4c000420319c9951cb2780a3f8f824e01d65209db4ecda71e50d7f16f47a1ae691e990d02b10b3f4a8f7d30660ddaab4ed433fd559c7373d3be16c6cfc2321a18b1fa3a512160a546d6e32a3403a406d896511f0266c0bcd0a45bb3f87b3f077e72aff081aa930cd93e7347c3bc185c5b89d13e5f21f1c2f8db76c89a31d220257828f232cb2777db428a1e92691b9c5cb4f483a5c16526ed0ba5caa3d9c9b44191c4df5300100a730dff7dc81bdb396c463867a278e8783ba92dad88ca1102da8ec00eab3c6de3b0c7d4738453dffa4daf40adf3b8d3fa61bd1f8fef6276f45b3855510d7b50ac3f964453ec60a520e8fd87301c74829834bd4247c1665b4cd3dc2051014d7ecbfe02ab5285d7aac6f1919332b0a996fee80553ab6a8f8509eaca4c3b8865c3a595f708f975986699d79ff349f19c2c03710b574c26dbea49864e26b23e4febc0aab9294b5938e3a3ed37cecf7416950982b1f3e8f4a3639f819f976e87f6b9683a55c360ae3022112f04ad754333417aa0194f4ada29724ecadb5aa03408ebb2e1acf040f5ae60cee54f416889f17c84b0d57eb494c8b34ae280133213739b420be86f4d993c1d9c0c2c4bd2ad130f6de5ae4a7cb45d38de077904ae7f4fc6a3d5c4ac7e7a0218320371cb43e6f61bec1f4ff7451a1736c4336c8b7a1b0745fee21f4bad7a831fb685446e8ef59c6f6613038b4377baa224796cb85e57dfd39026f72afad6301debe8dc72365442df62360e6372d6bf1f57e56e92dffb622c77def6ecb85fdc4cf5b17fee3fc66d8a4d06eb144459487283e1b4d5166ae6cb0f8a114f591c617510c97ef376ec353843c4c51cf73ca613da191724fe6935335925dee33c12fc7192d1a4bf963e47d477cd2838df4ccb6ce5b5bb4423bd0a246f572cfb4d028da508d647e86ec1533e571c940852dda192363e6ad00736b56a8f36ef20ddd7dcf00c735dffe7698f1a0a72a104ba7e529ce916d32a3abab580db267f07cddf87859b9f43fdbb4c89375fe4227130060f68302ba311636859d4166155be8a75f30095239d54ac09a03fd840c05a19bc782fe816b099ae2724554b7b7acdcaebdf2d5123a5de4b7c17f109722feb7b143240b768e2931cc3161e3e78ad85b34ea368b1a23001a258ca26e77580a2db483edee72d448ab410e992b17793238e6cae07c77b18d844c569b6cf418ee4c76fa638842d47a1e5abf0fa7d3951ee728f1f5eae080a85deb54658d1ef1b38103a00bb58b5bbbc18172d0075dcd789527581da22c73d31915ee385e3ff61f4531f2e7470946be55f487e1e7737bb3718ff56d3e12e60c9ea4fd6ccd3cd4bec98229abe224fd097686c24196ae6a224edb27b538811ad2bbb60e4a3d0f2bb7857f4370e11884a044cf6591910ce9ee19d68ba48f6ff5c31a602635052e53611f79201f8c1bb9dc1116b052148618f45abd2593b95b97398bc3d34d1c8ed71b2bd084de7054152d6b1dac40196ce621c82b2a2508a32abffcefc25ed0135dfa2fc008848da3d2ff96cd4b2ba73ccf98781535e379b921436a7016c6bbe32d9987418afb79a7a69278a56d0cbc9a9867b8031d65f91e0bd537890db9188db83f4c34066781b2cdb513cca9ec30541f1f5ce9012fee3cefaaa8986302a21edad292571925a317b11c1c9cf06a9e606fcb3d14faeb22e323b1af06bc010ba6416dc166c7aa9cba2a7da60ac3a3430623c56e6848e2d76d0d1f5051a9cf4dc3e007dcae073b3069e4213975758e0dd6f53fce36d59d7bb9eb5ac5656255c27cbc8d3de9b5306ca7142c7dc7ccc830a824d9e7e63b5306167683e7bdd2aa91f4d223d87adf84ed14abb4089b6249582e808393a31836abafd0581a2092833ba46a99db886adde86e17a6b06b0ca207ae8869e36a9c6f0c9944a54a6a70bf031cc0e3c8a979bc9fc6151e8a780e98ff19638b8923d653bfc15a0e87b968ab09baedfc24edaf3692b9e36d59bc6b88d2031d982ec6466a864570590b8131da52a2be9f3316f98de954722b6367cffc88dbd6e49397616cb4e93e4fa294551897a9ab54bae3a545d2cd3f138965456df102dd9e096e0cb1e988730cb443bfb38e51114b26ffc30571803d4d6e2f25ac329751f3337f2dfa4c92da1782105706074bb932e516036f8d67fadb8de43b9309f84ff76568a691d59e6f11c5a58379f125ae4a9b160b1416837a0785ffbaa1a5afea0f99a4e04bcf871c9005c2714c60a1882f4ad6e2a3c33d9ff35398649a1953ca43367ccec0f988d1c758e31fb20b59de69942af6d4f7e8c53c2a2e5a6c2bda9c6ed83c92f041514e1f1ef8cd8240199376f567f8aa1b91f12be4ce80fad2dbcf5766647d9d73698ee659ede31f8cbdc056865adec213de5f5efc71a7c62f6b08a40417ece51f2662b70029e6901fcf223388a6850799f9332d6f4127c7c2f5d812b767c51ea6e26335a863b3d1f7207f3d445d6ebb604f87bb6eea8de8e10aa52db1b98ede8ac8e7479b1d47a6234a95d20146e96a4c79ea04a749613ecaded8fc4ab756103deec8d8d4f2aa53dbd0421987fcf7cd1e3259b52bdb5c39f59e149292119fb061f3c3b73d6d1d57fae83c6ded77ecbcff7e4721d704c3c84048da730df4e99ce880f84544144b2ebdb1f5ce6289290e34701fea72fdf81f67fae8cc2310065b545272d7ddf5f2e1c8c1b4f026f8975af6336fc16be684fac7dee0d7c8b09027395127","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
