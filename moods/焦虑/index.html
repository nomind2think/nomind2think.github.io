<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef99ddb2d465df626f182f1b65c36feef77b9753ace9f2c92a3bb0d8880b3813f95b9f5402983f4d509e62bcc80b00afc914703b768e79fb39da343987cc217f47ed150e409e386da3f236bc9450118c27c82da431bdc34e889983b865be666f22c35cc5c86a9140aef04db152cd648ae2c6a4b45b8923a56b0e45c89e17e91e1227ee6ea6eecbb54fe51193502b92da11156b4b69406e0d2142cb65a713220bca64777bf30f0d2556b845dbd4c15f16fb51444273d7eaa882e9c1b2786cb3f8e310760aaeb567204cfe28d06b2a65b11fcc362bca6949abda42a69731a23c100075e3c6eec5cc05d578e8155a8d8f3457d4302a86305c3fc0f8e07287b0d06f2502912b8893476bf65c9d7a949f6d2675abeda275db57c4b932a998d34a7cc5b95b6a4357eac07b1847d280063734a7d783f2314bff50a969c433884072bc287cfc09053b333422e986cd2819d10d29de65c704775d4ca64707d81846932baadea72ad70a3ddd60e257f90541a309d2cbb9261023a02ac1d8056d6cc7fdc702e5d6683b4e163e0439c147e0024d07a93ce6e203f63ebb99638753412ad82249534841933235c9a23102f2bc0b045ce65279657131e49f646984f50e26249a4c0aba8002de2f8c4782eab22def8b28fb768657b87f8872fb810a29127545852090e570549f0a841477d399c2fecb9ca060ad67f157b5b9a00f6790634ff954f0c16a0ca5614237b7660be3da9159eedf13cf56b64d51bd8cd215fd0cef3406b53d7c1724fbb9f0a7fc56dcc4ed59af6affcb55e13d0ea249d785d5cac2ffe2b4f3abe823e00b9d7a1441e69b5572651310d21f55aef025841bbe9873cbe8e13eea9d0acccc44ce536540a537f4fa4ccf681133c25dc2011c7debd40226556276bcf079df15058a0f8131bd06b4363301161815a188acadc10d3bb191a82a9618a0babbc008f4295ad7f3cbe9b0d0caa9bdf0f61bc220339742747bac6bf1b69f51256781e376d34d14de0cb676569529d393941cfb3f668145a075b4b73013012d45a6bea5067cc2f4d11c9a4be866e32d96a80b74ef4673e7fedb227622ac0458067dbe3bde1120f2e591a571917142f17257d057b27d06cf87410469118a83e485e19c7f24da6f5c5d246cad242526ad7c25ffbce1061363ab0e664032ccc2c0bfdf8e1a5131736f1703ab3e342f4d095e68e1cadfe4b419487aee40233ee8a4a5e8c1964e97d266624b4d3fec41d71c7639aaf631d2270caa0aa9117bfc92a48b59a48a5c53e701c2db89df21fe52dc1bfcc7bb71e647bb7bd31a08786c32e1b0213fff7f3b22b0f6bc5360a949e030e1f1394020e2671344039619fc01b18a3d2f31675ab57f19a922ddee9981ba3e11c384cff8a1b828ee26a1b74d785abad3bffe0519f6af155b38cef11cae117c657512a9d744e49ffa654efef2e7340ca4a4d650e2f8f2cd360a4665fd1b827086a22751c4846560194c3067acec341b9f5ea2e321b479380ab5ace232e0b4f8b72c2c728b2f2da8e37bd69b0f8e047a55d6e78bef1f0adee16eda81022eaaba2236fc7b3930264c41933c4054f4dfa70bbaeb17e8a1450d59b739b3ddb313c32ebfdde8a1fbba7f5901136dfb62d8d88decae217ff18cf20aaf25539b080caf96c03e97f65ae710b827cf20cf1e070bce169e1177ca0955a5af850098cf72361bf96908abb62de27b905557f88dab5241fb572451751ec50cd75ad611d6780040498c9b9409fbf94db41f0bca9f6b18b5990f645f15184a2525155f631b738cd30904b89470aeeb168a6eabbc0301a9883ee70bdb4de6ce69fd62f64750faff6384b126d61d51a116b4d105e582361948a659479a2b67d585379fc9435eecc3a965ec6a6e268e2ec5336262a31860e68476665348b7de96f8eb1b8f51ff000eea830c8216bfceb07cc2f0bf6c0cf5e02d6e3e5cfd1b7a23020be0593ea067621e58bb555924978605b09d9f8426dfc853b753330a794d0f431d8c38564e3c041228046db546b866b0c9ad06de222b674a490f0b4ade670f56b72b639e9353d7f56f8e6bf3cc35268c8d6075134eafa8f3044edd0b3d89a32aa7c1e7f05e42eaf3271e4b027c9ede70dcf9402927ff52140fb73ed11c64aefb394f31306df7a11f5e2008b000947c91159cab67299a029ce46c7404041841a4646b9c1e1c083ea42614e5375a3a3202d6ad9652218815d035d07b7c24fbd1fcb4f10bd225424323ee0e785ae495164c2a735e23639e190b1751aa337cd20da666b4a0e078160f19f5cc2d4bd66c5c1adada8be54046cae95d145bff8ad720c625012a5b29acf704795686ded94ac4204aaa6d938a24be305b6e201cee18819807c5723e2eff3083e5ef725458d699977d3db32974c9b4e7d681dde3deab42ffb1f10120e0d43e7b550ae2a2b53fa60ee53d45430011ea72f0500a29a06739320af760500c0e31567f9c0f92ab2b4bdb4db3d34eef3a6efae3f47526086558e47ff5986bf2929e18443d135bab067e7018cfb013a83b01b00cc1bd62a48fe42e667d29cf8ed85d1277104f1466d03081324956f0c6d980474b0a064672a8a377322318726adb516fadb2ed6d372eda13b239aa76a2e0282203ca8fa1928955c0b32d9d65fdfcdb9c71977458b0fa4ab59435fbc217586a4fefcb73ba20248a19760413e6c08dc6ca2c945a5f9763041e3ee9d7219833b26fc240339479f6273aea818fecd9ca9c2fdf0c8f29d192f7f1825721fda4c4ef533e1ee2bed106f1e6edf8db1c95abbfdf4917f2a8d58bd6bc6c4cf59535b7b31f59743e7505b94275cb96272f73ea580b654d4f3d54c4dd5583129c260df04628c078f9e12556b33f7aa6ce80711a0d71a9c9f9fd44fc1e6dbec3d979b09568c1ee11fc78d1c49dbefcd379a9987b271dc69f5e03d98232ace10172767dc053d5be0e7df5601aa4e2b4cd0bd534468c9faf4fbecdeafae25277bab291b30ce053a1a136bc31c527edd86ec230e8448baff0f1c375e9b631f8c6d88fe5edfd24743c195c49c17b155f6d71f5679449433f928a84163a34f536317186180085ee61d3df4e649024596891a5f7e0fabb1c8c21184277c0f99209d5c94a13b813e8608fca5b71ba496de632b9a12f780da5de5ed1665d37c802b6ae99f6e9f8f6460951368943a74b3881a52efeb377acc243c019094884111b3b6de962d188e0c3070e0a2394da8e08dd3a1c4e4c8a7ff04dde102ff6fc00c9a159c980476d93a0c9495415a662f588a05e7badacd8442c4ad1cc948148a6d76b85263e7ffaa719c075694937b4a27c48b24e0146eeb96c79de5b394152c65a78f5269b2366a2a8252e5be36c068fe580d611e19deaec6ed5cec7ac467e16d6660671a10600fc0eb2fb73023211528048832ad434d2329980c38e2225b90ab510aa1745f14ec715739e3cfcf5f71cf8fc5d8d915a57dda0980ef289fd9b8009797add4633147aedd50ebadb9c06a2a2f0249017447e59bd089649f0c67ff40882d25d3f1ef9cef70070883fdac120a8fc3c2f815149c75765a5b7c93ab9624b1efb962eb91c3744bc0b65a1459299b039f04eba83539989ab23d0b2b9a285f870b8b7d945800523d840f5a0bb8da0804a8536113a7a32fe3bafed6c02cf2da0c8219efd4551f8fa95d4641e6354476cdb4fdf9a142805589d186bd41886795538f02b193b6bdc178af09953979ca6e427158013acd31062bce2a858033cf588635880624d4169ce7e66f31efb26dbbc7580f2e3e244d0054e53d97025e621e3ab281cfb508398cfec44245723756bca2861ed32d6680c582e0f984a797186e8b4b0a9aa9949afb079950b1b75e50a7afef4165d054ed7a604f54b4a63fb6ca2ea77cf129819ab6d352e6c84d2acbbd55182ae440f6ec314d874d81947a3e6b2e2a24da71881760511684e4e0008c1ef299839688510d913e6b91f7a86d9ead1218e36b35258b307e85d2daa95c77eee866fbc226f5c2166e7bfb5420e6d71615f4876a50ead5e410b9cac1a710a9050197702a665bb191b031597fe28e9b190d1fbb0321693185d292349df9e18dea56582616587485771882d95c275dd203e552fcb81e93d1de87e25153b06cc2938ef3bf27e660b75780b739716557a63b4320bf8796460986fdf5483c65fcce5e135d97d8736dea884de85488e8f8aedecd6def4ff7903357b414d2f2011ecc9098f3706b11ed34bea597ef68e01430ed197b93f0254eaa585c4e42a8b323f9c9d9d22f9fb1ba9343149fe30cf1ade0bb1ef3fff4198a7dd9a3bc3589d4526268947e87b7645b2a1a0f0e4e20b2deaa990ae8f29eef8a5da49df6ef88aa50f0ec4e3d404e03615fc8e96ec2d9079963d21fe69ec84755ab9da83b91d29495b8cee2d0fea3097a9758f4b28ed10a52b917c6d2d3dba28ab4dc3ea02b4be6c254040059e53ad0d8ad552f8bb3f334a15f849417e276de48a9da5130b098dceb2dc89f29f3c812f8c7202816918cd94181bb562bdfb6ed97af0b8b99e08c64c46e6ae4284163bc69fc43fde2806fa0486090c365a1c563c6201939c2835777fc6a9fed749af99df8c937910c95d147c1e05d6ee985a828e2aab787acaba12f47c892890105a458fd417476fcdcefe06ca61e87c2343d15045bf1b2382fee15b125abb9c11b7d77f498347753f1317265c90216dd09858631aba1f0c6fef543730c4298d660e618531cfb8a7296f977d706e26a6aeecc00bb0b64aa4aaeb747a9a180979711ebb15be6ea877d9835d805abc95b3cade7238b999bfb323abae4ca81b245904240296cfc961c08c068563657a3bcb2f95909189d944ca2fc3340ba5ca82a6e412d1c6b16980dac1cb1cff7c082684e7b1a142fbbd5cd07ec46a376cf47bde0ef00c2c240085aae0f81b298b16592116ff7d6261f1ad8c576f04210927bcdbc07ced5a1d8c7e253f4046c5c3bde932b0bbdc5a9ae8c82c7018ee7d428e0e5a787b75c175cd16c31eefb3827f7bb0bdb74a9b57c50ddd032b55b84d3359cbb5c2814f9c1f9b15706ab5fd386cd5129980dda95ce70e160d07a3517b3b4c830c560bc74f3ae61b165ccca065dce2f5c8752862b305ba17970840af57c07da81c4e20a8bea66aa04178d3d729feb3d6e6b751af082306da62a31f8eb43d642bd59f0780d1b1fcfea0ccbaeb2373a041aace7a1cd6889b421da36a21d70ecf5e54b0a99c7a5c676b71a489d7e580ed757dd300dada0806e8f3d9cec63a5ca9e9fc5c68108b78dcd19898be3caae123632156cc0c5e289902c192679318192dde0e30b4f7f032a14d801d4fec7590f69ac9d7a8f4235672cb0961df52b5bf104b3f6feafa1c8f7b0a2fdf57149120abd99fd12137b57433f7b44ee3fa4b47b8aaa4f59ef26e97df21a351c5a43273957b870982c2614607f1c319d48f2b367fb73a5547d910c9d6a25b3e010415f505f38fdfc415885f57ec9ebe24abcbaeae845f49a43ce43817a44b83a3f1666f5b2741f623056aef7e9dd4eeb0af3b8e4a32bf7f9b18056966d2ee6d3b7f1319df1826c7475d647d899b88957b1dad63d88d6094d64ffdd49a4cb1aa35681a52b6795e262fc25767ed4c5a462c77eefdceeecf669467b9322745bd0511deaf3966d2f01499ba1126fdb67cc5ad33cd258bedf81a98e2356ff87db1ba9a5252e87ba46d325629a41ac26d4fa65ddd8cf67bed306560c7b3af129fa669c26e0b38ee243086cfb84df921aee5f2177f7be250339b62edf0092b09f4f5e4e2db423583c3d96403625ff3c98067a31b58751a8fe5a79088683119106bb0acaa7f9c275730525b2840037e2634de88c4234411ea7fc9ee3763fdc77f85df4fefc5a18a66dd5f64df47d1a9c5a24ed576cfb1ed919b5b6729492680043fbcb915b0140fddec4747c9fa43f09d31ec225e2ea88021762a59df6962c35bae909c8b43489ed310f13e796d7e76ad6896be793750437b9201f158f31347bf43af4276c540105447b0a9f2846b4dfead2801bfc26aa92ff49d2d8ce7b12dc475493e6e4d4536e3f29eb9bccccc9ed094e7876ae7756f9a6dc34004aac03d70193a9491f95a9fd808a3d17494775b243a35f99ecf2fc614189ef98c31a7fc3e59eea357d9932c976b35464d70a3db2ab38be9ccc4a1b3f86b8180cd337dead9d1a5360a123b99e684a208c5d40abe7cd70e9b31bf7f3269a9b47aa4f7c3cd03bfd3effceefa89938859f32c729639dd5625e0dce188dfef47327b191afbf130aab59ac9a2aac1240d5cda62dfa4c3db2f009517a5819aca04fad1c0d2beec0df05d5fff593ea1be0160e7345454a018473601cb76cca02ed3a7e880d14760d59456b2a9dbef2f1e212d3afe4216cc4cec82319266deaed0379e0ea507fa2426b7ece79de1294a11dc51a755c61fa8c678e1fefc4dae343d4ae67e35b3d62882da643f13ceb8695dee09e590bc6530e18cff1a6573c406f3b08f9e31a00e36582a508296eb6591eeed795d1823e5eb6aebdb33ff6923ecd06a7e3c90db63af4c94aad700344ed5845b6e884e2a53aa20072bfb38d8744f3e66a4630a344b2a2f66bd179b8ded21df63819d53f7eb86a991b3fe384c53e11eed6d6f47e352489830f8c92a0651e3a73624cebf374040915757e25d45e41ff396b56692134db48fba2888abe28e611eb2cec0896540eb8d20d2490570379df4df746b29328ebe706433207925de75dd89d95441058c732212aae2af904bb2187f7254006d759780346f546f67f88eb52e03fc946ecb23e7050e681cc58c5846e44f4172f9672e7d49e1aaabb6a848b09cd5e974f6243ec630fe7ee570a30dafc8e3be8163fa385af9dabd93d033e95d9131fc20bf8ed23a1f00d6bf53bf9ddb09e9f48c02f7cc3a5250ae04f639e6b8d249fdd55f2857c81489206f20a9baa81e34671a92cc8fb49160f877cb4cfc37ee6175b512fb16dd5825b10f0f08559db9a82446ffa02cd4eab6cb49f6194bad96a7900a7cab5f12212b19332aafea01e79f06bab81258c6fbdf2cc43450ccb50f8af58317ee458101444df186978322412b965356f69ebe14cae2bd48ae9892b4ccdbf9cce380f1c13ef2fd78a3a6e75b3f4888e8def92b84854d438960123b71db032650935672e286dbbada59140684dcb7d7c4337107e3f5f1f2bde2b4c4df6337af1a527423cf43ca93b5c4479df44268e204174aa4edb649148a0b202cf3e37f5e413c065b4ba940956d40dcf4c8e995d158a3e240622aebe9b43b460b03a03742fe1b332b003d1e873ffddadf85ae265241d2bb82410ccbafa0ecc726b0af570b8469f18903aafd5072e0917d1837ba43ef2b4c6a33cb4351ca9e682f6c63d3e1ca39775f8a80cd2472087772af103fa8bc4a356a370ad2f2d5ac2b5ea6afd454a2c26fd3e38ebf3845ac9385fc7bd41769727408a0800f22e5e6d9752c15ab77218696bbccc95c3efdab1ed80fe7f6c576edf77951a7d0fd16ef7c880b323dc2e11f43f4323385603c4149a37b688eb1591807a290924fc8bb66b94a6060b193b3e2cddee758647927d2702d407b3c610ca4e3bd8b52390e9d6816bc8fa0df2592a2ec7a154c03db7c4a3581acb7001d45c7eec93b7e98eaeea0dfa071cdc6d1cc7e996a35bf9ca8a45fa5ac322e04dc9354a6cf5c7024d846caf22aeb67052a63a88e8579f40fce4ca334d6b7fefa249852c9d8696f10e29629e27fcaadc79ca84d8d20d949cbc99cb4fb31f238352c204fc941151e202ce51caa4c4ae7cd387e5bf1c216f568cde880cc0a6e4811581f009f0b93c83ee3e0cf4a671f59506d7b0d7dee4fc6d46eaa68fe3d0f0b888023b9e677fe834b5c6809df03e8227bf66cb12ea8db0ca43ae57dfbb161bfda7c4043f2dccb624816278a7cc9be0318ff0079ea73fc74136d15da2769feb67b6dca3164cc148d3c73d4568226f18f80f76a98e769c330e062b1f060080a6205e800a9a8f6f7c141fc69d82e715b4c3b0c3583f19376c2505853c3121c8dfaf4ef5ea1535174f3f31ca0562709d8bbce38e1817da5586f8743ea3ddb564d4ee8e71694bf394e92a131ed4e325d7f170d3d5c34e613d393198b8d986b18f23dbc9aa72b43e8c64b1904f2cd98109ed2919c071cb57c475874fe162c8026302764c479ef6ad5ec936da3d5f4b4b7aba0735c5b22e8ceefb267e426949039d22a17da91ee642324c3d6de038de22d0f0db85fdfbfef8edba33af2bce2943950293932d7ad9bbf5fd75afbe9d21d48a8d6507c58c158dee4ed1cdc7f321aba5a38533691a8e984e8973d4b441d77e1dfcc47af7837230133b9813d55d7f1739cde87f538e99c86dbe5b584180370654df373e9ad893f3f5958f2518efa639cf4ab9d033c64f2a30fcced06388b64ec25edeff478595b387f3f9092b87047579aa093e23e6a54e155f13147f6368641e66cad96fa1f9469b3294a171b22d75efc6f1de8a2e9bef14ad78994c034de76f3cf06233138bcd8e63910a4b838f9d8b974da301f6cb04d33e917a2977a8142e09aaf7a7776de01596e213be316b41ed93ae9e56dff1e32d73fec5521a8c5df632707397312ca8497c58a5eeea93972007af54ac1cafa98efc9ef1c54e9a479a8105d9b640d21db7e273d577f54e2840d07ad1f2d134446783c55b48d2113ec9a76cf35ac87b07ed2a1132d21594c827345413355f654be0ebcba4d3fe248e78ae4fe4813f6684cd173af1e5973558fc5ce3458803200b043ca7f2c4aeb38a94aea1023624a4862bef9b7191c9279295a812f8d91905bbe6365c473103bc5522addc8c476c92c38e7762432a55f4bd8fa8ae187fad48f870fbee245bdd2f237946ebd04847db2225b67055c1bd68e396c2541c76fa1828cb804b74ad840978104af45b54287d307bcb180461297bb554d9d3a01e43a5b29afc23cf9c99ddb36d47a31a4f1a4f40a2735f4ecdc5d10bfd64ddb7e376e1ddd594072d0108344f43a189b8606e74311c154b1724fbcac078f8d97745a94cf7b44939bcdeb83045d657d45e4e4f71618db8958302b359d3e2a2afab14bf89307fa918bbcfe4588e4d637659f67776bccecfb2e93c043bad982c801b78da65ee9aa98e2486eb85494fa3680e2c97bc5fcfe16806340fbcf16ef6269a492baadf96215d41cbb46c6fbc8f7b31db80528278f90c1e045916ba2b4a3a41f6ed3dececdf073388cad4ac0ed7cd42b2069d7a1bb0bb8692369d9aae157f8e754617c122b9e2cb11e677f90fb19fd2f268f068761e6d95c768e5078ea941a59b4f6b784ddda05edc8ccc4f2c1b6e32d791323c60b0c80355487daa79dbf86ee9c202f0ac144698e7a800458cb6d886a3a00d33dc86288acad39307b7c6db4b3df3d1132f9fd67ad4bb457ef183def5eef1dfe253bda57210f7963a5295bdc24faaec2ec622458e2565ae1b3806f1c4b90666f3efc735dd836c7233b548dbf4a0bac24798b3af21400ba04aeb85d54050e9dfd0814a9ec98575fc8f837c89eb853c3e86ee64f34538025e90df2eb04d39ed9c64cb98c4044cebbd0ca38592ac236fca622843d2bc3884e84cf490b46e574a6c184dd4a18979e5a8b01fbd24043944acf402454dfb008e7092b41d16f75a2800b0c239b51b8d9e23d65debf38242d107ef7332db95464ffe85de50b54a2fd0a914a0fae4bf4bf8f3bdcddabddda6c5526031584a1f870a9db336de3685ea0f1b797f500eddbb2b64c54679cc5eafc473002201f1ae7478d2504aa8fc27e58a0ba9d77ec766b11c9de52c73d4a73f812fd0f3baaf10be5199a8773c69a607d47cf54089ffa21899b3fba911b8a133d0f7474326a5f4859d4f2e84625118b5f5fc7d4181cde5f6bcdaf51fb93bd0735f6d21fb46254ccd32542fd64303014861d3308324f90130a4262d1d7d935c81562ebaa5ebac3bc48647060481a1e0633b6af0808ee32c7e6d2b122c1fb01ab13b7c96bb18dbc8e7f2483bfcd0a3f45e97a60d7da5fc88007d52a4e42a99e643ee2c2b22bf97bb1fc00992e4d1d25cbb20e88ec417af6171ad93c054f69b492bf59a6aa2635c7d592df66ef53470d55239ddea5bceb12230a2579d87c2ce789b44f2b3bf256aa8f6bcb41d73260bd592aa620bbb0ca2b6f65162cbbb20acd1e8c4f5f5cdc872df490418f6d50303b0cda39c758cd37ff034721c597a2199f441d9ccebbf6539f88aab8348f3c2cb297d76681a56b88e5e8c6bccde389277003f2e682e0ecb9bc0c22281a28dd79b3d37768748e848160ba0db068b5035dc93c3929aa2a1efdf55e05102043e3497a82e7d1cb6a26d3610a5664fe12b23f74665f10c42e648a84e4b49517675b30f96718389bbfebc00e66cb1aabd93c2ae1741964e071dfbb64247c989d1b6cee1f0ae8f8d150fd60fed0dbe8a89fececd6d2132a0a440d518fc407f306ab17954b62634aa2cc97a7d80f07ddca1530718c8921ecc3d502cdb1b1e801e6162987f7aa2f206b7693ad031a27aa458a2e55abcff4e69b733f23e47eca420a823330dd5cf922dc105b6e710853c89757a9cf681e9fbf382f9fc8cea6ad961fb3311fea1d035ece1a76643616f0960b6a6549b47a1a327b748cfdfa8294e5a7b07881c361445a1dc0b3f92c38a500aa7ac26525e53e6bdb0881f45317644cbdf135c221684f051c90dfeb4e619085bde7b3f115b7a9febc593ed0de0991b7cca1c2e34c2f8bfa5f37d8fdb7479f2736f62397789e4cf9a806ae761976971a6f0305711b0a163ccb6e4de1a38f70ad9a93e90746863a2215ee1f2c32de78bb60908454b47e60d95f2982483d188a6af87a4eef420bb991de4a347509f1dc798299076ab059e63d9d2530735f9a4cbc55e1015f7a55097fd7e617072e41bba14239bb02947e1df329d69587521f071dc24fdaaa2fd8fc67534d9eda0126c786f6c7c487123a5bcbb7856e7a5a46bd2d95607bb35d4663c23b0aceb8b501fcf134017ae86c7f55c905d3a1a8be5aa305fa645a84af37795faf8d5be1ded1c164ae5021d27e3ebf0cf5ccf9fa51eb6e28de11088eb86a0a2e4d9f86bb471e38616f8af971dd0732dc2a8f855c682f4e39e8bcb98c421141119cd91e7224d9374be367960482e94b438f0e04a0bfbd22926a7bc54b5185be637a6c15f301c0c944d7957abfee34089bd58a20c46bd5903d47b3ddc28d144a042f9852c3b5c7c4b40a90e2f5cd1ddc29e496083c2266927e2ae26514d77bae9de0b66db0faa3bad926a642f8b2a3a37d10a14bdce74b4dc0840f49516516ead98570212961e6ff402a8f428d07192cbf5d0d31186c439e65a587cef241cfb323f50c2b4ff1a26fb17b1768c709b8e72e9fdb53ef58d0bd77610de6f0f92fb6fa83440bfc298094c2a187e55f97482664f3cabca0dc2f784b94595476699d07f68e85ac82359616cd9b5650bb6421484e75594c9dcb82e3601257c08ae4774ce1ec7886792099ed4372d6ecf9992c5956024bf188bd839ea3235707d4afb98ae5f643ef70a61ff8502173d771f52adbf3303cb4e4f2fc74619b7b2f43031db6797f3fb9a615fd909520591fd0c7f9ccf209ffe6e8b8bf3368761c2969eba979500cfd3c7dd18295be04444908b94737aa2277ad22bb9490006f27962cd0c960c204c69c32b0a0fbb0339f2fe28486128715430a6da60818b2eb20f7a15568ceaf7f34f48a3ed3cb28b5225c185557b2f1aa17a721fb83040c41ae1606848ab397a529a5a65a7d33a36d35451446ac40796146187fc572cba5c14777287b4f528d272179893714b34ee37387f6691f58558cca2ba91da9105513b2003ab5126c6ee76376ec281e78f29adb0fb86f365e5293a0b7021822c5c7612ac8575ecaa5ad3314bd466a52fe64e2a7c8b6f97029c96474c777df637676ed5d854f4c5816e0b3c50cb06123cedc4aefa2c2b5247781e9a807b90622bd440bba4e650a85d007e4dc0028b7736102471725b4ae0af12def092c93b9058c680bd5d715a75adbd8fa522072152ae3e79ae810c18ee6d5d3fe06062891902a78c1b1f020ab883b44a059a1ec8806a79e82e96c0af5bc6e4fe616f54c6aa1e675a0fd7389d1c3281e09dcc36caa67b7aa720bf11ada417ba6553d1f2e2c7bab7cdd8e6f7ec8d8293037e3f0cafa60817b8c9f694885dd14812159d056306129893d1a62e35a8a79e3a5d6c317f78068b6be3837753dffa7ad235047eb1b2f683a510446b05afee3c623efefe8c3367d8fdd869a21ee1b7d790812360553a7e1687f7b3ccb37726193d0f5c708fca79dc4811b69a67f51a9b2222eee64e981785ca078817926d063aa4b60917d4c6f0e851a2f05bd8e03d72bcf02081c5f4cfc4abcc33544073f69e298469a69530c266c5ac44a44ba153bd308751b92629982e2e4cc3296f1f2b24f96ed98f834b0210e712d1973d6827e7f6bad35b81ee434f516dee8f00e46fc186b688bc509231b556dae0bdcbab798f5c2f1a02a8ec0a5f03658813b6770ef7e4c5219f89073c4d3e2b7219700e6f96d52c69d4c7374b484ffa3c34f84426c4f6fb988331bedb50d0080e2909b477268a59795ffe67a68ed708a839cc78123871831290a65fbfc2bfad9dc72a2e294bd6a5bace5ce8ff8fd9646d5d9bf6b1ae955637eae2690cdcb0c474479c1bf303f9d4b068dfe949979b805fb779a11bbb7aa7be10a05426f56301a7c3951fd95d66d331ee13bbfd9982023791f2599d9168ad67fa6783b57531ac941879df5e9d0dba3a6c50c32080a6048a96e44ca605b699fc136c5cb60179fd27fd47c54faae8cf60bd124a167f98b20408d101d0bf832d17d93e7393af0fc996c4a461c10b1cbe8a104c002d9ffabbc4896356c602e4d370fd7164ef5cc772d463f77117c47089d3510a87d1286c9cbdfc4b2c5ff51246c055477e006f6775aa925c3b0cc02e6828e8f495acaf6d12f95aa295b5b06fb727cbf339cb7261ef6c6cdba79b7d5aac6f2c436be376cbc8d2bd5479d33161e50819e9419476788bd2ba7dd705dea0230f6e62b2bfa8b5dd321639099eee5d2c04753b5a0132a8e7fd323785a77486a66c0f5b75d152dee54f1c06dee7d6289209417e1494648eb6def4aa21cc557eebe6ac9b206fc9f34309a9697618e3c6bd7457e0be5816d7e2b3b914446a1578cca9efe91043fc4b9a8698fc92894b226e08f6c55cdc0a04f20305a56166844f6dcb38b81d70ad8707edc8d9fe1e826cd2919708ca8ffb035fea1e9e5518a28dc28f0536d6c131cfdcf3db55df8778c4c7f52c93c14a434cadf767383301c6a64cf0c747bb0a3bccd4a37c86a8f20ab298a5e85505e2fb3837b171170253c20d58a2c9d2f461b21fba5c05cb1429cc7e59339c99a5722bbba42e959ff7d898ae4928b336ea39cfbab178e2bf17edb9240c66a6308435a71f9655259427013dc03ef1f3e1e5ffb7067f702cf5a21f0924e3b01cbebc89dc413c605bbd9b6f5e6bb4e978b9a718537d2880f06623f0f7fbaba886b0fdddf440a58622ab6f8a4e89f4ed77497c4bfcc772859c458a417ef14e06f2bb89f464338dd1171ccc3317d68f9ce1e3b0545a65d779a8ebc283ccee1e5f3513eb47170039e873b30e5080a686f14a769efde5923753319e18c60e5fd08ca6afb8129c7f04c4fb5d9ee650dec4900b5098fe7b7cde2204e8ad22d198e1807b877023f046138ce0521f81ac4fddc82ba80f3dbc63362f42cff969c25967f542f4db6f07eec6b9e64a59be1be918d9ef02a5935fcd177a4f766f16f94666838323f62fa877aaaf389e5eb07142428efa26e38c71deb5bc990d7b04b046761e34e04552c75de10ca6238decce36294d40bc151a7341e4000a2b24ec9643d0cf39df1eb8fa45000f111cac8b63dc968ed068533f5388495bad6b003a692b9f378bd3ab893e43903ee060174b045328392037e02a60d776eda0359e04bd635723f30d6b86947203acc697d24eaa12ceabe2fd5f1fd73e66a7d242a9d8f18cb59edaebe82fcb2030698f1af029773408ea8b65059940610d1e41d0cc1335bbe7c13674a327c5da51465033eec919ae24b6cbe2bff1be6ef68f5437f78f4f4113381449b61db11feeb78847ae555f9599cf81a7bbbec87be2b7a1d4e1b0208165f4e61c65d6be1bc57756504ca2388a68cfd56b31b77cce0d755221a91384e1552177dc042f54cf0c9fd016dd561edb002723ea7710192b0e01b4c5fabcefd6b8638ce6fca2092d8921513805f2d067dab0f9951300d25b41125a56bdf7387dbb76c5ec1591fd9d42ee462b68de5379b360c0f2001aa05bd19765250583accb834700b719168de3e48de14f71010617497f7936fe94a429e543ad18e6c24adcd1b605a1dc466ac229ddc451debf3af567eadd53e6cffa0a00a3ed95a856de5a7e6ba8dea90ab2d2bde4d1ed85439155de8d15587972af812568d0bfe11b37fe431aa925daea6c5ab6fd58de39ee19fd50faa2e943c4fa1bfb612013188b93145c84f2bf5a550fa5280fc3bcd34fe65cb4d3af2ab981ed6a4a389d0e36daf9095de8271266ce6342ed2f6da8a3911d6cc35b1d60fcb28897679692c1755e6eb742271071196dd075f66e5db408a6e97682969cebad4d4916dcdd6a6345bf46b303d36b24d0d7fc01d0f919136ee4d86fb4a2479c96907924a1a84e601303341f17d5642e42fd2c9ccfbc44f376971bb1c78cfa49f549251bad11fbad332b0e918fbe619e0262b90908087589c9fdd1dced3415a0a1bf9a3be39fa57590698906929cd82eac3b632ec1d77e2650fc9ed03ee83e361f0d8bcf31e4dba32627f12814bcbec988d01ae468df43ba3763554f01069b5a6e22016b4799ac06448581adb0d427039de31dfaa7ced6fed010abe39e36ec0bdd3a928285d80b780e9833613069aeb4860e05ad6386d7c7fc3ad3972a1480532d432287f5df177f4d6eeef48701c612b439628b006df36ebbfcde73d9548695b4b8beb4aa82f601f58bb7e374314602804541c0d4711a3bbfd4a4a38da388e02f5de92c6950310d8969503529e40c88838f72d76ba7b6f0131ab8b0123f9acaeb9e536903bbc3d2aa029a23a79c9cacf1e368a175ef0a0c61ccb367e3cd01f4f18565bafdc63f89d78a4913094939f5ad3f1e8a90e9ffae516e7c790d751b5f68deb0a37ffc06d2dc9804c385b6de647aa2150093400a75faab3eb4c1bcade2f9ab4398d1b6fd3be3bc639cec002ddac102beee64ed3a55883eda3a582e8520a68d7e4fcb5ee1712c3a297b16f783e8f2dc3704b1c4e5b9d92d0c52e6e287f843a4aaa2a445f8fe6a60e0f3960b86d6dda36219438fc4d968031e39e485e88dc9939eb0af99480315056f8e0893a74f69e110ed0ba3152c1b3522917cbc83c34e36c6497c5b3d517c3d8b2b7bf1450bb8b07ab5e95a716d982ea577010cc7ba500f0bb0a39f981e50829b90bce671437be5e842128db5a0cd77b3c3717058a1a12bf7e4ae83f37deb0e3a3eb1a3aac67171a559755d1b524b58ed65f5914ebc9b6977bf0a89952d850b920ccd54ad232875c470ac2a610b787e5b44fedeb92e27c8f8692b585d3a356fa807b17b4e69f53a89bac24af921a2cbec65ee3b0e1d200ec5a29434dc129e0130f8c7d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
