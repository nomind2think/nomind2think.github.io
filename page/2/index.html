<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"edaefb3f00f563ea9c2887e8e63e74e74c5332e30d5dff2d37cbfe6f0da87c263f2e719c086f23a263ca8e4d1601c0113f453e440d217815358bb488962a7db0a0534978879031436a2cfb8e556198f5177bc5dcaffd5a01d87fe08ebdbdcb9a76c7cd57161c3f578228f7fc05e585680318c4012ed4958b2a7fdd047fbda392f679d022e5e6bcdd9ce3458a0e212c26401ec4fb3c4cb97f92235c0d5fe5fc5a14fdea0742034c433231934c9e2671d71829d4c1562eccba1a191ae5e00cac56295b28715f03bf429ca721fd8fcd490d1d34bf3fb20ff98145133f98d0cda88988500b1da7e2a65df599ad58928cb4a6e4908d29fb1326fa930a9433305a80cd702efb6966dd2a875888c466710dace05e7ab9d05076236e990beb9bb3b1d6b514a37e586dc105a16435cb78bfbb373687147dbe60e9163da4314db040417c66ab249a212ff518a4bae3de116bc4a8696bd1834b65971bcc08b8c80637132ca3ccaa446c8cfbf63b11c897f323b9551dfe9881ac43f356768dec81d622d81806145d433a9e1e82dca83a03e60c7ed890c2c7e64aad92cd4a73db7739dd7158c0aacb1c3cadae5c2aa7b6384d64dad5a3a9f3e502389e9099782cd95e2e2225009b97d4b4a346eb3c801f5fa92e4589322f19c3a77ce46708e2cf3f51df825bdfe27fde484ec061b566a232368d8f5f079bcccd0e202705499626f429953dd2d17114812e621eded021ad93a9dcca3f238319ec260c24d754a8db6f636fff0c998e827394a9ee3b8e43b3c8b306fe2b447908232a20b572b058100b1d017bf4bdfa3caac6fb647a2000d508beec2d9c632f3ea76c497255ed4e3a432b7eb96a52d0893456ca6161947e0bc609680f6d1902bdd237a53ab7cc439836971a948c33a56c07fdd56c79620c29f2eedaab44bae11ef2bc6f838dce7af0c57ad59d4c8cc62c04c011c03b5e0476555a876d7e9a3d15f9b3fe42a7ef1a21cfda7cdb4d38e2acca014ddd999a94a1d02930a26c8fe97432a38e57ceab605e725467cea37f53b51d16468e6b7eca4527a7b83d8d91e76431a64b9a48f09146d1ddc76e30e36de0e5b0f7ed866eda62bb396fbd6c49ddbd38e89b9459ddf859fa12a10a76c1548b4851654b9bf3307409bc1f00168966b57aa7fbe72891a54c67ea39ddeff0718900c88c1e73c401cc3bb35a1dbae67eaa00311670033063ba01dfbcaf92189c605e5bce474027abb31a9853d96bb04ff48d11b029ddcd21185d1439c152d41addbcbd45e34d65f724dd2138e6e097234c7f5b5513845dec091d563c128e43fda01b27146978432dfe24a69dc03d8beba8d502b88a5e5ad6e1768b528ed5bcf0f7aef9f5831d472c3621c483817906472aa1ff427af35fa44eccbbe9dc03f2ec6d72a9b9b8a9e9dddfcbd1f32358ad509097822e04d5a23466711434b800c59df21a40364f2c224cfde542796a96d7ce377827e3d83f09b7c5f17678d8cdd15517ad599b0acc247cb695f75097e5038b2585e65b8721cc0e41427b802a6ec9b8c8a307856a92a63bbe0b41d2696d87d02fb43b6f8a30fa1a3fa4c9f8a85a176b25e524978e55190bdee01c25172822083ad671de8d65a48d6c0533359a76a23b6c9e6cd96759e96498cf5897456e622a6ed4df143d84574cc60f37e1a708792bdaccca1c6c93d23e4f3bb9311fa039d0bf554c22cb4f6471a0a1fef4921c00b09d45c3414e51214703dde241714eaa604a8e177804a14b8db25b7d1aada66b3bbdb36197bbcd1fe6eaee1dc746f96eeb164ae85dd943ff96701b7e76a70d003f781966c6592d24ff6b3b047dee43fe65aa214e5dd5fee9b151be8f7f849bb5f96d18887cb066cb165020188eba91493b80b9c42c3f9e5b670165b71690c0ab1262d67261112e1139c5e1de4642e0ad003c3f64d823652947cc2b4f6d717c6a263c59f9bb3089bd3d12e77292c94922aa1a3d6b786826f8f844495e9293a8d75bf9c41b6f1e2251b096b3fb4075420e39bede0bc5d93723ebd3cec7bbc9aa47864c8075adf2cc0310ab82844e206e59f4b5772b18b9766ceb25b5cd9a19fe3e02424cd3470f165d3c9c137dadaabb23ebb51348b9be6d1de262a00c35d2d93e1f8f87054297248b2f0e08e89d9cbf96b3ee0c0cf7841a19cb634d1d6ce9b896e6eaabe56134b86d6cc97d2a3783aa01894e7fa803ff2e9501667e7cdfc5030d11a732782201f9391d164774d7843ec44549ed3e4e9084db36df6d1d0b2668fab3761d9d356119ccd4849fae1b1697e9f315be9d5d7675b29bad9d924c0c720c976bb53a39303a613ca3dabde8633b850b0ff6b09f64f5710f42f84ae781892e731bc541a6b74f47688be4006e0253b2ad06b68bb8bfa47ca934cfb20f6018e5e27631dd4ce248634ca83581005c09e199d1978f84c1ad8f2c9489c69da8ba844831da46da51a55f1eb2bca6684e485476338c70c13de831028ea8203dd9cd7202e0d64f7b630e50d8153213e4a4513a6ef79d9f51cc07236f7cb6cea0ba50958315eb90373b2450c3827396c38e6653a69923cda540a9597a8f67981e616ac6dd1d56c2ffc0f8969b418d57f08f28e3bf9f8d5553920563f7eaf784281f737a9f9f757d14c79fb73c16ea8ea4a3c26970871065738268945f1cb8c738fc415e74cf4fd8c9e3798af8d94703774702e06c196e2e3d4fe5fd773412dde1670daa6c045c0a45dbb5ee9ea7fbe1c8691f188bd371fd32aa57747e1b6e7df85d1d7d64c09ac4f6de7bf1c1ae19df878677dcc60dde8d7d53b04581c9728a8e8270faa70429238db980042edfb97efe16e205d779333fe96eedd9433eb4c31fbdee2af05fc659636cbabd85c19ae33598c3d69b114bd754b08b44b2615519ad830ba57d50bf794f310984786411d13bd577eac423a59bda1ce40b87c3a9970472c72b198017c2abd1183924d1daa6ad276e11dd71cf54ed2803dd55a998c71c021529c216378d6c33371fb967915222ecf58b63e5ac5037a9ae47f656832c9890226825021890c4b29014a316dfd70d2d38b36c882587f4a149d650de0ec55b2ed7bb32ef22f7164993fed450823fcd8533c3575a6b846c8c035684cc50828388de8fea124ed8579ac31cdd4c24fd4d86a65a2c8b2faafb603b80d4026552fb42ac76eb88fe63ab0747ab9ebbfb3aefca45519eaa6bb0e6d0b10423968dad6a07cf76097e33761a33e1806c9fdb39146c684d80644d7964fddd48723f08370acdec9abb19440429d78cfcd2601f337cd8ab95f65a83f6ebf05e1005f8c7d539ad4fab048b1f4d74613d518b32aa7288524035418fb21ab7d0c61eabb48f9a55eac4682f410f60c720f9cf8f00b46524566be76cbbeb0f681d7b631ab8b5a9982e67813a8a7084b3025046f2f10e1bedfad9fb74555b551741b44265e972f4a126201f0813f3b56b7ca11134585963f3a62a47b52d8e391ab892773bbc0068ec7cc7e9369d5a84d48f8e6cb9a35c32e6402651c49ede6a5c91a6898090bde10edc614d1546aa3f481d9ccaf8f7f0bd14d6e851678d0be19c740c5eee0caee11ac582eaecaf1ecbef91e75c5931a8afc51657eaf991d36848ca036953fcd4d506a34992648df86fd808b2fd14048e528d5dc680a907dbfca12dce26bf47d2ad08e6a6d11de616c8eadc1a5f39fca9257c879dde60d3a304534fdf093c21c491705067464ede343bad6cfd1a99e93a2afa44d08afe24c115e1a05de7eba18717fbfbd733fd0103ae7787ceb1fa661931f0274640ff4a01262b9c4bd127a058ccc5628f5b7b91273c42078fc85f6b741a718b93c166f7ceaa80c82fd6c26b145a9f8b235e2d5a2418074d4ccc78689ff63a4ac44dcf1bdc53ed62925c2bd43b406848f3265c4304ae6e70808920ae03344c03f239b3c7a97f492e22ae4b6bb4f874f21d65b6062f44e587e2eded32ec62508ea5c7e7b46ccdd305b510f07830f5783a6d8647e983dccb7b65bbf2c3768958a2c52eb8145251cc34705e55461d1bd279b749987bbe66459121986cb796ee7638e45c0cbfa5b2a7ba044223df93ca164a98e4744d9183978b7dcb6ebf9a2493fd23c3022b33e29e00170744826d8fa0d65d4c91b8eeac358aaf00821fb613195317cbf82af37ddb40538f24c0948b2e755888b8a155cbc7e078df1accb615c9c7912ef32c5b88293e258aa737007e5a3c8f6f6d1ec31b463dde413323034eadbd964f64cd3dd8dca204e8ca0ddb4eea5936d9159d32b51596987c2d4c367d05034e65fc694edc2013bade58d9156749f8113cdf4846c75b46eaaed11dee27c05901ad5083bc467c6b295c4e5822d4de1a86e4fd10d0253e8c7614b3b450e6b2c9d94f03d3dc291fcf4a6571276189ed3a2ebff21a76c4bd051d669f33f60dafc6d099c60b379ec9c1dd576071b21a67a837d6d9d124c143462f4cd5183987d6d3cde4b533a84f40bad070194bcdcf0877098011e128892759aae477c273e46d7676ba50ea6c9a314efe74bfee4f6a712d8ce00f5423e7f5602d4cf2f0674c669ccedecc017e93be7f6fc0e5970c68351a8b396f745adc9fa0f09dee81db2baa3ac74aa4942fa330e4f4a3dc2bd72f1bd22f8213810385865c7a0c53776ad7da91fdfa39211afddb529246aa7e6d97954390cf48df319414d19eb54551fbe0d64e20492c90d41d57eac0cddaeea92f754a4992fb89653cd3462f62a419c83c4ad0579612d42775162c56b107b56409f8c27183b9fca2f9e93818a2c3c50de0a6fe91d73f51312c00a1fe6c4e46f7dff5f7ffbe5f049b98e1c65d9ec16cb5b8074e2fafca193bdc8ee58c2fc1ed8582dce68bc8a96fd1226db1c7bc9e0d94872cf812691fb8b970b24739354ab436180789e6de4a5c5f0c49adcfe89a330c4efa03d1a5eef81e5afc26b906827f878670fa6aa925f6facde9f3aa40ad8b145f04a42635a1e710e215d991e97b8230a1b5e95cf3c21b818e8a2a419dd00ae1e63aca295497e21b505cfb4d575ca4e36229315e499e03dad7f4ecd586ab46407257782deb322c07183f9539f4c5c8c186a0610c5f5086159a81458e602ec2023ea919494046874b1b48a0cea1d3f8503036919e751166ef8f53388299cf365bf5f1387cf69091a8ab8e9e74d136e67cbcc4104d40ca5d91956777fa8cb6aee22ffca46cfeda5a9aada861216f526a866a5b38c8669676b7f9ab40ee633ca6a84a629b6a3a51a5eddefd18e0f915513c0612bd740f56ac797e0edeeeaf81c984c3cae9847b6b79c5a30fdc6ed1cd36eed991c6e398b7262632fdbad3d681745453f690c46badd3a4d61e06b67314aa91b50799c0f82ca302e3e23017a7747b791d65b42b2a98c3f1c7ca59316ceb124cc19d252e703dce5d3c4d455ef32f9e7f9a0e9149c63d0be2be974c6bfc75cf538caf75f0b7d7671a669bd3973132222ad75f6f205ed590d8eef3a93d2e7f629f7d519611aa837d0135073bfff0c966c8e7329fee87bfc5d4c43e266a09ba6ce815a63a95fb8fdcc73d3b322bac223941570b0aba56b279f41edf909a63a1adbccd9eea325a6b0f05cb633128023f69746bc9a1aa797ad984b2f3146e2aa673f172360ca9dd2d36df491a777d87225005314bd69a0ea0ca0722fb93cf059387b86dd2c4cdcd882b4be2e67a17c503c8095f453217992c1dbe3b8310b414671a98c06c773b3d25c3fc9de11e283594397687fa71661f04f3723dbac36e580d3b0b2388defed3946562db8d1d0b3224e9c1b263bc47361867c374f7ee99142b4e0cc1b28c05a2a8ae6ad50f26b50fddff346168989bb1c29031e6ae600bf549306d6d3293fc5d31aa1420b3a8861fe40294dc7a50bc1bdb3a7d0b3048edf87eddce082da33f71289c0556d7d25990906000bfc34a9241d9daaf5cdf5ee8e0ce80295af0cabca9f2eea4a729beca7741bb7e01939d68e9c3360127d5fbbb9193171fb325070aff1018517f3ec212d3b4b25f86e494e470d0d87480494ba2cddc457ea2a4762ad22d7f8f7db17178830eddaf41e926195acc1136eef2ed10f0da6a17b453aac6aa0c3dd47c7d6c9196e9efb388496d32ec9108277d7f7bc69d1f2ce416ea84a8b9238341ff8aa137bfafecb82fc59b3e06600c85d22290b17bb88e7519efa5f3ab87d9273df5d1c3236c9b4ff1367d700b8533b1a5835c2b0bff3eef49f9d213635f0c7223feeb136fc964286d8242d18a268e6774b4109758c093816413d7bea7c1f32c4325f363fc929f5a682ae27b7c58329f948d47710e4a51a8f6dbc23a75f000554729e9f79c14742ec6ad28692509f01cb1f46cff5c0e2edac3224013507350cd5e0613689d26eef8f4dbae654d0a74a0d6791f4dc0763379a77f8ba47218f720662573bc88c140feb3a6eacd2a3fa2155b6419f6b3919f21f61a45a60abe3db32c18222e74301e3dee26c5da3fcd43269ecf408316bf3b4489a2750de2bac0d6ff329aa4cb67ec157859f18084e5f11d8d54cfd821984cba28e49b9421cb464c59d82f022a74d971f6bf285d8b905a84bd2e63041adefbc5f5d405d9b0f8f9ec12c396e31d6e3777885c9be1f1d6647c632b4674b3a81a3eb6d2373daf730c538616dbfa94ef7b3832bc16de6bd18a91f172071a710582daf5a6c404c1d28882dd4b552e491f4019a086bb64435612a78b05389130178731c789d0a41333499d00626d973e5a024a23f91c002491d1802f343fa2b9f0d876d0a3f4e0252e3eb637da608b18a5285ad25978ea60000b9cc914c13075bffcbc78fceb09ced82f6bd0d4ed543e0c33b09590483dbf95086ef51e9c54c268fe85eceae380fd8b40584111466d55e64cf81645d49290c0b2ec5c0f7e07a0abca7d83a556e354b16cdd308eb78dc48415d6519274a9bf74eae97b2f21b2c99a3eb5caffc27d54119f32f8dfaf70bd980a5ea35d06fbe9050ec46b9f41c45586fa4ce134bec683344a1807e9d34002ffad1b84f544435a474c4723cf77d88ab67044864689b390208e62e51e83d4ed815ee8f72e66e914a9bae6eb82a2b65b83f2c4c74668d372ae2e35e4e21aa52810c5c5e620abafba79bd7f11e71681b7abf054d708d8f7e727e0f2faaf764e63f8d04ae9f78ec176f5a8c3fc12818c427d2281ef59888e515b69edd92ac3391a1b8939f94b8644ce9b44233ba687e186d01c28b6887094cbca35f8f29a5de13713e48ac402fe5857936223ca3ae2f79d51ccc51354642a8078701c0786ffe81ec1d02c0284d908879ca50ddbe1acc694a7099a0ba1fa32e04fdc037e248cb4e19207a9c701ee8a49c1ee487d6a786e11d9b03a5f32b2b97ce1ee6724bf0879b5ddc793147fb6dad0cd37bfd0a4a1603dcc77fbb85816feeae5fb346dd9808a2a69d4454c4fe7f11afb16328b845eb0f4672b98ce73f4266cc9409848cd99484f47f78fe6255ae71fe8478be5d63ef38735b512b05304eaa1fbb26d474ac2ff21adaa3b1a8db71ee02a2c707d917ced581aff505628bdf4fb1a3e768e8c52244cabc1fec9144cfd268d6024cb1708c97f61334d6d30d52a4d18f5a83a8a9d2cec5720f3f5b1a3d84b96cf766f1b73773d4259d458cafeeb711f3864032adea7bc9057d68a2041b88b112b6d4a57b00aa3d3b44eb1e8eca3218144706d88ae718630cc907b47a0f01b7f5d8da166e397f56f4e47fac662fb290ce918d05755a569b63a816ea26cad11eb1792f05cfeb1166639925b01197dc75c1ba1cb5dc467d0df57fc35fc70d10d107889d802be041f11a50a41ada3fece8d33d232d8a624de7affb46b753e2deb22b9b72ef1b1aaebaeb2d6d961fbd4bc37fb4916b419b7ffd92f1325f805433f5a6b51890c51a9a8ab3fb06db72735642a1b108ec3d5c25549d397d47ae1bb299ea84626864b37e191d670794309946e84adc1339b59407f8abb45c3202f323a089a684057013b9d8e91fcee3c8db7b23241852893af47d455a93c44216e1c0a903e19b267b0c7c554c3fa56ed9b3961bdbbd5c3964bcf3c2093856898ff7fa8d35a0442b480493d24b2700c7a81d4310f5e3ed5a01649b2c403652410c8487e46eec8368584065584332b393ccad0a3f4d5c79cf7b043ee62da3e51d28716ba1b9583587e94cfa8c3a3a614f96befa5f8ed3419f07a61282851d8b93673ba6a569ae4f98ccf49d38e80b93c59a0c9b2e519887c3123e4275208706791b112a5ae8a727318905b3176ddb2fa5c9e834749350b5652be206b59713df998d4c8a95176334aae2b73237ca1683a4e4e823387434ba7405791879b9c72e2ebf66c6e19ab75fe7c5dc1907947bc622bc307b99a2a0cfece2384d9158de6c7afc16704d79ef11c5105d3fc8a6b11253105507154b7c41e6d997c37dc676e1b366be079231819a532b112a0c56f82b0079f7765e0f7796ee8b3a96a503c0e9bb9720d25559a5e98dee0716bd28d05b4b47c9c61427f12f50dcfb9b3e1d9a5cfa2aa523cc4b9ef26501bb82aa3a473acf0c638e4b1defe0cb7074f13865b248798c461aac20d1627980df7282ed1a2f96c2f128c27e04179a21d20d418a9ae752be8820333fff41dadbbb4da4450d4ab9ae4af863013750c2f6c1a55976da467da2597d3ec30d90e7d35669a2a18b7767fe54212cef7b07ad44b684ed1b7e7d187770fb96332c92ee74961f2cf9aedbf536f892029237f1f6adc02bef79a6be0bef60750de669c10325d02042df1652c71fbdc1fb7d0a9b50058b1de1a08b1aa25f34ae57b4a196ae0f58f6c2b54386415de1ab8dddc4844c1db86c4de9d1203faf7772f3ef1e25efafa0bb8110af420107da7e05b131872ea59f5eb78126ef66097388a4cdae89b9b5125e251e33195e92a49cc54c39d88628c83b80c3748d31f8ced9cf404f331776545df1095f6b540180c3e80596b5a04847d57f6c41d960371a8824858e836032e5c2593643a1cd8242a0ffa8cb8683c5db67860e52e59d5fc898b72cd6d796b5236cf3c2aa2b0cc85daefe6e563cb21817ac50c2597b691a215ea2b836171b429cf6794331e3e75f3296c2588919da8230cafa3b1d2469a934e1ab9cc648bd16f06b00c8ba74bff9a6e6ab4f6e3b0c76d7c21ead9bdbe6bf9594c5f4bec32e5fd7d163e2a46e393babad7a5c3026ce844a04cb20a4243eae361324e258f82cf963553db55582c9c025877362485e60fabf1ddcb9084b542d0a33b8468bfe6d693b8a13705a2020a4e6badee3d0d8df20f4d1e0e37f299c5ef960ea504c1f621611e5aabedb6f6b7e94e32bb5914eeb9bc162c1fa149df60c8835eee8bb4b5d73ddab975f030b0a5bb9c984b8a398d36ae33fb5f23d841cc5fefedceef98cc12d9ad005d196190d4d7e9911fbd3786b00ec5209ca16d0a7fc1f2282343b8f9206da734897619c3a5dafeddc6a624db9e56521712c53a289b9f93b97ff85850cda712ee9d80d91e5a9fa46b07fbfe02010ca54be15c37a76e1d480bd66712ee1359718b6b5d4a0bbdd7c470f2ffc9f6db43d5b691362ff158c0001dea975d792f5fd1d282dc819e5a6dfc807e1f9d0aaab80856db40e806daf499a6b07dfe6129a36f06879612a2444ee65d10e3ea955610da9b50df62497b312cde546b65c0c71a93b099df6d084ec20bb38e72d89ce9c6327d0400a5e65389f377f95263b05165bfaef2ce01e5dda5b2797c3ccc27f5962f556c8d6e5e247846999c365d9692b715f2cf730341f2c7aa506c527fe7574acdd0b913e44ea6e8a465b373d3afaf72ae0aff8dabd185dfe5f3f268bd071305519c3f7e804f47e508633430516f9e45786ccd5beef52d98a5b48eae930a76e1546170e4fa1b9958b72625630ab8736485c4f8dacbfee21040b412e16421c26d8c80a73ab92b860280bd7ceeb02fe362ec4de2c2f874a66fc6b0aa9c8fa75230c908db98fe3031d882fa4942b1dce48be235eb0dd0e939ce3d33fa2ee409e3af320577f0cd4dc05c4bfcb783def1203e48181ad7aaebee78fcdd6770e1c51f5ded8822d99177a4271e346505de090c69df45f901bea898be23e6ac6153ab288729e873748ee8feda1dfe553c2f79c925f9bf9055a49ee35984ce98327ed6e106411fff8d62634e13317a1f5a69d7f63d548ac48329db11e9a3e2caf791b1466791b3683f8259c6f4f71a21e77fdbe80727b616f4ab6c31474b46b8b424230603fcc41f62b12a1627bf365298abac6b6906ec6fbca0825285257bd55e5f865ea85f74067807ce0a26f8b075e604b75a05f38a06e1bc3b792fb271b7ca9a6d9e6d4e7324b055da1e0bdc8f919a3c491a8eb41e2479d7567a6935f16d8f7b8f15694b40efd3c64eb17deec7afab5446e08a8834d7301c07bd617f61964fd185273f2a09ac9e113047b84f0538809dda0686c46251e756838ccacc03d47f5ae68ad3062a071d582b55d369c4b588e862bcd950398f04b9ebdf587f8b5927e01742d387cb6493a42e9f149e7ea38ce354ec8291b7bb8b6492868ca5cb385d862530d37c7a1c969ee0a33cc5967a5574812ebe38f8f5174cd922de9a5c39641bb00759f447a638d9fc6643930a5cbfb758357817f07a7d83bc19c4664485daeb8d759886b8dbbc99a76a15d6401c764351db72d0cf6114b27539ab9c383c6b303e939cf108f73a8eaa00b1a2f40cc58d2cd124b4611378e2b548b2b431ed8d192e11e5c9efca415fa096876561bb9793bd5b5b5e10a86e360eae9ca3977e06428b6c6f258b4a7deb0abb40adbf68475bcc08cc9c0fc9f83a07ca5ffe68c09eefe7cb20536cfaac6fddbde1de4b05304d82974fff1beb355590d089a388dde2eb57391e14713d9b85cb17e215d9f2791c6e0b302c36398ed886afd1cc4a1227c1d1df9c39e6a60e7d1fea542bc0dd30e9070aaa9ac24b970bd416d0b18ae468c3964736fc7a9b5ddcbbd815d3ad318f8ce536b86a1a7c4ee3a7b278821989497cd8ca872f2498700903c3e93005b49b84b26d1c35dad78b1e39f9530922c2b74b54cf1e764c456ed44ee825d821e0ee83be3b087f49c5ee767f73e3f807c374d3ec62d6625a3f3374c71e59612700f7548a6cb0f69ee08aec2189e0c4049c344efb3276f4cc3aaf7f1712d8ca40844a11ae2dc05ff9203fab123fde468b6e37b75b2ba703904a35f7fbe43c0781ba6f9c5448957cabb7a813798916f18ad2b02bbadf24e149a16f07698f67b12ffca5aadb4ded4c81d8f648ccbb94d0d8697bd7592bd439a0993e220d2900677afd435194bad7b10a961d59072123cfb57720c7486f354955abc59a4440026c483cc3bd9ec4a7962d51e261074a81f68fef8e15b16fb31b99cc42978226ab46bf87be1d1a188bd2cc04826cf9f4ae627feb3302a89bee2d10a2559e6562f20723a0222f5067e5f93910915e54a4c566136968266c6fe323ba7b2573dcc938cd6197e5abea91e29d6c910b6a606b755a7a06c6cc587f8c3dae91c2be2f707db80bcf59d20a8928b3542bafcc5ea50bd5e171f8fb9263eb14666bbdb342680ec8b699289d79a787a3104a2cb02cdc4659c266363b98b6237e80e90314ac4cf1d6b3bf4944b4a15acc8b7755276277000c75dd1e0cc3791e3f39e1090cf2009bc70f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
