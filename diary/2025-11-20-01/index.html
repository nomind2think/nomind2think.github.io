<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4e7a15f1b639bc0c6e462b7b129f9b3b11dc36baa72c0874176526af2dbfed5326b89a640857a9bba1cea8f52aef599a993aff54d23e4b0f336e09a49cb393f4338de1323f673e5bf1ea22095c8c72a825f79326b3d23959a2ae3084ed709382e5bb73dfb8e9ef05550fd19b2e2bd71deb760cccc45730ed5bc3f55a2886f105c4790d7486def6f3d71464f2b858ef56df0b6264c47b63b9938ad4d22470f852cccdac88ac51e25a5affce821c7ec65325c09288e8c50d2dbc9e4968132a071a7999e68d2e4c99bad38b1a7a94b4fb3520ec7fe2d81c6904979014f74b54b02fa3bc1845f8c6bfa2badb6747a0b9d8c20f0513175b89f2fa95341f319dd1b75c95f27606cc72b297845f2aea7b9b1650b87932f743cbcf4e8d2b92ea3666b588f2f97a1200c22abe0cf2f4d7e711da6b3236b147b2b3cebf726d13932e9b725341d9726df6f076a4d38ad1560abb7b5610f4e5482dd98e610d86e662497f28499a4fb402d521b9928739598f97f5b761a3873a6600fec87f148533af76b94ad1b33671517beff9ef0d0031edeae254b488e3447b3d46719a096571e774c71f96b0c08e7f7a000813f4c96e6d6fdd9f68440733d9b0ae35a3ce4e8edbe1e46b437b548cdc48b0eb7f3ccef9a3e6cd682e30dc88e71b6020f6c0386f84f7258324080206a970554d53b9f34dccb90f4fc3161882ab8b026cd67cfbcdc4e61b63096cff195f1bfa9c9035840a3e499d08cc251ad8d88109f066a73c837ac47f1b008d4848a27b3ed058f95756c4e8c9aab32d1943fd3122e30d9694803ca45c6b33a9edcdd5bc2ff95f6b09d81ac545192e0b059bae03dd8ee8eefe53fbc57617aeb908b229c48e6649b2a9f9964d7f3775d97ce06a784d8e8f042301b8faa5c2ab6ca3084c9f3e9b542d682cd5ef35f7df47acbfe45fa209aac593b48c890b5d35e0a79cb87fe859295217185704a2c6dee21d818458c1cc72cc1db2a08290c7e0136173c795a44b60e300a88fdee0734ab8c50786da4c847df4ff8eb42ea363b45338fab3e0fa987cd3eb92f2fb12867fdac7579ff08888cd5ef2b834dfd0d984a12eb7beefe08922d3f34b609a039cd978dcd94ee8a4698ffe58c6c16ca200e20f6692aab474c9a4b40875b3bc8f1aa4437c7c489ff6ccd3a49be5d9e4ab40b6498c76c56d9bcf41099be3ff7efef6757f2b55022a14ce9f1b05d18815d0233eddab950ad79109203c2b31006c3a6cebd54815c9768d2a2e8848ab36536895c6bbf3c057e22552670c7db784716bf050c48dce8992e2e304fa190e1764a15048162ba074f0a85d160d483d954dc9bd39a1156aaac10f84b47164c06c9eb8f1c3316082b7acbbd2628c98ced304ad5a7ac4abc7d2aa8719c22b7566dadf0f0b711794baa9735fad01600449c243c31fcc983454900e6801878377d838f5b84a09ba6ad2099886286f4d19b7316e0c0882680c5d236f6096033045b1e1ea4776b23bcf48b201a236fd2e9250b384a1e5a46182027ba5fc9369341276c96c857adc59bda1c39f390490758b65edb4682c9e5db43ab77b18444180cc333a180ad6b3273295504b42cd1c48943e86ea93667ae3638a227c9257adaa8b97c2636dd130f33cdf416f8e73d12421f706ef3147026639c2160e21ee5e21a75cc4ec31a16b0622e7d32601b4cb73aafdcfa0aafb001db19b20b63bc52ffdd9f55c454a7060dc050f1a8e8e75b968f1a7050d4df49e009647fe175afa290aca2a27eb240e8d8bad1e34deae13865ba20d0f54b65f24b50414b9a6ec905786310c773d2679f054fe700e2e75d501c0862028a0c2b7429ada374f62a9ec0947390642687ba00b57bb7ad5349e30603498208dee347d21d637b3219c234a147993c8f83d19403e8b1fb21350238f150b91ba8b9314afe6cfc7ba3e2c225cd28b896f48d7eefbe499c785a423f6bfb0b5b8af1ac43a2fafa7aad61b6784aecd8b34ed55fc5b56bb92b4a389298d1d5a5ac1f9a6bf297dfe74eb06a46a27b3b3497b0450eae02c9c2f441423fe44fce2f6ae466c7fb643e97c38a2452570b5b43123ee81c867c964b31d13834c85ee0a3c0e5c49348519aaefa82458404011798e66ee05d062ca0bd52f552f7ee0e1895f5f2d8e33f17f8c5dfc1dde583adc69b817f10fdb31c41e3837c45b5be11334710b2312647b5ecc9dd9a1407ebcd8c8bda0ee5835c10bb9cfeee779c7a7bd801a96b84c670e01cee4545f98ac56e213245a4a73ccdc2ee8388e41fa8102c1271d096095a9c86a465962ee968fe14d2c8863e2d649f830555f41902f00f337c29f88bbb498054a6560bdb8e9da8fc824a4b0285b66be46788ddbb1bb0f60f921fc13c92d899f3313c560b70d258f6905a103ed818eede7fdb719c757a0cc117aba2130a174e4f907f738086832be30c11dbebb756b69a75b405125d05fb3ee865add57fe414347462934eebcc01e2504135257afec78031cf63139147614529b699dc178bfc4f30e7da8d5d3d2415a7b0259188be632b4a43b5dc5a46b19d04f367304e5b6c6b2f1f05ff0040c55fc61193b2e66c56c76a88651433dcafd8c303b8cbbabceb64e59d64faf715e718fc4485ace406c288f0ec6b0bce5ac34df2fa9fa9849ebf63961f1fe335aa8d150e4f3fda1dcd7b217d42fd658fcd23534c17d0b3cc3726ecb38f9611dfeb4920a68d1188e0616a3816b14f3a15c06eb5e7fddc65ce9cfb04a0efe784abd3de95c1b02d51f0b6e511f4a8a0b62ca00c7ee53349f5dd104a4e8044d07994ca2a21701bd9a439c7578d1a29ee28a054650ffc32ffd7298f9c1b5e5789fce6c3558db9feacee2859a05f15ae79ddd1dacf8ecd6b478472ed4947a5c37003f1a79ac305fc19f53af6138c187683b7e049fc51ac3f69ec26488478d3258e6da7924fc93c7fc83027d3d15323737b734af2dace52ad79c4d8815fb19f7e0a94fdbfbc6b60b8ba0d96236edfa8bdd0baa220e65e548b0409c70cfc9cac10beb390b8aff9fbce00df574136c870b066b9e5c893cb4a6d6c8d1bb9c202391926086ee808e75bc8851ca960ccdbd710ecb8d8322b45adf1b9d5578602448ad1c64ad587a89acfe8ac19983eda48b523f59ef6068df4c02238d6bf3d114677e10965033b058302689872c7358edefcb1f496be1121845b1ea3dcc499c8c7a6227685822564533bab888e0d7c8eeacbc93cbb92d1a06d81dfb7f9a64208750811fbbf7dc55992e96b81082c2fcb519969dd06feacc0f800f8bed35791858fe0d10a096395da1b0c90d3956b40b50d40af945450aed3dc52cf19221e2485f55142ca389b19708dd5ba93bb35a6044fe4c939230f7535cc33b142d85f00ee674567aec2eb6c6f261eccd990cb4e216d3494eebef97f8a9619826a49b578200e84e2c5d2f488babd74db3dfb9b090ec111efcd65eb40c3aca1b79dd6b775ebfa9d15170649f179b183122e52e490dc8c9ed3c8229cdde0537f91dfe6c739c8acf17cb4788953dc17e834df4368809ff8d0e72e6ef00413d48007aafa2f8fb35617c0f3f0bbc6e126f7dbae54fa9060884c49913a543ab2e31c84851e9c03ddfea26e7abfca58659b0b69f0978fc52141bb82859a7b1c057ebf1ee16f5286eff55ea9f432dcdcf3b6e97d7f8f185e38437bcf14bcb82095025d5d99b31dc2c644041b50a8b57d3ee9c46d909cf70753f616c5a1c5e511f0681f358da1a03bf46539734df879c8eeb3f3ba5fcfa3ca347cde3d230365a6a9237ae1ef91d7cd625b6f9cc0dd74ac0a52e61c26e99e88407226d76fd2f627cb1ba4345eed39fa72cc81ddb974c0100152b63779ed666008c7ed94c378fd52c6eb6ea8668914a755d50985bab345eebdeea62d2bf9e491663a219cb68cb6ab42c169cee6e04523a19d6529a491d8801a0ba690571da02c7ccbe7117d18c413f61083f0a944f3363777da9d24c2805c640003ff61d924ce511629d48b45e0b7836c8712d4df2b6f6e0b90da2a3a9a016804a89f9c7b5528ca8c6a27c14d49552c9e35a9835a0b02f62f6a870a815672884c9201f456e39a748d04fa6bc49adadacb39f4c403f963fd24878c7b9434d73b846caf78e3cd8a50f38ad7a84ceff266cc90bd2400561b6a12671247532e6eb97e98f4a8cf958790c85899e9062eab2cc8cd9b5f07a0d60149ad52e31a652c0a9653643ebdbd2f2845dc78c83cedff2bf73f63aa934467cbc180ec9dc591ae2d3ef42c2f83d55db40b93460b9edbb94e670eed301284e2b5df0a1af4ba1afdcf14c72bc2a733ee806728da6e62a14d663e65eaededdd06f8a0ea91f39e0cf49449aacb21950ead82c8fc38614763bd767bb5682b136f60f21f2fe71cd60f4394435bffb47f5ce40a41c4b3fe676011c66e22e5b251e5cc8a4cbd23e2751fb2bc6f0c38436ccd853b9fd7d2e1caa7bda26fec40e0ece82e6230808609ed53953ec3dafc52a9fc48f96c23d9daa1ee619e743a5e51da156021298fd4b58faebad3f5a65d01e17090ca52e5117dbba067a00b3716726d876de9a3210a782d8774c47657252271e9ecd1c99accc2fe959a642ef67a58a85f937d7958518f974143c9a91a75557d62f0d532116f753b644651af740323290c9f875d3a5ddc09bf5f16435e90d8f0f67a21a9def89d2a29eecfc019c575c0d4242b3004d89310869eac99960c4d494d2a238a88880123a59dd1ab896ff4029a5db474756a8ed5373e3411bd12fda81097d579e00ae36cb1620770f7af8f0ecae76c672c9b5b7dc6497ebe3959f126c3000c72e98ebe5d1a7ad7dfa1779cf2cb9e74b25f46b219d90aa910c26ec83e1019115ac30a1a9f644ee89ecb7015ff6f76d6610c02fa3e88c5542df7c391c74a241c26c1fc46c82cfea2bacb780f288f499b8ce3dbebca3e956417c71b41a0ce7935826a60a6e813df2d9f5bd64e99367e0e4a9ea880d2da915eb447d29b985d5d454f37e399a6f17331bcb923631c4a8d91f41f2f1041e4a1843d2e4ed137ba630869074b113e8810b587e588ec85b6c78bac8b2ec99bc9058827993b2019322df0f3fcb539dea08638631e543d32c6df92234d8d62d8e16b07415caa986bae347e521ca534a1e96ecc297a448a9297c6f482d0e946f505befa0cfc0241004ec24ca711d7305bea53bfe36404f60818010aaa1181a688895b816b50530dbbfa7a297a47ee9f349d91dd6814e84f12006a9a8603102965e7179bdd2e6a19c7e153a781d11e623c66e2726e6ca84fe981d5c52bfd02d2465b0a76b805525de43d5147fc85cb56b0675df5613ba344bec01bd6d8912dd098a2c258b8dd2bf9d8f35529efe6d7c5c65125a2101cdc81fba618fc3d13c7b9f723a84e5fa4f5092dc3fccec4fc52b8c30d8bfb4fae8c5e14dc0bf0249b706d7fa389534e9258a4f62c866fc33f958eab1b91ea60a83898d04619e5e5e48ec7591ebdfbe50168e89f3e08b8673109900070826cf074955aa5cd31512c4a9b20dfa2b96fffa4aeaf690200a88d3df784e84ff618a4348282e863e0b31bd6e27583b8fdf2039e82add0a12d0898ca08dbf4250e83fe30b0371d768c01cd3872b7ab392490b7ca806e455bec264357b3e2d983392dd1ae55097901b03dc49afdcc60401a610f16a24fb12a7ab9168edb938924b6777334657f9e1ca2db970372c81c80d79533ee882e0f1619e2c3a2b3d1533c154e836e3369f60837970a4087c5c37612a93570257fd1114cec790b11bb2af303246610f76e1abe4130e37c2b257b0832e14531654ab9b5c5825319c5e97583ef21c6edf0e4c454c67a51fdc326234c57411cc9f8b3d908c0e15379ef6d1163e18b0aa3c0d93ba4ae9f8cb20263eea29dd77ada12c14a2e176152aff82b44434ccd73e8f0c3f2c616d25946ecb81680bbe20a3b3daefb511e0ec9931c2ef950e0ed1aee5f55522acb6f34326ead47e3ba8e2d788fcaf4386623741266b88542751c855eae813b9ef5c370e16c91313cf1796290c2ec91400284c0436319a7f3bca8692a49e9e3da584675c3d358c174c3841af55fdc39224384fe8e01fca6446b29aa6e85c208efa6ea06bc2aa7e8f6692e9ea0bfd06954e0568ec5f078a80c5f35d694da2935c9cad7f7021c010b86a9998e544c343537e1f37e0fb59c4db93702cb37cfb9315c52380d95f1d9ad015ea5b68d99033e9cc6af5422682764d17cfec239bd0fcc5e8dc114b05e02aaa821e630efe08159d498aa6a66c1f2d8b45826ceabc17a97986de84478a33934f32e5a709c216bcbde23361051dc6ba838c19c9e4c490fe556ec43da289a739d74f072f7260e53fcde0572c6f576fb40b4e14c049a3b44fe85ee9e35a0d74eed3d1f4d61791216eb4aebd4eb0ca0171267bd2e6412710cb4d18e5cdbf49a06cb2995bc031d2aed5355fb6ce7b6307402950231d4eb3a54bc9d8460e1c9df3764ede79bc588edee637430a365652edd5e663e01f7891fb60c1cd3a54c5229fb9452c4a6b89f2d8a2c55dfd98a935f3ab369603fa76b66f301cdf64bde5f15262c8305bc9a500db0d33473773211a77fb2c74b99fd40aae0d4320af899d560af3e15d5ddfc8b77ee77abb4fe77041ebf2b1ce6a6169e54813968a624947efe7d24df3e810e68a6f871e9db003ed37c4e45ba6cb2722ac1b484756584e751d9690b0bf36418379c0fcdcd5e0045637186e0f844c8d6a787aabee5a6fe6ec71a5e9dbcb52710cb8e898c359a7bc9432e60d6756f7eb067e477af40bd86fa6d68e339ab3a3f3e167510eebe2e76076c58e1eb19d5bf3d89b628729abb17e0537556f501e2deaa55fe71643b4fede686d5799641e39b38d5af78156376b7d859c26e47c4797c21deb5efd9f867d22c653ff68a49a70673d7b820319a4a0ca9dcb46201ffbec826111ee73d12ec4383c7f8ae3982c4d99fd12313030c56ef920ef43135d1b1607bd433ca6e5bf8954e3761fa017bc255bef9a98e7bdff33722e3cfadddaf125e37b019735a0d35e48988c09255740a46101b78df8536f10119b3e2b958fb1110ef635b35d6dc339327202bc204171dd7c384a358e13accfd415dba72f13fab32eece75a156a28d3a95eb2ca592713457804e6a58ac20612587e0514a0e24a8a81b1ff02cfe7f2b80e66dd121e70c5894488cb9cfd49e71505ebb61bf18f59a48d3d77db900ed8f520d20f4c55aee7e89054c3912e59a6d79f23bc712f10cf17313c310e5cd10b8042185df214cd3c15e2647cdcbf3f1e1e870bc715840d47698948223e66a1372073a2716ed06ec0178a69dc5acf04378656962eb4b8e995f5cb1005e36b937a1a1d4a164da46ac279542a26f92b73169fbdebb993422f2738ef61697cf883ae6e4b78b934682893fdcb5a4f0c5a8d6b4d00393b2a46edbcdae070f976a3493e161a926e3baae0afa569611d55f6f35cf80aad9800958795b02645758c594a2fda5b5a54d432ff0ec29f2e6c984d6c894b755c59665b9fe22a58025a7ea47f9dd2333a2927e836dec04bf9b4dd2558e4ea4a122b429ef4a761ceebce38836889c2204b7b9562786d12070417ddcc2f30bab68861bf28c782bab42dd2fe0c0be1eee8bfbe9f94a5a003086167ea54631bcc0b649b288bae50a093a1631ec15c9b37bb9ade2c3f3b045eda9a20682aa84944b34d8d9d1db67b9be2e274e87712a90ee71570716e08ac6dfcd6f145b82f829ab1e224e73bfca387e8b4e6e956157695b93b20d13d111439e919896b15792d6cdff4add679db4db07da57ffbd9f2a953a4b0ddf86bf778dce411275b53d2671c7f7e1a69694476e4407bd3404fc80c1c2cca0bcfc0be88a8424335ab322c20d2e653f7e97780380459fa9853fc62aba6bc07264e605858fb1805ecf9acaab1d56c28c9006e1590580c401d8b733ccedd9ba029e878de5cb0e478eece073e0ba5ad7097d4b30f97479c3af7268a610cdcc0e4bf633f9bef53c560e61acadffa6c87fc144382dc30652ddc45a07fb253722b07bb1234f19d1ff3dde49a8c500cedbe5875b2b75b79ffbef216c4adff64e4e0eb3b58fe1122e9962aa337c82559e240945e2b283f803cb3ddeb4cfd9e38b373c3ba016cd453277cdb4420efa4b0e09cd3e51b1c261a115edd51449c1a2cd723d11246914937c5ee8f6f734b175c7c98685f26a851e9edf6ab9a79de64929634a8c63d2810a13a9e758a90bfe540dd16e4d6476d5688d0bfe9a947e50a32f795d962e0519e491ce79683e240eb66a29092859f94ee97c848734c64684a13fa77f2b7d40ccf297516abc6576ab72cc232e8ffe2a8ae0053dfbaa3994aac72ef836b1d6302db960a15314cc3c81c640d31f19788f8ba7f54f418898b9a1dab48b968be080bd0c3016f968c8b2759f3bf96c81c1cee452cb26e62daad19772b93be550bd58c953c2d4038a7a143d1fddb9f138f86ffdc174d8515f0f7a85a3f435f2a7cf0c4061d07fd13413be3afd343e2f7f67621aba0af80bb3b239fb4bbc8ebebac8e35561ebbab481d4987a1626a85c87013fe514bbf637c0770144cfb4a086594f4a6a5d4a8ff8e4753d7e5d585b784530479a2d8e1c9e86ad9d4668c0bb82e29f74ed7da7ee798a39f04eba32808cd1c3505b5f1f954f6384f66e6d36f296529cb266aa618b0c7f5e2d7d650e766e7648e13381bc3f76548cd577d695ffbc9676072423ab718ac78851ff19246dc408547026ad43424b01ba6a8b800b8e5e4296afa4de4ef026b36ae9776cb7acc71a0e2789cbc4ece88ad52c75340b11bc3c710e919ebdd39956628a45b7a144b1f061292fada95e1ebb3b4c119662acf8157a7947282ae1467bb392cb8efb8f7453467f6e386c29d75d3ee8170a0c2f260c5ae3753a97536a436d9bc16b4ade2eb81ada381658945025905e65c3136ffdbcb3acaa0f7b4d510d2d421d154e254f4967467aa6ad83820e56a85ff7d0b549a6c01dbebd5a35df2cb191469ac6fe1826c4d7adf7de09360cf239dc696bc58eac50d09730abf326edc595718b38f6ec490d8f6bf2c85a0ae4dd261773f6fd7d0b4223c906bb3ba59e5167a684cbb14c9fc9d1830210a70865d7fff02147cb4648cf788025bb9220399265dfe465741be37829b68b26795190e50e3785f7ff34dc70080b2a28b4d06b3ae714a7bece3c4384253cb77d14f4fefcc81fcda2c9287a4b200d9be618b8d080475e601e366be663b929cc2d4bc3836ecba63df7d2c9e250144e3ae2538157ae37b505fe52c7fdd71f3ee56fafd3ee6f218be6a29ff31e1eb1890165776ef5f4cb7e12f38e1a399a0bd27398135badfe5f54223be6bf21d3568eb956be0b1fbd6c13610c8f095bc96fe84024d2594300db954f7f0f07623620a59e948ac3cd3ce00269a0fa59729c98de030abc167bc575137d845437c017df078ecfc614199bf7adf3bf7a159891d4362db7bc409d9db5628d1a54ca440c769081963411aa367f836856c4f788907da7c7107650376907604904fb925e756ae6ae17ba4761bf3db24b1bebb541ebf14cf8c09c69e7631b28387a4cfc10ce5a1a8d6da289dff222935dd0df695fe62dd6b223ffd844fa2f6b701450d7985d8718c414b899a73e375b905362feecd88c994f82cfc0c8ea53411bbc0f8f93b703afdfa87b477310a07e7c067a84e9d4ffeb5e9069bdcc4d78603cbaca9ee0f33ad5474caee80c3e026084aa07af6ce77c8980e57fa1cf21b582606e154560d4da4ca93a549fdbd2baca24ed4a33b3a8f60eb79dc352943eae40f15176221a61ba0db90fafe6570f05d9816a764ca4f15d87ec7e6607df112578853ccf16666af2300219918557dd5d8363344d6b6af6d1d5f470a30e1f0c5f28de935c89d91ceb2158ffc75f5e857345ca44b8372e6b313f4bf7772d7e06d01f832da3b6071849353912c685b38f78847cdf6256262cf8744b4d59c2dbe6499f0a482e44b27573634f6873171013053ef163aa4f1703f044dfd36fabc1301671b91ceb3d95bb13ec38cdd5607117bf4f9d6ebda9b5664adbb8b9f40964b90b03348f1a1f4cd49340a38dd97326c12f055659c767d997fb0cae0a62b71c7b9a3024256be0b2008294aad00891074365ca5d4235b1ac17ded0b909a4627211669e0133f2986a4a04a948fbc9672ff63b66dcea8329712488fe394dda6ec12ba1296aa6966ce25aff6a29d50d27b3d62987f3098645cc2d50febfe2a163a8af10029def6f39c31043c3a5e778c3e4d1ce08108774a2220103379ef6a994ca2303e54a7bd9f94f87c9c4ee4d64c2dfedff3a73464fef90e4ea5bb615ff6e1325b022b3f6bd4669e696cdb09dd5063391d4c248ff9e4896ae74262126e7fb4499d530f2717aa0e0c2e138e9d5a872a83cb79521490b0be980a745b85da0f8edb39a35571ac12addfdf7c863a20d2f04025f8eae3151257b9ceb668c7cb8c7b18d7372c01ae47ed28ac219fd13da689105af9c9b80e37fcb3c9716131007ade61f6fa0ccd124374cd7b9a9c6fe21cf8905eb0eaa59f43981fd1858c0e72ff0184db51552082b8fdc41fb7c35da6e62c0667f1bc4c92683f4a26c33f338c525806de5f68ee6dbde56158bfbdfe28bb489751219e3752511fbcedf27aba1f061120f3f3fce2521e82839a642ed3e61e92f37abd5b26bec842eaa58e8800d12d36879d244782824f54f1018e28343780b38e99e8a20edefadff7b603c32babdc2e23df23a0d3a14f3c63abed9d49c7519a8708c09dc4f28e83a2b389448604dd8e926ac6ee36d0992fc6555b60e1a053b67b1a56c0a4c55db99daf54b14c19cf877d5a3cb62f82a97ae102e4f0caa21243d0d30467810f3e649b0c001b34c73cc7df11d946707aaf1bc629946351f3ed303286789091297c77c8eb3aeceb647648eeeba0dc8958bd83a646ccecf496fc1ea02137f893cc30bd32049277f78e9ac95c74269b3efe13d8e89a0286f1ebdb9611207108df9c6af6e4e91124b276e0721a359b16a58aa74ada2becdc012892f7329ba59cee0ffda556f4eb34af2f61b8bc6fbe23ef89395a87114319c23bac6e3506dfa29e4560fc8f0b43c8a1703983232d558a1b563d03e9228f08baf74e107b66d251192606db96eb736c203e7b803b52d00eefd594c752cdb2e3aff0d4753205c598587cec35771c898ba692f2b75963d9c855f6640656f4daf3b176228c413b6a43830075dfbff7df401e52165e06ff079e233bb23aff99a6ef1abb7783506c5415fd021b6b027f49384c29bc5b76f43b5dcdd0aaaf9437840fb8c012ad120ec980405ae86585dd3d76fd0c25161ffbb48d15f9282ab4d9ba850810abb343807a64142fb8ba0fe8667589207fcc2c2c87a3f913f3193dc95118d2f81017c0c78242e08b691c18e96e1ea3dba9c5198220d3bcaec96d27cfb69a10d15bce9f80a5783532d9a3666d76329353966353010d31efa00187dab7e6d6834a806a80136c93f0b514c6ec58f2486f85e27102dbe77abd65dee8c0ecb76baf55b9a6fc5ddfe91139c634606e983eaeb73979a4a505c18df9baf08cfe0fc120ea3d9579732fff10007e0a5979276b390598b574141b2fcc6f980a1a2e298e54997326d4f255bb34af91906167cf404a67e861e8100abf2c481faf9ef8f36cd9e81624342ffe689c8b64a929a286a5021e552fdfcdbde00cd7e814240b3a4c623e9819014323534faebb8d04e9217c239c3a37bdffe9f7f693196619e75dd8bb041702a1241f9713bf7c75a24578d94598003abf07ed9a014b091e8401da10898ce3447d0819fefb78755f7b8d5559f761934c7afe9731e94717a0bfd1c7966216c5de468e65c93e8c427442cd772fce5eafeedd3fec124ec0697f6ced9c1cba65ae479deda90390e1b7740bc254b5a3cabec952cba9fbd8c276c58095e0189a159162e6d163be4a3565b15d86c609b690603b41b3f0bceedd4d6b137a13947d980bb234bcb0b72c2628ba131acf5eef5b59a9030ff4fd71a4a010aa49767bc69b7a9467f3db19376e6b998884371c9363575ee3ae5c6f91c2662090cc7f338fc5684047b94c1d32b3165ff7d151caf77fa6c4512a30521f26208db4ea66fba3974b7c8f30f6fb7482bd97a306a709d3fbc2aacfc6f3077430166cb18384a76924883d1866ef28d27c260550ed83782650af57219698f9d0e907a456a99980c55283a5db206fdceb7375c986a776e9665d9f7308b13618dd51b1b63df3931348657add9396cf21b2ffb60ce973c311be20fcc0dc24a8f219689230f40f63ec9e897c2462519f8fc30f80d0fb2fda5a7f7e7f5abf903237fa0e98672adcbba6c5d62ecc82912011428c5af9cbf4458e61094aed976e8b9db88d121aa2ea6de3d1ceb9157c0415da3da47b649435be4f9607bc3dda767627404b043fc088521f02e166c7de140ec1ac1ccccd275cd8bef92dd732b5201be2b182ad63495451e132120c8c148bdc6d0e54f42fb9833c6feabe1063a0f39608852c87ca8f6e4ef8cee7009be28b1ba7c641ef6eac2aeda680ae851b1351bfd20097bfcca929bd203dc771b089d97bbe05d9de67fa109045537557e9092d9a34e865d2220710f56be1423482e6d2551284000b0497e615dacf42f41ed78959584232ba4239ff04814f04d74838b56171f946f967ed1258f91e915ec3b09c97f7c2da0ea534aa9188528e755e8c59e6272edf914d31863a045315812f74173e251bf71218cc43e3ecb63e97767327e89eeac3de29f974e114f9cd99a1af983ddbbbefffec35cb9877a1a5c4bb8e12233d4788c9618463a8c5d53bdd2b98e479edeff5382d96c4158906d9daa92b8c0d51be42a787382d1d3b25e1a3f8c450fe980c05bf48bfeda52f1e4932a8b48b318f232093f48af9fea24a89838e5a298ae11e35579b5e7cb7fc3a80236dce8d45a4edebf588a59e3d7806ff7b43f9d1ffd47223a0a61c42571c5da428ac1e7a90f15cf7b6427791051f7a2703e2637f4cc2171fd757da88f5f10f0d60f177fc2031eb7b911e960d4837054c7cbdb9100e7e5a4cde9925920ca4d5f180aebfbc6ac96aa16c892908e2163d738252d3e85c1792769595965ad982218c3daa3c0feadb0dd17e4b70f9d509b832656cd8ca1e65b9ccbec25779f1cbf80503c43a9896fabbb9d440a06ca8189c2324cb565b2a277b703222b95c61cb8f264cb101c3529559506488e208f28578062fff1a5b84cd61d9aa52d63277044ed2991e9c8340e2ab80234ef582e5d30214400f6bf8dd529727e11fc8c89f4f8dd4bd1e8dd7acfb0aef047fcb0870942a72558c1c8405db5fece8c80228ce47c12a80d54c7a0479c901955f4199f6d792d3d137cfca48b44140b0af374a6a39fcd578896817ccc33eb46687de82b0d345753feee9c29cc7a04f92fa2a8270be9576c212b233da9f46253d3a86a17753b67406b3ce1a2630237b0b8fe8a09ff442581a0e4696f0e3859ab04fd9f55b050a6fea43a6805ad0a20a45b83ef2b84d09e6c270c736a6a9867b5b28631bf1f82b4f5439664cdb757acc9df117e1e1c3590e0bc1f0b38fdc419432add7adf6c7ddc8af8795fef1ca748151ecc5cfba0a967895bea5d8cef46e3480399962eea95314b3c9b6ed6a36bbc09149285c08c3373d1e60388376cb4a40a1741e26faf31225dc7e72215cbe0539749b1bc1ff6c86d0ccd5a1cf3b432c2b591f6ee6bf62645511b1463e78da553ce88e7066df0d8711b569981fcfda3d02b678529b00b25910fec2f038fa03613650a2b26258ff6628f4978405f01f4d09f3fdc825cf0b6c543ac4248ce83efe50419b9cb7c3397ebb0c6e89dac900616356e093f200ad9a79a98a0c529358e9a90eca154a97cfa37411770ec24e2429bcfc9b3b87022f1843a49c0b9b5a92e126da9bec788d8fa26964b3c90a1f49372035e55eefd5a6a254a79f0e78c2a9478bcd911a950e5a35fc259de26c1a7fab335b386a96ee56db96471411f1b9dfb9f756070f3f6c60e9a6f045034e428c3556e0cf1880b26903a7bcb7313947fa396c32b2ec78b51afb62e420ffa2776433a12f4e88169c9d0142633b79f0f5ecd467c8648fd65dc94e33deafdbd13b79743d4b2ffb2ce47a55ac9343a80973cc2f8bfc4c70487f560499cbe0a651d0d5e1a372fbaa97a8ddce348c4107375dff02cd602aeabbe509d0bd3df57b3c200b96f333e6b384fccddab1957c1ca4a55a119b769bb26ea6aad61f25b5268e5b8360fe8da7cde4cc7db7d7ba81f41df038dbe9abcc90ce913cef98534ba0fcd44f022678e7574ae2b517bb479a3b8b4cc66aee3e07e3f75bc39fc1da8fa73a78ebc7f30cca52dcd7fb10d24756f3b1399fa76bcbca9879b2bef8bf0555c3c729886f69c760cdb7a9da05865c13d06f28818ba398998f4eae1e5a484b6ab6e7ee49a0ce67cd9dd1b0d1fda493ca67259c6380644e647ba96542c57ce70e31f94ace3c5ac0b13b0fa1843515fde272f6da8f25c8b2872ba259a80686044b5934145b334ecee73f1b54d0e9700c092ca8ed1b4a645d4c4ff4b14c1e0c8ddb6725261c84cbb1dc86ca044bc825ff4d383e3a04cc5288e01256aa2e9711c60dcf0401fa7ed82cdbeb59f31dc355dc79bd03b8613af662c36109d437d15d1834f390174e8d4517cf1bc9b694f3cd4e1a934dd09f62c85b9ac3d72e60eef30468618cac412f27a992e925ad7e920d36fd2cc2f970ea5e0402825238a17c86600e41fed9e0be6381b7c6979cc129f7ed6aeef59a474f23d8ff378431b623fe3f1079158e7a59fa0e98840799b062b9ef9ac9b35d56bff2dd7da05e9c240e39990f6aef56c78a8f7110e6d1456d14c9503d8b8c691c8fbe1d67b857109298c2e5c517a292e20ce84ddf2ad73577cf5f8a0f7b215d006023760ae3755891cdd6720a40f0021eeea2969f28f6b72f5641f598be9eddc423f208cf66af47cbce30bd790b5530215d467837c57838660d63e43e39f9933c0e2cb79f0fbc40a8a892691c35a05396d9132bb48d3772398a49a3e3316f0457f759cbda9089e75df6dea710232e1de31a5ea9edd244faf62e68a068afdcc3674848ca39985201d799b8ef0eac0531d8632c06119c5b119ff0ea28d0d66d8e64bda1991f0459af7529606edfe20ffcf7589b493c09c8e28a7ed4d28920a3128f149d32b11d430eb154247655d1c7967691e5146ac49f8a19cab20ba254f80f2f18f06e32d007e4681f895b6a7f2eae2e08e23d78f8851c2ecba1bea103ed435778d2f9809c08dcf36752ce17ac2af04934684cde9229656268039309567b6110f57c0b3bead77a826e8ea3109a7216b54f097f2c9c85bbaa9f773f6e85eddf20e5efe032a543ee89e0f4afc4933f2a7e899dba1221fdaf14d0cfa7cdf79ff90f6f5219ff06eaa89d7de57df881d6cc55b98b8c4ed6514c822daf4a450539ee5d3ec22f07f45b0583ae10a38d4c89a5c274595af72578df74fca2e0ccc928a706b80df42606533461c6c9fa8b860d041e2568729a47209161c97219cf5dc60532e5796c5685ac1989b8e73c7eeef718e95292d31901b52b37d01905cafc70aa65901242518c934ba5e6e1c44668f235fe9a85958212b7eebad4d5f777e4dd84e60837c65fadad978de0c16e7e0e541572b74c94d20cb854878b676725f6f3ffacd94d6150f986243ee4fb5989024210337d06e956b90ac088e2ad439e8e35c770a778d0ab809ca46fdec90c9bc4657f1db61ffe06ad8fe414c128d244d123498969682c8bedcbc3eb02c7f4f488ab7670ce05a66147266ab9e33e86d7e4382fb2d6786e99f64a9ec6b3b0f75df371f250a509cb9c8b145c1dbea36f07c777e520be567b743f28cb950099b448cb0953c47ac5bbd415bc5cbcf8c4654f6c3fdff2c7521e3ee1a0b8f7fe6d0642a2695a7dac57b9172dac806a7a397aaf39ccea7df9795844df47b14248c34663318a4b1a075971a999e34cfe36c53dfa2a9d29e641ddaed3df8e70fde3a08d63f1c8fa4fd912b88f4181c413aedc11e2a6a5f291fb31010bd665f98da04ea4bf51b17c9479df0d3916dbdd147ad0d3613a2572fa39b0e33792c438641b4052d4fe9a676703eab6abc994ddcc37ddd5049697a7a2617ae3ef12d5f3fd065152698ed96d5859ce094ea49cf9a2b700ec031e83c52929feff4b8090275305fd359fc13e006021b3bbbe619928152ed9dc0e697eb27936abbf2df9056deaedb13f692cbed4a5830654e9aebc6d91ea1ca7acc81384fa47100b3627b98736e455014a67b2f7f8018ebd47b1996bc29cdb9c65a7ac7def1c8fe19530fa528cf119fe473467745d3588c050871c95df839ac005dcbfff86eeb9eceb399bf4f2e005720c9c3cbf0a882ecff7682b4bf82d267ebd6f1cba1c51a574e5aba132efded968d299f068f135894e3be021c041e1a3b510211b1959201587dc8e9f810e0d9ac33eef0ccd9b0e09aca4ec6b300bbf2f3c7b70a33c9ff32ba00179f599b6029aafe0b7167ab6fa2025051c2cb2a50a3aa78573ac62d23ab7ddfb865b3be54d2377bfcdf35433e6944d7dab106486a20dbab73f4f107bb4c69b41b3dd5e73168d33e4ddc9fbe3a4c4d22078dd51f4d1821b5eab1a370f1be5fefb78d51c523ddfc1e79c6db3fd7839f7cbb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
