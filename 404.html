<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c175a49bb5f86dbc66ac5573aec2b0d992b4c0c5371ef1b26579722d024f785441cb0e92c196bfc5a239d7fb830e7b03f39318917561032e2eb171d908f5e242e595d8f3371f511cba3d83675fa28a4fde0c8eaf2af111db8592b2553085f405ced2c8ad42f2c0d3c9c47fa54532008c05e707c7300f01acdaf9024fe818a6d36a1527e362f155fdc55aac03820a044b8bcc45595a8e8d7a925050757d9eea5f1c08b91d12155eaa948230611ad17bd439918ca1443bf53309b1d08463b63eafe88aa8611fcf21dc52e5e4c526a61957cfc41e2105edb73cac9d3485ba9ddbf998791adf2e80dced3ea159fd473aba255c9ad1e472b1c482bf56fe94108022ee288daa9d3613e28d69cfe61f80396e503b46dcdb1ae5b8cf62bd51058ba17a4d2e5ce1c10f194219d9560f3938e502d54135c525226552d9dadea345b5157cba528d1e610bf3b64b013caee3ab93552cf6055ef4be5d8d0cdf41ea57518ebfbf283a9aede3f6423a449dcaeee830b365579030687501620077bf75d23250589b5c27f346bdec32e3b8af8ec5db151279241f4a8d83068296f3f14d3de012003c9c163c8a201a9e596535e2758018ede65e4276041ed37825f92b80b39a3943d5fc9637bbe146350af365809515fda0f192e7a67a7dd3199dca9b5fceec111726a63fe4a135cd9912da68fcd219cd6752114925225f790c7feac5ec30d6fab5beea9b9031f070ee50ed2a0e4490ef000f5a6ba414d7bd536653247b962e0f6e415692574a736a8152016776ad6b54f19b0d6009df4360ba3392dec71f21eeea1045f90b4fc06be9cc7da1fd252067fbdb60824461f9234a4b93920d5ed2956739385fe4861e839ebd01790590e2617b72ebc66257caee4b4cb8178f7839781c4daf2916372c172eab42ee90e93f8500d891ee684245c0cc3ec77b1925e077a8df07ca1feb0b70f00fe8211c410e4c9e9e42dedfddb78fe081bd6935a3a70354bb2074918e90c74ee4501a51151fb1b12aa3a3cb874b13172cf4405e890d24c0551297ed176650bd8132e208f1b6b79d684fd70f9cdc92ea4368e1a834e90229978f362d4447288b2077f6676425447f7242ab404e8a06d9953a62345b2010ed2deca5317c7327b8d50ee6e0b8785490e3791a0ef750815d9636d580d0677c0f2982905870e3e7550295ec7d13157020d7d165fa2a04f7a265e44b66d20a8f10a0217011e90022d553eaa6e7b7a8ec56f85758d31e85604a4a38fde210acd46de3cc8aac0fe164a7ec82bb1fbf58b12acc76ab71a8fcf4d250da52ac00d646b3291399eb17e34cc8d581f4e9aa02e465194be7989f86fea68e41e584fec46f7891fcda138ce1c7e288f9b992167047a79b29c76a8bc21a8225aaa0da220a91259a14df3bedba55ee496fb2f7d4dccc42356441490302ed1babd6b5531e4fb53b809121a45004c0b72087d6c134c0fbd710da793b074fa5a0cb3f9816c8e4393f178a609354e3c1853dca270df6dd21d218be5d855eb96d0858df25241dfb496399da6d368928ec7ec5e0f84727dd4fdd119ebe02420ac1a8e85165a671c84d9f9f33649711da2d8c48f4480e4f119c2ba9dfe8a79dd8fefbbc751f41d212475cb7b9fa6d9334b3d6e5ed8fac0f6e7789cd64606aab1f0ef31ac50a7298aed2875e1914c6f19ce9f9d0f282478200eb022f49f0d443834f3af450f3eda90187e659f69c6a7687cc6d4d7c1be71dcede57e71378fef021605b4b019dfa8e3e0370023ae9e7b0e73f9bf2685ee579114c33a1aa0a45e1dbf37cc1c5b2f1a54208438471b952bb2eee4f3ca09efdc1ca86a6c5840c9ba328d09df4a451872a9946c74bd07d477aa25e4adf2024d9d46ca5b07c421dd85e562c3dc0cee81cf49c52511b5d79e97742a6bc9896fe382a433c91fd59edba385814924318b7d67258bf42d136646365cce207daf930603c2cdc2eea9e1ca3a80b0fa5d7c964fe8603a3ca184d33c6af90f834bfeb34eb55353c2eb6b2e73bbeeb5ea7b3b3e8e05b419e3aec0a65e2ec861f77e3eb4b62331eedaeb4fbf5571e741dca91718ddae0e5534e2a53571767b087f12b03a3f331e84ad088f16f91453e64f76955d37e119a059d4805ac00bfcc01f2302808227fb94419d62f1e9cd15650b1a83cf7d65f922ba5d31b48a25836f4e16270fc96486d8418817781311a2bf47ca1b50e5a18445806096072e90d49f4bb560bfaa06ec6e950d67cba889068e3dd57975369dc40504adc7283bbd4cff684362db2ddc2d60dbf1ef16a2c7504a8e0f264e7ae0558faf7319e4de7e862ec3cc43c30191b3ec9d6bbc2e0047ad5f91fd1ca46ba2c9f684703dce9cebc6655f3e5a5b1d05ebe2242c5f216198f8372f4458b984971aa695afdee0a2244ec04809215869c63dfb4f99f59292e9ad46617d19d973a7525cb7e3a034e38a3cbb93ccfb0357cbb3a202895a084c1a928aa72b0f0a1429703a764d3bc99d689f46993fe2110c972688ec90eb4c0df692550148c0e143a90c886f7745f88737bf7fb892cea2be4dc8ebc22d2ee5a28cc4cd72626387bfa8969532fcacc41fab0f111b4424881c9879d8b5678b455e4c153514adc29f82c17f3f75cbd151304a0484d6a5202f0f617ddb44f959c243de4a5cef0701c8fe7cdb2782af3eee39ee05cd2c6f34a4bcd1979386f91382459727afcc2e79092626cbf490e9bf258fead60a191f56bb1438337a02d45179a2fe1ea375ebbfced6b6b3515959bd684ba7e18cbc92de8f66d7852bd736a762cc2d1f2f1a9031003cfd47107941be98b5f93085f19ee52892fa5ce22bea45e3fcaf4fead5b9b1dd070afd521593ee1eb84eaa143a9f70199e9ff8464ce436c9c1e14ab96b0a7ee11864e5be538f1429095074427cee1ac6b3d64ae0d2b0423372775ce15d139ad045b29cfc24d788b19f8a3dd3aa1adbba517d3373a13b1a1d4aa76f431013abb6ca12d3c0040cca4092e247ea4a13af3a12843b68a86516d267f23d346394db5c34ea786a91ee2265d1969ca3bf26637fc10babfa2a6a50a9328e538096f75d1da2968409a17a88fd71fc97e8b0fd7b094d60166a4ce0609448064446f59a683b41f62534b1e64171d1247d9a5c31fa65e7fc656ac7e28f4ca1ca8532e437823b15e3d64aaab5b943efa3590f55383a320dc8353954a6b3a1207aed91ae83cb50ab3ed1459f23ab7942319cd02a248e76900ce96725b4f939480d61766b4c72d5d1aab25f0890c2cc5cfa8a7b706d3b27c2181f732ed249c9e81b2d458d512ea5b397315be5a4f2303a0346f4b5a2081a7c975c7bc28c6060690cccc4c63d87e99359f5f129a40bb9e3db795c42b35462d0b49f7ea508dbccf11778c4959575d68fc592b6622497faa2e0eb4a6a78691078540fb120e3965ec4826e880720509cb188d2b222c730fb8bdd3a8d1dac6e9aa3c1b5410b568b4b36e4c378e4587848a6a3dc7d8d0d66dfb1855a842155a3910f277c450b2653f69f9bf339d82b78f5b2d80bf55ffc9f3eb39a0358b05c86ddadee33b24ac77b3dc7d850ab002778731d8846cf1ba0ca348a704a9ed8572f545bd68fbff2f8c917f50a1c2967c4a873e1eddc4ce225d7c7ccb449aa9a59621f8edc5d1ea517dffbf5b3c4f48de8aaa92e4ae69c32b730fbb76fb14cba2a36ca04ad6fc1bce07e7cc7b209639b47aee7db7d36d29b6a1a3febe83323a7c3d20eaf2696003576859ac608bf26670e188ae4bb8cff927ab749eb3be90f486a5b7112b152571a328b2643e81feb13f84eb19882f0509ca1c90acfe1ac4d083a3f4f72827deaf4506a87daada6f73aed3882dec3763aeede49f8aa8a39efbdf7caa1be43d3f387a2f9a654e8a9d58e801dbf0b2058966d8c3941fe551d4d029ba0936979ea2b4e4b08583d914304991aa50486b01eb31738fcfe2e05d8895f71962d7a1ec869e174f143895850bfee1bf64eb40bb8bc22e63e31ed6169a0c5249e44c733b0bc35a0668c684d9f404ac07841ab852ef1aa326f31970f033454e705e9f3a331dc91676058d90890d31701e583fb6e0feea890dd108eb9031a5a7b09f887a4306925180038ba6713126a7ccf4cce08468d79ea8fb8219d953aed35d397fa4b6fe0033058725e24a12de70c173d1c05de5700e94b4f989bfd70144619465c17ad5a35e5c1647511446ca09669f48302bc25b9f8f8492bb0066ce7ac4f535d8dadf9e3855313eea1210489792892c0dc410eca01acef4223409362fd0aae37092f8739b4661eb225609b413bc133e8c543760f333dd29208071788b219ea07a10715f8c7b343f3cafacb6f584012c8d7ba96b888350d1878344c9ca96d720fce02410211e408b9804276662f300a32018056a5445e55a7d36e6bf3fa9fd3b17035e5841edf82b2485be67ce4217966396d64937b2b6b97ff3897e34c6e18a68c1f9fa629ab68d306092cc6e0186506288623be9a0c7507658ee337040aace3baaefabfe3be044f638f875de28c7638713c055919efbd8c2cd4349f458a7329b3ab62da30ea346b8a96bbf6814666fcd4facdf28e199ede84458a705ad639df9df39f0aaa9272b4e41dc4d8da075261a9ad1e77c90f4848b9645e63b674d290a8e041391e377a0b2aa0629f94388afb2084c400dfd783bf8b6c69e123b6145c8af326cce01c193a6f8738860a6ef0e24b3a9637542e0da83325b49c4f2ef1c0b34c7643f7b4aa6a6283abef6c2e036217236b21f09b6ddfb25e5d50b3e270aff1d1db1ac628b129aaf3678e0f6772f49f48e8522a1cbb26bbd4a396e1782dfc9ce830b68a2a265e6aa9b0f7e5f5b22d1b476414842931a68f75e4cecf6108adb6b0c935693f8de7c62751ac17a78efe9d44fe13beda0a3821b8185d5ab7ec1ac76dc1c1538093268eec2ffcf714c842e8b1ab096f5a660c4b5203f74ccc9b10b3ea32be21e1534e5ae2b07919c1de607e9405bf1d462a88fd4cf13dd289472ed7329747b06df893a696f75134a3a0457fce2734242e99974c932aec22c74678d35267654ca2b1c6fd96f393602865b5f789b6c1aef1ccadf7ddae1bde31b8395d8f79a1bc8f78f6dbaf1060cb35712f9500f689e8161e5f8a6f7e32d43bb532fd8fefa61a3defe7d2778b297732fc6672b7e5d5422b27768e9671e642cb0a7dcda4be13a1d957699f9b9996b46828768d00d11d98fbe2cd07b49668ebe055986dea6657395818ef66dddd67ce1540b47d4ca54f0a599020d056781fd543ee4ee96a717d689bb77ccc56f8e198210dfef95cd8f09a573600a5cf4654a3ace078d72f4f3f6e64466240ccd1194b0a16520a7aaef495450af2ca8a8bbadc787cbd0e2a32a65f3a8aa2c64261d2cf7c239b31dcd15beab29bc1979323faf9e4d49853038b5548add1947a59f224aaa1af20f568564ce6e870832503f01e246814507c255d37d78a566e3a80f437be6dbfa30cc28014af1719de7d3c681864f3cd7bee7457573ff71a1b899f47f996539caa4f0ae5190d3d9af62280f0b4cf21c0a3573f734745b87a3e3321f8ab5986c7f4fd8f79faff5868e7238b701eca47ec3d401dfbfbcc9c603d4018bea66f058413b6c4f904e435cae38d0749a038c50ec2dce275251ad3293a86ca41e272da28d73bb02461dfb566b36ec248b61bd7d6b739a0830e440a25959256f1db60520a8b47307bc00487ac2c97e7f1fa8a5edeca0c5627823dbdaa38fb9c574d208e1c7e87067cf7637418c65e9f8adc654f87ea0ca9045f118ad7629467b5a3be69700cb4800624e6c2819a0a766068c8aa2f1aec89132cf4b3852822750fea8392053761a02bfc551a41294765f5ba36122aa96c3fe2068983c6df533207f5d35f9ba7af005a646dc1efd933eab6d6414806fa6b60e09bf85de60f424b341b4fd57f0df3d28500f5a56edc5836244626a36b755425fd9e85488c86d6f1e532736b981bcd4eedd2e2f18e31fc81831acf1de27249788c37198ded70fc0bb01f8228151681add871feafccc69e59cb8461b490322d6cbcbb5687de1cfe707cd157774915707551945ba6a04df9b0ba294dc8c8765e4998a68ac859a5f8b639453b9ff4d69378014a29bfb5e1cfe6b621bcbaa5270acb3a3174290025bffb17e006cb0f11cd891ffec981c900a6b2cf0de9beea04bfebfe682af947cce26d1505a9c4c30ade4aa0f2f1b3a9819c7cb12bc5a972780878f06105e96b6810f076a6a4228884faff1bf7ed1b392cb583a6c00457a00ef1878e57c7b3fc83fd6fea15345798167887580974eac6cbebfc31672c5a33dae7cabe7ca876329a12a56ea2a5cfd30b18c0a6b53afd16ec50d14bfe0cf9670e8b032648aa581d555d0c6285e12f335cf78b2fe1cadf94608ba370e019655048acbc3304fd8e220821e9a76c3ac7d59af1bd47fd88e68bb02bfe5bbaaf5d640fc297cea56794ab85162c5c3fcfd67722ec77558bec14492cdcd76741051957d72fdbfcd2c6c177a66f60a865314dfa49c11838200d34332188d1f6295148e94e8c44049dc9cf780613fc23fc253a6084ac90fb36ef9bacec7f47e960c4ad98d2bc8988da9b973db5aa591db444db5fbdb18d962bab87b2de816d451219789c3ca886fc782473fdb8b538e0e55de463c8a16da7c5dcfaa57a97092fc36d9da282a47e87f3bd85e61974bc728f8ea9c423e5ad3a988f8d282916a822460c20d5ed14780f4f3b38bc272f7129a607c25308acd6d87c48b72e4bc42d27f5162b197d2317baa2444225a91fa5855f52ee4a9b46d5acf61c19d85ba6a22e427d7b5e165eb65b92a17ab364e39a5343a08f1e8bb9a92958024bdf315e9493cebca286dfc057130d0c53c10c379d20be6f20faccdd3d69ee65b546b9ae7b1bcea575710463ef25f9b490edf93b0075d42302b4c0155fa9d942a0b01d4c4fb76aa893432eb025acf21aca877afa05a74ac2c395158c0f70424fbe1fc786cf9c30481d02236bda198f159173a2ca9d61850573e18bc7aa45fc70514490764cccaefac5abf8a9d904de1e6d214607369cfa9fdce2ca3603c222811e9ca1fac6e3222d46244e0643b299ac0a26319f931cf40d870cb35f31ba405d4dbeb1c1e41de100d2efccd63b06c75d56c8f4cab1a31fcaa4c76b888e8e3e6f01343b6adf4f1f68b588d5ca6af6788a9faa43a309d2782ec900eb7b49e308b6d7356b6a2924cd053a77c8faf94a845f6f7b9c2b05e6d6940b03b10ff7f760193f0344282583d866a85e02694af6d3b0a31a43d719b639822c8635ab376465ac2b48fb58aab82db3e4f5fdd5af223db4e4050428c03f9ae5b77c2579fa1cb79f463af1487f5546bb3e0bdce7a7ef1d667ea3eba9e3fdf434c6348228bc46843d7de62a50e1e478b9cca3895cdf17b5a0131c1112ee52c996c4f048ddba055c74efb228f929a16fd3f1d4966fdc1171358e90e05adf32068d18384bf6dfbfe2bb53ee4f90bc716bdfd74c51e1a6871d85070996c576bdb71f9428d870ebdf7d6daf190d36ef41f74723e1a4541841aef92fcf1ca14b3261c0bc2e0b507eb482e85e8cd39a39c4588d3857474c47d433a369f441591262d41be2fd8a07380b3b8fcd18124c6e035c90ecc79376e41252997adf583658b59dc44161e327dc478983d80746e327676937d72e42f94d0f20a3f766df598564ab20cbe7f9e53585541701c6d8afec9c18fc17caef61111c9923e5856c9eb338a3f4faa40ba57a30cd71b15ddf8934081abf88af41cf18cef7a0883f2f91b0b16b605b9cedfc01a185bb48c4319cdea61037c18109f3851371394c68f69c5159d1f19aa5bb046dbd6c20d62a533caaefb88dee738c1d5a444ee7d1d9a02c20e50729e18827384d41367e453cd45e6ab0d5e405513684c7ccaac1b04da1da5881fcd03c76df292fdcf7768a74597940c00973cfaf0accc9ca17b9036667a98dfa4024c1e347678d50b5d442d9f5a38c0bbb04a0a0ddbb0ebad8aae71807ecf4b1ab00d00ec90ff6d399e890e9614078df5d278aa7cbdd3845f48a3e35bc1f288dd8be6ede2d3cec7bb71fcc7e7342e3fbdcc559baa4890def2b33ec66e83e6fcb75a8cada6bf8e4df6a1d466f360cbe6dc7fab20e70e0a1a76adc30af74b1f042b9a0946ae7ba2f2a206dad28e75cf02e6e2a048d5c84e3b2b256bd10a151cc8061e7ee7f393c02b983980854278a943e76033f60a419ca48e79704e8502ea1e7edec5f719324e12811b70eb0afd4f24d845af65b27969af2252f1241738a176ad3b39d9c926dba34e562aa6d09fb5c3592a69a804d2f0c2d423e3ef8c36d3e1824fbb0cbf6f1047eb1d863f71f3e7cf538fb8574c03126a4357d357e0665d9e054fe838ef6d03c99b6a1a3c1de32dc8ba28dd6209172cdeec748e85953de70f8f5e3b4bca5ad18117ef065ad6ade22a110ee503fec2f44b229cf2a4de843b7133d417951f42c97cc52a5cce6b25f8d89b970231181401c530d1f39394fad85d933ba93e8a3853640c1e9c3d81356f043ba3c3f1d4e93f9015c94c591eb7ab6574f212b560c4196d7340f1b6d039c7d1c108a7d57e7b898b5247644e94b29e765c50d6594aa3891508a181caa8728896aa4bc27db4e17de930a013de1df5bac454a143d46c6da39d56b1ed0710d1c6d562b06b46dd0709803f257a8280dd1ab9ba717ab1caf13b330e0de92802490a3cf697eb009e6e286aa86bfe36763fa53a9dfa7644d86f3cb5dfd973054587c560c211faeb8f1a3cedc23d094b44a36a67eb986206d77442cf1b23c538679dfe31018d29b9282ded53e432c43f1141d1f77c26bdf3e357c76df2868a4de13f39634d1aec0eafc98451cc004f16a0982a50bdf0c7b19c32890e84babede75d87cc343c66a108068fc084d79c68d8cfa2c63ef3ba6bf6da0b5bf2b72ef","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
