<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2582479518764e4d8296b44ba2c5b5135347c4f72bb65e5981fd1ccd67585f263c462d4cd31e58c998dee7c0e9d7bddbed4b3400cbb14684aadba0aaa39b8d8ba9362c87331937c14f5bb49ef157f0389957db11f91e492001269ee27fb4d2963e84379c6b46f32779fd210390fa9c6420cd4e3b9edb216a27b8aca53ee4e44f132dbcd8f78cec1402062fd3df812c106ec054a7ba00c11e5dbf17e2ffe610567690b1cf8b808192b3da1b44f225353d778c31acf9828531cbf8f799aa1f7b96bfcf0c22b3b013dc1586924ec8a5d3e0a099a64a98c951e864a7b19068db85cb3ae745b664f467f4cbef83c3d3ef6d20c12bdb4feb6c52e52a52664ce9522976e5c1201e3a99c709b64d34144d486838b2723cbc73fbe407c6942c39c2e92c04561e441361591a50aa8f0760ba3d289087b312849741345f627b7c9cb296ee008fc79d0149acf4b4b768b22b69c69e6a379733fd1f9b2d3c35cb798df398b5f70d7dbfd19c800e1badcebc3ec9620b6b66d0a136b71bd053aa444004ebf9b10759c34ad65c3ea2218d6b837c94aae8dfd325f7d1000cdc771d95db3c5f6c1abf968f390aac77b47b5c04a02776f4d3e0ae470b20d4b7a7bf3e8c22741cc0556cbc3f98fb5a5def8b133bfa353a702faad9d90172c26a5a450505c23f3598f7c364ee90ec9cf339c5d0cf24d2128aeda75e0eb7ac5f7f5e87bb885663356cc506e8912bbc90cacf6bed6c41e7b2477012638bb7be817138176af5733ca9f85384f995064a6d2e5aea0e8076852177eeb9c601675b36c7383841ec57aac1195cf6dc654f13d80c3033fe0e7ed475e23578a24958a6af1e20fa6d8555e4b217321536847ea30fb6fb2e7b932b440fb4196a7967bb286724c485421543b2db3239b09dcf66d2f502b1b89e10e07f7ad0eb401e3e9ce3a7d7236525d66829552878264ab55adf340ef039fe8a6da996f2849823504774070791d5d8860af07d7a11b97746013a2359c8899f8c3c306e6ed071fd537a8f9ef160f7c44c92ca6db101605576c83d695f796e5bea2adce0d3c072dd50ec8ea0521342eae0c66d41729c124dfd12f50b0561356094e4c00fcf6a0bbd5585445f31ed6e7b81895753a05fe1701079dd061499cefc1b4eeae8e8bc3e7c4e574b931c41510adc5a42dcfc12f9a7b7baeac60653abb668ce4eb33361c40a85d317c7046703f53112cbb2dbedc9a99895802b6e2f8ad0a6f0fd54875e478aa893af244d39ac72a802c33bdefef73aed8c0c4ed1d368ff23efb8598bf1b06614149a40b2a428dc3a8331221c6dfba758c1ec2dfad6c9ecfc0a78fdc42c26210093295e91c983ba3fb0b8027528af89525db2ab190a5b690c1645fdb78ec30dbaaf60f4c6a746062d7b68fe2da4f0c5ead1db6702029fd9fbc76a25efa34e2642f3276867aa6c1269b39d1b2d05741461a94e9e15d4daa20c3858de36491014dcb43d94b5bc3b7b68b8889b7e78a1086131491bb33eb4bd0e93c724de87e0db2f1d647fbd7db264deb58aaccb6b849a602951b97bafbb9ddf5b00b2974f9a28f96db2332838d59f683c5433fb8ea6508cd71d0dedd0727ccead656d5cda19aeee1e4521446011586986a99b4e2be68348de6512274e5cdfbe34f75209c3ab946087b733e6dff00ad70ac5151e4b3e292a8033699e89df5df0cf32e130a9f538dffcf645c7433d20d126821ddbfec10da70c2d257685ff47ec47229beab6a49bfd6406d5a6a72f39303043c1df57b0ddf1da0014da674d8de431775dd443b7a882dc946131269caeb866b587f3d6814f4283f29f6682ff821b6860879116e1cb451d282b7b6979b4fc04ef693e733cae2efe11699e5aae2251a2d87787c790c6745a0e9a4ca29d0a874ccb0e33bb53d44d978d8b4894f3372f7aa885e7a004eaef2261daf22a691fa47b393c0d47ac752845e90b1299d9e2d53abe4847e3473cb03efa9cb1b5099d4b373881f6dfbb181bb548f9add1892fe7d1733ba7d6d61347d364d169720b03778a8eeb616e1f56ff43cdec5533b3a821513af665ba404a566c670e936638bc391d34ae6b881aa2f80d50d61c6b18b893e9be03c6d0b317cb699b60b7ec945a65a0327ece3528ee5adab58fcda820babc781d5e46215c8949a58a07d30e58961e33d54f41e64f10e69af97ea5cbd26bb37b019d203a8524a94dc85c91a79299f3b2662be15bc4ed02ef354670f3caad4842d3c46a54e89fa85da335d207a7526d8fb2a9b92c847955704ad9a567c571699e7c68a2907775cb2ee3fe4d98ae7a4fff2d028fccb9341e8dca77d1d70438a6f20c8363c65fcd75947875d44ed812c6e1310f11363af4f769c39a4ec15fbddb2fcd40cbd1653af43cfcc99ea42125676079d29d2f24609d3d5890d46be95c229fa78c4d57dd079bdb0bd85525166b36d9c3a7043445846de41200243f5099d9df30226cc98c9b4955e2d55667b5d840bca6c2b46661b79b71bfeb6f620d656a9da62bda523cc5e4163c85538a1c7dc08882e80434dd0a76ec62f22e698a6c13dd5383be628651f2064ceba90cda59aaa18f197c9465441a3a3504da21a580dd788b53331c68970b846c58535aac4667dc50ff0c0a7ad4521ae8d6b3730fa654c73db7ff750c0d7b29ed4f0a35d845ec83be2d48ad5b574abc7f2d534afcdae1b70250e6f0c98bf11ffbc70385ed3146487af2ec531659290107f02647492f83e361ef5206dc5b127433401e98402b2513ed2ffac0fb250423b4310e8a5f0864a4c75585a7129b4231be254a99aa6c14df416e65a36129cc7ec1bcba7a74e77d01f2a2d4fbc1734eece4ef921c26fa40c0be8a394ef07eefa7845efa4ade46e610a5f11837e0435213110eb61321dee4d6f6928edfef1647b1afb562ad08bb44688e018437161b88ee919f878b649bf5e94931145369cc121c66f031853e910ae3c14cc50303774a0a484000d8e7fa69b5651a87a1dea41ea15dcdf057a19de76cdc30b128e078e50d0ce01447917797f9dff56c0818d13fccf4042ef5a8b11880d508070a50b9d194338c7947a90a80d30ae65f52767551fa6304d39f970c1288b266e0dd3f484ec521cc544c7e269d73fa9f3d247956ed3d6c7917780337887102d3bed478e83dd1ac34e2353111e30c65d1d6958634a89f17f35380e4ea72463947d1debb97c2ab71917be88c273f2d96017ac5da5a1f3ae295a989daeab89a0d541bda90fae3ad46cb83f170c4184afd68856d7f266d262e66c31169f771ddbbf72e509b3d881065493a969ce376940deed9a40d6b6d6f74144a5ad04ba0ec18fa4b5e9f5b9eacd59f7b784f3c7f9b6d29476e5f0ee22b8a12131181cbc5792f83ca241ae6348429a78e691802990bf4bb0d6c672543e08ceaf604778b433c54d79d7a5d282fb70b3842c8c2f255d019a081bf1255786e5159eab522962bd11256ed6258c1c7df18d0f789e0d449c22d4bdf98375c63924cdea3f5af95fb920ba811b94e1426cf20ff0350125dc53bdc8b1ef008817f20873e73fdd0fafff37e00f3c5b47a73e49b51a5e0f00b6832b8e042f898271125cb480d18857750ba43edfd09661662bc891745bd07f78ad90deda833f73b1f57abae056d1c6a91a1c19fe7f2f29e2c1f593b1360552b9a8bb777eae06b30c276fa0774be44bba576d841ad7f89a32cd717734539b76bb836bb452a07cc04181debfe8969e8bd1ea515d1991ddf0d1bcac611b7ced2c563ff888c7b3fe14f04430888940796535f8fa45534101d27adf3e862bc39d9e1b4d83dac997d4a0cc8610d018bc22a840af216e30a242a727d2593cb01adde26a3e363d48d78ff06ae02f06c9dd28916a1f0bf3b336174476ab159dee49d9125447014e8529f957b7127493072fe61cea999cc45e3bb0b08ac90bb1f76b44362e9bf7d49ea33adbf2e9b818351bc7a530c332f4913c8b830723b7501110ec5510160f40ab896899d9ae902aaaeb4de049481397aa9c79e9742d6750cd5b2def00fa538e3cc65251672bae46290f56a09ef2b36537e4ea58e4a49804876eb4ce59aea7fba04d3dd6a0a7ca48aa14dec411f0ca0be2d25a415ea257eac3fc8e5cc977db6f2fa1a22f9f9b973ff67d422fdd1b77105a32e907f195b1ea9e36861214448b0671ea01b922b32f7848db420f5838357dcdb15ef8a4a107739ac33b2aee2c1f79e62c07cc2857e72b881c855b0e406d83f525fd7fa5ec8671af6092e913653e621ae302bf0fd379fa3d50b117c17919c453e667fe1f9d8ca0c1841c52cc2ed953cf41d5bae6001a2a6974e7dc98629a51f53c1a3929fbb1dabfac0ddc11ae865442fe62c27bde393d337a680c1bcf2df37378385016a26b797a00fdb3fb77908413b773e3de45364c8c96c56e24e8fe399969956f7b6e24745335168fa8cfb886d0abbf322a7e56fcf6eb64553500ec032e8632c7b7dbf38e92c8c5d494296e6a37f56c710b2c23d4c82b37770d59e38ac751fab0f570e19d5c5a8ab3e511c67bb9efd5f8c783217879ca45c303aebf3b24ad01b6c624c38e4271a07bbac8be51748e67b1d270d289453f2d01025f82b3fb92746184d9a5f57d14e1a23193ed60ffbb922f348b5460d91674e9c2a9661f33f71d07a713fe484a5f325b6c79e2b3d71174814b268cf76719dc2ba5fc6853298db98b214412adeb5e723189ab063101c30163243864365ab61cd2b744b5a5dd9c5273d8f6812febd4183f5e957ada95c8584aa0ab511b9eb10966998237305b0468ccda286859c92331e3fc7e628e916352c804a1343f39fc17890b90b49a6147cb36ff17736bc780c2d3cb80e6ebe850ded707ec8e19fd56c7b9ebfa6e4119ba3cdbd9a6f7e686488d42b03aeb77b7f16004b971d8307475ddafcdf639589c4b4bb168565cdf081be43b7bbbc7be46cbe1fabbeedca0d33fbccad7bad43abe10be7778717faa25efb0170d576651cf7a30fa40094cd744b2189c90d94f1a1b4e8a04bb8135da50ee555b07eb828066607ce274bc42db79f687e905115be4a39322767540ebe4d8a7bb3a9550cafd3a3891d680b3a7cd48862c4cf1302c9fa29edbefe990417a4655d13bb1cf72085e768c4081f45206a4254f7b00b7cb5959c62faf55dafbb0a240b044478bb52c41c86069bfd8d6b9a6117e5a65909eef107e9093abe4ee89a763cbd5e58eb4f4ad16cfcf4e33a88b62da9ebc7cfec30e6fee84062f15220252edc47bb2a2ff38607d62534f469f952ab7efe3d3ff236ef1523422a13798d60a796b56511b559442747fb72734a7a01bd4cb8ef94c41ce5c856ffdc953b9c395e6f43bac4de0e8f1f061d98b9a03aee31f02519d4c3df1d4d0920df3489f6e1140ad92ebd51f18481587fab14526c7fb1ef232f13637ca28d94d1b92ca6ba775e04614b643b235d4df7fda4d68fd2181922d702d0fd4f0fc1da4c9ec64319c66be9b450bf8521a8382c7c2699080c579747135b552816000350e6b4aef3db3006a5e63067a4f324ab49c32c94ab32ac30af16ac12d1e487a7f11e58d8b02e7c993082e6a6543dced6dcbcc5e3c658c8968c3e1ccba0c47156df71807ccb513f5cde68a198373f48cba9573a10fe57cddbcff3a258fc453521ebf4e797e0263a85bb260cfd8f471819a350d7380d7a58d2e52c9516b53b267c6b16235b10463d70414149010b7b06ab58f3f58d7d29029a2d9b3a7ae9c94d1d8d3b52b537bd2907dfd6d72c514646de1eced8197801e311f5912c68fa08dc44e565107432e1696b95b81e518e86256009fa64db3b7911f06fa0f36b1d2440f80699bc03ad556200e1373bb2329e5cf343b0352fea974f9bd05d1f832cafe45ec8d94f88d76317d952bd6d5538eed32e6fe4733bbf3683218429a0c6790cb7a932eed6cea33aceb7dde87f28f27d1b4cd73b485c1acfeb2e7d1981cfddac8fdbb06d158f024565c96b9840d4cf38281c3e9681e11ac08f1f0d08f23ad3bbbcee6f8394a0c5a7d6b0d60d253635a61133229f9b1ebb8a2c019465db39c51a6c3948cd761ca50e98e75bcd45d0de0035aa6786ddcc5caa128f8258adf718f1808a85122b4e9fb64547b55fe49862a40fe86f097f1f5d03ac9f33ba8e991b3146058399364f0d4c694fb1f60b4e67d18c97ff678177b7e9e836c7d47f83e65fc01b1e22a0753d2921ea7b03584a7e91a1e52930ebe6e34850aad41a5a083adc7066d664c4d22bfa6a37363bfa3a4a64c5b8a81a3efcf93f42cf562ff952d7bb8ed38875d2b26f88a3e6cfd8852801cb57be89c84b52a016d482875bb39ed73af8e91f6b5d3074097be2cdb69772a191f75499b34117360d7e05c226491423bf08c8cf490c7be9970c0ed76350f2d11dd71d759a7bd8ec5e54b075608b47023cc2fea7bc861f02c3907c9d20102941e3f84c326705ed2e9da95b8aadcfef6f72b66d7ed8e6e0044308c751e7876d6395526522f91a7e235841ebd9afd785baa0a85a985cf37271470b98d4854f86e633a2af4184e93e99b19b1227a6c7ea001c754464579f28fa2bfd6fd5dd0cae369f14edb5b1c3d7e3be96be299a60b272ca2506f06332b0d2067960ba3773172930948862f0e3b47562266f270346d40a4fe1216573845b5f817f8ed40ffd6f52e859b6dd55c0cf2a55a3ef5a5c5dee644459b029274f1495a042fa1ae5b8d83f0d704b618d5e7e2e962b8ff720996ebe8788b6339939f91eb91d3896d168ce4a9a424e300582cb4c109de026827156effc6f6756826db8be0be08d05f721203c3766dd3c0053aa3839e3275f89198192b836a39fd6bd642e0fd88f0147b0981b6d8f74afcc902c5c013566866766af28f68ef23b6280e66e071e727ec476ce83d6203baf95d50bad032b4e1eb9a65aeb7d3e8aeeb34b013a9375feea3dfc9236f3a423b07f1fa00fd0ef8c21a223f8aa798a534555d2fb5d86af39138068c64b8787e4af89e8c1e36c5bdcb851264a0edf4988047eacc18d638f537fd52c15a484e28442a079238e540e7e1a9c3590a214c8fb2ed5b00363489590cba982adb15ae52f675f060f0cb663e57b141e168ad3993bb5a3679ab183517837246e6d56d0fc1a824bc490f107808c81a531d5534a01bd3f5cd76c26c3730f22aa6b2162aaa4e6f4048b22db44c1cfa276d99a985c5cc8816eedd75fdd1a097317a7501254126a0ab633fbd6fe9d27bade4ed452590a16334c898124be3a957b5d125d6450905f1e34c8f14e8ded1935f267812aabbead1e43ecd66bfba1445da510bdfc913a06602606c6119360bfc253fcc88aedbaf9f613ea5d880fe6c65810b4d2522872c89cc49170148169ebaa6f044e78d91183d6f85f3e4f00147f564b8ee6326835b64c97491b0c76385754820a2ecf6ced4268de24f83c684cffd23afa51b0c6996ddbeb2ad20f9c40ab4a7fb5548d46896d122231aa3f902fa2766df301c9f377c1a5340b5e038f61d301ed6cdc2069d8159b8a7f44f1efcd4d167024aaf4b8e66755745d73540028a723bac3c7ae92687a1a298e33d4f8092d401d782cbefda3b860b56d068ede270a20040817ff0b366586e33092e717077e8df22e1aeea99d53eab7eb6be84e26a4ae21fda29bf1623e75d1260e98d8147f41e5c8eb2e27ea7aa512379bcb925a9e74f972367aae9af38167146a4d62840465021fda4852988f5fb984363e0850eea0e57bdddc8b098141c2ab0cc22bb5f98b69d1c537685f6db533846e940097acba74ab4eafe0783f38de1417cf21196ca8b6b39294e66e3fe9cf60f3842970a441c573c1ab6af95fdfc4a4057651cafe42c0948816813210c3fec402a0be7dcdbe74598f859d46b5bb0d9db60e8b0ddae939c5c12de7d08faa301b2aef12b3d872215141c6a135f222e2495e9053aef9e635d095b4f861acc0e9cc144d8a7d85150e79525bb244c7a84c97ec65555998674705ff76d3e3564f9fd0aa0b948d7a94d93db5ba03f71e794202e450f574b8aaa78d1646615a86841c5ba71d810a16c611dfd3f816c8ce5e1e39d8ff7f467ef4368526fb7a853afa57359167e41c123ae822867e422b5f4dbfe0692ef0dd82a626d46837f75db788f5976ddba2db6122e50e0356bc9c3933f3fbaae4dfda82a1392aee0ae51a2c3abfb274994201d65ae3ef8eeb7486a17d8f9366b3dfa7c281248c2eff94fa97031292ec5e5843b14bf70a442ce0c495d37c9e651642dddce66506fbf3307baf06f6e22cb28990fd58d36ed82a82b586d425a484bc427bcb9242534d1e53fb609a2b013e00ca014669478a442baf76871e3b93540d93939ba7d91d367cfaf902322bc06e03cf2b4ed71ddcffaabe0fffbac5432bd80c740261e0cabee8e88d9880d57be3dc9c5db0dc67e7f3041be8f2a9109ad337e994988819b24efda54fb08b08996e6d976ce9d014c42e98b12e7bb90faa4289cabe2c26013f4a544b525a34ac9af392ee95b9032dc2349eeca4dd6a3968b0dccb7edf305860a02afa8bd82ea88c0038d0b8cc5ff380ac39e72b2ca604dbfbff1ea49a25a6a06e3606008fade2a4f22797d92db9d4f752d018d95acd8e6ca269ec144c50dbaca007602a514a0128bece7f3c85df93b9eb2a992fb2fcb0c42a236d7c6c6125d37886554a16f4ddc960ee52ae27542bbbd5b82bcf1210e7956efe0db44524aa939149dd603bc3bfd80e013108bcbf4b6909f08333ab28f3f94a2de98bc3046a6b0f5dbcbccce410aa3cdc13f749081203b0c9f9827dead9c34362f08a8d1306596b3c03ec78c94860d684d058ac386872c57c291b8f3522782a4ae60b826fd10956203fe28754382c49094d3b559980e9c5e60e7cb2ec562512eb4d9cb798a8ea8bbdc75fc5dbeaf63dc66cacf9bf7debe824ea785b900d257bb98da1c940a0b8ca13ae9931826ac32c81129f802be0e800804264384c19b0734b99a7eb91e6c4f7a4cc2ae9ab82d01afc260c51e792bef7cfb478a89fdb738da16110cd45e9f8812ef3d792990cbd6c69d8407c5b0fabb16c2c6d8034b60bbb477c876ae02cca36997619bec2e32d62a32d797274da29858cf86d999abeee5df955c3cab483291b68d1f56e1e4b2f25b272262e62241954e617504971bedbbda59e5250911f1538af012700468b2a2c3fe302da3b3c2159ab1b09f1ab802b769da6f31546ba13c4dd22c125da10a48e66bdf8b8afb9b9b8bdf63173341fc954971102221e29aeb3d2e7628df703262eacdec4247a24fbee88398388d7d1f8cf2689a127f2e0a3cb6842b5cc75dd7e8d2af923ce2cc4308abc501f7106873947d96cb1b052f906287f92eef97fb7b6045d5a36aa7e3019f37dd9b21ea1c6eebbccc33a4858aac69b0573154c3ceed41a1d5099d33570f61a53bb8de788c609acfea03ddf425627f5cf99db263934ad558572df6e809f57ea595b3345dc67ec88e14754a87e7d01d7b3d0b08480b0c4ad9d517731da3a7e5d415c661fee6fee2314456ca6600b30b818c39c4ff26bc08c37a8185f63a4e711201891af23d99799dbb6df75c976930d876e1b93dc2f2eee7d0350f3d9c18c634923e74b0072153085f29e09cad8edfbdeb2d6f8d304298cd7360ed4964b4137d0de4e906bafb8f6f51b7d5043be722028e8e0e71317efaf98956b5d2dd44cef2cbc0e3fc3b97c952763878e6afc9310f6c49b58dfdf76571bfc9a2aa28749f50f45a0194709206b81388e350d463982bb58dd26d1533be6c575af13a1ea5cbfb331dc6dbe5d249008e65a9f3b1487e0e5084cd927810bae8ff9b16138e1fae01c674cb9b64848fcf4bdea0c375b670d185a7670925ec2f7a6e73a7f87456e3fdb86a53e2bc566f30f026d12ff029cf35fb49900a87b4adb4fdfdfd9911851822625201fc82979d97c23d05ae8ebe195f99528a715829b4a519143bbed363140170decd510496b1adb917b70bf8f6f72c46d0d61adb56ea4cb3270c1b738326dc9ccf961b1f150f61568042b3eef2310ffd032a512daae567cbd1cb85c58db933f681b8fbad2140220ddb9c9185372bfb5119176bb853ca704cda4c965e9559aeeb23d917471c3dd01ec6ad36344c51dd4b870e4a0b40663c2f8fe2e8802fc752879db04a97f25b8c241acc43f84ce3af82b7eeb066f4156d13052cdfd3c49ee90b201f44b333a2b518422bec6b7985020bc37498fd994d568262828a3e155d33e878f9900d5991df1c3713bc4c8704847ef595706c55fadfdc66b05a30a1b4e641c33a836a056381ec20e2d8b6ced977c0b4df8fa4fb1047e8bb8d70e541465cbc87215edb3372187e2714245216ed0ee111520029b749f744befdb49038900189a6e3201f46fb084d439de9a6037e269d601ddeb57fc1908346d15a2f91b415e62ecbe434745d09fb7bb5274a2527befb73e4c872338de19380e6c0ca3ce04cd7d3b616b9adbf0945400c7bcf5358950aa814eb0307f91f1038a2d919dbd03022e6412bc77acecd6938037c4dc975de208df7ba1ebc117042728eed02d9e7999e7b1d05ca44b391ae82e69a479b686feb5d5852027884b12584ba96f2a181695b37adda185bb2b1b051984667727078892f2449b97664b7cee6636de90a4846595d6ea56865d50d43e59294bec25324b31f9b155a5bae1b4d258dfbd8c05646734b6773bf21031adb81512e0f53441602748f1fd4fd595291e4bb108303837cc65d8430f380b846c58bd61670ed810fbceb2322aa042a8289de2af4556c9aad0ed3b3ea3384148b4d0a1401ff0ce4d4f79fd29c076cc7b14b21b419ed18e0fb8f549019a2b387c28eb86e47a8ab2b78ecee602aa0fba1119a8d0eba03914f5f409bcfe4fe143b33b9ec8a705c92466478dce398e41bcfe03cb7482c50215859bccca498ed2f753d28ccdd49ac2807170f1bae345a52ca2bee75211c4aef7b197cd8a68bdbd00f4d7c480a52eb558b9798d8b4f4d37efe8e7d4f23c71c9145598084518ba190061cea157bcf97ea26a1456bc416946b5aa6fa52aa993c997eb06a51418debb5b1df8ddd84d203ab5d6f6df51765900b6a402faef1934a665dba1f23b0a2380f0d0daa4934ce52cc5097d9c8a39ebaaf99d06d192e484346436aea8b80fd7ec4e581058041ecf2707101089d01b1a9ae4018232731729d256c0efad8ceec4a812a2dac3c73741ae4ea406c7e136593f5feba11a96ed7247c510645bbafb607aa2680858f3cc4af56023618f940f0702e4763bfd20106f2658e722ff8a76400ee09f74ba4bdbd2a66a25a3fb7268871fa1f063a72b9cce500cc4094b898700898825cf652db920ae960e94f012f281dd05b5cccadc6acdbeeffabc71ea9e5a00a949b01ba2abc1f02f592e7b14dd6feeb8dcecda6931963308085baa31bf0af0d76dc274fd34e23e0bb390344ed700c885555ba5cd465b98d742008299ad628e6815baf74e12b11c86f98661c3ca17493195e5a431c9e78c1c41f719adb44ec308b4617c4f6eec7ae21c9fb9e0024901a327838b4779ed32c2be76b0d7f885fcb8efc78588fd170e19064041c081db312c0c5a8bae7c1fff1619de6d480f31dcc3494dafbe8f79cd43c298cdba04e320520db65bbbdcd8fe383d652af968460f6513aa6c8b47d0f376596aaf2bcb9048cb543efdc9cd3c0852ac912439b5d3e1434079ef4c94cbd8609834a89e0972e80d2442fc1b9d8e278980191fa893583504403823120fa973f3629efbba06cfdabd8516fb6bc2e58f128b4b13789bb9d4b57165ea4faf374fcb0143bfac35a2fb8c7444df4bea60d42a519407b942c40def99e6384649c9d5b94a1b235146e3d43c79c7d0781202c1ae6410755228f1efa5c09f4f4f0510dd72e748d0ca874d522c1b49b8a2e23604602ea681a28de674394bd2c04aa87a6d3552a78a3ad539e9c4f3e5a8f5eb11dab6b82ca7f34fec3b27381de53c34742652eab2fb836b9950990344dec714ccc9929607f0ba700a679584239254a0394cf2a55d28ee5b3c1804232791bbaa70d844eeaa5477114950e4e539b21e9ea0cfd0744adff949951a5585167875f4d7abd3519d06237a6438196543362397ad7fd847668ab7bf8c19a3e58eb4507798d8275fb16c71a610910782c9c37017780ada95f281dacd239fac6eba36e19198f72d952863fda83c0a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
