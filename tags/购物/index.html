<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9fd1dafaa158b4e90db64b9e80c809760bc3b487b2992a21466f7683b17952d565364c75fc31d15821d6ab6b7b7aa7637b4c5eadda66dde6b970499e12d93ea1a172b67ad40b7a460299b23fb8341966d7256083c25c1f196827fdf84794891288fe15e37abf63f4259e85bbb92d7a65917a440e9fadb54310d57814081005804958e1cd64b0baec8dbfef489f65982a7ec4fb2a75df2271d7ea9148f3999cc594b57e393569104294aff3933e1ac3c9c40bcf95cf7710e0d83f06bdf5755ed53c8b76ffe33b77e20b005907ee5a1d495f0b19a1622abf1ae0829769c0012f861cfe2d9db9f9d4302fffa60991a6c6b3b62ec3e3440095c9791e12434edb4c2d03e6e83c4be29e0811a6a64fb86af4f3aff34380c8d1c75e47aad69124623bfceae285cda6848be3e2e85d9d9337cd32431146e93d7ccfbbb09dc212e5d463c6c733836f2d62c21929f04721be0a0dfee4be7695249b3ee4041fac6358eeaef43d02efca00e31452295d2bd0f04bf2ecef308d7ddd40183098f3d91809a8610ad215d24d0783694da99d073aae436e6c3145c801ac1d02b0055595d7e5f3552bb73ff865ba6159254fdcd9485e5d06799a5d205654f8d70f2a2e04f8fb3b4ce95b7726f5c1a83b14f6cb12b2ec4b4d09cdf364e29a61c2bbbe21a8d4609d04b9a9dcf66944569e1f2df0f2d24eff647f5cbf8b388d4452b3a0bb48736b0ad180f47003a6e7e17e9c33458198739a4bbc4fad2e87e386a2822107bcc31f10fa0d8aa3b366b7c5b3dc6fe4c238e767b03112073ab3c896588f2285b41b9739eb30e37faf7471c60ae46ddb36fcf26d164142d163e8311247aa6f047ff09655fbc2485fb4a061e1135ae15cf673cce49d020ff5b5bcdfd32fdbe2d2e98833118b20cba5e9b8a0dd1f6cd5cf9ea7269fa221ded87c5d3d8789b92a49091690e17a111a274be60815b9308a87f8ce88ce82bb3b0fa2066a9efebef9077682b589cd189661903ab4d7aacc481e8e0442af9a617c249766ad545991701a6bcc8c175aef3ffce2f7e214b871a0fc78e0b63bb86c18938679b2153a3f3954422c613f047605adcad6d3ae33926f5fb49041aa101fcddc1a1a238eb89dfb469b9cb5bd74f880fa3f203e8bff4f5b15c8260052d3d3a1300ffcbcc1ec3e62022204009ec4ca33d5bb5beca46543721e4c40f11a8ad2f259fd5642b289e871fc5c21ec78a6173c0bf0a5420ddc0290924e64a8adc0079aedf30b4ab45c182a23c8cf4804075876ba0d7d32f19a2ff3c63806bdb077b10a6fd337987e7fc18f4f20ba2300d96b06dfa46f0b9673983b0cc0761681cbe568aedf25d8e3c3a22eab010dd977b31d419af3f3149c3d9b8d9f596bb27b051aae8c2e53a5b7f3e313dfaa3ffcc807b5d5e351a20afbf11fde73ddf58a8bcec6111857391b1175080b91d2f72b49134c1377f30d02cfd5a20cb853b18e255d57ac7b8c195da69e4476d3210263ad6c6cc248e3ed49411e5d9d2e7a447d39ef07483f8af5a3c4276a534615be90fccfd45f4510bc2ceb965b6e867fba14381efc4d781ff6a69316dae24d67a3e56dc3599ec94e0df943d6b2cf1cc2fa3582144aed3b512c4cfd54e7374953b48ab894d9a966cc867bfa28a9a261488cc1b5fa2cd40e2de1ffca2674ae63760fe2615d9598bcf41a448d16e7e5172bd3439879f463a9c52a63d951b15df2b83a67dab321c3303d158db9e1695990a899bf0604234f2b6ade79710a2d2d2c47950713be77030bc87ac4ffc93e3fcb6cb5cf86b2ba08199d62ca7229e300d0aed393de7432a494e4a2dc2911d9a27293cf7765aebe54107d0ad4f66bd06d5cf0fa7f2e0b50a5bd9b9e036f2f1aba106faa1f0db8bc29d7cc267f85e1bf71338c6ba6f2c2a8b29a265b26efb0f1810b034c171811445c08b290e599857af837834b93e30ddd99a6b4fdb28f4b26f90a1824459f388115e5b4c2c960dbefdab808a35b68fee075271466bbf946ee41a5a414572b73d0a61f059a3cb3cfbbf738bb70ad0e458d37237a044c01cc3ef29fa6a5336eda1cfaa85a493ef74d9ba7062833f7f8366b0343876dd442ee6343ac186b7c6e33fed2edc7e6841a246f17f7505e4908550fad1d7da4fcfb41f4c2b5411324794861d3ad81ceb32cb57a150093aecc65662946259237402617c3a57798720289e5b65e7cd3bfd86620d98961cd07960d3c3b48af47d623cb6dcd5ffbbf362fc1923ceeacd8847cc5a42e7e26cd229718a419bdb0fc98c9045b533b8383fe90fd0c6c3951cb95a3f52cb1ed41ba657dc748fd678aecab7104a5719f60fb78accb20595ce85e25c9874a47a622e4d807a40140433ff911bdd186c9af669ae0d25517c41f8b0ba6b2d2051527a242363ff560243bf50ed83ddc9da45d3bb318bd7df58d0fb5a7e7dfc5d93ef00a7f330080351e0549c9b6cc5765a6be8b80e1ede35fe72864a212eb832c97e8e8cb5d1643b413b7fda1c3547caf9d33e22cbd7b19b1922e146f969f01da42de6aadecb842dafcaa12837c889c90603a442171602045875fd27e63c5a3fb91efe78cfd97e421b8778a87973aedd60a08abd55f3f8856ed8ae15aabb04a90f1c349c8784a21b768abfa434116c5a103fbf21ed4f27e7bf5ee1e545c57170e40753d508ddb920e8c6ae0a301d36f0cd2e0dd1f44af90adc22581376f90c88fdc45e0d984844b3fdd5774cfb21399acb0a01cad1ccf06a8ddd6da8d6bd4b9c4951edf852a30abdcac9adb0f1e0d86d098ad6062dd523d875fb084b8c35b6d7c92736c5d27c16996b7326f4c0231aa5a0e63d1db8b7f9c860292e2f3f846cf14d6876e4f8ee31a1b25a460b7c4381a611eee6fcc1bc02341f8f24c40ee942869bdbb13a9f918f8fae3d732713f86e83087db4b10ca4452e68b03018d7e2c022fd6bd622052b58fa1159b5f313d65e064b15faad0149b50195a68786c4edea36965fd806d6983838494087963a1f8ed805d924e0233d1c4c92277a7162deb2b1737582f36331788db1358840db303ccfcd335392b57a9dee50028d73e9d5205b3af8e407f1816e4213233e8b77ab747643241c43c2b79a8c0d4e5704773249c28a7fc9d203f3801d87106f0d1e8a36938937c9b631b35aae924dad4b827b70a6baba47e4e15fbba9ac6d1c435274880c997eb4ef82139e28e33d8718a329fd2a2b331f5e893a4254fb9fafcc7b7cb0c575bd1636e584a58fdee888af1244789185e7bd4862f93ca0d3cbc0851d96d3e91b8dfea0807c05714caca564849f0e1cc5333636d16525a9f814a865b4df06e2aa88bccf686ad8a31ef31c8f57c034c3db8e96969fc715a12a414f53dd61e6e724d551702cb319485cfbfc2e3a01771b5b9b87967409e6e62ca6fc434eb40613ba33f8a97b6bcbd30efaef8176da2052903a26e021d7a496e1e3ff81122fd9f1c6345fe4529d6d3d9f4f174f9b3bc903c1925238fd34479ecf65e01d95e8eff91ba43470b6c52afb2156f6ab211c7bcf52eff54543400012a8c4fdd511d48cae38966887b1a96cc0dc43f0eec5a44833482a37db219171442495260798a9a7cc82e6d86f8d13f9e8d0416d0b019cebaa26089bdf2d5729fc5c9aa26dd3d0b59afd338c5326db290b31e97089cd1392d90dac19a7effe1fe588ab7191b17b587d4477a291b81d59ebe5e3e80830a82cb85dd986533cc104c6aec8c386b3751ea415aa57a4fe7d009400dce107f9429889e09b618af97f10a0c936b2c2423be140e1ac93186a4794dce5addd113328868ac4014ccc8f72a56fb60ebfcfa66c262ae4c036cfff199b3fa9a4bffd2c1f99d5da97d94ab106f3d90d1d01d8d12ea0eecd7e41ea26e6cc6b890de8fd1370f628f5b4b98d3932023a2dcb1fbdddcaebd1c96d8da16530a4ef81a62a8d785335f2b956d19529ea7ece21448b876fff4cd364f0890c8ce130e6d22ac85c89b4b220b97b41490ae6a53d4d3f8636a6762734cd47176fb840dcda9de3c298c278c18397e0e41e732885c05893ba779137cae509b6e5356f047963dc84697cb1c0249096ef16da48eb675d5c961b6dfa663a2319afbe430a0447cee57745b5a44325e45f2304aa7a02dc4441531e126b12c7be36d95b237d6101add244c3fbd40d59678965c8b77e7814cf8856b21c04d8cfa1bc600420bdf6116da2bfda885ac98010e15ca34b9ec1cafe3695c6f95e4acb8270460415639b5ad23f2ffd5bbdeb125f6edc0c1aca345330798d08055352dcb4d59d6a0e60b9ec78972b90998a5ba2aa40855961a9463eb58379d19df7122e22afb6a6f687bce8fadc5c193689740683f06755861f9a9272ddc9bc4390b170c7f1c1f66ed943baea0739f321f8190fc9986d105f56d196dafaba89acd8d0122156cbe225cc06273ababeeef49a4cc89fd5684f3533c71a86369dbd7c9b37a68f0fa51ee48af29d4e6ea12ba343e8737118a4d5a4fe12b929cabd06ed17f3b7d452f9019c915c27fc388495e7e64e09574582e3d64d878c2940b996340a2560151947681f7151d6c100ee97ef9a70f69b4c3d0b9161e54c53fb9df680ac6dc17f3a24e41fa8f3e579a3b9533755f7d895adb30e9b899fc05a301160e94b25d1d93bab73c465aa8b51b1a49bf0eaa51f651f73b1f41fa57a79a07e858c41fc9265f8ec28b93bbf6c4c1ba129ecbef84d2421fc72ea1055461c961199a374edb7bc0cf4761e266de678df5866a68e51bd72af4e55a95096265d841f07f70623fbd15806bd05b97ed97b39ae07687aeaa32b6e66f2593301604fe040f0d150ab777598bd20109bc1397d031273ff415e679e7d60b8964beb698b6b7f0255b7d84c6dd53c84611e27c46fbb65bd0bb3ae152f93b002b869afbbd69268db6122ba966ab4ec8620d2e1659cfd0460d713552dd77909aa5e9dbed7ef04230507b82983e90feb1da572230d884c7e8a3b9c4fdff8973b0ea5632939f71691e89ebe3874b7855bd555e2cfb69b3108d1ca68d8d8176d1664e371c3c71699e8fb74e44811d6c91e46e1913805ff2133d7db014ee402be0e1440c5a1994c714746e832b0fd09dcf77a2af29180acc985da29c6e584f5ece9c1b71f1cf3638da1ebaeb4daf14676fde019482334e573a98462a08acbbddd130b9a1c0f6ff6477d0393e517f6f7738fd73422d2ad810713be43aaa50b9e2128687ad013f70319d01b50a78092186dcd49af8f339b221eb7f04bf7be45a92acb510c3723e2ca3d4ce4d4dd54c5f6f185b14c5b6208751938288002fe1ccc2c3bbb74b99ac732414787d40374a7f5fc77452eb74b8c25c32a9210fe7e958674a6c5e549097e2925cc2003db0e453543f0f7f9789ca5c79810936c8e295e50a1a0d38599a90ee8b3452390b20fd66e2d3d6dea479acf1191fb2856f9012753311d3d82bf8241c080a07f5c16c378e8137e5cf8b63d2213df8acf08c1afdb57212b248efb7f47003fed510c404432666d7d569a410dd58ded8857f538fd0b082d1dfc4e77cc3fdde28cae6492e9de42f970e9f28ae301d590b024506157098a76af8ccef9fbe7919721ee4192590d81802e0cac16f8dcabfd68feec06e3570da342a571ce7c35572445ecc5c6c8906e0b77bf67954f48a25717934000bffb938424e828cef3bd2c996634030c1666766cd3fd5d916e26619a784f125d8023e60d54482f8a59873372646138af6edc8c74a1a8f16da7db9d5387dfb7b4c6539c6867c94e32ee4c58ce329878baa0c0ff48c23ec8452b7e96c71fc10b3ea7beda17c57f5586653ff19c246b3045677d1ddbbc482ae77d1768f57dadd8e1eeeb05f6cc6a897ced042e50acceb6861536167a9775b72781a1c2f3c3e812836a03d59a9c9f0219842fefc209f7f840506138a582d6eeef8fa557223c106d6c2b6a94c337afc37f51eaee446cb4f1041b3213429e1423c075b658bbabfcfa512749c57cdb36a35c1cbe0992b441f1cdd2ebcdefc189bcbfa002f79a3064a433ec2ec1425fe91421040b5ce67e2e99d6efa9e709248c795882c3f5a37ac3b39dd9079883d9714683302d8d7097f2a2d7bc8de91deea7e54a805ce735bce2f9c49003b8217cce5a0702cb012229d784e927545463cfd6ebae4b6401d3b54793dc89288b6d59f5122d5993dc290b3d485943b827e9a7962be189131521d2d2468c413753313798ac1f81822c1bf7323aa394c21b6d549c72db1bc88e90cefec245bf9ce65ba92698a924cddebe95e5560ade0e8c5a82d3c0fd971015ac1206b29c04662a3c653dfc8b94850ec532d50c7e50e5530e482c51318ffef6dfeae35043360090621849969b2b4a629bd646ab98104686e25e819ec6270ff49d0b41874a9e219eae2a8fb20a34f248d7d030c199889d0a02aedd7339f329454b1c7d9f65642098e7263bbe14bec3e58ee420c37eb1e7fd3feba3f9505cc3711c20edbbc3de41fc7f7d5d3f24287af208d42fa132c2a5bea34d16366c7db988e1270b4c316b9f69a1dbf0a3029f6aa9fc1e3d38e4d5740f54670a0bc3df68465df77e3321aef72a5d1b263b3562e1539d90d8acf2f7e0c55abd9711bcf948bc40bd95823c0256ef812e8e6696d946fd2dd068f94957ab580064e86d7f3e147d06a57b720a31a50cb4eb458fdc3df96dc288da51e4be4f4aa88782602ba272d3856bd91ebe49ff40e4e86308d889c45f01d0d1a6612ba48c25c0b93598e7902c38621dc5524b52d70214a7160616d6ee5f6df61fe335bd0839b56bbad0151e891b9edd3ce4c03bb60c362151aa7d802da00f057d0a1d4c00a54445d269eb33b2300f5728b46773c2de0f424a87f46c441a4f7d9538c5cac370092bdb89cb9f3ab6874d1820a92911dd6ff20578a90349b21ea8a23456bfec23efde9dfc53a5ced40f89106f95efffccd5d03ecb81dfd58160b8fdc59879b902447647a5086336c8d3032df44ea048dc29b2d3f255f5621fa17dde22467b3552c2c8739f068bebd53f2a655b24b02694e9806fdc2a2329722c02cc8021e24585580b01fd602a5903560f414a17123e68a63f6276d69ba2a514dc975e9f9bd4978e53fce6d6ea70265e4ff1fd753aa4e6920f3ee33b42a5c8aad60d7ebcf3d4a2bbd42ab3c90059c72c94d122155ce2dfe510801891d21af54fac22bc3796afaf84fdf5926349808eb741399e674ae8079e6483a02483beed72b4e9cea0f4dcc39fd56569aab43285ba5f6c5d6740bbe89d7921ed59cdc16f594dc7123e20218074d323a6cff3d17c9762a59c3b4ff2f4377c23b37cf459be1ae960025a3eeda3597010372e2a31fad523ae01ffa629fdf106b1ce51792fbda388592dd2f5d26a4d1cca35d2467072d0568b919e34214db2c051a8c02d9f5b0cde6a448459f0678c43208568b21ea7aa0e0c62202074a57f048011915d2a73cead59a4ca45ce5f6f8ce20e63a7d75a852e45edbf6221460bfdd08379fd2719dbba3694b609746da5f1b11158205de1e1d850c48f2872edd99509296532ea389d32e5625bf8fe8d90fb70b78cdedeec31da8f7e57b8625845dbfbd197bb8da0028492698acc5a734ea36ec80345263119877a5c5abbd642149bf84e80acabe7febf450b8dbdf791df258eb1733b8bee1a02fa329ec6148f1ea7192ded244ba7b37516647b899d99c4c0252a9b041b7a09890fd5b2d8364e46e60b8787e01bf0a789a1420ee14b9205375ce64f882dfa569ed8f6147e64337ed3618dc8231eab31f2d9c42862aab8e5c0aba84fcdbbb1b316b60e8db74b8882218360ff1e9c84addf2a0cf31a89c89a50b3f1f522f4e2d091667bd407589fb0a5316125aa25d2a40dc71099c131e920d785bc6af7256bd956e6dfaef56a1cc72afb2d4306a35350ea6c7fa234c556166ce9ece192c2ed7f728a4a4ef1857d9392336492e23bf2abb47e89e24e73eac8ba17bf0208b6bc2a40505126f10bd07a910b58c31cf454d9ee90d08930b11930eea0b560298fdb275986bc0f3387a11fcb72e0f3cbb9d2cf06599b3e54533086ae5a289bc183d7486b31e8ae37e60893f060a702a20ea5a27a227e3ddb24d642dd3a498e14dc8b2114679d00515a90980eb87ba4418c003866f62d33e5e7139cb41edc4fb13bfbebbfbd0f8d30674b1eb3ede0520643530a237a4b11ddb252906ad9f738fb7efcec1aca8cf423263bf1c05affcab7a2acb5c76990d2029a8e9a5d62834b1a87fc0a4f0616ecd2686d86595a13827a904eb9db8f878a74eebe96fdc0e54d990e7cf89eb3ea106c04e21d1c36d85fa388905e49cc3eded0d8fc01c9e821376f2a77808555ae6517b6b35d1a55890af9f1e80a208ed7cd85bbdec80782a6ee38c87b0f612c015b498fd7f2fdc1e31e2929e07f4d4981aaea19bc3818cb4d0306a9b2482869899ebd77fcdc717b84460cbfc81716f7330b6550dd0ef9aa1cd65d663060ba63d3f1b18431ed63e9c4b87dd4e84e7d2031f35a31546c5556a4589482318723e149fb8f46110d2889a1325b59676bea1426cdfff682ac43b68848bf729881cd9f1279be1933c6182cda38a4831b666c7e2c267f112cdcea6b6196b480d72209ca8327ffa66ed686c892c83f6378c1cad6e62a7d89a5d77e69b056887e53d6f25a7c6790b2d874fcd32a13dc2ee578982fd327d1a322c2fc74f3ed6b63ec5c0948de960aa3290e1b070d204f1fc0f41e805122d1b79548f4c64c6bfbd6a67a6e6c6cc7d98691edc05069c7e8b3da78533ad058601db13592ce13e51b04339af8462154e75cfc912b73879b80c0a0903c31d807793a9e6dfb99e6efba943cf59805cbb3e993845d6a35b666a73a46d41fbff04c74ee650c9ccb98c64c4bf1d18540d6d11532843e17014c05db16ed2b5862a055a392bef682dc0acdfde7f3c6902c88368ad0f6cf349a5b99f299c402649f2c5406c57d3518b657f0fcd4abe030f1cf6045dec7d26665c79c759c5ff3129f30d76989f9e496858b95559feb7ded922447bea7ae450383edf56d6ba0d005eac5987cd8df713661aee94612a5e78797316538925e5f180ad5817de51f02eddb7f1e4af13c5d13b1b14f972fe2e8b08cb85e37a16c0ae39996648ee7934c7860dc69dfd98fa35f355bff2009a41fba06209883c783e18d790698305385ec09aad03a363e2d33e5409c304627b09847782a322145829a42e7e5875c74b06e4aec80ba1591d9f3363e8bdea3974cab63b0d53f1d1573be22d375aba81a5ebe1284511c76dd90dfe151b96ac5e560f4d2479f47b7d4142669216145cdbd51359670c7ffb5e2b93d1820dcc165159cf51b8a0f5c6657f7b320286227df290f257b0d21a60433e6c2455398724f98aa3670687dfa6743457cf8eeede6038ddba831bba6979e5f56c45e256e61510c7099318ea7ca95dbb18e550b94e032bc50b1eace551ab38584ad87556996b802adc1eb7949f896b74b6dcc16aee9d93cb206d2023a368cb92992048e9f451c4642841899937a5df7916ec5ada360a46db492beba9d4d789a81314fbac366f32c5e743e923e02142573d028d7555c4824e03e912747cfc6fd6ae62a9e8a95a9fae8821e0dc88237f6695eb5519c93ad0a7c011051aca72559a00ff117e14e7507d6845c380ce8167ff8c6db75e2107f0a8f933a1493754a195193200e9b472311baafe8a50257f8163b7e7b321223cfc525e8135704f8b2b15e78db2c339e45275f90ad385b43aaa1761fd9d87451f1031b6c9ee51dd23882460e7ebb7ab1113ebd2497023a9d97cf537152d357c757e9f416ed3f4c456c221a9884ec674195c09ab39a16dfc1ba801a445c81b5fe9337b621993632ceab65a61d3ba0741e19ab74d5e3dbb57d3b848498dc494e86213e1278a9f152074e963cca5f9f78f4801a5b6803f2d0bf769a477e330fc8609e9a70b78ccac5c3b93dfe53ccf67adeb712cce02394dd75810df06da7ede1266cc88c63aee13e8d2b3124957e717333692d845379f423192cd5eef7e90ac66f1db20f90aa7f87197328bcf6057034db07246f144fcc13448011b8a8a2b4af9d51de9653a39b707d732b7a9f120b83c4e9a3eec2b4d613240c3fbcef887c1274d1bd48a59ccd6c2c710253c569ae88c0b281629a8c7a161511e7dc29533c4d3166c97f207f5d2eaa7a053505cefbf96d12b88f7893bef33fd9a010179aebb88ecf9433eb67f296c684a886a06f0775b34a9b387d0d9da05e6806a0fcbe0c906423b392f34fc23588f1b175afaf5f6caebf611cd4d814ed6a317914e7a2422f87d712c772b359c784138c1b8e16b34ae27beec6c1291e3cba582e386f1ae11d019161daecb36966b9c9a3b45c8780415589347aadad9d2f297f022066c1ffe6d1bf614c9671bfb0f9f2700d411137c8bb1f32019589bc8963e53a5931b0e6352845208002c48a70ac4eeaab050ada5f883e805cbaa8818bfa280fba14f2005ad847fa998f5681c8a40db08d08dc03e045ab7f79b658fd8d0ab3df41dd8a02237995931e49551cbc13c996c35ebe7dae90f112ef0841d90ead31dc20ea99ab8ba1182db240984d971394d8b79f490d4c2a844cf215a784524c60a3601c22887c6441b12ddefa4b53b0e442c522371c0b5660e6740fd82a9e3578f0f60a4818777cf245e03a01beb87578455734d34bc41d2262aae17469bc8a774bdcb14c7a3ef8592ffdf7f9e2808861eef5682c0f2cab8272d7dec9af0b48764ecf5084aeb2bcf39e050ae1149aa81f90218f1192f6712c191a2faf82c8ed52e1b77300f1bef9929b601e2271539cdfb330959f889ee2f341ed52fce9045ac8d71106eb02b3eb4130f1aa8cf37d354a72b44540911067e7b44604ef8c451186dedb0864b1be80d762aa8906170195d4283b6cd7e8966e4520af31354a6478c1f250a6cf6d9cacb53800ae2c06a7157aea7beda7d3470b04e3671958e87e11aa19b7997c8d72a9a38ffd932b40ebad7ebcff2a3dae1d2b5d2b5afcef0d1859a62b8939a9175c99efcab7b5bdf5d51b2c5890e154360676eb92f4eaea19d8f8f4251a45fe8e98b5a6209cb380c28f71e9390a2ad6106204a38c217e50bd7d900194f4c838dcfcaafa795158894bb169885ff056e5dafced044a5ce1f55e85823d54866ea978d28f661a0b989933d1815fba76d8871df5da6a7602495156c26e1f72c614d8232d214603483a97c379f455e9a1081a50b9c52c5e7911f537ab75bb9ebf4f88e9fdc485a52ecf59fad8ae048f4412ceb49cceb788ad99f5da89ab5896af6a4fa3c3563e2e84f45ec8490f80e0db48b09c76f3ebd9ba0757a37ab23497ec1075a3f2f0270a3aaba44df442b16ed8b8629500f033b7fcd3c2d19176a4b2e86712a04e5d060c553714e0ba8634af990119ac15f60b42cd3e8006344e363c8cd32b0648e498f7bbbd1a9f241331f7f5235713c8bab7d104fc7d5bd643759c309472fe5447ccc65fe2fc286478d11281c30dc9fccb1b6af439289c9aed09e1309260fbe55fe516d277026562136698df3346348a7c82c3d26dda94f459dfa18712cdebc8f4809ccc3ba0531fa695fc2f11d12630143cf71537f51cdfff8953f65f4316d33963d58738f8a63c9079d5e8b2daecee3c59a34ba1962ecc6958a2fb7eeafd03a3a7b6e67c5949c85e7cbd6ff75c23738139ba959b66323929760f8c28e10e538ee23f33c8a3fc057601e08c2df66d6b64a31513c83cdd3480010399e3700a9dc54d6b222b48e62a3a803a7b25b8a23db1d1306d2244b522295fee1b67e5ae97f8c54df6f647f8c8ce6920d586e18537dc23a51e4ad0eea16dbbcd9a71f18d6c347dca9301bd515a3838be6d1d0f480f0642c21b3a814e78214889193f7fdb6e6fac76b9de5f9f3e37aad7da146b4aeeaba011ddfe84722844272fe449e303a29f3479255a8ddee9e8ac16ade094149e7b9ba2a31e8038b9ca3f70866b093b9a52ae86002c2275596a5190e59701eba1a09da19e0df0d4fce56e949ef2c29c6b8b52e9d1b730aaef4da47f3c6297c15ebb521363db623f0d1550bc73848bd4c1a7de12be13faad7337839747159937c76d0d46a15e9314853c76f74a2a88bb80d94c7180794f2981460ac3c86e4e4ee872c52f334ac8065e811d94d179ac7f016366ab780afc95bf92559586c50400e8e07790a960697d7cbb33168f29945ff4ae9cc8cfbe563db00c183c61094476fe2001302d00548e2aa78b059c334f6ffc02e38b53ca36ba3de72f9677455014aba975484bdddf12d2006ac2ea6e0eec8128241821e9eccb1880fe5593da72959fd2b5914b4519d444e3ce755c1b3ded0ace7a053390abae2bf2ddc17608c11a3fc01ddf7cfbfcb676d6991f95c3241b1b6fe7586f2461c0ec08d73da50d393ee172681b515701c3ad786b80758017375a3e6d5c73ee046cb18ed02bfd4bec41ee55b5a7b7b68c90e410c536e2735024cee0b3bf650ce0e3bbfa7f275a8c7361e099fe76ace4cc1bed2260e148635a7f96968f6c6823ad2def4176f90a1bb79f80b4e3c44e16885fc18bfdd5328aca233e709f458d466e4620efed6a73e3e67fbc186bf1f9af7e49da48ac715cde921b97233965847ddb38b50727d144c972e3327564249dd5a941c523af7658c210b3b2024a2cd1df5d9603d505322e4882d9933ed41d1aeda34f227abdda762738b550c8fe79a98afd3319a29004a7207d6f45212820a5eef2ce61bc94342b90bdfb46d181348b62fd2223bfeb0a25e42c8ba6908de01e2149add965fbc6a600e5591f3c32252bb9cb2a454e174243a79e66f3c4abdc16b04a64f91e4331be5227a61840040c51a70222a4feed670be36d27e88d613cd374ff01e65140abefb56c2bfb48012b0996b5a6c11e32b948bb974a496c8dc9bfe884b8383ba7edb6d877e391921a0f2d66c2ec5328d7eb5c9659dbc98f5ad1d94c5c4c55f1a0f4359625cd527bb3067bd0c1e7de6b922c4ee7e81ffa760a70c0422d1568afe2205b970a1e5f42cbc41812c4ffe628d5f82353e514a87dc433a83e613941315e870248051ff9adf1c449747510de127744983ada8c4362721cdbc1fe74e206c98a3c78d45f1e7039b07ff5533fc348d6e96a80f576032e43b75bc8ce109a3df7cf8681ff4a2ad9325dcd55f49ff210997fc6021684bf900d40c8ce3723700537f7b41c7e8da2a10610c65b16646c3cc97dcf6503be58c0e317a7e736f11a746d7c3ae6ca9a23720afb9a618a980728a58d577c531aedbaa596120fdaebfa1a25ed61fb4d99882f95d3af08a650848f81a87c4ad3ef3210160ca6d56bbb95ea6e4aa6961ea2166ffc724e73637dad00a8d485ec883ab8ef47cc950e0d86be9ec42dccf2ea9220f0292e42edce6a0be812b26593697fdc30d7471feae58173a53003caed3b55491520b5d4946ffe0fe5698b2b8eaa953e01d1440285ee3d184b4b31d0d1cbf1b907e74e3517a0c5f541405993ef6eaa96fe9a7ee4d5feb251cda70a02215c6163a4d40c3baf986211bbab9cb2701d431b873cbc2450248cc1ae615cdac0068f81802da39491502b3344f54d9e3252f9d862ca1a7f03a8c85bea4f0e30397f524322345ef385419798151ad54bcf11c65a90e3fb9900f5ebcbded294498ceaae378ae648c4eb152f56bf5f73b8777f08c69978ca4c5d3465000458a279693ba19a2e92ebd8758c201d877b48c7a179c17728748ac6667b541c2d74cbdfbb2a89b0e35190d1d3c6b1334990ef0d21f23976715b281f87a6f43e12f5ac39cf7629682d17b299a10dfda57a9896bb9e4a285ebceaa9818a17338297fcef15437fcc3cec1c8063bb9d5381eeea01ce4c620bf9537e421983c51cf9c0d40ff1095b87ec26778972e6cc81f6c933325f38c83e26596340ee6f020ed788e6b6408765e5609ed1a02125c793da89b3492545e8b8d4a6da96df2221ad4cd1db6f8d5214a750c344259173556e0873eabb89226747d53afb5c4ea952c8cf4368a561776c68b02c802c6a55c7699e7e0ec39f6976cd3276db111a25a235553a6091929df552c20339edfdf917c6c466d8625122b8ba114f763f6d40c9f688fe1a8f01a90e585efacd8a059a102eba514bc21a854fa0f8247a01f49e03b19e914d3c72cc646c399659fecd948838df1f230fc55ae87f10e9ce4c969b5beadcdfba9ac8ca5df47fc69f38ab4f27382ef3e03fa6de37e47967679278c8950fe78c9887f9bdba1838fb8878ec3c5248b152bcefe8f0964ca954193c9c0e68b655bc988a2af29ad9f97edeca777","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
