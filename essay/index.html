<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62f87f19bd0b2e7a0dc7ed2835a3d7f484acd1efa3115e3dd6d45000eeb2e89c5d2a190b24c5152896ecdabd4edd8110009182321b5b337fb5b20aeefaf96de21420a1153678b69efe3a52f67ba613535e081339132e07808720259c7c234c9eac2cb9c05a3dd8ab83734ecd896232af1f636b24fa35742f0780fdd1db08e944e72e727052b7988da6559d8a52d766b709ee32a348509bd8ef6401bd9a583aba00942e5f83733fa940119a0e7c03ad8deddd164cf64d3f92cca5719d2948c5b4555097c78e84e3c9bc5bc43b01769eeb03071672a05a6ab4fac8ee6a619deaee3e80bf73191d576ed82990b8b52e3f67f82a36bb110d58eadc8cb5bc7d25ae10785d2d2066c74a7522aa52fe0cce43c7435aabb79ca9d7041eb338af5d09e4fe479ee7d5ed7910d6e2b437acc6fbf0b5e9616be748d058009128a62f073ad1cd660ca7363083610e94d294678ab46ca41f4937983631c951f8aedd5008b95426f4c0eeee28e4f4d16522d2fc816c49bb22e90ee161ed8c7c5891edf86d842ca5e96d629c887c2c7a6ebb709999d31cd5a7926421e41c210db67ca863da13d673fc93bc6c388de8e2e171902814205417b131e0501ccaed6f89f3a3527f370617b3dc584b646d86d5230adf9cd7bf10b534ca54f0f0b378c8408f90d20523e5f48260c1f1f55634ed03e6f70e681b3e8abb85c12301f44120a38119bac9d431708db4ccf005b38ae88b705a0915792dc240a8897bcf577edf8368aca2a0f9786e6eb49d34e99e1b9458d8fc9458969ab9fe7d15fb54341ba78567d3ee4798213d473fef41e898651a90e5cf0b259f7d8ff595f62a9bed5a2600f2c99e31f5e2b8b2bc8e9e5867d958cc1584414800b4f59b2379f250031f5c5f7123d8b83f6a3befd8e2ce1b7e03cde4a2520bb46d77906e77fa99f0d22f377e7d0e41935ea4b67ac8831ceb6d78d005d30ba51e38d6760233e0df96ce04c89991bede674a255881e252b86cc7ee1bb94c21e625ca654b448897ab66880b2af60343ecfb4a49d1457b53ef125a7bd69a576f7cf81182a9c06fa60dccefd2e088ec6675e6ed957df4a30548aef69a3cde729b3f8b1d4c61963cb93f853c7b182866b132f96c7e3481c5183a2ed2e1de365125f0b63bca9eb4782f45b0c6ba34501309eff9290ada1d9f07b0524144c95ce0df9ba532f76d8d0873015dd594f137ba51848ea407e7cea5210d9f434f4f0b38dc007448b248fe880b15a51d8cb4dc523ba2d093bea3ae9cad26dfd6040ca615f481532ebebfd3cc0b2644ac5f4d78443ee69def81a4a81614402a352448fa8e13c11ac267d234348474a0e031287c644262d0e4732e7283cbe4ee058b411324dd90f4dd344296d41e9b2a7d38d87741422b5035294093364748b7b66ba5c0e6486b88261dd811f75f69319cf1cf6d6775b10fb096c0a481905de27bf0a9015947d4eea723cbee6e3f31929fc4473d10d13e9f64b4e244e4a0b26fb940761f4730b4d3c11794bf40fcc50c9c1eda86574977cf099e84a6d433906d3816c715b893ee51cf40f04cce32f8afd95b8c64ff1577efa3611008aea3896b3e9a5eda2216a832927ea8c4b870016f99f9087f9890eda0af6dd9343331391780a07d3a6b0a3b01b69ec54ac49a1c674e05ea5b0a37f0acb1d5616fd0f6bb58616b7b07fc9d946fc4b237f36db8a9e22ecf7dc451ed036c4424b7aa6cb68d166d8ab8eb5b7c3c08d8a29583e7dd15bda0c61ccfaacab1817bc7fb67eba72366d23efd34dcdf9f5e29d8a9dba2a3d057994f2590f167fb0b1d1b732ba079bebfabe149c0bb88d90b9bae24bc7fb10df9afc75a35912fc8a1601fb29d4fa038dcd9ee1717b49639adfd549c7d7102c1c96cdb5a54ca0be42e9c3b5af02c85919a07f30fb59967c3c7d8c8faa8271a1fadde088b47af1c221c7ac0ff0b3721b4c64a1ef17bc63e667898982ee8937ac560da7b8db3fd7f57c0b11bba75f303ba8224e32a858b9b3edc509c2b1e5e70b228d0597c9aea4550ce3a890bc00e6cc18011cf5f3d32d272b0892bcd0202d2fb83dee51531abc5c45bff451d0eb53b45dc5bd055fe5c317fa360aed5b02740d2bd506e37abd9bcdd68e9c7b0f6cf97e76f790e20d5db71a40e14a799eb7501d7df285cd6f262a3996314f3fa65cf1f91dac862ad5f600239d3484c381154e0d14e097a05d7c78c3765ccc236f44131808f167f6b009c54161eaa71ee4e738266662a62b77ce506b7ee864203d73317732b33cb61dedb173934042dbc0a2fee0f00f3391d4251385e3bd80609ed154812c98fa8b06c505a1c6573e33d000c76ac0295412c4d798ef84e8a63e261a48d3147c9544fcdd7b100ad866a0ac13815bf2b0cb667997f960b44db906202dfb2e2cbce043359f8849c5cccc5d920b5609978c8419384cad3cd4ed6b53a2885a82ae13d143f12fb843c05c343f9514695f6849cef7466d0051c9df7109e99a19cf19a5b0c1b603e4152aa36c9c0f1aefac75d1a41d5af49c638e88d178cdfcacf198fedd4e71473eda4948140d32d27096c35432b54f18572caa1cb1e73e7df41d20ff780f09ded28b0324cc1436d6b048df6ad01057363d00955d3c7c55a68037b3cba7f79808f402a4d094671f78063dea80b3d78bb4389afe6c6347a8611d9f5e90a29812091053589d03efe467cb19a54d5307f1234fa6a5da3af482f7d66246bc8ca3e77134bb210fb49e0bdcc7f40234c8965bafebfb843b7f3d6f8d8341b3be5d1e49cec4056d9095c0303aee7c401971229dfd4a1d20012f5fff37819bf22caf4fa52035fcc714dcaa9f9aa07f10c57950fef52be45aaf10fb8af07ef63003007dca644d34d5828ebf29954df6ee1ea806715fb934bdc531ce77db39b1e1e54577b5663280cba83d2d2d27e455d9fdf83f29e086abb06618d09f08e47d7a9c7a9323ad414266cd7bc09645efc5cd92f166e73edf491d27f4f0d4f2a7753bcde146760fd53b8d7b877d2e4ccbb2ea005e6c07dbdd2fc67662cd9482a818a03ce839f405667771e213e1fa2d2ec15ebac7e6653c1fbeb4e8cebd244495a1c0c9d3315f6546f3a4d795690247da46cb408e8f702398eb9329011a5f859d68e38089e3244e7e07b67309e8f9cf4fa17c721d447214cabca104ddb97d1778226d24283cafe576d41c7703df5928253904d81a12b1461bad2e571a5d371b05246a287f00ec85f27076d9c6fe4e414d709f4f4c91f55e9ee167f8c672a49b8ce8d140d20cc60a07dd688dcaf3be8edc4dc4be26aff8a5a4c56a29cb754968468c427835f28c005fac9ea91d1489feea36e4c9fc99fca4c56721f5e32debfca714fb4be54881ee2539ee6df2750c02fe4722a80dec43128cc87e9809baa6a9b659f86ef3fa0cad190a5e532b855370e32b0e6c51738c5b6699657084e61e123b7ce6334ee80e9f57d688939c686e62ad89dfc46ecbcf38af1dd1409596fa736b23d0fdec755055e0253072a7746761a3d2c4980b7f4706ba1f64f861aa23a18f1b4a19232dbb7c36b24e9a41e4170577085732197b4c3312695deaa94ac24b8fe157b55c9a3911fc4b65de38fb5c92fb798aca23ef47ea5c15a01c21d7f7cd1fd0596edd7ef9bd1e426d98d6db988a6696283e8c1a13976117ad6cb08c3b0728b42a516d3ab256a3d6a95109d2e8eb02ad10cebecda285885e3ea4c16b1fd3d7a661d73a1b01dedad0986bf64893f33a13cec86c6e3fb793462b1ed90d2d08ec8d21f742eb3cb1b3f8120261ab93ac70328ef690e830b89ca93b41b5e3cb9dd39aa205cd125d9186dfbf5a9e63fcca9701c9f9775898d3e3d8115519ad92e164be7249a4b077d050cd5607afc975d602b181b17d0d53a38d7e2e8f46a9d9a0207b0ca60057a590aed831de49e8a73208481925f1b1f27bcd75c125ad1071c4a8e7307505e6268b53682aa5ae7ff9ae13b6bc3aab65187798319b251f60e64c84d80e44efb87529e60f1e5abd441e0de64f2439c0d0ad99f4e9eaf86c18d076360a86e110790af91e38fef16273b6030b85f63edeceaca889efc3868a507ece7442dab088b8cae8d5a712543f280c2fb02b11febdcabc489f3c2ee6f5089fa62908765a72b0b50c388621574033f1a5c1db9fa2f0058e316159ba8d71afefcab3570077373f7fce60cc7577f125893836971e54b9ed74ae142807ccc8c1a2702d00f86196d100b221a6786a188c9979f47f53b45e7d435df68e54b25808a57132d36dbdc6348ac82592b16a834c0d09a8e5b4c708465c97a4db25d42dedfc47378c1bf4ba72529a7d121ae09584aab0f18337f97f9b47b4e4cbc805ca94eb113ba2cbdc6c3be0a8c0f1d614d2229c7d952267153c310156b4a91052b7def4649b016bb72b2d152c116f33493034f7a73cb3c98975ba69275a5ba476134ccdb45b1c70235630b84320f75b7764dd84f38a81cd5c8a3e800ab0872d546becb2bc32f3ef061a6280e014ff92aca75c77af0ad0a6c67edc58040977f3fbaa57802e0d8c96814955d47348a359108f725eec2c21beb33d8847286672645a6ff05654a587fd3ec9b338180cccdaa33e88a988624e233f359ea160b26857f6ea83a85b372b5b08abbb81a69179eb2165067bd791e62ca246e4219d969f365169f699a9764ecb57bd8a0478a9fd8591934d5218879b9a34a5f7f7c0e9b7ee81ce65571487619df6a5c461db947be10689222cb8d808e4c7d054c2875c0aea2985cc8a504f5d06ba6b441e73e967c4b862b745f75a243b719d5eb1a537c6851ae3548cdea9bbebfe9369ef2c4e1e0f9d663a7c61c5438d235c7316c2ae6e8f54f8b6155559c14cdc655916f38ed222e4ac09d7c31c57d9413e1b585ab2ccc2b8f7b4a9c8765ac43d646c4262316bc27ea13058ce805db5312fbd2075c2100b16447746bd639d4d8b3de3c87e5b79aed41a621e459ff72bb26d04754218a60e3ef5fca33361b343dc7815ae07eb3cf0a29ee70da31ae1886a7772c60ff6c76cdb8cba69b692251d78b84f18dc26d275f8cca1d5d8f2129f283ffb3675427d866376f3fac6f96e52605f01ca03b2c82ef156be62bd6209503afea6989f20b2db193973affbd1a9df0b3b7fd0ec528e571fba9c6c15d8f2ccfe24ac05e3f49283da82cb1951bdae433c560b68bfa691f2642e428d6755544b76ff27aca97e85178e17663ada0ee1b2cb9642ea7fc008aa876a66f1792e0e9000a0f0bd7a6ce864d31276f0a0e1c835c573cf0f002cb7245aacb762a1ce1b6c91664959428024f1eaf6e37b87a66ca8c4b1fe484638b350f655f17e084a9ed31b877832d1c9143992ccc521aa270965d9474c72305bb7c9e60c29d7c324949230abbef2c741fbaf83df4851fe035c6e97e69dff2b430c9c5e823dbb9c49e948178dd1356ab508b7bc437b5dde2771a6247e8a156120cc3a48001c7549d183a6ac52374e136e50f92e514868f41cb32e9abeeec47392b02de102139abd37cfa0df78c197b24e324606e4758553dbc2474a79c3ffdaeca2670efdd7430572722c9016787c939a144bd96f7a03202ed3a944c91e5be9c04a3598da1682badff0a20293d702dccd6bd2fcd757a43224a8dfbfbf3dccce735f27ddf8daf67a9fb541ddc0cc5fc72d64df3ff26fd16d8b11e94eb198f16a9e50de52a484d70a0d70c134ff7f9777bce5c33f7bf38220fbf32018af455e8f0824d2c127fc66e7401b6af7ceed665dec1b9511dd32ac38cda01c7161e0eb8c7ff375b28099cdbb16265b7f611d0a1373a0fea88326d86d0cb4644e10f3ac2a84cea20637927941728f0e68a5e6c7dcbb301d564d6fd4d4c4330023bd911abb3f4ad1a4662cf215df1a213621140032c0de9bda22d0357a86756912be00a07eabdfbbaa22e238627cb8fca5ff3c1f072becca34489f6668ad89f606e3918a0dab66bd06ff8b304ee54b6e786b9f245c2119d94210098dca03c5eef57a979db62abc3e0e9c91286036623e4e0562ea228a660f85282989798db9591c73dabe65a287c36a55a2170d91df63cf2984e6d6371687af86c04ac1116c92ef3754a1d2792b397c8347c1a707434d7f3e4ff80fd9e0b0ebc32359a9043cb7b1e03615b5db0795fe11dea48cc87a92354ccb5f95c2741651d4ab6e6450a29e1b20cb69cfb65198daf6791ad5a1cb13b4f20011c9ac11b5a832c93e2bd10d396ebee1c0b3661087accae01a845b66ded00982872d40f465ab35bff29d50997480d3e409b31615655aeaa6fefa4aef502691de29dbfb050337cf087782a8cb5beb86f53e222fc7f2ab19206213822295a1a9d9d0679711ec0381834179a84627c661a3d7b6cb6a8475265686c7d50c0a4b0662b83f63e60bacf82ad0e1ea8b992fb994b858dc1c361291685d410802d9c66e5c2c9c09ab0ee5e20c32e46e096e2aebf03984e03addf6af6bf7fe445bc141563c77d4102b041160a971c69fe7640a0b430dd984e343060fe7567408f4ab2ae936f30a7e1b8b820e407d54a9ddcda590b76b33941eb5558e19de2793ecdabcc3b20309fd5fff2acfe586f1c383fda6f58a8db32a650c73dec7ac4fe2e3a4e11c421babec637dfab0e7dd27c8b997c7253d4e24fef315edb7425f50e2f9f064f7f99902760a14078025884acd832f8168b3d5c4233fd201998a616c861b83c6cabd37a546c6dc23b2d8e9bc1886d7eaededfc5a06e3373b9b130399c3f9bfc076c9a3443c6063146b17ee52c10743116c899845a712ae709cae559467a8b5c45b8b71e1ddfd51035d9dc3f3dee7f4d5e15a640144ae83c0af11f6b80ce633d52d5c2edeb29e37aba9639239691fd9e28f81d55d014ef148fe22e3db8698df8944566c45d084fa86547a88c65f927b840933cdb89de57d79df5183874227bd7c8db5856da618cda6c90bbe74b14ffd60db59b84b9de39a6ce4de0c06be9ec5a9afd732d9e6ff6ad72a9eece002c14443fe5e30d9659573ee51a6dfac2a4e1b4c67cb78882312ef39605887838bfec8c1d980c11f073186db25c423cf61711d004e4d380236ad42f412e29d446e586a1360e10cc0ea2f00b932d71ffe73dd3f4826098d390aec2f2c7c11cac8322c0c96a332aa9a6d362b9e1219e5cafd109e9a465a6180ea3398a7ae8636b5f2c99103af1c2daa61d3a111f9d9d34ee1d11d1df24e9351282cdb70e72a056c37d61a259ff9efd8e4c47493f6ac6c7f8fca4144b05e39aa8b9787d45ca662538f43af10c95d1d41f68eb942519cbf4fb3760682d595c41881d3dfaa987a60d2db0099d1e091dea25cd469f842cb20c505b26d01a2eb79991f517b84f7f3e1ef3f72be2d38911e5ad38bf2bff812b03b01d1489fdae0538680a561f51eb8ae8213373d3bd03b9195bb9abef3998f094321c5f8ffb7e307a0a1227f3d5d500e6f603700a0ac632d2806c7c69979be8f0b446ce9c0b916d88c0cc3b1ad779dc0bfe9fd675424acaf3c04562f702d3ce196e45ea27cc9ecfea05df18f69a08f8503f84a4022bf5570d8a2eaeffacb2725dfe18a9e8884480f7eba88f7e05820396cd0939578fdf0ae9b2cb9fba761e93a1394433ad77db917f89b3112257ca7ecb63fac90b7eba7e6a1c5a3623e58283ecedb06fc445153324287da82a364cfefd20e76971a55798f3f7a2e7974131149d76df8db4ee7b5387e4cf8d1b257bc3ec770305a1791bc28ee49511576f9ba4a13b97d55e9898bafd8b79c53e2cec0dbee1902d750a8b2cde665191fc3a8079530eb3cf7dbdecbcd697577245ef4dbcdcfbf608c7a3925fe67266dce55a353a5d315671f0b6c14a3543cf8bf2c892f95b241950f8a59f37265f7cd2f00b73d28b4cac378bf5b501874d54b124ad96650dca39b88edfcc3857e74998ca707fc6ab11123e72d037977979567d1b93b5641036f3381b7cf1e4290db78f45b8ae115fa7b48eeb4a6a69588ec5fe2f2e9e9f281723dec8c89a85fafdbc55e0ed272f4340e8161fb356b019c75ab7e6592e0fa354e96be7ab0573e99ed06b29465dd136e145dbaa588012e4601567df7a90260fed6b22a3a2387017a8af6a4c4db9c70ef864a25ec83ccf66d48f8c839b857536bcb963bc8f3f127f9d4cdf3500370ffeaee0c67bb7bee95b4fddbd716485fac909262ef99193bf674a1cfc8f447f47c56b1f6615437c394d2cae3332ec0e6d2bc3e0c53ed799609d5e7ec354c3a39096fbe28b46985773fd10345adba3d3b3ea6f44f01d9ba3c4b1c156e03e4a7410da70a2b007f1610a873a4e3d6de97f2f839816e8420c41d22c8fbca70b133ce64d9b2a0a553b4c1ff6896cfd3ff9115cd10cbddf9b5798cc5a5d2afe20e1761383d24eabd61d56b66c15cd5181a143bcc2daf531af6c7c246790584276b5b590278877b55447f28bc50476ce55599552191e43159c81c1ae69b796818a5f477e5fbdb940bc610bc452295ed374558b75f04a33d59602f41930636754fe707e4020d6d3d05a03be19da39dada39f0904c26b79c2d65808df329a6f6c03b1c91895ba163a7dc0d136aa2a9ad1c2b389bcbe3c17d5f4d25ccdb4be3b4aae5db5c1587019dd5db04a8018e2abba92b30a6854db1b91e9ba347ba94e4fa104b90f53dc3805259c20808352c1026598cd4c1c9e8ba100ea66ca35cb96b2ce7527f36c80024756dd1808c73da9d15bc839b8916ba52e17b12ff8c5edc696c048b07ff94178415b76ed74bd2f1ede9b604f7b068b88f1b4e45df6538a87feaa8b9ea13445f68181745d17b2ad5780758f17b1d30a11894bd6545ff84592d7180baedd7ac700272a8feb916552ec2708f8317c0a83fe77c35509c2fc5aea54770c18b9594f7f63aa0d01a4ef0fc71eeba30688d6c0a6c83165dd0dc1dfc0c1e2e65d293fbeaf6430f239df8887381c96b678c93fb0944898db9b8732623cdf312b31b7abb459f02faff7ab7ff28b9d760128d12764569db23d1d02d98b091cd9c4b76ff575076c60f701ed3e5041c905c7cee6f812a4d87fa25d27d2775b1d9bfa7d1e74ac32b453af706b8ac3e98f3b6240e04f00731192caaf4f4740ca9e7e39693d0d694e602faf81cb5bb9f03e7992d01dc70d3391df08e0cf76331953336903a87d92331570934d69cf912d49e60eef59f2deebbc35d764108f9a58abe63298e59c9751036b0778b3ed0db029181061e3bd8f26904758d1ad8da5ce084ae55cc76b41141d55f52d98803cb2321e3875cdedc3dd206d9dc20f3150c79e9b009764c8fb318eea87d2f3bc9c57ef8840a59dbf0b43f621b7ca72ab3a84f72ca8098b426fd69f5eeef2a6daef7244641764d2b37af04a23b1c6d2549e759768c1fdfb09f9b0885a6085378b53b34f3494412cc938ce57c2e96d44378b9bca4d46f34bf35b0d5c623fe20401ba6f9d46d6d89b7fdfd18f9947016fab5c630b13615b233cf7a3fe48e9b99ffe2700034f5fec1d2027444dc55ee6b429388c96624b565cc5bf585cdff1ac9831c747ec1b0617b33fcabd7fba51e8ea5f7f5574b329c5dac00839b4634c6807e9abbdb3b50f938a10f51e407e2cacb208f923bb34f98606353f2b164690d857618eed5e23eb24074c287cee7f48a1eba3509f2fc044c04cb38e2a2866924c6ff0184cec898a131fc7ca3fbe53bee6bb0fa10605aedefb50af6d69593dfa98ff3e0fd6af9d4aceaad3efb2b697023c70d56af689fa1c295fa7a61101e86fdffc91ae782f3fbb1288b38dce6d34fb6a306048c5c8ffb49c222d907b0b1b1ab827fa94ea60c530dce6144baa483b369ddbf3dab1854f42e7e3f7c55293c4ceecd50687dcd9bc7ae60596d097472fe24ab4b091d61e67c29851b1f34fd6cbd820e5f8c214ba095f75eca0d693d07363d6f7497a7b9ec4cd292e15e7f0bd22452c3838d6f21a076444b8e025b2dd75dfe1d2e6d2c84dec08ceb3bbe8bd112e5fee060b63e3d8235a138ece761c9605442b082c6a3acc36cbcf82a84","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
