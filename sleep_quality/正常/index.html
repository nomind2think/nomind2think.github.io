<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6152c982d31d2be4469ca9178dda7a7f4d8e2d2bee03fbe5adb772cb34fbd321ecffc5ddb308b72adf4e6b7db5855bc93b4656af5180366ffb55de3219ef25c0c3aeed5e7f19cd7af94dc6ad029790d5bb7f2db5705cb9ddd06fd1b7e04874598c23e02b4cca9a1954b5df3bf94a3d0a2772b7f7d13ad79372ffc6ce0c8cf4e0c93d631f40391dfba498a64dd111b54abedb39c5f264752ad8dd2427efc4d4808a3d51040c4c00b23cb914c6e9682705dba5f87ded130db7253244e005dc8e32baf0efcfec44c1e93fee17139f630cbe66ed4395d2d7d846f87b6bff3492e04d4563899beb644129fd3ce3a240f60b7071cb3df647a31d6976d835e064419b8974c42c424f305ed699c0e46dc04e79980a27170fed372626be312b1d9ff502e6282756e6e96f2be974df7567e233529b2eb6b4bd35bd7752d241781c4710d6064031ee148c6b1c0c6d92cfac544e82e5889acd6ffc9f1703991d9b75d7c82cf659fd1fa6e6dedf2df67648c705bf02c2535f328162d87c75fccd39975b7644cfcac290d22eec78b3a026547f8ff259f686ecbede6315aff13f0d1c9b265b0dac53ae88ad739774bbcb2491165ffcb9a261899f23cf73c525c29794606ed9223d4372cb2365ae702552b29307a22c1328f5bddccc072e61ed12594ffaaae6e963412431ce629ff013440c8caa8b71e160e56486875d56479b2ce168ca01ef29377080f08f152f1353c2550ade99cc222b3a5b542e40cd0235d29c685fce98dfd5c4db15138d1f89a2b00751e36cef5f305e9af5355dbdb68c835e394b482d06e49036f2d43ee3738c41296553e22d84afbf2c8dfa03bba5cc9881374290af15706791e4cde119187a078581f7bc330051678702b1e71798bfb375a6ace797d226a23f1427b5eded01edbadb2b1dbafbdac36d96b794aa1a263784b20e58f138c7d864570212d0f48ea6163a48b0da0c81de6b99b25ef7d7cd636356eb680795791895c882476782e3bdd1f54f5d5574b73fa42bb477b24ea523eec85ebf008015b1a805a0c8ec3a56752aecdef7a1b72e4676d9def0014f53c20d5df859e983b7094e4ded51949d43bc57f1cd5ff50f9c7fb77c0cb655e0ae32c936ae4df4a1102f250892361923724a4cca54bd6780da257c959644d3a4f4dbc7ea5d82859ee890a6a355605917cf01b91bf23e77df26f3ff1c63ece60fa09c2927d9d765eafc9c9ccd59823274446a4946624b1c205ba94f210760711f62bc3db0bbe44e826c065538aadb65e436507638755f85fa58a89f6f5e1ddf064120158d43aa935592ff35654b91cb4d95cf7ad9f692d5d8416b5688467c48e71825fe0f4614b0f2770cff632fa0e70fd84db995c9a09732b186bc330d47f53280d84b9460cd802f6b4f375559d5cdc1629875884d6dd4037709f057c16dcbd443f84aa17940183084abc2af185d4b4f58dff9d76c7e6ad68297c008bdbde0900758b4502d8dff74e3ab4a159989cb2aafe7a0b314bb2a99cccf83ce1af95c5fb1d9bf602ff63869c675f9b024181ecbc1323144f50b70b8a9fb86349a4ad76531f4d2230c04be33598df81ca20df01bfd6841d425ecf787e0445c60c935a41536d8bd9210700e467091255d6ad3a90c0daecc012154888dda90d06c2788a1ca3dd8f62c88de8727ff540af20ba3243d50ab07d64ca0fb6e7562bfca41574425c4020a24f0c3247b2bad6ad398405c2d26b0eb405acc30909ef4477c83bc8d00f8513997ad18562d2b828dd80c0332f8cc8d1e13e9ad9aca70118956b123d6cf2dee8eac366bcd1ce1f911bc41a516d1b5ea4cbb4c09dba3827803f1a06d4586ac30071d7ed8f9167573526b74782c6c57f16bbc3ecf25e08ae0d1b4bf95b9105917618592553564b4d404bef84df84d38c17f305c7b2ce1aaae40b67854dade8b50866130e0dc5b57317bf6c60c49fb755320fc03adae507bc4584628da4ceaa1e38bbd006fcbf374417fc29e33dcdecccdddb3787a35c5daec9b2a0b865e749813c702f12cd72f36fd1ebbd383f2479e3c6a6a228a0d7d21bd589e84e262416ef646f915aebd3fce49cfe01f7b40f3bb282c0e425c5b69847b3557a09ac9b16d707960842bd88b8b01ff72f9f000ef26ba79d7173ed44537d3307d3b007988d27dc50c8d6583a6c7b21e2237a08d8ff5add748979e4925e2facdb9d51589d64510420ee7f97baf6df459dfc312a71e619cf546dd55dd75a8cf86116954c33f31bcc5bd76e50efeeec661a5dcf2bbbbb121240ef4f5fe5b8dd34c0d60aa113e6bc1517a89b83c7099d22e5b0e5ae5135b30ae2f32982b7f6e7b4b50b0347bc02854faf88f06ac8773e94a6d2b01095f6b633928b345fbdd40574e6704cfd0d2215ace23a823f7571031f0f67dfc38f993356c4f7f6ba2ad886efd43bac5c92c4ecf1f24a7f1cf6f54753efdcdab8443d696a2dfd981b35af7456aceee069128d1d05985a5c7ab0d222446692465cf31d4da13b2814cc66b4f1116dfa4e4411d27a98fa778ee8158fd6931ab0f88da5fe4f1d4dd902a2746f3aa58557f1203646347593fd44b085619da65cf783d35e5ef6048e8b4d78638d7f5a0f05ea73f464d1d09f9d25f3f3c83c5ebc3ab8bfbb6b4dc5442171ddbdd39e1932749ebbfdbdb87732f6d66050231fb6489b29674e9f122ed216cb58145c3aa6b91583550a9c69c07f189e946c7b5ee79cbb51540ad6e0c81f183c6b99f3c11399b16caafe976a9a221757c772ec79f6b6131811e9b129165af016d86e2b1f040cfc6e41de4873b9f0a76150ff2501ddc990db1920365097b48929be201df1903c170d9b60a649fac7dc38913c14f5b07c5eb45d134d40fbc350e90dd73b0defff56e4e59e0799ab45edaa634e09fec3bbff7e4d585da2ee7bfdb6d543d4fc2ad9e5455a3410a254294326c916cb793c23229397e5060cdc0c4c8964ba628e5f9c149f2986c3c9790465f7095e1d13d58e087af20392239faae1ae0b0b969fb499dee48d988767800ec6089bed342ea64dd5b34354ae7b0fee9115542baf4cfd7aed8343b840729d7634f9006a2f1e6e704f8ab8a70e40fd0d7ebbd86f793a1d31c96fe7e043a67e97159331e241e7e42c3e33d768994a6155a21638c1d0c18a6a03690acf65b6c4888078d7c8473f91443b5371de848832535e73898bc34799429c8eb3cc16a354bb0deca2e1f189693bcb763339d3a0c4670d7f6950efff23ba16be9f675f5765619b6d482b92a7e3ff4984c05b709119f228925b4cef5c2564776e93de8cb3837cfb128af09592af40f0d7804fd1343251cc2e731b4449a8e3389d9e0e5d6aa4d130a8c4fae9d50aa3b7625bb6c772bf0da9ac9f40aa594037eaa9b6aaaca5691ca0a0a054565c662f71e2815fcf534e61ce55b7bdea2582b1dbceb00bf389e5cd0f520f94f82bd5224ea07b3b8926038b9a9e4404d8f2d2979851a5053c4223902b91f3401f6b6c6ea53ed319ad0de63eb4eedd56e6187f6635601a5a51419148d867bb98361e6fb8f462899b8572e07aa56289b96fc7b78528092605bdf74544385d045b34a0bf6439e751ac15a243a246895a0462df533e1522575810760d01cdd755eae83fb5e4edbefc4181b96f7ed64ef4461714e48c2a21ba37eaf09973f45eae7e055ac66ee6ff2fdbe340e68e49ce9223907d1bd30932aa47e91e025d2af6b3bc0748f38e67ca8c8dd348867a68ea0f0510b32007aa6c3838a7d64a37770aea356ebf110856da67cc73ade52038a2bb7917af9aed7abaccd50415eb35e93da475b31daeda980fd8fbc0590ab881f527ed29ee4a0721c2002c63147575a0902678342a41733a076f684722b8063046e76b0a265973d29a00ba6253d8261439d92c10d6ef70969e70826ad1ecceac5a7bc44c3f277e899e16515d9a79dde6f53e304da267ce96af8f09a7adc3f1564403ee4d5d8861ee020ffd165138de770be9d78f2b3f7f2fee4c41020c30e7eebcd000b77d495ea26fd372b890cf88e56fe918c388de7bfe500dd85f9bbe12cec6c5a8191d2ca66c173de02743ceecbb6d98e1296f37eae5258e8395ebc693a9ef2a24f086318adba7d5e3526491eb8a91cf740ef00e7e15e1634af3d53fe2861383e242b2b8aa60745abd5488db5fc2b0a395025c5f324ca204b8ed591ec774d39c0c82c3d6b06414c90d13529974d69d3b28dcdb3655b854101b254516a85221bb1c2ec52d39d46aa7f3bab611e22627c96cf17da814a97aefd689a8f2625c392d4efdbd0b7ed168f1c33e29cfe2d4761b5bb7e522efb4cc833804f9620c7be20ca6ce53d1dd0375c1dbf87de2be0805ebeae90e3fd4d71b6299d532bc3d3012000ae9faf56b36062be649fc0a72e012c234333b4ee63f3049f9dcf9799617ca7680630100f4a2c0cb2c7b5c1b117fe4ba0aa34a4c3378af46fb373f324221744e64d0669906a20e7f314605e0d1fdb605a21759b9231a22771f4dc469210b8fc6393ee3122445d0ecc0551ee440ee4f7e59e869ec6e9492961b3e2778541ac079c5182e872c58753d981565d2ef1110aac656ff15a2f8088bbc40656365d2b08318d52b564d53097f9c100bbccba77ca2db532519bb50c3f06a9ef8c836fc0ba5286dd31df1b53e13c9342160877e0efa5f68b0f4b04f9357b9273bc62d0698e6e19e41ae529a2220da009701c7a8ad23a915722c14bddf53073ea867ed418b913a283e2092470fe0dd4faa4dcd3ef233f2f4f87a351bd1a91c5f690d9ad6ae05cfd2f3e8e40c16030011d5179d77412a412d56ec5bb6cad89284fe6621593328b28363b88f607b1549ca804152d54ce2b9893db74968c3e36d70fafab167b9d7e52a61fbd11c00e83beada6daf0c0427d62fb7a1a54a52b92a050c3ddcbae070e347de1273a6a2b89860f93a93aed5a94610ee6ae44dc2a22db4e3d6ed243bb43d97933e6173cfd836d47905f82a831fe2c235ceec71fd33e46d0b5ae59c82299724332fc8d55d39fd23beaba65a38178a24a03db99bfabf093444efe374a7cd0eb8f835f5d04d1a180b4511569e66d6ab6758aa0e39c4daa0c098d7b4130f16cdd13f2fda5cc1dcb83418818b76dbe9cd14797d97c7cc95343f6947101ea65aa5def847c8e5b249cfa073968a4aca6aeec94e022a5b900c5fdd89bd06ea3f332b4e05742f71ad36764354f3d5db6b1040f3756b80fe68ecba6b1ded5766dad44753b6c0da53b4fb386ede92850d4eb5c90d06345a37cfff8c6811468a16ca17d1c31b87950efbbd6ee5bc26ac99fb0f743eca3edea3bb0f64d3dfca58b11f8c3a29a83a01b413259d9a8640b88845e750b801048df06cf91c4ef66aedaa60b8f990b11e1f90ebb404826f02f17a0455ff40d3d1e8578f0e9862a5202e94dfc51b6dd52d48f2eed1c8a78903e6ba106e874e375fe2135fb794d3b4ec294067615689a9445e17413addb6abd7eb32bc485d1c27d18946fb3fe012ef6655f9fd32fda5378cc230bdc74ef426fa48064d45b0d5c9238813eb061d4db7d5d50426917b7b827b93686c09f9b9febdea75bd85fb0385a8bfb5e5af0813324819249bdc4ea04aed893ff7ed73dd4a0701e61fdcb8c60dc7cac9c2252633ea2cc00f654356e4c1f518ef30006d0f66f233f4bbc02e7009d36aa2850b493c366d75f11868f114f993dd949783e3e032b1c6b257e8baa639ddf2e0cbd57b8752520cacb20b655827e115eb30cb527e52b588316a9237f6459b75f8c2202a003b0243bd6dcb802a4a941ed86821fd27096d9821a374887f666467f36ed290db46af924b6cacdec4e803bd179d762a124025c5acfff467815b62514016259f96fab87897c91017944dc62a632d26aeb41093b2a4a1f3deeda71f6608c62878f1140bbfa48bb5a4d9e40c6aaf724e86d2b194a9780cd790dc824f53c2c7b3bd649ba30629ee25e5ef61f33c2d6810bf3bb9095e7aeae7c7d48685309cb0967dc8d493fa4a4d1bed3327e7849706fa5726294554c2e1a70a41bd1dab24098677124e4820707201b317815f07f9640b4edf642e54578f6ff0f33723a98fe29f4c3b3ccf087dc6b024c1677896ff2b2d83e5d5e4b5492e571df286695226eeaeb668cd712794f5f920aad58f9ef3e5ff9fdbf9ebd039160290028df72775326ff1652570891165150fdcb15b969842e57903227cacdc63bbae927838d598319c63104ce0919e8a41221d7c0450ee4c4ba772586000c5b3063888e443f471fa1967a116640b6b1e1273c966d32474c3e8e2086a51f0fa926da61a96ec66c33ce5aa8e1aeec3f75d6247c819abe7a4247bbcddc060a65ca88bf1d2190482c7517564d6d2e26d90aec75a297a20cbce13e48a427bcf9ade6ede0ddb5ba940f23a3fbd5fb51acfab9f446a7385d54284c76338934d9a33fc15bb48c0f7b0c67541ab1217eb8b33c10d67ec7de4cb40bf756d1a242bf45ee36fd856dd3c39940b7d7d6e69aa62a9e58e2416aa8c6223d900140d47905d47250a27f88950369b3f5c723b408411f0dbaee594900e6d786fa1e40fbda33b32f4fea9a367afbf425d4666a2f22eff715279fbc286a8c91ba028afc12a18d6d4c1b91f15d8d10ac7b358879fab6059a1c5b1c01878af09379a591dfd37b8ccbff4480374d4206273d3c4be17336c53919600908d1b7c10e775faaacc5f7060a191ac8dfd36e8d133e7dcd2c681c82a3e077ee162f229d33c7e1d894df46859ace66a09a26fd44e5d815a9d925f0797da4e95bbe51f066736b09a725f46a37d5c62559bc9a8eb2b76bbef9f3fee2e3a338592393ef4a3420a2ff776c0cce919ee7823e80f3c495d5ccc8e6c4a32e993d77f944c5ab369449c4e5d64f39a064f16d887ff776dfedb3efa9a404e84aeba876065ab9504f6e138dfb4c8cdb9c5f2df17a50fbc63470af9b1247d34e215f8c133a6508db117aed07ace2774f892a8e649e14b7a6590b493cdfa5552c5fed72aaf5da18b37d2862ecf8c3d4a194df750317005a66be69d24f04103c31ed130f4d85251a57ee846ab9fea9c55f75599ced1a84dba52e985538e7840cae15b0c463a2abeaa6fd730d97b63059757831d159aa9f9426a0178c726ffe38faa4752493318c112a2c0dde1daf0d8e64deb798108fea3ab93f68a2f547994c2de41bdb1683545b1238f72b74155d4fe559ac7b247704b13bae23272e1d0c13c54041671b92fcdf30d75a5e8576493e47c60d43acd709fb6152f3e5e46ed71438185bc0ea49f1c3ff02032783d84cd404b118bc25e23ebc11582d9b1eae37943a9b27a6b7462b7e888a339848a0303d396f0220d13888abe5a3c2c3994f786f4f1cc1df4b35477a9ad331efe2aa2d1f7e88d2d95992d839cd3c1399ce770847db0ef33915a0e3bf2f784a5f51067dfe30ae462a622c11f4d59db17980b0fcb7b070d529d38e93f94fce8b915be262f790357494c1764746c25819e9353aaefb9856922c2d74f78da35984598a7c9be9687885eadafc59b8a32e152ed4f8cf9497495b239777288e281f8daac8800c2cb22403a15262333681bc9603ff2d61d9fa285cba91a9036be78efd9f4e60440b5869630d53c04065bc3433711981834dc7a2b6aebbef216706cf2ce84359db4d038109dc0dee88182dc2db37c18f5746eb42eb4b773fade08bc26ab74952a27aee170c1fa3b297db8c11081fec25ac37c109c75e92a8b41d9314a4b7c57c8488fb9e9cc03615f61bce776343d11c58cb440b397b407d490efd89ddbce9b1bd0fb2073e797561a7becdb850dd026786032ecd73611c8c1207c5d55dc101f7675a47386f71baf5f1cfb820316c0493cb9b2a592ddc0b3b8cf65e8dfaaf4d0ebe56c1f645eea48f9111fd1d675aebda7d28ba9ca76144af2368f5cce2625778b13d32b26a515aa992d67349d90a126e40449a7fd5687cc37dcb5ef46b4337f7f962595c4889c0aae8ff25db25a178717d18c2ebd58a0085622f6448a9d7005c9f51226c3607c7d1c58dbce84eebc2c7fdb0f20fd760d671875e88d53da4341ac87a81bfd70a07f7619cb1950ce1491d543d09be927de363adf522ab327c45adda0db2b9300411be415d11be90f95ca2f64290b490fd872c43e3011fe68cbd8561fca0ee5948b4dc09da486261f45b26c4d7fecc829ca2649c8c0474895cc1fac7c7af82d8523f96c16090a31d552f9a6d325ae4d50428f1b7500ee30929745bc4a3e5a10e6ccb572a43627d39d95c740d06b85c1661e8674af4d8682179cc7724cf8a89628dafbd50e492d26efca814f9581fd90386afb4696b2a0688fa4c1828b85f9c22fd2c84e17aa6af6471f46570d2f93e915ba8daadb152026524e99ff5249f68a1c50f0ff7f44e1395182818281f50182bee45fe5ae55ddd7a9032841539fa5c300bbb754d2ada94d6ff9eb02cf1f243be9e7469bb8cd4de3ca6fb1916c47dc9f5fa7270ea0de753bdd829ba11531b34f98b6fa276ffb5be1bf1599e15b6e7fd79bcca254f38268ab00d95981426deda07757b9d376d5d7d817e7a8ef618395f956a1e01116c1d7caeb44dd89da30ea3dc1eb2ecd7117fbfe42b09fbcf2e8d07ef0758ec78fa91f21d76b7285164c19ae5ed6455060192c8e9e32567306e187a60a70d8669148fe367132286221e590ff17d39e01ad80c28eed09a11875b2f08c0304e0f801b0bc7631da5c1b660e9a76b001852c99c1ed9f75411beb8af6d02b72f2d6be2530e4b67c3b34125b8f6bea8e7540ffce841543cea903e00870ec85a63d180471f2d1245747ed8ec0fd46a3f42d395313e8b63386a7ef70bf1877f9d68d95f8b8a5241feeb6d3726b98a26a3eaf0fc3c4c76f32365df85d1cf7a4a77de0a616fb6e198d74db35e67767c09b29aa96fc15839e48ab744117fe19a3e1b4615af9a58f07dbe6b9f95e4efad371d400ce0470e5ca336f69cd13c27fc39e669eedf1dafb409bfc3033e25ab8cd5429d426e22be8169ad1e5255b2c668023aef6b9c5e04525c866a19351c69c48439dea5a9b7f328a57163f69a8caa10c2975f4f7f1e89209ff893ca0409002af4fe7ee5fcaf4baa585e47f58a26c736ea5ec3bc5a872da1017294e761f14eda94838fc55ebaaf2968d81dd83371e5f835b359b27d6220a0c8153ae79c7ededb54847fce94db44e0f98805f4f8de3a5946b77884eaca1356a3dc91ce5b583438913b377880dd086444ae179a3dbc8c3ad7aadc89cf089fcf7e8d4d884e6cf5c9f2246f8dc058b06462e6ee90c06d87ac523d9ec221cd65a1cc86326d179d571ee94ae3279b878d6b22d1b93dadf3bee23fdc933c1d9bdba8f71fecab033a81c570e47fcbae1e5212e1c373127d2991c8a96f64b3ed3a1934d72af3c6fbafd8e913114fd8249be7d56c9caf062f4fc1a99cb4d8c12934d6b9adec294c6140ac40c9133e74706e07ce8a05bf82f0e14aca4aa800344554397f39437066fc9096b599f30a5a1f0760b50dcd9d3f15bcc9fcf084d7709b584fcb060a92ed931fd8faae907ab19025dd9c3a1767f88eaae13d03fa676e85185b74f1ec33b7e6cee0d9f2c35f82b14aab80c041c974b297ab101d8bc0db9c2bd37487e05ecfedb908243c3272988f803972ab1c55e8f60fbe0cb641695cc8c867a0cb7f20cfea29dd96ad55f49faf856241d5066f83f2807104782dab8e641eba35eb2db55a45b3011ce5a4eba1122fc306e9ae14b1e0e72de32196fd0b4099b68b3b2adb3ba9a23ae5a50978d6dde3f387c1c2dbda90e8bbd11f9d642c682c2779a2f25beb2aa677e2a63fbe35fb1253f36b4e45511d98317253ad2cb49dd834db94ee2bbff0538eaa5dc3267b9a3ecc765dd84d1c46f5a0d3b279e78d306635c4552bb9a45e3255ecf4bd1e6d4e0843a88c8d5dbb92df361adc4035161ed537314cea8d32bb167a4684000e585bcfa682e294bd29533a6488dd6a65c2b333bbff686cc54b7d56cb4681a4a3f56e3cf2624772a6a4717db91039a1999abaa17ee2ac6770bcb5065abd611137d4f60b4f7f0fa5230cb7fccacc6f62a4fb7ca5832d0b9d84ddded94d7d4b9fe62cbba912c2b8fccfb5ba7843c1ad6b5b64e4f2799114b1d943c5139b15139aeaa914d0951bc643c6684f2863bcd92f435527e47be097d9f982c22145d9e66648c8752fcc3d71b34795b43841edeb957de7fb061860ef70bbf7beb2a63bfd9e505cc7e6669e1691a468e3fb28246f5e655900f845cf1608147a81a2f226f73c9c7e7689ddfc6a395ac5a6670fd81366e89d94019ede140d763a4d3eb355e977320a09bb6c8847d9494c93f8d3c15cc4f91a5876f3595953fe3646e5b062c3ef5938d767cbfcfc5545d88ed97f4edbbdf2333e2798aede0bdd34a32c5f845e0413ddf2035b14af1516fa583dea6cca4c9db9b43aba733529d5900d800db4ec5b5500eca55c563d9caf2008093b5426b54d63aecad4b2bd78a553c8c5d892c5fd5b6f488898b01bde9e1d8dbc3cc333ca8f3c09f98af962c2e07b4f07c4e823ae2bb7e3d7aa995d8dd1d6efd31e600685a37b42b7cc241a8a0504b0b25d61eb3ed6a26b1a9042815ca531fd64f0ec4f2c8238d7c83d6cae59ef27af87a03dba68b94761b62b14237855ce50fad3e96b910bcc9649f6d30ff886b4fbb30b23c9edee7887e04f4f39dfc4cb049d765be247bfb23fbe30758f88de7083b9dbb5cc4d623c3ef2559ca1b37f67a9464eabe570041e4446cc9a4059783a4a7ef268503a826d4820d70bb8dfde553a7743deaf9884c4892fc1e90e0bd8df2fddff995076ab525c46b6407e085ffb69da2c3f19cc4c03e6a25248a2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
