<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45f1ca537695edcdecc6f2fcf56a7e6b5ea7f4f1c9d7733cd3559962099ced0cc71bfc945d2fcdb2de6d3e18bbebd1868023ea86df9e3046b6fd3d258d02471785be43918506eb37e7bfd6dd798254e3d4e648a71c634a40052739b9e12c269167bf695cffa19d94376849420aad33b642d420a03e2c7762abc70ccf4447c65d3c89ad3afc10e372666ba1f0792b9c8ce94b40e924f02353eb83a796f8d46fa433588b244562fdd662aa1aba0852de59fa4436db96b741bd2355b49f85abf164f3a2cacf21fb9b979d689285415784c5893d77037aa9d2cad038a48f160015fcddb3617721e2f556da430461b4bf18d35074ca20d5fbe9ac900875258d74a773a61cb77976ee9c6f1f90b6d5f4c7cf8db784e8edf70072cd17e1dfca5845ccd10b7966819793f1e8cc7e0eb385c731d565f3147f24f4d407a8fc25540e0642422f81b74a93147f7df8fadf01df48310fe88be4dd9ea923ea134955c4555bde72bdd6e413f07ceeb42c1d93fa0778ce13a7ca754967dc32cb659e30e51fc25fa59f67bc7103ad334fea2f1a78a05cae838e1bd6187170de4da17ad33845d257b66b0e1f5d3161376800dfab67cb7ce1a9daf62f0ac92b6366892757bdf9821589a420fcd0dddc4c3490b9f98ab8432fcf6fc4ca0b7ab7cb5fae75275581bbce467db7374c23689baa3d635d4b8ad57dae709d7a78d906057a247399877a466488ab5a0b6c4d2f2d95083ad9363ae5a6f640c3f7cb356581efdb85e23c8a5f3560404e5c50365ec3a90c2db91c36717482ef1f0b4bb24bb9a0d13174594bba010bdcf82b5f78c05b3c0c58da9305f385fcbb0694bd760239f375168c72b447e771287cb7f1d5bfa89a28005eacf2e7496a64f3e2bb383397deed5323c27a6721b445c3d1532291d9426b575eb3af332b82b25e7f8e3b6d5e0628dc93ae2cee04ad090b1976ebf1889355e5a47c00fb036d4f37895ee21a86ec0587493a9358f3ad73d0c922232e6cfd3741fae83e9d533b8057a5207e2b3d7fd3daa0bca8560287fba3d053f241a58eae8ca4825f6936b86e10f2855cee37250c4922ca3795da5ca5797e7ec673fd40d49bb84dfa07b3d9838e5c151335815a70cbe269be43b80a24315aa3516d5a68dea2a042527186e84e11e1be83790ac65abbe1874b6369908c65dbca5d136d56f256ba9369480ba26530d574f0c4a25f98094803d71629959a65522d8145cd6ed062fb3cb5105d47ccb87425a4f4d8cacc0acad97f025a4b1996b486f72efb3cb621be9b0ba5291d69dd54972caf86372c90b05606e6a2cd2ba7c8507ede4be7dba259595544b78cc7134b55656d472c2b6116a156f262728b673b7ead3c26c5d24d20bfc48fc25d0088d2a8a732de0a4e5f27efc93a0fe2b3fbadbbf231e12d5a036109f055671c8238250361b52a475cfa4da73a5906b2d8d167d96ec4076d37c0f38bc1bb5c92ff60eaef77ecce7a62dafbcb9980b3734743619f9028b111d714ddba664458f1bf429072097e6d168950b62b205b5124f42a25805e9fe652bbced958f5f4ee768a049bfe44f264f4727776a25f689f1070f69883b678045869ed5a80be6b94799814e8792745c37dda741a3dfef8a6ebdfeec669c5d9875b83cee880e9595f8c17ac8710ad3d53f5aa79c172ddacc240f399b62449cedd655116dde7b694f9fe54a1828b4683a857c040671548bfbaf081b3f9e30b04516e797e6cf7192c28667f0c2b28699504c9bb024f6834aace113833d2a2107004a58dfe66b09777a48d0649ba96cfe8f95fb3fa07e5a89676636710894ce2e83e8634a77c763a7391fa9dc3d1362ff0b7fc8b2e7e0f68eb13a47404afb5244e809aec20eb4dfb063953cfa43a684b495f759540f01e78a25c97019d526cea66542c218ebd186628649e0d5edf04425d335bc6ddf8255baa4d6eb4fef53d56357aaaceba8017d8688b2fa00116bc517aea58660aa9a1dafb646f55aadd54e4b2ac52fbb496ca8242d93f720e88d50333bbf31a9bd5c869499a39e43290736ffdcefef6e8f861c80b7e1d5520393ceb4d2c3e0addc02c7d870ca0a185b2ec3314c85127a7237216e001e5b9312f99c2971fa06155a90b79f5157b1c3a4bab701cca1208cf917d9c4b95b005984aa074d92e8c07005a8944acf1c246103df2cc9087686866730f3f060d9e7080b714211b6cf50cd5048f69be5183c07a2239d12208704c4b9da3192dc1bfc7089be31f8fae691c3996b13cc431935623699cd55f913775072c8808f036a10aca12f50530a015be276fcea0e1406d449455c86a3a481550ea9020178a6c007abdccbd646ad6e9ef410d67e2730cc2779ba60a0488c2b2f4684036e53dd4025828a21eedd82ff99e5cda444b3346109b8cb625d185359154f5a6ca511445f7c5b8a7057685f6f9b33dd7e4778265c0034c53ddf62af4b5eafe54d09ec248f17f4ae6426e0e88141565e1db7eba100e80c29efbc2834a24fe318e89eafb2622aa573034fcf3df63a42dca97d7dd6cf19a7fa72ee83b5a9cf6ef19e21b333151093b94b9b8124b539ecb1901b1823ad4ef673e21c44159891297145f324f4bbb80d3541a26601e5eaf97e914e0fef1c00fd75ef9321b36c111e2d1077e959bfa903626ce1639861edb0146ef13a4b08d3d149470023172550367b791d12be20149a8d2b10eb5c9e9b157019c1cd7425d92587bff5edf8394e0e702647f47a3d273252c797ea5df8e06916f7e7a0c3dfab3d475a05782f8ffa055853668e3c73cfbfc0175f49dd1058d1ba3c35d4e5a9dcf4734b41f9e1dd2dd618c60653852d7523f82f0a493857fa5d7f092ed7fdd79eecbb01a56823e328abc73ffc7012e507b5f928407a452079514b83aecd685a5889954b6f3623066ab405ab2d18f2e53295fcb8eaf95c0dcfc1fe77ca8eb7d76bf4e3fa22e46cdb797eaeb85551dd0e026e27760ac3d1a97e3310438c19859d44020a1889b1d99e225e5bc4483069bb6cc70557f909bb4d6c5e7d8602605709fcf26abc19151dd24b4de6707d5e44ac1e3cf0fb08d0e0f75b8ccd55029b82bbb6e14d7f3285a3b6d86acb52db12550538789c9710125b39807572999dc8cd3f5ca60c5d6cc1b7ec45f943bba79863c0cf35426352f3b70dea6cb63dd9172d6921e1b0d8ed7c96e8425d04f13718c846067e0eca18752b26b9179918f21a893ae2b9d4fba253b791bd499b4f9d89104871c94ff20d12eaf99e020b4795ab89ceacc908a61bfdd1cfd71909ec704c580bf3d353c79c5b279fd61f06a47a52e262fe97fb22bd5a2cd02b35f1f19c7ea3ede93ee012f72ff8cb9270a31df3569e8467729e1704258a3edc3071252597be16126eb86e22d7d6032e98da083c7da20170aa76ed290c69c458c5efa860cdd0f433c261fbcb65b18bb30124fb6e3e449fdeedde624950bd8cd0a5df796a9a311cbae3ed79fc6d3d31958f46b442b8cb01878a455becf2b845ee287300fedad4cf9c2102b01c1d63cd4548ffb3a6fdb97014a73bb28677cea9db924e2f65bde1e06b104be443b84f2e4bb06dac00f7a70a4d00e28be2ae5313b818113a07c67fd5219fbf40b6a60d955408b5cf469e77bb4b2e32148c0e955e28f1a40a43f994f5af61e28169f6acb13c70acb0a5af3d423d3e21d1444106cb3046e036e6125a8499d1af2773d5b41ec70f5e2508860022d9469e529fcc09585112e580e5a29f8967a5fad3acc8e0220411c4d9503e4b0f35142028848b083742c936d85cd55f01c29e9a7c7354d850d1fdb49720d76328a9578e907938234857e7a60f5264093d0a87e3350e3268cff39c856223d49dcf9dc4b0d3e8808c3d77236f2ec5b40f2a41f8ab53d8a978f190f485cdf1c6c7b88bd1312add52bec4656785dc0a7ddb652fb66fc0833a6d89f7b7daef7b377e8457b4bab539be0d4f57f474461f5587ce111cffa74f584326658d2b3de995c60774eb1bff643d0687dbc9eeb248338842fee43b5a99bb90969a26fe68ae92fb1bc888dbf08b3ea00d661f8e4afe6078adee1dd470f4e36282e89a9b43cee8d91bc0236b10f14dd2a3c607be2b2d5703a8b22148d88d4143ac09c98b53458a03dddb83e59cf1cb0cb52eff5b379cb757b7b64311fdf4b707237ff39b13e897bf558d1c9888d0742d7e2b7cecef266dccae9916c9e5037faddc50ec2aba789af2f204c02c5ebfa81fb8ef2665662f881fd543cfd69c6f0f64c23ef87d4e66393c8e60946626a2a0f29a80b5eb1951fbed279217ea479a0449800f7cf619c9f43f21ed659d0cea4c41282ee2e4a367dc8b9510f578bb704b360a795f9c57d12ceef97c91e3ce28558b63bb0dee35d5d879716f0c0c090a0025e34084fa3e218618a14c1fbc9e126bcfb4d36d1ac269f71046bfba3a9edbe70c8264dfe2ed6f7547d565c7fc6553d27fe2b56e9304fcb5ec6dd5fe0197ce58e579b23e64e62ecc9738a9c6ab4f9a3b155b92bb03a10c03f868239faa6dbe97e4be4475f1d9f0ea0ff451af9d81165b3f717f331d91f554701cc39bab0b63adddf99202338a13301dfcc62f6874f4d504eba8bc2225a683afdceb9936310f159403045186f619d4348da67de6f8a000c3709637273ce80c03f61d7948f069ba2dc687266fb5f749b255ea23ce7f7366ce193f94a7a182a557801afbd08573a74584394630f49b6f59988062913111349a69de9ca9949f7fc403969475942365f4372455722da910b87c296bf48f79a99642568398103168fed05dde9a3c2333a215e30067ab3974b984832cb09792cef8aa1af4913451488592413af05bc062603a62c79fbe71bae3486e1e8ad7f10f2815835497d5a7e90b41932db5decf68433948b424965ff4bbc3032a727afe9eb54f90753645bbb5f8f7886f5fd27e9b9ab25c53a13f3fc2e30ce31505336b7587d8d4b6e2dab114131a1cac882e35e7306a7ec4dd2377216069e7cecd8b8880fe39f06711ed60d75178f5b19735b16ff7130d06e6870f6415d4ee5aa0029e3aedfe124d1f3bfce2a36fe3375f50bd655160cd64c93907b5c9ac5785db72c0ea3ed04b47c83859fd9cf2ac33a65cf5f45cc05ce177da88e1ddf92fbe1af4838190cab2b9002a3043f7d39fa52060b9d4d15375329ecfca25d3afa1f6fa51d1f4c3d168e0d749f49487fa124f8ab9711519e57ea38116fcfe83d9ede654570468bc66a9fe32b95e38684bd6b0584a500306a37c780a94728e5cdc1db60992d4cbceb4ae02ed388a350154e01f20d8a86d99b8b69ed6b38c414069b3f01ac5f9636fc11270927acabead2e40de2167e84102a23e5dabc41fb1751a51b0845066c61fb025f80dae81c4df0e777c50c4a96a0bfe72d008df0b0ae00be475989aa6e4d7fba0e10079fbdd6c02cfbd2d6076502d08e817fa99b9175674fcca8bdc53076151101195999b11eaa7df10f9fdc6cb3426a5554865ec6e8bdc9bc8d425877c68e51f2e3c14eea9199e42762bae5da754840f2947c66961f2c136373ccdf0af3b5ebe34bb16a2f7cc4bf0874ebf1a87dbbb70a77a190a516154aaf1128c399cbbf6982aac94c048ea2d401b5cba6f7172edaf7f05891371648385b69d75a6c3ef1e6271bbab9644d6cb21245b74115fc85d33f006e79d652a34f0a593b34dded7473cef2a7325c8fd98effc0b9c548d7ca045521f4f4050bd692bd4bc0834b902070b7a3bb29b2ab11aa64022aaa93d1b3428ed5e674d6525e356b32b58a6684a2cba481a7f56152478f03115059fb8a07f2dcf399b633a4c412b398c3b3f5adefd8c25ac229534c83a12dc5df3047b95758c5f353555e589252721dcd68c3d3b1b28f916ce0c8d8415d50c7732a6bf2c58d5edb0a8c1cd41689a5572e452edd02d3d387c6868ed1a133254f21c2bbf322cf0cedffab969606b473ee908f5cdb48d57230f9af0a51fc23bebcd1761aebc736c0cc00336a20e800217556be46afa80ec0c42e57e814f8b3b2e823c9bbb3ccf4c4e2c4f4f1fbf43043751253bc9408fe4f356cb8f0935556f76d091ff47e3eaee0eab606a470e5be4593eddc12b9e1715906e00fae8c671023a4dd05968dae4df5fb2bfb10ae05ca6565b61ec730c202abe40f37a69aedb705fc30c5c9852bc8abdc690b4c0ee0b764a5d679988f244b899ec6a448d6e9f1e39054ad5479b36a80c6e27293a24f9d8ce9ddee066f36fc7cff3e8ea7128474caf5fb9c735993e152e3fe3f75be22564f23aef9cbc9a7c62d477d7854781e7741a2a2e82a18a1456229628d5131a09eb6300d594f92473dc0c421f30f7a95bc34da0f7e212ce784f006aff8898f5f7feb4c9197a644132f4248c6a237b952ac66d8e1bec45e03be0c67b319c64b8d6c0897fefae8ff804619300d9274c60d521cc330c66f60a5bc6fe6b0aae489e2310bf0e2ed82e3dfe8276c8ff4777cab56731e7d43da62cb26adc348460a69488455c834e77cd04ce05d7c81d8dbbca0fe9d36b6337a9bb4af013d7898f16da3247980b9187fd9a8ab12478daf892c1878ff532752fc4b90febb70cc38a7b05772b8a8639f785184500179b80afc1a19bff61f99c35b62101f70d931d1f112f226f5175eca91be509b1d5c99f25d0e7cf937dc3fcc0d2e6b9c0607eb1efc64636b5ce8314c62dcf02bf7d42922c3c131d36838d65958b7e54731c327c7e1470bc54845038b7cd3e8ac84a2fbbb88892a9fef9f0c05e2655ab5b75b255a986e39fa47e13f4add575d93103b8310bc52cd4fdd401186950fc08335152e2811fee30d9735a578d25c9d7210b2bb932f3b478c254b887c4389dd2a5c71c71afb40c0a0fa81942eb4d3119bd863b3f4504f7a35cee9658d87e6db05e5b82b255f118447ec985af66c34dba433471e32805a1ed694c682d6216ab0073f941ec5aab4a497a85b392649b3db867207ec539672e7ecfe13ed41a6d490d2be1b4322845323b6b6ce3d4e0cf1306fe78c0cea1d8dbc0ad12de1214b613d9ee754c269a3971aba411fc763d6b9ff150b3b716e384e4332784c16e78cc57d1c690d48883e12168ba0b193a27f1f55d06866864a732d55604a536b473c5e296d1a3f8c2cac33e915a1248b52f8d5bc05e79848ec29c1f89677c59652bdf08262b2c021770b953eccb9228ee0a67b32676539f9401e2485d7fc9a33530db21a78a9f4858d8cb4678f8eaf16d2642251582224ad3cae7dd7efd27e5956e436e716d9f99fcab529a5c921702414b267e94e19d55c8acc2e0d6fc35c6130f7581f79a61035060be4dd09800da475b03fa61e3da2951520409775b44bfcec5d96f87e7c5b93f54aeeb88f01e0715029f61a45f62f33a229636f76f9043f8495d4ad66166018901c38d4f984d22f7812bfcfcd4948c1bc79260e06d5cb9207fb51baa3b2ed12c841de7636f524d59cd2c7ddfd73f73bb90b449bec8b37ea5413160c2cf7a71ce2254f7cb7b6ffa83160e8bd1048b7586a34ec4f8eca494cf6be4e65eb1acf6d892e998aa1c4c6ed6a9cdce81c6b42c81fd02a6ce166180dace713c0b9eead80434dad514dba237c3b07665cec7d7b8888454b327b2c2e9bc08af6d2b11c80bffd4e287f9a899ffa4415edca895eeda2adf0a22df1b8e723cf5b36fcf070c2c08c068be8034a4d4aef1ff1bd425abe24bb6c1ddf2742f0dbe39534a26f36b4969d9fd18676bf1c3afd984a538af5805c8ebc5b37589da56976c56edddbd2aab13180846734028bcf21f10b18450fe3f54a71588d3bf92885e118b6ddd9c208c875f668aa1afc311903bb71bee5f5eabd1747eadd01881b046b63930e5a04b54ad7d690668c731bba0892a2441dc921c96cf4e48b7683775fddd66d0f2d02ef499a4bb7454c5113c17ff871508d5780dd3fabb5a319775c1c2a59c72631d0a8591d311fc9d0f59e079db3b16f4ef29c54b27a9818e4d2b847a0d8338b0fbdf5c401af2f7c534141ee7add56a583ab0b193c5fa4552f09b2bbc9b95726d7aa1207ee16a5791a2507739173eb7d8dc5539bb95f304af19b42073aee72679b37a83bd47385c38e919d94802e96d3b2a186a699d394f5f59065aa70cbbb820d6ea1e7130de79d307ad7fa17753998e0e6578ae98c3241960799c09d3d45c3e25001230edd332a3fbbb60a5537a46b9d98b376453b812d981613f47118eb0038c35e6cc77b736c05e30f6479c6451dcb4ce4b251ba04429a2d1c1459d728c308248a1278a31398f59cdf7175d6143220cbf363bf1076158eb557cdf09dde5d195d3383d96bdd44c7ac0e4e41661292bfc3fcb07bfcc595cf6fd7bf9458ff0502836f73f186012ad7eec3410314b74e7f97a3880911495abacd36da1165ed92249275feb4239c6d417cb27de4bb6e72a18467679fa0e05b45b86f2a2777bff1f3ff8f63f9db4fc021ce691e0f547b8df51fcbfcffb333de48030768094d4b8a9cbb0b3698aef1847b893d25fa447057e3f99056676acb61ffc09e7a36ef60964b45b9cfd0cf31fc56a48dc77dfa33c0d56c0bc3a6917d291b5050abe9ed1b533fd9413094c72ce3bc3e03b852872cfe3516715d56aa3d491caded75cc82ce224d5d071cad7c4c01a74eacd6c0cc01f49be4d2deb008b87441ae41064c83a94950798e28b8c04e6b10bde9dce7b197ba6c9ff6e9796b3bf43e1e3aaf503d279515f4bc0fb8a4218e5494f0573c8fee58f763d437c017a5b00a6b0913d9bdd2dbd7a5e9f72ddf2965c59c0586ac90b8b8f31dfc6b7aaf93174a9a0cfe0392fc50bd9fb95980cf988386701c3be9c52d33d3f61b8862e802f4df7cdfde2154cec574f01f2635f68d1d97c377f1cbe06f4e7e5fc254910dc1649037e4acd2430c80fafbe3e9c8b352aaa4cb8886d9ee46625fae135d7ed7e7c5601903068ac45418bc8ecc844e095cd485536587277fd13e9f9f756518c907a602215f7846c1a4b8ec01748f260e7c18d927796cf173a8ab5589b45f99c2016c1404f160c49a52793410217d5622ecb1ffed6697b0a52e87db0e7989ffabc18d2aefbd72362f959fd0b4cd3d2b10da8c4e35065810d4ba314466aa0238090c6d793f016c244c0636a6afd26a5a7b3989e5f13758e2bbe01f9266d71c18591df3ee0e433da9e0197b01a3e53e7c9588c8a62bc2a717e5f83a1df15fb2f3b8461b9ad043b4663f737e674265480781fa09c039d724c33ce87e18715ecddb24f075670673da0b1a7bb983ef52852007665dad78ed53dea46dd41efda84ade1dc9634079928c6d8e19c9e876793cc98087456c6b0c9592c2bb5132e99aec48f8e021737b7f1288690ed8dc341ce48927ea21da2c37ca70777adb4afa2c2906181a72710b6886ecacb7ceb70541aa2a430c970c9cdc7de1fd8865ef46fce09114226e2b91d60b74a6ce85a0c3702e6cee4e30371037698a36b973acb9136a8a2622aa600c05ab5272283701d185384e51fc9cfcfefad4fc277188eed04d423123723d6e477538657191b9c9e1ae1bcdf7e50696c4b1339ed93253430a785e3a26e2015b8dec01927a75fba649cd8023603006331931d586d8f0312f70a44d5374e636ad169b973817baadb3627e3fded5f2635512ddb464567b6c2d6ddfddae6140d30697ac656fea992eaf0ac106517a1ff00d663ae418a522b1412e4f77ba35c5848704a100913600fe6fd393c257571d67db0b634e3ebaf37baae8c2eb57d1bf54e4c55aadba9f715fcffdc7a4616be619017158fac850568cc81f722a4b879cb683db77592a0c6814740ef6dbc3eda207c3264ef8c7691e4ffa4040912149be578a079ba8060c230ad3675f68693cdb154f4ccb2581df8e3d2210ed73d6c9c74dc7ed6641b463fd207f3fb10e04b764a85118fdfd62348a170543e413cd72e27a0af7e086bbb2da1260efc3fb98b3611b92bb7c8685099f889e82f0878e29d01709ea0d7653745e99ea5deb76909fcfc7db5e364d51add81cec4b0730a74e051084a1193c646f13906338a781e2202ea26ce3a07072e63dfa54cd91012fe991e0ab3b24d8902f124baa574a1d584b68bd2d5d3dfa90ec12af1d605b548b7682fe25c942e1f900b8a0729fbe3cdbe44a0888232a9e17061dfc9a5d1511378e17ef77ceaf305ebc2954c498ee949e5203529d11c150d89c9e290d3b491e6f778eff9b3c93da2ab5232367c56d1b1d83656633570eb790e0cf96b158f07f07576bc88cf424bf3ad42fb27b75aa2660bbf24060e2bf5f87bf652967357627d1e45ae831f35d7f0589bfdd1400d0432d5d6d1fd500e4dd047fc6dc99772c3f6591502dee0da9498e1bd3187a9038d722bba9e6408e9ffe4fbb5efca51148a8b357f5e7ac1c16b8234f2128990cd6e687eed200d6a97ed9ffd26c5f9825c43fa1fec426e5d62e869e5a77668039e7ba212bd8da3a867f89f3ff82bd9b0463961a374e2a4c372e49af7a78027efb165b773dc9a163263ce140da9d173aad1024fe33d7b67b7d8fd5f1222b5bc8f030afc8d763d64346aa928e34dbb811ca03b11d5798340295713133f125c9ecd5857e0aa10336d580f002c47bca99826a31cd23a4e2110f0ba17e42df71ad66ac5381adb3ac41b5b171ace832d0ae3fa075cb4875160b33eadfaf2144f083c1d43df2f1d1d9d0012a1e9c5c4f8f04b949c9ced011f6f644d2ba1f405a5f4a66e38b0187b67fa43efb3dcd5c8f0269ef20c690d443a61b26b1b4c03100261c9b8ac29d443f145009b21cdd386d0dfcd9b00b29a009741e637c0bef5056fdc868cc2e1f1285df1ffececfdf30d0dcde14b2ff08f92ea714a140ed0aa23ff125542eea59573081e208d22aea21dd086c765417f5937af879891faff7f6db4866d6a2d5c46dcb7e6be711cb77f9ebc3a952781f318bb6f05cd963a9fb0dff2bc21504424d82ab92ed4502c3376a2d45ae43213c4cb97b2a96a790454248d143e8bc8e840bc3352a2cf8a039468683837017036efe8144b5dab282b237038e9c81c7a29bd9c6fac395cac9e4cae92a461aae02f3a1987baa5467467cd3c6ce4824c5109f04a9614cba45280988d2f81dbe6f83d05ba1c16e11295790221ae78136be1276b47c13873f2094e4fc9bc195411a4504d15e9a2ad0d7e7cac9350883188b28f0e82648976d722dd462a86eb52a1a4e1fe7c1187280e009a6ab2ca09028b8bef1272804448dd3456e6612cd8eb743294cfdbaa900986404f220e7b179a8cf78f4b3dbc7d21158be4aa01b9fe1d8dea80d856747e30e0190a93815e1f05c313767e35c5efce5bd7c66e69741db50c7ddd8c5ef545bb076f6f80878e3086bc52d58806c8880a73c64ee0bf549919bbe8b6f5418df2b1cfd40678adf38f5252bb3e67fb2d57be4f33e7411b11b70cfc1009ceff1c7a761d51aa7c8aff35301487309cbf29190ec0dbcb05283f04770c4305308f92eea1b34979d7792b28612f8cc5b1ab92b5634a0a5a46b99c32aa095126e35972b51607b5a3abe29a765f45cbf577e60f1ae94c2f38d017f194776ed467877d57ad2279109061a1b187e9f1439d1e000df153fd276f4f05a6affd4899f7096edc09155adc5fa8bbcb0f150f2e62d45bfe09c71dac79786b3eb820f4c4fb1d041c01e9e9c05a7b6dda5322c22c9b9c18665925cea82aa3047beeeeef0a02035004b241d7e594bf68c0be0078098b18c2ae5c421f4d1323838cc7bc0db66611fe60e4ed692425453ae914d70faac5c49ca56a23d558c150111fdf1c754d98eb2b1c7e3c0fcfd40087973505aa1f17ea2c4e55cdff9408498afcec87fcf269d03e9eb0e2bf9dd3a5af31b6f2b737a77e52f551870037444d1eb1c969affabe48a969bfac6d1bce587dd69fe101d1fb9cca35d7feed8a452daa76a756586561d5270e3912174c324b0a6ad2794b64249894c30af9bcc9b8fe1bf487f5af6be1a6ee81b66deee69c96463db305999431b1b408186f6e4c38219d880a53c91826f6de8cb7b40c7405ee5a5dbfc793d2ae277f74f7b6b4ec07a86aa49bfccc07e1e981288230cc594c707dc20a6b12688ad31d5fd6097b489f27f8bba0ae12727f53c99022e3fb173258ef21e788cf17af432ee8fcf5e734d3ccdb89760661ca2b62b3a0ba1e4404bfca3cb94ca2dd23b1d861886443afbd40b9180a6e0e8b78c172f2d457389ad0e5a7e5d492ab72ea14865de67aac7c26beaa67b0e2eb7540e85bbf60d9fe8bcb46cbfefef381fd3f3b2cd19b72dd24618f6d2827064045e94379501fda3e1672e59db5f208564dddcb519bd7281af9f2d7cdc507ccea44bdc552ec122e035233cd3889b15d02ad811d748fc346ed0463769d100a9a16108f315315c14e1ef353832aebb779650f371c4080120c1b38d4c5f004c54f78a4c50b6ee482866056512d99219fb1d612fa1cd05a69b723691134347c2ad530d1a8cb485bf5bb4090494c6913ff9cc0a2df000c1cfbc4fd3d5bdaf54d0df5a10e829452c29d784cf8d0d9d1e0b93444709312296228585ae5a8d882c77d30c0de4943ac99ff3ae48984c33f0778f009b3b2875935b702631a32f0605ea94051844c1c08bef01ffb3bdf574f51f45fa80870ce88df49881277c4232a88686e3f45d21b2528f5d812e3ca3d3d2b7b53b6284ada23f3e0b2a2a15db4f763530f1d8cd855f9e477a2ded4de262526864406be71e3aa8c3367defc8879765d203418c7ddff431c0249417798204db8d90f3859d66f1b98acf4d06f435bd8245a75e05e1c157ae20e1894b69b517b8db5a0a8bb645d9e16bccf364a22805bd4e76fed63546ee19de8ad8bc441d46c28d8a55e3ee1725674caf7355a21bb313d9431cb8ed3be8e4d5ffaa8036e2fd5c8261acffc05b7dec4373413bb9d5773ab49f81db9fc5201fdc51c1301eb2ede3245eff4a08018dbe6ff04d387ce71cc605b920e69f1bd97379e449df2e4c9c5b8057f163d491df3f2c2180e190f8360d742b058f22a23e058ce6dc87aec042eec5919f06e26e027b72eb2067bca6383eda3ee2b75344471dc5d17125a5ace60c21ded0ef5ce72332304676cd0b8928ba51f6e54824da8457e59a79d5e4f6730d018aef93493c2938a764489c61fdff16a247d9274b67a5c374c6d8bfef6679d622418865cb7e2f455de510e6d7978f6aa054dff570a1a78e083394ad7f45109d8af355ef8633f636a00a3b02d1a7db23ddbf47997a54f7310325bce5881f1fefca9fb32e50c08651dbca76fcdb4fce09e43f36fe8c85e9730d16f4618fa7d444d79bc5d300a77f1c6578398addb043cbd60021aa002a24e4aa11536d63461161437301523344f1c8bda1a798c028456f51b377ab14660cef5375d2ed2e65d91834c5acab5e3e1f5941e20a466afd5db902086dad50f1e5ee5c52c6924d00eb4b6745bd4072baa96324a6c9dd05a18f4116671dd9e4e118263e158f5e5ad5893f9245a90658dcda89cdc44567fd1e4adb5d66efbe41cb3d217bfc54021580253b03b6d31ad3698f560b109d11c07f539433c47efaf546ebda32792b51c7bc2c5c0ff09d0f3ff5af60ec6e1d60f7b7266a3d00a5a5b7ab5bc8e174217274e5adebd42afd47690469ced026f5128c3833e6addb3ef1460d933c1c435cfc242b5812f0df2220d6a3fc70c4e2908eebe8aef7f260933d7ad8914c90edfedba1ed383ab185772f1304a001e8b055b573dd812aecf7fc3b4f516755425e3d81653554bcccc00f76a86c555c758722e8ac38817a835a38c4b2f84de258d7361b2b11b7bc50ccdaca7bdd68fe7f3ddf29cb09fe07be4e783f4e6afefb6e8b613e7c4d8a8d4abbab3ede59df73616c525b986fe64da166a4169c8e9d3c9ad029c0f5304b71879e0d0a7bbc4c07617382016bdf7a40d7d647fc800b5757202fb3b7b8f4151faae238dac1d34665bb9e904a93087c5348f147756a1d304e3cc9aa274d88b28bf890be664b41b87592eefcfe3a24508fbb9a08c623625040b1d1e9d72ebf577500b9869dd894c926899402536b6a614b2db56a97748e2df1a3127679a916b20478a8feedba7b258f99340c52505b2a4cdab301c1951684d9b44d2de422d8bd3aa9ddab9179a6c22d185dd4bffddd1e3a9d41ad5d2182f1c9f14ff738b64c2c98658579858e78bd4ea77bf3f17c7892f2e82a4cdb02b92fd70a16df332f4e7a9813faceb58c3edc332aeaaa7bb61411268edc82d1485472b158de9db8b5ba11efffc47cbc2abac06e30a17929f2e4ecebf6829ecbed43b6436e0957794ada3968953ef65516bbcc88828d88b4fc64c448870fff6bb1523cba352161c1d4be582366036930dfaa742900cbf441ac30e1f433b94bdb5eb607adc063ec7d0228af14765299f267cca5b5a7afb6c24dd3722e50f0e77e0c6cb70e4a665eacb037855ac540d6db259a21d0afa18c348110583bebcd1cbcd3f506a0842fb1e47644ae0d217ffb71a5c6864ae9d5747ee2fbe58be3a1dc0ee8c9b7dabd573bb54897b2d0cc51d951a6c761435672312d8e06520aa22068ea745310320aff39f6886564e736c51acd742609167699547aa384f50538e463524ba0e82a97951439a97f365798e5f4bddf2ebcc904341c61b41a59d2c75181ad5bd10fa5abf81bfca7ae95918d923a9e56d3643731018971cef4dd7a1eae8f30268c323eee52a8a6be9b75e0d412a6713ccb2b6b98c65d6002db1fe37f0f0b797fc236ccc4e50275c8a51956bed268150e830d40aaf43515605df73027a072b954d1af16ad5b0f2d660258bdf8429df69030779aa18f14390d2d1688214102fe833f7e11174892b72d704ae5d45d3f939c58da2ff54e11265d2e37db71a243aaeeb2af0fddd5007697c6981903315017e59a135381ac1b2b0636cef165d895d0696278057be25f28b55b3e8704f33a09f8dbfef74428969c84644e5780d8ec01750cebe5f0d8b7b3555b8a666d6237848c0fa67081927bfecd680785d110aa2be286b99ae0da34edee7362e4bf87a66244e07456ec9d2f0465fad6f749de925f81719725c815c4bae98a14b120b6023512af63f62ea21a1acaad0cbb425333ce6b887d863dd5d888c2c17b8c814f51fade2a7f553d307d0f19ce118225be52d3ac2ebca4806632b304593e371664ddb96e720a4e8a49053f290f3f85a3d27b4947d7480642c4a390eb425b84291778fe813a975a30c374621ca762cc2ff04b2bf1fe6dfe7b74293af0da3212238ac46e6f02ec49cd1759f4dc81ee2066728139300fe8392d26b91b850bfb2ca958c2ba6c5dc89caa094c1fbcfd669ddfb34cbd70f572d4b18f2b416847122c78c633a9cc50ae7312dcf734b31e981caba5ab7e1e29621d495dfa0d99878dde1d96e056204824eddc185205ba66803cfa3e106b293d3ef77aaebcde3ace09ce587e680a7a51497dda6e162dab63742d1a8116199527450ba9b4dd3be78df65986d82028c5ed07ade324b44585f21e25fca198060439398689cfe16d444ba2994d1642a6a4b826c897ff028e06d54a4a4d361de7466adc26e8009c0a3c7e3e1d29ece9eb20223eec467058c73bd8c2a4ffbc297544f457ebd68910650e484759c19880df5d8507cea4a4a3c1050923799a4879932c43346d334772e2f5b28ad02fc605476f0decab33bf20148f8e04286d2805353ce15154e763ee3bc3a131697435c4506d6565e2977f29a1b7d01ba5f6c14706f6c853cc2447a67d442e3f29673dd3595a3ec10ab3616ffa2b8d41c1c85e4cde9e897f38525b0e29544194cf59160e56f5357e1d6c15b5371391cb9a18b706289772259b8aa94a4d1ca04edb3d5701809e28b008600ac2c4272051b66a89806de7ee94534b36d48e998330338b0faa208a8ea544b505d8dbac2fce12fededcc77d9c9b6ea22feb5203b6fcb8eaaf78277974b58fb14e3dba6e68f2f0a3317fd5ac25379456710f2566ff8829462627e1339cc614331c5a9dafc79240dd9eaa1a32ba11153080ed89106e58170d42002ab0c28cb0a991248bfc45d5ba779b9c0e415e1dd91dcbc2171717bbccee1578b9f0242536c190904695b378471aadd5232cdadb0bfe0afaf1fea251fecdab5c071ed9c114a29462ea006010b84e7468cd608de9253574291db5b42771e6623997b855cf1821b04f20f5dc36904c4afac3009b595a5195741e38cd5e33d39ae6ad768054f240356a4bcbf00a3e4ce0c8999dcd32d0fa57be2533d32b519949990f985ec5a1904f0f82cff3cfe7a4926ac20484ea03c2c1e2416fb6919c2d246b66d5f5c6ba269202b13c8b7c4098f4568095d1725cc83dd0fee6a9e76d3d681e9a79df9edb003cf5cde06bd62353b4f8be42312227b57406e8a3df178e092dab9ae758477410ea361dd66b8b6ef0d6c9ed1aa4a95289e585fde85cdd5965baf480308025dd906256dc21c23cba76b8766b73301750b140e54595f8caec55663344dc7cd2e5bedb125d40bcf77f295d866d82ef755018a57ca505da9d5a3e790ebd106e37ecf0c40d2955653c4bcde5786ed43ff180ade84e41756dcb2ef818ebfb58e245b902dd734a0c68db9d062d9053d45326b9a6cb4c390c693d2f48eac7e934068aee9c60e757cc74a83ac0c4af5d8a96cb6a49e0a0b9391a52a25afb3b11f2203e55798fcef065e35d2ce985498b733b5e6dfd65403863534ae4830cf63a2335f7e2504c114d34602a10ded96a2e8bcf7f0cd1393b4a9f2595077b8f5904afbcbd83e861605e7debe4f9fc7cb8121f2be8ca0275e7d3d234b3cf91f426e80a22c066742ee6ad7a04a1a46c69f32f00693f7428adb9588751dd45f6a6b17f6a9669e1402f076df2af478c136b23679a0a75c3040ad6182274ad75fa410eb1ca524ee87915b09f2434204c7ea60717711f939a11d4aa7430715c657efe1a53b98a5e22910758df479a796afff15c8934b9c18c793e6b95015307f7ef338f4ebd8c37ee680de375283160c1fd2cfef7476e7ddeb5866bcd36abfc14ebb0a165b4242e8f31c95952f3d52ec3b98703d558f7907a8c256794d10369edeb34e9bdcaec4472fe90e4fc45cf1beed30a7ab278e8581575354f86c2d64ccae175b0c4fda725e0a43c761a3f1c1dad9f2fa30c3e7e276268398d066a81bf0c65cf2eadfe23ed2377e64ae301719c6f4dbea969e3d8e6cceaa3668bc554f49392fbcefc3f87523c5f9de5edcdcfec11e178da3c07a99f839d665b1a3a141a33de03262e85be534f7eca68bc6b71795d32435d3df20e2b1e8589b519d82690ca3c9f97ca170ebd1dd6eac76099a353f578f70b76724577cc1609ff1025a7d13a7743ba43ebdae24c92820f9c58c52851edeb0900f36940d94e75e8dfcf61ed0d75d00a4b7620f1769d6c1e75cab18eadfed601a91df08ae9df89f63683246873ff35f96976e49b457439e992f6808fc720252103fb3163e3ce88b1a771f809d4e43933cdc3f6fb942e7fbeb863197907fd0a5303c05b510274bea0d2b7715e30bbc32ec8a17c8c12f014484fd0103e6dfd09ec30631b1e57a1b1808d80c012c5c7ba65370af97ef800d0451eddd8406defe2909de6bd43737ac15c68949b78b3791ada868b90c0aaf26098a955f8e898df6b6f99e236d0a9d421f1d620998c2a311338ed22ea6d1532d867b9f8951823f72b09cbebf5ceac40809539523c7e096df32b54c28499b873f069fedbfaad398c78b8b5950198038e8a22308a50b4db9feb7774369872c2aee68897f66da086a533cb80c74a891d55b76c4fa5a4b206dc8ce7a2e0be0bff325aa55361b6f9c4e78a0413ff3ea3c55d2d4865b85c0f25f056e34e6f3388ee0177c3be5e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
