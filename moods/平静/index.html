<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"264330a78e09b38db352b946e7e340e5213b4cf311d6a0f86931acfe3850b7f8f10f098900c0bdc534996489c97515c800dd119a673cfd84df696e4a3409c3b7ae7aeaca103e5b54ad7a7ccccf41f40e0384b1400da09b7c32a75a0ae0b1246a0fb8b7314f1b9eaecc1ea30c3adebee9d68ec748fd47163c845c892a241285dc563a18d2ace7266a3802fba3d46d591e794699533e5528698cc639639c0dab4ea1adae37d2dc05edf0d6fe9028d75c243b3786d907734637cea283266279bb17234737e77882e8e792d24c71602dd4f323c002d310d11527be662c36480781e25375d19fc786d9f406446458ac66a70622672e009bc87518f9dd9421fc797469431c19257e1db1ed062d621e6bd0ea4d14510417fcdedf08f4bd407d158005cdf03c3140b6c35165f4cfc0522f1fb55ae8476337fa27a03a8080349b5476a4d2ca4b967517ba619a31917ddfc5c181442d243c485f631eab6299afa0b40d399dee29a19a4781e5fed24317f83bc54347ee10c611667b27c0ae963f3f116d58317c527c8b6320cba6f29cf5c8d179113ce18ce3cc6f7baf0c860b5f8ad98792d6893860138560c7eb1e1fe77c70bbfe3aff2c9af790fe235d4271f83323823a4b03f16b015f11b68bb5bf6c46a1bb25e019707243f98a77ae4ee9e4e2fba3edc4dbffe1e6f5876c3b0cb6846a1acaa45a09553a39817fc4ae5b609826b61116ffd7a8034fc3e66e5bfff0bd551f61bd3c34883356a56a93fa29fb1216da2844be17f900dc96b4dbf812bed746a52234cfb009e1545c84fd7250c87d0f3b9768689fd9202c2f60ef52fec68e457fe540f406b926b7246099ff41566b65c15775375a30ccba94390632f26dcaf9c05bbc8c6a6eac3203cf87470b869eff435a5fe7b19dbe81c82564730d324d175e2ae83c22c94ef39fdbd54b7dba2cbbc0396886c4deee4b622ec5e8770a80673939aa0ef491ec026bd72de7fc634d02cb7729699c141fd881d59bc64ebc51d107dbdbf9618a4a499dda02056bed4d3b44f816015687921bddfa337340ed409e7b94018d0c2f3c3fb8bae0dac26a16ad81e84026e8bd4eca4031195b3f521b3eb02222f441cc08b68559d2820cdbddde3fb1a0e2844ada29acc1dd3456a109e35663f9ce0ce2640030ec081415f0cfbfb1e00923cd6e8bc8578fa46adedbf86aea92b45515067b07c89c573448254cd305a285371adc1bf00ee4823def3b6690562a25cb800bbc8a15999dfb47110b7e5b0cf0194bbcd6eba0809d0a5209d6973899ae049eed23ddaaf7b3ba03e2c7f25baf3e62320ca784b7a53ac7b317cac7546cb00cb3bbe21957187d7a73f5c69760b47f608133b2bac2944c49cdf7e5b3f93bc7e09fece4e2e21286baf69e0f3e950a5f1982fc3dc3c79ea0df3e29555c61658ed33ce92fcab777896a97b4674f079c5225628d44f6a606f6834e58dee909e418e4a4767acaa2be06d1a6920b2037ec40d40548ce4e0362637c7a4472cf415f2461c9dc9ede5301a65f20d9d738595c1bf14cfe3dfbf2b5762dbe41301780b9c8444683f5ade331010b993077e1d3c07f672451a04c2f3dda7aa5a7331bee6a38bd2bd30329487dd9135484bff5607f9e7344aaed66fcb88b2f60d78a89bb04cafda9d0cc3249a3dc4da764a668633d769af6cf394ce343e1571f7922c573a548e05f30fb6a06cf0e69b1aed9e1ba37d16db3923dc03c6ba3587d90ec945123fcbc893b868fd3423b5cfcb8ad5fb3047627551937245feaa3da7b52859dcf31050f47ef2665c5b4dd1a087faec917792bae96f42344fd3f44debe6f5ff883d1d13e6dca5d23e1a86d7c7d8fe8b9f76cefe738d140bee4ab45d1324c26d35fb2604f022fc2604304ab67c7aaaa928bb30aba09bf67d2fe96bcda759cbd91ced88c1746449dba0a437cd4eadfba6b82892fe46118ae2f2e9d63a3540d60199c254b3f263249cbfd3030fe9c988b3e970c4a564e7f1f588b71d6289c914e41b029907f48a34d7da3852e967f67e47591839239c56a5cb806b3cf433b16993c2de47c836e7320f421ef83a8339417f159ac9123a96abc6d8d457024c52f4acdabaa91d0224f0c64c48fd700b484135cf3e29e158b2b0b3da475a250b19ca5ce84cdc090f996b48415748fa17f306141c354aedb4544c32c8a5a69836f6dab389784c9cc3f2f42771d79531f4c761d067f41ac4d62c530ebeb7c7ce3a1e7dd405bca2cf717b3b905eef57b9e809df10258a74f3d508af51e69b6edf2eef538ba451c8ded0c04b711aed93118fc21464f7c7847b032035141809c293435d69b91178da4897d9dd411267f30a070db6d0d9ecf6b2664d98f666700afc7ebae9e19b1353f6a835b4b6d7c8aea80e0ee86b056e9f7c4149bc331a52cf7b356ecc74367eb1f35066495bc3d3d8af633f34f8bbcfe489ded680fe293e4bad2af7db66dfba52c4bb4cd77e4f91a424c1851e88ae8681bae14ac2e4fce925dfd3b2a372e68bfbce460e9740faef2e0ae760ff3733b81ba73005f5f800ded7aa63d1e6648ae369d0830de37fdf22697d18c796e235832c35823381dbd83aa7cee7c6204aa654b7bc86f6a2f9d295e95aedb8eafb3e31f761698bdb733533b618e3f2e642d0a6c679b6be321c9ecadd6b263d25b85b6d7b909c9fbf24817a4a11538803dd4c00ebb03424852ed5f2715c76b59dd63f429e3de9e0cbbd479f6191a6621cf1d9db810aff871fba9e0a8fcb23611ac9273d22bc09ed2481ec574bbf9ac95794622f9fd9c02e5cd81d57ce167ec04114aba8d1a0d2c844da29758fe48e70ee40e9eacc5d974006508f56b2bc60be4e2fb45ce02488294fff80e3e404c21a61e76b74610f4e83b84646c347e3f1295230e66fec1aead3364fa3d18a9ddf029d5f5701a2b61189321cf168e65a9e0a394733d4b877d1c3dc14c61c3a94b72cb7909c4a668e6fdacc4d626bd5234b4c3ddd59375a6793f64c796087a581aa48d39090e1e10615479cd9e351fc5754d6c8562806640c5caf9752a78dc485bfac144b3cd379db3857f433fbed3e84fce597b2ea8718220a0f5da97500f3059f9b1d0b35cd62e581d38021f97193e44e937bf56e6158089be9679bc5b211408db6bc599b92a6455764a2c659f82c04d87849147b2a969477d7719ae5c5b53acf68571a6f17817b7fd9ad098ff590b20d914fa8213cd4e91762e64b91c7b9288c14b0cdca2e4146ec7b8ca33b6928b0d9100c7223f79f0afe49b23d3c649521df4006cdf303e5f4dce3bdcfddaa3720ea7ff97c49bff0384a438a01bf177159b52ddd37046b9cbc270abef127d57304f4e9d104e1458b99121560feaae338d0dd129873ccffd1de1a284a7e6e18e114bffbaba5016aa61b493d56941608d1f5bb0b2c7e83153cbabd60076aa14c6915d012d4efd30b1101cc713b86507f1cb1d8fecd4f7f92153b5234b5578f723375f984ca9a891b05f4487b810c5a8c0293f00bb57308f68086fb5c5cb1f631ba18a739646b6ebd0b599186f36565a985dd966419ce4995b478151d5c6b9072d769927fcf67c5102a8002eb48bca77b929dd37bd5b2f084d9396760a2c382a42425e8ca9b9ff9c39b0e140aa6cc95a88b83da11e42be282ccfd6b2e4e019f2673601d65e5fcb530f84c4982c68c117e45483992745a2ad813f36fc8a9e814cb1a9127abdc68b8e5ad86af932daaee86d2695c008274bb56c2c8f4de0467a87def0016306a0d9c5112eaa9d4a4485c75ee84de449babf2bc4be85a81e1b39765431c91653fc9fdf4cb7daa7f3cbfc60ff1da3f1865f0c91b76f8bb4897a0eaf06a4185f327f4923949146702a98b9f14b72d27e5fb3ccccf6c3ce336b2ce044e159f8ca272f0f394b13eaded7488d3522f60adc8bdef1737b2b0e83438070edb33e1b9e6c3d7ca20725f7f24fd1ad3d1b8872ab723566a891f7b0129f2674901eede058ad64c6c36ab2bd0212c30345faa75d36c43a69a14776f23d89a73ef0f2c8dbc79aef49604fb769822bed3aa14a3a9712f139b09c423cb69e8b856c530bd4f2342f7ae1db0c73e1802b488ff80722384698ea82b2af563d66e95b932f25a8b3fe9a5f64e29b2b0e7396447f14030fcbb29f065b51529dddc0ea5c238823f8c18f01ae3ff147b28b92f97e7aa8a37a84ca2483d8a932bf7f7451bfefa7899f60f13ec84fab191a1ee8d3a51cbd7e0a2017a99130e2559bb2dcaf58c0693808f52ca56b6c9b94514e20f21a774fc515e0c098016b4472674c4340a24ec3c3f8e803ef8783d51f413b40267e2fc73e6b3afddb92eb08ee0c7e9d3d33bebbac6a97e04c277ae9951ca429228d5895b0271f412d9e651472b76c70f9d8de4d12d08d583d8201045d6e6ba8563a5d122e9e14b06a0c0d4f63e1a664d793fa2a26d4fc73a614617bb4d1c23703177cf8cfa2b13157659dd6dfc2a02a35ef7bc0c478d93266d7a721770681be1fbd974de1356cc12c757621866bb20472e4e8f200bf43a1a3db207b49531177d82b0116b25d453816fed652388a1e01ad08bf659fefc527ce1c240fb0640bffd1fa2e2be211fbaffe3fadfe82b2fcfedb820fa5ba7a91bb39c1650dcd7067b46428299f64138eec6d0913ea8b39cae245133d261319cd97835dd8e54cf4653fa578b34d583945cfca7f7753a10c8afb5a6b7a21c76534a0eada80d67b9d6aed57e2945842dac97894755a6bf96c019e280904ed2431540f27db3ec055217da9dc0e960ecbb9b2ea1acebbf1fe7cf2e269f449303c0706bbef53a0bbd3e29589bca11c67d3e9c2b4f04c75bcae417b41a4a342e918d13cb5300b2a777143a78de95b658b985d8b67fea05193de1d054daeddba61be319ceff2a04d54da03e5d5f1b54bf094f9e4522db14f65c9718b9d02b4287b6b1a815b2f8f68a9319662205d401a562325434f28c3b25478b9ef062de0a3a2ab708e38761d4640c7ca85ab2c01cf8c44c762a26dabb9330a9d840e2c1787c38970661900e99ca72b0e810b7fee05ae508466a4f751742e3e16d3939ab979721deb486d799c7a5bfe70a4105a2d105505a4af730cafb2c692a1f1f794b5d0d3b645002adc313714b849d446e5adaced461da29abaf22c75127a104ae17f764d773038668406f3c545fe5986620a0cce1ee38aa94ca17e58a3e5fc7c7e397bf5724e8eb311cb0a92ed8fce90e844f7dbdaf858ce29282ee3fd3341bf8f28f16bdf15be3b71d819027a1d93b01be37f84bd5eaa212c58f079aaed24e73be31dc7d7ac3dd40b0d68e5ac4340be315e3776ee58b64a52856d5054aa4daaadd2f0d1995e6100856feddbb0a5b9bf0d99a30961c900280492d0264a2900ea56f945c28826f70e7a906eb188c3ea9988a5daed63b1c3b8afe49ff4aee14bdc8faeb53cf546f7cf782b32152436b2ad4ef16f523ec039c53d088b9d8438b3c549bc5a4867b2c6310d6734c40a995ed175c92e48747eff12f618b12a45c6f7087dfe04bc54ff7970b940753f402a06b83c5ae9b849c7a85a528f6bb6e92fa4d4938bbb71c48555dbb7d660e268e26d39a7691b4b3e28ad2af5f4d3fa85e419e69812f7e5007b2bd6fe0ce9e93541c432145e9ede625af530653d1abdcf3ee9f1cb218ba59046784c039019444c029e2286979449fbb0f9096a3dc234e7eb4d28a97e7928cabf67a29856deeb64cabcc6e6c8bc5b95ff632ba2c70994d9bc4a41ad7c7503d3662c1f6439c6f9f4e917c2658bd31401b6030bd1b5b118ebd3dd3277807fd16024f6ceca05263e70dbfa502e8f5b6f198f780e2746c8732ae160782802bbe757cbcca1ee2ca2d3c074a60b05ec45c31edc198cc8a39c61c9a72bf4e7bc4d5867f9f4edc1e849d67006b38be77cdf59b7ba42a09b0fba17ac76c53a6582218fb1ad1afa5e5bf194a55cbd0c17c4e8e073cf0730b2d925ac0b1c2b5d92d43856974ee27c36bd52629c87ff891ab2b4603c0d51077da788e4516290784ec9ce4dfd0e43c658509ebc6e7de9db334d269e2395226aeeeba04536c793322ec39ae0a264785d15172e8f7a51e741de0c265adba4d8b663fc4b176c4e53d39158c63bdc8f7137499565846f85465fdeb896573ecf9107077e032e17e81b9a9669e6239f01c4009c3aad79eb5a80c49a49ea878ab166ebdc018ebcf20a25d1685b22ce34d8ea2e2ed324391d27aa936242765dc20c97055d44f2c6763295d083166a11003935c17d421d5421c6fdbaa7557e1f9ea30395b837decb52b8514741122a31276a6ec781ac2cdce4a2afe4216bedfcca865361736d3a49119764394edaeb95adbe107bb2781d97effaf3e6a370f57925a574f2a55894a2808c9f87c47ac8923b40ca0516bb9d515c9a6851fc2154bdea6d1c65d59f9b6780905bf88e4c20bafa7b02191210e1f60fc2a4447838c51d77aee94c1913a06e2c284522f2be009e0ddd6af38ee696dc27bd273936c0f36477a864f7e1485428c526eedc5785816d79cafd6eb4d898b316599bafeb95c8535d55c76f653c58925b7ff85edc300df27ac8dfa64ba1fbbd3c296c6ca927c95fb10632d01146d8b743f3aea79706812bdcc46ac44e3efbbf007596570aa6e9d0093bb072d31c73d4dc9df6eef575723b9009eb8cbece292a61d0ad284ee812e7c949dabdc9d311b3936bb1e037be07fd57fddff6009c7ad9b5bf357fd711b14630295ceac5ae12b3d4c4308e9c1ebcd9a989c03c70c00eaadfb092427c6615481eff5f04854ee3472f19db5d61653f09f537c6b50057dfec51c9007557f3415a366a1dc65f31e2395bf15ccb96626457f1ebb8e9ad2f8207c94aa63f90757339d2ee55479eab0dae6504920cf91d0294636f62b7e4a1b0c18dcc76311254df7b35eb5d641167a771a471d048ded7db6729a3db856e989e30eaf913811786a08ef36f2f134d5d350278cb5cd4690ba04f05a3957ea08c571630307927f1efe03745825f15a66909b6cf11876f0e5e03e9c959d6dfba0f25f3632ed02fa56f6b0599d206c4f6afbf452094250f5fd33cf94745169b6e84ca53eb237aec6fea3b421a489b4f9af6a5935856debb143a79d9fe88a4fa9abe1c7e68d7e45c7b530af0b244d4f4557664d8ba0dc2c0ed43e3031f899a756b7d588e3c840e023423739c71774f2f36a3e57457b9809827625ab9e58aec872904612a86790cdcef2fdace20f796cbe55d14563de1b30c1f46c7067181f10b5ca9f0f3dae0f8ffb8e4099a7b71d11bd1a36e0d80e305305e4ca82ab00dd1bf872faa71ce0cd6ac6135940dc46fe406a20097a021d9ea24afc2bfc695c36e4e7e546b6c86a91be9781945007ede716d36c9dd0e52a7a8a5953e471d34a94f6b71d3a37436cd384f8abf21c37be0bf71388fe0f398edb7b7b053b1384da4f6c38d44ff2efa4a83aa90daa515b76c7d4e02d40f9e028468b9f66ca84dbb64bc7286af189b3a0bad7df20d7eb313f24269532b1b37e0395e9c3a0a478511e71bf81f6e85d42909167e04687ad352f0613fcb49fbe00ace9a03c6eca9473b056fe257808e73eafcadb76f9e7b031dadee9d4b6b6d4ecdc06e460472b8055c3b4a32994d713ed2fb880e93c0a15b8c247649555462148778d2292825bdbc67d492abc99f0eca1dfb51260c5df4192524642d738bfdd148d7c2f14f0cea621d0260d41095a501ff7a2b9ab06eac31d142eeae3ba0b49c4c7eb620df3116274bddc8cc66175a59d8bb6297c39d4f0725b340533ace597db7cb9797feba7e7c8a3deb9ecdf42d771c6a58e3cad99a04f03d8ba1966ad16b1c857a57e28dfa972925a14ca776b36ef4f0fb78f9767eb8ed722ef4510c2313d6560db6c2602703b19ca2b589c8e9aead3fefcd545dce6c774b3487748c41e7fa06568e8e3b71bf9985e6bb5669db686f472f12eb7002ade38942aefcedeaa273fa46a5726cefeba64e316cad43569970b9f4b0775296773e5aa753e2f17d6912f2f7f77547f8c47c030776c1d8e9b3fd00d14cf0fe3a55c1f5b829dea12db74f2c52d53e2c8e8f4fd03f757bb6029a2d48243e3c3ad4abf09908939646374b2bb181f12f05d1890641b5afc4d54ba1349e3259e8564b218948511784dd7656c4581e3e1c92e8937baadc0ae9c08f2e03371598b944be7165df606275a5e92e8c8c6696525e563fbb1a054b435a243a3048d0b2ce107909f2c53ba9dbcedf8fddcbc20b493f1713f0d4b3515826b4ec8682b517c638ca38ce57fb3877d8f7b17ee4bcf9001091f0ca65dd53cda7afa9155edfdefc63f02bcb0764e0a7962e30e773c711771ded9884049f860d35eef1bf688d5dfe07c4d11cff3e32501143796604ad8aad2ea2d6819ad03c1f00b6ec53da1390f70acb13c1c66cb48f16c2d7ba4b0137bfda7de424117a52e553c36dbad6d41f6630b8e5ccd2b1d3c96798ec9d1870702743f4cf4c1c3377d4fd404b4e5f6e4ec8cdaf73f1b541b9c238a9a5b59229214c74d4e189dc18f7483446dbccf5f0759f0d3ecc26b209c48e65d866be2a4d34f24095dcfb7646f0676426c55e36a3d97387aacff9a0b07440411a46720747c2b9f5787f6291ba8266fa91c894d029b7a233037dc21a5d6276f44b41bf3dd17a5d81ee3a8fc6494547e44bad14a3dbf889e67f7a856e0df7915e416361ec0afdb1b483b141ea43d515abd3b387b1f488c83a6dc956808771e0218a965cc4cd17f76b269f22303120af5d7fd72e3a5a94175b6beab2bb0fdbe77edd2fcb31e3075fdaa396bca508bfdc263c16790623c445de0393ff05f37ffab133b46966f1e29fa3498d5d7a0395f4eb906dfeef9dca3cfd95a38eba051ee47811e4b99558bc5cf0924f2d5373ac523d4531c0a591b1475cbf112686ff41fa91f26ded8726c0d1e12a1f28e071b009d3c63455123278a2775676ef028c49a0ce7010ee690a1d251f637435f8ebe8e3f5299bbd35a8b722894318bc29fcec15719aa71912ed2ba0f2a88ac4b4c981fce4108f675e177232ee6352b2daa1cf976d6b9775b99e75121ec186b3f219b7f44963e9a0f5d7b921cbb9ea6786f4bc3366585543f68f9472adc4d054140545615d67ccfee30309b6dc8ad23aa89da40e8094d196f40b34121e352b343d28c054034a9b2e22492291013c9baf103d7a2cdee380b6b28a65372d758aa3500fca41cbdf172e28f278534f0b2a4e1d13e30d933f29ec463b225973597b755f78a3ac17dc8ea26b2d004e937bac81fd070db5e22569e01866957f50f26cf7746d5be12b655129f96e695a1e01daefad70ef27a85a004ed5074a2a39e2ac5ab88bdd9cad83052e187d400bbfd4846b8b3e064d7b6fd8e7db0845be7732898d0574bddd3a8ec19f5899714d8fdbff50bef28ba3eba93b331e571045b31a0d1dd249bdb720b3e38f308372dae3ef01759d4f93ac7d9b9804e3d2d5bc9e49afd7968b0dc0d2c76f09328db643a191923810b3ea4f480f76ed899393de40d7c52181d30b32dc74f8c9812021d6522daacc834e33facaf4f64479a8a519a974e23e923d7aba1d4d603b780ec689c8aceebbb0322aacf80aff38cc016aa8e63781f519efcea367d0b8de281bc7a78c49b756af95c7bd456b75969d5753134577245c77cc5d19b2284de1152e9594514556e28e966e6991447593dc5caf96d974b73bbd0fd9da08cd3efd53cd98437445398303de6f859eb5d9e979e0737a1db1fd349cb306d424b098672b1cce5098bf4317e1ca826702af2cc276d5e76bec6c8ba9695f2b6033c15fde412030c00511a11b234b9e84bd0b629566db175043d8e48866d5e8b30a03b8829e49d0901428d2e267b70fe8873933b2c970f72e29a9aae37675c35bd6db87c1bd1809b502f0660efd80137186722f78d8ffb5b0571f7fe2ba4ba2d7988f63bb3f0558d7ec5bb9e070a42d4a94da822c00a4edb31ddea3a42af433606b7b654d62540253e907398d1e4873a226dec4165daa0c905d125b54cd2f840e8136ae9dff4f2fc64ba21d79710e54cc177aab5482968523d8db468cda0d5f55c3646f4fd9e3101ea93f451f86b1005b5667e6864c3b8c0f2ba141c16b48eb8f444944d94a2dcced5f7f2b5bda68eac7c6d83954e54fc5acada34f6de3103fb8036ba703a64acafbabaff32420ea824170bb717ded1375378cc29d42c64fc45d246ec5783248d1a123d5e8b4079b74ac16df670acff6b5be352d9372310e45740b9876a2546a4c27000fc6c1c9269aac24a9bb11c274787eed9950b4fc92a1934bc6a50941d987f0426c702e72f077c50f8f401c848948b51dbf7263da79442442484537ddbfc465dcf6dfd0cf0f20345cafa8be991c0731ad4ab01826678b7ef34bef723d28aed009665530dbb4fccbc776414066020be8e40514b2e48b95e571d1fee9536d618220721ddfc5d8a241dc4cc3d2fd5868f400957b50c7a2cb3d1d7dfc08a20661ce485042ab7298c2ae424525b10254616b79f55794f2a45c18179f90a29b112e06a8a6d1d69e7423b245dd0bcf6ba93c6a4a19eebece31094eac60e362ddbf5a524d5f5d3e952a5c909952a461a0db9b2fe68adcddfe624b15fdb93c10b2b0d8bafa211341b74654ea4d80be75416f3a4f23a7533434a33d2ab765b54c8cdfa9846ea1a1fd0b1884e50f76eec75ea48e3440475aa50960df406ba35c25fc71d21d61da753819e01f11f229574b4519f4b9021783d2a6cff7be96ab4c47702ad89f80296169f750ec748024e07d61764763c6fdef7e7ce2ea3fcf74266d4ffa847846ccce3c0307876d1db4838620059fd928f63b6339cfd92907428eb6dc3d78837a33cb5d98965a4a6a1bcdf2a42d7a3cc7897d10988f3d6531aa38691926184ac7f91973293df49ab22ef2de268cb98ae10415adae52c35a29c200aeb5069a28ff34efcfc63833526881f0fe0ac4a890af12769b0a0756872c74fe2198150818ed11b08006146b2576ce980cbd727c44d66ea02524be99164429ba05663dc21accac0029419afa21423bad3657faa013a189b9abb1f87c5c64e2424855a928cceb624834a7800b4980aab03e53027c4a9bbc49ca61f31294518fdf721780c36e22a54ba923e9982b3de7677b2eb5e96041711ffd5b6c312b1fa2cb6820a60b750d456e4017cc0fdf45a052a15655eee907853f6dc094968f8033495724343d232fba019f8ac85eedb85d92c9b2fae31be825dee4f0d1aed3b57e5b940b5fd0f5a0e92ec190465e733587d0b1085e00cc7070e935330580d796072450e449065d4094f4f35b92d7b3f8c1a00d96838fe5edfe9d2fb2eb1d60504b7999b10f4a14a749818a8d71a0ec7fed382c20b80d5ddc1535e433dc8b26a84feaba3c1a7727da0ccc08cea37aa5e9cb55fc42dd1eb3048ce773b0d175c4028cf493979da30f6220a5543f598f41e68b615f99b1ea8a16f5e8b0094e23e1663a1622b8d8a1ea42870807559cbcdbca45765ddd07b508cb2a14495f2ccc3f9a39db13ed9a0c30ce0437e095a9dafa2f95eb8aef3673b7c047a1cf58ec2e6445b14acf3f837ebc6e8150871faee7ef75c58c6eb404ff3f1aaadaa6f6352b150907312a5df97858ad66e47ea79e6e1781371b5ccbef09ccb766b212b988998476967d6dcd5738623479f8c3d57868eec0d75f3d6e3ee9f45bd6af62aaca250bdbf2e574489cd3c59a0f17448567186a3faceb8381808c25245d60a10b029a6b2eea5ffe70c89270f6b7047a238ffc0440109d2145ffb22042d3ae2e04dff502c03d2d75b90990d034a30d77c15d3519a0617f071b57af71cc2fd6f6a7269771019c93f4d3ca48440abc9ccd3be9cbdf789656b46389878519da10f87a3ea40ecbc30e10193c22a5553267566fd12a2f498b2b4df8eca485716c1b8a388a7eb71d81c6502796a1d605c98843272393f00689467ef339d01429055a770aa333bd63e7e8c4f3ab140e36c70b668d01bd000939d97636c02df30fdaf95afcd5aae774a0b1b8c36f648b82d682c12dd066140dc66355caa12a7b4e0eae45c09236fdb5fe6a2ac2e1a19d5b68eba95fee5137f2d8915dfd008ba3809ac22c1eac1b8284b1a38aaf51ef1a9b61a833b78eb654f7452a64b1ab42e8a9bcdb999d8686dba1764d088d12de72382448b0fbdd2caf1c8acd948e9481aed027a2f7f9792fe14c74d84d5e84a3198e9dcfcf1a3de8011d58245a59844f9225029561332741a8250c855a3954f871168cb92bf949ab4c03aacb8f41782da6545f70b909617130043d35e41156a717fb204d462cd647f66996a85b6dd18d8fbd87d9e2d72a33b4cb882e1d79657942a102f5fa313f9551ca7ea4d35757aba6965d56576291c8113c5afc7ed11d385b7a5023685074df784faf9e8b807b8898ce93effa4cfd8cbbac0d161fd019064e08ae36b7e7f52a108c47dd8dbfa9453f40b273809eeab0aa3cb0e4706c70e44a50f2a7a9f2c7c314dd01b4807f872a87137f9a1a73be75f6df3e8ad1b9c373cb3a334b9731b33d37d709d4716731168991a36007ce65cea5e4d6e709c12527f3b76f6e8dbd6d17320ae46dfa73b86712f8acecd26b1fa05fed10f90d49f3e8d7dc3267a4b46ef5a130bdefb9a3748f8adfc477c998c9f7b59430c8bcd29531132dee69dd3abae0aa12567ff7ab79b8959f357ef0323e6fc21491dca3ce1d074345da82c6ab29746c846d0ad161fbc0f3dc77ad395a3a0bb24b96d6b5d2f413c94fe352532d669a1d72b724a75929ecbb66d6d4bf73680c05a746be6a739140f355764993350d067a7f1b9b6d43c750f8fa2421b10dccc24f0be3957fefcd9ec068e3127d49adc94c2ac9c015cca64282de573f13349e4caeabcae7d1811d3414c928367cd0b1f058321ae396fdcd787f3bce03499a2b99d7a7a117d1b1c57d70cb42344e5e57b157aaab3ff76a2bd71ed64ae3d2889340d770fa3c2306afbf515b0251766dda762fc3c3b2a26ffb6411a20e45ea4ae46419c58f3538b31e776ac886052e58738980ed3ee283b07151933a17856f9411eaf8df9f482e56dced2229806ae1f89e6e38f6f9e92bc6df07549251800cd64dcf2930394b9263e4fd87babe3cad304ecd1204760778dd0b286100888940cce6e00d8bf398ac0b6a80ad068538f5ef15c889aeba5c3efaec3a97604fa00c2a6e9cc9dd328480d27ea3b58d6a14f8dd403b41e523b6c83361c4482c610fce960ed7145678e788373c46193b4151b384090a1ad60b3869ca1a134c7e24327de94f5d4b6bfd29321a1c609fabc9bd7cf1e4bb11500d395e9076ca6bf58acf276beac397981f0ccb35c56ff9e1461885922d87d7ffc2fdd294b6503224859f44754e800c3baa7b044aecd522841b097b7aa8c6d26c5f172330e62347bf603686d4391fe8d0bf523c9754a247d1f269aac3f83a3ef3ec26d943a2367de3c35814a4a26c6b2441da27de3c1c0805328067066c497843a247858f8445242130f4b80bd0ad79cf170b3f4d8b5557bcad9888710f56a96667d8e13c732d95fcb22f0a09865b4e1a487337ca65737cc258e4e738131ab95828b7003fc5fa1a32264af6de04df719f740150e02dc39c6c25f6c6ea114d946fec92d0feff5240f0fdb01c0add87ac1dd46c599034b5aa15f7f478d998c17d122204ab59efeb3367862c7accf95b319661747e0851e47ae0e82ce4de4e54260f727558b0df81ef78d8ff6a8617236668f38b157bc100a8df4e841901c96918638e21ee7331309c3d5a82545f59b077d1242d5426367907da816ead18ef305d928fad469591a9cda85341c152c5f9c9ba4caeeaf9b3e98507fb30e7172738aa146f8126da3894304770db06a5aa1a18c26e55b7ee587616bc8b2418020c93937f859a87f6137aa1f101c5eb4df6e76038d91eebb95399edd37bbe75c57a15b5f18d79409a4e1518be21b67169f06dd72be1414eb1d06dc47159578fe27b83c35c9ef9e20967782575a6331f17b7cb1cac87fd89c52a3155a47d5cd0176288a93581ca1558763636bc7dd264c2dc3d650ec63e3b7687ef30faaec34a18a7557f8c9c5a8b78bf861abc26d447a01f84f0a0db26461782deee28cb6757588b9f46c17964ea4b1fa171b59bce212388f8dc77e9955d7625e95e3bcdcee94bd3789b25f2f8c93b257ce9e4b8453fcadee3951d11aa1299e048050cde92b55d350a22322e97ba8185b87d14b8e355e3e29d7fdd5551e550e64446bb229be13c103ac0403ae68de6c49b388e24e5033245ddace860617dac7146b36780e80f00a6ec86fef86204a8c0db600982214fa378fae02d0d2fbb6f982e48ca3f0adc077a2511071cb81c6e33eade6065708745ef00aac9c1f7fc4b968840934aadd5351562df80246833209756e940761513fe2081daf9c9c63b7bc737b95509b2471bed2782c1ce183a7b8b546735f54e168e97d08c58618bca1e6d519f92f048d5193088a12f75db6df2e5e0d32c81bb6d8d547277db4632d6b5fb0f67d9bcbe9c1e986b907ed0d414c861b750af3d21be9d0374815d2762d96bb5340851de04439d6ba01cdb920811ad8da233bf3960fb53933cf2ff8fa3e5c747992a83aa185e02c51fb85934baf8fb41c968dc6b4c849cbaa735af045cd537f2cc8bd1f47c2ff54987c57155e569b9ffb3ab853c8890830d8131cf204fcda1d8ef71518c82faf7d57a5c67a9c492c40b905ce091cdc8c04ffb4527beace190f73e669e70e4ee0f5ccf8579752b78183dbef90b8edcd4ca6fddb06df5bbbd4ffeb14450a7fa2afdf0e1d4cc21cf484c7462bf7d132c44d3da15ce311e06a8a8b161d9619c9623697e4cb5d9ded34bc9a3f5bce8024100709273536049c4aec85e77c75e156d38b49bd6e650ef5b01dd05f74dd5d692b7e9f1eeb52e508fda8eae29f83a1f84d5a519fde154cd8ece43b47ec4380d21a4e231343e709ba80f371c5810d824e2d68b03563a52200564d5dcec82b40301f7dae384b8439a03a14c9ef1b8af9acd0c2c0c7cd3b459061e87e7b907bdc160418b46691173a55685d9a3259ede372a08c97bc20639b893d352ce7b25a402610b874efd54fcc5a92395ccbe7566c237d6940b3c5e70ed88342943f1dcc695bc48a01275cc971b44bb50c774354e89c47758e24d7a5f3a048045329de2e57cd065d70db1aba568b62e32489310a1cdc735de7ad62db726be9e255df5305c44e5ffe954294f58a848f93561b6c85d6bfdceb349830738d619a6981b98e3e110cbb869a912765a52a6238eb06d1b63e8222363030000f42d2263582910faa5868e5c68545046260eb9fe5b755318994f54155cc9920b56995fc9da9dadeb86f80a32720d3970a30aca6fd4bd9a3f96ff83c1c6704e3a923ad5301c2d23e898d2f25235f1475fbf5b4973c2b66401907f3e96d9228ebeb24f5f977bc940136732f8305b8fc25fbc1ff080f2c878d1581957fd5067f0f9a4bcd2f1ca75bba560dcffd49cbeecd77d78a0086b7ba1d1f42254219f816906da56133a3ec65f5502ea4e4f2a0355e559a7fe41cfff66b41f59a3525423586f308e63e94771889fffe9c70657b2c201fdc84bdc9989587ce18dbf3c1eadf43c77fdfccc8ddad9aa770ac7e0ab3d9e25eabcf003003c919ceb7941956af9e48b5f5d241c6031b0329ece4daf1fecac32c287e8fea48c6c9c5e19bd71fe6f26dc4b1396b38f39dd633be4ee40472a5c200a3f9c9d06cc24e9a7adc8373a449f5f271b5ae6a980616c06368d3250f8d2ee26d5c6d9471b33e346134d658b9fac36f27b44216496121f4608a58824dcdb3e3ad41127a82b4721aa283ae4fdedff559b194a4f779497c5d92dbe8e11f178d5a3e4e64c927351a0e57c8799d3bc962cb87872825f6d43cfb3eadbcbcc7a8c51d0d540dabb32f9fa37c1aa7b89c84e0da88be2be91dfcd29cdf21ffef97a609d16d7394b5beaee70eec892e116ad44bc5f80b09812c9726fc06d6148eb1701b2214cf684e9e9668b0ddee482de23314ae5627649b79d71d5f63e49a3c18ad2e3771f2ff5cbfb270ae69912c83ff285ed13426d38c824058d9c40d5bfa784870e83224f48b1e2e2554245d1a1960d147ff7f818c6be47da5c456b9f824ea82afda0f0f6b4e9976502e0a838677a3a679229934e41142c88c559f554cafd428c7dd446e718c3fe9217aa910bf6fb424b1012c1bc6f9cdc2cb7ef93418e44beb26bd7b7d09b8194ad2e2078329db64fc9f94d465c88041c4f27c65b23d3b66fc914d2744b49ab5adda4263c67d5f86cf86bb2b8873fcf0a4ea67f54a6db308900236a61369d3a049f43bc3444a94ea432c1d4cf9d02a546205d03ec66b259a9f7244039cf8896d86aefe4ef4505f6c5d1b2cebcf0c590328bcf7be1f8dd8e09108d2d41955897356713079b52c9e9b8fed7e372dac9efb83bc6649ebf61ed2c0820133310936d9853608b5d5b5f03a26dc0bd2e277957913258ac7205ff3af5d708c22504b97d52b0fd5b7d5967c0cd38386c4af3c63d82cbc9a250277e0970122c70b321d1a49541d1487c0e827e6128fad28e5e2bad5d93353f667797f5320fa2239901ed4794024815e681dfea7cf5eb6ae47f5a43ff9463cad5481c7fd95b0c8cb6bb35d87c09cac163dae665f23720dd40ecf6283449b08416a0d12deee0a508da8f1a5b66daf07d7ebbb0bb0d128b9c068dd597e20f8fa6d9d2c0f3d1de02c8cec47631f148c60fd867ce2cd6abb8f2823fc9d75a68ed510535793c72ee65a811775ecfa08393b6dcd8feaa40b2c43e1fbc0683d6da6e3a943ae3942e4df8dd779e5d2e4b8deddef21e42593adbfc6af8308dd737bf65049a9ee25f2536dbb2cec95bc42fd2f0bdea00f78a29d254308b357a970b23b1636264bf2fd7a3e684c14ecf6849b22d22362e871cbd6f1d942a67651f50d0c9f45ca3197a5abbd3c969afdb0784c219e6160c05cc6d72ccbd6fb43a9fe24966939e53dc5a561e06f872e927ed8192ffd191ca52f2210dce7fb3372af35ec5ab5daab9b100d5c7cc2fc2ce5065d552f985d692df13d386f5829f6325c79aef167da3e7053b96d49a95460cdcc1a36783643d7b5abdc572f4b728460afa742786a43ef97849c21d94eaeeb4be7c4ca56c08f64f1ed59d77e8bc9daa7fd2614fd957ed7c4719f9cd3d83c2d1c976c0da829356355cbee1f59043413d2d7e1a1c1bc03d6b644805606d32089fb99f476dd045b5ac5276002b67dc8a102adf2368815a897fc7d6bbd16709c6ab021e2bc6fa65affa4b81977769a652551fe5c986f37ae797a066a8cb8e4f7dc0c7a7db4e3ce012d34db7ec1512fdd7e843ba02c1906c3d9e4a4084f3f05d2e4d64c9da6e63e6cce290f5f93a05f450539eebc42860c48b7b1a5beadb6059da1461ed6e43789225f8ba683077d8610bf5ded761b4c214e4fedd331e6d0683989e098662a8cd03552b41bad6032fce4a4ec32fa75ef7fc3bf931d22515bca3c274ac9ccbc964672be3855ec79fa2379cd7c9936c4afd335aae19399c518220803252e6051cb7faed3eddb13be8b59d35cbb46410da3deb9c8010fa9196ed52bebb53b4539b6db88757de414093d5ba09603cab62c932fee6dc8e5f6d8e04d482c416d5ba0aa9ee3b5e8a74df1e9cdd8abaa7fd26","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
