<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa51fc13fa838b3f5069e78974dc1ed337f19b09ac787dae2b210e791f8ff6748c491705cc8157a53e826c4b1ab80458eb6fb53e25d899905fe50e3b80f293366af7cb75bf2c19e7a1707ab58801113ab891071365b789edf8559c098167a4c20d5035bedfdb4e37194236c71595a43dcbb7962ada382b22d7805c6e169b60f9774eb6a71313e928f9bb1d6627993bfb6785b7d8df5836f7d862881f444e2541b7ae80f5cefc51b960d7c66625c890ff99f27668b046d4b89d6300f8e5b36a10b5c652d85da33a2b1d3803339f3cef10a211beac43635b779284f5c250736e171a52dbd2f03b02bb71af3c116b3f96a8a0fbefb864bb7e42b508f05d0971cb1f018050b1e02a2384ac854efd89fad9bb599e5ffafaa0b0bffd6d51b0d7609d0f67018cf22d6586a0e236c0288b735982298bd91044adefd8bb3381da98d68c69a633ba45433a4cd6c3ea514e0f1d63cb81d466f1965642b3dd27c5fdb6a67d7a5ce746997b18059bedbee447b3eece9b7cefdb5714f2cb294bac8296af3c7bd0babc577a5d9cb35b04a5563898e93aa79ac798616194771d6616a4b6157f8628b12e00429cf6b83c9e131db909600e7093d61330378336534d4c0dfacb12202b2d7aac5d56363c6a87907993d7b0f632dc0e716eb48d423346c62ca949b94154fdc1d44f3ec297459410eea8e55289e10def31566651f0f7b36a998a09333d1bfd1ddfe69c6832b456a8eab9d733dc2c77fce024350e0f2419d3335f6621859c0c1e4e0b720229c9926c346bfc9b1988dd81c2a287e005d692d3faa5f7f63832ae6a72c8ed34541773f9e130a26aace0b6d7f77bf5347cfd6583fcd4f53667d7ea40c99c0c824cddc32513b2bc35e99b666319293e0d6e7528eb1c01224f8ccfb0e4c7b57e67e53c3551f4c7f1aa82fb5ed0a84ad7a1ed3d965c75f5edc6cd6a0e43326c17da9feb09fdc68b1d233ab880af7a77f4a2aa630126b220f5b9bc40fec0b7650753dbc87b6d0a1b610cd3022c4ed7d3c180b6c8be869a596e16cb523b0d7affee070294e6fe85a7f96d4b8d3950b4b92e1fecb5ef1e16ca73dd22fd9be702b1ef33e480301b02ecb85d2916bc281ec465de6e6f169394b37b36c619ac8537ce8c20d955f2e1a84c89f99ea60c0d4534071cc4a93ab91d5aad9fb47780a2a72f53c39c33f11f85951dbe3a10530188c479d7fcdc11a5801ea16720d3a64213b3678fa618472937785c6127f4e193ab1fbe132b1e3f427537db7fca057e83f2bf9ac08e40395bea417d163d6e211257560568875f4363d41b896df4d47c11f4a69ac5b560de192b69f010b17c57bd7a86ae6f03aa9a6c4098f4648e77833be1dc96bf335da86eb2fb3f71aea18b179f59ce6ef2a8ec299ee65ceff03137f390642372260c210fa36df141fe5fb791cd23f3a9c393ffe210bf491cee4ea4b05b80ebfe03c60706525a03477f1d5f9b5f3164ccf74253982759510981d478b187dd6a4caac661bbab5c918b6968ceed4405ca7fbe3f9e246e2d5f3afe5dbbbfb7f547e0356ab642fa4f47d02e01bd756f40b85e394c171197c2f106b00e1c213a4724c41fd170863c86ab0155123358225aae8c20a5a3838a66648b762f128bbdef75c1b47e6e8f6fa0ae3ecc44351a8dd27b0f7555b7208e3f7e07024e06452f96fb8f81cf820fefb55bcb6e04fd1a765f271ce2bfad2da5dec212cf0db4a0423aa62c7ff6041b26db2e92550935e4acdfb89a944b4acd62a6d495a0aed7a4ede9f95781f4b76d756d4db853b6fa2e8bbab0d5285521ffade36468e70b562d2ac0ae71bee3a58f26513dc9c273e45a0197442fdeac2f38c6bfaf654ad2b1f9c802917396d482fd9230caf78705cc9fb17d5a4c646df09c27113656585353415ce8512f67b73738fddce6587da1379ebefc2a190e2a487e622f83730f093d6171d16e7a86376fb602fe0292c0ae9bb2f4dfb59c7b3ae4243bdd1d00c1e0d519bcbf4101945ea3c4071343e4682ce6eacf14783cd544bf80e48b76d68a465929ca5f3f1cd61d17206e5288637830c6f0aa57b926f762ee976517c2554baedfc9c6e100cc2abffdcca6170bab0352e3274ea1ca59e671de170408ccc57f506100fec6090e7877b9bc9209f7c88d898558812c73d3a38df453ea1df3cbf8b5b7810da62f442b170d74673b0f7d1d0135e42895086be908fa90ad795f969ecb49f33821e9a1afe1b4ee72e105011546e344f162ce79d69d27cd779779ac966e16854229ef6b3ef92d155b78d44469396cece8088be24fe2ac68a4725772fa6653df9b7198843a69de01041d3de56060638f59cbc64eda7f792066b56eb304ba890aef407a600ffd06f5fc9bb974cb75e07b5d9ce44f69adaa6550f9689d629111a08ef9e1ade9e4d401653c4d0f7376a485d54aafb8b49b06cb41c8077f2f5bb21611f586d3b040385cd2c418670a01a3db03a8dcf599d8bf7b5b936d332fb21a31ebb6a6715d0ca3143df2243936209a48111181a004cfc62ae1fcc0a9b5d2a4d457aefe2e133fc65263a0c20ec6f4e0052ca3558cfdfa4cf218a19d680905760481bc86d97f7f6d0231a206caaa6a11014ec1a1b0c73fad6b33f8b19233453bba8a65100e088502222a2a564df0f53f13ab592df25fcab128fdcee938affc6aa376c0eebb5ad8e015cdb3636d6b05a23cf5db0633b8970b279eda30ebc0dd6c3adc7d49988224ffc41b08757e4ca19816a79fa3b430d14c69bd8092e28d70fc724f1e5f14e64ba86a90918bf55db2dbb0e192937700b4dc589c942962e5d57aca93674a6c65b50d561b72bfe277d522271108b64d1435d855f7794ca87a593e1ff16252edcd46acb4457bb3edbc0df84f6886da558629424f19cf4bf3bc3b34a404e23d6381844d8a4ca13df616e860956173529840edb3b2293934198e926f1f6ac867d9874e1f16c98edd995d4378d7e3c5d4bb98eac1451b71de5815bcdb6c44f7b22d707af3dc3e75ade7ebf320f60c260b623c90658e43a394331c90c7379ea93f5f27c889ddd7e061c220fbe791e2aee517e4097784cd397f678df19785f2bd91a6ebef84739dec855b75794c89ae8a62c5e03cb2cb71c9af417ddb4255a42df896a000a0c8a2496acbc6d8598e45bb0a1a4d8d0f4a052210f26d756c6c7db722b4647451f62bd505eeca20ecd3b16c1fe303b04f0431b99afde039551970fe590100dbbe0e9eae116e9e6aef63935241273e5ba5dc40adb74a6c0d7b91b9ae2cfe59bd1b7cc57d90c41099a400c1f888afeb7c201c40dd35627a10ab06f72b52e62e0eb19bc59caa2064129cedf9160d27cea32fc5911e3a81a1c5945efaf6551a865f8cda9bf36073c386a0bfaf2990e64379f0d420b73cd2edd37632dc646c0ede10e8b92c1f5d91c1f407534d8a5e506d91cc3f8485b8cc78f6df35f27281806aecc2cc877e8d62665b0a3198fbaf7cd305f66e5e4f05697cdc3fd297a65c382f97979e299e0184243e72c9f3c5cf116cdec85b2bbd4deda900110560be668025d1a3091f687eafac508644e4b8c8082c9ef4a957da4c022b968c960b05329d52dde0c07b00a1f13defea2c9de01ab85246aba86217db7267b130739cc3d6ca1f288f1a94cb835ae6d6089e8beafdf381ce9d06486f1b008713bf037698070e33bb46309f458b6622cb18e6f4b7b61a33e963623c03207327f91d80c34a3b8f06ad3caf54cee26f967be102caccf3234d0b8cde58bb1acd386fdf8dec37eac7d68fe7ceab6df70af1da672d614c0fd5a0088e534512fccfd75eb229cb92511905bab479c276bf313cd5766c93f52a0278ee2e59e1cb9a40688ff5d65fa5b03a280f16ea0be1725fe221d772f6e7d5029a904390158a25b1591c391a6a69f3c31e387bd5886051acbf0b37038b942c1385b15f707e46242fa9d57cb0a1976ea8394c4bd0425c7ebd286b59a60946416105314e4000e6e8c3300b4d3ceeaffa8ee8da4c0808f64b24c2b3bca025547dd829c7861b43dcc091c52a6ecea077e95b89feae511de063e5146293a3ba43978b240e8cf5bee2d50cb8535c12024fb00d5d246e76fa908e5511619770d18a1bef4a7bdf9cc42aaea34e2002adc52ece03a4ff96672e4ea194d232e9f5b08a0bfce76d71acf7d07e2e392416cec06cbd83cb2dca268e6dd267cee3f9a849a6662cec6ee43d1221777e46be675e0d1bc9dfa0c24a68309dae7a9ea212ea7f250207ca373aba3b3ff0b7d04c0eabfec363d403de5453caa72ba97e59f5bb95a9b660518e39da587c395a41c2f2e86dde92434a2853d062cd72585f1116a4cd835b72e89da7d633dff4ecc3ebdcc8d2eb12f3727f056d02460d2f26140c33d287367c729ba677d920a96510d1230d04746b51e27543a4adc5b7b0173cf7e13f5e4d1026328f407f34fb7dce5ca39c4efb2f9e534cd2b3596d4e96b4165647d5d3185c2e8084e0b3a5043730cdd2dfb6d611f8e0cc5fdc5e7e239e8c898b346f8f9667e619adf75fc811ba2b635f4d984c3c6a61e09648922f209915652c0aa77e6ae81f9129714a5d9d74a58ad08311434a38ae8bfb969f81c510d17c706a7a35003a68c9ffd91c60bc11ca4c530443b9c5eec3dc518a6a0e02263507d656c48c73034a9c059f67dc7c7cc7f7b0dece799a6e41ba46f46973ab6f8c1e5f91b8b7bc5621153de71a41ebf8188e4d06c962b6b3dd5b74a164dce542ea3bf6c4757f9c06cfe136d9f2e0cf90260cd10fe773b45dcd868a546970e617f894b10f6f11bcb030f77aeba12a579d5bab00d63e5824a62cc47a0859a20650bcbce400cd34d3e3de40dfd226c3cebdc29aa49227f1269df149a6df5096e140d7856c42be4d6c7b0a539eeead90fe7aa380a3b22d7df655b484ecd099f2faa7f4b0f1591b90595a1e1e60d37b690239e8d743b3cb700b1260efbd1d41b6b9e14f64d1beed51a8bdd3635d6fbbaa0d30a757908a534655cf3b49803142fa4e57f2e7afbf29964b1ac98cb86865150774568487ead4c7a8af3aadc293e4ca57fd1a9844b170f5a76200357779c502b2c36f8a7fbfbd0c1362605ddcfcc551e4f57185314942b5e64bab95bc8e9f2e935939cdf5195baad3e350e0624cc7fff908faa60d9054b9c51ca22f3c4d274f3fa713cee766e36dc76652d2a5ab424c25b927fb7e7b32e99b96cc2eedf9dcebd724d05208998b12799fd0ea0a91e468625a1dc73bbc424041f99048f04febed9afefc38d57c2e9c17f79a8bf68a6eb1688e1314d190d31faa32e61f34b4dc8837f03a1b4c17f71ba4a1abc48feaceb913b9d6acc0da23ae4b0c635997eaac7e05fecc4b7e9f70e956a102f5137c7f512e9920bc6f86bef6bebc3ff9eee0357e127b2e84d949c83b1bd877eed50f55dcec136392f9e7535b1afe2047091659080cd783b6f95ab75fdc3ae49397dbd4f7a8922f7d874df48d06e5f9552e43908d04e4aa624a7e21d485e808c2d67b3650a80ccb6e5ae78dff1141ca3273aa31f431ab1a5d3b1c38728b9819fb2c6c940c28acf4050fe9c43ac91c382d940c70906d3c88ebafb086e80979302eab61b0a2cefc72ead3776b782eb0441168b1ca1e8916745b3fad6ce4dfb1b09e52a3e6d26fd4e63f346b51fa30c37019a3478ea06b03c97a46637247fc594f9a84d9445e37ae364ef174b7746016c7bf0925519a3669f33031124252427f241c046f8ca0f596925481ccd8f63d9ffb637d71e8650ee71b05100127976da05b2289b74023653b0928d17fbb2ce714ada1a3461eef68693e46b5a474b437f065e6ff91895bf81e41d170308faa2224d39a2661dbb1f32354cf3b2b1f95e3d4643ebf74ac85d79f20a21bba7cb603f1568db801ae2b69cd0f7c717c17ae403ec3c787f4fa35909fa5be45405e67e6c57cdc69f08ccef8f959837877f75ccf3fed2055da22f3ecf3612927356d9666c9648adfa738a7323993aeda94f939527030cf88359b660d289c0fa8d5eb3d1f054d00519c6e48f714f21bc5244b0226e36e553126eeca7dfaa13b47ebe10ce9cfa723db485c78040f159ea10f0e8986f3ff6591b28234df72ecda09bc93ea05cc381c2cc0eefb837d61731af4b14a9399324a38559987218a1e1242892c8b20d3145289a08d73ab0ed69b3947cc8cf75f0b3e111714ac34bf66e464ef172904de2db7bbbd23c06a2acb63c4efbc24f369881d4460ff236c58b3690ee45148acc8b036f078dae96df42a4f727acf20ff491440913e8abc587091e482fd778721a7f9bf1483c651039c32b571f12ae685ea965862a24e70cf955b16e1fff3359f4c0dea383e02ab5aef882c9b97f3ebd4b5caa882b42426f3ea6430f75f4676c9f1cc0c716587f10a0ba80b82f125024b7521e3981479164b4a0b7c4dc7a304e700432e65c75d3cb6ba699486e9f65a532c62d9cf754d20fa81da320745543755833cc595f7b50dd3a9e690be946cc18d7147ba32c2448e3ccc7b7a3dbfec00bd1a6cddd5e6c0c2ac6a0d97071fc3c71f52c248e2a647a43d0fdc32227218ec73822f64347e0d8dd581b610e79523b1315f12de6bee4a44529cfaf73ecdaa5a3dd26d86561dfe6735698667d764f051ad8fe7d08068ef6c0c41119e1408191f928a547b9a59090857d0ca18b638464e4dd507170a704c7801be813f921ad14b7d22f0e4e364a363dd714f72ab8b9a28a3513940a329639409fbbde021c27d49de748cb3b7b10d7ca2e054b8e721d0567cc16bea9b5cc2fcfc3b75308681da95347314c67f8bb1926fc4d65eff912f663fdc82c558feea98a1cc8bbe1ab09b9d700ef9a967712ce36c2a480be5feb47df722613dbee88a1ff2379ce0086585c7a2f3d702f855d2b866d277e00966b017bd64474d313d48043151f5876c21130b41ba6a37e55ce052582a50e489b9a376fae55a274a6ff671d5be1db3beb834976eec338dcb24cce5070c8bf68db79e4a7d033b7351529c8fc296e40cb4c9e1801a3fa9584431130317d6a35d9ccc2f3107f96718f87938eb26cc3dddffec3760b77ad3671d2fcbc8eb343c204b2f02915fd5af99248f20ec5e025218a77e6f579d98eedade12b9156237e54a387e93cdaa884f87375a33477096775a90f251ba197562ef46f6dfa8996cc9c9a474ecb8fee4ac32637b29a7b79549424cf6889334f924f97e5468b9653b97c758964d06340757f0a4ac86c9ec87dc3d9f11829e007b0451a498cfbbc68976238b1d9e378ed3376c652c022b5dfb986d559bfd56769ac9b3c20237670b4392e98eacf43a26fddab2136d4856e8c2f3a0a2482a44f7a564c377231b26a0cb0b0a21fb7436269499979a4aeaf97fa4627d4a6bea3a79e610a2b3dbaceaddb53f90566d51d84ed9fd3d74f2c6d81252dbc3f7600f57e888d9fc9985c84137785c084437189245e1348037b6099853f843b1da7fb7fb33fcb347d433a7d5e88d8a39db9627f04a6764f5c1beff75544a1872b6c8965de854f0573c476e66426f3b3333ef421341a027fb38baf763380b5aa5976ad00ed10e6f1e2e6e6c7a11cce93b7e95dc54a027a05384e9bb7270c48ccd30f672a5732f76bc33deceabd27afcfe997d3a19eee147556f754d94f0d25ea2d01db3c7b26ac6ec8d7c13141d4349e531263b988d180acfde94333c8b6b88052bfd897b1678bb68a15877f55ee9b9d5617fdf5a4bfc172020b866ef597be1ab489ac5716eb2d2d1ea0fe678f90d8a173a0390de117b88900a4c508db4e39c2f2979c39afca015b4b44c632c90e9ce4864a29a87af625750b8dbe33f1d88b6750246639143e61c9463d317f1b4f7bead94a16950ce46d66b45b2255e37fe799968c93cd0fcb03efb5dbf9421e69694ea4ddc8324f0b37f9ff740415e53e76a8b003523e712537ad623e5748529df4e88856918daa6c512528641fb33385006b8a37f29d6c5628299e1e18d8ba79dce8761b2db99aefa4ab28321bb68faafd61a75be0bdf66e9ca327dde081861af703cfb86d71470ab19b0a8dc289b1e40c4232d04ab969c8aa1c274e6d309608e0a2c14be4a7852457bcc52242750d0417f5dc06b2a6382b12796eb3f3ed3475b0d4e0354e7693ea7f8e172df6ed8baab1905964ac595a94f04024a0a11690df3d8965068446099f4a36e8e94a950e8186780ff38df71851abcabaa16833b3366000fe99484214ba0aa70a7302cb64d620a67c4a6fa98460aeba56a5f5d4c4bf1afd37abbc4daa6b8181a6102fd1345ae81b4ff1757035a575282110d1e9576fd956351daa931e378a8a22541baafabb84db1955f2927ece3473fb473ad0ad21a32d89733bc5df5034c8cf41853c3f64108e777f011f9544bd930a6a5e098740b039f6f9cd076f06867a53868e85d671f7063f1b3f9b4c9d895724da9e02b4878b28099e4be17ef37bc216ec787bbd5a666b946338254c160dbad520715319ee425b6a32c381949f7a70dbf350a2c96f7f066cbcf741cfa3e19e68472d4dc980caa02199fcfa37d75456d904e8c4f5cac2d458bd75814840ee6ed411cd60653e2607b41934070b74b1c15dc915bd524ae5ddf22cfee705c47a3f3d35a0c3b65012dead84e44b054b4e7877c500b6a06d1f57f9f280fcbb1d7a34344b2b2841f1db45d2032552b6a9a5ff395f8f14f752dbb4caed0c96220a4cac12129954d10ffe453918b4e68e10a9957f2cb966c27f0d90d423a9e669279895e50353bd1a977ade3ee401bba88a12f3c673710bbb709b78e5ab6181c2da9468ff9b65915ad781e22fa8d7ee5c692bdb881a889ff48f35268d0197349611246dcd843f205fda64fe0c74ac2e30c1a4433529ee698c57b4ee15a3c23e796fc94a2429ce7a81e14f2f613716dfa41a7f2f13990a03c6ce248dc00057d024b1b42db7bd5e7999ba0d380e05c14d13b75b24733ec72c1ce71e162dd3f29aacb8745d537e1a482227d8fdb5f77ebf62fc67436d98635258d3f35ecca7d3e938ab606f6f69f90ae1d30954d5c509234dd93e9f00aed69135b5766122502a931a225d52c993fd016665cb5f81ba5162343df880194cbc0fe864dc82d134bc74ce4949748034c24ebac80cf71b5275fa6623e2347f8c4e1dc9a06211e8f55f61df5c5ea3d5432abbc031e4922fe1441dfe74466f4d49e0f48e03bf946d77d45592ba3de49f49fbfff7d582629158a4b0f4f03d5b92f76fd0ab88c0129aa86acd528321c57b7c4cfa5855aabb64adb25e1cdd925cd7c201c649b8cbb2c8e1d9f1e93a33478f3e697e4019e6778815107a1e90f9e39b07adcd5417da43c545b2198b019ecba94dedfad2602cdbacd71eb68cacdc36eff969731f7e978c1f5022fd3fb2f4a5249a680e6a57c16c695188973415e0c41982cea201865ebfa3f6fde0aa00d72282a8389b03cb9daee7ec0935c52c3a3d2da9a0fe2a70ce7ba566b35cb3a76eaeebe065ff5063b64d62b001e6ee0a30874c3137cd9246d035158bc896c060a889981088b469b8023284af93af834ae4ecf122973cdc20c759b28034f2f344193cf99ec7931a9bf25342f7cb3c5b9cd1bfb61957b96d8814d63529bee478c672484cdf83ed0faffebaaf3cd7ca2e4e110127418d4e71f39c97d884f79b8028dd91d7218b4ee8abbd0af","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
