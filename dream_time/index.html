<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a526ed2a67d7c3390915eb87aa8b27e96d73facbac7375a316e6e1aa4213316c539a032840020f40e89146176d8c23dc6c56a4687a38d9d82e3ae23393539e997f3cdef9db3e8c60d125f1caf73f23a89d28199f8fa5d8d37eacab7df072ea42c12f9764cb9782b565cc006c187fdd95e79936d09e203b6feb0a9ad6364c36835f5cc4fa5fcb792bff6dc5adf5fa90b2ebdf4440c79ad6073b40c28e075ecd9842bf6be4197c62965a5ed24dc08c544ec75ff74c694ba1a6b3210f4f0517a47d48566baf85f0ecbfb1b6b7fbd81d6de5f02c74a0ba540965ee81ccdcddfd0e0c7f273e99eaa7bada142e84d70558d575dfacdc8d63987d6fd881829f5baf0e661b2ad26bba84382c8a6c7786c929c93acadfbe404f98c6508c905419e22b7c5dae999941a7766e453b887af839c067e74abeb5f1c7454d7a4546237449a34d263abea49751087ce1ae5bf56420dcf111893a3cc5519eedc73bd54a1146046f6d4f68b1174e0b4da301e8d55db878f5fb91780f34bdea260b94611d8d8e3ac1acb44d395a69a01ab23f5a9b7303a8d176dc3924085ebc48303b3e2532ce1fd5f0354fb2c8a41cf8f08e5ccd30362783d45b2252a699b492fa4f3a230e9cef131d7f8212c89232065634a9de835ce93a6d963f08417fe9dd4470aa6777e6167d4c359dae4222dc58b945cbe71df45120f2287b45b44ff4e7c0c7348b8546414c546b674ee319813bece652c4f45147c95b5ce955131d5e02f62ba9bae6612aaf3072cfdb036dd4a4b2f83971369eb6351e02670fdbb0e89f7aa35c331b6eeccd93671b3b7fd1bf20321891d3d8f6c31e002eda86bef6296e29456f3bb5a350e513d7a90eecc3cb35d94259921a23e3b596d8df1d3b5f2daaa12da515688990b0f154be8ecd947bfce1bc909724a47a3701752682228c58ea029dbb95cfa85eab368f876e3248e9d81a85b860514ddd172c62c42351789e2fb187bff64ec5c974cdf2b67618e8f2a0f7a16defe2ad7d9477dddb6a643abb4ca743ce58c0d8554181adb30e3bc979cc4cc1f5a204e2867617924907929e794bf90c188b46a3e1ffef9312b5b69e166bc656090d5a340527db236e8acae7de3eab907cda829fc38f5a293a4a1bf4dfda70f9aa12d1086deb3be1670e0726f6ec1e71766b5974a4bc517cba1e072f7057fa8575414785684ed4e5a217416d34abed9e593cc2ce71df245eb47a13dce327a9a6568b631e5c523cd8433b1be5d8e4f8238d2f70caca2fa8f4bfd1b54032cc7621ed8a3fe04705a6730ad2c61920f25dfe5e01b74659437be8392708902f67bb40527d4303ec84c913125d6f57348188912e2c9801b5e98dd2b58f6dbc651de7ae7e1c7429765c1370bef311ba4047aa85f3ee329b8ac0d2142be4e4228420d4e9bbb3d9e3158c2cfaa29ea438af1a2b558e1bf92c892b236d76fc6e79798782938e40b320e2946710d799a93a3fb93b59aef71fb243e0196e4a64fc3dd2598769c43866310b3ab7484761c56656cb9db301f33843a3696fce1c7fd0eb6c7366bbdc8d6b757dea27a34413ebed2884efbbc9dd90c59951b1312043222aac6269dd1b2636e07ce119a94686c439b37b9d7efd8ffd706652729f1d3a663d7400da84a868006452331d3925eb72ed5a496e2107dacea0300b86d3d920293ab3ef1b84733dfdff8bb90e39d2135d1287538562d264111e313f983a7b742daf2c2f1eb7e2241effc1fe9bc58b323eb52285b0c93a2ddd8ad6fa8271e773394091250aa70fc6da01a01949aba7a37a593e5507e22c58b3404b72f4e74e8fc063681a491131c9e95c625d0ec650f7687c35b820d1d42eb339d0b9fe140aa59e48cc949b3079f08712c8174a727a1e80b378ab56be0572c5e847436f0d40b82f78c2040afccb7afd5b80ee43cefd4cf77a2d82e71e5057d463772cffaa6bd0bab6536eda49a2cbb43887a1aaca98a1a3d887d71c4a80583d175f18df3e8fb3102eadc3bd55a054db045fbc3b3349ec7d9266de6b280a2f59ed87ea4c03a90ea2f38020739a1ad7ec26652c27bd31df281e69f7efda56fca31ef5214ded561e02d903db28953e9c2bbc2a83aff34eafa82876c7cb6d086b07a5285cd0b55250a126ef0a870757dd0a65c29e9d5795aedb74978fa2702006011b996a71f46c791764be11c8f3bc8d0225dbaf0343b08acb164db1b9138f2132a09bcb729481d75598a16cfffe153cb184073a714c7198dcca20d3b1ed3ebaab113337f10880294ca0037b56e4244133de1a4a43368653b32696f501e0d69af3a1ea064fb5d5ca6c829552e2123b91c039d34472b66bbb34fbec64001a5a374399096dd47b84a8d7c6b5e994f41879c6856674fe3c47c11b874a36ed8babb38099a3685930a2578245505216954608fc53b5e067e23fe7551d20f49a6e5b9cdbc99e3e554827448cced50e1352cff091ee68905e329b35e9dc25ca04b2e95f3d02f6a9b85bbd7098111dbcd584bb5e86c2b100f7438a2b9347a0a39067be122f3f3129dac421c71dad890b0f5a5c6753ae218a6e5e5654207d604c803717134dd364b1f404a9f7714ea6d34098b94fe8ffc313823b3f51a9e4d2fffd0618dd4f9ae5306520a2987a33d9ce5bb1ae074e9f9317113563ec16d42da4c95b955a010d6102967696157028a419512ae6410a76543041d8a333329b44162d15511263d4fcf6c81421324c2563af2fdedb5aeeaaf26e5e7177bd419599058e0e5e6c7365b56179c6201b6e7b0d3e01313a3fa78b2c2133e9cd79d6877e0c4cc5463d5c3478845b383025a9853ffca07ae3fc3287cd5ecfc27942c5ae40d97272249e446de33e326b3eedf7bd26ecbbe956e46bbf2aff9c45eaa15955d5a252de459796692e97944b42de65d7911660f0406ed46261a512ef4ad8b694a039eccbd910cbcf806278fd1135589590c13d07a540e95e43f3674a3f285a428f9cdf57a0a896e1f591a93c1f979bf23cd08b271ed4207c71cfd509ea08e6a3288034897f556306ef9bf2cef6b083fcf55a7cad4f536cc13fd300536af231429c29db089d2a4d1b633dd913f9a551dc25ff0f1e79dc45c86a18347448833863bafe0a12cb70de3db112fc8ffb45afa5ce84934d1b093293018a98d7dd1c96884fc17f95c8e8105a80d3dace655ea4d29132662c1ad5fbc6ce55047d17bb910578c0326154feb01688f751851917fffc2233dae73bf67b95fd467613ab928233a843397cba1a369a83f23080e7e1bfe404b258eb1b82e56a6aeb35dda7c27f4bb0129f56031924bcb15e4943a05316d5c912a0f711089dc56d5988a3a58a6185550f2efb1680bf01d4e0efb00123b59336bf026bc167f7fdb967cff3dd63e60f476dc5b60f63d649c6457cdcb68c61cf3ef9092d4303bb99cd7d73ed313cca46dcaaf2f3742a8afc0f8d01cebc0bbd2c5af7da04a5375b7c89e93adeafe0f58346f13cb813bd2abc6cdd6768c66a161e9941ff64a08be79a3e262c1e2f0c430ce80ec0b297d14e5dc5a8e50a82d835404994261369fc30037dae5d9eb4eab6958e3761e0b2a6aabee512c73a3e479fcae9496dfb7a0b16978fecb35bfb9824ad45bb22d819482bf319000fb32ce41c314df6050c78f183cad82e2f2b6bdb73c87faa218d6f0abad294c610024c0dcc43fec7a7bce1318139a7d2437eeee04df9c756b88a3ce9e004a071d17ad4985ba9156b5147f408446153c009b46a037b5d661fb7252fd37e66477756fa9cb0e80b5b9a3b9c5f0cfa13d2fad5e7bafabef95edd91e98f9807648a0084369c408e6412703bd1b4980f01905e54cd2518e8d5987af081aa0602fc979606effbf14c047934c381f4c03c25ab774cd174b3ff3889436bb646e892ff2d199a6c9ff55cc4597ad1b13ac1dd3fbd2fad611d9b8db33e7718cce15ec17ac0ab375dcd1a2c085ca1d2ec853c18faa7ad468b97908134a135b92d3978a3ea2fa03b968d382fe1b63dfcc1aee6ae4a8ad82ff89ecf48ac51a4d41d6fd7ecd3680dee2b79d33f12212b15f1db79cf7f4b2a3c275d1cef29dac9bf6b3fa2447c4bbefa6206ef5075c95bc28de9997f80f1a03d486d622609f5cd8dec554bacf063a0f32dcb12c420df771195b155238b6adedab3ee37c39bf66bc19a3071f395e80d3816964172d8a838dc92fa88fdbf16e8f79722e33f427ec549f517fb17f72867b7341fdfc2ee5d884843cfcddc08e52bca039926cf2c13787b545f577864866fc00cbbf0269c896706503b77ab3d5ebb069b9d99ede81a786c3905be0356f92c2ace7d8d3537d9bc01efd69f01d6d94ee8fc4c8668bc35bac11e5f0073d4b3b4e48944050cecd4f8ab7c614ce92299d8ce1fba458b1a2ce4c06990b82b8659986867a5ca9245cfad6514275b6fd7a06361500b16df8b6f434af31002f22cd54c6985378bc0c5271ab73ccc7dee7e48f57e46450014516828de7e5ad1c054645f93173c87d09180ab6bc19390892f438eae95416f9e99100d7a6365ea9758e624558c2a36d056efbbc80ac62e7c1b8cddde76bf911da196abb265ec62d1383060e7413a61f9b4acf584a3179c5b8cb9501670172cd32c27fe546c5057534fc3c106e87f68771acf095502613558bd53ac2e45cc3ba3a6d5e7ad2aa65cd625ee41580d6723805068227dc2d1870b46cc4286dda3ed5c920b27cbe72b85310439f7fa1e010a5a15bb2e898b8a901cf5e2c148f95e5f71aa34d676aca7001c94c62874e806dcb5ac4fa0edf6a0b416d890e458345ae9f08d9704767da629b717c6774a485b825e8f0574abc7cb20027512e88cab407706610bf257e11c8b4ee60bcc3797814fe0bffbe40a93fc3dca6b704084a5c4c7a948f885c0398d09a3c4b5d523a8c395b52745ed8a6015b4e4054e627d3a52874bf8acdb70908a2c4cfa6c6bbf8dc80732d383b1834190b4dfd01d9f0f96730a6692d00487ad905b66d22b2e9251234249427e9d40b49bd7fcda68a1c079b2422c04615672b2b570b553df649f0ad7888db6b7039d11c735a836b1e0b54442cb56d03e27f57d07b102eb39f5fa819916c671384824e9cc46561b878c453f8cea23c12029ff593e8ae1825281e4ae9f4d0b6ef2f85f36d66d99db6d2c392228e877347ec755fa42dc16a244abeb38aea0bebdad5adf7e9a84409ff7581e51b8d96b6524d6561ad26a8fa7a043a28169caac4a08aba12ce6e0bdb816b062d709c8e3d6f146fd39606eacd91db9720432129b5692bf12524d33e9eab7fbc9b04cc96d3013ecde37e5d79c450382f38e90ef81313e1109dbb029b39496928c3f556bcf4f15e09bf2b15d66eec9e117594e2e0a85710249cf55b9e7ca27aa4555ac33a80d5f36c8bcc23b35c0e4b14a6b5a250cd3c1762b08af7cb986e102035ab34c6fe8587c151b1834c4b0553e028091bae794a6f6b9ca437a574708c6562d0d8b24b6e336a29901c0246a1a863ef131e9b90bbabae739f0f1ff16c653902fc3a0c75fbce10e1e65b08b39552e907a759188de6a915353f29119dcf8bedcecc33ed9fbf29339f735b98ee3d5986570419176805e35d15a10a8f8f7f656fe055b5bbe9ca8b4fc0cca4605e0dc26a0243cd5bc44c6fa968cc505d07535a41c77a123b6566134bbbf1a4b24c7e73e538df95d4d0d4e33f373d84dbeacb9bdbb6f0a3b53936a1f5efd4dad154ebe35e0c0f570f271126fbf95a6fcfe2ca8796d81e59d9993b6d257cfa04354b72dd5a2c9cfc6ab258bc861a3b4362f475ae3196bab9732760c3e07fc1aa514626ffb4759cba7b385f63920b17b0e73c77a5f32ea19449afa0dcf16eae997ae1374feca0b9c1e0ac9d45592d666b5de608ba70b12db5055aa84e130a3235904cef9be72a8a104789d59968bdca37ff9a61a300cdf401800b35fcc35044ea4d2d4b5c74834f1448fac7fb916a53888e9e8bdd1923051312e0735845dbac416dbee8f3c12a9c538240ac705aac599e48b99e1f02859e3e5015f7f0473fcb8c7ead5b6140788f272bbca1ab895265eb6ba15b3b2cd3da6b91d19a327291e716d84d6eabf2acc9358f9582fa90acd65811a088998d6cb8e3dd49805deda6f987397042bd0a7aede0aa77ce8cb4032874d511067c0c989cd7e0c76c71a7bc0f1dd4051d75e5d744dfec0e594810e662a0225cd27714b1180d3a67a4837b6c35d4670de54ba1547739b6d37b6fbdecb2571f26e9d5b76d6728ede29d46209105394f5f087f635a54a96aeb227d75dd4be106e97fa2c86eaeabf82318fadbea881e928b7060dfd237fd2f5021d373eadff9cdb1a2cb7c9c3e780066f90bcb92e6df8c5113340b6b85e612f5aa8ae6c7877d04dc4b49309abac1de0c5c0d7778f51f8bb0c52d9d6d07d6315cd50d6d0aed2f3d4fc055a8a178f1d82f65cf16f147625cae94727fab762c92ee78d5eb965d2888e1b02e78898791d2f59c0333eba70460a8d23415f6f85ef60bf58e7ce60546557ab3134ac542e64b3dcbf0021b358fa0254925869266332e3dabb8dd7c258d65b233372bb3fcd862fc11606c8ddf57e5e10fb25e8c2243ade3de47522b4b29f47f862ddb97342d9ad0edf206029714808ec09f9c8406465902fc79a458f27e255cbffff3511e2fd5f0d32a7f6a5782b311e0c5d2d4fd0b1695b06a004384c5c8857fda8099f3779c6d22ec748de698a649a7d12605a8015a663f02e2307de173b9ec2776f2138dc8930fa03da8a98317aa93eb0f781be92db836909a22d3d67598101383d12e6e6fa7961773c11312b0eef00ff1212bcd936d6a36a5a43c4aa71f2f093149bf5a299ecabb5508e9cab5f3babf7c3725247ce1be835f5dec4e5882c8481882daec7ae87ab0c48372ba71ea61258afaa4087bcde5436967deffe553a7f42c470c2a4796b99229ba55c7bd84edbc70dee76a3d2034e99d58dfa76979acf4a56982dedc769940d55d5c089cc84ee448c00f1daafd42e4e611f7c845b518f5bd12f5ac6c0bdd7594b8dd6dcc525279c3bba24debd06e597edd3948c42dfcdeda705282b9a2791e79a2e887d408d1e139fc3a03ed507ed5ac9d5f8198f56073d83ffd6afecd2cc69c409b696360a33b19755102538be8687248c6fc115fa32676a48d219bdf9d356617abb2e2ebbeb8ccef9434eeccbb0ebedf0f6d7bf8d27d5c3b9dc4d201dbec424cdb6eb06e2b974237ac04b080af3627ab386164bc4dd296c7eae661a70f1da359dd41aa2191529f3678bff2ed272ed66fc4d2cfb9ede2b22340e35ffe43050f06bda11c69d04aff1390d56d9aa7fde468d745cf29b88a2d054d3bbbd20d7769c73994aabcfb6b69f88f0f234c202f4c54c490e09bf7d747507d0aa19625d35fa7fc746d144028189a146e1a6c3e845297cdcc4850c1b509d9a4c89414a78b2b6f579fff224e9fe48145914424811802edea2d590992b4da50d6f7a41510c01eae10534fca0e9de1465a9d91028586bea2bea6a3afe7d7bd9668c21a52a4b14cfcd699c188b8e6b2af26eb039a1fe6245ed74935aac2dbfa4581e7b0d4b4d6796b9c08163cd0c2332d1eaa0d4431ddf6a44a4f331991d257f2600f56937459bb41ea259ce3d56dd254d2555452da2a212247bd1139886e0783ce9eaa27ce501ae0171aded2953edf2ae2c2807b78febd72a48a43b7f3dc18dfd5878e2a7585cb9e3e1d9c826dfecbd3b9c7460c45ba406a6fc2d91112889928c15333c3171239d27debdaef64422196430f495c462aa88f408415b4ad339e7a16126ad2fafbe118a229030f048df5039179b8e4705b2f77c21494da97c83ae60726ec82f9b221567c0eddf3bdda098fd50fc154d1db2419c535f05a2b6434aa7abfe7f58656c69d7ec9a23bd05c97cdc0e213545944a989d2a51638d45fdab6d25c36b73795161b50706d747a1327356f7368d60e1efb9579291651aed03ba13925eca14e7d719322778313d0f78a77dbbe42201417a534129cd563292045e4dfffbf8961364e6615d74ad841f6f0023148de6e5e045f69c369ebc7c6af28a3b7e76a25f6b0b09a165b6bd5e294b24c31b9ed0e3f142725bd02e47785407ab72fccbcc79ba7c8764b3a23bcaaa421e7eb6a0c9958bfd864c71387e28a5510a4e4343325a07176344e0ba7790c5490bc7a8bef1c1f4026a005229ac174a22d183b1484c224b4f9218c3c7ca9bba700be1827b9d1ad7b2429999eeee41106a4c70f55bccd18ca67e075d22cfa2cf992c44368ba578c1b3d2b7b4ad731e78b555f107d43bf57e0050a4d147c92848f75f851a637618993bc0083987917a553bb4651b2825907be66e3e1171c41a94bb7e33220bd4efc91592a6c497c80fd85a2958c68ec32f8e3031def2f54dbe0b594dcdbcfbb071540626bb3185c658703812679a9c35c4b1de1f33c5feff714ecc0bce4e0bee2a124dde3a46dcbdf2549aab4484a263f99e1392cf081de9b5e714cf194381516ffca95d3d88f66b138e392c138f4a28f27f79b74a6c390974476bebc2f5acdb5efdcd793597e4ef4ba386a71a1ed6f8add2ce8ba08580151916fd37722256466619ffb1d5bb1cbed2019e995abf3a3bf2c82d584191697902695019ba3f78b94b2f815ebb2a961801f1ac2f3f41992ad7ea98c7d65939f7399a3ec6701bc151b41d38aaff375ece877906d1f73ce3375b760c5235e47a38fef627820d54b203f6bffb4ec4ecf01117fc6e9809ae86ca6c05416755d557c9661395cfd8b08c57f1e8f072b2d57f7d744e5b6cc954398ef4cc9780966e3ae37c2b992d628b8b09dcdb330825c622d1f5d5a9d1474b93ef45bcb69e8a3576fc4ae6364317fcbb534ce4fcfd91a48f15f9c5e3755dfa7018d8edb7854987d70ba4a75c6ade211ed2f86cdae6987dd349edda0b08fa29d6268de1216a7bec2a0a4f89131be6d7a5a2012dbb0348bcd2c7006f63e7b64fd270f5c14fcb049dcec7d66a8ad61af139f12fddc710a6766eac3cd5ab3e416b40716a6ec7aced2fe9d164448c229f213f868d986bda74d2cc586265510a4c5b066fe49100914fa13f811f7e9a0912e8b44f6cf0b0a808d377a19eb53c14974c49d8219960df2caf5708658a568826c5132fca7ee009b9474b4df98e96907f41765b9ffc0f553f4189f1e491aca37f41adf1916a78d5ea06051ce3ecc587df9bedc6017365ddbfd87a78644e8cc1bdece134a9552924415eab8f8c363958fb32fd089fd3daed6dedb45eab81e348","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
