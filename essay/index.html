<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f23d196718353ae48c010b8c834ab1a6bda03cf62ed9a0154b63649f7d8162feef5be9d39ede7b397f99383f322680b36aad1c5cd1e8c5a4740b17650b0d64b67ffec13cff1eb12826630b4543266ff8dc7ca5a9d02b17bcb649eea4f2bf93f4ff4150652e5f78e7e695c7b216eef154a13c96ad91322528fbfcaa9be454ce329a5dc8bd713e25a02e68877b6b2f21f051d0c6955691b504f90a6252e9321c3e8786f76b43cac54af16304227f100099eb1bfa5483f80cffde7381b27f71d6371ef8b4b8b8eb4f349a6308df48a394e2b1dfe9c7c4100b3ff08caa6ae37bed33ef2334355793bca2665446f1f064f2e8856ad43da4008f1fc36432d8391a0030b2f91ed98ca9ce5224d2b2f322afd2010462c345f99baf7593889a1a97c139ac5836ef7ba208a768008e3677f84be3dbd93cf284f885a7271ce0bc8404952c2d7b753fdfb018fa421a34a71fc3ccaea9fc2b1d5b17f7365a2a681a2600fdfdb08754664d56dabd023455eda2066c33df17a67e6d79e4480565029b865d2664a52c691ac4d10de7e7a0a5a4dc46e46a95abbb8f669b46a501fd73d06ff440961fb25168bb0073799ff6a059cae7b768a6c60b5f9ab0137d7fd9a941136c5e4db91f15aa5c694a2553484ec231fb40f939c048fcfe6f4161432ceca98b3893f45f1fee857b893422fdaeb27885b15949c180fdd2271737aeda493559731bef11fda972f154daa68c7e1068560319d716c5b3b9af6878def159ba8ee24333ea0de3ac908c72bdb4561de0360b885ff1eb6acef0a587c3dfeeff31a74588ad1358f6337a540d98ef360f49f87fae5f9830cb6b02b3b1dc383ddfc850631b305bb47a25314e2aa910b97990042c52078876bef826dffe9604b92a1c7fbbeb14a5dec7caa024179ce9c6be67b5af78bd31cb27a4d1efc5258485bc5004b7d047be5f83d73a8c6f54d058bd6e97dcae302b29ebe85c556319af3c99417493d57b16c58071bd4d0e84a41daa4ad2deed1653903c41d845cc2f34546afeb0f089380b32be18309f6a34021eb63cdab463a2a28d46389e9fcdad3428e116c1c9575bc3e79f4264d5c356570569900f1c7bd06062ca7e6dd444c345850aafbe5cc5b0d2c4cdd2275a70e8c3051d2cad5928e16546124599038c2a241dfd2ae580cec3877cbd540993e6e29b1f032d4a4990d28e580b7128775e162a316b63c65afa99749d92173f3632a2d322526bc045d5dcea4c919c4b1413f4068cb68edb1e89dcbf3fd7285cbd19e1eddc2fc18bf3463730e6b2186fb5b04e9f72115952246ffd10680576ddc20b1d5f46cef7997718f4f4ff33859cba49bd6a6e43b7f4d7a31df174e2432fbafbbc304b3ff920fd14cfa8699e59b564b01c5eff96828fb4cd75d6240331d45b2689c99f507bfa74a75f52564646eb62ac19dc79806e0f1ead37b24c5daef3524ce243e2d22895cf3d06c11b846db38d0bdaf3f1bf9c967c55a6e22e8d62897c40fbd5463a38c48e7f61a0d0bfefa3080d23ee9fbe8167133fcb71cb909a29f74da1d1d64619e6446d95f42a9c0975a19c41a498762d637de9debe11a5ec47694d4f60b7cd3b8d02d95d00885ddb070312367307e4aea1ddb19b7d79ca8dbb4fb2eb6a98bf2edcbac2784616262310baad8a78a501ac59bb2ed7fb0c87a4e4cd72914c27eff2fb78d41385ad257d4a77028dd57694e3aa0ca06b9644b6c322e5661ab91cb15a39dc8e9332d912302fe86585c93e3dabcb7a070b5e96ea5d5fc78bc1bd705374cf5714ac8a6a316e2cc3e695b7fda0795799e66c79c88a3b5e49762f06d13e49606c1eee2170beaf2278bb88178688b52df7a17f4ec566fca50d3a5dba67e7fa541bb4f866e7321f31cfa664d5aebf509d2f504ee9cf1651ae605dde08f66f2108720003dd17808c52b98a62ff3f9f6e37ea063f149bb2fbd678aff3f557875da33b70a49bc0aa56ab5d790197e547c7e12ccdea04445a065c0737a1ffde79ab031be5099ff18ad90d7f659def93f5c4afe2183215bd9fda72d9544e7e4e2177a6b96191b440ff54c4ac3453b71629da58427fa0c14024426b7ab6fb8a83a3f4a9d4d5abf722bd9bca10b12ffaa517ef39f754d57b93b096412e7fd2a452d31b04a3ad98ac9e462bc9681e43c7169a2c1fba9aff20d924fcf3226c55577f4ab3e47363808d229056f5f3a69eb34db2364101d3ea762a5f8479eab652dcb93422faf2a28ba697b18bfdfdb1f0ca30376d6c168e910abe55743cfa04735d576e3251f655a5d9c2e0c3e215aa6ac72cacd96ae7fb167d9ba970b0ed3c951a34e1fc651997a1699e3281d2164920a7b8e870294c00984533df9725f8d92e57a9e98525a05469ff10acaf5b187be4c2921b622c7ada91fb4bcc82b820e7f485aa0da5034de8b97a3269bdc0796d444591de564db2f46f101d19f1751202bc58e92bfdccc15bd7cbbb854a57cf23f7f6231a6d6bd13310f4b477e2990aaa7b90d023c1e7a8aecb10859068af09d3e56adfbd09579c548ae644773c3e1e7deb7edc469c5d5bf6beddb81856529e5c86a0aacc07bb4c99fd5ba5e1efb7c367148a169c170542e2c868a8ec49799ad0e63127894c84661ac2a20ad83fe18ed2778a1c8a5034c597baae4dd5000ef12a3b5c63a243cc3c799959c8340aef96410b244d12690272d68d202fb9a601716776f82ae749bed01ac38d66ea3dbbe4e88af6931758d5c9ca5ce68e0b30189ca98a6aa5445490f5ed3b7c94955efab8b1699f613ca848f90bddbe683bc488116b88d852beda82d62ff8d46479fd59872561848897021860e22cbbe24f8f6892f2a9fc3238b8c11ce9f74d10c4265fddf0309cd72c21f09cc62726b6172100d2fd50abe0bed38314b87e1a5cddfe23ca38759351815de4eb812c7c7bd4a660a29ee969e010ade3b8243e3c4ff4224bf734f8fc2792dabe4eb0dbd66629d0650f7c115b2b0bf0f11913f7527f20e70fa7e45d6e44142858bd1869c2ea81dcc559e523e89091ca3bb8535deed32e41a3df23315b63bd3a6783ff302114e1e4e75c792966f4de3ad564957ec1d8d52f7f41110d470064c1244e1950d418d2e55634d7d73b27f648056f6b26833ba3aa505340d8ec022489c10a27bc6e2bd5be6754bab1a5cd2b14deafe5c28f845293489789160a0699c81d32ae36a753c54be600dca6c04fda52e49813b0661ee3b3b3c2db771bcdb77e76bcef380dc394b2fbee7c4aff76821b730bc8ca9b8def7edfd9ee6c0373389cae708c9b04473b449a774baced71a258fba42261bcc79bee46c0fe32167c587d8c2fd9985047ebb4457ee786ff545716c6c95956754a65c52172d0f12ab24cb7c8c53ca2967c3331a7dcf800b8982868ea12f40123eaff367bba4f28ba4b8c06854ece8180457565287f267800511a32a56266482015afbf82d072b13ef8820dad2007404f6687e8818fec4358e8ba6f6e1ad33182c201052db0473022f47cb0679ed3b6c59c348afcbb888a75ba2162e485fa455859caf805b9811a5f237e73e5c8ffa44c674d5c4cbbea1edc7beb76f48c47565be237e52ab804fcf26fd13255c4c7af325df91c10a722041ededb9d96f2d2253493518502ee1017ca7eeeb3f6fe9007d860d37c9d64655ba377ee16e9fd46b8233bfe14536bde4fc01b77738f62c07fa272639e132783adc065857a0b97a3ffdf9e544595921d06fc80b5ef1ae565bcb360961ece00ab1614ff961407421f1bc25154105e95d1581cae2462bbcc82538da7414a49979b2e5349c518f97b4678401c62f1df64812cb01101c32356d7c4a7e99f1e26f0db595ceb4d93fe14ef1931b34551974edb4bd528dff3add6b70b867dd57f33bb2ad76cdb4159a04738914548806549e06a6fd8c10c83cb93cb09c917e43a28a53bcc7136d06ce24df56dd80f794b22b63fac41679b976f034fac38e6483cc4e2b64bc1664bd756f6bf26cfac6e63bf453fb36991b94eceed07442f275b44b85e6aad32540d0e02a193bd38dca35890a32081597d0d0fcc11b44656a8cc016f2a4aa357626ef5907db8f034abf19fd37a234d2283200f13be5ef8cc79da2591fae19e00a98e222dcadea9d453e9b574aecf562be2ba060b63d9569b7243c7957d746d12458bedc1260227c45e0c95ec3176f79fa671f5f976866eee40580568717cf74555fd701dc4c4f81dcfd2c398d6866f143cd4232b223de8d2fef0fb5beea9ea134d7c2a8f6b39070b492042db5acf510a042b2eb9b4de0f35d018eba5ecdfcb240986cecf22c27f3bf30ca06fe2ff28c7310ae2037c390a96aebcda01b0f0507d72a1ac78c4cf996b824878ea4d3ac883be0aa5150ffd5830199f57540b1039dce7db8d723bfab97c35b2890918f3ceca39f4e4080cf9be5b20483e300062f56a608d389a7b357e023a4bc3e3a25545edfa8074a139e0da6828d65163cd21e8fd3619988ac34000fbad58c83fa97966b04f9a3dd4055928ff2d39156db322d4c226b517a57bfb390e8adfb539c7f06f191fcd887f742b0cfcb841c47ccbbdc4bd0507023fa23bcad2de4ee46eb2f924ed9ea9125de4b77fff355da0fac8ab7d18b30c97860327cfd374c9e26d74918aebd706446e8b1a973861bb68e59ba3e6d967b5addcbc197e6e69ec40d47846fbdb9409ce3c83c70485adb261410de100460732dd9d0ee10517ae9fbb581f9252a4a79838d894584218ee5619e1e18d925f3f30936dbbcde99e8940a35ebf7c7d2b416390d363e732590c8a37498b2afec3fb249cebed46297317b83d05748de4db35b203d1ead083d2380536980bd912022f1d8261c80c1783826312c90f3f133fbafe7b59c8684bd696b60060b35eb2f45d04a6c4abcc35781be4008f9bc628dbb28fb189543c2b002db9ae063dd7a955c574d81f90531950b6c219cfa178c7c1031208b1132c7a20503549c2360fd62442cee126981c3967d226589fc3f09df031b92e81696825d306ec4ba369441abfc3e1ce083cadea306894c437e2bd9f3d3c89671a8b39d076c14230a5fadb30bb31fc0ee03d31fa904cb453d40fc2403785a24cf32a93f60124d5749f800031d65dd7a62325372beff5f014cd97790ef5bef7305d90c1e7edba628c6eb08df308d059a12f09247dc260c27ff485dba366fab5dbe502c597925ba7696233440e7a0b6279188ea64b1e0a1bbc0386061abc19e1e98b730c2ecf4560ae95c3d0d2e7c308709d963d0b77a01e1eeeb9675dd8b0eac630474e910b521762f40d34f7f9815f1656191420730f352cbe1333872c556fa1e8869d8855f5863b4c325b22d9a3f8bbcd97e3c6f62f80446feac157889d5d96fbac0a936c44b60c48efe3cf0bffa5e369d9eeb7c19a65f5030c9d0b868f8d4b2c16a4833d173e64c99719fd399fc8227b6b05551b380cda065b21b9498e2c5a4b1d3508a466bd7e7e70ddd8e57e000e0f2e10aa9e6f63508f6386897453332a8b3176858262c79faed35798481d27f38f54926f0fde04d719ec0e070bae5053dcf4d07748eb62c4d32b0dbb7de39eeecefc4a9b728f899bd2a3dabbde23fa77f138ae3accd3c471055f321b34ce45f47c3939b8efdb656251f99fc8331f6a6b4a728ed0cdc21711f34483efab11f7c5623bd5015a1dda47e6e97d4dd4fcdda7ceaeefc6eab5fa015e62b1dab12c7579ab6a4a7423487393c4b0f96133f56ddaa36a13761e12507fef408955dd86736fd9e803e9c329f3e3b05d46097d272d9bf3960b3e23e388dd982c0b881ddacc02d3c7540aaa7d260a1bca499c86dc8f42b7bcf63427611397cee21a83d830d2d70fa9434d08750a693ac896f8eae73ff121daf1a5ed89a6e8ea37a6eafb00ca922a313e6d9aa432d3c53a4ad24222b3e31d26602b116b2a595ec2b60ef8850b99f9abe5f2bcf36c4d58e9eb71f285432610ba90d0a7b469dc492555ceed4ef5be86958d6c8e8c5cb0ba3c918d841908ef7315fae039c48278196d8f8cdf931a7c3f503e250588093e2c186e29c3b6c05e3e201f7e93280377e4fd82608e035f23b8e4c477ccdfee82d07dbd79d9b51557bd7a9f47c83c2d7f589abd48ac6f7f48313f8517c241cf6f3214d3c8e9c5258fded5c5a0f2e2228ff221747efd89725c376fc790fc01b1ffff07fb55e83c4cc2329b3462bf01a2df6c59d50b9e5f116fef43b4398f046fe879b9bb124e6cd0348144faf96d542170022758c0657ea84c01b18cc4ba812b179b468853e91072dcefe3539bd4d5b6135e85546b04733e77cb21d27866e269fa69b51ade4eef29c1e628a9bd93108bc9df83441f50b462955dfc18fd882bb2d708ebcf4c2c8cfb2b8868680fe3c2817dacbeac462d01c2226b59f01ec6ace91d58eeb1e7589f56b9d70d995f4598d38b0cab90e90271322d7c2495ebdd6c10a45a61dfa6cb65953661440a65b42738bf4719edda3f9990dbce8e4739c79a4be7fe4945ce07e65c3fca5a69b71e98042819809f0dd7b20ed761fa89903589df87680f0b2ff782920a44b4fa3d32506a1eeaddecc58ca9b8bf3fa11d6d29bdcb3f8fcb271441bab9681961633550036aee46a1fb617cda769f12f021e7d32c207e8999dbef12d39223853a8e774950ff86148e84c4864d5ac83e34c8c30998dcdd4616cae6d420197eee20cc865628097f00293fbf24bad6e3af3c99cb509b6a860bbd06f8e027dca5ab59c9b3e3fb719dfdadb212bf2712d7641236c8e2feb4643069b67f2e8ee9c236f3f845a722979f7df60f38d62fdc278a4f0acc80b40fa9976e0a17cd214dca785308147dde4ddb1762486bbde810800a5815354a84e54728e1d3531cd630d7984daee25ab6cf3607eafcbe1d52ad86425bbb3bb6a4788cd62766defc57b1e150117c3494b230239439353d73b00922f324c898050d69a0c990fd5ea99cd204690b342e8750b2fef07334156b16c9b3119d894d12c5c3a1595a722aa4d7d3127a1d0b43608e3b9048a3579f655e1375a077d00626b11bf83f2313461ee6d8889839ed6c72ee9b97b008362f7bd8d97ac561376119eb25539a83c08f1c8d9ffe88f6b57db94c06b476977a1df1ac25e88893bc73ba297fc1ccfd32946a640512a8e0bed939b11e3f266c3284087d05a6e35dbcc18ac427c7172ce8e7a20aab0e4b8a632a25a1bcea038801ee90accca57cd2cd14edd0de0e4c33e958203696350b8e840e9cd86589e8f35e9db5aa424d8f027302c92cee91d1fabca6c813438f857b26a4f90da8b3c0c792b396c5ad6979831c2ba94c0ff60182fc675d22f65226ac035cc64073baa14e39db7767f93957be6109cd326d1b919fa5300a1b68e1f177efae4e9d6c9138f85f34be72063729991c32730cd78f88bf6e664125e36a7cf2cd87798dfca90bd7e3a9e3ea296b2fd2fd87aa4e9e938c92ab1a741a348d5842e1245306720d55a492753c914196bf7c2143e9e7b1d1d3b90f6df4a0c923537342e31fbe79feca44d5e53bebca700cd0bea13970f41ed411c5b7296b834884e4b3ecab4db888c3f18d9bb38358ddb5c777a68b4d6bbcee9b0577df1c9110ddfc1bc413e8f61f50a5271f8177406a62fe0143fcf86cd007578530f0736b38f9d20fc8121f374ca101adf427f21dbab1802068476add1922e650fed765bc7eaeb7f66efc7d5d5587559600cc9ff1d3b4e350ec81b30a73f3ce10b38aa82434a761dba8f394baf7ed914c42626c3ebba744899f205616b1e327cde73a56db6d660b08c114b4a01feec83b4df68e11f0bc1b5e9fe6b915edda95acb48e35615037a893cfcef735c136325de143f899aa76a6332dba054b0823896777790064bb294b4bfe79b7fd77513d86fbe502e6a7ac8bdfba82ad1a5c17bbcbfd1e9a5ce6c445c261a27c9a0af768edaf3aaf9daf535b5585435e23d19d8632667d1ea0b7802186d0a371151850f6f368e8a07edada8cb81127e11b834fe2a43e6c875349f5578d2b3012ee3e8874178b2fb7bd6a074e16ac2435c7e1a066b0ea8c35142300f89fbb9a3bb7c1e9f8ca77f3fba85307cdb8e9a372214b0e07e8667b1f04eaa4cb0145214b524eef31665faa7ce5c1732015d5d80c543108dd85f91a97d6f6e5bb00169d01480c2bbb424799e80770017b641c0c226281c3d50ea375c54e02586380bcf0b6a6ff2598b6302b8d234d51bab889bdbbd4d3edab6b4cf8c955293e7f6e930f9d0f0f276b3d6dd80c196c33797998278554c3c6d9ce7f11b428ea8fed6fa727f395e1d6e680742f3dbd18c556c0740c5a325d5fe6d16266600d7baffa4dcbb4f8e0b342b6ebacc0e12eca6a0e5887b5c0e8df581890d6538c8c2872e973ba4da0df1d20df5f640d937aa7dd7537b765d54eeea36d52ba22463bf798a49243ef239d251000785f261a19591422e37f02d552dc355186c4ae559e4530444b4c6283d93e172f1d3a98e15716e9d362f014cee4bdba2e398cc66e3dcc15ed3ae7361603d5121c71a908b58514b0231edeb82d366e36974c623566678ce31b1774029554a3274fe8cd2e5855284db11a0faf5d31d99a8985fad12ff4485a20aa2268404d3748e9b2aec2ad1c66a58f07f4f9b3c89eba27e72041f2cc895223554b4d4f7afdea94d837857a23a4c145d8eebc396bc6e1b4fd2da364e658747f7c13d8ca340e2d18bfef8968c1f12c42f3d6abd8a2b355d1c084c2f3bf63f054cba3ae36bea1dcc2d094a0fb75d9a760c2b8bdf0c5905016001e9fe7b71126bb0dc75c2e8f453bc78e6ed9ce2f6eea8256c9138423dd2655c56cbd05896b5507dcd8fa069c733ec8d3b8580293903a6e137b09eec1b20242d19f149c54bd9df658e26900cbd0e60f732c464409004af54143463d6800afdfe726a1ca6b6842331d8e8503660f13fac0d807a61acad1a81caec5b496e98982cde9334393069ef43228a5da05b509d8ba89f58ffdc04777f06d99de3f92ec6851b8e92a762fd5f15bc1c65a84971b39a9aa54b0eaf93a0e120eeb1bfa90b1d1ed73b27481d29ee3b6c24a9087d9bb0bdeee81d2f77848aa8aa94e37b3cd18bf51bbc2312f8becb96d8088b4ab8f83cc60cb1ae198c3f86b61a3a79a798037ed720d030576fa0216c6a644fedc4654f368bf00a8eb124facbc2253ab606d12b4b04e31362c070e891c9bc5b9f675754e711914e8b41340971e5cf19b5f4e741c787efd0ea2fd15c9425ea61c5af8305de89d85c0acff28b32f1c45a43b31878e05653c2bd307e85853cecebccb19ff82aea3e3224e7560a9afdf9cf466690effd585caad7ad873bf2b6b52cbd0fb86d2ec1c16d582ddb81260dd9c9298257eb30c4ce005c32bf87f230aa2a33c3138768c31c5bf2b46d416e93642545afbbf2e89a7b0bd0e75808c4f4b189cea0cd746bfe62d42bf8c48da2fd41b9fb6b8c4b4c22f41048047eaa8fbcc6c00c4e0374f16bb20ef640fb105f61305f1966cfaaccc4a8fa126cd550a9f31355064b2df6eca0d8464590dfec6b2e3b20cfeab5a8a142bdd8924884a042f35af2694cca5056fda0a04f0e72f51a2e97c8901c0610a0eed81e56d01c6fdcfc8c2ecfa7f8f63dc0940a3086a5fd39b1b095c9d5d4a6b9097cc83c7e73aa18d353a0b39ecf085bb9e220b505c73d3aedc6820b9d3d9c7318afe19fbf95cfa2a60d2cfbc335bde371d7613a104f2e14519ad50bdca6a2a60df84c1016a02ee3d4d197c689dc1ff15b54fa94f11d092e88fbd25f8b0cdddeaf1fb00f1f9ba47c3f2f910fed1a5e31d73fd11cade44ed9bf0fb9a93b6328308e6aec6d3f0d39fe588dc463e0d0fb5401214c6a136873b1934c6320d5d3c41073eb32c9f84b7745055f8f9332194947f8075df7726c0ac79d10d4812b611a297ac5813b87c29402df5be48c54c8fa8220a8355b285e6ec00c03d342919c44791df61f3e430aa68e5bf4a37e605cdccf5ba8f8a3d235686ed57937304d259f5f2c7d3430db8e12e0cd1c504e2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
