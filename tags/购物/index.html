<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"414532f1fb0e28edc5d2aed31f18ecf6d1837d27199ec85d040c5f79f91ef677ddb2faa996c313dce881981fae08a1ad938701a70a4cb48dc15d753046db4d1fb4782d1a829c3f71d395b63323afa1fc5289f4c3fb449211419e8e3896df1af3589963dbf2f3fa57441ddc18aefe4ece9120982d34ebeb27bb917c9684025e1b9aeaae957cc51dadd7f0ab9d2de1ae837486f5c4448f6b7a90718d91c261c83d47a08387764033236b3ee8588ef592f285df44173574315a1a05676667e510e90792061388b4d63eb4e44abcb3e84a80289d9b8154c515cdfff9a642270fe9d0b0f2d0c709614df5e42cb41cbb240c48d0daf308d304c68c28ee947bcde97ebecded1ce335737ec10c4c0d6e589a43ef80aa74701c813064edcdf8948f8ca870238f6d1e68cd84feaa8108560e1825036b96a88be3db358a527af88bf5ab57047e24a5df03840e019823927cfc6bbb9d70561d746dcf363f18b97f1bbacd51c18b4650b13229de7ff78277604e26d59ec32317520365bcb46719f40b8ae46fe98d9b78d15fb81ed251c9b476ef22a9ace31958a88063bebe7003dbac8428b1105661e8eafa872d33a99ebd99573383786c9c9973692c61136656baa2a226520be4f3cf3d306c0fed51a4abf9245dc1312f7c7fd3da055ff083a3aa694ce4543cafa8c2f7ede9e4a9050e173855c04b6bcf6236d10f2671d78e77d827f13c1fb57f662af4b8b6cf9f07ef563efcc1c06790f572b867697fafbc8720fca1fe56f56464410f28cad5d9504732aae01a7043f4a86f6c7a9cb68e272be55f9f25fada4f630f8f09bbaf6dc9d5bedd7bdb6eca839886db21e1a6bdae6a765d635a2b7f556d34713842779182f882890fd323cb856b7dcab3d04a2b197ed799af4481680f3481b397d0b568817693703edbdeb13b4415adf8d3e92a2cf0de70bafce1d436cc60381afdb6431b53d7ac0adc767e3449fb6b7e3affe27011694bd7e9cf7c26e555c1e51c7d39e90ac53ee8ed3e5086eada14dff18bfcb235357c6b7577ff9859602851b015f10ffd75779204c95dba51a61f437c6055e010527e632cdec8262c2545ea3095a26211671c455473437029fe67c3395f3e1f93839cc84ddd017381f742c6934f157d1f86dc1144453740926b15fb65fe15bc12a1ef236f308486b1557f0575812071a539f898534899894db7cd5874f8ade1071173de55c0c259b2288202abf929bbdb4f0645cb86a887d6c28fb809e5333d7dc6515733ab7b8de3f1a6e9f5b073dabe465f4644b913178cea7c1489a44a21d7afaf0153c8af7ee85b7ffa8ec8d435866bad230e7347d2b12c1ac3bd3f94c4705ae4000729b7df1d31ed2c992fad71c5db7e9f63090d73ac541cd39265d318ab62d61cb0b669109fd8811099c3e539c3d62725fe00c88185ace3b7a4986b4f1bca4fc79d22785860cc4982cebdd00632cf4ff189570b977b695f9080b3affe1509f792202a33e0546415c526692056a2a764dda55c4a0cb637d61a92a276709273e07068bcae499de0092dcf1f0ab69921f0ddf9146ae98cd74de5f3b0a2064d2f8a43515ea72d6f85b9c7fa8ceb0b9e6fd096651d6d8752ca211f693c500bbf2978950bff5f16bd153bdb62641eabe4013361a10e0e209cad5e618a3e15de67f4f20238bc0ddcdcdcc137c7da8ceea987650fbe71aaac026c41eeb8852a73ff9587f51ec78750e7910970746f722fb687c647843523b0b547c894c535e4caacf2bfd5ae7fc0c01479bee861720488a56545f242119cbde5498f54e536095eb192b34f973424d7b09e1bbe404f4d92f2ea5e580cbe1cdfd70e8154fcdff3601a4fe8848a980522e1fb1e5b6db3cac85a8132285e86d275532000edd98e2116d41bc80ad207d45feac15db383039ab7e01af26a976198c7ef33bbd4e946f04122cdc08959e97d2b0989f145b135dd7ffbfa1da04887d250e7c851bdeba19ad17c5ffae2d32fc503f58cdab17ca02a70d30258435706f5b96c20d48ee1f7997feb28ff182b25c3dc478d5ff670e87085fdd56602ce53f53b8a38957d002cd4ae40138854c8245a42dc90552750660bf7dc57bb2bf76a7e55b421ec7b39f1c2e029a07f508ced97d411ceab602b60dcb2aca71fcf9723f97002b7e9e9fc0c4922053c10da25a456c3e7cb1adde301421e759263c1f048156eb7bd800df4ad2927081b01d715387adab9f0174d811acba6625cd7df95d6925500738ad771dc5376190b92b0981181a73f7f4bc7b514998b0015825dcdb2da0a3206b020c59ba8038e1817a5979bfde9636fa467aa7b32b0caece4db49b7b0d687f98b0b277e37aaceb39f7ae86b3186e905e504f5de12d3a7cc84360928b08e47f21a9a1558809c95f4bb7f58b0c7b7fa93993207836570a5e21ea63675a017d3a641ad6245ad94982155bd6c1a767bc54639d8f124d9dd5b698a9b09b57055661905a89d3117ed87aebe903a29791d0964c068d330b21c8552019e1990af75cbc56a8fbc45fd37c71f86bf0db4a85918fcf9c93916f0e2f77ab6c12490d60d332542f24b9f3ec2cf126ce0b511651d1af7111a21e272c208ce1c384e4385956807bd0848b82cf3ab90026e3358c65696d41649247e845c3b67a34dc1dbd71a3d4cf2e5ec28b3da05fd0fc609e3950d45c6e9351e4128178df3751fda88f24b290783d5f068aec524e79105953e2af54964e0a272fb941f15cd9db16420d1c3413d9250554ba1663173d717ee842f6876752760410e7155f3030dab0d18fcf97da26a620e8e7f718f1cdc1f587e73ccc73e1105296b9c7e28fdf256343cb7f636ec3a0b629c55e3490d3ece4911781afd137873b3054bc3417e8ef44bf8afafeb81fe182c890fff773da034b0980bfcb371211a3651ec406584f6144c662fb41bf95e4d07b92541aaf86f2076dac5f7cdb5e89523b9992c35e7be55473dfa2ed23b544d8dca14ce7b93ac0e886bcde0ca3ba44ec6e43e7ff370d46ded5d980e2e7d81b951049798936cf15fbb175a7a136a84d15aa6e6cfb732cc01d9ceaa5629d77d9bb17428eac897cdb034478011d44473d0c361571daa384db5a6d5b51d466cd940a3c1367917c8c851af3125cc1f53d0effe774aa87ec890ed13cd4a1ce8b8903b91d733b0aa008e2c6ec911676851e0d0e0967311a0dcb0c86836510723a0ee1e19fbbb88d448fb559068782751ba5d242dc717b44e6528a8f119b236163f1fdc844d27fa06de7bd479d584f4fce99fb16a561e9a8e938ec2242a0206a2ccf5fdff678dbd6e5960d9798ab43c3e1698ca7e24b103cbb0a2b5aa7478cc007050d11353f70b9d5703bf312fddb58f1ac4fd9e35013bb00c869f3cf4763bb939cebcad77d8b8377ee6526b811383ddeb11acf1332d64f48033fd10145f6248a9272dbe5948f6853974b8bc6b4cff57cb8f8b2de51e48789e2ddd8b9e5e8042e1aaa77f7e97d46242913330b91df2107e8d30673ebb8b1880c658d27a165c1c9462e931e91a01cbd53d714e8ace6a9d37613dc1fb7170b433076fcb529806ae33f841af73dc9c1192f200b1209efa4e7c1f2cda6ec605a2c48360a150da686116d138654a05f839c257d781896d83bb96fb3bbe96e3d3fb4fe1a5a45e2babaf53df4e6d5faec2d79903f47208b26471aa27dcf90387e90317c38c9fee2ada8f80362648ac0fd2e4727e5a442c62629dfedde28636c5647f0cc9b37208209ca57b51a4d2862cd3144e6a3471d91b801ccdd249f85d44c99944f7ed71d5569b610e4afc8a27018d17d20e278b7ba2b5df47d722eaaea409ad90941915effa260484989bec0635f9855323eb3dc00d6b03d55e36f612304c4916501c4fd0bbcf36140d29ae6cc47e614aa85bedc48e2bc27755f85425d9825d4bee22d2fddc7ae69db5cf7e78c2feeb401cadf53f27b0a09d586afc35f88bad871c529a78f872a1d0d0b0da537ebae09a8bbcee13d0361f0cf07eaa27f58a94f4278fc56d13bf804392e4b88076d0761dce6ccd9699447e9730f75821adcbff8696bcfaafad1c817843d60bdf47de1e4def5bf4a0f7ff5d482664335abbf7cd8a37162da8bdf651f04095a7282897cac337cafb6d7ca323c2c1fc47044ae7f8cdd657bdeaa1c9daaa9e76f4831f22dfb2c566b7e087daa155e86882d0d8ece23ec8e45450ec140bd8d5c4f9f6b0bbb39f88370931c45066c65af8516c92057d8e86d11a008faf014f3d94d61df81307a6435ae0fed8611b70a8a502e55de7b52b5d9c6371abbf517a037c94473531c5a7a9adf7dce49e12a9eeeec9b31c3bfaf8e91b564f6cef679f4efd3847f066b04c794e0ef091285d4b276d77b42646a6de8fb72029973f04d3c5c5815fc5dbaad2b311b97d0713f780dedbfd4e7668657601c20d5fea775df84e3f9fea316ea7beb3eea94e6323807e8c226e60aff13ac154337f7c66fd7273423f0fc0b70c2139feda41b254f57dfa3c0161cc5b807cae888d868afe28e09528b9719d2b21017b8a5c9eb2eb9bb96a3b9b11f7634600e8ea1a54c7c603d94e6a6ff396d6b1de51422b900cc3bf128a3a0308489c834bd91ea1f003777e6d69e553bb021c3bc1a8576e1c21804af2e6ed5fbcba1513dbee4d4f9f1f6b31e8657316e1916bedd6217fae30f4f797e50aaed66cc53c81c84c4911d0db9bc06e5e694bb6ef8f99334addaedcc9fb2db17e6bde6ac55a60f5929af2c32e4b581b3a248f6a49c902ac26aece2d237b1ea4036e628322ff7382ca6f5d2e7ed536771153cb4ebc0a517a43dd6c6b6e3b8b360f3a88984214c49e0f524096f03fb1dfc9033ea95f616af9cb99a193d0bc463b00ee5bb58b584d909ce433233b86241f24ad3f710a60e1bf70f5a7392b1a3510c9d774d418d41d200ffde33880e775b2e5618b1eb341a3112c2f0e32d27907326bface8e8ee79f2d251b2dc554fdbdbe8083366f03873222ee7d9488e1634841cbd59bf7e3992e00cc5fdbb97d814de76cbd3ee7244e1ea7e5fadc22089296bba54885e0037539041989e30767d72a537c1d1972069af87d397175bd43d2cba23810edd5d5c871c891c472646f56f04dbe40f8b5b94f492ff3dceb8655bc156c8248cacfca8afb9814faa98ec617b14c119adcbf9a1e2ddd68dd7944b704360bbc9d1bd338efb9ece557e821c0552f105481902e6ff027e071725d58f4bfc7220892c5e35dc610b1db19e5ef6a5162358deecb5c569d7356a034ee81aca1e4a30c095f0ed2eb65da72dd08980ebbc473d302bcd933af90ba679cec3a69b99f7a9f79888111341380875a483dcf03cccf57e8e2bf76c80d33289aff8c21d325169aa78f886f4c0b749648bbeda34287ec2e9f2acfea05380457e6542399e2ca3c407190fe70914b84f8362b47249ce7c9a4889adacdd6a173c3ced2ed1bfd023fb34c4f3be1fcce20ec94c980e3fb3a870c7281c952ef4d756dca980aa44f498cafabf9c23b15ff801c769ca3fc08e672d5162de8c6f652585548ec474e334f5a23c7f2f925ae9108e113735dfca389802c47f70f85b0931d3dc5bcfa532a5e05ff5aea061074e58a75164b862e7f9acc80bdaa9a8f9908e3f4384e4e61d97468f51691b32d6ef70cc3fc354b4f937db55971d00751edd6f50b2c581814285e3eef15a4c2ffbcc28b2b7070b08032dcac7364462bf8456b1a06820acfb2ee0436bf2e57feba57323c8865cabfe25a8ed0190b717b034199390655245516a01535f76202530ca59ca9b475ae7526d5bab11c9e3561a3cae1e5fa2ab277100c2596abf6c064358fd2006725ed4f45417a09ef969384191e2724c0aec820e70e343a40a1914557ed57dd32f9fe5a4d030df41f3e216433fecf327cfa0a469e24fc19808d65091ae9e2ebef988109bf2449e1312772eac3af384a62b5f10225db629cc4a85ca00d76e0133b0f7aa19ec24c2e1a477018dd6cd3ec0e693014e2954b94b6b8b5a7a7e2dcc609ad03a7c85a9949ea1c62352913f93339301f863c97faba614168837ed1ab0d1d8f538423a171651e8263a60813a566938dc249318069fd6bbafdd53d0e8bb11c39d83e4fa5cc56c9a57649e13ac5fe16acdbc25bf2b7a5463711485443024373cbadeee76578fda6b7bd47027b3aa0f0ddad60ef57dfe7fe0bfa9d64d4afd9f3996b7d0db38259374d922667b20243613e081de8a053336f08ed768ca63adc577c2b9b74fd4c49033a85991120473a6d50d1387a1f96296eb121b11655ab069abb257b19dc8ab12883db23c318f6873081f257fb9d661a54c451d4fae85b540657eda49e9080679b538f2422a7d675510a49ddbf4202a317c593d365131eae48ccd9dbc1a6b533d501d4c0bf52762cdd467c1ddd3fe144e6e4bf3c463b7be35019c830db1d9a503029dd1e3350ee2733729b6a0776b15403e5df9f915f71b74ea6b206f258fa2505a8f942d7f96b2afae1c11e47b2bc7998741f36f703a0cc58531f9a5504f719f7c59e8eea07078dba4bef2656dd354853fa9c6e134caf1b253a13f535ca647f685431480aab40221ee40e44c2160fba84e5a672538e9fefc89e8cf920a702f69dc4ad5ba0e2a0a883f7a6bb7da724eb562dc7a8608fc7233b405be283c8ba3fe292a5b6709e21564a0be4c32fda0e78014d0a4fe37d3fd5602798b0feb846003834a5b20bb5df4f7fe54d4b69c5c8b2eea62b944cc536124e38ce1cb4cde6ec3f2154ab1d82b8f1934dcd783ab588807c53e103c101869eef8d90655e1d96b0386467b8f817af6014b3635801051788e1dffc0516c7510779d5146a39c7f285cb4bcb903d53523e590e233763cb0e245df5cb5b1448a13062d1e5ca965c7eaa4a59753f1f12dca05610c66431e48282e050e225d9d1844f4783769fa82fd5bb9cedd024b4e2329b8006d7e6553c8365e68b01ea6bcc509d252918f22dd38b7223da1b92efd42e598727745037eb3b9b576eee1b047ddb0cc7d3905b3c36bbaf620c3d7d48d478921108288510807a4dc79e66c5e3d204264799d3d8c181ab7ebdf0a4f4fd1d485a4dbaa9a232648191d949cd66732c1ff62eca1f1742978d4d521993df97b2cdaa3c401c65f707017e1adaaf72b3df4a008b7fedabcd14dbf07ce43d03e33e4d14c46b2d0aa758605bf588018db96e3b962823c0eef5d9f2580a4d9c8b5569258a0db02f4aadf1f8e824b29d9dfbd82b2767f2b643038b758e302ff0f92bd9ccbccfd2a4da6e10c19f9ec96d32d425e42f574ae6a1f0d478ceeaa25d04fb2dc0afa71b8dce5e2c243b95151f5a3830ca08e40755a6dc7060121a3b2a4b82a637df63262081c1b0de5177833118531498216e4d45089d6a18cc6a69a1fd9131512fd4af001c78b12b9e099aaef39e757de58414ecf18742bd707aae810778b27fb8fdfef75e67c51aa2808c2af6bd9a8847b22df1260f34df2db667fad390de1e31bc25598ae69797c6f02358c0f0353510302d696cedc97d8dae059c90cc0215695f721a5718dda9ff8b6da0d536b12f0ce5086c578e51c953ea1fd0eeda02d7af9d12f206163a60fc6c88770ef55afca96c079d87f6634f17b62ca48a4caea021532b79c14afbce80bac907d946743b60afa71f6d24ba37aef7935cb76931c79b670f3204daaf18ebeb22bf919a7ca0d1cf9ca411e59e44b026d457e9e7f4904ffc5ef9fbb515e04c1dfeaecf535acbcfea24b1c59aa76fa5b996df15c3dbfe7596c94462e0f48cafdd575ef357fe0a5bd94773ebbf304870e241d47e5a3d6a5767e2d27152a8c7d00e321b4d0cf82315eda7c5a641e8310078c11f5e6cb9fa324a7640baf8de1106138e83c31a391f90ec25e4795b2ad3d1180ce32d2178ab068fe2f952159c253a46c9c53dc2dc4fd1fbc87c163966c2e805662552fc5b0b394746a7839138f52e82f226138006c07d22a1e0ddf24c8a501c02a4d10255d8a720244b6b198d478bcbfb6cbffad6f1a5fd5857a58443b6f59240db013ad95233c6e50c3c6aae50fca9be66b305a9903b9b88e8165c20ca6df463a37e7bd7effddff7c7e97512c97d37be5777e173a058e8fbef2973d9f6518a9b601e32fade1419731b6916b418d0db856f69666fd9cc8d55650ddee4c9ddafdf92aa771abd0745fe9bec31d27aa269a1f2d86389e6a197f3e32da2eb00004977873797eec4babc38e01c57a4b6d6a6dc76ab81a3bafe1e7b1e780a3d73247d3d764a3335634e926fa266652474e4351327ae51da15f3fbfa42e262c7c7faf69d69e2d61749781a3b995f6059de31bd0d79a6631994e92ee1dab7f95d381e1544a332fb7c81a034538becd51cc2c9ae166a9d47834d8d0a56a1d3f982c5bba618d73fcdf0f25c3d2a796961376e50aad804744d78a57fae352ef344d823a84183d5e7f683c203a9adddbe3a22f80a53f92e6345a7088e16ccbbc1e3359831bce33ab74dc381f40641c10e1759e5fe7c9fa6ce3e28b5211f0171b22497def23ef56f1a9e28adbbc498bbde9868b5a1b5305ed07379c284bc411e1f3c6c9a576e73a5ec6ff09fa63631ed5454f03236d4f5b6f5e98be2f7b305c78aed152d5ca5fa4c74fda1db9efbe64e34768419b332c6bece46d80e29ab9741b93032809fe6742908b9478bda59820797055e86e48f817449a89e6ecb7ced37dcbdf1d19a6393fa38fe43613d09c444e449b982f3f57929271f9eba5d5d067e4cbcaa2b703692d02275f05b58c4d2a58e9c8bb0b0c6478e6c4fd1f4a8f22bf50d1a6007faf6fe2209393e22698625e79427edaa9f561a925d528b996c9944adbb7b56a23b5dc9187b4db0cdac3ea2e656425005c9ee8c3dc9be74b06ebd0aa0e54f129a6dd827c5721dc42072e0085adb8ccf1daf3974fec97881196792d074f3c1090f2e43782969bc312d63a0af735d802f2c47cd2e9c0a762c063c0fbdaac7a1a3fe5f3f9e043f3ff98711c0cfb666821ad77d62fa95ce6e7148f104c73c7c6a01b5911188719ba12ecb08bb19ed1f2807f1974b6258094622b9592740c0e48a03d50370b8950e0f1f6a3c524117d87707225d2e03b00c832f2ff8e733a26bef03384e83dcd1fa2493b1ac6abafd2f6ba148f2e55220b9c351ae47a6265709de044e7b75a9442001b8948e5f4e474803a8ba06006d7b2dca7df6fc74e704e74c5aa13d32c1479b05746f5df14b3837c61501939760b2378133c3da1db6ee9292408a5eb752fb84af81adaa190f894b0ad574752d9ca227e24621d29a14b7d7f1de8987a6fd82787c5292f70600e36b2df24f45e4daeae6c0e04b9bc77c71b85c880088346fddcfd0ef5bb9681b54f4d209b1112066fdb7b568a188acafe7a0f3892e41aeb2af60c3c603810da963bd7fb82c624f141e8e5085da53b3d5d4880270f994dea39dcb588176b673cbf6d29dce6c9cab9d62c0f17bd007578755c47dff8f4e888589c7150f3cb1528c220fe51b3a5407ba889ed0524fdb51fd5a9907c3fcb2ae258ace9d7f5f9d2b636d9c6c4daed422c85aff94b8a4bd4eaa21172cf80b3b4b9998127e5c2c3e1853b7db05164431e67314971a9cf243c910910074a7b4ff3dd8664fe3acaded464beb8967183746b92653fec586edc721e2d79ae05be06a5a707fd9dcffb188fc222f92054e5ce40157aae7cea4a3723b66a74614c422ec48770faa893da257e547f483f3674974c025157d725fc812d04be6e32ad539ff14945a250e51f1b170c3ed1407351750d9e1cbcc32a5b20247872929c78d5cefcba1a242f0bbff620d1a57ca1ea5cb1f5165f382b711b182207b03b8587bce583d07c2ab2a9d81222590bf0cf86395269c6f124eb7fdc08d6ea8fdd49bb5c0716e73b43c36acf8cb6aeaff4612c994430e81fa3afae3ea840084eeddd3105c4a9be7b46106c9e1ca3d0e3b756fdb9be4c4ee655930473b9e3fbbbe5d8a63a7dac1c0d5abe7dd4f17ca84ef5617436b02ce00b830bf27051b7fa576e887de42a875f6148e23545412114fbeb96b34f7da79e6ee3ce721a2fb29cae1d440a7700406a94bcfd995dc219fdf33d63a0ee7a5519787c3c6929d26f6ecc894c118bbaff0640411ed1d3bbd41c6b902b81614a13bb18dbc28595f9316cae087ab407218c2a6595a527c3e24bdc733a6a204ac94e51b06cdc862dca4005e2ec78b181bb5c1f2c6799b4312015db4405cb374e6f9056cd89062c1e1b85723017c01b8cd54da81e5e6165351c5f6bc79f5c6de3682ed5a551c5d2278d5e8aa62ea9c3ffc265833f9912c00e99b29b38a57a5e865a644552553f668abebe364f9d687e8b6783786155c28ee361109d38b84982037682e825830d06231b658e750b18580526756d0edc46310e3db915ab447cb597f0c6210da5006c8131f92a6ffbdabf194f728bc66a9e299b9d2d9d7ef5561687de0163a38152a4d0b240fbb18dda990201ca15eff4461b0ce8c8a845f2bd625623b5c2230e723a20869e74b5548d031704b0357982fe5eba2b90ef6738e7ce40e1271c192a9e7b47745a108ad5f2e978990e17d2d3ed5aaf920ee0f03bfbca0c5addfa56684a19890e25ac4fcda5f56c9d05029fc6b1f8004c1ab0172d0a1030a1a0b00c7c60983bc93e8f49a96d321d7207641f6906541efbaee096d19ba2cb9fb272e38c10627aebcd7a5f75acd072a2a716ee1a00d130c4ebb4be6e0bc87126ed9cf37815713768aea0e3daa6df9796e3229129cd9237dce5deb56f2ff1a86c9e7a75c5c96bae6d0fe56f75f4ea545975d16446a7ee307682523665197f4781da13db3aafe2723f1244c38acf38182d1945670abcafaa4d0a03ab7082fd869a02e963758c266a578d5f3a2822d7b0a34a51c58f0383c9b49286074174b60fb8b696fa6b209e74914e5675ec29c8c3daf35c5bcce654c71020ffc634b0b1bd69e8d6bbe6d541e7edb1bacc41eb55e2da4865d64c38510d452a3dde061c1b7b4e06b6233ad3aae61738ab4242aeffef76f61f3bd09b4b65d0800fe3cf5bbec63f6adda53f93acb1329260658320a18cc6dba52485de149c98d974899bba3b70cb8b37c58a184de45951d1f746d57bf21b05eab729231c7e78315471314c998b0e40d9b4669e298db39b578c3576c56e38a5cfccd5da8257f827c89f3ac626fd20e483019674b89ab3f178bff7d0af3ceed65f4cd3332c34e0e952aaf91375d683af3bb305d5bff9fb5cb7ce18c5ceb0c696fce1e2824ee03453df3fd8ca968f3e03ba15252ffc955cbeb42640b5cf1b34754518e7e65d44ab3eb8f010654939183a661cf49337df3e1a46588b9e670ba6c49b51e3e8f5bedc0b2c987b799f97b783a60e9984c2814c49db058887906f4cc632bdb53fe803b065a59ad3f20489c7258492ab81921497df98f4a1b07dd6162fbf8ae04f8f222e49f70980a9d4673dfa29bd703109adde18e7b8160285292ef88b2d093ee7384a428ec0e552fbf693f1a9a1bfe63931747a92d7b7b68e3840fbafeaaaa4df46a83aceb4f9abf32c41e15cb8444ab0f94805f82b5aac5b950f7fa239ee5735cfb328ee585f1da5a5360d939e08a1ddb2404f047b48cf60095fdd8c1a977c62710448f81d32b6109504aaf4c4007730513d43b41d737d4345c4a3b894f58cb5cce1679f25ef4c41e3aff5b497398ebda39a0dd6be7de36c9940d4145808865f10a6e0611c36a406d860cdc6af2075189cea49c9cc635ae0c0240661b24437c8f7dd6ee280584d4e191323a2d453276207ad3f62bb1ccc7d9c4da89c1fb4d72001e997000bffdf466507c05ef0f27df61fad163f2b1e286011cc5af101da0055f10b0b87447695027b82c929da5e039e36dbd153058fba7cde020adca498a3ca1a9ac80b6a5367dc7810870920863db1ba53ebf5c26fb2490ec97e7121528c32622f9ef5c9cf83fcbdc4e71366e8b251e238937d0f028580cd5488c5344be5f03bd339c45c8ba9daba2319505493a55ffe34d585aaae4debea146b86641b2c34ceaaa1ab62788d2a032cee5c21c7a8de34ecd3d013b82bbcec691194b718ccffbb06c8c6a7cca0ac5a8cb66f6fa4b9526313d07d4706e241a33e2d99b4088d2f3e48432e82d71c21760b77a06ca8290ef26a8306b4a7a96fd9a1bb66cf65ab40a07ea4310c7e0c71ba40bf658bc74d99159dbf026e5f4d251dc545e53b25457dc14d9a2f2806a08b3152a5b4a6f3d628ff48353a6ac267cec67d1b19fee26a737a2580d4dda0eab946c93b110ed3ae69589b21029765b25f346c53c7527e313c31138b3a2a5d2571728b52bf6889e4b59d2dfd31a3258770663ee11965a9598354abc5dafbf0d3eded8efcc5014b45655602ac3cbc76085af3ee1438479890f7f3e01bbf96b49923e13f2df3a7eb6701e759aa7235d9af1cc785893b9a6493356099f24a80a5ce90792bb9c06c709f2e85a7248fc3ae889ebad5a0435e7a6d5c5f76f8e29fa59485a72d3a682ce9147d4897829b50be6c7b073cfadd342fe9e24e61de5f59e421e199f0fa6913994a0072eaf440cae876e33dd2c53abe421875cd3b5f45b05c6c4bf277d945e585309e6e9a97053637a9880babc4ea6268ca4db41548f10f0d847ad305e080e849d985e0c4bec034ef1800b08ec6bd554853ff0b5226ea2d30fc108cf0207bbc99c1b991472445a34f6bbaa28f780c84eeadab7bd9c21ebc01178f9f565ef082603c2ddbec2850de9f2409a5a613990d34b1a0e47bc52374e7a1076abb7fda27ff61f088e44d4987306555ce90da0154f71d69f1e72a86f0f8a21b54f6bbea855f8f0173835b31025b36798c889230a17eba9129e1208d57f55874ab72971723380c67714f17c81678fb2119fc61ea5e72906d99fbfc47474146e0c54cf22cc2ed5caa3437c2b945f7ce4936f1d9af31815071962a38c562cad82cc31b8c307b8d1246d9f6c1c8b0bf51b78ede29d97981b18cb0889828c69e52f21fd56446f842ae33cb28d754c5808ce59f2d267da77c900c556d780bdd8c17402a91a1eb8bfb996ac741b22767f5faf6cddc4d5f4382abc29a69f6529c07c267003b0aeee0dd51b88424997e65c160e05a7ad3985f545d498bee62713c7afe19acd31d5c33b8a334765e601b7efd993f3c3ec283e42b3bf25feda4d4bfe302e8ae8c70bac42fb60eb2cc3c9ffb706a6cba4690920d7acc3f5e5739ce1dc123c4d9e1b412b6a29b703e030f170756fc5ea187aeeccfe2bade29563b7f3a55b0583afc627e1e613f3eeb78af310a00956cfa78d3f416a815b3e4ee088421dcd92bd420d262cc8762b31507bd5ece6fc4a83bfa0e24e1c0fd852edf37a999c91b97d98c7b0f3237d06a2d58eb374ada5692a415a21228737ab1faffa6e4c00dce8b2fba7d1dc08363bd9b99ebbed64dd687995725f7f3a9b4c4ca9940c769dfcb0e32b8016fbbf3f566ce8ace7618cd2fae14be728d98d2a6e708a5da7798a27e10ddf60da80a003997ff143eb5c9bec4b6a73374df033fb78d5e68d2147df884bd7fb26c7ba7aaaacdc3c3e8f7a83ce34361bcea62a1cf9c96ab5e776f0d5a8bc2789efebe1eba1fa64e22d93c0a95f29f401287a7d992b7fcb0974d67722db4cd1c732fcfc4b92f5e8e8b532ae2c625e41c8964d19a655a0abce2ede0562431cd70322e2872cf1e12a1e088761dc5375742efe89347ea2993274b820c20cbeb67f74d8c8c04538dfd70c2a42b3ffc6b0d4aa94396a788b142047ce1743be122982eca34b6219857646473e1bcb496ac6144a2e7494fb8b85332d8602efbde9b696bb92145ad963dbc55ccb19472b4c80d31b113b5775f4fbb6a81e9745189fab796f5878f42e4f4850f3cc3da16c16a87bd31018068e7f4f1dac24cba0ce3b9ab6349607543969689a97245a505b5f42a38a3ab4b1b9b5d8194076d20f52e1afb4de2dabb01c54a69aa29b39696d9b85921f8f226612106342bfc36543e48a49b7124fa46531632af6248edcb29ccdff3e7612fe96bcb110b9230c7324788551163f05d1d7aea17dc470dbdc8926debb1a925ded0466aa4dfdf5014f9c855e4315e8a63f9af52a03cd05de8e158cbe4fe0807063c340e33ea7aaa230500df9927688295c4de55469cd349e9bdcf5d4ba905b23ac23046f8d132aadec6acb355084cbdaa71acf0a369d52bc52186de7e40a3ce2730b05cd4874c31aaed82e47c2d4be838d7db387021a84888488dd566b74eab0563811402c0c59ad709a75701a4cd07311abee710f34caa6ea0f76fb41b19eaff9626234bc4b4a606aa52df4c983","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
