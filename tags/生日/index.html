<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58811325172fb86e9bf5080c946b84178b90b8f4b9a3ee85837187cd14b3d6c0c8d817ddf427a5a41b580f913a176953b1231d8bfba318826f8b51595a95cf7e3b4f0cd99a50a094934756479f555994acf7b21468940b05e9c6b62438a2be6c0bd5bf06df01bb7d962d377609b967ea15e6334bb2f97020d083ff7e52b329441735341dab80b4274bfe13dc7587f4f0b788a1e76b3bdad7a8f9353f6bd51a7bcbbf7e28c3141d91bccd4f66e3db633b18395bfa63d89b332c1eed7150e7e6ad338cd4282f958ce3a02002b96c9ab7e00228b4c6babdd444e54f788006bc1f17a8ed02e4a75bee151af7e1caaef5a78ba0ca0a1966a8fb5446686400242c88ec656f0957847711cadb0baea6e4277dfff46bc0c23ccd33614c01fce78bb1fa5bdd82b9d6e0f6232c96cc1b0b0cada495b2d34f6f8c778092e5e26e127cc25878619ce12c45a45ce27aa9450ef22c24bca07b5e74890af7e9ed578111620706d7c4cd9c39dd5a50e750aa260a301331e213c9c38d76a2f0acd9eb937cda00f940eb4b312b00706bca60f9ee01b5198a29b4fd68d0ebc417019c67e8b451acdd78c89c7f8056b44e8d46618484a7905e99b11dac3145003eba44f345c2a10260697da487f11c90770ab37ccac5a35a1236fd5f6d4ca3e8f0e1ed1aa86fdbc662d5e45e7f9261bd21b1daa735cf8eb30ecf24bffd078e4d2c2a41e5066c9cad16943cbfb96df5e980c723e2f9afc57ec650470d57281912d9556c8b94fbb09f861a448c5a370214877e9dd9ee3860d7a373012b6922dd32ddb4fe68e5b089e289562645590073e5ff02ea191f25d7facddc181b660157d35b52c08fa63b57f1ea460612dc091d25f63e6e634fb38652c70bc53164ceb57eb01b190598d44b4175607fc91f00e1de07eafa0a4dc96685a5aa59d3d8e12ba9805f63c91997766aa98f8edacb26be68b7817705c509c87f86f3559e56e007d80543ac4c5ae9221605a2d86712c3465c642d512dc6e7e69f7571feb3fa41c36ad5508a671fbf426bcbf3da1416f15b674d7beba04dc24cb13598452236605327a2d885effba9ec90fa928d25435bc442fae0487bc12fc051b708ce3f628a026ca459d2ec4261e6bd78896b9c60f008ce38886915121eb22d0a861190fd37e7802025959e84a349297bed78eec42b1d76de8db55e25201bd58bf7517fa79efe3de61d4cdb6fb7b56664086067fb1787e7daf13e39ffce41dedcd36926697df81147a2f66f6bc978eaebacc2fff36de8b042726b5ed6961c7f7bcdef1fc9edf2f2007b72cc3c696da668298f15f60a1c71af80897f9ccba89286a4d423b6b31195acd5881fdc2eb6d87bcf8fd129735131b9495107b89a1aa65cf5afe3ffc9e594a70565d24e8d441995f8dd2051bc58072a17a5d01527d78476de357ba76831c82ff66f2bfe858b612aa3822ae9a8d2fa53c410e23ec6d3437cf4fa05174859e8496e63388e68800515826c0c1c90d0460a37098192c83e9731eda172a7d3c2aa4a4bdf3150f18c9b1c41162d335654246587af96590c1f9dfe88e1fbbfabdb09612ef3281d8e28c46b9dbe411250ae935497e18da1519f6af3fd2ca79ac2c8ecad00942911df28aa663d317b9b322b57dfc35598be75c6093be877f07eb35b9c03abf15d4da606db6b8867ccaf4058c03489fbf3c09a5f7c37d35a770a8813a4af9250a0590193726cd73a4265ee218d5ebe2e53ba3e8b3c8c897a214eb756e01488b21490a09af69825f40770201bd1bea6d014de8b56c95f859c5f6690b6c0d2fda222713599bfd2424b5c9abdd0a46e16ab60fa7ef722f710585a0b11147133928014946827d6e2ea54407a882e0051e8ab0d5d4e95eb9b0fd367521403fdbbe7d07ac23cfacf24baa97537d89f17c6baa9faa3db402541d08a2469e7d25cf59795c3dc591deaad9017720e5df56872e747cac3077bb6bd15a44028094103615d71525944ad8777ea35f4a48e70ed9410471d847fd0e6025dd827041c5f9f89340fd719c785f09c6d0edbc6de3659b96c78d55965fef1c042a207201646e09f4ac8d737acaad1a2f51134b09496e4e75828f6e864d356cb90fa34e5a358d3b9b7d76e6cd5fe644448d3557c64338c72b51acbfeaccbc7180196d56988bd0eabfd2a24eae41a9cd4e7f48f6e1d5cce1f2b987c00b112ebd2b0a9ed3de7dfc3162c6cefd7cd149bd0c31ee9738639f8e50da050cc612e265efbae596a6030058fc171d4c6182c1c44c85dce1393aa23845613d82affa4c5cbaef1b916f8f75c4e81914e9a1a65d780990c07e518878c1d989a14619163d7afdd5a18638d712316ec5b7958abe3d65379741ff13e401e1786d3f7ab802f6d435ea465c8a46c316c04329b2ecd02bc2ab9a0334ba621fd4b10ffcab1ad9eea6a4dab9c488677b510b692bb2c41fdab7141d9487321990c6a7c37abd0cccdeadb1b884e3798c0684a8429b30126b0ebbf5f9af8d169be123960087c96a3973f83263c8915d6a39e04cddff90b5271a3b366848d7ce11bf70ce69ea5d4e259b5806a1e102884bc72ee4b206249926538f4d901a4b7993320677b0bf4016d1d7d5c1f14b55ce5591712f22cc0aac62733eb76a681256ebbd6e2a89ab89cab7893f56346bca5a07812a5e79a8ab6f0843b918afb80911e3325fd115902b84de1997e15c651c85c994f053cf18f99f3c16240b6b613cfed227e517f4e3a136e0175f79a81f3857fcaabf0d2c9db9c69e7f94a5b8fa57bf2a523b93c2f551184ce96eafa81eaf80e6be5f6887e579881831839237df20edcaababcff26906835298c2d2bb067067639ee6c3d2cac07e94a0cdbebf17576f3f5aed15f877555815623dc3adae79b0103246ad85c82607a81853389fec6f1b9d03ede883fd97037d6170398217dfc2ee5169a6d274ffc3c5330380964d0ceccb81d1979d383823f75a903528033e622ca478c556fa6d0f64b62138a4236f34a2c8098d9b28e776c79ff6f2b4c445ad94e52ae649d3ce351a5c788f8e1cd9d4bdf48c8b562d0323e9f59712085fb70146eb00fd10bbce42c6041ca8d048ffb97de957b9098f81ecde1dc8328ef6b75592893369cf90399015a0dd4ea263cece107ef1a32ad53ab2c505899979329699871705e60dcfdce321bab3a20d6f03b1926b2be6404ad28d43cad3f40749b201c8029001c14e3df2a0f4e8da162f35c127978ccbbbbf973e642adfd5b3307ee197dc97272432bf7944ac29162f353380384d0607eec7bfd1c7d3a78cc48d9d9f9377a10dded170ba3143435836f49b08be13ce35f9f9227b528d630e49a6ef5d8628eb67167cf551a146ac38ed564052937c120790e0dd7dce0c635f76ac81922aeb5eac224aad17c5e3e7a76fb5b844ee1cb2e9398d956249fc25c7ee33b343200b91a8f3dd21a3ce2fbe5779890df40675b138a7fd18158e13c60a4f3990f16cf94a465ecfb52882b87693db46e709d337700125faf1ec4371718412372b95c2db1c08ccc4bec18d9e563be69410db7fe39c1b28e9825106866d6a4f7a7c3d6a1d76150d0aef08e14751584c27ea58111c15346e46b1dfcd6c302cbd4bf9e4023f096033a58dc54ef65c65f465baa8085a711f0767363fb19e4669a95280169a82cbdf3a0fe9d7de69fb1e9ea118ceeaa857d170044d10c9efcd916076815cd8491f3dc3cc213615bba3068d2151431da81dddefe48c0e3791ff3030117e25b33c78f60c3cd19931ab1a63904fddd9ed6a75157d0d02087733f612ae682fcdab4a1cfd1b0f4e01b3696facfecec2b0af1ebe686dda5009e86ab24b0536282ab5fa64b63359d1915fba115e2058703528e92755a961563a4e3bbee1f3e76da8f58887410ea64d1045226cbeb27cb3b6bbd0c0251e70d6d9a3fac5dec5b2ea7f5445d4a9dab9065e567404a91256bf70597cff18ce0a60466b80dfdf5351e922d318921e97c68640505029b9e6f4a1e74e201761715e04632c3b1033618faf5afed031d0a0d5493fa8826ef3a92f6ea18f830ea98f484713b40cd8f39b627c1dff0ee4d32b30798a72285cf5f3f2c3d087bd671d10fd670ddf2e72bb9a5b235bc115d139ac161a8f3a1cb94f13134256825fed5b0a34e473adf1185549a7cf5fbd21d10c5df3cd0de9a5ca71bb1fa2b210d7e6d617676a15d4886dbf39cdc541e02da021e3316efe60828e6343a75c838326310f8f6b7f8a4303f77050e4916064e54d1a690b2167c2ef2c11dbd6e237b40a74f668bf0228a69b1c52677fa4a1534536806539ee1b6933564b5e5330804c4303d8ee50e7991f5f87be0e475854a1c522e01ca1252597c3d3add1b1ea73a90a320cd440293c8b42cb14cb0f152f6985e04054f77d61d140c8a1d28200c3a93fcb58245d78a10cbb2c1ce946fd0e2547b4ccf90e342d7eda4aa954653d12958db572ba7e1878d4aaff098d02f09fd94353e18bac837b41e21ecf7f3207e902314d7ea27d0150307782403a5f414c269c97f66b9292d30c9d7da966a13c02f84b6e51d13dafc5d74b36f4482a113d597bcda079b5aa82d093ec26c853ba748ed06d2460e13fe3ed40581b27c922f873665813524c66978fbb0308c50f51ef7a394a7861e9b5f7d2cc1a07b3d09594fff9260991020d2bbc025277d8ad3ac235fdf447c81b5f4339bd30d5656e9f9934e24bc4f370382ac85e2fd1cced7ffd500f258e684a70b4ebb3e50d57b44daff59fea5076f98a8cfb48b0b17c755a683dd0bcdc8b8b2c9f8e12a7cef12a338fbd335d020e173b2ef2862486d78128796bdec3a4522434677ddc200d9af243c33ae5f53b10216e6b5c54be95ed3d0bdf3ddb4fe496e9efe03cfa546dad2b02b1716250a6382d72fab4907feb9f38fdecd7b21e4638d08848e5b42b8e64cf415263cb8526ceb8bce57666a7cb90bc89a91cf34c3e0a139794ea4f1d2b43809797a4f85bfd9457a478c37eccf612185d483be67b8dd470f3eda14727b5e0259739fba3301ffadf19b403051fa8fcbd2bbb166f51ee9a03fbb1ff2625c688f54ae4225b2c2f2ed39e7c435c3579419af1399336ae0e7eeb4b08fecb9afef7ab40684bdca0ada7738927c77d0079acc40248298f744bdd087b877e3725a2db6eb6aaf6153b7486ad4697678867c0275d5d67ac463a1ce9319cf26c1c507dee0652b315249c3376d2d7ff5f23b007ad7e3bebd8bc49f8d522f2fb550142cf09081c23ccf8fc41baf9ac1b6f2338adc862494b22822b29028cd522ade594adff0c5398b25396b0d5c3f3311702efe6f6565a3719c71fcbea289397fc0cd5db0bba799b94b1e9eee62e1ba6160cd93bc102e2dc74dbd9f99a32e8fc89213d7c1a2b011d13a9937a8b6c7c5a0995addcd24979d71bac0d564721cc172fe6cf5a9ccfe7baddad50989d2aeaf09175be8b3ec661de773cfcbcf362c8b76a049eb18a4d31be42dc2512bdf32be7b579f064c063f240783479971ddfe37999fcaca38be44a2cdf1d9f594627d94d222e78f705fff650d9905999851cdbd0af648569c3f2771ea87a57ef6a1a39045f7bf075b7dbc0b086b460601e2a954a3c595623498bb66aa5f99eda03b9d61bf9d9e6ec6caf15cecb959ad18b23b938928de853bf28349f242e5631c773ffb4107a91b0e007007f78f242c86e22857e3886151cf81fa5dc669f2dfd52fa04b2f72351c0d66714f6c6eb598b3ec0333bf121b887afc4bd2c5e9257f75555cf3f793db4a2e3dbccff14bb90aadb234b97ce79426fa39d2ae645f45028cefbae317d005a7404d6ac66d8076c593ab58cdeccefd067d90defa5c2f21a293aed73360c56f536a582eda630633d005d39eeedd37745702d514b41edc8c21f979df2528856d85d91209cf73564d720e2adc342a2e1fe76f6a3c57e5fde0c7a30b11b89b6ddf74c0c8d31df5b2034a2bfd5af425890a68264869cd36e3b1fa327bb49a913048d62866fbaea99cf801b37bae30ec6b670ab227146dc54c13b0c998b03c0c818d7f899c9aacb7c3afa4e6ae1db2fc3b188bc227bb11e9468a4c7e70d0e238de5231c1003c751cb98b408b1143d4ed592613d5f8c2d769c6af31377625c338485dd01efbe51f1a3c4af9ca69fb90310dc9d571e4c5e2f11f6085a3abd0c3c1e71ec78b672f94301757d634bf84684fb239c84dc68cd944d914dabc42ff06f7543ba1ecadf6bf6323c5d2bb485c058ba8661a631116b6a2705d273042c9a25a5e61ecf37f68f7c14d441d0ff90a061f19358c489fe21d02a0b5913738a1310f5e2c7b7c46d82964939dbd7aeb4b114a846160ccb0ba70212470e0ea52d10398d7b290a040a624d97776cc4b4cb790fce37a5277d10576d0f356be5c753a4e1ba798b2a4d7007431a10ffbd30d8a1ed7e4c5b0124da5aeba8d164875b164c153466964eb3cbcdb04ec12184c38a5e585b2e07704e35496fd5222101c49e1afca210571933150be205451314132f51b6bb1e419705c3cc5939bdee3fb2a0cc119f3a279ecdd8fea60113a4a56caea664b94e7acece934a80ce1b6d55e83e905abf94c2c0bffdd5bd377c84971a5d371665969382afa40e7974c80366f79bc160474c7f85d3d49ad0ca9879d0e3af31db459b4f018ebd116f608eacdf4fa082931e751fa01b71ed6deb7bcbd6149e18da89995cc847ef0136935aa591a69cf8309dae8ad3aa5451630db242491ee8397cdfc38351dc7a719b45209164530ed4a916dcda79b605713b43575970a98caa009d91b8ca1b12e2c6edb2fbfcf268fa349565f34311f75af66e3ce0bf9753765ac34748c9103a7b2b569e824ade9453ecb029dd9668d1d1749ca71685beeec1f81746b1ff5f8e6611a5330e79e3062ef09db0b6feea094715bee401820223c2c5c5ce3ccac03a222ff9e1ade4437666f9b544c7a52b8d7d3a0d7be0ac7f530be42afd519b54fa2f7b24db4ed600edfbfa8ba7402ef11576eb2d08173313fd173c6d8c6ab7b88abe40ebb47312e2121a1166499142c3a638cba1cab9cbc77281b983edb054aa46450297cfd27be18989515a02aa4779cba9bebb861c4fe9e43314c27deab0c2d9550e74fbbf91632711a330479663598afe18734313065897135792c9f4b355a30872b7ab2c7a492d5b4c4f7f473c4f963b561678fb36717c0979ce9f8360b4feeaf82858bbabfe8e6e85cbe152a4ee10bcbf7cdcc330575dccad647aa0715d37ef919bded988a2031d86af2f16648865ea978d62658ef7610c76ea8be293b4a5507f5ffaeb3a63616f3dea79dfe8210be23433453ca1fc8adcc2429b7ac5b12f2fb827bd7609b51f9cb3f99533a7fb4edcf2ae646d96fdca298427bee3cd12e6d32e968da60d7cc28d23f1dfdb780bbf55c856ca6f217724a5e42377a2d25a15522c6931e5d737ffeda10e094f8028bf036d509546e6dd735777ead7a96612c81c5970bbf01bcc99619ac8a833279be54781732234c7a94561bedab5e31d160a3ec646637bb98651636912aad622eeecce62a91bdf06127b7cef00a863b851d710354b2d9b7bda1c8f65d735e06e1306e9527196303c8d5c9bb1abe17654e2125a604c4b013de6569d2996fbfcf963de970c0da379f050e4a8294096a210bac9c14ab4be7e6385786d49245a4480c057dfd11e5c122bfe69c4e8a9047bd36e539a133e8fb32ec8e0f3c69c2b134a4699eb157a2210e226f0beeab59b0371dc1078d00eab0d4b2b017e579ccb56517e5ab07daee559ac1644ebf87a8572894d2bc1907cb0962a806da89887293b8b4222f18be7d47a7caf7c76bfc3a10204c5dbbff74b055598cfc207eee08bc215e5025a4dace2d590112991f852f32d874a34b093077c26ece65712093ad142c0d1a7b57a4e7cc6f30412e68d974949bc48e3b48e0180a782c4894e7292060fe5a8a4e7446b292e2ce95b5384c4a2a72c3e8509fb8754aaf4f43482b92b77564309f0cdc59a99b97681c8bcc955fa791a73a8d099f8caeff4fd14da7807050f6112173cc00f6beaed6085086d5b784c23105d6f7fd273b334a7dfb5bc0a3eac17eb47620fadc2c6f4e200982e86b08fa2025d42032f1f7003f811886164ee315eeb52925437f7894843250e0116181ad5b3e6a5e6e750d7eb1b8bfffb1d54fa3bf6cf65aa7bc33abe9b7dda287297ea8ffa9048d94003f96e6e2ce4a88842eeff9130ca75a4e06ad7b2d2f346d5b68d1c78fab53b5e4f4f3960ead864b4f51147dfc8f42182c9469ce585a822ff62e999c472e96ba58c6f4ae6d06d8cb980abe098ef337bd139f2d71f0845bdbc30f91f991d41a0f334bfeb1ef393a375fbc85ff30b5e6a35c48c740dd16c818053ccbcddfe0df7aea02faf6c006aa9190a81bee5619be308d7296d3d9b87264265d670e521c9c31cb0842bf67b6f024cc71ab7a26d93727d6c164de999e80cb1fb7cfce542f4720cce7d636c4f392204825441bd33fcfe2561f3146911729da8eae48fbcb027d27d0913ac0d603e41c3e9216841db4e27f18af473467158cb7fc92da687f3620467d65e04334baa81d8ef3969f8454133bb14146ad608adf0b02595a0d6e4c9bae847c8cb644ab1c9a2d023974c650f8676179acb933f823755cba13c6e130f73f945e8574e33eae0c5db06e9ddf1eef3d7076d09b83155b743c33264a61a1501cc35b7ca47f7568d1cbfa3321b49b85f043d28692ba58deb3b2f46f0e647d391311880751e27944842b952d27e98115aee7ffe652dd815fe771d654e675716f06daf5d1289ab94a2de48899cd1561fb0dcadf9831001060ededcb5dab405435d99e5ec73454d034643204c519d8201b41a5f02a05a411582163cb68dd951ad6659827e3c1ea07bc660303531f3d690b1113b5b735d5555c679a9cc016c45886daefec2ff12b7a864d4deedaf9c058d045bd2625d9413358252d9cba3aba0a4997f4bb9241b76649cef2df8c39b2d3caef8fe346d2b4b0032aff8b7e64c58924d53f2103ba927f5537abb806110202d64f2fc42844e1a1b0cc25d00ea5f24cf5d81fab33ba82f1eb917601b35a969c616b9c947e96bbeedbc05be5cc014175871dd7689c028c5b73b2abce0813479762f06d9ac7f24bc55f75cb4f8cab36ed8e79cd38f95d3d50cafce405dcd2cf948facf0486e538b958bfa53937b3f1b3bd5bbc8bd891a4e3aaec2c90434ca8c31eab6727536578e252ff157e119b53ddac7b93ba0c0ab3f5265ca002516a571e166e84aecdc67f837f9aef39e046e6ea9c7753e3ce184e2201bf6db95bc284581c59d0b96f7821431fc74ec03762125304ac259169055b69467c9aeda6d4b3da959a2aa1e9d34bbef2ab19ccc2d24ba14f2cbf276534fb73272e94b4bb4f8c6bb41823f2443e06b2b1f6b3ecb4db1b7f003b0c97f4622c956efd7bede43fa27b78b1bf5deb540b663694a954967ae251165ce6f4b8f6ba0d25b12527fb7c9841db86c62f70bd8aeaa5c4aeebdc9ed3a1bf8cffff4e5617f82566db2cdf3461056d4908f6987841919a912078becf93e14f6e2bc158375a69253535915562bcf68fa1d673185a877e64fe196e89ffe0430580f76cdd5e4761323ebdf1f0ce2b5ad38408f3e6584e3a04c068c8e617be4092ba93d128af9a6196d73a540a0caf6321c7ddf64348f56b00dd0404afcc069f54238fb37232677314d039d81c481fdec6264f36a538d6459901408eab7af32b304a01dc58f5c6d86e1e857ce7c7625f1156206737350d84aed68bf449dd49effc86db5a8441d5f99ca615286167a343b8910312bb1ab0ab995c805a455465b6d797132f6a1fdf39dfc726c211097c3d77a7c8d0ec6cb96912cef9075bfb47d5c547769d5af37d0b56c303c994f328674fc4e3e3f924ac29cffebf27ae7ed8b1368112dc50a5097322392429098a48e4abb9b56bdaaebeddb3eb5f4ad0fe88d5225a5cddf5ce81923bc4047a95b9de8a4c80d9a9118020d09c8338828e1011e5efedc38cd0e9170c21bf1663b03d78012ef0a18771d04dad8b93029307dc9eeb7811bc79fed56b40f5e74191824a8ef0375e2352e15b16bf7ac8e048654f345a0d5c66e1630975fcf0204f48437bf2ceaba92f144901ba4a32424f50fa9ca151051e63bf9d213a6b738f2206aae35ed1852dc15a580377e960ce91b7b59cf6eec53009152ad808ccddfddfabf05d623f3b656c0187d9bd3ea40106f3406de71304ac14f624483b3a711b3f41a5b8e0d78c455e7b38d5bda8e4d1d69d255918a5baf625b4121268b0d56e7c8dbfe74b1397b576b726c020402d06cc121d0e24b2e69fe50d853c83d894dc7c7247011b88dccb348a5e5f32508dfbb8f0ca7aac1c75a7ffc7e52de185f04b5665ba8575b95af4246d27a44a5ca7be6141695ca0813a51f9e624b75329f503957a61a74a1e825779721d6acb6f4ddb3abe70a23cf65328729af4b49fd29b1813ab81ae6c3ce2260979cf739761863f015ba538aca3048a42ea4d56c1bee7f3442b3d4a68c0229ec1581da8a2b1ae3c0366883cdd105d15c2d056e00722d0e6034a5ea8b6333a406d4572fdbc1d292317748175b1754b3b7151e9eff8c3bc60e5f432fbcb0e3273f44370a083963bcd38884e457a67830c68c391c05d97d2e18cead31f8af812107060108531b1342331bef4ff7e1446d00c24998a207c53583afe50bb2a576753f6e5a36f585dcad12c49e124fd68da1aa82ed089537385a99488e0953558c89989f46f3c10007be70ddf03079f2c7d1a1186bc210140a66147fbad58ab24f67b5f7f7ad34ec6d87edd25f6f94c58df3acb7e38d483826a8b318b69a2d2ac52fac113bb7908809e7950646e188e26441d7f791c0fb1743681d3632221ca5c3c1fe2ac699a6657a2b9023d69ba64dc34f4fd90527178e7cdad3b78af70d94d32df7c114cb0fb7a2e3730ad4fc05364bcc891570306be2030a67baf4a42699528ea48f65769b0f6f61866e1cd047e6875f83f3934ce53bdad378cfe6e8b67a64ac514386b015044f2ca1d048ac5a845c9b5234e65b655123bbbe6fa84ea95961923249967c4c021d6f24f9e0f066c5b6cac805ede7fec5f221201c3ba3a81be6aabcbada5797eddfdeebd9067073255b723df559c38e46c944e476654103ec56e3eca1a4c27d9e518669674015077321a8f602dfc207cd511ca91841d5ac09e32fcfc810014aea0f9d2be7a5cc3e1b1e1ecb5be64046ecea5b54b0b72274b58d992dee46508e3540e2de5b5e2fb95e0cc8cd990b40fc685261805108992a0cf834c4b72f79c4226d882c7629103b2257c8716455c767e266d6161ec73ef7b3939ee6c785a483de660458a1a8c9396a1f41cf932581131ac4e06067a24a827a147f85ce995c843aa4a3583148c53495ef73651d73d88530461108e4c8faa040cd0883da14f07727da4d3b3118f4363c9ad7a6c875f58f1fe3622980f9441f52752dc73e6628a3f3b90d6148b79a88c790eb969651e68dcd7204faa2a6ee01e0ca520c654d9ae1f193560bcad9489cd182f82694ed83ba35d112ccae86971a2fe0bceca9b45ae21a1dae2fa5a794e0f92fb4f0c1428bffa43fb00c877eaacb31e139b89a35626dab0d496b8aa2a3d8dd68313cd852437ec594eb3c1b66924d4ead9012048a7bab0256c7c00cf6cbe5012e71f911b30bd8d6084be48980f469a790abd48079c5af38edba77c9700b864810a21ae29253ed1e3371c57bb2cf66eb4668e7e85c81da0797ce84fc479f767628710d46a3462399d6bb5bbf51dd8b1f8a766d21ffbeba9de0b37a0604f722f336c0dcd46d46d838bb9224153dbf4d3622821d5a2444c1f8551e83d6ac8c7ea7325ff11020092de5fb016bb8b2d0d5b4a408fc931c94a7ca7c31ca9f246ea171cd6ba10fbdafa5f29faf9cf38703732f309d880c3adaa326304635edc5419910f9f416f33b23b99a69971f4e4ef9949716b79db65fbb780591bf859720d17e0667fffe39c6896e8ab48efa543662df27051bc71ccb9b748f22a9f57770595561c90ff84e176ac5e307b1b824f5c7f951297776f121a01950a39ad6aab90ad3a83e707320418ec92199cdc549989b5b4ad1376e259a079d37f3846f33484fe0df8cdafdf42504551e30baa037e4c1792124b58df95f00e98b4392b32bafa669735c7a05a8fa5238f17ee0d4cebbc2fecfca7399be6c83ad06554cbd5332e5c71a071071aaddbe7172a764094752e32855b6725256c2c261010e0d9b250532b7f59181d60da196e09029d992a6d4deee6b5aa4b838cf8de49a40ff2c011d386580e3cd6da65ec2696dde90d11882010c199e1005ca5f5d628a152601132327b5550dd9bbc0e4824a09c8a9bec0e5bedc69ef6a3217655f7c5dad38cdcaacd364a3bb70917886af96f7aaf0e63d9ba72b5ad052bb5b6ed38cb7941c96c404057134b650840d18cc52cb3ea0185d10c867ad6892d7c7ced89cb63840033a958f2b139a025c3638abfeca65ee0237529a7a5a6e83afc0c0ca14b292bb81596a3c14bfd33a957f278ef7c9c1d7875ebf5ec94db5235f4aeaf8a41fd989c815662a812bc0d2642082befe1ceb650e34c8a488dfbbf452e3cb49a815a0468111756586b181aa5e91736247efec4549e977aeaf00f6a7b8b6c857fe094e54ee09638da088fdb8a35f60a985c07b94da7ac7c10572065d7ed7c1113a282af888dc9d2c7cef588ead6b28df59a1d795cba5b6a1738cbe9376db66f5633fb53eb1196ea7937a94dfb887de4afdb87394fb1402a73a79200811b87d86278a1d035cb2a35a4ac24ebc2b5ce68e7b009417df232880eefc13671fa8509bb0ee768e6e43bfef46aeded1455d4c0fd33bec0664f23b12f15675505fe33c5bcb42bb5e133f40f41b51c4245698d5705fb5d8cfe334880d5fde36644cdc993f34ea74d5faee37862a2eeea88da064f2adc379bf7e471644a96e2b1ea93f43c81ffd1a7d29f2413add205a34355d37a2b3d0f5d4da563a69031f2a707ea6e5d934b74b0fed91cb2ced712139144f8f2900db301078eec5681524afeb56096237f6687c80d3086b6483932f485ef5e8fad372eb8b7a437f99e06425f69a3eed57bd729c4ef1262a4fff25a851e39a1fd0a209f69e0bdead586bd573f5d88cfd5e36bd4d3b3c7b3f87b2e48d3c1693a4fbf818f773e821edaea3c0adf0ec529fa6ce2d3c6f74253184087c9163f489648cfa2a67e5d65f2c227f7475be50c78b184702835974cb606a7a1bcfd46bd85bd694e0fdf2d515bc2e2d83a187565e315ee7dfe8796df25ebe6dda2ce3a63600998b407225792ccdd73eddc4a46d1d5045b6d100e911bb477cf3d294e0c153f2165bd0fb1eab5044a5c86f44d1e2e2f1ff2fdd9b5bf4ddcb502d31537ac0fc93dcaeb8fb92de425f4c0ec544828a015cee0d0c2c6d1c3883fb622922292542fac1be1798d7c9fcd515ad7cccfe744ac8d5dbd76ed2976624a7a7518d84cc6c2a0c7367a7afe64fb1c42b591c28c02cf778e445b74a5caee6236ff6ba9fe41a8bd9e3dffd58e29a18c1889417253e622c5349a4c80affe58acbdc1352eccfb98067ca7916ce10b36ad42d666626f279047cd1f110c691579f551fdae115ea28c35b1c5917d2ed8baf1473f151f8fa5770b922f9f3434825d6b2efecba6cb8c60a2a209dee6fc9943a80e8ea08d58356ce229d2e89e59938425287d543959e5aeeb65e062da93ac83113148b4cb4711ec630f1f9555777de56653792bca2b8ad08f6db9c61714ed471a851ceebe76b7d5dbcfb8de53672d571f6ee759abe743410330b0d9df6a41a492010f5f042d7983e0f061ca32a54d56497ef2f97d22d51227e1361606e06dc7cd2c241e7414d4d2abcd85ece2c4680edf8c067480a8af0b5a35cfff2fef7fd77fd1bc8972ed5ed1fb84f513f0fe4a3c2771f300c2130e0f8433fe9357b36e0bbdac91ad8d199a2c754c58dd16cdf68df115fb7784576e12177dea54a4ea2b79fa07789ecdc5709708823155b15f875c1c7e38b186608d55b0e1fbd0a85e19cd3ccb5aa10e81c44f1ba5c4d063c072af0febbaf8d37378d38db18868134bf960dc8fec12d34e8e35b00a084e5715bda8aec54ed6ee564962b4cdbc5f4cdf5138be73816e34e2fe75d534a35484ea5aabf1747e2c508f099fe6407a45433182e3f62584a72993dc6478818005a9aeb5806c9c3d5430ca6d0d2b339cd8d54e69e024c7cd085983bab10809f8e12507559acdea788617e60c673ef2a858a9274413b12d9cae01a3609932486457ced6ae002fda32b9cc81b7d5988123d19f31156d1794630dc308edd50cf8cc055aecc204e0309a19d6598e4321eae34ce1e10515a431f86f07441beda54f1b5f3841e4a5699794b7cd6d9341addb881e5c9c913a409993a843e4dbeca97efa52e921290a0cfe5499359779a4ae3b0722223d2cd85d372d4fc940f3cee8c4b2477e39fe112d59478ddf2f15175e9685c0c9806660b162a7bc06df0de46bdff96265925615fd31a597e066bee1fc2c802fd2fc4ab0a5ec89c1eda0651212408304c7933eca43600b5a81e8ddb3fb8ce2215e498fcc4e73399588e94f946e149de6ca6ecd8f1236a281fe32414d7cc980dd20a6f84a21d0d14a3a3bddb974939fc68ebc42a9a06bc85c9a73993fcf3c5287efd0044a86124e73d3885de73fd6ca905e3ebf408291d16717ab2a257334e1417a6bc8a204adf255741aaacd9ea538c7012341cb85356cbf5b3d39984896fc3d9baa06af3758d1c8fc2022e11dea4e29bece7494c47b9e4142fd4d49710df7c34e9fb978099679324908b4c428674652b3f69bbb9e6cdb330d803d4fb001cb5a59f37b50ec0d23ff7d36a4e7c876b1bdf9ffbe7e4a9d607eedce58c108f02eeba1cf3daf3ee70cc9f7e0ceaf95ce27494e22e736e2e83da627cd00c787c23ece7722e2f7ad2b780c1830873296c54a111e604a5ea27c4ccb8a4584ec4531836267670628da67787829e9648f56937d0180817597846229eab418aca46790d782e7f65a3e85727c5d2f5a9fb594a88f7f4445f55c6df13d31b725d37b929ab7c089382e49e142c0c0be9a25a171a14a9f2be2f1f6dfce0926563e6a9bb30d7edb0d8198be4023ce45e0b0de709d3a773ff71da92207a27cdf4fb172a8899d5097d68c24cdc019504ab512438f2d48582bb808b3e135e73b23f46e19da090110b99c34acb863e5d02435569a1fa008a751a2814379b1c341ba5be731a6580d0766048f0337b8a7bdb77dd2905f5d9cf85a34b4973ddb6ce8f807f03099fa9e6cfce68148919c376472911f4829d205d05e23310b9f028474fe081bb486cc046295b65e4b3f733a087176cbe00a0096d930350468d60a408edfdf7740d279265ae663eaa5de8b1f6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
