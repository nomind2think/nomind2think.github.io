<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cd9db5ba2468eef1d34a74062b1ab8aaebec971ff9acb8c38a8c4dd6aae2e8ddeb16395c97434690f81b0c429b577f5f2607dc0c46727b7f8a0ab55b72e052e5cafb063b4f01089fb09ac3a060e3fb42f7d5438ff5dfc9cfda0748136902a5055e81f8b71060627036759e20dc3779b7090f78d1a7ff1a22002e30e37439f79e87f8b812ab15d4947656943936476d7d022468839d6ed27ed83e195335ef5f2c0bd9cacd7d9a8e8c5945b6892edc61335c5f3b8f769f5ab47d3abcad8b18af86ac0bb6a07e31aa099fa961d034068182a4251bfd1e29210f83cbaeac2dd80587bc13bfb518a6dda57f8caece0504c1555f5bb4c0c91caf6529fc1334285f443fa6a0d7199dc7023f084e44053bcd127efff7aa70f4622ed746d8db287d541053d51c6fd1ab913e4c235bd0824d019ada6089e82c1c14468427f63c5d165262fe562e63def4b1a97c3e894337c5a2972d1774cdc7fd1f464113bdcedd25a563212063732f9336c4df215cf208fbf96e1d52ece43cad736323e519724eaf4324ced8b341a8454c1035bf6e0aabe8ff4f1fbc75b3ecb103b7f0d9abac14bc2ca9c23ef7f0b542c7ef6aabd526aaa49728f0ad24a3f0f2adf4dc66812680068b4f9e6bd7fd444df21989c95182e8fa168da35718cced4ce88f5e3d41fbaf24ad411e8cf049421da1e68114d0dd28040734d979fa4f186516803bfe1ebe6655e348d60d670be0c658ee91e7c35e78408a364099a77533994e1a4bdbc00cb685592e0d3c7438fe61e8b2c71ae9daa3e90580372ba1824a13e1840314315e84386dce9bae2e435cfedc7c5871ff7bbbc4f4dfed554944fe2e415388dc1a029449e5cc5ff7b1bc4fba86827e2855adc38792afa91613c4829f1590bb2bc1a335b83a9dd37144c4a8c949cd1f18fd1c9275b104fe735b0f2fc408e138a91c5f1f718bda00ecffe2bc4bf0a14551c3a20cf67bdd262f6c9b9e70105b2ea56135dd6d901b2c40760df066d9ac9e02008dc31616e745eaac9f28d382599194585ae4d9d2ffb5458eab71baa0657abd8d5cdce738fad9df770950dd93608759aa205a1290abf95658f653835588fca164305e7b5617787e5e74511de2b9f49d3bd9a409c09c28c2095d4e9b6a4d7430856658116621e1c947eb25cb14939a94df3f9d533f86c9d462b5f7ec78be70e45ed6818b94c47b08483905ab2963c3a849c4e3aeb7e598ca5f64c93bffe6155dd974954bb0bc2610a9d5e168651da66d83d81ea3d36560301f5e201366a0b79135f9eb524827d38073275bbed371571d5da12ebf67335bd951000119232e1f7106f310625221cdf8d121f9915d2c5ca996b485fb499739498f3820f9a7488107855d5222c29d734e7169adee9a8e5831edeb64e8abba6469bd369a46d4714cf4b10ee38f31894b42f1bc101b61b4791bcacc560b294786ec44b11b4ebcefcd3dfa682ba6e7c47e49c5b621b87c9d89f40378193db7832132ba4b5c36d699064b2098529317794d9fb0e81955eb5ba393ba5fd191fbac6d0dcc4a2c4202030ef5962a56a71e2ec466ea6fbeeef1307aa63dfffc124b284d2e9294a6a4de4a23ff941a184e1541d72b79c44b51738eafa048579ebf927b505a214f74126ad0bc2af0ac9eba6133487d575057f6ebfba5d0b2de73a30a8998ced7aac225791c594b09cf8659b816ebb96e63c7249fc9f60fe134f95841d878dad9c7ccfa760b0a956c06f72d76b95862cd74dff333ee5f3bbc126cfa7b889ffef92dd5e893e405f1813737c306ab7b763349ffbc249a15ef17deb901a7f8da8b6eb945e440091860dad54f6ec781cc2d418650a34594650e5ad29be130c7689c30577b0ce7d917be539892eee591bddbf4a42f0a4fa45f01725d11f501445481f62a5582db9015bfe968d8700833d176ebbae39ec218c63bd5d33cd08b0aaa093e8975bc8b55a284db873fbafccec44811d4300358cbad1015713238f9128829007ccfff1e1569b2f3d9b15c0ea45ea9fa6947bc8c1c235375a6e48a04d723f0a7bc46410020ad18efad4475cf2e2443fea785eb599ed5e4bd9158ba0583d63f95922b1a46ff51b9841cf9ac927cbb1565e5324aafcdea16c927eb789fe3cb682b2e71c83182a0587a86e59202c474af6f3c8be7754c58aa4d898ffe3a9bfdce004f43295d51972693666f2e1c6ba4a0cd5906e6d242272371b87ecb5d9d7df45510b605100b3520a30caa612b996e9f98726abe322f526e10b0b0da6ce0eef9bf56da776ca673d7aea97710682bb74daee570cddda49f67499174b50716a3d6a67a9760f8d51cbbd41244db3982779ce3754b10ba0a0c4f76aa57e41ea37ae723e3df05698e77cf030292c65f9ee5bc33e88641b3e74c03a0777ad10078b43cd8e316b656fb6aba0d1f5a8d71a4bf30f2f66df1a26c2c50e0f1a806f2896353bf354b7b03199a817374e9e07100b36d5bd9d3b0f01715e514c13e7f81d769dd534d62c0d51bd967efd508d1c53ef5ac07b8516fd699fe6515ac0424b8eae32ad4a7f4076bea0cd4b847fb83e599af80ccf74ae309c274b33cf7e4b89622dc3c03e606f36060861f77dfc896104a6cd1d29b323dd9bfbfe9d913cf342581af814c5de95914805b8010698b17112aabc8ed19b4ee4f55b0d368b8f63804684882355fbeceefb6d983299406d23e4808d415be5ef61d710ea7aaed9e814706496f57630560d575e2b0d4cca3057602aa5c3dfdf437437a4b2457e5ae84458643867fceecc1dc50100c46bb8f8bbddc843223952bf902a1c7e6c86e9bcd61b9d598c3f6e7b800ef6cd6eb110f5ef7aff6aaa9b7ddd070da8672a43a9fb3dbd945a50b5a0efc1e50b9e67d70847cb977bdd5b6f3402c2d73b040f0bd5053da09ddb772d5649f8524ded3fc7abb60e4ce5eaaf35dc3595f63f1b20c5900a3f61a7e026038c427009596ea113fa170f9ed5e62305032b631b2dd0d3a1435dc6f60a84392e9a6ff85c67b917ee1637a732ad3c3282cfed9b682006701e11c325d96870225eade31169f05a794826049d82b99f6153314d1ed51ea129c7c30fa9800c89ebd91df76d86074fd6b7a23f2c6946418b0b54c36bb8572dbf4cd52a70f28d833794be1fa74489efef12331e41d87d104a52f2b50046e40e417b0669d98e38151077f501c3f695a20c840fd306d1afaa7b0bdb78130f8429db2c125855520d60201d4aedfb0001d2fd0be4dcda179cac57836df1693c92697cc0defc9f1fc079579c96c0b3325faa2c4c5664df1c6c92d7375b95dc24781b31ac42a5928489a02eb50d23b5860e0c9c05865b2b1667aba946c0988e0ec1b311acbc3a53cb3375d7e786f862c4bc2a3e02990e4e9bb1e13cc8c8e11c7768cb9b9104bd196ba036220808c8b3cbea54be25f0937e8de53c6eedbd63936fe32e2ddbccaa279d9a88744cc726f4dd3386d69b5f7b17b53c45f7cde41c7814736f30fe74fce3185ef2596f005289cb057273298db7d68f8fcd7133a2754ea5542936c37188bed85134091cbda766ae3586e9df35f8afc726e0a2eb0ed109dca41d1df352fe5ea56e26740f644bafc7dbd958e5826816bae0c5e6bcd30099a7692f7e2a97cdd60d781947c976e82ca0b392b1c54f67207bb61a16d5d6b2e9ab381241fc94d69d5bb952a87a58a5795cbc1c35b3b9b8a49a5fc6c2f95dad72095ce56db139298e232776a0359acfcb42bd020469335c643daad85f90af281164d71ddf68da906aec7bc927d936619820651dab9af5a18dc43518ff4ac38e11b71225973a935a4a37ec0337eafa3a62b2b82abd5edb62eb38b57a4fa514cc179f772ab40843cfd6a9d01a1aac0dbad3465b512fa3cb8230d42cb0a52b79ab3ee1d881167c307e972887eb1448b4458ffffe2dddb37d8505b87e7901d45b621c0a6887f0544f8b577e7d375c29d299b85d3dd56fa3260b4367398aaad197529a2b15df5f9d38b7964a06d48477184244cf832c8c9ad2d25ddd1319ff9a89fec154c30e089d2686e733186bc8a9151aa08588bc416078dc53cb2b40344a2a49d61c9480a0bf27443154f982b3aedce733f63b84481242fa584a8e556c756c03d0562ab1e406925fce5be5109cebc0f0e96088cd62c951f5221a25b96fc1da3966b41e6fd9004cb00d960a0443a7e8760ed97be0e9bdb5c5caab61a8b7c815b8b93f072da27ddce40584406bec53aff8b8905a158cee01665d1e9a049ff588d2588271070bf5e79d6cf820f89c155ea82ff3371bd2ad13871c3d8efdb92e460a12ce6a2b21d73d2bc605c31ff93c1d7bef3d7bc6b4372a8eeef26ac93a8b69d31081bb9e318e49dcff0ba5d5b2140f38968753bbc467e730911940a2a5f755a9723cac254d634eefc23f185855f702f998e86ac1dbf0cf3e8d3cfc91ca8584f2282666c55072ce9079f141b6892dc189238804c25e5b246c8da3b6f96af04422c767d37528ced4586ea7a9d20c4c43adbfd6525b00a8f95e128e19377395cb314abd1919949aafdb4a573efb6711846cbb8e2f1fc884a4771ed6d07b9de8addcf62aed6a6c419fe5b2190e7ef2ccbdbf39a911d96fe8d6dfc5dfebb3202cf55f77d44e36d87c33b92c244f098768c294f156625fc0d6c27ed28ecbb473602196ebe9e7f6d63537db297d1100f0a28e704f42e8ab19c1abeea1198c71647e43841427e1e2407c8d4c3512fce904248198d349a29f628afa46d237ead6239dfed56ee7aa4c8603213d898ea10fba0b7e068c5a267855053e408b9f775ee495e8b98426758fa5e29481e346abb1357aa12b4341c63774845061652d08a8ca06680a658d25fc464b01a9258444ddffd94ddd25327a65e495ea3749db4cb6d6d7d6ec8a748f3077ee04b9fbe5630cf30e7f629199509ff226d78b6bd17e2b221a71fe8996e08e6830e22734dd8ecdf23a9d83dddb6dad6e6204212587ba98b0a292f7a9cb3094eaad44490779039602baf451557f01920b249abba1d0f3676deb526d1ca5bcda1938f21e63d2e4f664afd15b5315bba85735fd7ad55f8a6388838bfb4d5d3a8d86914223fa7f3e6e40d8b87c8fb87f1ab005f8f1ba65c5922b4c783ad99b743a74534e1f635416edd4fc24ad0812493c4f70c8ae45e09a9fdda89ac9210dff1a206b4633de9b0fd0afdc7f1244090249278d3e1ef491a01d38c08088144a289e941a23880c5cbf9ab39fb0eda3d197b81ebee544592803ad2a479c6e7795609583170ecf4a95b90f1b98b32ae2f489b779fffb3b7b8726c67db8c3a83f3bc3a91a1e022cf71ff243084d3d7e3d36684264ffdb43f226b7a14323b566e62cec2cc3b9385bfdccaeaa0ce6ba86c8b5d5e47f0412dee6187ee091f814d2999668bac3b0efc0897c13b314ae8ebb1fa53a07c8ef5dffbf6f84d38deeb1a7d8483c391f0e5dccc09b52507ca2a6f79c7266d22e8b150b3585ed1034ec013cc0240c511779416f5e52bee1d0e1ce6d0c90d1e13f0dd82757d9fc37a2b49e1cac4addb9289af51ee5df9572780ccfbbf7385213029f29222f0c2d3a2ebd960c367be590ce65b1060351a8fd11bf94012d0f61928b11273f664cb9b58b66ee4121b39dc2042e4c0b72840b07b5621aeb51def1c9251a88bf931f8d3c5ec793bdcb01c3e04f8398e75d3cb0b764f862eda3e9f262ad2e2d5f71b57b650547febc675a38edc037596e7d7e4eefd2c7b757e6e62c82ffb77cb98ab64539f10b16c9cd5b0a239da4857233895ded83c0b1f6614be3a295bd87ce5285d61dc647952b9e1322c0b5362a3b51b16d454f23ae573f447ec288af074fa46fd998ee073bd7e93a248586bb481a68eee1b287f8ba506eb189c59e6d3a58a0fc517f5317fb0a03163cbe38a52ba0f352576d722b41ec2c6a8cf7f1f6e8538074c0c0df2233e73f291c1692a72288a8bedbac8089d8193ed60eec88aabf3e54cebfdac030380b8bcba8165246595c06214e446f5bfa5f9208ebfefaa4f3c108526d2d8050a9398940cbf87885eb1b91cfbd241f31f5bf67e825bf83e047aa2b4b8e69964a80128264b1f6ace598050385058dd579e802319c31d6c3f8e696831e635b5c7cd0332737342ecd0bdf94c80bfa5ebe43c9a83dcd3da8de34c60d97858fe3dd6acf29a5176621ea8eb5f0d3dbb6cd906bf4a417e175ca45fad11626ff6723f6424ba04ceb4acd285fcba15941161ea5ca8492f3260549f47cf39c6c6fb40f611e1ae2ea5678ab421a21e488062743945e0f52dbdd33b0421c8da6d0d109b8037e1193965a8437770b7bbd927d922f4d1970436acfe7d21112ab6878cad190676f9a6f05d9772899f6c3ba1aa57f425def8a536d899db5e6360f332502b6318b9c8c32cf375a53bc6e1211f8df18f4fb7c166d8bf050c033b5e1d4a564f18b61f8ae85cc0be40be30d63d134fa9ea579dcaaf5b705a35c69a1e1c9a679f50881955deb72ee2cd9c0734043ef6846cd328954b6f3fba1722998641b2ea6d1242d82115de9e453b9960026717d0b2fef45b217be02b4438ccb804f2b33e001e5fbecf879c704bac73a315367f1b9ec7b0af6c487943c13e2554960ef025143db139230fbe7f6fd7358ee933ee80e6ab135c3ab1308b905d1c5e012866a9112bfa6c8b3b65e329f1ef763d32fe814f329e099a33482ebad97c42ffa23a07633f045da937743668c68f77a2a351a3aecc8eee426ca887898722184846c71a32fff33063ff9dd50f1a0c323e2b68c73bdcc026f6911a45ed71d27b40166d8fb27506a8de6a5745b0b78daf71757e48a5d44cea9ddf53f9d6e9291e8b9ebcc4ec5dac9a23d901340ba1f307949c543ccf87fb7c714fea99311e2efc737634c8a8666f1501ece6bc6ee8966e0241abbde7ceec822b5fdef6bd4f9b3081b3fc94f8467a9908d2dedb2191ae4500eadd3087505b7246ab21cb5d099cc305d172af688f59c872f1d0da83b0940b2a48bb90e3b613fd50e6bcc896ebd15c7dfb425ca82c33dcda555e2c8317b2d23dac0f10bff76bc19976dd5574aef67062525ecf8dbf5f75747cee7581ad5fba97cc0a40f2f3a80fac95c94d4382455b42ab265e9ec510b94f972c04bb2aebd6b570ae3c5adc7d5a3af1fe0a1e5cdc8ea73792f9d3b868dcad014e52684bd0473840c2051385fc2aa488e74857b4aa397ae943ff38be5d8999ad26e204419a853687b08c353f9c015c995ba98fab7a1fa625db9dcbb30bd875cbea255ca8600b8a98b398ebb4c132a1a96118c10e09224e80e7172ca228db92e96828ee5d72a2845e09a8ddfdeca770ce6795194bf722836de4a285c57deae5b5fa8fbd38a5a86b46087da35e7302b5a6485a7704e0122e80949c5d71d8dc7fce6779b25dcee554d50d045625fa179694a938aae7e22073032f4eaf8b1fb699d6ebc55fd082fb530c94505fc1bdb4165f8bc0359d3306d1c7561a13bd252a4ee645eb00f52e1be2d1b2017395eaed3ef93de3da35da79270ac9233a7d2535c2c779fef7bf531a4164d438849fb0b97cf4060872cea0b9e41c665445c65348987b4547118d226a6e8a5e4aeaad28629765b7b3332b4c84440aa4f15b54bd9b0011f3d0f0cf5a2d7072477e12c31866d64423b987b291529097b419f0b5e5665f8bd01657935e8465a1fd6414aa8b145fa60fc3d68a0f48ee6cc31efbf34f3945d90f7edf4a2d76ac174d0a9010b8e7e2c97a8860a17332bcd91986492dcc91218a68f4b81ab206fdc071e70a7212a011f2064ae70267b5d936cca4498636dc1157a698b148c9f98f5af9934eec25ecf65b199a72dc1296074911172155f91c586290a20cd9ec53e3f08625718b86449aae7da842567f218da46147a9eb3c82b5a4fbd8812d3a185b98d97f754caa2f24a86ccd9bdae15a856cf9461691b91f54d9f364518d63768c6323a7321de6990890870daab336da33bf93ce772fef8a4bcfbca2d8033594e71f1c1aabbf7d404b5d741d3a5421c7a9f6596ff25f20c6a292ecad9f36ed88641246ee8dc0cec257bb1284c85755d37005c36379eb808c63c117e85b95f4a86d422ca4eacd48f703c2e0b1b0c130a0e0c8a2cc075ddf6b1854cf39f4bf85e8cad4ac647811390cb231bcd28bdd241b1ea3533096835e3cd65e80a6baf65daa368fbfbeca0adc81e8fff69b8eb9f373e361d50dfd9591f33d09f8274b1ac7ae35d8111385196908a824235993b0b7a8582c2df107d6ccfb9756779b117ce45a901c0ec85d52ed3fa727e86a292a5cfc20f0e64375d2b7de2201dd8417f42651fd010c12886023edcf62a139d8e93373b8b14fdb300e01f87f08a254ae5fdbbe202c6739bea7a7eab1e3a787ff88d76a3c25809081d2769afd9b5f191d72627061f900176928b3ce616f9c450006a9f77b34668f9bf360f3f17f86434495db4df18f4498b2472230df02a6b2ed3a4c9f900a258c71a7f392cd8e50f24ba44f916313893b9747e713104430b77ffaa62ce1d3ded0837d3dcad5630e752cedf4e98b20dedd3cacada7a49f7c32d80d78236717a6fa3a3a3dc7930ec8c01198ed4290cc929ab8a239e3660fc2aa52cf6bc22020fd34f11a49685bd52974869e6b478c25d7427f2d3f2f83f4445a599061e44346a60c29499e6acb5b400f91ab5101b4c1b626848e0c3bf4e7c76ae098ce01aa4fcb679a44530b7fb689b0ba8fed0139cde09e77b7a936d95910a777b096a1f1296d685992f047877c78d8637c40e46c3c0112b604a93450db36cf7419fb976dabef40078e699bce3b49370d5fe35ddf73d6afc6e69bdc4f7d655078ef8c7e9f1c4377015903fa563c61a2639c9bd75a13ef31efaf9b2b96a5444cf8b8673edd1ea2e41366c550a46a9e1ae4a0bde7ceff398b15c68ba8d9a96ba5517733e5fecbacf2108ae4353581598a547adb40b1a85a2dd66854493f8aeb79dbea9f7ebc9d9adfb2782d1e0e6e954fbcf04221160056922409938430c8a3d3dbc0cf7b39d0e0100c9d580f8e5a7c46525d9021bb6df00f986e90331a66f4730cfe3f34a65b4d66aa91d4e70a0efc8c821e3836d24a1dc40ef6256c7e3fe9dce0503ef6483ef39663f35a6e78bb2ee95fc7afac31cab65f0d32d325f9b9674c721c3af6efa91cea5e541ecf18bcf892ff5262b7f385a0cc31ffc02d1174edddaa1133769c3861c7a80ac118fb30633f80af151ca8d989502a6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
