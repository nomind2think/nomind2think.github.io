<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0ed964012d4d63dee1a1de8894cfed98816d565ec4ff2d45c05124ead9d0fcd75720a41e1f56f1becc4bed017656032054a6bd411b428a38969ef9575e183eea44190417eb4df7feb820a32320d0d0a27039938d021020881c7a6c20cfb743a23c7766a84d1781463ad04f88c0a3fcd28e8bd0a0652237560657f67be62709240812cbeace784931a7355bc6ae854a173e72ef696b58c198e751c8da45c696c8d37d8c48c76485c4de39d2efb6f6b19cd3c8948e5b2e6542b2849930b38a803c8eb68f8490d32fd8acf6761c90b6ffeaf64025bd17693c8b057488b44de7e0bfb243151de7b675a303a269aa2a3dcd63d832f5301387343eed509093c364f73183786fa1f80cb887699bdad16a2d3590c1968f8d1ab32bb7f15b1f75e42d876148136db05218cdcf52ca4644f27c24fb4838fa18239329ceedf0e06f7a62904448635e526c1d7ae9529f359cdae7af592b2d500de6355ac707ff885dba89e058bc0da0857ea29ae74fcb832b2e332ea1bbd7bff2e0133c7218cf76dd7556a550bb4c53fd1ab11f8ccaa4365a09b603bc80d05151baabb6d85505638e90faff06d55345bc39659dfc98745d85ee3d0910852c13862b2b5ec2cf228d729482bcf36a5d349834405d954bfeccbf977bdc1c8b4e752749fa5b30aaca36936dbfa53e41fe3085faac6af5451d8bd5323a08bb283ba9b175e796c4ac032879f0d1c18ea597d85c3d9fd8dc70f11389737fc30c92f1a029b97e8b6805a3aec20cc3df0896c1ed9e5086f843d4b959891de4d653884e96974a57b3aca2040bb5d18a574da55f852fdbb73ba0ac7bd4535d485943efbc0ab3e9a1e0ce015d380c2fd780abc6874e452efd042228347fc2407c863d4701cccb4f428dc4319701297e731a46b07bb81732992b52abc219c86bb250d36e7d5fc0b81f2c69430fbe0c764a8791bec8532005ac25093978283955b81462301c9c5d86a2d7c36e2c0282a2820a1b579949ee11930cf041a9877c70e8ea70b60e426f12745bdc799c9b689c700814c0c65a4234b340e1eb41595e4473fcead8e13310510d54eef8fd602c0fa17252e1871200902e2c8cb1585dabaaaefeacb85eafa54c082035e95f0daee116d59edde936e19e3fbdbd3a2699692238c3cb30383b240c3c9399f91d8fa0a8267b3ecc9948eb192fbfd543ada107d38ec7421eabe831ddd988d635d47f31399b8c288a156796e565805942115f9526ad600a8e428cc7a9a51a769ab42796bc6d6a968616dcfdecdb3713037e73cdab9967869c1a5604147fe9b7b582c9b7070a6a3265daf81672436a09021761daf7170c87c515db2d0f170d39c05dfc6b0500e175d464736533796fbb703ab12e727c2c6c89b4d607e5e7c9aa54e7b634259e1bea531a86a48489086b716563a92cfa695b08e1c36df78ec3e7016a9862ffdc50d9c7848798c55e8a7b5336daadeb31378d2b031e8375a1a8990f7492ea4fdc28e22d863ec9377c4d2ddb071e02ad2113825872247e1dee04578712fca99ed25d35123826e95238da586d9c97322080f3da96b581181f7835be9f0d17a9e21d59a222c616e77f629c0777f7874e4589d0f0eec8f94b039786ba5de020d198700b3fa38249edc32db420f1da8c2db68a33fc5776ecff55d4707b26bfd4a588083c071dfbb3385abb2ee58169bd3f7c54dd7f0bc153f49a2389b187d29f78cd0561cea03ce3a1978c61955d012f543956c13dc5b6fd839aa277dfda58fc135354219cb99fddc3bae73d79802cd016cb21e83e7e19d973463771801feb344fe065b594d6f1144f6e5daf4bf9d66f4a939bdb60458ff31bfb0064e23457bdbbb1857c42cd76d170e5081dd64e1c8e0ecacaa7ce9d16ceae00dc3fb3f5c46243e9be8b15206d176a6300ef1fd4ca43456b2c818f7ff6614867524fea61d3a21c3b87a9ebc7a316a8567c51824339e7180b118b967e0b978a9fa9494492937f01b5ac70348dd284cba4c682160ba4240597d58f363e0608c8da03fee34794335e110acd4271f3d7461c766b4df47677071539aebdaeaa79fd008fa4091947d5fceef0efb62215574433dbe31b3a723ec54e5a0992224d9f550fc3bb9b65d2bb162676729786170dac12fabc7cac81da4b808ce38df84d88bdcc6a0c8ae181e08c99ccb3584ce133434e8ad6753125721917ee10f9301575b7a7d9ae29ada0f2d194b17bfa205131d328a5e802efd8c0be5118bb096d7a676678d135201e2718601fb73c682de84a55e597e6ad21232a33b47b1c3de024e889d732af7adb3c729b2ad1f070d8bdea3718997fe285d275cd86fd4cf04b1ed0c0581742f1891f6791c7f88ee785ec37950f18a393d33e2a26d10d4069dc950999052a3257e2dd31fe98fee9ca29c75a398df726734cf0a312fd140a585113b671bf6bc49dcd37113966e87110ee4d1a7cdbcea96e03ee62b911608df10a347a188d319fc4a1b76986591f1a4c82c09d211fdf42d3306c9dd3868dabcc710f6e5ab1b20ed320503c4fdb6df86fe198c838de00044603f41483862052528d1d5e6faf49c5964314aac70c572aad6696d68d75bdb507b9a29df9271ca3f6c69346709c029c4eb217199d8c5438403383b6d7d51994e3e4dab2290f4432da1933a463df81b64dbc6ab2567f7c76d562ba0428c70ccafa571485ac802894daaf485e3baca94c5f2c6fdbde1558156ed17c4fb71ba959639b6b52723d4646a24ecb91ed4ba3648d42ad54b896d0e37a5fc2136cbdbf850ca46dc6fa5694f75ff020a6c2e427a3604cd5363af4801a8a74fb6d528579d3081291e31c9ad8f33d709214446cbc8e3d2ab1f16180f79f2bbe5072cea32e2babff99f012e8b9fd9d995c01639b06cc1df78867bf9a6381aac362423b738effc923d86a531b7745ffa108a0e3227cdea5c583ab8847c83cac999cdc2b911d89a580df30965f28ddcdf14635048fe06b366f0ecd6c33a77d2e8afa9a49059f5c9b3bb551202fbc724cd0769936fc6ae75287aa8ff5ab4384c339b38d5ef09e4a74c154f19694f377c9e2381b97fe743b8f6cf5253907e871c45ec622d6dd76c9695f191501b24cb9c518879b0a90e02e61a8a3344f65bc981e391c5bb03b176ecd98567db847d40fac52a4807ca8af4bcd2231ff7f04a7b2aad0758917147a14641bdfd1bc0583fb8efa2dcbce5d68cb0abd597e47efe33bf939efadae0143697a7278084ff0738f195c34e90f513ca4693b577bdf4d02eba35c1445f2d86a2886b7a3abe771b9634b6afaeee2562116de19ee97a878ce68b81cd215a4be1308ebcbaf363013834209e2afae850ede232426e7efc294d3a76f230ba320a010e7e5b303dfad1a4dc9d97f9db11844149fb832f7d22a2a6f0a1b6f710d7c71f44df48db881df73f0f20cc18bcdc6fcd50e511025c5154c09c03c1192652739d6ccf06a9cc8ad53e888154f7b6dbdf5ab0efe7e15d085bcb591dc52864dffc92896b67f62cd6f222940a27533eee43aaa911c59fcec1ce77f83c7c68c8e04c1dbe1ec47e883010b4c65d734b61accf9e312b0342643f89ff175f13aae77313a165b40006fbd65eca3a4be5650def69bd3f281b3b602faf10dccb2ded2b940300140fd10d924d58d489abe559f090d0cff292181c74aa83ebaad68ef430db6ffdbd7894fdbc390535bb497ac9e68f7beec41e391ac365d816e753c60e60663d6281026836d7e7b12212298fb0f58aebe0c53a4040b7a8cb84b4656bbda01997c8cf62be92a0562584758db16c1bcc40b5f05a1f9f86064e4f7f571cb6379b87087e14c4783dba655749fbff088cbf172fc6ac1fab1cb482ed4463f48834eaa95906d2fcab2b22e6107fad2254a7859620db289d0e8fe25a91b8744f75734a496e590b7221e460db31cd0aad506d62347d392b1b056d2ca720fcfa042094ca910b16d2d934cc2608002da1189c488a0e9640c436c47093c7055a7b7a2e2da3d70eab71fad4d7735228654df1aa9cd35264c012c2606b47fb31ac3392c40045a60314822df89e292f3e7b838ce579b14a2eefc817ce078ce42ee1adba6c097b9c24fbf4166f203c470078577745d77ed3532d2cf74a586fe669cd82800286f9412311d762375432cd9c9367703b977e7a14cf23465545894db66fd45e289c15543d05502d97977c31d9298eca5a1147e2dd0a9241dc567d54045eb2772f6ded8ef873d1c9d6d463f1d2a7a4b923c21e3ded5002eb56d41122c723363b4f1e1b54646bb1af52f382df57cf200269af51ba4108af44699464a083c942667d470ed0fed153f62afa44121b3b40585eb972cead671e7de92707117913b36d7df5e32ea7bee18aca69ba420ba729e650c9ef5008c660d89cb816b96f9f8e01c7b500f03b6600cf5bf22038d1fb981c106ff2ae9dc869479e6a75c961c757f6e079fe309df2b4f6ecc2ea44801bb320a883608607dd7206aff767eb2e0580b15652acddba5592e86dd3cf781f8b8c46cd302457c1b49b400bc43bf09e5163ca238188f3b0e233492c21d53504cf337410dae7fc7b220f8ee5bd0be61c109f47cc01faee3f2bcee39f856e7e13321e5f29e08546522a16e1ef79d0b6a7630a66612df4a0a8e6939f47bff737be181d8e71329c0afe08ca8884efbab9f045c613e2adaa4b2ff798113d22053632980f74b7bc2a0fd9c11498618d11f82723cd337fa720c753551731174eb92c2d3e1006bfae2a4290627c624e12ce7ceb0ff0ee767a90729f5577aedc1d32322c24550735fec3a7ebfc61facea0889de5263e4cdb3b9c2d88099bbf9a6e1a2a01e7b8ba5bb076ef125dde5ae79b19fba45af524fe70f1802b5a6ef7c3bad7c2c99f57d4c2bd254b909da4b44c41e42df2b999dc7b22b6d241b25ce027666695757fed374bf0f27704c97e31e3d771c2078c60dcc9c10909138dee07ad1d384d6dab8ca3ae04ca3d8c2d98255ccfacd1842afaeb125895b41e02dd10503ffa45d22e8d0807a97011363c83f8bcc95bc549930e60ba0f22d90490bedf94cd2897247da9447fc4bac30cdd7b294d3d3838e20117b724926e3ceb5afc38a6bbe146534301563ae3de0f79da397be93a39277d1b68b01fcb24297d6e0554b30633d7579f954f698d3b7544f34b9d90bf6e1fe82d1ff93a4dd50c70871503624547fbf94afa8cc765650ac781f072a6743e0f6ef52ad07d6fe971e2ce19cce880a4deb4c70fe2d272a7987d701c9cc3ca588177a761e17585d1765cdf065df6cf9cb60b9b0621310e2ea5c675dad8e1dd5d43d4437033076d6ff86c49bc5c5032f05782219c63428450479c1d537450de27e69b5c52377992a2dbc8e2a5799b6bdde22277a1d8baf1c856ca074584ba48cf6f26c91f454eeb329d8d42bbb7d8a9e565559898e526961745b13e39bed29d4e27d7b7352da08f0f9a1093cb16b80a9fd0021fc1f4d9f58e728000a441c56c1fd5532ab4f76fe6aa7b2eba320f17a94d3ad5deb977f09de0add71aa8656a27e23b9a20f3daba393cf96282d631b2011c196c850bdc0ac1d717c52d751bd03775d0a8c4df254293ffd2c36b9ab6fd0b924423b0ecdd4780daa0cad706b08a0c531d68260015f0ea4c51cf640840b2077a21b8e3419e610bf81fb52f56759f60210a1c5f630a8162e740085def8a17f0072e187adac366390eeb77f1dd20c044d3d8f1844c36822b39b4c9ef8ae6745ad83dd5a8fa5c54aa7fee4be390969bc0beac5f90d7fc72b4ab89b0ac7adb6e06c7c90c6ef64c1770146e4b551b8385fe7ecf64f4aaf22111197426cd414ff20df6a48eeaabad2baf54c443d4f911aa70e175db811384642cb1dd3377b3c5b3b328f4c1ecc1fb44801c2fd5e202d0335747026703cf4271a1c0518f6df9d6505f72e7231201f53dbe9d49c96a2019c56e3e7d895c1f6997d5e3d1683693901f59d7d1a6063eacfe02ece77b29a440a6688538ad6f1e21445f79075cf713521c377ff9ecfa794f7e842d1c3b6bf582d962f25425ff76b0493a1853d23bb7ecfa45a56e11b06235514047f85613ca0e5d6b7716ceef6e7aab4ca831794d90edc2c10343a5a944eaebcfe69aaea20f0612621e2b39529b06f6cc32947d53dcaa53a6ef9b25ea2d6de95103a634d32c9448d2d94c509355f4792ad8bc7c199255775c64edb0e339bd9db5bd67a84c5d4771bd1da923aefc4907893ca9b50681aaf5ef60635a1aa788ec31486e8b18c1f2480a478d5331888928865a766a701dc74ed613e2fe50d8a47eb52b522bcdec2139236222ed7449bab19b1577318166ad4f15a224fbc5a2340973cae9b698946f4facccd5503cda4cd37b732e2085fcd5615e3ab940127c47c0d7bae99ddacbe4dda4a86466187e87bc5ec2d5c83479dd41d9324273ea5d854484c1f5e2e19c2644253662af39c618a97ef71a2169d97c39f80f7dc46efb6d2514e05973707dd1a2b525193db9c7703b7e9fb3e72dd6c6981a44f72b5b3643bda20abbdd32be682d9e4cbfc02cd0594d024f14006a333db190ec2a7a4cda41bbdebfa8f8a5ee9e55f21169232554361837499ad50ae096982d35be8bd28db5ba9a98c1e108cecdc6c6af4803c5a176380ed8fb8e5485419fb22854dca867b7064e659694d17c123e53a4acf1f744c3d08f4f3cf8728f472d4080e4c449ec3cf862ed2ebd46ddc09ca603699096e2bc811963d2bed90492c62ee92c81d2df60b27cf7e7d82a504db7f3ea4a0ed6ed88d3ea2074c72f0b3462ed7ccd29b241e7dfa4091fee67569e9fd2b5ced3b1b4b7e8f59241ff87bd101e86de31c6375615eb4e6148496e14a70bc22a2836bdfe3d38a24a0a66c19dcb88a889bbf403b35399855415c9ec6dda63faa5cb06aac46cd94ffd9da7979938995bb1a7f6f378c7e61dc016352af8c67ac2479ea6b1cd5424f63feb625c08bb658f9d4943037b49c02e8c147f1137bfe8815c5ac1463c12afeaed73f3f79f6e451d3988d42fb92b0215ed0332df1a9402425ba777a83d837db9b58f2f5205cd700f50d9de1716e73730f3dfc66a13c672075bb9b2aa48d63f49f376251ed911010faf2e62ebc087aee188c9e95805dd49d21a885eec6c0250dff390f3b6c9c5075da917e57d2772bec3e06df8d58421dc8c6efe4768d3c0078d5d9ba38e8729a0c2c0c200a364f1866770fecf03c94aa004f34b489d41498e244b7104ee7465bea9d6cdf85b2670f085149b094595a022c1e1cd2c7745c19b120384658ed5c11973c9e68c58db27f61cb0a22e95219ef01aca3869bfebed4eda5b2ad89af57255c749391b0ab58328af8603307faee5d8d7e6c4a82f5a74a50945d302842afb9657708b4aea0d8c1de9041da544d03591e97e3003292cb52f34d2b93404f0d403a3998598c2e1223282322af364f6151d79b2629e1ec6320e6ef7cb3c8f553728ea255191b0f3970faadcd5a78258c2452a06efb8324de72dd492f809e385a6d07ce687769689208597d700eee572763eb89b1de1def15b69b64a508445e4324e4ec2ad46ef35039c73873167c4d3a1d474ead0d948e40e99c1f76483e7e79ab87e1eb06293f260a928e41a620a9af1d7b337c1de8a70c86bdaddb5f1d5fc54fc4e98ee3e83771f2f101bee2339a0dd9b5252bcd0d5c8ff69a3aba7e0634a0656bea80725a1cf8710adc6bbdd7d5aa0fd2014198f190e1596a3a9310aaf433fce0078834a73ab4a3f4ad8d522036cd36714cd4f9fe24d8bc3823cd4fb215a03fe382e61226151961009be1957a9f6d94f03cae96d37a511b7e16ad52c3f1a2f665af336ac0d72b43cfef85333821747f44db27cde647acc11bfd60a75f1eeba786f6efb272ed2daf078b1de584e0a4a36632d0bc0b6298309cbab02ded69f926603cbba27ec303e4438501ff84fa5200928088a7cb41ed683b4aca656511ade5164b657b70c902ff4ff429cba1989be1e1840998a27de30de4437c154892d86f3b04e79286449701fe64145a93850e545fa64878db54bf60c152df02da6d1e41f6df0fc4a1afe404d3f3bfabd7418b6569e2ec4cf7796057df58e75c7a415eff153edbb2f8acae76b11f08f5557fb35361d6c3afbefa73a238a8ed02ba6ed831ee28a9ed3c2eba1b6e3b3194af0d4c9318a85969355bd7c76badf7ca687426cd1e34dc6f4f8208d8c194d11f0668e046f79fc6213e79df0b5b762ba1a0618b7a989153750477a951632f97aaea6d9511a5e4d3e3fccc8d0116c8de5a4d448a2b1814c187b1a1420a8cb1d4ecc38f15fec67b346225e452a7a7d3614659d57d14f3bfb4ccab3501f08c65f6e2f4807fdcfd8a7c077d29fe83af2190d0c3f1236a8242e1016a4f490d43fb5350366b1a0f0b0519b59f7f6df7aa852c1957c1fbca23f39896329af80dd22c5be607c8cc08af8b4df3b7ff5a9932ec2bd83c613738b4ef7e45b4153950bfe213d6bc42e442770bdbafddc0c2423e82a87004089ee07cb1eb02902debe23d4b79765f5e3b9355ea53203543445626711c28e480a1e4c4fba0edab08355e0f884cd46820757bcb1a8fe144096bdc1ad00f370cfeaa8056050c01d4adc7bc70fb2d12a76b96b6a5dfcf0981d50455b4ba42c5044af0e764cdeb6641d61cace1ed9ccb80c18531414fc6ddd345ddcfd1e919dad18e7784261aceb2ded5314765b19c85739eb4fc3ddfe782fd2fb3468e12713820f7ac8fe2c7be7f50bc3b26c55368cd6841094cbc2682e5503727dd5cb8cad2b4fd758f3d5530e9324286f7782fc3dc4d32af1fa9de56e68c127e9ef203f63858e5d1acc177e4ad54ba440c024e5cbc50fdd5f301ac6297d39eea26371570ade19630dfb6f78ded11d2c4eb48616d27b109f108079a0db2d46860424244b5e5ccee9293dd8fbe9a07e612485717037babcf722fd2d018ea403f54c6a49bd59376a06f0ac15d6578e43650c6799e5483acd1c902c64ed38274f8b3bfc3deede6b2940fe98231f1d3e40ae32df54ecac2767209c5f656658a57820a0a932ce6ecc929cdb776f9b1c3bb9426c33047a82df0b066f7298fa7d03a69f1774c21da0887b4539a562b0de6c4f2e44e018f1bd11bfbd261b31bb355100139963efa451f34696cfb0951f58a316fc61675ff991aec26352ed4ed7252a380ab58d417f22e8ffc77db906ed6bd767be494e806b4bb1dff68c201f7cdad0be473367056cc7e91e1bd96bde96876457d8bf8600bb9130080640d9491432499405255d295b4fd85417b2ee14387a53cfe6b7fbf5a850b417d4140d0e2607849ea7a2ff3317c9b338ad9daf4423b4cb13ba2accb71a2b8a2b7b4c6942392f4b7462366b6bb05e3939845fe690476be344a0dfaa8da576adb12cff82072e3556cfe6bc7109169ff4d85cc511b46361539794026392e73131053803db28cbe73d48d84f030ba2bc4a5d8020773c70d0957d8becda6393f41b2bf8a5d0c20a0ccdc6a143f19f127d5bc1d11e093d12dc11e9d5444ba93eef5ab1eed083a1fd6cf2d6b72279626e9ba7fe177d97f0ccd42527a45983fdefaf15c5fbe9314264d29ce2d158899a95991a9c00f892a84e620ce37c5a0a60d5d9140ff08dd202e26c1e2368b164f20ad290ead394e9bfd727f907a3c46b6b36c6b3b60ae796d82501a707511a77f107a1f36b2c2d3cf7fc4e078b8e53b4a030363f3abb8c3e4cb64e93b9c3d6d46c95466a511c964a9cf16f4c489a0ef20e06c2c94ca97f2cb52d69ec69432b46714beb9bffff04004b1a7f86d9949f0879ae03f5aa4cb603cec4aecf3cdec78a77000c7995adc9a5882f1e7c13df8b6db508340141d63a71d69a2f9eaa2492101cb91640f3c63d4938d916a12571a562936cefb4bc20f3081e8640f5a1511fff7437382b7fd8051ba539763619b8483191b80dcec74258af87a3eee7718654a92f6a62d10b7121f24f4520a7560f41a7280db240864105d7b189db1cfbae0f1bad497ed7b7aa8e018b438f1d3a08b239326268620e9596201a5736ad64b1a36d5605d5caec04eb7148200721410539e4dab47bf820166ea3c4befeb55e0993fd719438d5a5957ea8ef51a728522e76b3553d66e8440c8f30bdc980c2b673b90d45ac00f4a4a3d847153e6ee27345f971080cd7dba3ef43b815ab3fa33eeacdee05d9dafe17c1d86c36ea56eae3c7fbdac452cbf9f19331ed031b2f8c64e09ccf5687cde6330a17d35b21a1d550bc7649139ac190bc9e0f91e6024560ba8893953de296e0a0b0f11906c98ce0fc133e5a7148e790d55e727f47ee712b72badac9b7ecdf4847007b6381114c1f216d20c435ed6971afeed1fd4013d6a2731cf5c3090e938e408fe757a78acac1cdd0bb5c66e1050ad72898002847f1cff242bf4b58e081e1ad9cf9cd2825a956307f990c6c5b1c2f59906b20b95afbe696386e6950b98567a0d6ceff13bfb685cf348aa12f2008a4ae786c613b6d17a7286dc6097c996d62820829572301bafb75f4d2078c20ff8f646d23efa683d6ae1ae85ca82fc1ba72161b38a111aa5d3504e4580f7ef468ab817dbbc1ee0068b32014ee412617645ff855b2a35a288b2f7059fe77f3750519ea9c56eb977bde2b58c72974f976fe1149b1d9faf6dd0130249542fc9051d1a7ea28b7ca96726ec9ff1414e2a2d9b396b947f568217d97d9d882fb9d1914c5b46f25e20154000368cd9d0da3d093ccb372f9e94df6a4a228b3ec74c152ff03a8cea9acfbeddf6af324d47709ff37bffaf2b0ad52e0411221a474de582da820a46383d5d26491322bceb4aa175402373e7dc35181f0814ed5af405b93cd5b9277872c19dff4efe9be240291f02c41f294c6b11dd6aec7b93b734fb24a5d2c0496aae6d09bfea98481dd0f8b6ab7c691a8fffbb6023fbb1e074301ad2c51c3e679e7f8d4b9a867a13c0dc8f1e48b9626856ebf2eb85454c764e613610287dd37a188e698cb64bfb201984a59914d2ff3ded4b9fcf85b99a5237426","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
