<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0267dba489bcb35c936cb2b2ef8ec959adf9aae071e29990f8e29c24536358da7e4c546fe812809c66d260861c9ae27f95f10a5fbe7057028b14a6fb78931c4a335f6be9a9db138989dfc050199286c177176b286587c530614f3944949054013f4017e7bb6468e271efdb8590b26d13a370f6bc761375088d707a7a09d83b1e086eec231f1b121f470a466f2a04aaeaec4ab50f7047bdbc37d96274ba7219bdf5cebe89c1c457f60cccd8ab9c60298c289c46d63ed7be6ee0bfb82bdd73d4a48a7aab3d6c9c426688a8694659ed9ed661a9f20eb64c448fa30f7cbada45a0c6cf28f5de4a3f95046b5e1075a1b21e370410082c8a92ef8acb354a5ca8e82da45cc434391a53174ef16ef4bda359fbdf422160308a3c953eeb1dd7dfa2d0737a8abb9c7e6ec7f54b252b85c66a064e96ef37ac7023ebdc41798208967b1980752aa287192b1eba0c451b1d1c638abbd73ed87918f84aff304bdd778dfea986667afd9c1e551d2a44076e7a4158e0a204d72d811d4caa5ee425014301d27b854e766d59752d0598e7aacf1d6d57cdfb140cd2a8b8dc750534aee2bb0437a921c970856a746fdb315aa618e9f43f2249dc8bb4dacd0a6c182357d6e2cbdbe888c8fe6db90ee3c8e26dcd124283036a0851da4f0b9265c9736cde3565a716586a2463ecbc6c35ed2788aea652ccc438b6716da99d1f9195206b78a77e4f730f5985cb8f0f689e417be5929f51e090a1adce30641dde61324c99fcdda363c9039a5a68fe7d6470d311f4c7f29e68339220d58544314af815293b52f9ff874e8a3cd39c21fbd5ee657c954a7576c9a9aa4a10f3a5c4e6c352cd9816802f0ba7a57655e6667ffc5b7052c1527a9063961248709c5ecce6de458a26674b62dc74707e7fcd9f54c8f9d02d114b1eb87b829f67db7550ce1e33e9a084cc19b2546e7c7bf11f27115fbf7f775a9d1ccd6c5900c95bab7e153fb83a1e08c0a3e7de315afd565de780ff7208febeb201db5a3dfff6b3d167c348b0f8ec72225c8a4b2b61248b8fef12f608c29f7c0cfa8777f035e0d6417c63093e16a848ce5b5d7b2cafcb101a412f3fac112e8544431d68bf8dd8aecc659e978d0c6b529150207a8350babd6763229f962f8975b67e9a5cafef406894920376589ab41adafc0b729302bbc463875dd6cab75e0494a4b9bfc053fbdb4dbe2568efddee79447c4707e1c723c47abcf9d4d34e18ccc016eacd55224e84fbe1430ecda4859ee1f0f7b8bb85b372906f82297986df8906860e4f0cc5c725b857656e97ab474ddb463a9956ede45eb96c4d3f394cc837a2dfc7fde9c141ad06a7f8c3caff4a185e94fe662c01e6d9595830203722d6dd20b5abb422ac09e6908734c0bef980355a56bab6b88b097bd1c1740067681540796f5d7ccaf7ef78bba6d413ff29f219800e7e74d132afb50a54e4b35a3b7715f56152ebcc3316a38d86ca9abf36ccf68a2a07e2fb646c470189c6edb999aace4ce2d44efa9aec1ea9322ede198bc942cfa48fca4a93d89f8eb840d8e7926620ea2a7094415285a48f1646a37241515f9bfdb0020123a57d6e9ee02af458422819a606121761d629cc174d8d8b5645987c2faa0cc90916b5913072f3b118a3e5cc85e6095a4869fcfb7fb6402c11baf4067ef2d53cf955d09cfcff8514bba2232f81b98cb8884db2a651af46f4bfbda52f682f2123a91c799dbfc31e5a4b056b4a9dce3c7f29a7ef95ac6d85c87ed4139c2ad6da78f92f4ae2686126db22293080a1b6c424194e75e76d060058091737124363a4498109e3727722b7a035b04630577c566898020489677ac60e57b7704b55d541ce7320374541aff9a6aee9c1ebe52cbca8f5a54c883bfa11cb9e086c163a075b94729885e976a30c2b749c1d99d0b88de362b7b3166df52997d70664c1363cd0ef31f55b292bbbade4bc874dd839523773298c585947b37d904b2edaa93ce690c75d9e3c20bfc0a8904361eefe589709df547528a3ac6318b455d6931a2d8890b97edee8051272d0af77ecd31fbd4793468708524969ddde1a997b589d5d36f4a3eb0b4debaf1edde2e2e4f4503b6491905bee395860030818af4ba62dbfd2fea9587598bc74810a9811c6f7ceb5ad6fb0be00507a75ba65b1f05f54e048089532f0a4e0ebd74c766565fcb8947b3389213ad1339ee9b0bdd0d55dcc4c324190c2c6d7eaa612c00a4601f85e704adc39fb04fe30a622586718adcbcf8b209d5c9379c31a0deea31eb1b4d80107c96a452796e4692d4114fb95fb02925d57b12ab1513ec283ef20dcc45f4bbc7ac1fc004d7dc069ffa11c55bfb54695f11464b45ecd4c15776933d1dbd510a781a4e1553f069d741031a94bf5f9ffc2bf57b98348a29996152605aaabd4636b3b0c08e39be3d0070d8b82253ab8f1698d3cd61ff5caf86bec8c74c38fdbbca64b2a80b3244e7debfaa1bf76244ef20bba25b7e144e6e9f39cf2fd3af6628a63ef78dc814ead1a5d21d200fb99bc4af1788a9be3af62d47553c1ddc1d59eba192c35507c0b6454b75cb3c1ca98d90a22977e04902373f7ebd84aa4e89632df6997a00060d63d21c59c3a4e019571480b38112530cca3f770e63c20080c2f1454dc3f957e4442b7a463151930e05c2e607d77bf826b142b15733cf9546e60bca157f29e25bef39ca89b03e73b0018de72ddf5e4332a706242b5fd8bf557d3e247e409e3dfc34193c14a9e7ff9547e7d392a5f88755f77fd614341e5e4bf970410e673869240b5f87f796415ec83207b6e7bc512a28dc461b4a60c14167b4a157b88da470c267c23c31419274728b9525881d1216d5693f9d43ffde630ed117083709364455628dcfb6a0804f5d99036c7e07d78b84af977a7559adb0a28d87f40e23524567ca34a77874ee68b4058f87292aaeb63f6322e63797110346c0ad2fec0558b8543a7c623873304e0f8e28e8b9d817afcab0d6348c8d920734def1661574bc49d3c063ffba5c9c6e14c48d6201cbf65f60141b2ab4b5cdf8f248237a701fe13170eab4882bfb3626784119e44531fc73fbe04dd139a360395bd8993fd6ceadc49d55cf87b2d5c368964c71006b3a09e01204e39890b06c2a40a7e497654a73a139054c7d24cd6b576a403aef42d99862cdd6e2fe96448e57ce42d5fef4226c61975f2caecaf186e07d41e7556ec856719568664c81e1319261ff252dbc27457eae1df5a5df5bd8a1b7ed610b24cdc22a857cd10526b37c0198ceee2e530de9a27e8a570e83a2eba467b7d43961587eab92f38e21f983cfa4e8c28e7c7c2bb1cfbdad60c5b04e14db476db5b0d30ac20ef6c3650b7e32935fd7f0ba4fb11bc96001382e5bd2a4cb5f6fe74cbbcc011919136a157cf114f65d6fd1315de5871a8fc7818dd04ce58564770b2abfa73f4d2149382d7a49e6c4f205fb070cc991c41e1bc4bb920da80ad6eb076c8a99c959200860803776298e9b545295b8e066adff18a5a6978f987dc92071e91211818be198b4186a4595e4d9e46c464a31ce8f84e0839025132b262e7e74060e3f3a1f9f6d1504f35bf252226c1ae268555ab16b5d8af4284a812200da699407868bd6ca21e579100b2b36bdc0510e89540832618c63f2274ce3ff61962af4ae3da1b9165f1d071f7dad828e2e9fd7bc5bd7c5432ca5c61bde4058b052071d55642d4a38110b85489845470f72c04553f2694712b78eb11e30bc5c54824e7f59982e33e10a471f757d2574de8477d65522080c9f492fbb6f10a3688b01f40399cb9a698961d1cba0eac04f7f40210525b934b4d44701601a28014b58335d694644a8245944dd9d0fbac194ef144fb7b26c0db20d645d48236a5c5630e53705da6b551c6358cd7e2fdfc1a52f64b9040e963f61c425b38c607c45be156bcd949f0ef640d2e12e640cc48876c0813854a8b7ab56fb2646989bfc28d98258e3dc30bc706f2b4f3054923631f3c58a7dccdb0027933b3e7356e2fa5a3e11241740fe7093aa7fe95ea3f83f13ce7f788a1239a29648401ac4db1d5d0d2bd3a4f8fb63215eea71b635622332b205717e6feacd5a0a96acf3c0d759b67e95ef2fb5464dc7d8a05bcd3442b0bf89c992e158fa9fb6e738577ab3ef5d5136443ef34d60495025fe2c5f343fcc874072a0853c94e19086f2b87e03c39e4686bded5a2715100874101c6a987698b027446f3fe2ee48a724d4b7988f405c15a6f21d5762c5a7423dd872aa22a20c71d1d404e08f43e5d1358874d4164023b4c4a962c298e2d23dca1b41b6302100004ef3d1d806d760a14aec093f1375424cfb88b56ed7eb3fed8f22915edc2572599281dd004c34eafc9830d827d638a7bb7db7d1bd847a796d9d29474abc0fab8330e2ac6a817ca3132ac8400a8bc472d0eb40f57d1ff52288aa0ebbcece15ee8a6d0f1b4bcca31c278a548ecc54a5dec54c5ef17da2aab56797fd578d76d24dd7f986397b7b3b864024f6ad5f356ab77df4abd280b14f07c1d7717edd587597fa1388f1a4b2a4e9320960024029069a7e9480d339e5a7605d844bdc7d961e54d17027c2229c933f615115e1c54444f3571c3c5b1a29c34a68a86510d4bc2480b81e65b2b222fa44efb58514f287eadcbc92b7863eb82264e9588fbfd91e200fa4368d437415180829d40655e65778f1f06e8ad6b278f080c90b5167eccc5ab0112e00885097432b93091ca520d12e4be54b73d6772d1ae1a20b7e6ab8d3f8640e775eb0f6016c7eee7e083d4c3e0d1d3aa034021d8ce6f8f362383722057f8c461784d7fa89f39b6385951a741dbfc112eaf7c429517179b31ab4cc3e1fa8359012fa7d99d7f0f0f441f963525227b1a844a55a2de0093c7039f66e228c8de8e7e543256fdd9ad738de8ae9443ea0270b8f3533a18864ec095cd83b73e7e8c80ddc27790df6babd40df685894dd79488c4d7349c5c4b66e4298f3a5d834e272a5297c2a4a4127f0fb927417732f45e8af03f9b6425153ad89a7859140348d5a19b8a8fbad8951bd05f2e73e46a1ab7934ffe86e90852ef5afb7f00d09dae2daef1f3c2dfb5d2e85ee9f860d7eb3c70684f591bfdec55a720ef9882efe8f838a90ab74195c8fe085170f5c468c95695f18262d37ba4aa41479cd0c9f80c819ca667d8006e3b54c361b5bfbe3b5804b8d3f2fcd2b7651f64d93f3968e8d3fea24e605925cb295a322dc53377786db31054c842d7e74654ed8ff2460470d6724da1ec5d6c1d060824e8eee6f63b5bdfb210668d76a038519856329834c6d96c79d4c16cbe2ba7b475d74ba94ec4ceb31dd367b69b7853776e6bec41b17574be1afb4f723a4cf39c23fd7abb78be2078ad8d7c400b7f2dca2ce03ac7b9133086ad6f6a1e757befc627620924cf89a0723986edf8afeea0d62ead44d05ebdded0d2adbe288e681146af212ff07465e1ef00b0120ee1ffa7d28c2cbeb0ab6c18f024bcd2e508229292bbe1b03393c838c77aa5d28105f284df2a0f8b6e4519f0869ba5204f67b3f8bd1a1c70073399628941e169c174c91ccb1b7f1ac70e35f69d113d8d3554be794c25798da97b17990b06f1f330e87f1ea4728226f41c43265fcb1dd245fc139670cdecea294aa04083757117d57b86b059e0cf0de2ee34bb9898f61a1f48ce1bcf5fed61c4f624573daf10452ecf90d4324244081285b4d7c1ee8133ad55ae5317eef61e05769656616e02796687f1f2cdff7bcf8bc5c66244b11db17ff17bc5631514791ec2c0f2af717d6325e03578c7f2b111e957ec92081751af9809332b5194f0a98ba2158cf47132942351e71fe4021fd9667ee030ef4109c553a2189617fc3ded575a8d2d0ebb05d6a012fb879089266ec54196190d03380016f720630a44c4193287f1662749b6599437ba9cf268b75d5b16e07422aea52b4bd067314cc64391d09d162a7140044a168d39961105e7de40dea91ba10d2c9d8c771f734d0d33ea2f44412aefe18719a44617a1a4e998f7ffa7b2ce9a8d47c5e8ab77249db7c8403ae62f88ebdce52c232d10ac8dda86507a270377d7fcbc8531656eaf1cf5243784182bb7997b27ae58535e410737dac6c226aa1d41b71566812186a4c68102630c6670670e7783171ed21bc238ece351d858a4ca0631dbc2fb816e17b8a5a7aa37e82e7d25a1fcf6bcf08f6cd2f9af24815a50fe30fed622e6960d52cdcd171395d99567cfffd19e54b937f7c604c79f3f0337c8d126625cdebf7b0accfeefd1cfc5f3bbacf92f5c3e8298f70dc8be904ccea151e53adabb8b7c78fc7cf050b98eab0b97774052c42ac8f4b40f34f13e117ee55d79da2e79f6fb16b4f5bcec91457d48fc59f9c6d1e4a4c7a3f68bd9553379514669620f82a280090eb2f020c51ddd79fc81f34d97618bd2a6e52c637dac4d556169584af70f36cb847b4b3baf6dce11067daac483919138b794a9d1209e8da503cfce5a64c2cfc062b7d951ec0e6423450182b065c3b8b3ff6ccc51430f470bb5aaba7b80a3a412d86db1763be2669520ca9d2da4374c5196a3db35c0506a3cf61df19d50576e92c5527795638c9f9db678a1640f258c0a5ebca381586ad1029b51fdd61f9f090522d90dc2503936fcfbe8428d791ac728716a0e2ca56670afbdcbfb52b45a5a88557960c46330ac1fede55f5d1aecf066d8d9fc72a881bb5e1bd92b43624fa2c0b3b1792c132bb51928e88148fdd34ff6a4471e2e5afb1e0d8aba66f44f0e82308143006f1e9573be34cf72fa1b46d8cfb97de96f077f90283b6a5ca62a45530ebdde501869cfc5878dd19e46ec738e27e3e49b1f2579f3c786d32f3ad1022b66eab4cf738e3d50ccec069d7b28a54f45751c8a8ece3f9fdc67e0c3d5d8e56163d5aca6d88b16086c9acec3fd8ecb00704c3adb82dbf3a3d8c864feb327b3c402ef4a85e5ec8f04adf1382ef1db6aedc88c0dfc24a3f97d40159fa2c9afd7668680c0b4485726aae833047fe946cd5311d661ef557da9517151aef3299448a045861b9fb4e0d872ec96c1833c2697114694ca9cfbf7fc1c93cc219acba8e91d0dc8eabb53ec3ba4605d927f272b8dbb82296384762a911c28ee6b950074ddb6ed0568ed626667d1bde10b626f4e4ad647f55049db0dc893ed7808b1d2a579f4d777a3d930a9e2fd1b9e1ff8dd58f5247597ab043641e559bfa1bc4a3542d21c679253a8ee8b67959987070ff82634b83f5c39c4c3d730eac5bc0e3397a79898f9259b8480a9bc12a51959fe7bd25b2a2ec7c1fe8c3cb593cdcfea8d26d5575f92abccb37edc53e7c7af8c1b1cdc8dd8227fe7f0000804b61896a33de0d4d756fe1be18d33b1539243329fdaeb32c824f1347ef88c65b21c3d4bc806adb9aaece5592cc722af9cf4a055e208baee1f95af09c859fd73d629b1ec1448dfbd44b0aa37f80cbd0cba8c424125e09a9dcdf62df62bf839213c307220d8acf02a345fb8622334d6dff00f9b8255fa5a496e685c73f74de70d548ff94d837d8ae3e86b176adaa22e5ca11f7ea83ad29d260754f089b0cc968b733e4fe3b4f17b8cd1237de8f783df9683a225dbcfcff420e92fe6cc49b4a55ac634fd52f8c2dc566b543706b1d6a3419d6522d3f2b47a8970f9e66d9cfd1885ca57fd4ade3a2a52e906c39894675bf4c5c854302ecda2e681418f1f7fd00f97864e848396aa503f8fed5064ba1094122de7543ddc841b2cfc2b40338778cc25e366b8c1008e0baa8e2032a293c68f9b6a2d37c0fe4584a2e51ad477792ad0bf4145e7bb755c9a7fe3c79edd09848ad9c64e9713c85bb1b8a9aa16c8776628949d1038e71c3e1727e7c8c4e6e1b84a2e4336a300c7c0fad7dd5f835a7632af51ee801ddc7c39e066e827730c8c9c7ae75404c284d27ef0f0a7f4ca4ae52cc4f513749a7a7aea201ae9188adfb6d6138f91631e59832bfb680c277beb4f1d7f77671f722a67d122a3b65a5c8d7a4481da779a856a6c580019115ded68e74a403782273249e1edfe6e2e72b27ef9c849b7f4c251e1b30aad59b179ec6f1955fde591152963c065bbca707798e17e8a5db1d827c29fd5f502c71ad67c3b5d4e6db5d66394ca76b254906d7eb3ea186ac6c670bb4c41d2e995af9d9bbff34500a51969ff5898a039debe49f193724a382040aa54959a509daf0716ef158fb738a3ceb39e32a039b1abc17b52b99310de1c4416a922a7ab4bad3cbe854b92fbc0f495cf325425b3244397df6d6feab630b800c5d68f62771ebb3e22507cebe0d42723bd0f7d60f0b6db0af4ec732dde73da876cfaca792521aaa6d887311e9c8c5ca6d863ba544c6e967ce0f7cf6e4ca7ed59571b9db762b90802ae02d7097b321061179fec5ad8c8b3804d9998f15c3f355c6ba04b6f625f3d12df75f2982f4f04e6072070bb89beed8277aa9c81edb149c97dab2c6f27d6f9dd25711ec1fd2fe9e25e6528f84eaa3a192728271140a8fba373d33cbaed0228368b16e79c06d2c483202881510ee15ce306fed2825506a125d2d5737bae0f2a67d755eb7e67056b6a972ac52c81d4e500c5e1ce40ae4afae650a4e8ac2c7bfc22df311539c83287b96605aab9da30aead9a4bd044e01b8e7ae3e1cb72032eb7dca32e23c1d5f92768732b86e460f2af093026ccfb727f7a82f4f97738c54096440781101671cfe90bcc37a2b1d7bfff6fd853ca10ab32bb3340331bbe9134a8e242efcb882e02f9454a92757f3a22f979f80e545b6a85f2b4e6657e30ce0363ae628b7793b24a46599bf7797600785785d792f2f702251f6be7fd8fb4d08d330db4db26e5877878a82f24e9ac76c5f863a05599e7cb763a7c406af743b48fab76ad605883bf298689b49aa75d0bd8752b8902788f22fb8a01f35e44e95221e25caa249b8e6838b31cd71306c969c4b340cf5da7ee9b0e05d83a19179f4a8802e37bc751f3d00f82a085af46ed5aa8095a52a5c5edbb72c8aaccb066a2ce74df5a214d82b2063425088e7c3912c2df209a4c24cbad027a8ed35b5256cfd6285b10deb4212b12b9ae75782e33572075aead9f400abf9cbfe7aaaf773a8a0dc0ab540b6d0b7a753c1f5c242c5ca4915bdb569fb8ae9d4cc8d96dd47536c0eb45186db6882573ea3f746109fef86e03d51f85744fefa20b452335019d95cc617d494a6cf06b563a472c22abda13afef37a77287822578fbfeca039c7c6d8b8de415aee0ec3a46acf97cac44405a59e8ac8e4e9ef0e853a11e063b39bf55b9c1570dbb6d17898fe7cfcb5dfba07bd8def825dd0337dbc1f150d6b241f1249ee69f57ff8b9d50b08c4de6b5110c4d761af88bf7260f7258014f0c18ed7ec30afe0e2030a6674037c1639100271fdbdd29c8693358ade22a4dee1820c39f2e451aec6ccac8ca24bc5854598db02958171a6746b367bd145f07650399508967b8b9ccb1f10f2b33dd317452766663990a34e79a9bcc183220bd7fdecc325658445cce4814cbbd282abbb824698ff1cf307bf8ae87ed11b25a912431551fdc1c28fa2b60f76650f99152ca65b686d47fb01d042a61c4fad294441bb65fb1eaf09fc6d6d734ade9cf9285e0c796c961552ab9d4565a880c6a9609149838f17a48db89426bbf1ba4c6a65c95dc0da6f195d54e750310eea536ab1255dcfa490eda3d49d2fd072d7b3042b0ba9728824e1e651245ab74c1e6b0c93300a8ce01bd85a18bf41896c04d163c29554fe6f448869fe7ace4c8f5b1709a513f96968bfcb0c02886b15b29a25f8576b458cb7dd14ee4a26444b266fc0c84bf3f402a177457f4ec577ab49c9d033cd2ba5ef0885ae7fec1d3ddab754346590f4b91218cf6248345860fa9fd0203cd5698446a93858683b2bfa0bfc6525d3b57f2da40705e01e283eb0d994c137683f44e175c395a226e2ce670edc9e04eb9fbf03e4fe7c53b6d48651b21c96cb8553609d2fca82a7dfad0a147efdb3e89c7ed2192061a6455f6a4c42a5c4183d95b8e500d2fbb0efe53c47c0f807fa6b3284d3c7c50db5accb99d64b41240c29e1fe2c024250b68afbece2f1b4f0cfbda29e2d8a44aacd79a4b8308fbbf1a778b8a2b2a43210e66938710cacd25389ca2eb086f6a2f7a5c4dd77926d0163f64ff6407540023d2777e473dd4b3799cb030faa26d7b42f4181f522e4f221cfb43b1918ef7cfedf11d3b2beb79b41bc6533eed3f9b0497566e0ffb7feeb962bfeffef097324c6e39776354a3a353e3148b2e13314d847004d54af736cad27b4c3e9bbe6c393c85725d4ae5bc6f214439f4068132d2c69d21e2c1a536904516b08b88771bcb98731e56f5ceab7416de3a2b03b50091151a705ecbc047ae25dbcdfd6cee079390f353b131994f5e58a2c18af8db37bff04f239086226f96f954f553e64a0beb3efc890d4d8ee885ea1aa422bd70790993fbe74a425ba7c61e64be0519d5c40d7ac6b9aca8dcbd2db758beabdd3366639b66d14088bafccfd60a61dc41e5822139ede4944e45ac262a6a4520dbd143959f470a01d198a1a09f6dfac4320a424407e288693554ca228b35d4bc4a87f51a408120bee5ca9313e43f6eeae339ad3bc9c2afb8e5c443bd314c6d456dbbd363c22dbdcbf7cd50f532c589202fd25553184e3da41eb2837ca918fa5cf0d88ca85af430a91c1403f60284fb055bb98eef2c41eb4c303ff4f85e04bb2ee6593dac35d01625b827045047954a8a92892f68bde3552b7fcc888fb1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
