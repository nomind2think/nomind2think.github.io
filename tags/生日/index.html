<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a21b413c7cebd6c12e9070a13533a4404ecf64bdbb5365dfa21cbdd554e29866c105ea9de9c567715273c77851f862311508abb9c60227aa157c181ca457693f8887cf9c0399f03ab9454a60019b5e8eaaa774491b108703288a57442a54bfa6a0843a70f035da1fa7bb6e90a536e850644cafa70ce776dd16aa7cb6314f8b1d0bcf46efebccbc73303f00227f3cd252156751e51481832ebfaacb92f4edfd65844fea9ba3b547a5da887750c2e47f078886b009bb9d9e6d660b1973fa609acc7f2cddb2fd7a114acb86c1940249436e15080474987f90902a0b0e699d9fe41981c103d612dfec279ceea45c2177e2397e6510c4a61f4573e9c981d09c6fe237b93fc8e030cb47fd9b79edbc78608025069aae157946e81f148290579ec9f8467a2f91e83021e987f05c4f4806a2e43854e7968e108c9be628dd07e9bbb584490cbce4804b4ea20ce2b2d74daf678c4d347113f9cf781f2588b01334ab259003a25cade01a568774339783233a5a3851c11daa1d6630438ce801f49279795cd31909fe4f2d8f354e6a72f43675a0717c6a44298ea4db2fd9373d8f5bb27ce8aa3517cead20225a7ae4b8f1ba390cfc47666d06425237650ba1f2d05dae7d96b04d0c525a475234597271b73495f48fd63dbec0fce55b0e196d46a6ea92c7e00914190b05349426fa7fe5d75aee2dbda540a6c35588dbfa481c702e5caca611b645ceaef86f2ada3bd9a266bd3088432a68844ce5ad8119c19287e64a75284483bd37248269e4fc7d66ba5bb102c4c496de187511c9b2eda0b667e2cda65dbbbbde4569d87550c00e32a003789bc347fc34e6fdb418347ac843bb0535300da6f07f8b0d9ef5873878b9974fa6382ac8ebe0ece297c6535c3c716962a729d2432cde25a0b0823819ccae9cd91179288398b310a457d9b1e4bfc19f319dd427531eff7374eabf7ee081a1b9b5d73dc037411fdcc5c1837599e890ef6985ee213fe4d1838ec95655fec9bab0fceb9363f97a884242564ebf7f1cf7ab80d1b27a3cd46d436d6098fcee95b21f9af0470a770700b3b8846f030db11f2d8798c02f50cd549cdf686402c3ab60635cdb0754b519926a2532c1c5acec20e9f8649d9f203ce96ac00bc8a53ff63c88fff746c03139c8753cd3bf1c3441bc8b20016465ed0e148725f371ea3fdb40a388e916743896a8669d6e49a127759135def7f215db5be818fabafd700b12885dbe8bdec3681055efa56b2e43c49ee89673f30a39ee11e726de8d0822d6d4403c784e84e9b676ca56883874e2bab381430d5e4493bdd0324565bb5e35410b1ebfd849e2fcc83e8416d18823a245126893544380194dafc526990b9ce8652ee9384c4e31bb5e25b670952f03dfec687bd7ddcc91436d2d48e6b1693b1f124cd7a225598c9f7a4ad3a6775bf08af732ec6ce7da19527e7a0ff1081e4b53a6e784fe4e04a69e454acc081cb350227f480ec2d09c60e8fe5d79248bcc63940619521b0dfa7bc012346002558174c7eeb956f67d31e4ce35ca04e10ca83a1c13618561299a0f7748c8a165b61744f4ab213afa169dcd90351a66cf1dfc09f2f0854c164ea559f4f7ca3a2eea32fc262bfe07a5116c7cd3b48c5f9193782e52edd5b3e64fd1047039dbc41e103122a5c43cc9e385e637292ae4436532d346ea5fbfca4e0d298587520d6ad41529cf4a4ede164a3384e223278c0e351269a4821584fa0397b49b66f3a522719030f5b5bfe7dcccbe14c7e1869186d9cfd8ce8039b199a6772b98642385bcb0ee354164a73eecad63fbf5f220cb20f1a0427268172f39915d97c6e2378c53727453236d6be8564a1dd37c11ab976903aa451363f6d456a5016a10b14dfd70c3f7c46f2b3730d5c79efe33642aed02dd6c276fec2f07bd96f11a64a8aa8bb50cb473f59fc7370c83369736850e0cef6e9238df139f6421e0558ec94f9519e06342d87df5933dcf5c2b42cde539decbfbef307fdf2f281c029e40aa17f273dc711a297f5b04c2aca142b437965cf8b71088d59bcab9c76895fc136f0912a6d7a090f10ea8e2f914935046927c081d0b635f6ebea94287cff27bfe0b1393ce3859f6e97da01667208c873e2f2e23472c3ce8c32018570b0cce09752e7002c848dc13781e5a10228b65eaf652c5beb3824678c9f09f6f78266fe3afe603e6c20b08e57ca2713a6b9cda694d91e58b7be046bf659ecd742ccdff753e033d0eca8c7aa2de5890ad745e97248c0227066e1156f08de23f95e61defbdc6c78bb774b850815b6d51d0774a9e2af3afbb11385b8b1c107a9c06ac8578893820403d553f12a77403b6037521554661955a52a039411d2d7fe764fff4a84bea58bec0daea4616dee519d07c3e833ccad0ca0ce7713acf0c453788196e7d8da59fc14398f80c40208edc3c298f713527408c2c6bbdc5f2aedd0d3f7cd59b377f82fada1c05e7d696e73f7b3efd61218a2ba31b720666fff2ecfbf6c43b03635e4ef377bdb06b9677c0f2fb245ba5529b5bad6a6b52208c5dc288d60211c1b26c28f46f9304c86929cec607aba96a3111be62ecca8640c3e041748722b3ad1ad5ab38d3c0d951a7ee9b0aae72d598434ef1a8792a88b72d176f9262ae4e79f40eef1045b82b27960308049648f45a33bfb939e7fd138a9e0ff6f3dc58cef87df30990f68807e5c58eec660f5719d81a7e5e9b6a214cdfec4b4ef2db4a3371d52797ada39b47b5476fc08ccbe9270f109918eb6635d17ae6fb3b763908b4f9bea89fcaa743ad9466dcf4f1d8b26b77adc6fab29c5ca1c8f57f6aceaad0f7e43f39500d0e6e37a58a881a6e0727528de0727d356a4293bb9a3c4b7aac55a64546819b49b7617ac64703c20fa0050ae7c71e7e92e3a908013d0ef9d408951ad01c4a06820572927b646d7fec80a0ea8526a6ea03d547ebb6c0bc8c19cd0c0a8eb5e72a4ef4362114df00fa6c26511199f75b1bbf62f09e2f3cfacbabdccf0101942029bbe4c7877e0657794f5e84f1e5a8b28631b93318a68aa88e9511c7a1c6c8bcbf30b4b34e5fbc4cb3dd784c1f9505c5f0b3478c525afb642a8ca980d6c78e7136d4499ae13bfe1c61f5aa202b7837247db6906dd62919e0b52d3e6ac6f817f309486a73e8d66eed65cc6cad6e8ba38725d894b4536f9e920973f4613a425f0dfd8cded050d5ede89ceeafcf1a579ac33deb24a64206388d8f718115c6726f059a93bae9ed20fa8e6cb343803f560853f6428596759c1a43752fc60904c09f62b2c4ab3f080995a01fa62a148e0dadc8dfdbaead4b0cac9ca0c6d3d7f8ddb550950ea8fe3e72a1394d1c48439cad4a1ec5f4c9a3c9ce1c27db3a426dc13b65f64a0c7840dfff502af9582ed70f6e64189a254ebb418996b8010e5c2dab062fe106c88040761232b1ab6b03b1aeff7256d538db40272f7198be3b1c167196d3a716873e4f58362be6c979380df46a3c9d7693ca4105a6b52e550c185e9957b265d7d4deabe5da43288770da0f2e4faa31923ccad76ab560655c00a5fadbcc60d39b2035e9f2a46fa2c598d5b40de51c0799d3a947aa8f2b501637f401e45312d8259dc24092496b2f193deefcf3abd2d1ee7f4117f6c8570336e9234c2e5050d5c084b778b52e37327b4bc13cc2af28cc72ae697f191f2cf20de42c68f83b0e9d15b4ef6ee2e96a338a5f9ed09cdb9bded2cb75d0f3dab5b2c58ba1380310285123333862478ae297bd88848121044d853b4572b5021b36c8111734ca3441bf37bd4bf92fb07accebda6a691781c686bf970b01c906eb1a46f40d5ad589b2c31aa75d5a892da2c8ba65cba8cd863f0a7af62e495f24f663714fda758d5b0e03ef1a442f36472ec7568e8673044c541a1b1d65a7166d480893e0f569031104c7711108a354ce4dee40626baafcb5230677917b0cadc3bfb3defafdec71fb51df6f2af2fe4d9b143eacffdeb0025cab27c57121b8fb4d2ce792e5d03511f85386db3893016d4945ef0ec4816517dd7cbf2c12586fb7437165d5dcf12aa65ca690d97656b749053747b2cc23f0a31ab8de03ac259d0db238922500827e30985fff5821f156a4b6d2c470dc74f574021864af61ed937f758813ff2b9a00f1ca908610d8339d5e6c0cb3397cb6b3a54b34426e57091e885f67ad91202637abea8a44658082f86f467bd3408f77d29e0784c0cf0ed83fcf902290a6011a21d220f26ec92f621f5ff530e628a6609348e5d8c7c920e8d57cf210bb8ee5c1d91f4d39f347c395ffe476d9f77128253761033970d72ee7b5730f4d5489ad896bd2b1a0575f1a273c14f923662eb03a438a77e8b2875ea6dfdc27f2c1c83b9b905d8cf3b854077f68d4aab125d05bcebccc4afa6fd9ebbf2ba70aff7d87c08a9aaf8a6cb238ecf30ecbd3809a436e1109ba63c02f0dc5f45d9be7b1092b233c74695d2b01ebf5c7837da0a999f23bcffb31429e511f8fd39c8541a0c87192c89b2bb28ffc8b540085df6935ea9ac18f08bb18702ee6851fc65cbdd1a65437673df5988eed3bf92644773772731884acd8652f33eb34c207daf081f5e5f3797d36b56034f6f8bbeaab4dc284e5c3953ab0bac0b2ab67f587b4be455d151d8760ebf85b953977ef243d47575ef28426155cccea1490bd047a6f0abe92efca2d192e9afc1fac3fe34557d9b503640f9ce211dc9d1d603df1f0c9c5994c83df6278da3d564081b6f8a304aac5056066da57b2eb9c48f0bcf71677902e4cb7d1ef951e123403df6e1d7c4b39340a7d7382900be6a4dd8430dcf44e2a8f3b9a917198fba8cecf51b85a31451686c20c6ea3d0f56f971a0137ae6656467ac82c53527e8e754d09ae7fa9721c87c9476c726cf686d29cfef940eca254a1fa6462767a4a620f73c2ce6387db025151ea506ed30182ad3b18b40a80bbc8f8bde5281017e3a17b338fb2a3f06c3afc58e1ddd3c0905825a1ad0c0ed739bafc898d4ec3112ac5d25771fe37345f8a118beb9bf0f643f71600478529a31646c6d1597cb3aa8745e22d690e9a49c6109fb812a9bd6bb99d386d78a39d654f705778174cc6c7342b26057b89393c369b9dc535ff657099d5bff2728801143cd7430688d9b37f39af60329ae86a300a122d218d3b21743bba1f704aefc6bf25327f515d2de98d76cf91070de8287ee9f8f4d04646b421967bbe36fdf0ff9e4057cb37a5c9946df24e8794728f9e340e0d56341b57bee437b6fe87e6e7d9ef49f4f690029a788d475b024569f6062b7a79b9f2c92a741ac5c3d01a3ae3dcc36fd2124572c20dc4495492ff38191e65765ab1508b560c9bc5df014c52cd1daed00568077f6bc1a3e761721efd83b386194ee101ec43aff653184e82da806742811976554d1854de174b3d07896f065dc904cf211bee3c8556602441436f5ccfd878687b3f371a2143e881f78ec4ce671ee87fb81bd7702749ec5b58b24a6065375ba4c420e2cf16b985a4623d1591dc93f522987570c27d00ec1411245da2972eb1d8b42ab018bf433e782dd893bda274b9fdd8d34c85c380983362226596a66accf797d65a68a442fe89ecc14816315a146e9e843752239717e4613b13b4833c553368786a3f5f3bc703f6bfc11ee4da81566b72eb5207698ddcb53990d94d28912a0558d7f3dab0964ee19f8d2d25b75f3a0034e93b5da9b7b7e16d9abf602b838b8d1471e72a006b37015ba391e8e093f481e02dd754130e48476386b95cd1919fb4a0eb0d64e2e2ef8871881c8aafad4dd74d6b6c72ff3737d9f748356a4aa7d5aabf898f3a0f4fffa8aa7fa605efc915fa221a2061f03521499e516a4a618880c2df1f94b4811d979591aff4bc16b4550e9397963739138db0412047958df4ab5ab52467e5d7383d835f24a80ade27f194090f3cddec3658c1f1f99a1f18d421d95cbf307474b91b243b713eda449d269657ec21f39a5392a67864f3cf03b02e7cb5cad27755e9aa2fdcc9b90a77d879014983c6c5ffe095787f2f77f5ac08a4f840860f5968167f99e37afb56952eb39c3a80c903cb59db02c38ab95ba6bb4cb14a2fcde13a57b7300f83c506e534268ccc0b66b42a02c0a0cc9e0fbbc6a5beeb24db5557cb80722304641a96410d8810622a9127ab98529634500835db69596228975176f3133b0ab8cd32c6f62d991166dbcc30d9a51dfd1d81c138333eab23e53df53600582851b9d857f227b2b78c5996860229919d007149d372f83bcbc7e89d2704d043a63cc36cb81e15580ba4a731541ae4589e3f4269fc2cef0a927eb6286bfafb2db198013ce948345a2217746cec1d2407c0dd37bcc6f880a0d9137db4a151d2fb012af50c79e6431c7bbfab615f39d0d31ccefe3864dce27f214a1f7d0a37d121cbfd559fec2770c00e0f00370deaf20b731cf1d45b1857298bb25f6188a8d7302dfc8152ab66edb3047de4bfbf2b31b1010fadd0c3e8138933459df06f5ddd3ab02fe02b38406c025d38b28afe61dbe47851ff7ab19a0ab5d4a916d409d605765c26087c6abab03b96a217919e30953757c853742742a5b0320215ec731181b3f5c28c80b034e0f80230938445817790d8ce7201836c1bfddc77915a2146d6c2ecb215f3739deed587d10b3220e25237efc5850bfce847f5510bc8e5b166fc2aaab299844187028ea970eaf6328c712bed39ea35e7158ee9c2d6573818a9f654084014e969fafc0101e7e07010c7a3383c209ee9c4cb2424068c7c05fa606064e832bd441cb11402d787d8626b601b6b26465ee85df51e5a42e22d216c1c93789e98712404c37871d5b86df886398f60b937ca2e78d75fcf87aebe3863b17a2693aba6a6332020a404b78bde3e7b057e7959303d5d627f09dfd4414da0b47c75ecc2f8333f670f80753a39dd728ccb9ecb80c3c464cc848730b37ad3203cef46043c6d4753dd4c3359da75554279ac53493538841a3989a973234fb13f1e9f2cc296d2506be56c6396f40ff2f2effa2e3cfa1fc66f29280abb3595dee4e18eb06cdbf49c5feb1aea53625d69d6e4d70165c28785688b40df6d22fc6576aa11ba475a2601d3a5d45277f0fba4581ce334f000c9afbd64516749398b9b67c6471d3948169eb4b8cd3676ce3fd2fb50ac0a7a41e5d2732318e10cfbf39f534b89f51b383337ae455ae1324c3b2ef51d3c32b1318f6decc787e6711ae114c2f8600b326d42f0322a73ed556b7ecb135fb4f9882026bdffe98681eea6fc5636ae2e32657e8b0adcb2ba2e1edc6707f91e1a5d7e16983cf13738af0bdefed0791e8de4242f45802daf7b71a59a3d62ceb612e94641bdb7be372b921537763f01885983a5893f891e95758a93f9ec05edda3e3682fa9de31859d2badf6be723b76e9301e4cab48d8bf8da073c7c061c7c37752726763ed303cf749171e358f547730cb99c5706692b3da04936f3557ccec686e17a1c2180ca0cdf200770356f3630e91e0909f8c0a8822f50eed08569de7ef6bcadd39cfa81781aef771ddf0ec479d9ea601225eae79951f87e4a5d886edccd1429121088a81941f5e08fa0ac59e454b6659784df8cf496e7d51b432a7fb71d5b28ffbbfd991a68f0e7e900698ca6a4cc804174a8dabcc98bf4542ee6960ca97602cbc56d79c98778ebd86d6695c27d224f9f2010ea2ab9510b04758d771af28caed0dab541407d8d972bd3b77d5b3570930ff73b5d43beb4fc04e72637f4935ea6fd0afe74d6226ccefdccde28cb19a3931df587f7d7417d7c72c2a3ec0282d0d13b5b034702d1c1a2e2718752906fbbfba721b79a2297b93c32f23127510a62213065711d3efbea93c424218a038e5b7dc088f9f88453b7a1ad3bcdc69f51d3244f3ab9de7f4e7a6ebbc461d1d1f6621018b8ab642e5e52e74687e78aedee5a2d6d92a7a832a0c26de5d00da1a07bac52b68dc7665daf9b4716efe9e34e3e70b5fbf6b2dc2e4ee24142698acf565928d7adbf392621effd11b2bbd308546766098d0a954bdb3ff3eebd2e659356cc412a7fbbef3acf3e38915be25fbfb198dd803a71a0d7ff630f13139758c5ca4dffe0143c15e5089504218717e3b99a5324bbbbc2a915ccaed647e6cd1f591e5f9f40847c19eafefe6303f8e7820de07ef4eb93e4b68f9f393363e76f4754a46dbcc3caf2d476ff8e421d0b64c6049fc2ad849874e58bf691d8fd8b6db202b58955acde625d4a562b04ad7b81f997f03d1d76e14c31120ecc783b43c5da10f77a1ab09e33869e2824d44a098ae8a57c9387cb8545fe3789d13d1ff68578e4fc1089d42673279ba0dfd2ddc685f45c64d003ff949db7a684219f4119a28ce1f9a6861e0b6002b0fc03a3d80fa7a40fe5d8b57ee72d5c7f154502cab7228f0fe28230cd8474392a6156b6caa22ebbf60db7d24df3ba940c1a8190a8275465db9eccc6d7211ae311dd84a0f8a859aea1e90dd8f8c7552c99d2674d781628ffbd3e29429dc04e9558dd63bfce4b9b63b4fafae05237a4bc6764275c2f1bda332325ce3db627d09dfbb10199c360cf2e393cdd10ec9ccf35a174da52c4a788a1be067217e2b93bd6820e73f14ee0a1b9a02156d899a8ed726c3f844baf095a8efba483c0da88a1564de6a13d55dbd6072d3d184ea8a1be878aaa6cf0e34ab5147bc9d9572bfd500fb8abc6b55f2c6233c70137a35f58576d84f3bad64ce8539db6a4a871d8fb2a752ec407c3319ae2b9a68ec2e5229fed8c871e64d6845009492e343aad3f862efff8ddae5ece81fbd6ef1c4ae93e68fe00b50701cb002acdfae17d991c77c78977f2e2becb3fa6417248629cee41d486cee58c47bf9ea0588099fa93e95b4213254856ee0e157d6acd92af548c32edb923f123c158953608bec4415065d13287b0b4a5782f413f86ee504ecf6df0a1e8cb9043dbdf733434442beb78eab5bcd6ea15b989d790e412940aad4a4853ec15ba0ff5229d6db18b910cdf82eed3df49c5bfcb649eb4fd8b9062a7835604a0301199713dd0ff825d7146f5dac8dfc772ea34b0bd0643947d1ebed0e1baf5445719f8935a7310f773091bd0bdb17d8975c8ad0fdd2861331e486f916c57c4412dde2879a15860fe1aeed90d818606b677fb7321603db33e94d457efe1132f148ea9bb90b917e4d9432188d2a9758215db5200733403e600339420de06a62ab7f10dd2e48eeaedad01f03d58dff565ec3ffdb323b554108ae959bca158b17d656c4ebc14da19edd06587ff82831b504562acc9ffcb1527bfbd33b9fee10ee9034475fc83f46716843accd2063f2112e8bc92a75927f109062c3489f1f3596085b6b7c47abff0b310f59052bc29f94220fc0c246cc21ff7a16127ba8ccc761a1d9c0e5d10c0e0d33703b97927fa31c8c60c8f67ede84bcaf5c84181a4d41a3f3dda7780b388353e40885719caaae68ef90b5a7db21d67022a3d1d8ad612bf590cb0329c18e751925278b83f5bb85e2acb424325c5e1990ae2ab4dba581a0c784f855083bcf876c3691ff4979d9c02c9847bfe94950bf2f2e79dc57eaa584a494ee6d35587989564898b781804e9c55b832e81ce7bb1875b6e3b1f1cd48591c5c8a6396a8cf3c8ecd371dec4038ac485c7cc271b3a4da99ec5984082e67333a1644a5d9bd91d05c26137415b7a2416a6112c90122159f955104ed926323a232dabe491e7717eb443b9894220f007caaf0d2c81560b9aedd17b9d10316b06b8336705a7654eb30ffa3ae4fa34a9309c23ffa8ff43f5a1940017959423b3afbbeb32736e892d8c9cec3e69bfa9fb6191f17d00c479b246048dbf050f9d8e67ebab8108fa5caa47b221fe1da9f06541dbc7d09576b232e43894c6cf8ef91b1eb4722559d2108104c27e9f72c0d3c38c0946df8a156bcf6996f812d09262a658dd82ea046cdcf17039afb65584c30037b6f99334f7e7867f8430ecf7c891044a6f6e77a7ddc9c3954a868097f44b03c12b090bbb16158edc7ed1208f162b6209cd1e189a96db84408dd7aca2ae72ee016fcab42aabb3d219e955eeb7ffe1d396161fbe10bf160dfda6bc06404fd0f05ff9930fd2ee3263e3cd1abe2f9bb91f259eec1c9fb243971387160d34aa7b9d2203d9274d4fff67b07ac82a479412a172c04c9406408d3e8bc6fa83fe82bce7cace986fcaa0417f977b92cade1a05c0abc8f0568c6441567068eefa5070bf892138c49095525c947d88a7ef7366c60dd3c184c4ffefd748aa0df40edfc668071f0ae5fcf800dfeef71b930a1f3e26a2ec0e05c39db450bd033920c083543d8c25b8dff9e494dc7103b1ad91e67b60fdc8358b1da8e95202a0fdf86e70f6140ac5acad68ae6a9df429bf99b04153519a294f18110ee37a6df35c204f006f6e3aceec57dce207d372490ae1541e74dfd547353315eaa00cc1f0fe4ee988c8a0c0c46ed692ed4c6428c54a50923815e1003e1ded4a4800af0651ac0385dd747931e97f5b5184b2c75f6f902f82f06a12be039d724192136addcb2d8a88a50b87497695a5863074d2a807eebeedfe9c6c080318403ead03eae02756f3a01ff48c3bfbc500f3edb88003348d29eeb2105b0b0c2d83476bdc140d9f0e733e3e9cc8fe6b825544996b7a10e0e9cd97f1be7e2f5446d2b85d705bf8b81c7cc760a18300351c54d785cea00a47fb00b05d43efb8a9bd355d13b9820402b5c633d2bb5bbe95c269f6889b7713432544e782902b79da91ca38928e8500c4781c2b6275bb30833f02cc94d7081ce1e03634add4bdf04ce0564cb6f09c59936aaf37e9be51551eb7b6b55118fe0c4ff1794556f373e6b778eaa282a4d3fa611e835cb125337b2d9217098993db1f9fa2060e0cc11515aefdfb59cc4e5f746aa1f65d78a3309d3cb9a98932116c9e8202b3acb2ee6d94787c5ccd8e9d12e524f3a50c7a4d0ebbedd094273da65797489a8134a572f769aae2e6e56b35fc63b960025991d818ce71bc7f5513e995a7c8aac120c58a61846ef3a0fd456c2b00d292465df997e6bb429c0ab9d058f759803da30333d1d8d429f6abdd5bd419ded68b746b98a80a87d57b9ea1cf4b9d8f55118dfe1cb78a8fcee0725086c2c839b34ddfa61c0f0d88c01c21f8667c71aa53592082e25ce1009d53683e5563eaa1d74ad75b179dfcbade3b69bf76857efbc803fff3cfb0e1cce22a1822295968f4a9bb6a22d76a9f3d4d2589d7cea8d78f6afb30ee7fe93ccecafd4ec3dfa369baf58331df546d37916c5a1eb09e6a6e4e1f3e5db5cb18bc70dd3e4d7ec8c233f1b6718c6fc85c87109d4f8c16f0214f0679a46c242445d041e5960ce5ff0a043278df8b0155bd3be928e32d935622026b61c23f50aca2ca78fc33b13a31a2263df1060dafe9a0ab4b3e3c3d21439487e3fa118d72822e68d89b0d695f2aa09d5bc45ba19aeb46124380b2a45fd9141866d289ac64b7cbbb5e5b20368252825d91ffd2a48dfa056dd0f47e54a90e92abd9a2ecc85bb39cbfacf45e9091fa6a1910a9c33f4b14c75e67181f2119f2831cfb9c5d6f46d8e4dd499eef0afae821d164d416bf22499f6288a3bd8b4ceca430f58ae25f3c3f3b81316728effdf9a6a5d3ec58037ebd10fa79aedc005480727e146c6d360c21ee78cf8372221c0afc891cf617d99eae24d9b9abb938e5a7db955292186388006fa7388b2f156ca8ac7a3225156fde2f3d8fa6baaa1364135a6c8df0f97ccc6bc7b35ff592e510cd56d246dddc55332ce27a42e93cbf3166e9245b4f4d21d0332f847957d177dfd4382d4d46254cd1bd1c66c497de2fd0d7dc9889378da7580ccc948895c13255e3e85ce5ddf6ae0d6bbd97d448517d17e2bf4283d876c3aba3d3838a7943eb426df3dd5327863f6ca19f1d10cc09324d402c3453c4dccbb08076259ab142434244a5d5e8cc4873c584e465097d3f875d9803fd517d2b120bcce94e1125ed6ff6e674692e8ad5ddad1cc5ea84f0f1ccb9085627ad7503a2e52aa8c4d126299950278f83e37b470630efea6d7f48850589a243b8a023b627dbcbe2cf0fcc0bf73c2ab2b6af9d81b80ae7c556352b6fda2763c9bd736e424f732c1ccd2b3478c46fed803665576627b32c1dad9997ba598e87ee9d4a14cbe9a3f19d3d197163b10a226f9d8c35e1ce5de2afb901abcd03dd30eb10998b9833ee4bff8b179b0fc9d0844151a323c83f1a6a3a36d4a493f34c2afa731f3f76f06d36f9fe2cac84849beda0493c394b126a7d634434de2960b38d78015ae5be16b182aa96da50eea62623532f235e5d23444a57869dca930b003741f473a7e626c573d7eab95908af9b0c13b81ee939079b2ccf0d5ea6a25cf0ac4d4d7dd135954ef312d6ee8050ab15889e5121202713d86ebfd045d8658cd6b03f3de02d24d10615743c28fe6c67dc46f516009de48d21e0691e3a4df78df3201ff57d8c5af84cb815245bde47bcb1afbbc4b6ae104e337187904b61cf5813132a8973c3dc59412aba52f9eeec32be8eb8ae1426fe7be8452fcbdfd72839a2f479f809aa2a267ca4135f011aab4dcba95350edc19e490cef1ba7a5c3a37cc03b805acb400d9a75e1a9630577c91b875fb39d6ce65b54348ccf5d6907c1e0df88885a4e2713bb2aa57051f357accba8e10e8e3ad5ef52bb5ad33b63188c9101c876d9ec308f635eb841c702b01af88b447e21f42c379bc4c61d8cd5913b65e08322149a4d956b8d8c1f33b4356cad6a029834056010772550494657e2c064dd5e72ced2a97309b5ed40eff5a22411030300231e14a65b677f725efdd983b53c7c865e8d4e7d98e9ee4fe66cafd4120c27bf27342e2837a8f728262d77813ec2f99ce125c5e794173edaf35a03a0e915a6a2d6624e5e09099fe039c536021763b3cc7e2ac9db44927a0c94a48af75e3766746d81f8a0fe8764086c4575f388dff58e2c31cadd94d3bfdb47e8fb968f2b9353856a54ba571b7dfc952b5bb9ad09c4d75b488bfcad4937aa721df92cccb5cc5f8f2ad060006205786548083def14e7a8d290b6aa517478f0bb99ae857287be69a7d7d031b2f2ddd286bc7fa76b5293394d487704f6727e519daceb69a99128308c8de5f4b4ec4db0ad77befbe021767b98f519413cbaad2cc87d51907d0e9bed58206b8efdaea9c0828d83561d88498c3b4184a6b14b180418d6ebd563543f34acf7ba3c394fd88aa4ffb60de2ca4ace1aab95abb825b2386c3c78b81a439d8348737fa349ea98e463779c7bf562f210a7d274bac10a6831d663ed746459348977629e980fbd2be8fae27dcc390f5572d154f40cb3fc0c100bfa97439187fa6a6272a1dac9699e08401b2c27f03b8eb4ef74cd9f37d88ccedf3814bcdc2ff62d195738f7cf2c8fc5c48214ce59138747c17bfb874c50103fbdeb2fc10bbd600f23dccb128b9aa8dc782ddb15d928e253b6bc5a0431295c7656b643b4ff4279200435e0a6b2a05f92aff55326908298b588a426a4d7152f9540a98a894fe680c7c396f08014e758baf166a2f23bda58c30b033d06beeddc1bc0b8cd8525c44a06f6e1ad0236ce9c1d85d0faed014b88e93c78208e586435c8ce08fd6ab3a34aca64576d211accff12a179522cf82447d1293c5f67d75f6651fb5f7966c070102dd42406f4be55bb37ca07badb00b770bf6b1bd0c08125c448c596a404553803633c8a805be33b43867e97f47ba04cd3924325de773e95365e51780547f83dc2fa707dbe7bb23aa7ea675c9b5bcc86831c36fe8dcc9ebf9ec3347d4dab9b996df77a946c46ff611ce938b622a19b575a33836cea920cf0a6cc3fb21ef98d6eb4d074bc5ca213a4e70ec0007e9abea1aed793389d1738eff0d492e634ae77ddb692069b921eb6fcbee4f821309a71b52f3e04aeeefbc5decaf9dbb9930066a299ebf2f83e89ae76dabadaeaa198ca23e6eb6fda9a4e1f14f89fe1ca1eb45ee31e4ace6584515d7db268ea74c05e2c3c8b9c4a357853dd7a909beaae6b7572c9a2acd61ed254f220ee8094726ecec131aede4066298769c4a2629e409675f713a0cfc129239bfc7074f48e5ab59a5d67f85718ba194774dbe99faf9fce55d20c2226bd03692991833aa3ccd24506ae9d7b0beb43f2fb24debf3e6cb4f999e4b8942e4ba5928e967377ee9612fa89dd10b1cb6e3c5baf5d9572b21c9df507bc0c6748121955c0535279d3a687f0a646dede8e9e829af620326f766ad7a635d7e8d4ce3029484e9cd9b5b0b062b6e8d4e111ff29fc644c6d1059be1fad2b7c036eb980aa53083611314e0aa322ab1a78cb452bd61e28c42be7f9af38b8963c0a92043a0be2034b230791de0857a1275f4afae31fba076bf09ec746970eec271ff27c30a2f3db1eb2941063aaebace4defa96be3f54e947b86ba99f6cad023cd8a0dd1ff7faae823b1ef28bcde94c5587b88741ca0a3ba6c7a0f34d942803777de89b6285fcd0c5a9358ffa3c79542cc54e0f668c03a3d7c83bd64a30287c7b0b4dcc93430f1bdd28364f2c070efe8616934d3d2a1e37d43f5bfc64702acfdbc2845471a57399f15391f59586bca8d5214de3716f59bf54905a43ca38acc0414b861dbde1ba7c4c834a82d19eba2850fb444243dd4efb5937d89577041a7e2f8fe8e6fe19bf06fd1e2c26b5449c2f9a21f4e7d1ff7e386077ce4f5f271347689cd421dbeed82f21d88005adb596ea9d5ca21f2e845a97551b2e84967e11e8ccf9fe7a1ac6c8aefc078f06ed2853db9acba0108834791aa9dcb48ce258d01b76b98c4326d6352745053c18bc84dfcb9bf8a49ea2729d68a16c0f56c3d0af4af4fc1a6c008b49c088bfc3b9d242d0924286a1762b18fa9d5b88de689a6e8b928623ada4fa86f843caa8fd5fd6721b95b16eb31411ab11a22dc7aa1d2f393472ed03842c89c093dfa6586bb110d92012caa11dcaea9d7419626adb96720fb81d9183e25670a5aba1751b9e539b08ec5a90a8cb14623918e57c861857f268d1f84cdcb1d225135498b7e549b4f32d642ffdcf503815c6438d256fce8f5f63ed4a54d2068507e6870245021c54725cd68952ab7f92ba5c6547f96a0c66c1469d6147ffb1f55707f59cee06f39b2f1894b4003154b75ed0b60305e399e8fb4a40281791c53fab31ab245488fd6712bd979449e40e6e1458a58822346f6a6ef3c8d21841190caba16f2569edcff438c25ad937da0dbf4364fa4d1808e90bec3ccdd389fd23dbd353352e2a7496fb5143fda32a4b786ae7b3a122e02d53f7b96d57fe3feab0e70142eac37783c8256e3ad7488ffc28d4c2becbcacbeddd2713c0535a0957383a97ebfd3e3a52013acf23553ade23b7d873083182c863983e6aa7efa18e562627fef3dbf5abaae75676abeb2f3348a518030babed85e229ad32cd1e6e79103e02f2ed971db34","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
