<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b903d93e883e8a5329d0325b4fedab7db8b973412c9ef7cd4f5766546d1a2ee31716a87963730bf0eff9d52d61e21666eb7f566178facce79e695f77ac3d063993df08f5dd1b3a2b92f66875e5935b4c9200ea6abd1f9c44526531f0af679d8c35e429767d8edab03f7087497275547db1be6652ed57d4d421c067b7c4f559464b637387793b4d54985fb8e0f479a72b3d0f21ca7ef8bb812988f3e9c80a46c0f384d290b97761e033da2ac4e90ede6bd78f2e32bb02315749f201ecde79b0b17d6075ab8c27c1df88723080b71f08294353e5271aa45316c50e1330e6c727ead3a00cbf66cdb6fdaa1932e8d24bc1e33b39f518d34003264f218a2215714748c87866fbe23ffd9340e571cf636accac9e955ec128612a81b82d43b86d12b8dac89af7b5618cc5c53188ec5408d46e657ea5cc1b8299243152bc9a9ae240c7f16184e4a0744a47304993c6a3af4e03d5dce20f86dbe31ef8731e5b1c11e2bbc54582e058369f8c61556a028b3945cca7a4a0bcd89cd505acf8b47ff6c48e861aa284219e28ddd9d4d43ac9efda7ec9f626631ec9c0bb40eda1aa40a946529769b25ec95e9fe582ed8a6a9713869cc5b9f9bb7e11faebe650ec14cc48a43f3bb272a0697913f5e91f3ce1fe643184bb3f7c0dfcc85b172692b3c1184011a675314f7be98b1ac7fae9ea374980bffc2e53bf9bf54061a63f2addc5f904faf1f6ad7a7cfee4e958d86f640cd38efe071a589a21e24550f1b4c8fecb3e884b673d1e8db99eb8f022dfc9699296d1203db09259f9a25446d72776c665aeb1829ebaad03e80dce3adeea96ed2c39e8f627f53d2c22eb38f0de5ee954c24bce3b89877baeae6b73469ac73b3f9d22ccddf1e1f9c7abbec99de6dc32a24d80e0791fd5837306d04b22ffdb8e61540ef0d98a18b5c1236cb186e3a3eede4662fb17ec9d9c2ce76e257f6880837c9f374bef92b8c7313339f93b6e4e5e1e15b9f1619b786d99384ca167198555b9f3165db10fb23ccc6db9f7e5288059bb1a2769447545c53d3693e57e176c05b581dc94c28c5b0cec578b9ecb98f00c196c2bbca38e812daa4a618a81c7f7b6b5a5ed147e1829b2268afc41e3f2e059d4550a8379f180f61f3fc236fd8830a4c316fb8546f68b07111a67b0a7fc1614ea484a3f640cd02deaaf682311a7bd824a4c82068ad5c0e65bbd68074b8a724cff7a32eeca45f36d06d9c4ba63642dc81191eced686f07bbc335212b94dfb7a4bb0958214f5d9b22c9b2728b620e54a54311d6236e0719de41f61df55262b39e447a3db92a1ef1753cce3c6cb236051a1cff516df0ac0d5075d93140dcb86c712b763deccbfeaaa6e6094aa95fe01481e255c062736c276e9878fe50b05ca026f06af54b8b08dbae5d165f269ddab783517b1e4c5220e9fa6ccdff38628f82a358e78a71fc74428ba39e92eb148e3b181db49603c08cd322c718c8fe32311761a0e5ebd29f3d2dc82face498a32e9a449bf04c0835de58aba96b99ab9520afafa92b946532417d089fb26fd538628041c575d8167421b7fe78b1019bdecd27ad989a9a766bfe9b577bd7f66293cd82b016d397ae1c44561bfa62ab86de16a971e2553d35f4125143f4c5323e57be3b738877cbd1db48506d904fcae8611364db1304cd9dbe1f33fd946885986f04530693dbf984708009c1bc590873d34679d44004caeeb028cfc08ff6d424fca03780af3ac7f3403c0fa0f2e47475c1060ba46953109dd1b86d4846fa412b9da9c3f1d0c94378e8f81ec02daf30f8539eb4db11b9d18d8b1c80a8b0d29197b5f9ee1a5c433d48853972d019c6d28918d86ab199b71634bcd4141e30ba3d8cfeff75d22f51df6607e5bad7d490a16b8beeff5e6b61bac1ed10f1ab19a0adfa948e71b546ede11e69582d484654028403fc369ad29ac0fb2e23a7047e6c978ef798c275536c5655ea1983bdf1760dc40f7fc92218aa64caa03c55ec32c8683776a2ddb4e6fd5138f7ad2d0ea30e1d2bb00d578c4a84531f3e519415557b3dcdadb484e394c0e36ec07f4cdd6ddb115e360a999311b3e08381aa95325848efa88208de61ce9ff7b8c36896c193791091139c61e985b3ca594e0cc31b32db94a05a3201f17e78e1845c09764cc5f753d22cc9552fbdeb16487fe0d36f802d4f6eb7d7dfa8990e2d622ac12eebfb5338defa6a6a5eadbe64ab34810c9bfd787e9a5bf731004ed7703b074492a2d1c39476370f67a686c9a61968333b55da1cd249cdacd084fda65e0b9e1baf330bcbb6cd0375b3cac8714bb75e317d08e9c1f5ac9229c3d200eb3e1ad14c2572f6b43970d78376339110a38379085e831eb6a9df54b9985e87cf67232b79887a059a961e7082dc93744dbdc7fc8b7e956fba432cb2e1a42d10422b31bb388990cacd3d7e249e6b322428b5a8ec7e38169c1fba014cbb36afb5a396f06386589800e6844bc5bf775eb35c97ef25232434896e3b7b2eb51461d69d233a0eca066ad247f628041e96055d26e75ee6cc05decaf1ac928da75085e0d0bf3c9561308b25b0d2fc6bcbe2762fb8a483849d0d618ed0410f1217698388c5c27876dce3d5ed314608ffa53c22d9933f1ebc8cdfd6c5227b01c2a367c94d3e4c691099595460a8cc6254aa73776d42aac6fcb39f79e44c3e1cb1159e55960b086df5e31fd3ef1db5ff441c54a18c6bc6ced7c2bc90f4652788187eed1de618ff4293a0948273d23a794d271f72b7be6aa8d15fd547ba91c1203fac73e3754080a9b374a28a97fe24a067002964254565ba2345277390474421f4675d7145945ec653fc2bef36dc75a9a982f28002b0d8979363a95550f3d219e6064f5c8dd0f7a4241138a02477693a59b34360e30224071686c3684afb2e3d4b396cfab9859c8663485358c4a41b1a468f1adcc0fd04f2ae804e745cae60548cb8144634fae07053e4c2b7cda08c12f70d2f8caa724b19c0c6ecbfb09a20570281f07add79c93dfa20dbd8ce6ba7ea48121faf9b571ba561e50bec3f14d6928b5aeab5abe11b900007d8bbfe4710905e0d702fb2146f6b8b8ebe59f4f74a99304c92267717e8167e02e85e75145862cef319d19e28c7f379bf5acffacb2defdb1af5d30eda1be8fa74af44e86062ba50a1d7898c556bf9ab566a7024742384734bdea896c53ccf202baf1999630525cbf166d5130b9fb6095c3f76be2c2304c164205b88811987410a9e776de0b89fd88a94174cd6fd0ebffaf506c0e706725f89e8d95b3747521c5ade7f883f741f15db8af6f2da1c80e21952348a71e96e785c90913e0773e7e1bc307841e9d693aab729592c8ad6b13f89bb65ac0d298d06b7c1f2fd19c4fe95ec09f5fd73b8eddb841d1045ce81829c8e7db30c6f7483b996d88e655f7e047da8be609c362dcd36f971b91c486ca8324450ecc2d118e13a01736dfaa70d1b913103515078375ce79b0b4d2ae138b9e896c2f7e468ed49db3ed935e512e07867a177d39af7f956fcf901e9dd0f54ba5a36a4263a49ee8b110275aedc7fa12f0758e884a04f66b9323bd127f516ae8f4f0dd1a9a5c5192c1ad93a3d3d8d340827df473c070ef2b24f271cbf25e3c07d99333701ae38b9d955406a56803485f6a0e712ca76f82792665c5ea4ea0a74b1703bf306f217a2a093f7c100d384c3a4cf7aab1e642d60d343290de967d80cf12528de96512dc63ae07b87b60f35eacfd5cc87bad3719bbcf97dff19e69b91e068964193db3fbffdccb5fd8a594b4584ec815d7f411c9c1b229d93a89dee459627dab9414b67593633831100c4a24fb13104c756f86a78a3a612bd31244ec4004851036c480aa1ec948adb7d42c31e167e37faf27b0d122dd78ec0d56faca9f84db56dd6dc572a49b5117bd828ae110ab314b37dad1fdd14592a39135223d46f2745890514e6b5f6ad5cd63a7d845b8c8816eac5981fd9632afc0d2325a404d852330be1ea72c1dccfe1307089415ea1072c6a205255eac1f6dfb863cb06214d24a00c7c1d5c448282c6874334799760626d05c9957b886ae6c13ba1c7cb4bae68d010af51d4f45e3521a0cc570c0f69f66f176ef67867e718c9b5edd2bbdc432d004a3ce9b5530a2ce603380cb2391508654ee71ab0c78e74d429c7071027a5ac90ec492f2caca1612a1217786b1a6243463ba96f4d394e0b281e487bede322383e9407f60cfe359055d6710e324b98ae182bd6c63408210b9b3c79713f197c3fea2d353179403a8192ee5721982d38b078304e6902e55cdde44fe14ae1b2640e952ccb1d488da4ca9000a2a7ccd93c00eaa974f6c72e4745204b1324362853cfc4a113aa688ee6961bbf00af838f3c10284872f50b950192d7ca7ec29c9ed7770d8af1d95e81a59638e369c89339e4daf59cfdd044a33a9fd0ab793b76571c81cdb2fc801a554f869847a8cc72e2a017d48ddbf581eb33f783f517dd3a5deeb1e9323ccfea3181e947b2d2a5e5b2aeac667ff4edae3ff0b17b2373c07cf696406ead0cc89c27d898c2fdfb5b1d23887cae81ce2de3563335c60eec0a89205c30d8092ea36680b6262f1cc9b655d62b3b6faad2b204d303a53b0335746983ae94be0a82ed7a1d270d123171b13b133de451944ce118369502d3567c9957023ab992692095057113a09fbdf018e43e6dab3395700c8c4cce396a71bf83ba2a8335e67eb22e4b1c046dd6f177ebee83f6d9b60f1d398c4da48fb855dea4ef8166d14f1b472bdb3d9f05750267838c30157795735641e71cd8aca4c7efcf5151762228ae31e981a0677f7b137caa4f0ac1f0ed24697e4fd193f536cc14ac4684621b7a033ce7d5400de5330dc1da519fc93fb380a7aa36f8389aa0b19e841c8efbddca37cf1d795e2a4f92f0b67019706309be32c47cd23e19be27a5099d5274c43127f96dcafba6640d95609b78190f3afffb3fca6263728a3f402de6544614f76c487c2faa4b0f9230f04872896e01f33d9c561c89fb8628ef5f6a36920433742d9b243063feb9cefcedcbd0e6fd824c6a10eaa05d3fec6cc3f1777db8d44d6a681991874540bf5b54d8fd52527a03a600f584d879682e243201ddc34ac9889efe79c0caabe4f5f5dcdafbd107782557b42fd0f1bf4286248ce967723153682bf2307a4377c2834f7dfaae224fda34bd0eee46aca56fee7b0bf56902089deccdccebdfe1e6caf8a94293e5bd8ce9f1dcca6009cf3ea3e575e2b62cb3f42b671914cc3665ed1a1b83d436ab121485e1218e8a5d6ffe4a0a80762e16cf6921dd0842da3c8acb78165be7c9297b2a213d72d6406cd0810c9e1d7e6b9f0ac0c52e5c1bd6fd7932fa5f1e3a90632bad649a0186020c8c892a1c6c9bb795c8ac056aa1e08e1f40b21901bc696f78b0609cb3748567ba0402fb30420231f235972bb207668e716885955e99157b35712ef3707d79023c00885331ba8ef7e9d41a8191f880440a0330f0dcf722d29e74f9b9c5310386d9288de28a4d11a5917eb2d0676ada54480f540b927cee2c4e8fc7f7912a48c077dd155b0f3ee8e3915d21fa48081ef1666cf295a65055cf449df7be7946993006be0842638a4b79a737b72fd51d03f0f1b192c621a8785e9ee37f17bd4a4e83a9bc1faa04d8c13fbb0b78346a627e11cd765054d9eca8ba37dbbc684725ef2056e4794991e4720b5275def4e477be2bfb3961a98c4a1c337e5fe3d0594c305b29303751c25f92ca7be3413c577d1c818dce604d9b0c15320478aa684483bbf25dd6f0ac836493a9bf98769fc3d118d50b5257920051e71fa000a79865c3556330976cc379741247d322f1f35cc661e213a3ca2b240c74b1a731a51f3fd5d81cdae5929bbdda5cefc37bc9c579ea4acb46f1ea5abf36e54ed753bb07a07fa484c3297c85a0f66d18a2fd1ee343ad56a7470075361a9429b9fa39a727b83fc355aaae057cf5035f6d8d1a9ccea3e4cc8ac080ba529303651e7f54fe6c9d8fb0110b1574c98ff39d49c40c391a67fddbaa6e6bb079f7bbf52dd10e3886317f308b15e2f70319249a63e5210150878fcbed45bd1da33815ccb57976fa3e56d53f0342942f00665301a8fd1015d9e071514bb9b3f39ef2dfb892cfd871c990d046d1ee84bdf714d30d0e791fe64ce27990ef92b422c2ce1878473ab4c0d2b44b338b6698d63acfb7e0730c8c8d747f57df6f15a3e48cd2734791d0f5589688891e2dce0356945802414f6a6df34d74b08b0019b75d65aff41c286b70585ceeb26838d07ccc7004475728390c7c216706df16dc4aab528074bc66a943390b967601164f440aa8d6285a768e9f93387aaab268180becf2131ebafb4aa1b3a6673de21d2a02cf2f30376b02ae85c89326250695315ce03eaf4aa406e4ccdc4a8c3831f9eb1c92c685011797839447e26cd97501ac49b232dbd37628791fc8303cdfb451f5dd1563e654b176a2ebf8847301e2434a823cb976928d153d8b4913b74bdf080ff9054c59a5ec5efbe224a2cd777edd70e23cfc471f5cab4a7b93c3a555c430144d0773500d4e914ae3c0d02a788b236cd874ad76179eaeccf1787d00da8218d357e7e2cf6f904d99a3689a4d8f0d8754834afc64e2668cbef83f951c73835d1c0a2f37e5134d7c0d184df0433555902eac07dcf12c259b73a734c1a4357ba66e2b4d01ffc026a8d0265faa283c05efffa089abe7c42399f98a96aba911c63061a72319cc3c597eb0b5c525dee53e650d497f685bd908d22f140dfe895284181f5978b203f26829d3e57f2fcd4d7a4e1a00678c786fec95aa47d8f2a412358d87f160d75a0ad893e49e1c7465594c103161c3a344deb1f5796654e79cc938a54dea6b246ab5cf8cde1eed48087a8c4c42176971b4da938aaae4c23581d403fe595874f711b9ef1df8e6eacfdefccd0cba6c63456848b65c58fb38bfe220e9ee8d598662ea5bdb2c3e9a420f58e34f20896bb8e063a4a972a3716bf5abe4eae3ee78ba15b427bc7de4ff97bed933001fcd56bcf1b207a12214be2f37ea7f8271455888cebea4f8e5421860a947286e195149f4ce8b5db320a9479a25d6d79676a22cd188e68a8b451adb525b0c0b432dda22fa0232137bee90ce73078682187fc1297db46e554168facac57d1a9eed59c23d19a8e6a59e41ee662b802cbfd92a0b2b212020baa68b2e2bab0fece9167a9dcf815b20abc7c38f2bb132c63dba74d4e98458eebd5f6f1ef182e271bcd1c4b8c74f06ebd41c8255117361a80565a4b55534d871e0f18893cf5084f67c922108f9ca68a9516f3bca2c2eb43c710cf90ade0d1012e597f9326f91320807e71a4ef5e97015107a7bb9eb705d3cbd697683daee947fd7c37ad999761c0d5fab0e0d1cdf6c1d48034041dc53175b3b3355f3b36b56ef6238c4e040a06f73968d12a5e3dffad4168949865ac3350ccfb08383418b82fa08b6a27074a05a44b458a1c78de5f2ee4b9043eaf87b4474a38748be268406781ed1bb9f4af9550d9390e0f967219f12fb775f8b164af02ce5a38b66d28b64da509c8f2b929afd519b26453d94511592c4c112840777e46c48f105c7bc6fd2c85b36a5e442cf5e9f560ad8d48edb74af3ed986b9cb42fe3c018eef1607d9d237311fc9e41de083b5cf57c8239933e7d43d1ebd49514675125c7a9992f162712dbf739803ab444b2be5b46085e0fcfbc3d6216152f76adbb23578b725f6fbea6f7cfd2b7f6a6919b2fa842a279d9dcae64d3b71b77fba513fd0019feff380798951df71db8e960ad826139186703b5205d1cdd7b53df8811968f46920d577d75d6200e375da925de8ce9d6b5bec8e5596d855534bded51201e7c55675f802a36ca11f3fcd96ca82613c5ec8bd75b3997874ad1c199a3f19b34c783becdd7ff9a1d40036e85d47948b25558e94d3baed3837a658cc8738f741369bfedfaa3105bb09cf12b68a2c48fe2a1bb24ec4875e28460135905a753158de68807e8785bf09417c024bdf27004ae88e6580277879a8b854502dd9b6f8158a2c49acb1f43001e4b3ef8b5c3c4c306a67becd6710d2a2f90daa98cd8a04e754ac1d6cf3a3f2ea00b417b5e272c7c888d2e852bec7a400371d7316c41e2edd1463e0fdfff7061ba45220acef01e6a01f00a0e9cc641436da901666a328e599a937289467437d75ffda3e040960cf20f0c457302ce30bf3cdf3ad1f0e6849cb1bb7dae995bc3f71e2dff4a271381b85dc9fe494c5ab328f5bc62496569101fbf887e22edad18e33862e9508af6b0fe167acdd4548c2753bb76dec8734627957c024494c847004c3e98aea7bbcfd59bcd6fd346c0dd6ac4cf528393c0051180695097f24468ed6d9e366066019146cfd541daa480809622de528c07b37011c63b6a9e6921f8d241703da1d84d4713b342bd4aef7f377a22f69ff43d73793994af54bca99765b37b7665c95680dedd6ff9abd309d2f4a9e8b34560479b8fb157359a9d9ecc822ab96ae1b298d5bc878995ea6b2bf926003c9d9246165fcef561b68f5725eb454fdeabda24f18b53122279325beefb1d51a76e73a21e1df7f39e36c07bed0a386385177419ca7f08730bb9efa8e471ee8ef7d2593e53358b76c89620b2507dbd95a1a005a2f25287cc4638d22c8e3062afed1e1d97dab44afde2007d611a7ea38fb3674f754b4799e3bed717a99283fb03040be8fb8d899e8941aee45f7fb7189682489b693b14db03e66a6f7d09910a6daafed6ee03e7a7638a740b431e9f79d2b103db6b2d7cabe0143d55a1230b9f79d5ab9925428a8524db277fe5b21faa5a352ac0de18e2d484e0a33bff6771835c62d059996710e2859a74d5891c30aaf5ace76fa04892de7dbfa8a721756ac13aa520fc6da2ac8bc93831f9eef5ad942fba06dc89b98c2c725b8b120748ee798b3d93ca63e61d1cd7dfa1154b226b96dec14acfca08bf02992818f264fdf87ece37e14e8565d7b1dadcb0f6b53bfde6b84e4d697409d43daacfb256111e73b7a06cfe992176c7d3567369b7f6f0b0a51e4ee24ed88d8e8dc8e36bc35ed0212f15c95b4e254a02dac1acee21eb27d12028bd858621c2b57ca19bebe04198acb7f8d2d87860412d8f343df2cbb90298c9e0cdf4cb1a2f53b832dbc98e5090695e9e6e4ae7c0c860c50821a85245a233cd6e721a7a32637f15c20760c4a497916730a7b6fbb66bb8514118696821319b9b8aefb944682ad754be363b0bfaa0fc8a8af3795fa21f0905ef76e5e1961fbf5a9361d4f91981dfc857036f95201d8428f519fad64ae67e3f9a83fe3aa5c6a0529fe4b3046abba3ba652875107e92e9b9310e3141482616228f0bf48f2f08b51afad1ca7df261beeba3601309337a6f2e9ac51823580f13f63d7b97ebf56eb4e0b894ab6745476170561b3c0b01fc5dc996bba748814e0515b00e9c122c9c20fe67cf847fd09b8aca573193c6491c77aa67ff7a91550e67862381af1e5c3a7ff2cf47cf6d565df9d336c0ee3cde6e56c08ed9cf3f6edfeebda29809757ed8789d1af14f3b2780729639157c3b24a04cfc5725235dbd8de033c55680f4f53ea8b4ccbc911a65bb801d714e0f0a50c601c29be8fd2207849bd180162e014642cb8694f4b18f60023de7edf46c60248b57a912e05ccd49f6224e2e627965430bd3cb7ece024c8ee71453f0f7f6440bcd5fea737b5f61e8682f6ad659bc2e9e9c493e39801c9464b1fb2844c80223777fecac3e5f8ddd292cea349bfaec50b4205309ec43b422ba2310cb1468ef279badc817d7c65949d675e11f861930975e9b13c590abbef9f6b714638408f13dcd229ab5c6f61255ae9f27987489ac9459e8ed","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
