<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20aa95ef2e420c2abb8ff4156db8d52c0809dd390f83d908996abf3d3df2f596a33d94c1547e7cfba483349d17094bf9feeb1ea14a156520728159ac039dcdde207f9009687475536e99e0ee8d8be46c9b7f1f787f992a92e973c789b0926a6b18ec0f6a209a78ca2c93aaf050814f0e4541af24f68f431f4195f7f4fde52105a88cbc8374ea08dd08a3b69322057c2617b776978863f6e0e85065f9660eb53c2f39fe725a705ce5990cfa06c458ca435cbe55fbe794909fbe8ec87f28f75a16ffce2e79e5af8e370ebe701993414294827af91ae01d0b90264da3d5eb6ea31c9a6298e1e348c58e27f7d063fbf927d2b12f2cbbc871887274a3565029817b7c52891573e67624635a0633bf84d370087c193b3a8c3a8782a7cfbe890f14f2da85b76594d9be76d2c53252e25924cfb9d2586d1c31980f83abcfed76bb8e6edaedb8de77e5b1354f3f15afc121579b1a0ffbfe53a155a35b415fd5860ff055e2e8a985dd8f13a10521172f3f5a140909503d8502faa66a945b5c98d3076188acaee5df836d43ce18ea0457d2ecb210c159e996002cae82cb35b96d2d70be8aee7863cabdf0c1f9838888b624746a1dad72b9d383a061392997f1085e7072f2a6eab37867215e7ce799da7ba6dd0f738599f269b5df51221c96da177b7b81522d333ca8f90ec45957fcd482c6e56dafc1caa7c2f23f41ca94bf7433a287856069168c23917909b6d065287bed86ff9a2eb3743a79cb8d0c9ec5d9081329f84b4aa32ff0432a8944562ea076e6e4f790bb9c1199571144d8bb04c05ae5907c4a54f946439314adfe8cfe416b9065c004250280573781749781108aea41491d331ad61272f0cd1da6cb6707dcab9a473c6455340a8ea430e20f17439a81a91ef78d6fbdde1ca9ef0e563105712c5f841f27462df634276a253bf893f57a5d3fab5c74852afd1e21e84ebf396f3b3075135de9e15d7f6d3e61064ec8c139c5dd2048d399276ce1c567092befe822363440dc5b4e604b8b6f6b30cb6f148a09fe2823f9470bde1980e4d8f9e97ad9c67d96ac1851ca4b5fec0e3707b908bb88fa4cc68c094bae25160beba78f19cf93b04129ffbe9f6b28425abbe3b5df9015f5e726b687adab9440fddc4fafa7eabb2eee3673e3e2c3b7ab35649efed12ace0854e16cb58295f07ba730002c287aa15ea42c71ad8a72466d89bea77d1a93dd9756e72f677fd4eaa74e9e0fbde5f68ef587da1be81320b4e30b2bcbfb639c0d66882219a402bc2f7f65dbdea42d761365320960bcde4d598a200d291d0fc806154a98b0f793e2accc9c4b8eb99ce9e0029ca75bdfad927d0ff16eafcf74e1755e850ce91d3be59144ad74a10d7e264a0e1c455929ed33efa82376f6f5f4ef6008a62f8ad95bb294c640e62b968b94e042becea2f834ce1df2554924d0e5f9d4954ab487c14ebeee48ebb7467d76f03f70fa5dd688e6823b43f1ad27a8459696e8ef448b428d09e495dd64960c0f547fed58ffb0cbf4df9357c0509276e342bb5534e8f6d5897b79143e369b4c6a7dab949fc9b69360d5b84c999ffff73034775265de1cef1e5d111645da8cbdab75249c4c05ab954a5d2256208a95fa76816aa0b6d4d4d6d8cd45394d5d098f31f9d8a6cdc5ad12be5081e6817f099b6be8a8051da825e3e192b1f81113b357733677763607103d0275085f87c10317907459c1a0fc98e29ece99529c4bbed280370da89f9a178d96e71c8a1cd957e5ba0b1c13b95f5c09f3bf8c7ef764d1a0fdff8ba4b361717af9b6e53738ab26292a0c0dd59f247c9b2c9381eed6cc773ecde7bc11df681a47c9898a2064b15437e3e788242753d1d35206e7710160d5cabe3d761ea785456629ac4a208011d7f5e2912a4f58123cd09812150fff7a6f30f003420c5476510dee21d58e9db5dfe3a1f8c910f724cf3febf997aed13c3d47fe01023f6d466bbce2e3744790229204d8443fa00992dfbb9f91dbd67e545680981e458d39059eb235a161fe5d0211ccf54e4356c55a47d38fc1559e4462e059b0dc7ce2f95848049dc298ec89c8309558e43bfe4eef7318d39f3854bc434b464e5bb0034eb7f38dd7c58ee8e424b480cbade245447b1da6139b0bfc8729350fd93e67b94e7a698e13b7dddebf19565bcd09320154133a0be39b22b8ff491ff08982c23bf6822b23b0f6cec2deb349400b0a65f6188754fd1c444d887e220eec5e1794135559491a7fd3e6bb413b0d21823387eb15e5601da3dff0515aad820a9064ad5c7f03bfae33d976b5e47359a6533beeb78df22371f0a9f893913da41d4af89013f45d49351ac6ef8bbb50dc9b98335d715a01f294ce03b5316ffa93a82532937ef6f2cbd62830179823f943ced5b5b15e9aede2caae20c3012a5b1658447182ad2730f9ef698f12107b4b533bd99da894f73a097d074cc1e9bcbc9f3363b0caf0105728e180d3dce9d9ac3705871d185d4924dfafbdadf24c6ffd44aad3e6e9c2d1ba99a9eeffdd30732bbe24febde3b142bc4fb074cf4f864fccf80f84134f81c9e2d29891bb6b574bd5a6e4d373cb497b72ca988e95213fa5a667b3fa094d77a8abd9034513075652fcd3984169e4cc2b5df0146148e6c69d6c935cd0fccf3cff9e935b2d5ae270684d3f7db2226d22aaf0c2c1f9ffaf65bba8db86ec0b00868311b5c2cca76cb3c05e742d145b7b1e0738d5be6a7edfa855a383bca1538c8878fd0fca81953a30175d1b453f702269552663579dfde650bfe368a7e5741f838fbc25372b5164eff9dbb085de4e955c0572a081487e5c255f8076188203cb700c8f0aef5ae093a44eacbfb76592df0c13ae11f5459f9016d8522715a64ee0a007072b4e625211becb0eb1f6105310042934467ed7b6cdb85165fee62023217229f93feefae236b3fd5546fb25f3f262da4e0ee6df74b96a1a5f9ccc6ab78d408c47061ab0bf004290d1b8ab2d43abeb38badc5a90b2214089403a52720377947c8a46c401350a92af4668a9541f10893acbfb3d6f51652ae6478a00d67b9c64063af69079154f4bff0287f74afe1d81234a5ae2b2a69ab29c4ffc7dc2df6c114f75225da84bdf14b40ca7f9107363794608e2082856b80606de2320fc635924dca4a2e7963c9ba925b33369b6c767f1a77fc7cab29c36d87db17ee7b086f50e1f4c5b6a934398c6b4026f8962615fe817917d4ccf6bcfdc09877eeb376dae29a532ec29a58c71b68ec87a8ad80534b3a3d7fda2f64931883aa1a9e0f1754615c653b100fa3f9c971a4fe46e144ab9d5fa6251e003863cc26662e55abd750246dea87a829eba761acd5b40ae9489c63bbdafafb1072cfc2bd98d35fcb5306ca69b2983bc2640197776b56b0f8ffd736b4a28d74c970dffbc59a6f58e5efbbe274144b52b5c42c845ef8fa057c1e0705a100b263a5590750d6306f7de9d219ebfa17d38cfa78c7dbd6d9252e4cad0302c3cc293eb94135869d0540fee6c37c09f3970f83c34f77efbb4878200433ce2735cf8bd475bde13ee92270155e616927932c1e16e40b49f65334366c8b7450481082444cce63397ead235e78e551f71e66a3660aac5d5754c2331d9e4b401b84dc63074b4ad95fda3e63deaebefc80a6a97f372081576d162ec60a96aaced63b13a4b19cd9b9e3e1d245c2d1266530d621c253281b6b15370b503d6ec88eab67a613d7000a405a52ae9b4ba5c4073d3dac46632ea1333bbd06da466aa15cd94d6ff2f0680c8e32dbd07c2b89431cb4715b272e06fd9747168bb4788a060155bc84e725f9b6b8b1e1a001714b1ba49aab47cd50092f1cb51d9878788b4b84eaadb7d2081d75536df3adc9a0cb14944fc2d4a57a74ebc7935be23b7710cd9a55c2a0e1f156b08f132ceb6bbc1c306053e9ea64848b34fcc0d517af836fc1e993fb13d80824c19ee3276b0018e6f1e852118f1a89abef70a5a28ac93cd22a832054c827717de305b4747ea13b7930654dc678ac6de4eccc433a88e9c24e08aa57007fb3b83b41ba27c6af3565ac4d2ef30dede18a30937a14f8d5d2ce5eb318a6d0dea85d31b7dedc0b1f77eec05660e9ad6a6ec075e7f2b51d7ed1e44e688d2c4f64db0b7bc3ee59e74708d70501b8e155b9b804b1e655f88df0f88612106cfff1f9c263e8c09788453643a7ee5fb15c9df40e0d54cf641464e5f42cba64b65b1d02dea17c7d8d3ae3a3e3b794a3ef133a8d3218a8442bdd7463ae9271bca8aef94802dd1945c8b913d375ee013fb8e0badb12c870dc2b8be418bd927c5dbf5ecffd92b5828500b738e28e3866c3ed369f4021327e5fe956dd265e20433dcb92fa204b061faeaed9157166637d401b824d49d2dea54fa089a392aaa65d051b32e5b03f889519a010ee86713356331dc2249f7a32e2bd86a8fc61420bc1263fdcab2cb3d4724451604c468f37b115de9c21cd52c354716fe15bf558812f65d77e5da7b87bcb7a9976543c875193a182fa518317d00f573da2397e5a07d9b237d97d2e898c5ee7eef773c3cbb8e0a7b4be020d3d5a1f0fa10897c44428c6845ff204e5d4469def2c8e439aed832e676cc7529b06fcf2dc51e15872ec2a21e05ca661342bd870fa96eab718df1f59a3cdd4d1c74f790e3d61b2bea8a9a4eb70290deba37c877afcd73479417194e91e69c782cb4a2d3a361a66341af0110ea9733e8843b01550bcb8a2865aa40c745ade69d7aa7ea03bc6746f6324fe4de29629f328102a03920a21d0c3104b264310e12d28732435bffa12aa4412ba001ac318b7ef049099a445040ef20bc32eddaadd113de4bc77fca7b8c55ee37ec81e3069676ff44e9f2f3862a45a4ec1d2e353c7d3eb0ef71e6c9ec55646560367fe346cef5d8db46dee126c8e4f2338b72a8a4e1a1572a5e4bacb13d297455f9ace14f02040878852df5763a5cabc8d66267258663e0f66dfdf1eee964fb80c15bc0c4f2c7661f65adbfa88455862901c5a1fb74efd50e454418c4b70448f6f3056b57c61a429fb8349c96dee850b0269b34410da5c2e62ed7f65ccd75b3bc2ed0164cbb96a8ae9a4852390c9f3cdd9e127e403746cfc593a9b0eecb2f8e614f173969f311afbdf52a7d1779ea7c34ac4079642ced3938df6932106c81ea8bbb21f93c079dc0a7ad0aabb98bc8af3c20874284bf6f260dc9981774e66dff02d15f84fca6e155648c66d6e977ac9bc1567068072c24fb6c47d381ede4228edc70fe54eda6ced83f4ece3b14f5298f04764d3b49c1f09261d2cc5bee5885bf445599eee4ee527ea6e432242881e3cc2fb82bbc63b6e9802643dbaa79c9d3320b7253a071d92983bbd8615d4a3a68351405f94b5f2c3e652a2116c94167b728a1ccce1296f0f57d61548db0d507ab550e6ceb3cadb05940b85407bc25eebefbd46e34880b463330aa58022a7be4385473b88b9d46d64b013464ffdd839eac8bbdc3784ac07a739be870cf614cfa7d187784560e7fdd2c3f823479414f95281a7baafa340daf342c1a9fc3eaceab8c288d783ed2f6918d36034458e168c6447acd80a313031e459de26df0549de592ccd2aebb07b23b1303cd44bd24edf6bfc5498f402f20f29e92918fac99c062283a0856988d9ed7863534c7634698ed068a1b9fa653b9a78ac8e8277c072be53cba65c0775f55764e4531b8e89b919364eb7fcda208bce99513a89d8cf510d49d75edd4eee2d22255178203e1a24f0a4c6fb3446d1cd6256c2bd6154e92e18c3b7341fabe675684400a5d639e2e3379bd26d26c5c0bf2c704d8235c805ec2fac84a4c4559c5b1440c9ee853ec750f9f8980693dbca84b5a27ad8a286965c944cf96e223e837f206439ba7867d032411a8f810fbe45a5dfd109ab67e629314a701d524494475b29a55ee86fadb5db694695d92c669789260b65e1ea20b1d27673927fc5fd3fc222d5a82f77e80978c5f09553c12012a8393a246d6976dada6f0429ffccc7085c21d525d0b14bd978f3dc80cfe5a9bd68f6801cc00d1859d81f253b3e1e07d4c2369a72c40b913295a13508a46d8dcd049ad18e66502b311df3eac9ed0b99661acdaf5897d1442fb7e6639614a1405dd7823cb10744c8b30e7b76a6bbe47ae15b02b751e06137a1fc5da8494be1584fc11c062b334761aa252ab677a06a57d18ca5fa915e0722b5ab284ce8433f0340c92f7dbdb0ea33f7d72aee39e157152ac919fdd2454ae8698cf5467928547a0b3a2074c185c842a6db85c4654d57c19fb128299f3b687e5fdb1f813c9fd3085f07ee03ed5cc93f926be1685ab2f057a7884b11380c122210685a66b7663e26e66b6f9bac59a071f2c0000c8a36f172119794a2076f32abc057b1aadf6efa6a60a0d2dbcc7344e73cd0e8504af798cbad0caeb447fcf0a1ab66e3bc03aa3e0cd6186ccfb5555ffb1fe42750b2b83f8aab3037765255a9ab4557a9844f6c3f001bb4abcb78323234638d78e361c0531a6366a62b7be778a6c1bd7e39f76a4b0173eddac2afa086e2cdf67828523e55c6d8f57379ec16d3fb41d6c02ef3b574d82bc0cf21012c243b40a7d6344d524884b7d7fe2480c6c6727a6f0566790a289e8ec1046169125e607522fbeb171a2d2849ae150596dbd5699bf41de873a0f6c2409858f1e50be75bb5cf4f90988910cbf9ead541e74306be5db59a40777d03bd50b6b4e1ab9b6cbfd412b20c9af556370a8823e5469c867dd30c94af6bc9f8190477ce5b2fdedf329802cfb8d740b9d06366226ca8d9ef88cb554a60d803f52cbbc17cf7fbe525b02925b83c3860c7a04a93375239d82ba6fbb7dfce627121b14cb8ccae6720af5009e9467743369d75d07b33856b118d97aacfa63d0afcc24f38699986abe73f26824d07968a7708bb032d235ab3d6ee59b83aa671d8a72669b05568a36acb16d9915793f298838ab38f518cbe991dc4a07a0d24349e7712b0822d0d6743f7187e99056a5af6046de1bdd32243564a5a02b030492b46c2f06eb832e461e8dbaf2db4bb98ebcf66e91bc4f3656cce61bbe85756068fc19405d065ff02359a6a7a92b41626905f1f8bfd8447c6cf24fa16b939909e440fc0c237e596f9ac50323de00a179d7658a4421e6f23f948041fa2304d74b996ed9e0fc1b36c9ea004e99187954be725382048e42c0b54a71955568236ceb10eae526bd6aa5d31a52d8661a8c1d5227389cae063feed0e6db34196bbf95b0beb15e83edd50356733b02ef059257a98579cbc841a4faf30e8ca1466ad91400c2582ae5d8aa4d684ac386b9804c15a534095e5d7f3d44bd28d82d6ae2b236c61ff813a97c6371b234d14376b3af3173ace38b805228bbbd8bde019f3f0e9d3773e1166909ccdad9705ae35f75c297e26882d88450831376262908ece52b15329e67a841bf55304edaff7f9c0a4c5e1e8ee640e502182e97c72c86fe6b25121117fe05e151f3367b57bdfad9dd640dff719ebf69b24cb70eea9d02552a5e1dc20bbecaee349563846343e84e240b059b1279f65cac0eb32da35362a027d589852b2fdb467621ff404dfe21b18fc11dc63f0d2b80e69d7d70584260accdec8ef7e717cd20a830d2f0ed95af8313d72c97c01f64b44bd3b116e1c443133a0304840cf69a1747db0edf6c75cdc1a5e435366c3fcebdb246e8e81729f4e1c09610110f5aac22948ff97bb0850f3041186f9aac47ecf3f8ffdc3cf168879e4f49bf0e1a2a6abf848f71cbc96d50807a1a5aa428a503355703df98c190eee193b8d56fca0f42ffa99b15131e1410c925bc201ee8ac4860343ceb77de9719d0917c82ecba633030956598bb8b7159298100243c00f6bf2d8e7b00857934db106228515f2a3d804de18ebfdca8bac2039f03494624897396cd79f5f8bbd719b4f1671965a30ef606908eb7c035c0a12ae7f4cc49a7d5d8fc968f2f7ecadcde85d9535b823eda11931e6a1a93fe311df73b88e91963c3c09e319bbb4b2abc3e3bccca5288726e1de03de09a056100ef6fb9910e38db755866fc0f0e590dd937092f0b40c15ce894ad9b1e179e614cb740879f209eeef0f4111993a697adfe9fe158eba43b85f8a0c86121ec21dda0d0bfd72c60621e288ff9162febf669a5ab2c4bc74d6d8d8d28a02c72820d0e3971ff643e9d917e38b8ac82c7381213b2e7d49ce15e17d03142ec4c17da08c3091892cd111166aaf60ee727e6e2088c0c18b9ddc7149e67f12801298aa7a94f01e87ad6cbe78390174ed489d4933046b886f92f99f96f132e8699beb5bf5cd8e9c01bd03ad404226ba061b8176a440dc001ce77d14180388fdabe3ee45015ae55072872fba5df45c21c4ebe40dbe7d3c68d5d4bdcee8c6268b4856d994ccab7ae58997de57edf876b207fc8d6edf98acee0cb293cfaafb865b94bd6f67e734caf7de9b9e81a8b94294c6afc23995950467f3c0ed1e0a43b55e887f5bdef25200eced9ae272b439d4115bb027ec5f961c55a61e1f0e8ea7f2bc814cf6f0bd865138828f300d20e600ccd50d395d8c2f407872f1a0721a219d4305a562ad36479379f925a1ef13c598888bfcf6b04deb87ac543366b04e6968933edad09a693b240d7184c026c2ee3a4fc2e0ac568bceb5dc47b2d71ab3b2f51dd37d3ad4e4619e3ce1dc7cf45dbc2b117deaf9651b69d0012bb3ff61e1da3b4d548ebf0a8bfc40a4bd5d2850ec9e69c905e05075d89a4104a6943fc0dd5ef8ef55465d8b99865ecf54c73d34c699dff0f5d85f95683f53daaf965a754f573a69d83512c748aded0e312e5569ff96f6cfc879ef607bdae94c38de965cd92d2fb68e541b223ef7c81a1a6204554278c138885ef71c64effd42bf8b442586b787303442bfe172705698bf0593c8cc1d71a14e31e3aef1c9c9390beb39e3c16eaccfb82551f106d22e31820bf03f4396213620a5126c3b80664bf73d7ba19a52b8318a2d091cdfa3b871157136daf478e93f5f4d3909be049f0f02da0fb4d59d579ba90bdd857e7f4c4b245dd0f652c2bad1b84809504f93b3b7cfe58ab17ddb85cc610f531265117611ed8e27eb8c86886232122e6893ab5ddcf4c1a068cd29c4389a3c188ed17ea6b4132eb5650cf8bea91111a7e3f486bfe85aff1875907411476fddb895806e3d7fc645af7b2543415b534cd33467e7d841519323b77858a5c61f06042068bb5b6acfae22b59a24b297176015dc33467ece13b28c365cab35b8559e2d093a0f97f8973a5c61aa91231b80b32d2bf94d4247547f521232d28d1739dafb69387ad7fc00380dc639eee354bb2b8381fc0a33acfde3c08bc48f70b415e471759690e66826d0dc4e1c6e5bd15a2928f5c342ccc7aa6918523a75501b957039ef74534dfc2d660dad5649d86b154a77b95a656495243b87f82ada0ef0d6087420b747d4f553e79865c74291219783451ab744710b51f4b2fab526b95d21f9ce1c406e04794fda67a5fe3fc8590d2c9627ab716109bb7a5d3cd5b4ee858401a198b1a74e09817235d2499790a602d5333c0edf51d1a85343c9b43a3fc954ab565f332d94778ee2cc3ca39db46bbf12cdf641f41b9074ec698932817019ffe5b1cc0f8078aee7676592c45fd93eec835d69f5431aa75ba58ca46dfcd31424e42cee64772800d4ccae0a3a865bd416ac95b165d5948c25cb39eb7e05e4444bed6a428bddb40dcd3bdf8b3552b846c9d1288a3e3701c5db88198bcda0c7883b6d720af22296e86f39490eb813e3e8ccefa54404adb8d9c874af6d483254744b03ea97defb4237817090c56bff32be8c6eab76bbb3c683c1ee6ed1926b2ea49bc08d62cee92b92f7aec6d52d3180b7c47822c27a6867932e6a5a81e89b5c1c360a9732358e5dd5f2d245b5b2e1d9b5661bb36b7524bb4678e4732bfddaf3a14e59aa0cde484e96f1653b5e45e60f421fdbdb4b67d8a7179f29612fad6eb135a25a0b49584a7c30d9dccaf6c3808af1c7523a4dd425e02478d49f2a889a09a854296c825b96332b2c8210dc7e247bde5c5c81ba0c5289a940a686f3fa194c9d535089a2550257d3b90bdf30df3d204a2eeea0f8ad5abb65ddce24913d3706d8d94355d81d3ec08f3a529e7be89a333ea36ec9e02675265ce6238295e0ba8838c4ca31487bb0708bc15b61224de5786ac06d6011c9c842f7ba1702c2e44d9b9c5ce8e377720d364ef1bac082cc094bf84d6f306a0a746d3aacafd52485d9c48b94e6239ecc2628e4034eb12cbb273cd0d237e4d759a8c843d34aec07b5cffb7de3ce6320f5eb7fc1ff2e26312d1293bf2ad9628c11121151a6c3a863b95d3c99d513c68b8e4489af800f351ce485a692170c3b98183a43e7d1eab3512bd27ba4ef7d41e639a01316429e949451e55f7b319d5049a75667a2c19dce7e11ee9d4985b008db148a68283e9cda7dfb63474ece01c249c2ef30483084e895ff60e6d15b7fcc9ae9f8ae3952a06b40a3d77b10093cc52264187cf47a64643daca10355033de23047946bd3882fa127f644c1de8b70d0adb23ddc36fa5282d0224cd573d24c2dc82c37c5ffadf62e586d670f23bf9d1a7567321210c162e94e6da949afb828f9e909a95610eaf423b4d1b5fb052777872b8fb243b9895eacc8a5a3e76bfee4c2e53ecb7efa85812298075c9c75c08c7d32e6af2969437f17cba3480ab9adf0e0df9fd051069805667842340f0017c132a6a7d91a369cf3011ebd62c275fe0cab37d0a67bba0af39f7ab81fab5a9f4d42a55b939a570a21b90ac0e6ebcf1d55ac3b95a9d439a7e7cb1f210c8afb76e2fac0b047263354debbdd207f20d9aff33b87f911d8b41ab2a84214ab593b666f2fda4936d094f80012d737c29088d2b6adb8add11885de80437d248b33bcd2aea59a41d2f0ae5ba7018defde49bdc4b74ab5b32dd05d33a9a53522148733562defd5d1ed0732a479b8dd4cbd6c46bc8de5799e240cd5a4b2451e28dd229b2865634dbff3e018eed8655255c990945dfb6cd936979e650f0c45db12d7cf17b7e4bd5c645d9a402599525ad772c3a607640a88c73367a23c8834077ed679f30e6f3884c092a45a7c1b46eeb32056578c43a8f19f204319602182dbc052499ae59b624716bb92e8fbfad74a05350c3adaba13c670d2145b4866d3a3df76dea862591106ad6ac7d81ef57077a97586f099d50f1d9053db4cb9d3acba2c3105dcf70de4e4ad5c456824cb1d31e7157bcb9b88c44cb5c1869230a46345908a4542a3a5cb55d7c5fcf22cac52350ec6929bd3e7b6e0cbe054f590120bf91d221e8681bbe722c36fed76322f18dd261bf8c29cedfebd2cc05fc944434939c027cf91ae0a25c6efaa3a59b5532863ea3a33641cb5fe52038fd3f197097191b1f196139db3d67f66d2eca5a829c905eb9140dc57d20f198b05dca62508d2d7f5c7d2922c9dfaaaf5786158d49501eabe24640c6337d58d122e5704c87b03ace495e2ea477f1088a3599b324bf91c3b63193a005ce7df5c98ce25e2b6796f09cf6239c65149b5d4d433a63494fd11670f89fd55fb993a4cf4dd849d0276d58775f7f2681c8e6ae375fa976e785f20425d9aac4ea0aad6890d41ba80e227d2d6b106062c05b2ed98ef082168c047e8725f22b92ea32260cfcaa3435dadedff6b85575e61fb0d2f56dec5c10d765cd8e8e693420fa18341aec185ca195af6d18a7f49a7cb0bfedd049a23a4b6ff204a8ff2ee18e053b95d575e32616e91fe9f1d3d0cf91bb8f01e8eabf3cdf55a5daea8f7ebdb3809f1f3f027cbf1c83bcd9a57b9cb0b5fd0b23c3d0242a73d07a049cef2474abec38f3d5b161597483c2c8ac5d5dbcf1c03e50b03560fc209445ef25783e827a56f51ded7b6e76e567dd03885a9baa62e596b2a5efe802203720aa82874e9618c6d1b83db9fb5a5ec4b0fc7ac3bd841a857ab3e20592bc3e32442e7fdd52e74fc29c73ccdb913cc6fbdcf823bed3375d04b2833589fb0bc0425fda1c87f0b68e5f7792808648f330b1e0b72297ac57c609ae2848c57f7af17acd86881a1daf93d01898b8350c1ba53d1c907621791791f2721a7ec368eae2971f9e854f40091db9890dac00ad4557ec49981b476ce0093b551eece2e8f6e19b254a3b900cc6978ea77cd8f4c58b6a03ddd372c259dbcbe2061133702ca8d36e9d0c6b1f71b0a007674fa79213e30d1f5a126fdd49b34228920b5df07807992affc95fdf17451fd9fdbb3ca725d2aaa71f46a6136b08d676ab31021a84c57859457f71fb2eccfb241df3497227af7b50448fab62deb71b54daf39fcbba326665ad8aa3cb221ee1f4c1168693e391dc47e41c252b109579138712a95c8f7e7cebe83addd065574bb6840fd838337dbf4391271611a65f4cfc075aadb608afd24a49aecde244738d976efcc687d49d04f9b539677cea32f04bd60a4ac5ef46bc211c2f555cc8d981df32af7b07609683c43a71940852082f81a9fcd293adb8cdfe9bdf97f3d44dd75787965fb71988cb144e150ca8319cdd2e5de2b99ab4c96d81c60820eaa5343eebea298aa538fb8dfd6c4e9ed38867c1c67232e5f0dc7db0c92c9d9bfbe459c7c6f2a37e1ecff17d9ba1762de4307eafbb58c1852a557f1192332d2737fec329124e286603d3a88ae1c4240ccca432400c2b32f018b29cc0a0d73658068cab44ddb2255b1e41a676bf9f2c8ed844277e7870f3732027e614bf17575e36473aea9810db44152ab51a72595c6c3c4fd81ef2ff8301b1a63ecf674e86dd5a01b3b275d99feabc333185f76a072465c9011098d1e62c9ebc32c4baad046cc444bd98c690298919cf040c2801b716efcb3933cf33b306eca6f452433aa9593fec7abf836fac839399232b10c06bff53f8f44c87614ec5a5d4ae31bca00026e104285f15fc46a268dce6901140282f3b8af303c169a72eb5c2b93c2f9927295c2a519aef60c960483e6a8ee071e0dbb654f6789b6d6306486ff1f6b974f57573c176e34d632b18453951d4e00e8d0b15d52cbf21544fce8031b4d381a561a96d22738f8d26b24f0606ba924e0d037661bb95e36550377df14d426a7b2fb8d279fbd001211d6af9d4a5b4c73aec77781eefd30acafe3f968750fdd2d5d040271975060221a329fc9d162e88bc1d48d93b78ca0d014e455981b273e10a4ab94a1ac46068444f48be6340ad5b9b11ec9d7c49e676d825b5347d0e52c6aea27d627b091cf7fe9fd893874d26e7013c26a7eb910bc9b60f3996f60310f09f5a771a046da529b530e8972715bbf4b07caa19df8191e8cfadff7576d46357dd28a63274ddabe6f31d995104913970e2d5371f43c8a4b9cc988d8ebec03176ab2ab0a62e4014522e8bf00f905a03d2e6e7df34c7c5a2531a916a8023bb52dce95940983a047269e68b0c8ce6efbf7b36e108282188b75ea47703de46e2014ff2f4bd49e8e69a49972b2792b51c693ba512a7f7523e3df31dd9e75dc518beeb45b02a3e55d6949275560c545766a51468caad205afcbb89a661ad48fc87c23f21e9433d95defe4fbaeb33d533f44212ea921405bccf11bee7b4e99623d692e2fca8e324ef6384ef97fbfb09a9df9b4c12ed292769190bb022f049d5e46dd89c3db9b4efeb52f915e018416f034e00ff5a0b0081241b0ab6ae20bf2debd0079ecc64f8ae29e439bb0922fa229dd7b3400770a1c79121e3451e708f52230044d0bcd7234941d2135ce8c1170746cdaccd3f02bdf04ab5fbed26ffb773c2821429ca2f173f24c2b1d4efb55931d4dd7828902ef392b42ae00516c38566cc26eff0796d160b2cb4ada852e66e708ac1392f606cfe596c8a4f3f69892bef2c7bcbee854dc38cdf1851852257c309e2fdf79773bf3857f0395e96f9d099c4c99978ef5095d03e15157f7afd4841c3231cda945f18440acae3c3e84f5b0553932c8463bd0a09c4f41e4f2ab2828268bdef35fa9d8625a27948c1ab7264ac56f70773cc7f94e835101c2819ae506afa3f0d1bd3f0d18e4588c92b0a35cbe0e27c6286e334e412cb79cb58e3fa4e02873ea78c4565dc3601aafa132582dd7f52cfadde07685bb5e6dc1fd3f6991b041ef8da6fc3826837361a6d0751e9841c0135b2a2fea198d65fcf6960cbd2bd0377dc72ed0828cf88062d97e31c7e6c01417d5f03fc64874ca8bc565310ad338e3dfbf00fa6f58bfbe6fbbc3039f81f7ee9df2bdb175a1fafbecbbb593f14cda0c5bc2e2efd39d759b75b9dd1d695040b49e1017cdf98df64262a8bc7c436f2dc446ce71dbc54e6fe98a8cb375db3f956a1bf47bbd2e266b224fd8701c03c3fdc54e4bfc5abc1901008851c71a48ea6d104aaa4bca89b71bdaf14c34f291a900e3ed80ce92d6bed6f680a62e3c59058ba73346c6739bd4827608b1c2cc7419929989b4ed156ac812315a4f8b29594c7a2ca0e46cbdbc3cf3bd8c3953819abd52920514faa97d91f74eeca45242bed9e0de0803d54a320e7d9c2b1cbb0d394fa418b877d65aac784c2d436bb4fcc72f92309395d2d6af76f69182412504fbc5d397b48cb8138bf39e7749bdf44ac2154b161de3c44a17f66b743484aa280fcab91fb5e34b3516b47e4eb1f579e5f931aa766b7069eb0962361d90b69268b810bcc3352d89911cd82de5c90c236f9b89b468d7a5f35f9783b9d0a7fddfe998b2aeb04ceaf26cbd700ce251f4149974c2370833a3c313161f47373b0547423588a8bb61eeb15a4d58c28413d6f400c7b6c72e7989306ddfb03014a795924b624bf4d2ae154471e450cb9f5faf729cae10ab37c36408de75c3b1aff61cff8fa94907b5bd3149b161b17420ca5ff64950e3dee48b881d43c2d40f27b90faa89c5514fbd13247430b63c53d0c0461c6f6d7f2e88f1e8bb468d063ffead0a85ab86e8df369d84bd4e8a5f0b4736c7b7af309377780c2842c3a9536e41d47f8cccd079ac22708c627a1672eacac7d2eeadc12a02ecc72cd99a40366f708de964041ba54d6e481997b204e392d1bf9186816ea2384edd7e580aab44921132e49ab138b7a6bd2a3292906b5dd64dcc5e5802aff181813562e05dcd7252b12a919ac0f5cad52fd84d1cd8e94b38ede576302a68f61de4dbb58464c84f2dcf1420de97d361bf2a38797f357c185fef15131c18852cec0a44853071a8c6b561ae58258f0312e588c4e0f4cb4bde07d348cc4a769b9c59d80a7d356001ec055f4d8c017c09392a2b768b2a267f1875936af34cc1d9c38d1de83a09df7f09cc8b7ad30e936d9683577594737d32b7a71915d59a6d99c462f392b5313785386f205e04c5849655ceb701d92f29295f58eb1227212610f66c02ffa91d6cc64dbdc36ffb9d63f94de0e9e1da9074702b5166cadb8c969325ad445389e6f59a111bbb81b701e46dff4119bc847c16349d84b7a73a6ca121389d8c767f7f94b8dd2529d5ffe8298e33364c0c9988493d57dd8c6fbb5356872f0845343dd23976c93d6bc1f7da8b94cc45d0b42030cbeb293558c7e674b77291428b9fcfac1b3d12cfcf98662e1517cbbbd77c5ba8990ffe7c6a4dc1761c6184665d491c026ba75bc79b94cd2cb51b0bba66abc290d88c8bfce5e00181aad31441aae5e80e12120f671a2ad705f8e647d014320626fd5f1f8a06aa2cb51ba47860bfa70eaa1f0c32d07eaf5d83c592c1ac5cf5278c0d73ad7ed1f5d1285beba74e81647de98e04b2985d8159911147982609288b22fd77baf2ea18be26cd5e2c23931e12a64eb636d5945564d6b0589b2b173062273ef55917e312020307f0f57c195d1468b1d177c209696a8d7f5fca96a07c634a88fbbe79cca34cc1b215b936271767e8d44ca1db9b50c3d0d657ee2003d2b659cf9398cf8574c9148ae32d4fc9c3a13624237a2069b9c4e1088aeec9d2df5cfbd4f212477b569b88c075f84df6f798611094ec9f9c36ffe7333706605afc31c6ce63859be7b421b48b0de94553a89594376d5f15a95e708ed28e379cde797c187337168ebe6bfe7e3c902150d0f9ace0300b72dc6106af86b740da899551d6c933439568443427e82006172c5785c68c5ff9f32dfd7d8cf912f9d4dbaaddebefb6fa6f0b754aac08e93fd67a1c696aa99ec165af748787dc85b826ab6792584a47b928249e8ce214a743b86c8c3781495df97ee2c92a9f2b0a903dd6a9d5c3dee1fcc9fcfeff88d43414d08eb6e389e622a4e01a3055a8238504ce05219a47d266c730ef924a532158f8687cbc975d9850825bf598b2814ee2da8f04f20d5c16eab35fda953b9a37d5feb4fcf68313b8f5ae16238b8189ab8cabb568ea835209845139f9f2775beab12e5c847884702f533f1c7a46479aa529a7b0d2e0172b32a393017641d06e7e8e6d1f762f56ee1ce0c082daea2f2bc26c0a4ad90d5d0e6afb402a5dce3fffce4670b0f5f545a965ee0959503a4ec54d1c74b7a538a02a2217e1541280d3c3d38f4a3fd67b9b8516b2b1927ddf2b6a2d4d25ba0b40fbc2d9d0f0dbb1d807a615571ea751ae1a32c5121fca2a358b00bfd769d8cb3e2d9a2aa8ddb5fcb681b083e4bf2828177d5d2cbd68e428bcfe9c4546c056aecc06c25b517d9712486a697c604f9034f62f342dd0ee55ac3aefd98f343782d50bf1b6e6cf05b44aaef57305e0127ada6bbfbafe780931ea51e0b70565d03801ce192dcb5fee39c1b4a28e5ccf1583baf24313c206500b02c9bc2a3ef570a9a0fd00b848d4631e5ed7691dd8ed691d50edb20ab21d4711bb26a310ff828c2e220c378269b1d1b2361248a5c0fa19786f6dfb264518cb970a7dcc30073ff28d3f10e76a238368d7e702e2dea4548a0be1c03630b0ec240430204f82fb5d8a92c60f32d5365a5b55e1608792838e3171d15a2f1e4030b04698f60f6be5b65d2e85fa2584fc8df4ad838a1efb2bd08f7d606135b97d8eaf664f016a61be21521bb81ed053e949c5e70bc34eeabb7bde59c3f3a289084075eefc91a3683535cfa91fcb628e9d8863be15a51bbc66bb773c5d1bd7b7349f19994e394268ff4885b4ca7620ddb4c821352540d802839241615000bd472acddadd6f0a7b976da7fa0f11aed25dc9f8e8226eb901c0e539018c00cd035ccc3a6b3afa83e1f782a9f54d5d854a3d40654f5829651d6fd8f480035a815c5619d228bb54dae9f60d36f59969ee1b421aa8f7cfeaf7b0cb11c59a45de7db7192991ee83a860c6efd2baf81430d1e5083132e7f5ed1e0b5043a787ff4ccf64e3579877708f81797ad0f56fd9ee4eed825b868699532e85a5b37163a229cd504bc0771eaa73e8e5204e217912b273e4c247e015fb9ded54d6ab71ca1bfd4c4815bb2303efcca796e80aa24ca2f5edef177beb4321ff3473d936b50e004dedf776911ef4ed3192a9daa3fed8e07a6d5fa5a0c722734b7413dcd936ee3292b32e15ff4b17c641debf57dc76d87d145a9f19ac8ff7885fb9e7bab35fba1e3a03d8d80c612d8f1a967f4757a01badc05f751d21125019f2e610c4bbb1587516d34a598e4fa1f3bc2d259da85dcaf9a703e0b544d42b9b9e47a081d9f98ef37ca1576a8e7395e526dbce44579fffa5728f429b00548c39ac716e5eca3d65871e99ba2fc9fcba9425134d6926761bd4581c6a5c716c49e128fb5bfc1e7c7cc4fcb2b047a324ba6823a38620646c299277c5b2e0e002aec71b781cc64b4352710997d9ab856b365795245008410d38a4b0a4779ca217713ed5049c1f4b921f90477f7594a5585b1932820d4d25deab01a34bba7d95df4c3d7c11ec4da6cd2e47050ee1da4d7e27bf9d120f34e08f9216923a9071c953ee3aa41d2341ce617cee7ec9c1a954054a1951d42747894b848e8ae1312119d6b64c31d783f674e29368b6738768ea2c9eee08eed30349650de3ce08fcdf84ca3f41011f10b2256ff65098cc5318d2545597640fd8b5abd3c28f4c0e18bb2ea34de44179a7cffcd9ea93bca1c821d43aa58352bbc613de2bd5045cb19f2a1a3d2479e310c9580dde73724e3fde86bd2fb88742234ce3f07c6b459cb38c9697da9b88c1ba1148f49f23b528d8569c86fb090913d402285abe4d80ede42aee944bce5dc495187cb97276ab66e9eff372cd666ec0a372ae5c999e818d24770d8bc2ae5018c06d2d61df3fedf75b11fee735725d0b789d0860cfc37995224e1a82678f7d24e23d460ac69fda347c77e410478c89b6a1f7cb7915e3e448db34595818bbb421b19bd28246f90faae5591bc8bac8a82fa68c691d3adf49dd8cd2c54c63d89db8d8e8b35438b22de22b5e6a513bf12b86c8d4c6d5d2d0345db91e1eedea6ae0d3cb75fc3d31f4cf403d7b3fa58859fd0c2f1f4226cb261854be3e814b79151bd687bb1571e464666dab7368c4f82f36302a4a2476eaff3c545ef5c61720508522f2016b453790e1644702a55acad07d1a41688683465fd8d8e6cf05e621329893b7bc63df3d377295f07513834e2ced30b7330bce066d68410468d8d87f059c36e6ded0ea27157ee93f90e6e05f0ad7fcd625f3d7b9adb18abf3a23402cb3c1cff83a52b2a2289e2ed006d22c9965bdb1b3ef9b960dcfb2c0e25e6a73bbb1225ffcd1acb765139a8259161fc4f2b4ba97545ef10de4504e7c8de4e8b8b0f69a0a069a894554dba01dfe95e2744e0391cf589f044f6bd24e205779771d8e9eb4810c90831a5f916ea846cada64deb16c4c35ba2c8b88a1a8dbeba84996ec6e8c71d6aab90d9d642dd9d8d59b2654f16ee6c7623e59d0cf7a65560396570e7331ba895cd249e2e62cc5fa3ea6d7e3eb8651ac50bd8f06dfb4c147c86cf45f6fbeb29cd820abe016218c82e3a6731025f0d875056c60af131d13841f4bfa72605089ab0897f2b2da5cf2da101fdad89875973650cdece6e8bef90c5ba383fb37596c863e31e670e82050959466bb64bf20f7533a6925292ae66c720120780de4ba29eeaf4e195caa82492a6f190a942f97d294518a860d56a7a17a087e909f06b9c54c55db6516174f58953a597fca50a79cdbbf6590e43ca6d1235eddadd5c3c4c27fa186920ff36b840f9bb68712edb77808c619bca5c6fce51c7eb3200cf8228d7d986799b9753fbae4b596f87a5e9a5f0c33024336891eee9e32b018173c1ae1ef6c5aacb1144add93ab7845642d48bceeeec326bafce53ec50d50657e92b0f77fdb8db9d274d721fdf73de4b027330f682f2c23fa77ae4d735e64853b32721623ba643240e5419cd409a77e8cbb61ddc11fca9f794b0e446f64d8be0954b1c0b1f542aafc9341e3da65fdb7cb8a7d8a63ebf4517cdc9586b50ffbb56fd6a485cc432bfe605ddbc5a19580ce272ff031ad9f0c3b78fd26f93ab559d1c885e66747b8bc38fb8fe55afd8bff88e6a81acd5ab11358bc88136f39066f60d016f1d0b4b9f4c10daf0be867838e8067debbe3a1ba15769287f6b7fbe91b1ccaa707ff98c4f3b60ff1f93c1a5390c32309b93d4853f67d01b56dc9150ca9dd91bcca435c0e69f2e524eae062064c1c37c3b7941df2e9a1b25d2fa787f556fe5459a83553fafe859a11ddeff25285e40f76f11f278f1d8684e1e662fe6e51db4854c0dd366e0960e7f2c53090c735173c2b86ed08db7028b922bbe1970377892537e1ae05660837e6db489d483fa6051005792528a0afc6fe28cb89b7f26f63e2072eb4f53bf85be13a7b3f6b7e47df1e176da9d5a1d0f7891f2f304f64f2a1a5786baf3426562d170c231d073114c84668ffd74314c855cd20ef9a1ee70aca53733cd1e0c963ab41da1aef422658f8e85875e9c79865a5489a2f871bb24b16b6573da10eb72105dbd3d7254884a6470f31da7f249c1e8146550295a291d6186038048470369a2a25d6e772911181009365b49e48c76cf92b78eff37550d616de31a1883e275e5b01c9b3091157a2c84aeb5ac8f1981178fd9391a9b3ae2c78e7ca9218d36e9893b77f8ff76cbc3f0c0bc202596935b65f66d315b4ad3c6705da4d6ff1bec084fecbe6f82015f28330334ee766482784855074675a93a804596066d639d5ce1cec25c7ddcf668649dfe0ea71bfde83a21aa72794842539331af9ab2aa086208d1fc3f18956d5cdc2becf4b8d185168ffdce66bde03fe71ffc64b1544acd20c5672a21f365d34574676bfff31b366e7736d99dd10f0f292bb0cdc9ec5bfb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
