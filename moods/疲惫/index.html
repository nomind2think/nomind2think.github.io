<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7e26db19341c50d4f9b9b02dedbf25522f71689b5706bbf1c0f89056742a11732b93fc1111fd35b2daf0f116fe83901338e074f50749de3c059205856463dbe118b0d6f400293ee958416454bc7bcc8812d134cd13e49ac2d42bd211be5a31e74b83660c87b3d3e1c83e847983550c6b8d43b41def44c52ed9e6a1d96983416f4e91f8b370ca7a9acd349f7e67c114fc25a8700f40fdbc5a7683fe9bc3b6a8f070f52366598c15d6c41079e54c8d4196cc8775c1ad837aa650810152bf134aaf524398efe209c9573b163d56d669c3d226198c0cc835c8a7dd5c4d54b8bf70c20b9fc96b26a0a98768d77729d8725bfecd0d9020805621b61c8e488bd13a6058b4163f7e2ae36eb99c69ac2a310ebcd716d702da716c5f71657544344bc9f35efd90b8b060c92e1a4489fb7d9f7b5052f91e33b301af31f92fd6a4d12153ae8d10496f3b2f159a999288eb1aa32b325aa4789d38cce1de516b8d9d484e6c70c072b6606ca534a5c6de03424ffbbc906d47c27b6a203c1823e4ac4345b79df37a9f89cfb7892431ade59f94de499230d22e9c0b4791e01cab62c0d3a4eb6cdf6eb9987483d8e66bc0d7646020b0e6625e889b38318cd1c4fc06596aab529c9610b7d487658bc89ed499eb8a29d37e70e89a6c398d6ba626f8d04b8fccfc29d3d1bd7956e688ba10df1554a08afef457496316564c64cdf76c0391ae374b3bd14a246fd612d1c63c39f2685ad38d2779faa03206919a4308359b98d0b04a0b467fe7fa8d2a91be941b42e61c7108f8bd8e1989886b1e68e61e97c9ec87b4587d42cde396a1098ce55b4f9d56faec8bf68499172f25cddd544131c48de5fb6e35b8c791fc7c3841ac8fb4c00ef159a855ba00f0b04fecfa956fdd00af19676803bd617873203f2dfadf52aed4a5eab43f4d9d7f0c617785c9dd7757f8670a2acbbb83e59a298c755400757b3f2ead7d2b35892874e11e2cec02126d758e9b7a2d3f3b25a84dc9d6a4e3bcc77ab6fc2cf141ce0c7ab6ce61f7b121ca54b066dd37ea1af23c82369885d218a3e96097574960a99a475315c5cbe7d92ab9b13bc74de5ea9dea9a6f9e2a1ea82e21723fecd446bedc818d9c33a94e8f7a41d8d2cedad168900f61fa2bc92d8d2a383cf16ca38db6461cc2b23e747ffba0f5661a9b5398f49c495c09b2920cc67668cbc8efcc21d98b9251aafeb669d614feed3222cb10dbad237c2a047b4c6690728014a827456b67af6bb818e73d1268d36b8462344be50dce58eb2dcfb32fa8754134877f44189af539e1f0f572977a44e59e49be7bab6eba96e6cc67bc2a128db42b89ee0dcfc9e7b80cf06d8332a62026710d55d05783151bcf58a263b08f8fbc5ae3123848fc3ff811b43063eb52c3fcd1cf9787bab8aa1539f893ef328ddede61c9f088f1a0661f2008ea9c0d4b263b399ce707b51d0f60171deb70f236bb6ea6747c2e5dd2be0d642bf30f3ebfc54e789302349d61e278d3ff3d9a0fbe04f26b4b0664c071e635074ca360d07aeb5ca1e71e29bdeb7aa59d29e2708cd0ee1e211985402349849dbc4070f75cf2f90e455e8130150ed169829dc278db1c11342150a53143b376f6830d162d51cb95a5177d3e3deec67197bed9dab86bcc2e54d5cbef5852c650665baac060e9e38c6d2ff2f51e0282905e3289d6d0f2eadc8c14dc946a5a9b2dc17165a093709b7270187a1111e62a30b6e9ab5f70cc3ccbe62a205cf74b07d03d366609e5c382f360298fe134c79327463ecbbb854f28b4bedf838d3b2a78fa821a727258fd0bcf36fbdf0ed931f108203f6fc4801df1885826f4afb68487c6f9a076e77519c30629397c4c15b1ea9e3d07028dadae6c1953607f27872ff615203603efab0c329e2257cf064d60af38001e074b7e97fd628d66bd175c98630c2fc9265d03b43218d0c59b2c321001425fbf78ccb1e57707320c035ee43c7c04d9a461a12d58ed3d7c54aec1cec012af7fd30a1a4eb714deb062fbb7c67a7b2043e9b6941d08d3521648e0ae7e2cd6109bac49c3cefd7e7da937b2300d33ad05978197fe1214c18b7d36776fd945aa8456c3c7567dd05fb07c15df0c9f6a925b0a79e6b9a146951f47aa15fc9d2717ff627d3b54d5944138fe53d363fcf3a22c1a86ad74d2898f049d9cc42e6cf1400e490a839ecf1dd0233e198b6791b4e417cb546e952bbdadfe19d0593d256c07d3ab2b0b14679163cee0af2fc657fdc0585ea9bb347a520b8988f8c87ef4464666395738979600e6ad48a0ac30f23c31231fcaf1e69e064694bd3b3d0b5c494418804aae55514d254c5c3540e901ad1c914047cfa2325fc58363299996c4ec4c4a2b0351cea0a26b56711d64a636b14da167f0fee0e8b473c472ce4893864b261b15b11072354214a0033733cc62a202ea996f4b9d79936327bb9cb425c288aa9898ffbe67f8f38d7371fffb7f3db321130e0c254ef4244ae8b3d972718762842090883e4bbe91cbeb1ac213597fe5feba0fb7b052438e758091f3c5ed58a79ff5f450cedc1fdccc49d32c9017b72e8780be46908193cc603fb3b02571793d1b680253c2874bc1f6f1688e3c5c63602bb9240a14a0b6fb9245cf8fad098ac8460f6924aa079242f81ec921fcf8bd3926404049242cb0bdeede56e8cb6aa7be11ec4532bf53bfaec0a0f3b9f24af8ecf0c9fba712888e2f63ec2291dd049c0e82a8ea026a5d2564793a21784e9ef31e9f3578cc553d12d8c56e91a14c640c110d8820862d2a8c1e2431df1a6f132793a4be438348cff7bd0e93107bdf65f0eb0d86d7d5dc77176f7b75d8884e677bac833b8a21082002c372585d24dea9c03ea86c5f3935f9db7dc841e0f4e7f480d73752916e0c1634ba2370ef8a21dd3718cf7e7e6522195ed1c892b819e92b8f58fe49134a9226c7b39409e5aec88c0d9f323065e11f0d79e78bac05781cdd63fd9e56af1384fb20fa1ac06c0145f6b91405354631c981a879c0a9710b982a879cc02b11f245f56824e4ea8c43c3291a977efa24345d28b88d12f79b9701d7836e406306c92ff9ccbf00b0dded1374c0e61f967fecfa496d88cb0fb37d9f4e8609b22099ed663f12b8e5dd46109e1d6e9dafb9a0b90178f048216a1776e7daadde344f397a27897b506ad8445330cb3b302568d5d53cf10932fee46caf17d5f796ff5d2e4315c5bdc78c6649d7e2c5b8119195dc509fbebf4003db9a8d49f0383843b84db9cdf3a06fb55e619b6e2f8794cc12c31d42e5ac51372ad69348e005bc9fa2a17d3db3875e6c77b0a2385674f0564a6c98fcdb00f45966fd615a9fae8297b9a167c22fb7eb5d06a1716f938bb1d1e3c6a0a0ec10ebf71173a6c3cfc677387de9350ecd55a91e7956bd7af7a5048e7071a0abd9f26d48e2eadd6ff7e843ffb1987dfaa0c1518a1e62ee273547abf79f52d5a924da94c6c74be7aa727078c23f4e6396690486c80221f7a1322ec3a2035d3c7ddb7597dfc4201e21d3fee540819c03f7c9b2bc1dccac4f2586fc68f1e42c61533777c75db01d50965f62c199e8105f9f60218da3a1b09873e8fffb10f8e82bf25babde6db61540b1fcd739660a44ffff2937016809bab24c1369b4221e1edd3e82e9a04700b20667e361a405bf9d415cde6b89acb0a0571e4a214c28d98f411dc6071e2bc0e8429d92924bf1f6a4de9e1dea95cd736b8b8023d7bebcaaeb363d98b6b370c96f3db392513413425f07688f604c10ab2a5953ab74545f9088b2a59e1270aa5206e2b5109d759bf37a97952699268054aa3c8acfa6d9f9d7cf8d42f9f426cd83d4c9fe8bc1f6f07cada75d5de49e9d05af1db2a9d15e286bb14de8d07dbba84438fb74f786b0e30181425e591c75db617013ce8d9f9907cf03f46ef034d6dae3515d0af1a5069ca2c1cc0a510cee4900c28e8d0bfeabd9c5647e311a59063d1c6d30dd5999225b83a7e97a5d29fa6e4332dae5bf48e71dbb50db5630d19ae54a9964ed7aa7151db3f036c19aeb8513db365bfe97285f077dba46f5b76398d47e6a78e6bcce098933827063dddd943b52707f309f17d4347e0159e25e3a768d7624874df18df5f5cb4d15cd993ed6986fa583bb7f90b97c9a132fa3d32580089766e30cfa7de78cd18a83b68c7c5eafc7b4198bc1587340dab934e227485db32bd3e13f1324f1568cf71622e3cab2661f2dc84bf81b04dfccbc981d4afd233030ae681af2b51277d49bb3eaab1dd44cb00ba85745a944b657916678a75ef678cdc646848da872ff62ace99420cdda70945bd495171077c30a25e999bc5b7c4f9de3eff0da7ce8a4cfa3e67a3eaead0b4e2c411da57b145eb8279e03e8effdcca93966fa77566df86584072b41f2dbee2595e458d8b7ea9b028e64678e77df0d080f5ea74cdf198c58c81394fc7e047b3add0f9a82fe1855d977da1063862d60f1291551ebabe34f2ca5ee782bf222a8d31c6af5774b1c34e0196be377af932ee4c32f4aca1aaa338ec85e8f5679dad5354202ca536cff7a395d5f962fcd377675e31af81e4f719de14db84955ffc41ae3fb82e915031bd05a2b373c55a268fb12337a4c5818fa5438f47997f01d51a97c0999ad578a161545c2d3aa4c5f9bd461e8a43f18c3b00675b1fd44def2f82a6d7a0a3a641dc040361203d6e38c65522472e526595431a5485524d8f170e7d33d89d2351d23c0c171b37a2dc6afca60cb1aa7dc15d08d0178282b86c72ecd2e569d9c645b403c9816afa5a471e25baf7e7f280f33cffdd9f668cd14152a5c034f1f53803848bd4b1c3e2c78ab5c7bfe79858a953e48499edcf0e177cf14704b80939493b477a921ddeaa6493a10bf543daa96e590533a17200c60190680c377f83b952e7f04233f0aae0eb2a760779d444b3b92fc8ddcf145a7290f861d0743a38ecb61e984c29a1de220873a09086a65cf73ed0c0aee57599592e7ca8846e0d91b9857cc83a2b00e61f1f16bcf87ba6d738207e43707831a91ba9fb39bac85f79fc4d94c6a9abc36ee567e9a40f4be696fcba7cba6752d17fee540421414bddb8af110a02a52ffa2657ef80daf982d153e162638ffdb3df59a09480b0c4117cd9eca104cdfcb0b0ec391f8ceae00f663bdd3365735501140c5b81209862139c21c76347c80a766a7e0c8db76f5e9ae55e086018af76de5d98614f452ec83ce0f469cc1ea79211ca11ee42502da9e21a83757adb705cddddf71f6680dd8992c7a5cf192e9aeb7da692b74fe16f9ca413f75c1737294db6e01ab120854a2c62f2068f50f49c4abd27f3e99d8558f7a9368e8f7bb89889099e714729a509a1eb9391124554477965820741d48bf1967cf318d0494ea59cea7524be68966e61c6ccc9e332bdab3629844f79462fb27f110cf1e9937aaae16efba65606aab95b893c471af7047a63a21752ebe698451c853e7283af0468bca1051664ef8de3afe3130342a80c7a4cf08f386f77d422627eff21da4ded36251e2551fd1fa6d913c971d31302d779e8cb3cb043d506a784aa907968aed04389817f018ef052f13800d0450b66368e7f92159a3f60e56a34268bb7c9e1f3998162528e5a7efb5b618337f5dbb1b77f929626956272d3b948d9f9779e9e2c67737d65ed15b3660234441392d0a2fcf5dbe0498e0116f675322827ee219d5763c58593e739a3fe783d48a1c5c32076fbcd135ac092022585006d62030bb7c35ba5eb8ba75c468d63b5c72cb68c3f22cd4643fc8badd96d227c75a10884b0eedad57e80477740706199e30cea30ea63fe995c1b24d3ce5999e7e9b55ef3534ee03116d1c32d0d6cad22675eeed13caa2f193fe267b9a3912734362f4327153b1d8eaa8d718bd50ad27c86dae3affa4070cdfd4bd96b2c5b8d37145fda4f3ace8498cbcbcb14a8bdbebc4f6eebee85e318007ee7632f3ee67c6d34aa6dadb818bd0e570108cd76db5cbfd394002384db8afc7a84a3aff2bf0d9089a87cb5beeff9798d9326e357aa786c867cb9ed31d00dbc24e2cd49f6c692da57fd337e43acb9922c49b849ffc39380ef130365a87a0cf540ff965221f151c711a2dbd8648db71a5c96842b0039d7aa46e111a6f5f89815c09215542d4ddc0c46cbd3b6b914e891f753a6a61c4de03f3159bea78dcb376d746d355948523ca55049768db499b608da02eaec2c79d4ed73874a1200af035005997125316c5bffc17e91466bf87db090a29c3a998f783aa111ce129bf6c4ec6911b3862d03675292e80868dbbb262a6317327b7a1089bd0ce5d44086430b3b5ca565da7f7801c77e60ee6a5b709abef3461e192d1ff9b5eefbbda5579b152e89b0b3637a6a856b8a6deaa633aefbff9cce1c378da9e5ccf41348a192bb498ca1534e7a7daa3ad43404f7f041a4e2d9365d344c031fc29b1e9cbdce6bf29141f208dfc68b0727c7ab69637fd0b6e809a47f9a7ec06dd7510ad92ebc5ac0853d556aa9a437c5d6f3bcc9588ce6269a28861e17c8428be6431fde58c5f59503a9b61722b992f3ebe0787a3138427ee84433490f971eb5c5c5f5c8d98d835dbd29bc3b0afe6fcd4a379d16ea267be0905f83375169b7222c9bf6632c0ca8a58a18ff1394bdddab907ec404628d40cc1322c034d1d69eb1e58334d64e6ef820d7dd59c91174d9ff85903c527ee276b1ce89ea4e4abacc493454d305cc0957825c65fa6245168ce33c1630eb1079d2938eb940d13754e001fa38f50146d5853feb8404ff747bfa1339b546eb3c16c0250841f40276c00d330ccd87d8733456032223f2bb99c7722ed786af8b8fe8d719c3214b4d2ca9113d77305895199f9544c1d1d3fc08402bae6297d0941bbacf1b6eb07da4ce8be2565a77e27b27ce3b00fdfb4d57be146d981591bf18c134130999ba6d530ffb0056eee71ef6b3fe0f2c038f3ebb0a16b011b8f71bfb5a26e90c3f528f9c5fb8636b15a36cbd8d0f0a06e77ba6154ab3ed5699601d99eb138217c7e89d2cd3b9cfbe738e9fca78a55de57e67a5dc400bf8d67aac0b774dd901ed446923db9a903e2092d3cf14a051e2dd492a37818b19f5f7c89ab14a8290791bafe535e78b639dfd4da2051cf4a05228c13c1d276ea6b146447d389368654aff33e979999b7d12c68a073880e5f0823d30629088a1c3db33f8c357593f19e68efe4edc5a31d811f9e4c263bf3342565959f88ddcaa55236316413e769edc4e9eafcbd8a3ee00dff7b9ca0efc72937b8479a519d91c96cbf66f7fc3c60de8f4fc3db8868eaf9f288a861b66ca859a918e8bd669dafb003b58ce48eb73897518fbb5e5e7072f7bec0937bae5d508d02620eda1658b1e7ed359d0126076b224b4d0ac9828d1c3d2e7a2d544487b7a3e3d765a7a85fa3feef46a3f90621bebb372049e0453fe622741757c4a8741c569a91b60b45dc0056c2e723f2e0358f990a04c4d164d1d3c0f2be743ef26dfd0e6647d4302326b9c6b2f77503368289351eb4d35b071543f1493f8beb0e8040236b41b53244c677a668863ba7016ce342cd20a7f005fd747f27969e61df9908d4b5a8484f21e1b1bd65d7c46e9b805dd44a7feb46e2aff8dc0e4f66e07f0c5ed2eab23c49e99db8c8314d9e4fcfbd97195aa98c9ea16d4202446c5c30770c23397d03d3054fbd5aa78c8d9534b4ea509f5e26aee10fb32788a5f56523352ddfdfc9046757e6666c5da346b35c68bc25058ec77ffa2017494cb95faa2c4dec8b8d480b3b8dab2efcf15d663c83a3fabb8d9e7094514c82ca5e61db8d2643c5228df1533973a1fca08ff57e9c687341b9fda27b6af278deeb333b716a3d20de8dac0104cef01b7d55a24ac4087ea45e0261f692bf1e506da460a7d144a304e1ccadd0494991e6f300f9244b4f3594976f06e4d8763eea7da5896584d5ec6f938e9c5816d79f9b95e4a201eefa76b0a55b4325b5abf48aebfa43699c174a1ca5b5d10384145bd3edd0a79354cf8abfba83eb4e31aee6da7f121a697a4f86d81d639329a425ae7cfd8d3bb0a31d88e5fe705d4d351bf9a6d84222f9624fbd6c29f4db287876b64be68fc95379ae5d1be999dbd43a0199a6b8e4afbd37da9fd4beefbc135ade5bf27aeb8d9246cb47069dc2c5da369907d12229508d8ac1874585bb0af581ca01993f03665c8c2893761c63622253ead41f6bb5597a9db2c876bd3f80f20ef48ee35b06f93708f043fec732e9fd0eec834aca037e2dee5a6a5b10435e30ea0553ffe6db4cb5ee91bd1a1a6d239223da4a90217b2cd9d7c1cc97c0c0f1ce1151106b647f04d41efe02f3d273b3c9136435b24807e10b0a69b71ece66266e2a89577b160db53871c9c666f100f6fb4fed7988dd1543f053df1339b38ad0483472b424d06c5a0d58bc2ac02c82ee4da82b41aed816177912528914db7bf75bcf62bd136b1f5852f905d142524f112f32a0eadc1f3656e109adb9cc1c76a2a9c0150705f39e9bbce1b652fa2c746a8e3df8f8c8382aba97e8a83fb4bddc2de4def587f2e6e8ec73ece01354cf404b4966f5ec6cb8cc131f61dc08f534383f6a3c054f6534dfe236404ad676d93b2022c1d9e9ad824f6c6645ac219851f9a8872451ecb4bbc374dad5258e0d16a7f06b7151a7f140e01d5215ea8138c52770acd80181f5b34a31cab802195233e3c27442b4f023990009bfa58341e06eebd9f6630648896d48787fbbad9339cec1b03ad2f59b84f3677694bb1f5bdb49a3eae1d72af2b2ff31485f25fdcaa7d0ce023e6a8e843df818fc99953c02a72a38c1d1250bcb80943f01a1f30b1d73481b54124ca0d557d2aea5074660c4b93b70c2ff031cf77c3eff9ad6169060cbaea3a8cedff088a4e15d9016928131800645681f9245b8f4469002a475d46a3f55a477ee135eeb2d8d0e4cb8ca372874ffbc7c7206be460f3ab34d70348056f63c8bead214e2e8b5a9c2a6dc6b2b8883e9bb5d0a6931f1733d0b158b8e7fb75a335f90c45c7d7c4929806d1b33d9d21d39bc575f28b121d79d96c55772dfc17773d3a83fb81f4a2c1f70cf28d402d420005d41fab2d951ca9c45732f76d571c12b6f3901081f13371da8c7d14a351ac7f4827518ab2fd00b88681257b75e515e9d630388f399edcf4d2d308d82ef9ab31dce34155c5ece2dfd6c7502e2d4ba17f86770c4f6fdc39fe90afa31475124b0419cba13ad70250ccea5c2a186f686b1331e0b93f68e26e15eda804f4e1850c847ee6f8911210cfaf94eb1b04d690a96de74c85ec9bd514999c0b04e3ad748d3f2650cddbee5860199f4a8d2ea9d3762d4433b60ee01136f095997c1d36bbeab1249fd4f1e113171f6b2d526febf2670b53297620eb1c25dbb526f963dce3a3df31ae5dcd09b8a13de29e6b64783e7ec615b00232ced0c9cfb1b4351dabb77848d39c5cbc3ea3ea05ae2c5804b4287745280d4330011cfbbee8cdf8b2aa8ff3238a024c37c9346c6137743fc766055bf2d07a84650359449834adc61328e3097dfec5c97e8266f91882302215c6f587f3f2b4e987868f771566541ed604cbfd03df2e6f510c1ff2193d917b8f5f8623a7af95234d8c29519029806f4fb581bf7d28a4febd83237d5083a2f1bbf0559b7553e9a1f527390040c940f5f659bd314234ad2f7b3a5ab9e4769fadc062f21c3287f25e9af4bf488727be642222ff810534ccd54375267072f749ef9af124210c51b3d97c2ba7304674286021f2a7decda0962211f196a7526d807772377e3107fa310428f42fff047fad5cbecb1f73f8d32394db11b3eaa382124dd60a6bfd8a9fc5530ccaa2187262adbe39211e8bd1e807d784feb7e26390348dd3be95a475c547579a35be8e7316dbd8a24e4167f79b54da5d74fe5dee1c6624ced26ede18408281e3860bccbbcd19448bd512748aa29bb8612195ea2805456872e41e173d40e25951161a7c9cf9750bda7e0d88ab6f058fd0fe404647ced629d5cc78f4e446aea4ba974d13a04ec63b448e3a2a5ae247daf8a5456f7c681d485f5dd0cde58def7d5fb83c0394f2c7e6565a18c3e55bbec7236eef8669288312d54defe27035762684ca6fb1a78ec7c3a9d15c84776035f6c46d9ce77060782aea34684d6cef15e141414c9f662d9aeb1c8ae78543143a028c0b7fa038bad8eba73dea07eb33009d180227fff4fbbdbb574688e15d07446484294a8dd93bfd7e25fdcf97bb9c8b3ab189f82721222e68584d70c5c141a521856af9176eea398136586a516d65b959be5e9c281e2ab624852ef4fd7b9c89fec1c1a982c6abb7fe6338d1011cc2a50e5cdb6974669c39dc711dfe46f46f865001ef2aae231ea61c53cb560cda9955082dd2269e1293ba2f9bf395bb173e1430a16e2e71d90b35ee3770a7d5e47aacc069512bc42ad6aa9681fefe11f48878e27f4b659157e81c9a56dc2f6815760014cc8357be82338ac90dde6fb5b73c3a92698aff9ec12ca01312080aa777575a629429029b6acddebe17f80c21abd8ed1d445c4a76e3e7e30313e15ed0179c4f171680f2b0cee2f347836a2d1bc8a0f2ece7cdd64a6a37472e2960492116b752e8ed80eba25eb922ae859815821170a84839ae7579c361d6199bbcd55d254a7b48cf932ced20d0cc5254a3a2e2369bdb3022bcddb9ef40f55f89663dc34a19a50c7bda5936aa36fa39bf73dd2f9dd7dc252eb80e2510d40de71f1aeedc2ad38e1cdfa7b7cfa67eca2b1b6db111574dbe5cd82d37df8d48a42be8823fbfc88d752b9daf05c3b1d59a07337a0ebae3322e3ec4a7600dd743a0a8a7775af03840c8ff20413e607571f92af571b0750efeb720709891834cf6cf8f8a81a700eb3d5d9ff8e08d51012a74a4af01a129fbab8bfa05c1fa1ec7127a4cb4e519366f591ee341eb7173b41524e23a878d2f3bd2d1c6d3bb1a37ecc1199721a25cc2c8530df7c663ea683625c23672333a74cd2b23c36dc625b481d16cbd1ff4100a133c6aeb213b8b0bc2d66699a2e7763a19f2f1857a21f51d43f82645ff6e0857ef6c6e45f70235aca574413045e2bf83a1e85ca66290531eaf59a17b6488fef0f982d4e1dbc5bf0691a1e9466233ac61fd46aa93478e5429145197c2d9decf1ebc0dfd934ebed7855cdb08ade25525e98ec9a09c8df922fb7e565f1c6bba4edf7fcf28c699b43e891577695faeb87a678b6c0735249d6e96277f7cddd2f2fc88182bfebe5a934623f2af1b26c512f98fe46e4d040f970725acc42b9f2fcd3e3022f6cc1cfe2185770d6a3ccc91602205adcb18e1cdcc68a255e79d638a2b8e925bdcccbbf77c61d490be32f7801068fbf84b671a94c2403ba4e7ada05f6c19621c0a678b6500b8d380b3270d22cd57b401f84d667c599f980d6f1f38b035ecbc0528877c06a05244cfdd94f408deb0d3b5c57ce983a98c3dd4bfd49c1dce105c34c8f96dc703eb5f632cb0ae1827f4fc7936cff434606f6f7c83e88d8cff2c83a101d65963e1635a83e15efce28901555766ba39dd6b8a5fbc11540418a28e191459f6b3b1a361520bdba86a1268ba8607d480b4e527e7d07bdaf0b2453f9ff4c530ac4819994c6e78f7a716ff76bc60bcef1aa1759da8b26abadca3a287ffe1b66bb77f13b715c7efdd23f52e0cc27c1f2db39ce0974d940b58e7ce325a74cc7ee61efe20a42758b15ebd49fd8bb9d3200ddca3be99c805d7fbc5d8933443acd9085132a0fa367970c002f7a005f0966a90b6878b199b59fc03d23ee0b6ca21543970f0df575aedc041669aa021614629c7c872ab33ef1d28fbf8db574c3a5087c5d645d112ae924ae36e6beebb673c73900362c19e53589862b58b9a32629c665552e3e1c9ccbf65d605502ae09bf160f25b96d74f895c65c45ca2f30335ee0d152e6800ec2e94e1bb418956dd1ace275617789949bb0856934b9aacc25531023f09ccb406ad95024a21a6e1defd66a13c0dd05b08eb6089f8ab63d1964b4efd004143490e07d209ef4a3ea0fd5f3cb42502c63017a27e93b33c14053db1a507f3c44e4b04ccc8e2c35c1bc3b0875bf8a22be3e0886bd82860541dfd96c5aa8751269d567ca20bb634d269848fcc4d15fbf4a9cdf60b1f3527d26a8f2c98ae9d64c6072b483eecea800742e27e38fc19ab4a6a64173e1b2f78a7db6ea5e07ced4dc25be705817bc3421f1602de68898397579e24678dec54b788ebbdd809171eb74594c0f1319608177ab658f394bece686ec3979172884f250d079e8dfd35e7a3c2a3ee382f34f2cd757f017e780d10d02f5bec891d8a66b2dfee53fb9c1e1bd54f3bd04c3ff541318576620799c92e6e5a72605e1191b191c57610d5b9fa24fab5b2a5e062c13f72a5e9a861aab233c2e429ed5b67f08ee655768037a437b9fd09929c2dd670e9c3c81e4f54cb54498ef9475c04d603fbbb2cc66c473680b6e0f3afc43803387a1113b593ec0d7a164a8b8ba6e14684fa6d3230c395bd17907c84969ec0237b8f65ea0491f4edb1910d81f070fe4071a9da2dd527d0fe8af0c84411a401d9f43ec753ba1bcec14313bffb73caddd943a27566cc74ce6c61d1b1b8de354502048a11c3c5cc35f58665870c6eb5398694c0e00a57df7c61430fb1d0c904849ef723b1f667aaea14c491cfc0b441f0f0fd59bc71441dbe6e9122b7aa1e794b22065d02422c8622948507a125d865e81f01535deef8cd1f96f467f767ce9a0c2bfe515589f8ffa57ae7f9d0bc6f180a4a5df3c81ec4cc521c702ae4da9b1796fa96463e100d5929bebc9bd0ade86ffe41855e8ef487a4ca4594b2b8ad54b41b3e407682ee1f3a52f5806638dd168604a2146da31b57dd790f7a2474566329e010eca96d16b3218640ae6c4152edee9060c3cfe8598bcaa778b8ca8e0d57a183b572dd10649089d5696cb24f16b0e18ea1d1ade8fb08482c8c36fb22a7604ec03c0afa4892637164dbb56346313c07ef9d7209ddb3b3e63af2691e99831e752d6f952a0885da6954598004b2960abd597c93d67011600b35acb6e38200190351d5e564d93382c783b6214307cc61519483516584670dcbba35d1851d2e8a2dc754a759c467b417891d07edd8aea3dfb03c59198987eca16202b99af8ab1658ee7b6dd3d208a2aa02c412b6211ab1ba3c9fb0cb955b1cf83bb8b7f94629ff0f286486a990da62a33fddd0f11987786094a30b783fa791b9df99160ab99ca2725fa01fbcb09dbac23c3ebea60a583ca89ba732c763476fc37cf19d4cf2a481a89823602f4fe464eceb3af5595440826457971c67fb052b4fa2a5c898c200b847e24e4dcece2a187c66c601f516a73d9e9f2fb32efdfe3bd81842a2f2e09a201b2e0f4fceb91262668fa6f338c26bc3f7a91bba866bd95712eb1853e97b137c39560c38c86fc60b593eb99a2fac8ded910f1e685f9d885a39c5a1597457a340eeaaa4062985c1b927d936bd379be447a652648d24767935511fccc788c9f2a71a194cfccb55d66b54395c23e413210e34193aac78382172ac9cc67dd01e92cc1dec36e06d32f96b4ea7d5222f319f3360d7542f021e8d2f814ddb5de7af4880f47ee4796624fce2e1219e41c57d20c43994954334914c5533398f61a81fed4dad0e4977dec8032494c609cea11a8244562482a87abacc2eee85fe0ab921b18469d8d29237b61115a5d72dc8881dd51c2ac605962963a77e63974cf4143ba416065043015c05dcb049b2fc4744890c63783c20433209afef2f60d9a2d9ffd93499ad9533518aa71d53aab17baa5909e1b71ed158408ba4ba30e91d1fd361552ed47479962c572a26b46b966d3460df47776d9e16d53844715d17c73cf5d9cee1ed202fd51f67211374ddb67c834344922b3042575f5055ee27795c8cb754efa3c32dc96bddde1a049426db9f7df9ca3af451c720cb4e0126c35ace649438d3888b32cd4ae4612d3edab426e1cc7d9129ee6fdd2020faf01f315cbaf9195676477aa185527099e306f0cac4bc8c0e5367a3ad72bef10818b8b5b3434677ab40fe5ffed909fdff5effad20e98ab4859250ff2ddca08fc8299fe60d35141bb0ee291734886144a0d1259402168c77ad9bf37a9fc9b400551b85149af1bafca5009a6f87829c3170092eb631bcfdd87404c536ffd388b3fa879666175a6048ff105eeb2bed70ed562ef5eceefae77653b1b578af952ff2f8c57dde3d47d707d77bbddc75a3dbb6f60dbeb0cfcf178be9d6df137ea9442a47e61d357dbae4d72b916c9b9c26711b458773f07398db55a78ef60395ce02b38a7ba41555759470cfd519d7d3293da9b0997abbac72beca6b0a2bbdc175c379d4c08192924395d251c9cd6bc2685d4a0cfd139b21039510fe02d25eb482d861f1fa2433a76627042d7096eeb40e32c1efbba29a4955ab129db108e78b54ab8ab2485d2b259484c85dc1999f410267bcce4bcfdb99fbfe1321f31dfec0b6e93763d1aaf23f4fbb28a693f7fbc7e32f03eb194f5ad3d1ebc38d15a23a48456865c80cab22de28c8109b6d1e10e01b84072fa463b440e490d7aa2587342cc2c5b41c3a02a7259bb76618f39cb483fbc269f7621382e5f59b6bf73780b449b6a49e47e89a2512e9028fbb4decd78f538fc168b68d44bb804929f884e9455b8ceabfdd1829f6d30aef854366273455f89cda50dac2f250a01eb60f987cdb2e8170683b7e5cdb58c06a45de9243e1835fc0a8bbd9c537e57367faf263463b1d879d61932141bd4c93d34bd01fa4e5b5ee919724895fd5b1ff661f4e1eba252bc4d2a4512d2d1024fc80769149ab7ebbb835b475a8e66258d2ce3b1469eb978528943c880742658d75138ccef9f477422ed2e3a854e449332624215af2bb335532ddddbe92ca86fb5a1f92a85f8e2c4e15fc39e6321a79df9944aa60054d65ba251fe8aa440b9145c3df9a098e8b36d30e5e8f18cfbd75f1aee863358827c36c0797262670b2d1ef4edc63456d7c072710e476efec90136968441575101e2c09911e6998c2e860a19539148d4ec11229f1c5235d4bebd447e3e1cf16a161ce1140fdbd011586bdd641683a323e5e1b878a9a5bf137e9ac8083ebe62fe49e4e45a3591f268a5e59eb0dce48091787ff51922f46268036475ff9e392b1c0e05d3aa0a9d75a630188030310deb94bb720ef4cea29f2bb7766dd03d9d0f58b796215230ec68494bd8989d58da7f0c99b83db1b71aca9308a305f7d57852127751ec5c79d4f8159a5beb9f1b2daafa2e28ca91317737871bf12a6c5e98433e676ff68e35a8d9b824236373d2e4c5cb56f57919dfbdab5bd2e9fcbadf89a2124813707ecbbbaadece2d952e673c4106b4bc05a028aa51b94f520489d5f9c3fcafb5b149f63ebaf0b1c678583cd8ab6c877c566ae0317a4bd28d289b62bf6426cc7eacc49d974ce8dc7f1874db82fee1df593a735ddca8fdcddeed5559c4390cced089345f3f15214e93bf9b5541016feda97e38ad01b9ed160c7c2745628b20c39c14bb311aa5521818b068fd969d527db800bb626de0d3fc834bd68e6e71fecca140c4382ad15f3ede571956ae08df517dfc97452f104d323d23c5745d824ebd64540a3564798b562cb509933d5ad329987232ac28859b2e377c9a5d101f5eba8ac24ee8b64a77fcabd8550c719610f3c75f5156193628b9a9da8bee8f7c3a0aa0027b74033273f6adc9dd22967ddd05ff0017053b7a9c8af8718bcc5ca45aa6da2ca2657e6e1a970cfc1e3c5b6301083307d3f0d0af452b330beb7f6c317b2b9347ccc18163486dc4eb6f97633481bfc5d139fcd2249cd77e2355ea915be384bad120ba1ee12f91291ea15971c8c683623a73e7f4e81f875f8f0abb2be8724aec789a8a3a244d30490181fb63fe7199a283284f4a0df970e337ce7d522cf161bebc18bd03db4d3d684a6045b98684a3efa051c7f02c3b81697720238c90d3006cf17d1178eac6f4eb1c0f42de240dd2f8a31399e8261aa896f5dc0fec735733e768f397eeb8822cc6dd12c602fbb932c23f7eb71ac5900ccef2420077ed84ff6b3ac10694cdb60686dd9cf924923ab389651d8cf48e637ec09ac8977a17590bca18bc741169c352a00eca4844a850548d187ea5109bc291cfb4cb6fb2d108856a75a25c4513f216863e0e7552251b50b24e2d27b23ec221c06a058b0a991541526f70ad2206ca0c4f31fb5fa16deda7d2039cc0631df37078692df3274270f5d3bbabed1932d52220e96e72f5be58d15429e445f8742dea25054796cbe6f2ec55f5778cdb5f82f3573c81749410044ed27fc01001ce782a55e89214c6242c722d21db7b403c110c1b03f5ad7521f9df842b591d6b56a2ad275ae9a26f85304729ceb1bf1c96ca907f81c9a8b708ddccf867b29f33813ca8defc70a6ca9733c33716c8d0b8353d8b3c09aaac1bfb995dccddb612e9843585c807703a7adc72f0e546bc976b967a6b6191a6f2d86555f2e20a2f4bf44feea33633d77b2b73894c9243e2ea572d7b13a31c255c6897b2a3901d143c358fbdb08676427194d0b44eed1654d16cf20a5d4c6d0c4620e903049cc3505b193a93547507bc2f8c2dd2d56f4ed017ca578dc0a52eebd8af0e1bf26fefd3573d26082bb37db06120d58b4e601599759819af8142bb28d79066055f0956d3a611ce293f431e4e819040ab5843011584eba8c93faf319cb501b9a0a70716dc9532756a91335a88247d270ba0516dc1cb20f527cb8c3e7403c8dccf3e26ab350e176ebb90ebb00b7d145e61915f5178be7fda43ca511733487473ef6b6e694847653c3756ffe43867c3197c63adc2abfa5707148ced9e9978a1bdfb1a00b4f93af40e8e9880dd3db3720d26f6a07fa823d79cda1ad62e1736c8a58c669d33ed70023028b54ab82bd8744fb72f452076a765bf0074824b02b9d714adf39abb4240d6de0b471a0a82945142ca4f666fca4794dbd4d288bcf91ba2b91736f7b9d585781eee058edaece6cdd40beef2dd1013f21266e2dca19f87d6e5618174e8a9ca1e65dd044d2ff1c279e1b62bab69802aa2c15537f819ebfdf463a3926de0f9a9cdd857ef8d6d9b35bb8555b587e71fbcaac7d77a2d093d2acd0e33c8de6d9f7e786b35bc7f361593d418f107cbdee2c23f8378f9198dee51797cf014c934b49025288ecbb9aea829181e63a4d008044e23f121496e05008e8240358279d77416462299498a61833e5a16e377bb050a20f184141eb3ef6d2ea56a7e361bba782efc324547ba2df0c66abc92ef895705925bd02aabc29ab3ee942bccbb3ea70d16f6c6b5a76372d1b8ae9db8186ed8067dfc2f19b77f6567fa07c89e57e86c0384c0e070a27d2b927eb5ea0127b1ac2ec819f0b37d8c979f20cdcc22a3ebba7d0abc418fed0577896c4716c89348740d7f318fc04417d8583edfc48e7965ffc97ab3cf4b4ef879f6b0131845c9f41643a75c7e5bdb66d9b1ab84d0c027a03ba6617353a756ae1b1c842bb618ad5cd57e8d5c422fef7480f712d7f208a5f60b874a8b16863f47a7158702bb4ff5c4bf3bb8416df449cdd55cbacde15d860a90f90668e1c0527d876fb367ca2df96375625639ac9c874fa1972293f7207442b9c165e434b2705eff21795b44def45e7067ec7a08aff2b9e069d6d3f96ac1485efc43bb6a9f0fe162ef910bea251c7579b772f100e2b2a94ddad12aba801e0960128e14fa63a97cc6928e269d5120faf558f292f41a606618128a9e950a1df56c9570b15242d5508f179ce171cb24e4388bafd576bb03e2d3f2b7314e5606b97601e0cd30f73850cf1e25078457257bc2fd3b6c4448ad4c43a95d304089c0e7830ca88df2e5ae87a6476586be1003e4ae4bf6ff1ce181d667238729b0c7cdb816d9f913d28d2937a24d7370760ccaad216c82a369f9de0a82326de636cbf5aed944c5acee5e4f4541205ebf40cb27a8cb55de855bd827c1dd962ad25ef516bf012f3822d74ca05a8087af6ada3bb0f9ad2151ba4ae103992a8573a472e79ca1063989aff0db95604cb55c1f3df8cc4ced2743392af7f5e57c5a23886e38932ee2b4dbbf8f90fe4183a491b1fa4f3dddf9023f1d327084af4ddd4d564129a17d10a81351f71c557146b1a393fe7bf9241348e44b6f766713f83523d64c2f6270357facc34dc58bec81734b0d64a4f6b28fef7b0198779124e3c13ccb9f34e0252ae983112ab195da683e6b1da51e141e9627c66f5c645888fbae0b29d2d936e33dcadc2dfc285fcfb946a4b6d391f7486b7921c4af18c13c5bbf07395dfd9d2da8604ba8a1ec9606e4b081bbad1123f517900e4bbe7aa66b291d9e8af4ce43ddbd446a31cc3404276cb7677172703f4f602b93c2ffc245c88d0ac08a54a9db99cff189920ad13537bc10fa750f0f5683434dc56df7e9a72dab2d1b31f7673e655c10ce70c880bb8e45b5ff73a92764698d6e354e082d0fdfad557b81fbbd24ddc1f4f789a81f96c6a8dda50ac147f73e013217232ee41ac26c197fcb5e599b259e2dcef034944faa14db2fd7cb2cd92cba0336e9ce14095ee0be95e97599b1fe9d6f646dd76ce4ca2a6213dd6d5c18b1a3a574bffda1ff668fb9a28d8c83817ca9e075235073a848c608b89346ff4a33ab0dad6389362f27eec57d9ff0a1a51a150adb97e54fc45655c92205dd798c872efacafbb9a36550aa50ded28d0b978c98cabd8f684cd4ee7e9f18333724f079b84f6b3fec5c6cc4e9fb1c48370f98f62f4caac2aac904aa8c2f605d19f999546a83cfd950a9bf448096c04e5e8fd8afbe6617a456b2eede20e0372cc887f511e1587e3c51d3acae26ccb37105d554178631103d9616755d3daa457434e3859e6095a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
