<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09416c72d1af0eb46094eb0ca78c25f3b75b546e2345d5fa0888aceb95b35ccd537ed867827a172b1ea5a97a0fa4bb472838f083404fa326664b35c847c29b5275185adbf9c7235810610e51e6773a2990d2ce1d97592a84a7338a6c92fd4d2372f7e45e515469324971552a60beefcd09d539fcceaac527c493797c5ef5346c97c2340ea07fa5fd6c0db4ab0af96d0b703748ede66816cb774b13b21d55bc1673d972698b36345c9453fbbade402503ef4764e9f9c7ad90ac41b0fc128b3bea76c8d4f9835e6c59c96cd6ce13ffdbc9f0f460a7eed6ba8dff59e503d1e897a2f2820c938fe72731506e6d39a7d91ef99e6546d1a2b95a193cf1aef2df6d6a4cc4d1819e21368f0790cb0c52055f4b80d0639ef9cfd5ed4f1317efb4194707008b48ee3b48c199f867b22e9a3718272b8410062dcbe543cb163a267da383d55ee5f7ef612b0d3cc5bc47969e3a58ddd91710791e5e4931788f0e6d601d28e2c1310d03f9ad39ca6b13744bcad2cd4e01888d5371bdbed21b2d7dde9cf7070c891cc7e7d8796873752eedac7644f9b5a43e7b143fb0bd580b47f06d0fcb7e7b6f92c174afaf38ff2c21be6b9f87fddf4c2454399d150055052d3699b63ae5e21250dc4f76829d249463ff99bcc736bb3a2e2c3c096a4ebd5a85c8836e26689ea878125a05f764243110820b94ecfa150fce0252b3ce5638ff0e5e8f6a43c369881def101fff34ed62c05e24611d9908dd061d788a756cfec2e74dbc4477b74063c864b5d3a9add850d2ee6ea503124fa338998511a3dd93148637d75a442976f201a20776ae48b7a9f9003c3239d3fd69472df37643021fba6671ee4d62b767091d069fd90cb7b7b4b6d8114638dcff77b7310a44d7072ecd01cdfda24dfb42f612a4f1631b07ed14c94550cefd5bd0e4a521d9f4b9b84b7473b6435e1f40e05fa892aeaf40e7b12771f7266aea84912e9f042829535e339825bffb919a8bf311a7f4996819f3e374ff1c4dedd8ed27c43d0ae18da178f22821fb2e886e592cbc7f3365b52f019501051c010f90df1d19fc63d75dfaaea666f7c36face41d1abd35483754f75160cc13732a47b27f8cea787d95655e8879ab1e72555965b96345c97ca57deecd9659c92d57c9e26c01b347fa152e052526f5f829d6e91599160605f4f5ac0c1e601f3952544140921d7e50a71855b68328b5d5f1307b986ed8f725b1445fcc4f0ba81f1e84a287051f8c6b9f3f91590ce3db1e9e9d93c3ffe28b169f6806cb7d9bf115d2a09ab7b1e26cb960b337834cd458a38fcd6a52f00a6f325554978dc88120d75abf5e4dfd7208d7bcfa1b4ef92264e50829374b1751c2e64f5640179f50eab309567aef96ba0e9cec7aa9f939ef231072f617827fc022981445cf28b36204d8bcb5f71703dfa513246f6200cf29e658a7f83d1c42684375e26bcd24976403cc7ae7413aa62441313b8694fbc1d6d12ef344a950a62e7226b7eb4aba696ca01ed3a6c00ccfefc1f3321e09a083f169943a527bfcca82a5c34f67a039e4eb4350ef72420e02b3d5a2ec11ed9294af9287523899cd0db6c5fc1f559068927f5b8b78e6587e77d66e132a27461cc91bd4222d538aa7416aaf7279c51b8af85708ac1d45d96ac1414f10f3a4126378a6935d495347f4a1e5be783f6b65ab342d622beed6c513d9f06334b959ca582fda2e0b2a5a5fdf1f078b8e6076d5720bc37f08bb0fbbbe7385046f3df37debb6440960966e6df1513f202b24825ee1c705f969ef00cb1cc7bfadaee26b8d7ac3aa33f4012768f816b4ca37157a1e38b9d2790247d98f82a680fb1864f5ae1f00687fee7a32629c40df81439d71d5df088292be93c283f3bdebe11e7a1a19bcd4f32a64a1958ab658db40d7c51301bdad84041fdf8c78cd39fee65bec077a564e02790b4da6322d38a71b0af48c37320e8239190362862dd0297f99e7a2426f3c37ca91e6d267ee4fa229066801407afd1b1d32cc103b2676e9aae6bef1ce113876cc4c6857e5209f8c181a70270a9c7dba5a6fe862c6e19c92dfc1ba536622114dd5ca46913acfc8c89bdd3f3189b03c6bc5dcbe2ed5591061a9e59a57bd7de5b59b8e89462ecd7dac500da6edbbd9779bbe6f9977f87bd42041e70866bee36b47a9a876572c51d2bdaa28c10d1126d8db512dc61f5e52e9524d224db01e2bfca1d04374ff4237b02b61dcfa59242be6c4fd1de38e5b62be7b8af8f8a8c46a83b7db5300aaffdf6cfea537d0f8d63df7becbb7cf54218611b55440def6f65df6b6399d039865b7cde74ea4d8cb79b9b120accdfa6eb2bbc8092183e46ec23dea4b7ab6a631484243f335b1e0cc966cf4cfb297e726ad608862641c23aad6ad7a00c481a9b129ba836df98f59ec2b08ef33cd23f54339f4b37d5386471a1dfcecc1acf1775f6ac856c130b060cf7009030359f275f0ffb509ce07c17cea03cca1b14b0824bbd7e9788f58115ae403b0afbd6e4514b135f0b8df10ba10c33b38b471a7ecca9708f8286d1725525b3bb4ae665aec0d9d5ef59ace979767a3c4bdbfaa15234cb4e0e2b4b4f7c81a97d3897c3e4632eb46f07c14628532b2b860432f0ce3d29b076140a9a76f0a791a00437725041a1b04823e9b43054cd85c8246ecc0ec89ba1aaf1cc1a1a765f4e5961f798998ffb8e0fd0fda5a5cb36fdfaf98acce469ce03380ff6aebcaf084f51f848a43afd97131fe853e6a7079649cda5f14bbb11fe6a01fcc03d2b2ac255ef2b25c4f9117815a037cfe56b3fc0cfa74e483ef4446e9f14569a1d7b47b0616de02dda42845d3275d42425f607d76874bd55e844964a7c33c4f5ecc649025b14e9d08d9ef99ac4903f913500bfb9c61b505632b9a0892c78595aea3d9931cff536bbb75129038c25ddd7e8b197c5e2a2bf58c5fc754a19ecd50d41f748a2a07aef10f4ada3fbbe8e2751130a2617c35b4299761b5e87ccb111c19bfb067285d369aa8b034814935a43a00feb4bd2f8ac05291d8576365605ec1e3930c3155284c9aaaff670a54bdeb206b5b02cdb4d4c766d20edd1f2aa1ddfee297cc42caf261531ef1c5e7a004e40767ca22e6af5dc1557472e23fdedd7e3a14aab3d62defd7a7395584c5c16e0e83cd374dfdee7e35d56bcd646cba14edbeaeaeb22760d536625e442a90095a94de23463e340d70dae79a8eb17678b7a4f18ee1a9d04c79fbd0ed2fff17b08fef89b7e7b6f9a27d7f0cddcac14a6cb2c003fd58d01471ebd3f1b06775d3013c1dfa49d7fc2da97528b537e036e48dff739c4ce0ceeabfd8f068ae2084c7e6301ed6fdaca9905f1d380412b8df7c2ebb6357807abc7c335ac730ea984110d1b57c0a9ac8bf1bbf67acc3976244a2abfe2a7a5ff03871e846bf23bbc7b4423383ab8de65ec2559c3050637ff3b5ac8e0f95392aa069a5037514d181881e08fe538b9821d2f023c86fdde02a7c6f58c2c2b669938c94d58d349e9f612196d6d82b8b2f36df767ec4441aebc1270affbfefe6a39cc65a8e8fdd4cee5e0fd076adf1b69531d36dc03718212f8d526ef0907d773a1adf5fe0cc8857cbf2e67f49ad97231695b6351c1ca04e2e4da51ba24dee2ed5988dec94681c30ccec4f3b7be33352cff8960438448f5f292c11fcd30ba9a98fe960d6396455d2a615a7b2473c1b5bce586f87e7a2c8c8ea3c8c1e7be068158a254144a0cd3253e45198d46a79deae4e93db0f3dbc21687ba2b2dc7d92492eb89319b8a6eff8443bd1afb8aff4c2f40b3de89a506609d435be1ab98433dc20396e97edb747c6f78e8f9d67ee6818abec12ec7ba77910b775e2bc554f9f780a52ef42f2d88b5fcc5c7722226c78950c0dea994f0b18e29e2d5fa0861240656589c7acf56a0f40dcee7435fcbb42585748ddca4f278bbbf94a5d3709c865aca8efe9ef6eb033a6e2cbbeef497af4b26e2b9bfe73ba9634b8f3c5834ed306ca48d3626d420b0253ea01033ac5cc9690347ba27291b5bf69e28732fff99cdf944be58c38bbc5dbe4a725e12c7e954df8b501b77c2e963e998e61ecb9a88bc3eba0a16e0760050f03232b74d333017ca54e9c6a4332b0624bea57eb9b9aec0950e013a4438bcf60f5c87cd3bcd36e2cf75158a6c4f406c1a85dac57d6f7231ae2fe97ee332468fade1838f05ce1ee156b903c3eea895cd82fb15da836a117592c82e1388a23d07570e67476773456bea501190193ec2bb6124a004ecd52ee506d6e3f9c466483744be114e3beb46da0562144f890f6df8d5f8690f4c12e2dd3379d6897e6a8b82d1ce7b6308aa0ebae84b958c748eaefacc942a7eeded0331bfb46ce38adc795335890449c59ff1c0468adbe21c3edc459351e94fee877f5b965bfdb230aba7db517ac1b5dc6b32bb621a85ed4d4e4c24010b4fd0863e6b7dda11b3c34629ea6d4fae5a5ac76b261a32696bf6c214b6cfe6104e5df3f94cfc1f5cf0253816a3ac4bccfa454d01b1c841a367b37bb042f082a09e1548cac10c425be3bdd5696dbf80840d8a6171d1126f45fa64020abf8b653cd554556c99806b2eedc4754d1ba30992e765672c4a925dd6295540822c2d0f756d05e4907e05765c20552766915d88c55c53c8ad15b313f8a2fd1cde10d85db4b75d1eff2fefa9284b0e0b308a1ea2f4d06baba1f79f01fa92420295f39816522508197dcc10424940fb8ffef59696d7f6b04622141b08f917d862535219b72f0fda99dca8b3411c31f0c28d8d0463356043ef76613ab48a7de6b0bda625a0314a42eda00fa9b8c6cdbe61c9b70200f53175b25e10738dd1d58080eb3adb3bfb58fb2ebd859b4383620d17b104607d22bd4181d0f16520065dd3a04773a0f53ea0c76d7d5df333242ad73971700ab1cc20be4cac4f7c2af3f74b5798f8f8891d0f5cb5ae0bf5a6c44b85ead1953f2f03bee4773b3a5015d8fa69a55a1d58ee1e4ec77fb0489446cc6a3c4ca8f351e199e0a74eb82ae22d3d8f02b790fe149e887eb9eeaa83fc2c02e88d0c5e4398eb809ea538dcef21365331741dba25da94ac9050c3816617e6967e3fd67aeaca29df61fcfd59c17ac3a16488b50092e7a99c129d08c06f8d59c0b4bbec74b587e395f40648aeb40b9d53355bdd5f66d65e05fcf520801d64c6946457dfd9cba3f4f72e0fe2db09cfe285de6e5fac8270ef0d7cda25b59cb3519c9cd9ed997cbaa4220435d69566cf8e38b52881e8952ca03331229e6a532d0b7e3e0e62cd9dfb568b855b1546747608bcd9fbe1182e53f0a776627e5b126ec564beb7324618db2157d58879a707e7f2c7f8eda77370ba9df6871496ddcf7ee8a306b5d1ef5e4a425995916ce4adfd9d8801e59d8d79680018bbbdbe34d4160549ba9c7f8d11170bc1a0983e0c64446939a7c5a4ab8cf250c04e292ab0b71e60e807e9a2e04606743152fca12da725c9cbe78c4ad711879583a98c07326a2790eb2f820346761bf8f1a90d837817156770c5c8e9a5e9488f7d6f18286b50ac341abd08a44e7d42b857c3d01cdb8f22f1a43c95617b13f4a3d58c474df0664a98bd774425e88bd43c2538b8e6ea9702515f58e4b4ec8ec4a80c87fe229e303408948b8c41b99ca15ee15c5728088b0e204f0649ad983a901adaf6e4beafb3c4b9f120a94858c41e819daa6dfdc54a5a6a7a4b56cce41d202357ebfc8d71fc746d6d024ad26e82f95bdc8f9d0d5572308a2398d5cfa31a75462b7a321a843802bcb9b455fa061f135fcccd6e5b62f401447094c40b09913fad376df4e390658b2c1f60d8b1fec1453a74cc136103618fcdbc8d6e5ceb7d98c8bc80ba499872bf0593f6f7b927ea6ff82e5e81db85188b536674dbd17f95b2bd4f76c0497ab77a048d6f2d8b32f3ffc6b4b11d48abbe6290ecf0d972620309147bc5c02478409af0f798078668230603f0da2da51c6ef84f19d4c6784a2270a0e22459fa01b0a0bbaff9e7be49d823d2880d084b62eca2f646ed3044f60130e9ea29e5046bbe34f6b2ad94a5a8e80bbf8d4d5007a2d366765f93ec510c3378b905cf0f018af2678c60500843a1637e52420db5d1321d095782c0bae3cd8b7f4add0cff58278c1f74c0d05cf1559e22d910a204b0fe707a63774ac06c1f173c626898744c5c76ea0cc60ee07960775260dc01638da5106b562800087ab824ba8b44fd1c63ed735324223ebe02a647c4a23c3333d4d94e7b7f74b6e9c9b4974ccf000f224c7c986454e085d11a7da70d49d96efb05bb769d255d00cebd34b003f6ff25974f3edff0271ff8184fb4de8c1c0e783ec19d803e3aa931efff93bc41e9e2c6ddb3d33d91f332466db26602e28f95bd49254ab7e426cc95759db011d316d022c1dae9307b439fd2b6ad74574ecb6c99a57bf6b0bf55e35d3d442a8e44d5782203515d118f2a92a5430ffec068e4d92143c1a14130ee2b6edfa937ff15c9fe7fd540a1460a09a180b805a9134b35aea9751775cb80f3131dc03a03aa2ff7f705a5c9c230c0c2e0ed566b714ae7afb1f1c25f6a0f9a52e77be2366a13a544ced1d1871b3075feb1dbe656a91455d7454a192b416f7d085ad5ff80c5bf1c93715a6ff805a36b30628b73ecf02f7e5dfd0703b4d5cbdbc5b81da486b013503a147dfe3d5ed9c96154c1283db722eabae689a2d514cd7a4d5abd181634f8d157e33555725a659c423a8508f7976e802af8a3a5d0a0b101b6ce3e2222e473ca377edc3bc103b03438fd9944fcc632efad18384d5de471a7a91ea2561e12843fb54da543e2b5cf94435c0fc38bbf99c846bcd5ccd433101e80fcddeb78fb8b9d812d3bd5388ba5c73c152dc3c17ca768a8712a1f04acfcefbb92eaea45c6f281dd09e4362181cca9c61d7e0c434c130a430e0d5b7da102530e97fa57e6c1d6f464dd36270b39239f2896344ad849cf9176dabf0baeb1251eefc4a377763496fb2acb66660398e3c1e8a6b05271654de5a672c1004108554d1753de59519cbb46c2247d2a234c626b04cbd0f387212a1548e1a97dd70ce100fecb43949e1cddc212e7ec1c57b110e913ce8d9d59ad3c088cc874016ea4daf829679cc20480362fbb98ab43824be3cbaaa19178cb9223e2568791ad6574b0ab7ee693ab0900e935cbae198f168092377df0f78de6f7c7de4b8a4419a9664a9c319c79aae3107ae638369e077f12e26304c04a94a92e094dd4b88f332d6b22193a787b7e6fd2d5785eeb7a178d7d16ad6235127d535518023913664f3b76e07393244fbb3fc452893922c5e94d01b798c48b83c0c3c01955e6a374d4eff008ad98e6b493b2434f37211315043e0064e0d5a5583e710e8742671cc79847d765ad1c65742407e5871b381e5d9ccac24a96f314a1ea33000d73913ae7dc1ccc321f351b530f98fb658aba387acf7e801b62fc2c364d9923a49c342221507ae387400115421f69de4ccab55c20fd2cae5df10fd9d8094162c046b53b46680c4b447b20452b336f2a96d03ee6e8907a519663253798fa4e33288f5616486bd58da95a52547351efaf552844365ba433cf2de587152e64363cda0aaf301f4da8bf34e13c8f18a6928de8e2bf7a3bfbba745bf425efde02454a215367c38fba8d57db492b4e8823ae5bb7ff8607ebe2b186d5f598c513b7426e82ef0de0c94adc155f526cb24a46d0ff9af20a4591202d0691f9c082bb121de8081fed3048d0fc1662b5d6341e3c7f5238dc4d30e9303ca847037e0a7f479146dc3c5478c9a4b14f1fd2d9e737762fa9d3cfa02ee14685c515936e6c080c20857f41c6ee01112d2fe0af4d9669ac6d70b6de9b3bb7f8a7ecb46ebc4ac71d984645d258c0e9035563c4a4007959b42a40a8439a395bd037645bb51cf73767be2e452a12a98870a2b59e59ceec4606c772dad2a62f12a48d19298073d47ce4254b4170d7d5087d943c212f724f313e0525c886032746c0227be67cbc0c2e7ee68f81b028f14e6341086b06efc1fa70859d3d5c87a61654fbfdb67c19e81dc9618fc695e5cbcafb18d3be339c54079b8d8fb5e6c0b7820426077502757c3c897ce3fefe2e2fd1b9fd0f18928393bd3503a1d1830f256008883e064a66a23c044b0afda4420b22e3eb31bf0a3576a2e2f5848cd4d3ac39fe4306f16505ebd15ef35330a58c87c1d0b99542be2d7cabb10dedbd5a63dac6235335dccd5fd8bd0473d5b04dc7b981a63b68770e38eb4548a7dadbb85c1c1fcaaf389fd8f421beffb8c2495f4b96feeb5ee1f0b8e01d96811cd877a0266d63c5fb4ad5809e86893a8ea006c36afc3bf71bd598df1f7c5ac89503eb68eb415f4fc88df43c9ee45ecb7b040ecec2b3235a60773e415f5d148cf83a4ff17f636d1cbec2493e43fcdcd9bc85283d8c54713be19e9a7fed57038ea22889939659eeb0341e2e92433b8231b49565bced120abdc5b6453d7e03beb93959e3845ad6680cce72a8431c014baf24bbaf14c55995c21d7f9228c01d87da36e134585be4d40d245e3c6a211c3c97fcf5ef4941991bbd791b72bb2240a00469c445f27838133ad4d9f55e3f78095b36baaf0aa28dd45bd7d0adfc592191ced9f8364c08b570576c476c19f544ef4c7b2936eabde0d626567c002c9d15d853d0e3ed491b7b5f8f27ecc2e8620efcb5876e32cac97e8807d793a9bbe855a8e7e639438bea4457e1b2ac6bbf25fa46f9c413f317de66a17c0b886fa409365de69153c7c12fbccbb44159e2a6176d3045508a988d29d691e596180f72111911cea5975d981b0e1d4669e50b9e120ab22d2520574a39b05ab7c6592cc091196321ccca72e6f71f648d3bafe571c417a4045aae649e61f7ea0d7761182d5fe6c333b8aa982cd6199daffb23a4cf30e1ea3b4354f813f3e859e1d5a871386f0ab516d62f71da91f3d71c1a0ae5b1ad4b45c497ca133cfd557702bf94aa02fb8fbab875186d75e0e42b64ae710d9c506a969073656b78ed027bcd47f740ea90573f16a214ca6691a37e5955f7e7b7c76c20f656880e1fde74812c0cd235c298c218e184c8cc5b7edb9c96903f7143631d3d9bc4164a19b3a708c9e9f91d7bebd434bcc5d7b23d061d32f0620a00567d439785de46ae44d7050f071117231ce925a85b9f21969055939ace6c445a4b5b9e0d318cdf1dfe36b4085f901e939f3a0cae464c0fdd89de2d0310548c72e9a321acd86139cb4f6957552a48c685de8823d64efcee331168521b1df4a2bd084dc2f2cd81c8c5aa75254dfc7b4ce64b35cc9ac6c0a0e3bef431ac098e5f6b8d1120b1dce21892b3e450e2bad439de51553b9a44cb65aebcd351ad90ce1649d9673213978953724aeb5a84afd4b861cb68b4a50e8eb7308a735200560a44a5cbe4bd13464552f4c5cd904cfb51f56e51d5160e8c56028b0bc2347425cf2a3b6617938af08f593c388e92cb0f7604e743903921f52102c2db0d97c8285f418ba9bad7d4aa3b5803c14df9c35661d9e9e8b53a0e9ebf2e17ae8990833337a661a6bcb92617dfb5c343e836061fc82226dfead3ea7fe85e8a26056c99a0d78b5b4647ec6881d69ebeb0a6e636b8f5fdc279a6e330be9702b32801a5bfd7f4aa4cb99998bcb498d7db767526af32a6db68081359cb185b7d15dca5c9d47e94ebdc480ed70eb9d9c128ea29ccff7692b53b5b033910b1d4809b916306a2ec6d0640a59fecd6b1485275d754b959a51862eeb99a1a9877990ffb02c8a6f90e0cad84f299df207fc50c47aa16fad6451e9a294c42fba2dd19557369e3f43afc47867f693669acc7e356047b5c9f4f840af942d68e969496823e87f63bb48078b96f02c667f1811690b481594fc249e689b38c3664a4a40d2cac9c57fdc74e3fa56679eb050e9c9724f06713a28747111956033549dbbd9b952b3cf2597c147184693dd0a519a343dd8b5f363bcc7c8f749ed84d817fa714255fa632d20a714b29cce07229779d01a00a9c71b2d97a40e4a43198e37d6b160e8176da48b317d64478d9b35ef87a5f7f1d4dd5c9a9e6d388dc65df73cf75c3df3fd1e7cdb80182d09027c796a16a1604bd86b715de01db53a2081205ee9f2d0321067896e20a898b964f8896bc096faa46945354b0de514b8da319bcd6b8e84e2f3a10052c1a9bb1dc77be42c4593283713ff9610aba1ab39ef6fbf1a3a2c58e2da2584846c960354f7901f5d0116fad0028fea353940bb6c8c82a0225b6f1059740b4f903b30ba22ed729e8117f2c0535725e08a9a5dd47314b457fe223c8df20b0b8e01639382eaed64d13dcf3c5deb246001125fe5dd20b9cbaf24f97d1da9f7342e4893893ec7427c8cf84171f1ab5998e062b383a3e5b13df23a5ef3603b76c6bc068072d8859e3cc84870c14d7d8159abedaa086da975932de3ea6878550555ace578aef3ab5f5fe2e8df01739c95f212f0f274f21358a911e55fd223d978454f02a6930cca190d7fd78ed635e14247a4058c1561827a7c9ce3ee53c88932c1fb7a3a06af064d0f06099ad6518222ffe920a211a6816155fe2a9c386299806d8e5ff3283d90f9fcda96c310cf37f4f243abbe53c9504843447184ed372116ea8602d4c39a4751327d70ece9feaded9e188e9084d3afa91764ea4a4822e15d27a6db5ec940598c44864ad4babb54c5193ab19013df378a8f8f6db16255a7c9322c8e3a24eee3956efc86fbb2c801d3d945408222460218a202ad3400fef91aed6fe20efe80d8aeb3b8c315455104517146ad8b22bde83d02e15ec6c4848278","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
