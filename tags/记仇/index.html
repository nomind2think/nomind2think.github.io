<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20adc583bf7a274d891590d22835e722fa1b6eb890cc45006aaf9e4a71c50e55c4fa13947275360462e3a88015086f9c791b601985f042ada45e9840f21b7df68b56b655ec17be61bff6341e6ddfb2d3c71f9fcd88f89938d6ddcb5ac71ef450590032e3824e3a467c85cdfc23d65865a18bc594a4da3e9db08b5d6f25ca8be8ff50b14071db83d120159fd4c11d76a95c1d9daa468ee5eb6617b7da30086cd4dcc0b69c6dea1333e63f03a5a262ee23e339d27d183c3f9e5970a078d2ce0306dc072920df5cd10db914562ded8da475761e187f68fdacc5966fc2377b24423c3b33c1491eea9ddd68562d908d5046db3652c217265c268959ee7d26fa0ffcc9fe2a80d67f949c126186294eb4e4fef9f534fecf2288cfc712f1d00d6608c56dff57c7c67a4fcdd6eb7ce37e691c9251247a9c4d6fc7c15fa525b92852bb2f31b6f64c3cede8c94a6810ae0bee959d6d4681fa958659d83a43c6dbac11564b943bcea9ffdac323c9de4fa598c04cf66511cd3647050a1a9142a56c5cb29e801a9d15a47ee38a69189b078775f26bc9904318f959887dc33ea7081ab308a78c60cc6f22a977e40a13ba80ad5894175129692dd3bbee0a6e20663dedfa4feef95fae5095c82515118005027450f8bceac5f62238d4f2b1d8d35412bfd124fac1976cc3943031da54233363934cb9208a37e6c1f08b6b6aafa484aefd0f80fe84d90c0c633479fdc97492991d654958d2d648ae768cc98f0a0b428fd877764a5e828f659336d0bc6e910c4fe1942e6c447ae00d90a75d47eac2b2e2e2f272020bd92e47964c9a0f428172aab73c59b50a6d0908b0a8b279ae7c8e28fcd1f8cffd7a7c6927d08360408158b5eac1099d2c04cece0dcfd2234029f804fba6b55ebf9118293b3ce35fe15c5b604fa15f1ab53755cf03bb448b4ee7c39fd59f7fd327eb4ef98aaca60ec534708f6ba529e5846390886d04c41a119ca457790cac0ff7d9451019fda27e434ee8c2c321ab64e4c23fc91bf53268e547d54e5c0a925aa5e22f74b26d2826929ffab91a70e61e39b89cd2b3527c3a75b6b9a56e1cfcbc828145ffce555116092533a4afcedd167966267d20d130d96e5167579d463ebfd9786fab170f61393df9ef69785de252ace583fd9b46d61fd752da2c7acc341eb94e0c3e288bd135f33a1a970386a17b1468e1e3b411f3afacc230056a7693c99a6f221dc76c798cb9c5b363507486b588a1674b4877bc4da896dd5b2ad0222e50175346f98c375806721ca0ee9b37dd0d55bdc483222371d03aa6fc51f51305bdd1e476ae044c8e9d3abba259d31bd2b26fd66a9f53a58cded31086edd3600692c4c6f0ded24c32295211aaf18382e4e6271d9db4656f1d4896fa5ce160422000e8dee7593e6ede06b493a0b2223089294ec02894564adb99ae76274d52acb6e7047b347425cec02d11082a2252d0c5f4d3936ca62dc18a6b128388b3ca9a8979d2f6fe19da2a035dc404218362cba43cae89612fb3296a2df4bc2f74a8962df2e65dd1a66ac6d78a988123cfbe4292290139f94b153d660f26b05131c530a57de821410b675e1c14843f172c0318cb57e10f1f196b26aef6b86442d649025cf70c8aa96e5e288241714a608f7a72c9aa1298d53cf136c99ac3abddaa05422f4e4d2dafaf969c2685d0be9f28748c20f2d97f0f3bae97636d3d22d27f29070cfad5cb04f0eae7c40abafb9e2b54e215a435ecffd85272371b76c85541a6f20127fce81d1fc067db5140db2be7a8319258cad97a931658a5c879b0b74a73f452e17392a2117b0bfb284349deccd598159d2062fd87898b22d829ba11f1135a597b1e09edecb2173455aeeee6f1452fb88778c745eb007b6d0322896e8d8347a2e05de8f74440db61adad34cc637af1c9422e31bad4cf64eb6f59cbae0d4a60ec965379c2705b634085332df671a2b33ca37f6d3a7876f5e06f34231deec0d7f59af1847edbffddbecb9ffb74feba4ebd8c94f58fc467902142344f20df2f9e5987526f200973161f0d0f0c1bada4e1b63369babf5343933c201ef2943c4265b642e9f24b986766ded4f72142d46466fb19203d9e0f29e3c22c8fefba5b73a1ed684c36e3edb8bac1d14e5fafdb29f5fe8d2e43abb6cb03c7e5bf12e3a98e7f4aca7ec8c96d42ec339905c158ab5e6228ac0ac7f5385cfbf559c3d4719a7e4575f9415c4b14e24f20593b793f3328f0b5ac0e6f7a21bc6f02fcb54f06d92cf68a054f97f0f545e406114688027f691af004763ff5ad73fabee2d0ec76088d363d2d731cfda0b798c8ec3f75946a8edbe007a1980b5da93ea8703b37f62663a00c29fceb0a34e1dcdffc742a5faa905efbc2a0143e9c38c17fb69ab269c2251683dc903e9543fbb91b17450c2ce361ff3adeba6d977517fa978565bc7a20dabaa73d58da12a1c2f762362cee92bee5433c28f9587e81d7d0bccb1227fcce0a948753e9702e4290ac4e3d2c0f8f66f1f97d9ed49f51f9a96f2c5cbbc1b49d9d1cb11a72891c103966df84e9ca8fd989892ddb9e0a3ffa96743818a45474b0b8fc51fed8af7c9661f39a73fe494ee9df3c498c8133b53352abd5a53998b8db8638f41c7a43e8b57c0a2eea3a0485add4b1479f16665badbd2fde67567205aad61ecd859f4a8600769a33fa19822452695023b6483d5a6ec14ef5d179acaeba03529af9fe6ed117fe515b5d8ad2c1ca39eb76c7395912849f87633b664191f5e05d001b5e841baf04e329fae538fc7b12b7045d115f98819decd1b12692cc8d411ac3b5874393de18904313a2379b6675d827691fba61e2a128cb8649af351578560b6db012d90b200408fd95f51f66c08bb3fd338215385990a38693ff066ad8a623143d80b05561c448fef7fa1c5573d180b7f572d567933551d26f384bdf7404069bad12b91fbe1b7eda83bd1aa7fb785f74b69607d06af8727fcb804cd318ee0c03b1799e55fd4276b733e862629eae41b1dfb401dbb11090abb49423c253cb1f2f0990d096a3cc964230e5802a0c506c4cd0f3e28d539bcfe1aca6e50e813e29d31550602a6946cf009fd05e20f8dc338ba5e50fbf5cd8277016c9c4c9b5d459e68f6a2e39fd1be1eaa461a795aff7bf9a61a7de9a71759a69c850f8157cbee3d513e93a7c252311b50550c86b4d61ba5816876e3df91d5a3306d09880209dd43041565220e8d6f2432acbf9bb316c9877d9881b9835dd3e445026acbcf02b3ab1a013afb627a53bcd8faa6b7b283a905d4dc989ff35e2971381de3c547f82bd3b47b20fb0488feb89bedeb757cd0cc9988e3dd14c0d2b3cf14896ab0a657deb7832cf218074adfd751e05232f11ec7b2406bcf1082f46117ebf711d1133de1b34fcac8fadde249634e5fc88699ae7c1db003b6aea6d523af4062d6a32718debc9f056203dd056b429f34e674eb473af0a4032e3ccd89def5aa47328bbf002dfe77d0f25d696b5be9e093afefeb4d421e3514fb2eb4ba1b916a18f4135aa701246ab8258db2a23494e9afd9e8df09a78722299323bf600b628db507084aaa5a45d804660d453feaf73a89103a2e9df9bf4638e5cd597a1000535a296502b4c0d694833f7439741d5d8700b165de11d2704b1531a3288c3701f3db1f0cce7e0c9e8340e4d46e7cd43e01fbc677d9071a3e0d00c33ca9ed99ab0086d1454c3ea14f510945ccd3c5a92325f092fdc14fc9331a4b621466b32354676f1976db6964b6f1561b4a2c03b3ad747f8a61b08092c4181c0b33243557919248bfe1fa2d30f94508348e20c973c66db76d2faf811e3bdc105f79e514cbe82db6ba49c7a19b3a4a8163bc95e05b63ba710c2f91240b3c32478dcce1dd8d6d4225c942af1ed7a5f525b812758616e124237680ac81f8df56c5c4739d91fd316cd42f9b9f57cbc287166198e85b2ac94a75815d555e318ab6e502ee568d47a0c66ee9466487d27f30d3175c4d7e326960c818e9d7d05587804b4ea16bb0b06caecf9c8a74eb55bc21e01c789c70645c1eb50b12c7152c208c5ec49a3656b91d662261971bd090b85f9fce51e1cb25813266c3abe1a705c419d867e80cee030c1258083de4229dc3081dc23b317ec051e29a8e5afaba41c48e9df44d7121e0a757b8069a42edb46b55fc1d4c3456d9bcf91b4f9e823dd8ee8abac6ce87e384bdf1242b4a36b311b53b6efcac62aa888e6f37cafb6b03d117d415380dbc9ea0e23f7221fd173b9b550a53968b3521dbf10f5d9095eed389b89a6e2fa079f00ceeba4271ed3bb1943a9c0d545aef044feb9c019ac81b52c2b758e06586b93461ee20152956e7199a8941b62e9875fa11478f3925becda8b9bdbf9225304f497a383017122e9220b8eddfcb01be490ee2155574c844ed00ab39e46afe431a6fe581bc639cee66c38b4a5e50e9411baa29d6832535ab8dd12ae772b3db06b9f02a0aca0e8d5c5235986e3913f76a1d1a08ea65583f80bc6b8c02eaf5fa2ba960a500357b8f0720d2458a811f55d9997ac8e2b4eef851d911de9ba756da839dddd8dbe85b28a96136c92205cab638f6ec68cff1da5dd44cedcd0894a3c8412cca8947884c5dbaed7ad164f2e9947ff5e043986a277b3a47aededadee1cac611325079f52bc707206a9ae8397554fb3978b2f99623a8fa8b60c89c59606242225739c72af8ff3c848231220def6f4a567a0cfe778b7bbf9545e4b015c1b33c148e23d832ee90266fc291fc13d6a322804a9ea7a67d2370b8ce51aac7bc96ffbf4d172c474d2ba43b76fecf3afd52bea9e7ab4a815c27eeb883045217561a429db003dec7c995c6e607f90937560a0127684a20199db6d7d3dcf2f22abbb65bbfeda143ff74426c7e9e3cb7bf4250b30baf7df2b9fb41ff4f66e0dd42d960e9018bce7c3094d64c901ca3ded004f0aa833a99eed6db0ca3812ce50b7a17bc413603e4993b81d8ec5a6de197f27f402949a7a37e84575e4dcb81b4cfb8100396a84c55759a7d8a9c66042e6d64fd8fb282a6972ac4f94558578e4febe3053fe278b0ba540f51e6f9c9261ea3d71e6efe149f5bcaee8fd0ba712ff904bffe00a42ea9d255cbcca022d352d66e56bd458ac7968ccf22a7d1934699c094ce1770acb67d1e3187c48799cb3c6de28db70046cbe19a495136c80a91d4bdece31200a2491f6e35bad107259d3ad6e567e60d91a3c60b5d285fbd7bc6a6a1ba72dabb7be7d400a3c9a7bae85d7d0d43e7b0854d2d4873ba5e1d0d6f708f086bdd537ee7c37e3e3fc74dd9075f7bd3040695195d7b47d61efaf94baa8323df15867c6b9eb11dbd0c91dffda3c03b64f092ed1f9ae9c22866583099498ac9e7a4499358a4835edf0b6187af24c8ad751c00efcfc790c2b264d879b6569c66a9448fc2fe3809725df6ab3c91ed787511783fda3b920a109a047e6418e83869c089efa122031ad7b2dc372ebc245d8933656c131a2039d0767ad0e03b3d99bbc15cd1f53fbdef744770236db9ba15373ab3f430a4d9f03dfb1a1215f5516a011d7f7ad4ef76dc0cfbedd00c4f1f53ec279490993b24a72a0dbb80a5709c2042dab902d72a10175230131f9b56f81e481e93625b18265d189e13e0d4f623701d1d53775da96eba95afb65e191575044632b22193f95c15317509b58d04a235bcdb476a62bfbcaf2226f15c1bab2efc26058fc2a25c33cebe3628aac0b657564cf4a0ccb1bc191d01b20b23f3aa392362e2d11d2c90a0f6c48acd7c225f023755462e43c289ba6f07eb9b3d9c95690e3b65a488a2e11f7baef5b8f84e5b40ba1fee2e635b6b03443e171600f32445e0c8ba8feaeb12e6e686c636b73da878c971882e9516b519e4e44a25cbeec2fde5d9d4e8530d45b205141a85993ddc1e8adadee281bca4c9cc9affad34023fa7af099074d4e6be165e4210b6004f4cbf3ad25befc3de5fe873464b59b7011bcd13b6fa6928237d8a23d0899aa9ecfd8bff5bb19ee2c808f12dd45c663d0fe88efd14fd9a20db48b7305276f2568365fddee25de04bb7929d2b9b10112d0dc101274fae4dc40964f430ddab9e079dd8a172987a3b6716519e3504e820aff0722a6d8e938557ff1fe909e26765e421246be98300eabb5a4b12d98b6505903c7546074f35ec33eba43bafc9d0cd231f111c1e0fc5442a5fc9a221a47e06f9ed55131014f3c79c37e33cd548eed8bdc31bcbf054fbfd259a4c43c0da389ed3ff1854dfec05fde1b90b9044db8d79635b19079eb2dba4c1c15273e12bbd268255a56d5a17ca20ac2abd118591ae28b73b09fba5dbc673682c5250792deed7b6cdc7eedd3f1639b5f65c73a8ddbb8ea5deb8e9ba9bde9375868322e5c1da88a8b56bbd76b866af6d18f4f39862f32d7d7fc3f351a9ea78d5eeeb0f53480b13bb3cb31da234fc2a85cb0a8700d2f74efcf3e09363353aa4c2827a0222acfda97f8e22f9ef7f30e290a29d80b5836dc873bf0a66123fb3df9a31bbf914ae4058ff579a769e108862a1b84cfbbba587241baf3962248f673e7a39af49236487ae680aec2d90a330de1a1af6d35adf1050c28ba224fc5bf8821f80c8f5f734aa94bc54e3d4de6342659a0f89fb4e5bcbd890a8a1aebf050ddc9efeb1d21223a57c3b0067d68131e78b90ef92448ea573fed902423a6b17b928387c7b8e357c4521f00b9dbdf754a5f19a5bf75c5cd1405f37ba5fc3b98f4b95e373b0f9c123f3d77444e2635a1ee71a72efcff4eef391a0d287e5e20220ab411182a1bad8f77b2af60f11b6ba422c3b83756434e3785528b8596ab71e9ef8195f9976fa543026cc8f961381fcdca30ea5e43f0366c69789caa312e6692690add61aa0825edac4b767ff6b0b3883c575deb539d760de4127e77b0400138372f73d0d61fe68bb0c743142091192a31c3430d980be27ca021172571bc946d257c411671cbf1df7f93cb6b1ce6865f37f19f8d703f286346e635fe743fcc0ffc05ee103db1bae7be14d028654e44ac054207913c6ef7052ddaec66febe9ebb8f25f671748b4dee078e5bcebfb609b4dbad126b22bb4f657b38a8569f1de4896f8ed3032548907c1ff91fdbc5c45065a23ff48086afd69b01fb2caf48324e73d816030cce3ab90001281d6a8d4b1d04d6e9ceacd0d4abac44cc4420485df48ce9fc08027e3689200c075623b5922e0e0618f4e8d3fb413e301dbdcdc1b8c43ca7994351af6c256b3090f9ef74cc0a5003aea5980699f9ace6903deced0f69c70af15e0327e1843e1f1651fd38a65284169fa40195b6cc7adcf48be06ade0a62c50e4b10c76691d79e6603756a448b1723189180866f8f3d10bf990b1d8ad9f51847283581687afbe31bdf5f9e87c67022b1f0b9fc1e905b91b1da36171e84a8705d04d2e72c7bd5a811ae204e00b78d424a65ce824fb15218162a2fa01d22367f4f393dc5b5945b607227154fef064f622c4b661090ca956a7bbb890619977e35a6f5dc8cbc55fdf1dd39b9ad13215fa8a123d13792f59e58a14f558b3d14d200547bd0547c8c84768272d53bb97b80d7e6277ab40585d493d548fada3cdf498fb77ede981cdf6953ab17ef081988b08058145977de07a803a4600a99a4cba2b639c37d441322b7dc16cafab0b6440c3e59cac1cc605f2c0c82c8eb7e9142941af5662b545bdb62df5c63bc2845666e603f5940827f4fbcc8f980cf43980889687122c05e6b07487fce3bd906a7ebcd968ee49e45ed5493715f87b0b9fc223f1541cab6c5aa7e4dfbad67a32f7524c21812e688a39713b66f81dd60fbb6b7736628a1a15840a55f2bc8f5be47079b8606e372db806edacca01b54c7344d57b8755f4e829b52c420bbce2edaf5d2f23971661a29c1c14317068bf4264c06b211d036fa05e8adc77d43a8ed72c6a42ef8d3adba7161d56897b212aa1607b8c266aba9d512d354cc1d9988509ee8e4f18734b693dd56b2476c1a76c3f7fd604eac78ae2777b5e497f5b1e92c6b0ef2fada4f6ece74cf59c2eb28360a0588cd6c5d3af27c3c1f162aa84fcdb453f83569f900f5eafcd8953df3bc4c6c8f64b1d447ef28f249cee16666e8bcd06076c2b884e97821e56b9d80a65bd729c210264a266a51ed3b02b4c43cad9b787493374ef4dcc2a4f44b59ff69fcc753999d6d737a6ea8e64d78b79d5a590389704c2fe9c7bb0d3a563d3cb94817f14c291621b6a6679ff2217220262ad2b46de42f2390089f7c62512c73decf7ca7862967dae733d2a20baf54fe7ec404f9ee47acf21b74f1fd7dee42e277c29b0eb1c8f2ee42e84f25cc81cc2a249f9e0b7e3ccb9cbba2c92abd05204c757a7afa6d9b1f60fbdaa2eaa6b920e5eff30918f233e7b68e3102443b5f458a4a3046d498b59992dbd242a19a2e6fd25e844f91506529c5ee71a390bff029e6681a67fb6aed617c197a7ef20a83aadd15701223f900b574310387d917e819736443e9667c38734067ec46d654d26869001336ce7dc06ac8a12870f32a2146fd208eee48896a177990565d1df47502524116d9d7ebb25fa0e5f1666549270e2da9f35b51a621956c32dfc365e48716aaad438eb845cd28f3d5150e2023db02f3c41399dc6fd1e1be133a0a65147c9a1136f0478ae32976ea22e889264bc25e276d8866a36b1ef64c0c608137fa215962be818042233a4336db00bb8513b9c1b2299bc7574686fb4739b2988dcdc396121127bcdd7d82fed0a7acd2607f41c9a1e27af1098e7b87c0877f351a6bfb632d30e64ca6be6abd4380e6d374320576469fe320f3f58b89da5ce1ce01f5ac13b69e75fb08b27fbc30e0578325007da51a5bbd8cdb1a9349c7717d2b11fe986bbc92a599cccf2f74abebb9a4fd56151747fd6a366eb968b8635f73ffe8ebf7ddaf1bdddd33425c7bb2a8036e86183db30b616374bff006122e5b5dfeca0778f7f8d009a51f6e5ac9dbd6b1b33ce9819b0842bf75db42e2c477cb11e7868e28325df55078ee27f556de4a76f18ed537d5eaae38360405a1c191427696af9670262bc12a7ca49d40920dc43016b353945a7a8e039112fc68cd9867cf47905e17f654e8d420b21e8044d1b976c4e78a07a04518e00ec347f8569f1f61b77473c82d9e5eef5c30b0db66f0cb0d0089dfda4d9aaac1ec8970467a4aa74660e9c873aa70c1510ebd2da0bb823bd37d77dbffaac966a64616fc151f415c03eeb8f9ffd8966353f2016aebd8f5f6a23fad4d196e81ee5e31099d503458ad27a0b8109892b6f026ce61ff0a10e340ee5e995639a33f7376afe0eeeae680ff439120d44d8a57a3648efb8c06f3713acab9e8dc36ee4dd61a72088f8f28f9d5cf7da6a95a547ea63eaabe4ecaea28ad56596eb56664beb5dd3f93978e339ba4c0b8e615f470eb97261b7814488fb1d3d4880bdf95328386868b024dcbe0a258ef8bbb7297ea8e4552cd967ca27bbcc23ddcaab7dab3b0cc7f398556a76b0113901b12a7e9821315e729c47361cbc54ba5251dcd0164aef1af66f789b4f3ad915995f4e78f4e30b67bc9125a13c5479ec3c20183d86092d0c59e1a0bc455c4a73bdcced90da03d7fe3a1765ff3782df28f23474fb12a2b938e213e70dc961aacdc645f767b160260023c172b26594f8d8262ccf4a69a2c73dd48d8d6678967e8510d2c9308f02cc60b716a15afdefa371b98f4245ce000a5e2d11c880d2a3de80cd83d5fe417fae61910e26506d193aac9aed822901ad583a6872b9176fd99d1fe15822bebef6ba73322c37892781bbdf25f2d018e4827871e073c98be02565bdda10779078efcc425f392a9fd3d4ff34ca2cf4220270f9de22b1d2652fbb9da0ed4108b6817a553d87f93860b0b7c674aec7686230141628819dac22de1a3f7170a758f7e73ea20f6a495f0da6ab7e59283343096b21a1eb2134d652d53cd3b79acb3dfe81bbc712f79415c39a3332ed94466d02c10efca11190d6ae00c81bd394d7ea450f26910ac345f49749992dcb75f73ae4609ee846e1408cd8d07b3a545f9b29909f032508a0e3031353245597f4d008d9e7d87aa747da621abe981b8d1454b6dceba6263fd7121217330d2566e7b385a2593b407391fe2a5d777b34fab3203f4ae59b9f5ab79718674149c73bd0faf704dbbae7a958f480aa01be4922ec24c5409cc45081e8873a63fcb914ad3a7cf9b931a3e665ca44f7587243b2ea272abfb4534abf41589c559dad23fda35193db9c3f7e772d9fce7cd2da5b21c3490ec1641324cccf8046b7e04fadcc6e5888f9d27ec863e96241b059339c58c9e845dad545364ccdcc4d2100950d291dc211e935a1adb75d2a5b2e0447637af3621747b10857bf2e12d59a0d66d400d28d212b61e55ceacd464b50ca99d9e7caf3331f1b22da98df30ecf19ad3d21d025d179a17f7d6e9ae1b3ff00b6ba16f126c466a8261662d690ff32ba3a5ceccdef2961f7854bdac6d5c8b278e88febb4464889d4b63e28f5949d0234e60bb44165c8a5177b18c623ed5820e75f940ac44cccff7b6b5adf9a550fa31b8f82a88e8001ece856eaf7da02445d986f8f4224c82695d529cd52ba95370aed0f22e20be906e0cbb77f8ae9fd6c90f1e635f55e6f2f4b89c8bd58df8f02ccf8e224e5c8a3a68f9e4dd8cb8027b249cd06532cbe82686326dbd2ff6adb47af55b6f56e8f1a17bcab1dc87ac586bcc238109a59f0f35fdd6dda005719c858c54fbfffaef6ad1c649bc3aa13142cc35fafcea7f9a9b727160b5342982729674f3ecf1d3c1ff14e9199d43e56e9c98316f458cf5f1e73ad8799c643df47cea9af09d1484edfb24e8538d78e74e4925b5ba9cc4191ec36762b2d6f05df2c1645b51d44f5ea637a71a38e2002b3cec4ae26f381e5a4e7e4955f9bfe6000e6dbe195e383433c25654af8cc5e43dca09a947a2af2bcc7850e5211c8cc3c8ac8b5f9327d7adca6e1627ef9064b0d42e56940d74530b3a1a98600dc828967629df92306eb1721051a7499ca9eb34672c43a6b2102da651386f549e0045cc4499886d9534c4abcb1e021957ebfcdc5f45fc36b44fef389f215a4ff508f725ab64c2f92019b3e124cd1a758fe27d83bdc32ebd949dc6685c7d670dcce24753c37d2d3598d0f007ec21ccff72528c5a9878e4bc45898cdfbfd7dc0b70975d70c762085c849ae19953aa37916b73fa5c76f47a53c642004e55484ee59597e6095424bcd7bdd15de2ecb031540715bd5dc92ffc29fe090c33cc79f72eefed66e6e6d7bde37c1f5535d19cddeaf2ad6e2a4c85c23e46a7beae8d01a16eb723526daf42b57458c9529a2b9e6aa2a57dc059296631254748e61372d4f40a20cc67adbf6819e6255851c7aeaca50368327751361d90fa86efbf95a1f13d2920867945dcbc553e30443d3f7404107e422df1907aebd49c5c07a60ce2b2c392f3685595d21e74583a166437095e633235b071c34d1632b2b95e795ebc0a0a309fce1b0a3dd9421530571c6bf5bf58059ef34e1be64c81e682b2e1399ef20277bcfb3f18914530542c568b313bf6f2848d51d62ba46b9fd0a8553aa4ba6107c1c8ae3adec763e990829087cfc961640645f9f719e7db0c8fe932272b320959186fd35a353609ec0876f8477b43a081a2ffc15814def27d12c6396632141e0a9c909f8700f8c70a1e03b7c70f57111bdf68c882739713715ba748b8bd44c043b0dcb097fd0de17f02b821e6f6799ea9e8d0d2426c549a7fd4839bdabcdab5530fdb5c159","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
