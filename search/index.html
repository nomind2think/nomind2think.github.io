<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ac6fafd9b4c7fbef5962fbe1661925551968686b7c3e811b8730034503ed4dd88adb60aad1f2b0080501b5cd044874076ed3d04717c3e90b5e00559dee1ae6a6588d2abc15beea5e8d7af1071b46a852f05523539f6f3ae872bbff1c6ac929b04eef04a2538945e11a1cbb6cb2615dce322f8b3d22a2b64792ec37b03cadc8036ebd87df06b81bd5c34bc781cf85080d941a86356b850ebe48ed3d31200aefe427b0afa6b496eee1a56b85b16fe0938cd60f8f68309d6d17f4c318c57ff8998411a448be4e5183734eb5638eaa309a6e411b921be6d689435d525183d350834c4e7068b704e15fda0c10d2fdabe2dcab3e27c2ebb52c9322b61afad33c4b7864cdc5d30cc226410a973d7eeca59700ad37932d08f2ad133461b1c9a80b276a1841e0f1fb3d358fd848e163ccd2582c478c1455f521c23ac5cdc99bf945a46a3a08a0dfc4ab8d922197a4a92966bcfc6ff38157c034202b70d6325d817335c1f8b3158458f6f1ad4fbe215a451ad429282cd863a25b3d9ded697659af78aea4f3479f922283d18faac681c5094f3ba2965b659f54af5f5e71430e85d8b2e2e3ab5732c7a678b150e789bc9dac94a65b27d833a2662d1bca7669bfb039fe44d10df343d12db5756431be6e3855c518c0f5b86fff961a76cb0d670b12d917b56d68c90494bf5e32a0fc8094ff408ca46d3ac7090a650100f928289bd504a11862f3d9c52c6fe9b20cc688cd17c40531bc7c32e9f1e7df8d800956b91f442bc8553267552c769a46a10ebdfc3fceb2b4e81fbb4f7b0c6797aa8fedfc63790a6f7f5b147fe6ee7ecda773db13c289ce5692f5b6797b4785ca77f1b58a774eba9771ecddbc4f320f384dbc6b6b582b481e68e9ac7ae3fbe8f65e63f42fca37af0e4d93a791218364eed63ce30210d6559cb8cbc963ca1851c31e34535ab999d13dd15db3545f776ceabd4a750a7f5a02b4926a2b8b09dcce5a2331ee2ff9e9d428f966af7c6ead4333e6646a7819ba7c7f46fba486452e9563b79050e6ddf3178e82de46161002a7d4070808f015f6e48652bae3d196e1e273c73d3797b1b28801e349ea45732687b2450e8f2b1bed76617426f9d037ea657d7c95dfa1f0fe54d9f39fbfb3e45905dfe7c89b9bc02f5454cc25801fa1a8e0df1031ec70ce6889fc282b5f0d2812fe66faa7165e6a638552588953714639e5e22fd286446f609ef8c2845482141c1e373080bee309504e96e377ae87daa38dec207bbe52391c86edfb500790e9edf9a48fa2c20d306dfd51acaa5afbbf8c9930e0cbbb22d28b96e32ce155d27bd67469630e0c0e0153b68daf64a6cc1ffe3be4e3fc47031dc00e82cbccd661ff5b88d386593ff959136c48da9522b81053bdfc29890f6cd4bc2859933c3d8bf3fa5e7f19b9347577eb06b56dcd4773c0db8925a355f859befb91d65b7ffbbd545e497510b525542499b0cbe01f535dff2ef316804fddbf8d87997db9535174ce2d36bcd445d92dbba30d42e32d9084631895abe3691785de52c6c5406db80e65392087a87898b83e3a61a4be1c35c0218e183dc8e0a4e75b45932a2706cea9d1c22ac69f9403d7b22dadcfd5cc4001936880bbb84a7d478cc32bc6dea6696e8ca1511cdbfb8ef4f50208295b325ca6e4399c029a68016455b6e5239b713ab6e5bcf5b4ec20f8321c7fbcf2039a3c4ff746e9ab5435f2da893baf01e2467fdeb57cfcd157a7a17d71f66bf6bd12b79b0fb1221c61bc2e264f9c5971d66989e8430c5d7ac8fcffa80c2531ef80b79288aca168e479bb41108d3bd6ba48e73d3c09e0e7c5c17750c79c61968c28f9fb85b9c49e2f98f1ae5a40712d471816feeac858a085ef7be19962c26450758b29fc510a42f3d04c335e187bc396393bb41334dbcab7fbb79a2e7b30910699352337720cf5936a14facebe38efff6429658d7abd61a7bbd205f75e9d34b4b6418dc7b3db823b33a72c30b2c5e34504407cb9d8c42812979bfda8b122279fae6be88f5dba758b618aa77ce391b320da50e47490130fcbbd7c5eeda9787e2f0263ab179ffe3a3193dbad0fa15fb66a21597cb9705ae9bed5c92607dfcea9fd42ba521f656a1726c874b4227057c09dcf4637ed60be658111a9e27bac27df6e714fb094ed2732f4eb6af75e758debe6af9bfdc7eecd5a5953337a9e257deeb39e2ba7bf66bd94ce249a5ab5414999cf3de9d6c28debc95f06e0621d811d4c3196d5fe2b4d257dae46644e1c9243162306aa7a345b147f3758280de10743ab30069fad46f4f086243d13f6f3ab827d27eca3f318bcee24e9c8e92a70b97a5cec2ac9aed16eb8d00993961f88866d321999b4e66a6dc6b8ca9b28044891b092d9b3428d99061f19e518b24a09e5394231a96d0d6e54d9db5288eab6bfc1b2b8c1381cd648b4b99eb70afaf436012077e322522e859b0d152e8019946a995b1f5682526a3931cfb9d84b6747ba0eefe050c98acbebd1586137bd90e138da7111c5744651a8a7d1c77511c98b0510f53ff49b43aa1bf23d51337b04f5ada05a035f8876d9188bd9ebd0c1e1b408c38545cac7f2ffa379f9463820bfe5bd2656ac0b535354195a118539f0fb8b8c0a52db9f77099460fb234260c1d53db61c51d06e9ef1e971fced7553d9e71a2316f5290e861ad6d34a12c7ce48c25b038090e3330a5b268df1082105b546eca0319d5d422b30e1bb06bcd3e3d3ca56e99109570c0cb5304ccbda19751d84a428739c77b5fba7bbf80e4c53fadf784b24912c79b077541cc5eea25de97ab28fc2ddd97c87291968065104bc4e574a741ed4908a1de9402ef92ad553e8796c576779de7eb7615adf8f847307d9343155df562329fbd1d66e711ffbc637ff5e4958d32b389da950ab44e63f25d28728b6ceedaf2b73e67c2c97a019d5f2a637ee6fe2466a3f7844bf56c9dc1618f998571e83b0ddc0f551ba5e78762094bb4e75b3cd56534bb314ae8e97a5a726112bedab8fcecf8885db7c964ada1095dfb7e74b69ab95b719413830cd9a523893e7be6d85482b546f26a9e3b4e34651312fbabc852c26421cb50ca5dc264c2c3f2c11c8e34a001e820337efc5028ffa35f480225d030bc73d5e14cf490d580d97bc37c831550c07faf861214479a21bde927f0959d2465a0663ecae7ce82bff0651f2afba1676b2c39d6b083d6e22998f19873aabf42a55d25e689dda0085275faa645f6360dce2dabc5f2b94aee384a3f41c9cf5064524ce29af7c57ca60003f4373929d9cc3d30462eb24e0dd2fbcf4d09de95ef1e9695e152651525ba8f254fd2bb23a3ce98e967d8340869c6713d5a71fc38155a951ea13de2263bc95a6f8dd511075beb9017f1b67085d445ca38dbfafa2503650a5aff6d8435c9ddf4335aa998ad2c1a74ddd8602775ddedd637143953f6721143cf04966e4acba9e77c55e8705446b8134f2258098804bf721d98345a0168b95b7fffa7355a8348a9c66bae0362305ceb5038c91f351703f12110ea0653205b3737cae20d6923a698940d447c3766f6e5645b55253c7ccde5b4c919bd977bbd95bb17fbda0bcf76fdc1ecc58bcc83149264931ca62e4d9f83d6af6d4d5e5768679ef305bb63e71799fb07a16c95ba398305306f30e4a2cb83af3ac3cb67d9b7b2d89a9a755be879470ad0fabc1d2ee8868d0e7ab5175637701b8cf883b7a4d296656dc93f84ee63079611ce3a49f9c1ceb74551515f9d1f1a05e1b30d6dc1f64584b0d4f89bdbf50c2f864c168e0bbc707cdb348f5d87b3b0e9a85455fc7e39b4fb52c9fb6e554baaf84d77760b4af4ea1a8af147ea4c04f7752e74cc24dcc273cd917f54e5db834bfdf1f0779715bee6bbabc4edba7a383ca36e823fb16aed822cbda225f491854ad1fcc960e774903fbbcaafa249a91d52bf2eb2b3f787f047ee195e169a4cbdc83478f3ed2b2a06b5bea281e70e77a91c561d4a5ec861876368ad7df7d314b464f08412cb7ff3786d4123d7d6b52736bc5408b74296121aeccbbac038bf6ff12f1c24271ad19dba1a3e83bfb4c4bf44b7919bb60be173d1d89175c34689ad97090c725e8c3c7e3bf92ed72d02fb2e9c6768a9189c952e83372fee6addbf6adb7846d01b91d5e488b831a2aa598722fc40de0de482038f2df6be8f4c6acb3c1374a854bdba73127bb34c671cf32ad720f61d6f596a3c526feee529025147ebefa91b25bc4bab19b75945ffe456b1b5bb8c0f8d12afafda799959b893bb608525bf0f1e67a87a0568fc56ec45d965d39302b87a1c90a8515e2e8d092ba3c4613f5e7e4074ac15b4945b4030bbe84f240c89e43feffed601cd7c07e0a57f88bdc0736a3ef32e13af5fc03e02e9528b87f933d0d8d2a50c01e4354a62900a5714a2a26aafe43e3c846fc402629809d6fe13e1223781682f429735159d06611be60cf7b1e5bc3aa6a636f9452f9ea2b2d02e80e8fc528b46282e1bba4b2b77994b08ebf949bfa03d71675fd4fbcaaa00d2b2c60a2ce0348331e290e879cef6606473b2e8ffe2596e59d8699be17d3176d12abaf36f8bfb9e86b5b3c3a40a4adf21db2e015c47890763d98b69beb978c354df3af4786d042ef0b72a478390c765a8a6fbc4dfd38289c5c36ee10d7ad55ba4e44d7e8426f47689e50cf2db2b5e00851a1f7fd419518a8923fc337ad9011b4e7f9015c07515c002c29a30d572d3451dc0c4b4c6c64d317d65e5816324b0126d1c04b88f05c1e79aced3469c6adca810f50fb912b79ed4797da8ea439ba4da4e7a6a8e8ed8fe32fc52cce242c872ff4237c6d2e371715c01e2459ee709cc743e14337baa2b528aa00c8ec75ca10b9d34e1e0c30228df4edaf25242f2b5c2db0057911da82c718c05a16accd12d0cb7a6d80aa775bc0b04ce7e4a1e4edeccb018296326a924a7c190b0bfd73d9352da019e9651c8935d33a01b93f5293899799b4dd36e7d4f44721425ce15175b1256e710f771552d0deadef8382aa198725a5693b6836f37f6b6380cff9323382554f939a595b9cf534c57171e509aebbc39b1113995b4eabfc98cdc838f81e3263d04c5e01b719b68854879269c74e931d6f0cca5891e6ba095aa2783fa873e8c51d9fe139b740b7992e5ec03225b4180aa4bf1328bd5d5151514313e8a6a54401fa5b0d56b9caa4e5e7c859bb67f85d53d33689bf8372842e26c08651b75f380ef721919e4b7e8fa215f8325c6ceda80a00937db79beb864c6787321a2ef3f24fb303363f61745f6e0760917473b7ea7b99b33fd47a40fb01978eeeea808a4a6d3baf298b2c4047fda05b36b94bf41fc98e78b36610447af101e67b318105801e95636255d251bf0f8d92d06c72d240e49fb2e9d92de5e8bb08fe2366fd7face2ba418605daf626b1640bbbc8213ac7b7b6e2744d87d1990c76f0f2ce25b20f6e2fd3e12072a263dba5f13b701c99b7ab6b5606f6d6f710d9142c340780669cc7b68daa1c31ea0db46aefb580ea0d679d47323537d9a97acc997cc26db725f6cd610c3778962e4c137e220e47a063d1e0d62f94e2a82b898d21b506625b3094404a6d7dc33dd089eb626af63ad6d4c81dda7df122df231e867e7c0069ebd1e2ce8845a413d7fdf2a33ffa512334d45fece2b0340218577dca0e2764ced42a71b145b77aff64ce321d6077bd4df8e38abd49f4a5c510edac748f37726efa1c08d4d4924ec6ea0bd292ab8f26ab997524440c6551c198ae284f5cd2216b9eb7954fd6c9bf0cf9622d487041c2fced92e3466eaf099b8e29e654b72a1f561ce8f98cbb9d60210b499977317a49379291d15551939e7cd13d43b90a40a535d8d85d8eef4365731599f137b9888e65defdbf0401b2f88b67fe77c3f198b6926bccdc039bc8863335fad72014843fc1e028d6332d8292c8e5109abc326e7196cbb8df2e77eddc4b74c313b3250cc8fa4b978eeb106bf7c4afcdf94280a4e01b1dc07e2b9f6b2c45d44981fc46e0dba6f9a930c48cce290532a6a44d9abde7d7b01893dd2e253bcb2ba0c99df6eda845c5b1196f32a2c99af2d113fd3271b31000405db0dbecd1a8ac91efa8cfed08428754d4013b2de07a56bb84d48e6a835192c7d87013443d5cdd056da490882cfc28b62997e4df0a97647249064639afc6b66acf4c2330f76e7e722a46dd13c019c15468407a43ec7fdec67383007fd14d73ddffb0a144181cae3a35ac972d0587b5f5525fa6b0fddd57871849e4619392f7ca69c01e5bbbe6073f3f89011a6bf84d2e0cbf394e43ed42bab708b70e813774c0e9281fe4e7cd438d73e1118b4373f9e0116c0d64b09f8fbf83a8bb9377f6446691af97b271700f95bee9f28660b12d78110e85d68b4eeb4146c6b5c05d470a837980d350a53d54f772519e6800173161a9aed416a5c4d3d170e249a08cbf7a6ca6d4e7f5d4b379e6eb2192e9ca6a9487c1bdccb9de18dea210d89131d3914fce2885a39c9074a53c46558b277cb5ebc3afef5ddb4b6e469a03fdfe1aa5f1d41d18cd23fd2f72c346f444a0a34a5d82abe899230b710551445f1982a7246ade9b3b1a393062096a656769938dcb30e5891ec5223d369ce9226e6dfe5eb53f7a7fcf20a34c62b831fa73e205049638095b07538bf3e0995913160c1e9121b6e0295f84dd6ce45cbdc992141087304c9eaf318b4377f4bebb0c0bd7859e7326c7355e87126578bbf3fd13c365983973c9baf7b3db2ba843120854880614b9f7258ee94e6245f49a0ea76a4aee31eb3dd281bbb1b63d21837cd6b71d8cf5a85ba1686fea0c8cfb817a7e119acb86f35ac5e96b5ad68d9b0c3ff31a6929c514b3335092650625520c2edd245162ac5f2e56f8622c71e2788482b98abea743bb95716b0e5cdb84f7cb5f3f89a08cd470566f4a6f1a39731bff8d0ea513b2223e7698be10acbc3fa6574da057c54fe15b187f0d09a7aee563c26727070352d9b4e2f5cc1aa168eb95dc38b55c610563b574f9981fe0088e2f45f58c19cd274d32cf226bc1960f14917dcb86b380f196e32bf1bffcfc6b34e5f9d2fe465ec99600e46dda0b95e5e1a7c14cedd378c020df137afc2ffa33114c9b925f3645ef6f8b1e00a35f8768852f9df8bd7a067e63f9600b2903d9c5cdd88a448151e0e13e75db26ff1f2e46c3ac89f0ba4e4169d566ccbbe521518b7f4a2dfbf9db8ca668908432f941d53dd9ec5c500aed5394c09d1bfbef2894faf1f0f72eaa686d9d55e66841c179d0dc3fc09099424486225ee3eec83d83b634cf629656c02dad13fafd07e6c412e89a46e42b54c5af346dfeec3dd8c428d53f0dde49e2fb534db4abe9b86e1cf3b3faa42cbc30e07d5e71c19d6f140b573fc10bf8a8252fb7a8a4f48087a86d5eafe929a555234f8c384de056bf486448511777e9046d8ff29c958817453475519c1717dec92ad190fdd00ee1d6774ce6cb3eafe0560088ce8c627a347a9eec1f032ab95bd2462baf7ec92e3692eef253f014f82196bbd5edbdf0a5f42e2e68a1bab289ef1feaa916c2adb375b18472741ac06b23c9e6c2278d5d531e085d8763a9146e4d2d3ce2204f9b1c1667d5df7307222c69e12b478e8a5500b053ce64641b56763013231d37286d27af56d0fa49ee85b0cd05eca7686051e4e678cd6514eabd8a735dfad156612fc86d687115b68a7f009b6610783dcda0fad840a73f69f893607cd98d4f0808a1a8d282b77a3a6c39c92a985170f4872a49a7044c1de97aeebe584b70ddb6a9b9cc62bc24492472f1a2e46cd79288565b15183d6f790b767a8467d74654f0aa6306cdd03361d177a9ab7d2030e1bdae51f0f7370caacdc9fb26588081821d1aaad4e5b2dd7131b8bfc1497ab307907f6a7f854c9f5be493026b85854d7f8b1a7ba70aa41abca6000af500784b28a426dc50a2032ee6c25291446691ae0c527ba53c9ac82cf77a4646305242714083015f6844aa55445d7557b72bb69589c33c64d25c0536c53f73b456d3bad42524860e4b7c54bf6860119d05538767d61d869f124e6382bf4c0f8ace1b7eec85ab61eb4dde84494e109c7eaa32f48c870fd472c65b243c24c2f264fed7803d85b3e1d7d0451091775f73df4281eef75cc9ec7fe192510c18b73bed1f8f3bcf159ef2ed8a32afc643576fdfa44bd366d4957145b6adc159531f7560d259c1fc4c94e10cf3a0c5a5349ae36fe02bcb8a6ebeafcadc260f214ee9825f22d6f6089e7cf65bf05407e3f218451088a8e1a980d8571ee5a55463ebd3cfcb8c1208187927b359132e71a0bfb3b3f0a8c0be5a2b3ae7cd290c973fa815cd2a328cfa58e5986fab69aa83617a63b39572ffa5eae4cd3f38237de9d01836bbbe37a1493da9ce3d218fd7d7cf8e23dcbd2d92878cc90560ced76189563db5d79eb007921dcd409e32606f926bd9a10f3929bfa277d7ef88a3106f87a2599b503f68d79b624bbd59ddec5abc4cf6f948ea11c255f62ab363c0785e232cb47860192d6a0b8a97c0d2223571deeffc1263a5ab16c042cfb290be819dc69ee88f70bd33bdd69c443e60e7b7235f506babf106ba2a2a440af540325328b57179f26e877b46b942d5b98a352ad2ee656a58b3d546fae2972fc90acdf58e26b06d514cd222e0431b1d0d35fec3a080e3e0d2c0a9a897b0308152bb1f26b32dd3f17afe6479e759d66cc588f166e600642a12468e41c5c2bab45fc30e1f0d5fe3e0b3594ae5628fdb85e4c8257ad73e37205022d6c94194055e2501270198d895a083723147f724c58b01d7c974bb86ead06a73090d66fa82085cd1ad20401f479cb067308f399d4024dca90a25642faa73336339cbb3bd9e54caf70f7741bbd7fabeaa7da95fed5fe74783785f1dff224587bef9d4c7389912d648d677c615eb98ebc5d2aee19ef484d76c54bbde9c6e62ee8e1e5723c63b924619692681baac8ec848eddd4e1622c524aee6d0fc8d12c2dc28e73bc46f22a98d72da176f8910cb553afd8abb9f3fa13cbfba47cb00dd4bc98153850e7b2497933994d89cddd7e44ae122070210a9647400cfa25809493534785a53cc584ba1e62dee5e0b92c27b8970321287a5260f618cfbb07815e0e59ff0e7fd88addc016a1fe433330e7580a87fcdf422ee76d3eceb113643c8481ae47c1eecb0e7686379f15449b18e2507938add9f276dfc6e4b1263c63f612d3a7367715317993440dc6f7a43312255dcaf44b720f2c5aa714b9cbd6c4ca1208e2079abb523cb033cdd7ac4d82d7d02ca0f5fec71239f79e0a3dddf7ae3821af0c22d8ccdce2138cb227bf6610bf567381cacc19894cb3059c3f1fd322e94ecb9fdf24e76843cc9e56679db0b07c7f85f522c6c63c9971ced77745d0f0cacf6032ed75f5c4c1809df9bb060d09dbeb3b6428c136c47267bb091456fe7290400535942ff554573e60963fe9f54913b8ebed434e4e63f9ccbb09de7a9cf04ddb3ed01cb54d7129015fb9120b71f6abe897315378b54067f77fd3b3bf3c0c824791419a1ea4cfd877849f749cec53f9009ded070e30f617610df7900e35ae47ef616e15bb3e37b5c4108b6f019d46000587f40ece67f487ba9952d8817eb15f69caf92e9597c020d418d4b9676972b18c5710ef368815bb97a47fa08c85ad97f65d7484e81cb1081c84b26075812648887af11bbee59448e2fc9a758eeaba23d4333993665d595b10b11f9477283d3212c7c5532ffb17232d1e346e88c3f047561059da6a129e46665acaba93fa4f2079d344812d9d4eac5df66d6882c5c72a9e8a832d273c1eb0e483aece338315eb8316b235dc8d4321c2b0b5447cf711a1ccc2791f15547f4298942d57e59501a540267941ce549985f53b6cd9a1ffee2170a5b4c1052fe47f6e3503401f6ba827c581d2ee05d62e4ef41dbfc24948348cb7776cd5323929f587cc65b491935d1242a472a403869cdc4490466fff4e33b95456bfcb66d150fca53b71b73b1d6adc280cc85b843cb6f1383fc282d6af01db9d566dc8b044caa3284ecc74cf6fda696f93a0a46f0abb0b0a026b21484a80e1d06a5c54ac192794f5cfaa004bfba098329fa31cd35a1abd3f37c3057c6c72cb488a664079c96b77d4986693475c5782702da43b102d015a71ed8b9ffc22aa985014889dc5149ef86ae18a37721c44fad4db98446ab95140e11dbeaccc434667e8774f0fc86bae35661bea01989094d55ef8878e5084cd5efb26b64fc10974a97bd075c09c1004a3405b76d63342c2d68b60d675c8eb0e953a8d57bf53e11218362924e021d912132d2d866b703de45a5d66f657e247accc5824e61a74d6c08550a61a1f2207733b3ad961beb973f282958cc0ca0839fe081840dff4b38fa4cbce80e2704da3f8161680f29a142cf99f3309a3313478b912f36b6dfe86568834a4f5858d8dc2b6abdfd3c9846823e7e67b9c302674c234587d4b59c9c99af12994e8070bea87e2de47459f7298e5c34de2c095fbf352e4c0dc2496072754dcab8fec45efe01540f18be2b4b1c296c30cf1b85c5093af77ef09c3fcfad6b2922ce5cd1a7e79b80b4c9f825596e4395bee059180879fe0dc2cf70212e47e3bbf657ed8f744d33ada366b0f5448849ebeef386dc5bcf76d6c7ea63afb84d7f713e5e632490f3314b0682f97016722d874b89a87b20b5a41ce0730d108d6c595e217236306de600c976e9ab0764e6dc227ea2f61313dbc7f91d026df2a7e2636130189ef70a4299765a2bfd8e9b37af5b049b1987bf6896d6a8d8137d4242b54d7a5360c285e8794212429fb0dd1f9905b8bdeff095b1b420d5b9cfe869cbb039decb22e367f859731105388c1090f3a1cb7cfc028e835a30237f56486e16a314ffeb2a3645beac7ddf3c69e74ab6fe09c7ca649ab6794a51df114908981db8a5ef0334b14976d6bd56b03b8a489ce205e97bb9f407a6db7ef4c154d7c7ac4515c43f2e8a55d2f10f45dd60e98070cdcf1e66080b5d15fa51183ec3aec35a9e048673498905fdee16bd9fc5d6f8fd1dbae15a250a2b816fde39699a50b7a84052e91c30286b92d15f2c0d4926577dacb553a972d826e875b680db2a7d2e2eb3e7eeba085b7bdea7774f33f74a0c618647511d8c23fef1e47792e4e2f1ba35d86af8ffa39eb3374faf9d3005605305901df7a6380ea7649fe6662c44e9bcda602f2f6dcf2208c92131bf932dd7fadc15bee585c69","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
