<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c06b1a606d74251ba9044fc592617168a6fe9736f0924052919e5d48d00e39e15534423958c43ef5056098d88121e41239d8fe00af826ee8c291cbda5d6e4c0a37b59c534b5919fe6bba243f9c5f77d28cae8484c1d05d32cdaa6d8e55c178e46aadb9c25e36848bea1efb241419904e43950ed6ab83d2259c5239b7d518f961d50a24aacb5d429e95136d2da1fdad79de38cc3f0c08231c27af237799bcf0822041e27257ad5f34735e81b5a83e45a8a80d5f8a32696ae9e9b68bfcd2f16a199c062dc688604e3002660065eabc6e387ed8bb913545f77c86de2d0c5eff144a268ab8d93d3bd483c6b876ad0653e73afdeb3eb13a7b3c71123a487254ce908d31e8dc7d0cb858cba1c054d44de61bdf8b2fd2eeef2dd1ca3fdabc038c4610575c7b50fee125352efb253a08a5aa8e0411c7c9e4ddab5e96009a24cebf8136bfcb11f95864684c914ba482aa41c6217eb5a64fda9fa092ff8f2495348db3d282a5b17079d90915360450eeece8c51bfb2db1981e2e60111beeae63ab0b99e3a8277ffc38c4654c6e50fca0372a0094cc4eec3fec51859654f60ad405e3bac3be41b14dafdc51ccb9510be96e51247a6e77730a5ac4b400bae9fe70bacac8ed55f8409ae30436d7dfdf8738f030b035386b25a3c80cee812aab2698e184ea2cada9c57f68f1b4e6ca75205cb360e34353822c01740fe1e0c15be25d5662d054dc40a4cbd41fd01e841b6a7bfec01292af72b534db9a4903510a1bd8883a6b79274cccd5b37e6d716be441debfecfe8334877d1ae37e34deb455ecd8af1c7d5bb249f675466d3c54f3101a22d526fc8a981f4ee22dbff5653d96e8a66c49d02b29ff11806e5b11949f0f9ad6f13dcb075b19cc8e154b9c083b8dc3fc89f1a0b7e2df3d1bb741eb99ba93f809f099bcca672e5d7f1c1daeaa9f5920de2084a8e33a4e7551daea40c6a3caf30aef0a9a480ea5a4721569617ead98ef85a46448552f1e62122e300f9316dfc2b574fd89b47d30b0bc28c7156fd1386e8eb0f8cb0f3d3954270af59ca64e17caeea0432e463b060a3b81398e609b139f94cd40c523e6597f6431c09bf377b2e30aea89513031b5510d88f04de1c3790a2c28accfa071d699a1655aff0ff64d7392708c117952c8bcaf2f5ae3fbf801b07534ceb1564c8355c6d10204ed0e04f941cf50ad0cfa3294e4b6f37487a16e457e3023d0e7421b13eb1ffaa6a5baa000f7b08348531c71fef0a196fe1b1c1e604de0c78d0e5fc55af3b13ace0f9a8f620794d80e95cfded4515cddc8633846245e629d12c200ee6866c438230b9308f1bec5a39d930d28599bc9b01beaf81094e685ce3a348ab98b675201b4fe4ebeae7b41132c6b2479e3a837e6cf0daf315847bb80dae1ab79581b191e300436bce9e85789e807b8aa5f9f890791afe9f2a25ee03e55eb7bf4a1c818ea004b2f4f521a0159fad5cf38b1b8cdc2cc6e2c1ea7d45dc4f2a3b338270577e9dd162320b498b23300739fed3c9176ffc1cdef2e4a1a7b48f4a8d63b313ce2fb2835151d7ae45dee917ba90fd017821ee9d7605c701d702f480fcfa49bfe9494370377899c0e0ad4383a1b0c42e62cf21c803d6caeac676a3a9e13e16e7262e03909a0007e9c221be5a65894243b4056e6d1d6cb8f9c0be662728ce4ff038152274f0dc42ad1167c7b6555887f0695572ff0a0a2a63120c86e90cb53fec826c65c4436fcef50ecaed8fdbc4031424b2ee90f4ad0dd549441610f34781f1cd65a72b515559e6c484d73bd33e3a0ff037aa3ae5e9d8fab2ae985a4c2155297d2573e9e207a77bca2896ce6ff54d360bc2246815083870c47fe156821009eb0d5fae8e800a3454ef057c4fbdff5f2dd53c7599eb19844794af0e12b7a217609539b5e8c8a3cb9b6c069f50c378561ce2fce421e68853b22133f34c7bfd61072d7bcf522eb976ffd2fc4e9ce3210fff310fd5b7faeeb3ed1418a02acdb059d9701fd5f1b52ca926395f4e286ad274584e4d39547a179c64aafb2d2cc45fdd8e49ec974ad49b3b4905bab0f779fa2869ff5204ae7bd043160f5a41a22d279924b8cec5708186f94e5d82d18a8c7167f511cf70a1c60f69d191c9d392dae1cc3a5210420ddceaa34a3fff80c35ee05aecf898a311f4590577b03577bebd2c4b2075cf3f9de8cfd176c08b68ce41b948fb71422a09141752cfcd6af4eae51444f315eb905c367d5cddf3ff013b9ba0080d7eb44d7fa332296ea7cb68f81afddbad4683b1996a30400c6c660d4f966eab32378f0c55c1eb14de9d3259f3615fa343aefc91ca251983dc441ccf6d1b724e10f6f1b854496fae46a1e4254a6dc4327af1b196805c47ff8e2be6781c416d106cd1f630e468fba70610f033c2680d6e2400b87db0bcec58211b28c40b67fd2cc591910d678b45acf404d42f9fed3d19f636097885524b68973926b972cf8e68860c2f897b88dd6334609b7d864df53f3edc866ae766dc203786432769b0d66f7e9933549b92bd223f9b9a1760c9d228218a2001f04b57a0f6cb91d624a14b379f47d0fdbc06b35bcaaf82e7d6acdceed5b688a083ccec41144cb362175b62f9736ed2d135e367251faf921bc64485ff8fd7501f022b45a28365b60b9bf495361c048dd2e4e50f0f2102144bd6dc9469373d27fec6163d80b2b7fb93f18dcf9a581b93a0d39edb19dd46827f83212bca366fa10eda0dec847a2a079cab498a5a39436eae7e469395fc6ffdb186fa419f58a61cc9e1c42d13a774d0a1146961e423165813b7a005344acaea950fe12972e8b60c8bf58e340b04eee14c2c1e6de92196a714b7db8076bbee5ef2b665ef4e4e910e53d8d05f72ce4934e2a3b531ea395b22a2c19a17f3fdbd8f41c2ed3536807f10064c09d6392cb23e41f042114f6ba3e3ea91007a1152c125d64627de31708db52a70987bca215da6b4f3ccd88183a464a96d8c59f31ed4fdd084320dff3e5797cddc2b30724a986015cdde2d938895e03b41039c3ffb44c739c534ae396241aef1e899e50d2e05b995f0acf98ecc061367b73c41f2c757f0df4c339e555b9b007fdfe3b5052d92f7257c3e1952d6ae31fa8921c7258baabaf67df8aa5a273852170380fcb0840db4d475b570239d3037f479f9b958b8a3688409ce64c707dd1aa093d74482c1eb8f5d77d43fe19b2bb88b5549eda928a6c0b59aa349a85caa16d9fec7e82834e5a413bf6b2a9468614c6a2a20ae86d1523184600d2754af51b19b409cc963f9986800b006b10a5f77e43ff1d7225be3e5daed5fde22da956b1f30d6ea47b1f6ac7c1595562c9f40a9f7381a7dc76639216099fbd123042bd0fbe6c31c57772c93e11af0e42873be3a936652b6fc97627bf2575ebb660be1ca44f4c08e0add448618b936a169940bd01cc8ee6d19fb8722af39c3ddb6ee0c4ce6e096bb7f726590295d6c0b012c59147e726acc66c8b0753a62710188971c64bdf56c7973af1fc634211589f5bac795b12c3512ee07ced4a28cefe16a80165a1cff5a645321584b339638604104bfff6de4d97fd0472d965e8a2564bf9540df647db876c6698682d86e33b1e0410c21cd8bc46be1b1a08c293c5ebcf84f4f5a187bad81c6781acf3d2f0476edada3d8f83dde2d8f919e5ee8c737d703f279b7a9a58c7fae91b82c754a6e57549e64bb502ae738f50f60c455f9fa51e349bd35907e922562eb00363bf870471b39d7dc1f99c61e2f0a14c390a6a00253792bbc2c0360f62a6d8e192e2f8d6086acf3707cfb4104a00535798747258fd4a5d6ee502fbd092d1731021c6effb3b5902b6a0727b18ab17895a9089eab6aa6f21e4a6c9a40038e24680ef1670d04978731d460e19eb0109806640100900f92375aac2df1ff88fb2f4dc5e1eda3deef2ce258ec93b08e17ff041c51c9fa3d3071bf1aa28c672c46e5868f3ddfcffff85cf50832b9fbaa19bb429b8a46bee1c27815fd97dc991a5c28ffcba9639c10c581489b47bf6c286983408a3aa1e85853e022612b1bd1fef9ee4c1b97c5a5d9e0ede89a28eda0ca188f5a48150006f3d92736257b929e58e19422c872a9fad461af229a20ecadb52caf02bffc462b3e4cc9232f66ff503ad8dff36137a79f77ae731311e94c0acbf694f99a9928a35af00e16b788a930548c14902f38b5200da4e5e152ec784be234564f048004b2ba2edbfa083c12b67f9e29cdd267a910060cfec3ece8ec50b8caf1122abc819c03188a489ebdafa0518e23b8ea1d8e8f7e9252056087de67dd91eb54ce45758d72ae74db302ecddd9729a5b3f83a3345d47028ab757bf1532afa7ccc882b93f09994b9a83c0911b61433df086040a1b1696b8e4b2cb530f2632f0eae105094db97265b2cad3999440b4137528e0a9815cf1356242362e8416e8aa104f3424dff70e3b6ba4c8deac365fa61ba99562cd685d36585ce190aed3949ae8ce8fa6f723505b18ec62e423df7362a5dceef1e13c77985d2b951db5e88a3f9eb0454635361de1a84decaeda136106be0b98ccfc2f37911adec32776a35db36120f08d6054f2af8122795e221edb765da64ded6eb9c480697204a1ea269f139511eaf6e44d719770d087a79a94252d9bc006089ee3708a36fda88747d67de4d045002f43b35dad89c0b85a7ad4ae655cf4aa351fd0839875b3b9904934a41960871ac4b80e5cc670d0c7f2b3cc2595c884fe54eb1b3ae46056dea730f2109d790884606e3d439293bd237e5ac66ded0a5de30fcac9ae5d3fdbb2b64a4bd764314f38ff8154d2755346973135605fada742d2593a4403fa91ab7e90da21c4591caf6044a698756be200266ced8cd1074c235ab2fbba2ad360021dbe369ac6f6fe5691c82c277aa48ff7e0f1f9d78a83a9519c90008da42587ce00796dfa81665dcf55ec1fcb103da5c1390c91f1bd0857139803fdb5caa5ec14d2265f369e06726c1b8d2abf53cbfe3504b48e90fe64f8503a28acdfcae6018b5e3ec894f88139233f42f9a8b89fd63bc196d1f9fef3d0c6c4b4a92c135d01a8f62c213073fbaef7cee2835e3d2893e7cd40c540b71330c133098138edb4627f9c5cb2f4d3be595dffe45c04253c1d94289b9f692baf1be591fa82660ca19632d87deb2e38756d81f78c2179797df17be1695d49a547f86ce0456a263ef268f7dfe4a1e3bf187595672438f831bb6ec380f8c42aa86766a9dac4c86590e4b0380267d577e6b3cd16307033d4ed9b20c632d8fd83544487295e3746968f74a9dbfd76bd74b20b19e3211f9bec8ad8201ede84ab646a408a61e0b94943a1ff6affa2ccc67634f4fc4bdb0012abc48ba32b3be2edb695a28421c5ccdfaf37604d749a4479170fe433c4ba8e0cf026333bb1ecda74c62bc67598f232bf92c6a146c289e03c168bf6f7e32275a3af43613bb7fb5add69a6c17e0a8aa3bbb254d233e57bcecc1b09665905b326a5d504c89b55a985d2faab4c7056a26d15184dc32c0cabd049c51fed73f7497f7fef72926dc11e4dd8a80a4133fc4a6b4c2fb363c4cd89774625528789635a1740cd2ba5245bde8a96fc9270c280fdebe728424dbee92531c6caf7e63bb6b23b92629fc1bba1a62afad42f4df5bbae44dddeef7fe7385101f38e333a54792cf8e67631f3b1f83d383a73ba899a07f3ced9c4982a8b9f5057633cfd2a4520249586380050d7bf66e332d272178b5145c2c03c4d6b75bc4bf1522d7b087b3a8f9f1bf95577f266e13641b2fa4a02b0d717dc9d0f46a86afed0f28914bfa531550917d6d66d4e262bb8531f6b4d52b28022a9417ada48526dc348acedc65d7a438e19bf1e0e1e9728c07906248214f9bb9a794346b4a1c40acf674a1e87c7dcac53373a2be05f7fd509f02a963fba1bca5a06bd5673734bf491bdb29fd575ce478e86f042c00b43b7351ba566b24013ffb92326c0b389fb384de12a476923175c5407a063c9f9534d5fbde58213ffbb0615d7f234d6e295ed392a808ad300cd993e8b8900ffe985cd43d6eacd4758f7f985c7a9bfc12a96214bc371985dcb656db579cf70d9d78b8993763faee5d0939fa1eb9f5460f0e7b3a010ff6a10f821931569c5019edd1c404711a738bd95c77fdc40f68bedb36c3bee30d97c554bac55c58ee77359a66a494b996fac3b10c99ef83700bc19089212f4798dc1ce4859e84c3b0a0ff40467a84a38765ae4ec2213eb4f9b2b3387eed0bdd4fc67bf7aa2dacd3b335ba3745008a93abf1ab7fa238eeaed07499dd206353e3da5e07bcc36388057c66c24723b322cae094de778c2e302be81c4856b95635c67ba9013010a4411b2388b2d013384a6505e194846ba8eee42da42704d5be5b5bcbe28612c71f6b684314bf07833f9c62829bb1cf1cd856dd9a4b92e927051347aded8900eca0325b946f14bf708d845b662b46db3e79e48e38ef8bf92957fd4c534eb7b57ef3d50032b92d3c335285fbd6417514f66dfd36192837ffb182e0e43ccbff4ac5b90d514e83c508f092bd2f39261214dc1b46ed2f6b7ebe038a6d292e171f5460e2a454fd2f120bb2e75c218de97672ad918a49a2a7124df3cb50475df601f1086ad903b2f3dd947c746993c7e144815d32144d858dd76f6925ba7c5d50d91cab326ed505e8dcd7ad7a2b70dca035d278c11f0719358acfb460ee69082bb92804527d5c0f731b076ad5619207477347af91c940be3e8c4dc54fa8ea9f07b74599ab87af2160d5acf4616def1288b67024c0421be4f8a209be4cc7fb5b9ca2afced7999319e25ba274458d6fa8a99cf5b8153e2264b1f983a34c40651e86f01e8d4dbc9ba201b086c3dbdd95d1ac47dbf4b4b5e60f9df6aa98ac00cf92c2df1b7937ce125d713d1ed9860cfdaccc231390b5eb61ef8d2a8f125c765d9cc234b734762e813a4176035c8ec0f1001f241ffa17d795402b89aecffeee4744b3cf2c64b7ddf6dc3b7a8d5567814ed699e65590766a5e1b1b77e836a94bf36df29434a4ec44f7198ee0fcc8f87a66c074011dd560a9d0c2485ed4831b852aa225aeff527ea407074307060e103efe51461441c38b0b175ae6b28dd3d7d34998887910f17f3194c668ed7ee3c204245a5fbc8d415f5f4acc60cb768fa0432eaff22188c1f329819811b22f7e1a17b819537f70331bc440abcca61c52be44621164fb5788e3000e6c82235e352b02f5babadbaef0f4c2562d12859cfd624137502ce07103e9ce22813893db467480a56309b6a7386ba74783062832d898f679c3f9e6a0ce630cfde168fd8628ae1d29baf3dd5f50c605c3693d2ee3bdc86c2435bce5fbed6293703af0a2516346954cf071314c66d7deb251607ae014153c6ff052f4ffa629d77b3b175a5bc18e9fdfaae958585a8e27d7c750f3b8726388b146518071e66f7019b23fac291f6dc2f5e2212f66a8d35b760f2ba692c48e562bc446e841910a68749979767d19b65e31a438f1d966e007a1059d3e9f9fc448dfe968974ba4b7d6c34fac8ddf4642b1357f21123baa83c13788dc738d7b0b5e363d9669dc6b058e685a3551ab4d3f4fce6cf10533977b9e45ffa6079e72f405f3233074dbc5f858f06738bd98255ae5ad84bd6b44e59e33ac7526775781f6b7b05f298727b458af6c25beb34bc9f6b714cb668a387a00be136e1492503d3f919acdaf7206cd9b99a1a3885a318728ce553c72c40d749917c42c35fc4c890af9967d406d8dfe43691a170a93dca456e0f5f1e058d01f77156d7aefde42878ae93fb503c40e33dbc38eed9585b934251c26b3f07f4f2cab56f99ac54bf13dad6d07adda2aae5bedb6f8fe91eac8924b9aee5cebfa4ad8c281f938341ae8090c33602166d05d8f7d15ef8940ac93faf0e050bf3ad4551a31d5fcab5d2b12dce5006e819acc9491ddac3eaae6f27fdcb473f0d02c122de525ea579d87ec31952bb4566e61559dc6851492de547ac4df6ad934380b05ac88a91bd7699c9f14153d79db4a54bb09de19d12ee2badba70fc4709e8361e27507bf87393074e7dfdc052ee688afa80678d89493f363dbcd9915d99ff911e791e6933e1f9bd1f272e288a16d9b49edee9ad0493408965485698592951e9265dbe5f7cba01ed9ea20ee923ea6e930d5c45cd17d0417058617440d849cf49edac3f5ccb0df2c4aaffe377da9dcbd8dd43ac87158a075954949ca61676a4ecfee5d844722e611af7930db99882d97874d895d4d765e31140e2e692a79b4d105ccd618d96cd8403545fc8b9ee141514ca91833357254b64c60d9249c19287a31b511fe3b2a776904b28720f1e097d05bc729529266545ab3f555910f9bc117e9c20b24fa8f98a6b95fcaa386cb067f479524e1f115fedb7a2cadec0ce28641fabb0cf8dea90523f3244b297d238e6b77bf1bc7ac94b4c7fea435c01382d5cc1d7ed41e53de1bf4456a9dec28645cf6988b4eedbe271b34d8b6051b516d5468cebf4a00676887efd3788a224a88f601c8c7e60f62c5e564746933695b71a34480dcb23dc2411299ebea9688f51a1be6a6a8fddef8a8dd1513ab1f8ad2f0dea8aa098966e64f4c2193f1ee34872e0de0dc5061058796c5d69bb2fa4a494b0c41fccc9f8858bed6e1146d0ca95ae0e85a41748cffde1a2925d8480e1e4dfaf327decedf297c1bc6f65555c0f73af9cf912b84a2ff042ac24a5a6285dad46fec0317c1718ead8c8b89d2054e4b54f2796602d65beb1192b272abfbb88c11fe2d30edf4cb538caf61866f7def265b1946619c43a9ddb364a92de919444713ab1c9b722cb49a7b7657fd41f9270db2c2c90c1f4a3a303fd4faff0cb07c2cde300c8776e9c7bceca809ffc4a4d2b21501f98ddc27ffbb5babd48ed1fa72e015b82e564780b3e8da6c796bedaf26b5eba0220dbb7ec3eb035d7056aa1802b3d49b676034605a65049dd6ffc3041ba3d20b540055d44e6de46c64e27fcac4cf29200c5688e593a5565b10d5e9559be42d2e8145118ba3de2064cf7a27bea649ffc293239323e65bf19463d28c996ef0af5541cbdad27f10ff1e7d6e32114fd83263c07ff18560074504294d80ccc4291ccbe8bb000c65036ac64be9c62ee5c0f2d80cd0c75154c07e8b0bff412afc90958a867dcf0b29d635e3c019c384cf638d3cfb9bd1510c43b97d8383fb19cbf673ae919a9bb10f125eb8c7d111817602054b51923d3d0eb1f08d4509ab435875db462490738f4ef82cbea23a65dfb19ccf61d0b9f16918ffdfb8a3c0f85b6372f57922a71b78e28d2d87877b6713775d88d96e7ee1caa93ec52ed73791d14405298ee9b5390e1a3bcd1dd8a98bf8632f2c0d034102d71b3f67c1abc327ce0e1542dfc51de2ac5644b867361758b15e0acb22b9cddaedec811cefb696e0db5f5d129017bce08ec0062b0f2fece515cdf921c320eec397266fd3433ac64450a3c10f5a5499cf4151aa9cabae2cf849282461f510557dde2d04f63084839b56a91a8093b0be9dab8cc9bc0c681b11b267a67aea08aa2f2dfc0799868a72547ccf202b679bd0e8d4d409c22b4552d767e5ff029cdc4045c5f9743fc46b3d15b1e6f405f3ee5ca3670ed9e6df3cdb12fd1fe090c14a7f2770dbc788e6a370aa645fd087688db903259c0581e89a7ac08c5dd77086c1acfb0150b5022eb6b6f41466a698e6f19f9761a2726857a0a253ccd5462ca179144871ce071bed0654269e9ecf31ca451182288a20e84d81e4c8f5a76ded850f6c1874adaf29ccaa615779f13346597bc4391236dd3afef6694954d9a720d7eded1eb5a2bf630b1af6081038247444586242ef71049988f6fbcd61944173889a45ab0934d57603f0d8f938eaf50c08b95ee8d347aa94cd5124480d96e43d6f243f149f045d2d6b560e2b21e3223ad950ac79ad9303adbb0d1a5c9e57641ecb6c6e7ccc3cfc028bad2f1a2e6a0d1128063c171720a4db1ad6e6b617a698ad7e1028ed542b634d69f85a07d096697e107c642884f37ceed4ea25a40f0b967f99942406f0dbd437e66bd840a64736ca5356141d567f46c4ce03c04ff13b1ccddc82f43238bc72e7a9f2579cd445dc67f50b8b818023c406820368c9dba5e2f2a26f9981a93bf18327678717a3ecdbf53097664151a7ba8589562e3595caa7aff2ef4a3e7bb4f504c8d5059c63acf7e4f7d9d64ab6f197566f5310aa6b69d4c9e4b2ea8f47de45e14387447f7eaf2ff0e6feef092b6630aefb11982f1b25be1a9b6f189d47ed0b432f39c2cc4c28ab31ba89ff44ddd69bdce00a1907cc7f58cf6a13ed39f8d463c4c77f0e0617e06e8436dc616474400ba2b1da73d4f1d8eb60e39db0dae3eb6e6e13b1ec53b90a9f6979e3caaeadb5b303786883dc0feb8f386e36d49f66225a9dbee1a87eeaa7679ec7e76c62b0b6c6fceac6847304f4bf9654ff6b4374136c005f079d7dcbae877806a53a54e55be6131fdb6903de5815d2497bae8a44d2ff174e38a885f50946aa2d252df98b71d8210f3aef711c2a920b71ae9fe787116ed1faa7965574c2a9009b0e5e376088a042faf8977db6f4e8077974a26662d279e757915723e2dbc609fe475d12f73bf2e4ee77fbde876768cee19d655dd6693ce7392823134c5470b39d465ed87d6105c3ac70872a59d176370445813151ef80311279bc65461789491202ffa8617c748cb3f4bfa8be6584c0a5f00032e0a292f1cabb2a8090244273db53899b34bb409c7ed7e6f7dbcbd02f65bcaa5ed85075a4fbfe55190b6ba98cc43319254f64dc09121d0e498c5b0f63c4c21e6e9b2555e99edf3f011e20f6c46d333b62cec486e96d27c80a82311b5c7773e4cc4442b788fd82c2d094921a92c2395d12e953493d2fd733423293e388e6c0f69cbac32b2ee711d85484ce81a654f042a35d7c5ff912fce7849258cb3d41940fa59876dcd32cfe3f78fa6897a140c6dea5b4b47ca5312c518a7f191670f2c0017c7b804fe9fa4ac45c49a36af41d7fdbc8804683b6af3219af0386f7f1e242851daeca76d2b908f24b2161ae4b744dfdd3edba30e039c7cc32e3f93899f1bdf6d8a349f2bf3ec8607b07eb7d2976b94eace43e21f64de294a96b5aa3fd28679faf1c69f169fb08f021c57c44aa144a7b0dc0244c8fd3da403e8a1639ae149e927cbcc73f9b80c937a7dd4aed34d4b9603ffd6000c5ac8198912ef6bc8a63be6be455f04c2f1eff5c69e2f426298438755942738c1f12e8355108db16d3181665145416beef88e0727dfc8e626e80629268ec3ab2df555b095d19f5c6bf8e5522b1a19809f16a18afb406edeaf88801cf3ff2c08fa9096231cafe403783307730aceb73ef09241b4c4e1b0366443ab376e67a8cd21d42ac608855bc1d4612591103be5991bbc263edbdfc7ead9c4918f1ec648b1cbdfdaf16162000996f6965a853cd5ced223d42c72ae4fe4cc648e6d4e3c9f29c1472d19464b048cb4445ed7fb771790353f571a9b122c1da65f21e7d7a68d69f7c2f23ab16eb93df0c782a9b37733d165fb8d1ec29e682da96885358612e81723c6b3f960d7dda1bed9a26671c15b47e7682a4b12b1c0d3130a37a00cc9412c66947f246ee20979edf5e77af914275f2e3fd0b8425ab265c153dc71e473663c9720998271fcfec333bd90d2e8719e9ee5460797ea7b16c98309dca3371fc23f844462c76d71f065d0fd2fd3816abb16e21f1ffcc6ea99e5e919a85dfe03c72a3339aee377e8a6803bc0f2b852eab8b4f423d0b5def1f549e05b74d42dfe55af9c13cb1749d713ce661550f62baf434e99305bf7d3e292e105dee17e440ae2115f5947318811fa4bffa999b548830b90047fd9188c42197c254ffc393b4b9f663a21fe1033e2175816715d03a1ee89ea6a9e343cd0e450ab85dfd7613fa82f87e34429a4471033e0794fab89ff70da88e0cfe756564b056e85b8f441f05ddbe9f8f754152f80ac7610a0d80bb4b7ebb1e3eac445a9dee8583b2a3e716303afa6e15bc14ab8c84ef4463948a73a25dded6f243c7c8294474c9e247d6fde7968debab7a9bbd01dcb1fac16fbb366dbf8269374b25446ae8c9adb5108bc184398f75a182b20b642302004601b4f5d2fa50b7ffc4e09988796618eafa0c498c0efe78feba1ea7c1f4e3ac1be5c7e01675db5691f2e7f3a856b53119747968a38c393aa0a479e6ddb3c3cd75007fee60da7c1f7d4a419e6edbf4fad3a7c70b06f572ac1c597cdd6ed79bfbd464c4e54b21ab7a540471b827eb5159f506a7d7f622da3c74021f558bea1bc76f796e63a697a1c8127152cd65753c4c26b403a811283fb3368dfdd619cc036d940329ddb72db9ab233a2132db0b850e6c3e27082a43577d08ead8b64e1ab257e9eb94920bf9c5ecca435b05a5b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
