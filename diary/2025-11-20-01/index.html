<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cbd5e3817cf5b35ff1df171a1abe01262cafe5ce9dd27a621ea262e4860031d6546b1eaf1089fb349ec178f53e89533004174243bcb6e368e59dbdaadf58d72be8462afedc7decccb856c0349d47d03d4bfd9a80651a320f3de4378f5236c793b58ff17c5c180ed7a5dd697884dafd542ce7e501fedab2d543a25b827eb17782422c3872f3516688b74b070c357873876b5c2db5accb6300afc903a328423eac0bfedf3361f7ac67325e3a31ff34c5c189277b5a59ab0def06afffdee4365d944a93565d479c872af563cb0f9b3cc32d05602ee52e014c02a6f475f912e62b7fb9dd1ddad9bbb4f52efa7df23bac95a6d1229413439b38e3c4e00c0b6020df70f2e7e8ea0061dba9953fd26401c369f5a50f88e7d4c07dbdba2dc1177b522b986a4de9a50fbee1b53894266df9fc2a15796165bb34e4f00afb4f0b392509f2994b3adf680a00efb5eb1a29920b05a753d8ebbdd56687997ce82e2e297dc5591e69a7c7589957ff8d0518b9e317f19f67a9090cf771a5628ba03ca7c2dd58ce8cc4636cb86dc2ccc0b3504316a7ca1a079f026b13a4c0250d55acc06307155b93121e7869d648175edb5abdf50584c2d503b7b532ba9495a56e24933d88b4b7b92c5aaf54570553986e08bd096712cad3798f965ebdec4727cfe6b7a2b1af9af57c32388db816646038b70f0457001204c6c18b4bd8ed16e936056643a7d3ece0ad43c4dc176f4181a558418c93f6676f6e0ca1fbb87a54fa69cf84577384564e28c24496d6fe5a7832a3b9564aac8a42ca5fbd5548ba9f240d2879475301bdecbce75097dbc390ce208869249b8919b7680c8b0befa6efcce6d98a2dc71e173ecea53328eb7d418080ad0ac44bc5520e4325377456a1ba8b400eadbfe3de5fe7673a0177a50090b52f7323f1d3d0374c76886ca0bb58773af9ed45d3931d8ab599b7fc286122c4b0b0bfaa25e90c8bf4aa32d3797ea0ccf76cc0770a848e28b9597206c8e355430c54992ced45cda0c9e927a33040b710b3f5369c5f9551d728a78710fa2f56225978aa9cca0b6a7e0e030145e714aaf0afcf2db45f44794219194dc24a2db9106dc6bdbcccabc06927f1dcb6e71bfd9585f71533f9ce99a11f72eaf7a02b853fa7fa5978038fa3c962e9762325d467af2f42c41ba8aa19f2f51f9d19055f69b252b1c1358828d1b30f17def52e8d439b5225386ebabb0b51527b952f72c46920fd0e43d4cffbab09411a12de4262e90a8d07a3ad74cefdbe2c219c6684ccb45c4bfc9d2b9fc50428f76edc252744ddd238d97353db781cb5e176922e3b8ab84c92b884656b4ee04b694142003412e24e3c243598a2409dc9935f10ab2e255cce408ac70ecaf6b8b7331fa67d24700db2353e7c04250a110f0ea3fddb810e9ac0c9709e8710c8c756676bdc71259160e136679d5c1aaa9de884731873d39c339c710ee3bbe2c7bc427993c309dd39370a31364c4b3f0791cb8ecfbdc50b9be5f1df575e8934218502d48cb569a349be920c22cef32af54de9890c9f38f3d645dfbc4dcb4024aabf7e84f7e473c7ad51005be39899fbcd5ac4bb5e6a54764f422926c739d5d562734ecf6f91a8ca2a5dbb4ae41587673b6d1e4858dd1e298fb0572e0b6bc6e640054d5f7ffcd2ba96f9ea11ab8c9309c02c60c0ad6d3954dea00c6f6374175fc8b8b0d70a005bf9d7ee2057bb7786b7eb27caa3df3d063f5663b09efaf13af529528aeda901826e563811edfa612b2e7a4746be958462bc2ff5afb8d7feb6b7409375b410dd9a8ea85be4b38bf7fa0c549e34b7de92f25da47b4ab7ef1c061e2ab5cee15e9506b1ed140062f90b8de69cc83298ee43ad3e46e62a511f2f2a1ea61da2458e4b2e34c8da8256aaf28c8ecff23dd07e7fbee093f0c434028c2f9205d07c36764d1729da7a3137af3ae7b9a572e3350f6e6796fcff9118aa52b6b74cd67f3de838791f4bdcbf871d8114a6a7cea6e59664e42786cfb92fc07751f9e945b1b2fc8bb41fab3d704166da882ae09e0b315c8b56f77a2d04447c3e660390ab7ab72a70377dcc668357ef65f19843cc3f59da3a4880b0c0aa033cabed2e4979cba9090a7a8514fedd19bdb9d755d050d12ca87ee41211eb3d633f916c27c23bf682e550a905ae93e39ce42ef287c3385c426c6245ef416abb72b502d0f3120968e9b9ddab3af9f7d4392a9c67812d899dad155fffcdcc7a3ddfed5c6f20f5b24891d661fccb55e4dcc54196f12210b5448c5df392c296b553996c9ab1ae7a393ea1579cbec7357fb3c82a43f6f75e2a8d63b79dbb5278b943de13b27a4783534f385c2f4ec64745efeeeeaf8d2220a6a85682ca59c2c920947f390c070406d54dd818b7c515a77373072dc955848a661631c343ecb72bb1213ed431c1a63c3ec44f5d45ef7e95e6d4304190435888d419a9468b3e61079504eda50b6d5f134b8ff4a651135625f3d90fe6d4b2ccd5d09c49d7e05a146e6cec777df34b720a1044f64e61c4e8d2556cfc4a338cf321c43348d5fb0308a307e6ec648bd56e2839fb3c15681fa03e836eebb1dbac702ea62caf3d796c504d7ff1c94846ebb86a363523d79e90fb23fefec6163c786018753df2d961862fc53564c4cdfb416619dd06e1f371931ff6b44a24e20246598afb2dc1eacbb1e6a4359f5c16b94085cff8cb76ab27fb56943a14978324409108893e1633539b8bfce2642658426c3cbac2471bc53ad46384b4fc8e11672af01b381efa7da83c617d10f895aa5e60f1f31aa7effa41d7dc6e77038facc1262f7fd59ca83b6f3049a10b8e1418cd010e9336d10e95a947b00996c759fc05fd8828b0ac0829e1441b91748a5b0e9d479bf0b11e62e281a067192f2cfd20e9b5ff308cc08b210ec680357bae3e2bcdc2a9dbf0a5ffcd076f3d3273f6bb2f4689f150e95a7417e794b43e291572fb5584440d35548a1080acb1d05f81f10c28cfd616d5ea813eb8d8c95aa2340d66c86eafa33eee2375ed6af70c5fa55035b00393e466e56bf43dbe05face580f8b1f80ba6ddf3affb59824108c6fcba96574d3cf2864f972810caecc7cbb8693d43e867d3e21c183a7f35d824c439ed2f275ab57ba043b4c02ea0a3b5945f6eeb397d6dd87a27736e35449c9a8d14f0446b370238916e7372e763701a1b201c54a99e480e32cbe42098f00f9bdabd5bf913b278b015c9757af8096728427a726bb976e0f9287fb95c3cd07c87430c2bdda76070da177b612fdc4e33d41c52859015b88d66edc17741f7e8bf7ea6382f309e8bc7658fab1947bca7f178e51665d68d664a1ecb7d345b254d0d222cb4333efa34a74d2a0c4f30dba0c92e7b3f49af68bfb08ee2b06ac29e660e54cd53da1e64a1f45de985eceb2d6b5d89db4105d65ce98255f3ae2590ee88e130ade418edb0a307e6edeb15e91c549584110152a3893b083fa75a0b7513d157613672984ecc7fee9d6167d74db4a01d576df5a373e01f799f1f646657f420bf2cc5cec05a6df9f6f1dcda6b897f3b0ca883d8dfae70a4aa4d2afc65d29e07d75c25909fd0f8611875b7f289cd8eca3636dceb2dcde05591a75f104291728071b952a2e16c82846fcb12023033b7daf539fcc32a7f8fd2038501d226400470cc4f782447f4affa72e3fe89140d32dbd0def3e05c39d0f5f42729de8582db9e6535e2bb6ac6818bba123c0491f5725f7bd59280136e25f7f437cf551dc018c739ff54cbec2e02070e754a2802d6b921170753f02aa4dea44f7e6d252b828af0e9d486236752f1356c5885a2ed1c89e2a7fa4e0f589891cdd903c4e5ae8a31a15c4eeb133f0d708e1d7650232e759e1fc2c65cb086d9c75d43f673bf1ed09322f65b7a3933868fe8f9695ddb9a8e1665b1398c936eed972f32dc1c31879ec3a5f4ce095a681557d739a0c17555fb58a26a6dc9c96554d6b66da806f6184315c3644e413e96f8ec65253322eadbb565b955cf3da4babae802f6cec7e8a2aa9bfaad3258d3894dd0d0666f23ebae85bc73610c6b8cba8b98bcf25ca7fd095251a876874c375860b5e82d9dc4ff508366d6fe271ce5dad20033216727b418abb1c210d2969ad83ad6e42aad12ac6cc47c17f62523df9f236a3b7ced0db3f400fa110e3eb520d57c75b7dc95facbf5ede0425940e1bb2c7895cb3f4816449acb7df9a52e923e59cbba710dbaaaa539e967a292604ac86865b69de2a153ea2141854d7bb1bc5cde24c1822f7196def1e607811bcaecd950c661c25007c2bb7c8d5803f231b6be450f1d9d6103f67743b46c343379fba6d55663453f09198947eb4c04776418a685a404495c72ff08c72d234695d60143328b5511b685102d54331e6728e63feca07654a9cab4a678da82395d3a756b78a6e9517e4346e4688e590e1f32db152ee3943f0b618c81579f05aee716ebbc9288589c6e91f971c5d98f90f004f981e4f64a7206045dcb168c4e391fd86f36c69d45e8081b4e282f3ef491b1fbc28eb665b5e9cfbee825adb630ccca42c8698a40e3ead990e294d76e7440e02744ee98da5446872fd3d8648811be6dbe8c5a6b8e156dc7a21ed31726300f4169da7603e94a001cbad7305aaa9154c8e444d5489290cffaa014e0d25800e75f3efb7fe6b35eb461c12166e67f0742a10eda3b0ab3488c545ce221ec739cca4c2579ddb733d8b8c6f1c9b99f76d4eb64da94fcd7269e3907f331f69a65846672c3accea90b028a04988ba91b75db7322b68d8f8859765d9df8b014b98e50031c719ba8e7b9065b248dded7f7e559761f382af655bb31d170fdc4ea2ecf4a12724b6fe00ef86d6b3b05620bf153bab71fc9634fde19cc5f98e53b29de451cae5371a88aa30054e03568f00a2c9c756c3e47ed3f8e6e2ca7210bd4e0d3ba3e877e1351816112162b3d0101afe1fab01b9edaf997f705a0382803b3c60595e9dcb47a70a8f9cc5e14476b05e8e54dca5a3815c65e7d751d019b229b6b964581cbf79c546e1ddf38767ae03bfa7cb04696a4f4f0112d25cbcbf803feeb4c52c2918fa9a29bf077959c3edbe87ef204ef9bac5ce2e05bef6bcecb42b57f1b365aaa2ca34ee7450508882d18700f84f8851cf3f8c89e7cd8893ea0e92f90771917c1f5bd8617787ac02d82e9426eb0bac26f57d774fce7dcf088c65083883eb1b78c720915514b45793fe1862d38d5415544e4b36ff32f1ea45f67e2b56d3044777eafe166037a00ead527a35d1894e7ce649ca11094beda1befbdb241e136828d9d9f690f2e7aee9de78c82f8f654f3292f367d462f5aabc02f6fc284f51d19852720ab9fd384b4437245f9ee7e3bd9ba980f343c4a3fe0b4e0ac40f83740c452ffe143d04a960bf075848bfb6e89625ea981584208afd4efabb6986e8ee593163fdfad686a1799175db6569f9bc32501c5854731b4be1b94d018df2e3216f64b04ea9050402a6762140fdbbd1e0af444c8302af9f746f5f54363538aad9b9e09cccb214148fd7d22864b4f2c99ee1fd5765fd5c47e69d6be702afa1d56402e96365c9139ed8cccf8e0cf43ba54525910dbb4c304c398a6ecb1d1d1fc15c323a5413588b94a418835e472da20c252cd32f56e0e1ed77ecc745ed4daaf4246a3e829151183e126290657f90f06d6ce48f8f7b0934bbc3bcf701dba3eaf28d8faf9e148965b2e37a4a62952a65d201ea6120f9f412f0e1679c47801d4e530ad744f9f03a9a392ec9c5e671f6ca749307f7303707a76e2d4c2b26d5019b6f67368a16e2324c82d09da5459267101389d568538d5c50548fcea6675dd9d0850843640605e55a5ce8bfae6c0c9a926a8e81e20753414f811244eb2c4e75e6c9fcdce00d24f89d03dd53136983b778735a6e9bc981c0ec5539a30bed59b459729721d23041e7cd7257f8b9b2e5a4da58f158b3bc10818d019892fd78a87f33af1c424ae6584512b8487f2a86a1e146cc0337db8ee96581db8e9406520b68226c0406c8676edbf8fba97dba284811bea63c13d35496e4250d323d0c3c75a0754c42ffbdc293cf3d4f44ff3cc18a8b62c288dd2db0d68773bfb761ca5154adcf06a43a977edbd63c3cc1895cd8b61be1001fc7f3b052dd2d8bf7c0b77f9394bf4bd333f0c86027eb7d920ff3a2cfb822c3a28da23ddf58708b4a50a70ed91909e411a7c3229a8ef23a7cd8fbc94047ecb6122782906e16d56a38af5c488f1cc161d476d30173d2e9a3d5c7ef7dcd34ba374c382d382059cd5728b6e438db4600d05d86198f3ed5a33a12d957c2ea3777ec8a25ee98c12a09374cae917240a2ce0190b790459a50762e43e4cb1720d8dd4562ef8b2a3d706fb69d968122127e76b2eed38737158e169e9581de7bb3603c5cccdf32a9139a85dfd17a7799820829fbb0ca6e465832c4a45b49dcee25efce6b14382a64fec69efdb36985dfc0d9db6eddb3ae0dc86c6f445651b962a1cfcf17560ebb3d1f8a2cb188b342a5db7ef0bb7578e57e8e58e095dad6b5756a39f0a99306e0afa11da7deaecf8348fdc178bf4a0aabb2c8140ef7f8758002cc77234c7bc18aa52f984039735c16310b367196277d7b3a0acb7b9e220a1a05017486a648f5d5e9ae2ebda75979ce5ef328e6ff6b8ad8b83b04219f1ad0888510c7fc2c0ec934e9ff4e641d2f50ba730987820ee83fc6323501fa08a2f449afe5cbf06d41aa971ba852cf2f1125c58b6a3db4081acec62c789fd931ee3c889a5c78d90f4bd913befb1c42242fa2f38e7d5ab287dd862c26babe36f20ccf7e2a56cfce5fa1bdf12633b58cb1d97e1c695758588c31c1398e2935c6b165e7e3c5e628f460b7bb92e325642336901c3c597297a00ca0c5a82bbc50ec6d2d061d7c476f99c3af62adf3e7abe6dd664b3ecbb5e212522217e752d603c6962286f9dd39e20553d5fe95fd92bd68896ef453b96c71ee68e73631c7d9364f2c18128e6bf96504827adb300a6658622ccd849a72ed44665e4a95a3f64841cc645d5e2bbe0146e2ee38f6f14370aa5ef4099cb3e2147ebc9c9faf2112370b02ba4e2e57e53cf60eed779ac4e49e03ecee9c2e75bd8f4c8d5213f042d3b7fc6febfb32881614e364b034277ea0f4fef92edf87800f87bbe41a0c6c409c493de538b7809c5d2dc966ec0fcc8fad1b08ac7c057ee469d79ddb0b8f5e947906c5dc5695d25dcb04ce167dbb18c7fbce80614b262591642ec2a78637dfc03202c2fbb527d8c3c3dd53b56c7d1bb4f7b55b489615a854bb3707722894be95f883185a1a1139cf7cc359e409d56126706aaf7ef3d0c02f545c908bf8b3fd62bfda1329aaa806cf814fe50c74531c6de935fe8ed5aab3662275be65265dccffe4ecdb3402295624b90fb42ccbdf1ab61e430c7dc603febbb62171cd10542906cb2874ce4f26f6d7cb6f9969bfa23fd538d922405b1494ac291eb66d1751b623cb2c7b31298b33b99bf50a02333d77ffcc21aca47ae56ee74a8fd33f1a45289464d2827e23d0be36d5ce7cf45faca3388686cdf71837f3c5338b4ac9f239eae7e19e24bfbc2e3ed6bab86cd40b0850b37cf650d2de293274cd56e29e54a962b77d27e7d4e43ef1c0ac0edd6ee8740da36551a2f5ff6619693cf049334822ccd2cd0f065844e60366a18bb41a2fa192b4dcce1b60f69b8deaad3833a1a729a2f4fd002bb208a9a65c09e1aaaaf829bc6cb43f5c7b50ac9fdf33a648213db6c88fde7c24b89ef811fb97530ce2c6860df4dbb312dc027a6e88f515f81fd6fbd48643e303672ddf86ff7eb69974db12eb991dd59c6c392cd119e95d39db1f60065cd8c4d3e5ad4fc255b024cec3c7d252e6359a199d9a2d951c66db2c567995803fb0fb09dde8ce4daff9a8901fbb39f65b4293f0c06ee7e310d067107bf394ebb9660cbcbdfae922c7408a8ea5297b2e98d5f9677b4b532ff2f2cad7b5863707feb3a5c4dffeadbaa98d0840def028532772b89d729306a91c63884b83fb4b13f71bf9d9aaa384db4db836812cb1c27e8afbbe3d4ca48976e23ff9a53fceed3dc07857a59e2c833c87ed4d5742311f2bcf2931af3ccf51625ba952cc4aabaa83693c4cf4a7a51ec49dd01c3848a876a2554dfbe487e86e47c0dc8f7b0534ba2c4fef5c89e3d807d63c35f553c599a7c39ac8c3c5c859e6e4ebb4021d01f6b30b1686bba13e7df2925e5e8d74a09b9826747e3369eab5e089bc2afd453d3bbbec16f629a742be7ed1751d4e32a74524f7eeab33e6f358504d51887bbbece84177a187402cb9c76e9325a0d5e73773b20d22a1aea08cefb5a33ef9d5d4b27359fd5e9990723d176a0b6b176433f475d8191c946a67bec6562a5b963ba81ebf551b8a5749277bef48c561f74add1875b77438ecf97e4f03c4c3b3417c3a69297ee9f6a28670c35701b3a92a9ff7e8aae32bfd167762a265ccdc7b1b4f4dff95c571faa670df6a0800e9bc6ec1028aeb204e311bd8e46e7e77d5da0783e633fb9c21d9f2cfa11696eefacb1e1c5ca04449a6ba5d78a03c9ab6f762f2460cf6ef713d915c93b0251024f84f425f05c7b7c2d774bd8ced53f47079b5e1c9e14fca2bbc74668761dc6ae2c2443cc6c44e81cb1f20f5b3f3cc43aef3e74fbdbaaca8e0b4f2934d61dbaf467c4aa7dd20558f30f71e49707c75cc6e86e58156b42353a96123039082db11886a3efee7a9df8e0c94d5c6c1c98c498b3b8ff720f601d8a59d834502e4b9dbf47c71d6337178d10bfc24e7b75a7bd9513855d12d00d59a39158d0ce1f9e8ec5921c3601858e434dce1711f322978516f5bcc060a185e8d309a9af255677ac659b05259cc6706d60010f7a54784a1fef14a6743c7ac92b4712c3da7144c69133259459ae1fccbd27309195cc3e779688e11c9e9336e7d5f7b3cf5c808277d6c3355644c797ed77e10afa91d35ccabeff72d12e600d1b75a0dd254eb1a123fe77ef218ef597c55c487b926972df96e225ad9a4900e8553f3cab3e8f4f20aaadec07171f36300d1f3324eed5faf8ed1172cd764e60fc95983bf90ced37b6492e550567c4b856aed10cf6533a8d164f64343b2a75d2f55af8d1077651ca57fc95b2688b769ebf8515fbb7eb12973ae1ea2456fc30983d7f6aeece65a65d30905b1927567a0d2c35be92ca4764a4b005ea5d3d021d641861efc7556c43f106eaaa78b9df7e3077a6ef29a2966e15f9cbc0c15ce0d6966f646d8afaa4bd0cb35cb9e14aa581d3963974727fedd257f950a5519a25d1a5dee25bd61e4b5e13951584821fa470bd48d32c13e8cdc66d9c0a9dfc32d4d44039028d78b2d2256d7fe98c4987634453b4b5e3a43b5a390edcc58e1d3614dab73d368315fa7e9d856f6ff661c8336f58115e2c5ed1281589159f97575156dea0b49d7587c6118860f8595ba1a5afd854f668211529c7777c3ed49dc5b7c9b61860c28e89ad0096fe83bebe01d2b6e711885ab243a73a5cd1a7fcb87aa7c3550dc55abf469520861b62c0fbb8f41149e619e9c966d4a981b01701688ccf8f8a361f6bc98af246020a63726b80ed13e69835b552df1329ec4bcf83f238628095205166edd076022eadb0cb73b1ba82098a4139023c803b4036d7f3bb62079aefaf528a52f9c8c1741a4592bafe73834d936418e3bcbbb393d6754f0b99a3a6da51da63501ec48e0a979fc85c8b295e9b2201d8599e38cb4e4b0075c6d7d0acdc6c23f1263d760728be79aa63290a7b3f6a0a820c9ddd5a3c0c576b2efd18a5c1123a41c6e2732671a736b50a2b7beaf98245055cf0ba527e53a66f299aef33393075df74c0bb5ac5358e39526265c193e4ff89084288c116bd0feed6da4b55e386917e8bc494f1562bc6581756db0e22c28ba57b447057b4e0ba7e53afe6d7c3896a684ffdc56ac1c75c6f82c15a33b12567c18a53588f110c34deb858b248ed6940dc088e12d3daf69a3a25fd0d80c8a4c593e9a74f3d587977303d3116ea6e1c484e620d070abfef350f0fd93261dee63e5325173b4fc59d55081123f881f229feadeb46a659f28fefddf3ae11031c4320de94c09cc1418ead0a9a939fb5a7585f7abd6f3baf53d5e9fcad81cfac2b22647cb2f7c82bbeb25228054c367ef5d004bbad9116fe3b8b0431228305109bb96be35e5148cd6c3d379ebf78303011dfa08a3fad17c0a8b7be159269554b2a6ed96589b49c3ae9b41fc2d0417908755955e6f03c000114b16b51335f1ff9971f90389c6875998b4450a876147301fcd1255b09541566cf315b16da1edf2b058695d7b7548807b5c953c58ad74b1d24ede8ec732220b6dec5e864c558399177428a8c664f044a25bf9d245095133f21c56de1de3c5ca901e74e22d8192f3c1a75782fcf85a9f6a8d269df08d1fd3779cd1872750901a2a1f43494a0c0eca26bcc9bd9cc0267e8edba8eb1f082eb1c017a3ee29bb0e69b78dd80de9e308cd020a67f0869d823505c892a7da032b15ead2f602685a171ea8fa0335c11cd4fbc327ecec39ed137eb4d4728b948ad8551b66b48150e2185a2f04f44a9fb852a41885f9b81019c835383b4ba8de4f2ab7075d109bad702e95895cd2994fbbabed0bdf86cc023e9801b9bc1bde1b6b8e5b5a17fe58c0428a589039ea050e645e4df187ac01033f49400884a786f357bdec1b74548aa03b9f37624d596e8fbd28009501dc53ffda364299d41c20c9707faa206e203ec5b77b600d3019420b102f41c1c8c430ffcfc7a162eddfb91f1bda6e9d691dc8697fcc5670e476fa0b9a6dc170cd8c21fb3d71af00955052304018ec94c07de4f2271aa0c04c6c6eaf6cd8860f2a25e648cb48abf1c61c15a79d54cdf794b7e3e34865ceffe7e0cc3a9cc54247fe555f49071e5b302bad840133f328d7ff125ce71ca58abde95389520e214ebd4847ae5406893fd20b6f7d743d643bc219d4af16869fa2475342a9763b9ff1e5ddd58c5a691ef1d1c7e8cf952f8a398d2113509fb3f9940034df775745ba6ba1228065dfceadc0b6b78a13f6a8b123861f61374504f971b01546a515a97fc917c6d81150d30f7e6f60b0782ceb1ee8482a15ec301274b66de9232af83ce072a4fd0e6dae3e00a510b98c355e62de485d5e0c49e499156e2ccf48a88c3aa26d15dea5bca274b38823ceac44bd4809b2e4e468fd364ef0565db3d35c7e367d430858af4327ffdff63964ec308e3a87e888a5bec747943c1e5f2fb026cf0a4be01109ccce0d85ed34ead82f110b3496c92a533338d9f5181a70ee47fff929b5499a521cac56398d05a49d79ca3552a5efc0bb977927409e0abec97dec68d374b8b715b89c2f6f2d2379276e88a03dc1c0e55d059e7ccccf5c0e5e49542911861c64e60504ff3747ef845053239b1204c581ba21a5ef691e2285de68cc72d3ed182648afad21aceab2fa2efcc9d32f25f37cd339cf4228f8592cff4193666de3aff9d93af859fe91327126051f153235afba4f7f8cd99d70411948e89b6bfa60c6d3a192c4a2bb4ade590bed65d1ef28c2d58395661346777633ed4a8c66991b04eb3179df8e043f3390360629e85e7f9a3492920be0b105b666e98885778d924acb0c02710c74a52db91e146e1c6e28200b46b85a90c4907ca914f442398a46ed3cad608495f9fc9eedb9e711d1367c31d18878d624d892ed70694c0f23e6c5ab728ca295486e6015a3ee6c922988b8c5802005c0a2f24aa50c0437436e189d91a6baf68e0698db0901e7348c60634c8db899fbe31ddd942a8c4e6486ceebbecb92c4fefb23030733f06913509a76738165ca710cba636acae5d088832d2b9961a73de17a0c45848833c168662bf391302575b6e0d5dcb7ae63b9bc515875769927fd9215c549e7b12fe92df98fd82776e145540895e205318b49640e45033fa4523971d6c4e42c105b851b337986d1f06458ec4b2bfbefda5a888e96b901b7db08d5b447398cd6e4d8bebf3716e64aed3d7f0bc87bd412c7221d5abe4b01aea887140491cc52a8d2b024c2a3b9e4613c78647694ffeac9fc0602bf1ca134a308521ad2c53aee7c8b467b4f68ac2c97cd1c82efdabe4381344d17b5f62ead9cb8372917914d11b17b65b53b90229d3d43496de95117b101350656bdd5b35ac0588f7285acbd00f594575df42cc403379178076f1f40a73390e33394a224422d2fd3c20af269f9e6f04bab448bdd27836884a6cda8cbbd76208b7ac2e4b6bf012b573c91ae9115f8f1e8dee6d50177bbc1454fab3552fabe9ec850332b6f9d5bac8814c57ae0d36af601a52a887b3e76b36b67422d345d45c749614267683d08c4b015241d54dc70f4c66981cd76d08adaf2846f714ad8bc3aac19c367f998c16129706b0e31935621dcbd6a503711a0a47d83f3f605cf49b9aabe1cdd8835ff2bdb44b8593fad9be0612436b9d4f7ceec6634a47f74c6451bb82367ced2a572de7746cc58a8df2583ff8dbd88cc4e80b52b35ac51e96c5cb051618b0d2962eda595ee60d45342f6416fc658f47a7ec076fb62cbb0f659653d6e19e253144e5e71cea0d7b14e021da3c76f101b07bbf9c1a0eca72d62d6c125632c370f02018d7228c460c89d43f5d81b5da7ba7ecf137c5d81995b900830977626deeeae350b4942a70e75974797ac33782e95608b88b6f8922438d4132cd1b99c24dc3a3450b94d06740bbe3ffe1f1153af6eb77e7e601932e3f8d6688db3161721e1cad765d4cbbc9df7ccab8b23ef02982cd2952fdf89255e8933d18bfa37eb9a55fa8a7faabeb2433c3883481f6cd46042441518cc3fb2628323f911b6eac29e6bbe34be111b696df4033e3077b8fd654b37d7aba5635bfa6cb4d366a8e54a3f38d4dc9e67a284f4d749da8ec3439bb2b0d60c8cef6a9e620f268087b15d8893ae3a4f52a72ea8fdfc834ee5a702b0a040b99ef36ae940204c4575bf0b26c0c89132b1ccf7603500664d9b1521bdea9ffdd324c5d05d33a04451fe95c5c1a42b1dd830c2dc579613446f89786ecf685fcdfb9d4b5bb6b5deddbcc5f05c0833518369eb77156f91b2b70517a40897b721e3c25e716ae5f5911aa2fdfd38dd938ce8642734f6c788e7160850fe62272092c6ea296169418e584f0e440bee1978f578c717d20f5d6432c0d0791974d28e16459845da5f5db7472b7d55981508ecbd115591d6bf6ba1cac2ed1bd9c388db27c18f81a033d81a1b4087c0737cc95adda46a6d1067605ff513939357819358ef046204e9db9186382aa78ab455321536fddcc0796b98419d63e5bd4828134e6fcea967769bf90f90fc644d80c59447d929f3567141abdede1677f64cfb2a12f34b7df1c2bf7dbacb9edb91b078dfc53b2e49c46de3b2a2980c595f03b16b44b570ffe91c7f04c5ccfec6a2acb047d9a43a1c5f88a99e1876210a176ae9436b33088a5bc2631fa572445925bc14144d621c502009a77051d7ac759c8ec5d8778b196a01c3e2bbaa331d796b1814cbc9ef48baac98eab2f09be4c79ea45b56e21fcba6493f602a1a4a1052a380e885dd7095a4865172766d3b5f26c6e3ca10bda2e2e0f5211bb8a13956ad55fbc48621a7ebcbfc91f54014fbecc5e30ffde0869ebc14f84adc870030dc55c6650fc926cf655ee44fe6ad426ff93c4136e4555476423f169d582cd7e74d09e240d38de39a62ce9805dd53a6e78cd91a88936c9448cb5f77d89e6285befa7e9ad80c9e4f1eaa7956a23a331bfb2509518d5656000d325877f0f0b8caa81ddc50cbfae03afe5e78cfad4deaa6d497c7720a813de7f1ceb4f3bcc1df5c3d5c77b96904b81aee13ad1bf102cf7c0be62659b32d4ebaf18e2e8586e1c116d8d9fc78d05577b9cd7399f387ed6e762492b4462c899402dcea3ebf110aa1177d0b7d76c2f7b0cfee403f7cc7964c6d2f481f13b4d8abd8785569f824956faa31bc73b0312c0b2b67139924a734ea9e2b4e6bd3aa61df6707f03e016396aaefc82bc00d058dac72f703a3badea8e55b0bcf1debcdbbbdb6e917dc83749e15dd78c326287aa1be3dc7d79b7947a25c00572f675aed2b33092b17cab49d3b68abed30c99ffa4333564cfcdaba397f2597e2e05ceb4fa6df9c14a2c55866cf7388925b1f36d5c4d1591d2398ff363193401c1e12518cc01be18aee3e1f2e7d2792a6d8fb3d85f2dbabc0e9237d704c6fd1b6e624b9cd50db9fb577067d7474897b79e17469c467f5e213186e1b7c9d9e7f584da02117be691a477765afd69f4d39bc665a5b954c834398b4d54397a2adace43ef530ac6f64d09a06b3a5b2dce2dff53e1e9e79b528bb01975d0a0b0d9985adca76d3ed169443448600c64807a0108e854d263093ad9ced87933271d8e03811660eb3acf3c0394b916a1414b3e6215313094f456c919dc2b1f668b7eaefe309c06caed3c2d3c5aaba7f546728c7ca63e928ddf5e2b0321041f45aa9f9637323d61e3006e9ee106d5205a6186fc11e323be79b06469974f92869350ecd035e3f575c3f92df209f9ddb4c4680225fbdfadc2e8947436c5b86a1f8a7d31b6833a35bbbefebe651e92642817e11c60e032a5a38b92663e031a960337a952cafd63b6020a4cde7d8510fef9308a016d894aa8b3f1d81d52736d08afb6e77133397c8b7f152fbc98a584bcfae2f8f38e98958764cd5ff0b58bb967cb4e0dbde24c1e185ce8001d0290dddee8ee66b6d54bf12f7f34baa1a496297ffa5db953a3b7d20a06cafd18ae3eec0527767093cc3b862072897d866cc5ad2d9d6e1d6c42e1a90adb9416e9ec8bba34e5291b72b3c1eca578a311fbf2ca595eb7aeac85846827a59cae51adb2a434ad6c282b09c44f2956ae630dcdf82926130fda1c1ffd3c52720ab541dc704f61db87dbbb0b4ea904fce2e4af7c1c3b300eb55068145533cbc905f531b5a521cbd1a9adfce22692a6bddce0b7d86e201e1e512d171a5ef19dcefdf21bc5788c7ba8010824656aa60f59f3d8075c2e5b70451399a5845382f0cc60847dd36a395de143a3784c8d9932d3b2bee0c66c77bfa8ce929802aaf7b6afc4d31cd6e23cb0d829df517c184d116232dd96e885d16c3fbd840c4d978269d4534b65dd664ab6dca27f83739ea3dfc30cc6a72b281be58713254d22822e53239248c644ac40a31d6b9ce8a126a1977b775eeffab28b04a49495f01d239568b3b752594e034de62b0550bcd4eb35fab49570cbcd62e3062fdecf66ce50c1074181e6d8b2b43456146408975e59d4dd37ac87d745a4d4f3e5cecdb0542b511bf9418f83b53e4ca444d067f9110da61595d8b1019d183117f7715dfd26c7ddcda14f462290e7357a7d48ecbecbcc417b8c06e36fb49e914ffc8b50e099fe5069a9e42d8a2336351ef1d66ae89af85f19b6c71a689837c72bf686a267c307031db44b1404f1be9ac992a493d44ed91be4730e386493da1a0e6e1761575e5c41889017c7663b7cac0ab0f39ab32a2003c2b802ebcf480dc11194141c24397965c9e14653511291fc9309be02824c794ffb065ffca4df412d22d671e4ed83f2615e3f0a33a7859d1436dfda42e937245e83886ea4b872a825315b27755ba091ffd7b8bf8d4ed6aeb41dee5c999631367c6c2d61eaad98a1bd570df4a827d000f939a20c73527b9a064b8cc5415a40f2ed12d549d5e53d22b726f225bf26094b1591abd7c726c7c47ad2a41fec6ede471b155f7b3b7ed86641e0a494bbc5d172ab3a9c9aa6be4611f6c09c9ca37191b12de526f4174e6b50c21c76a3a86d0f513ea525f69e45e48eb4470dbe5b5e3763e093fe5a8183a1ff618cb27226791c8547b96b3f61735a11732d522549621032fb24ef26cdb0690609795fa38d9140b893906a98f2833563578cb23739b2dfa57c04b875d761ee0b34221a104e7033367337fc29aae0cbb3dbb328c52ec2b176a0d9a16e91eafd639fb539d5242984b7a798db93c30accb1e99cc7b3b966238c2289f3314765d1c7fc0ce85a8b6f5ce750ef80fa6fbdd540e6d2ad1a4619280a3f79ebfc999bc4b069cf08ae80d2db810c19e43ca2698012e8ce130947aeedde282fbb9d8b8fd8061f2b8bdb093729a3a7e761fb29ebbb83d097e91ce7ff7a5b56bfac015f45f05e9b9bd137bde7934d3bb2c998b923475880d75c235ce076177a9399020450b5b58281954ecf9890109b311e4d28d4005a22f61567447a1ff638b2828122f30083e4a4c5f1a7548c11ad7557791c991067ae930a1830d3a1fb13bb39a3e91f0c0202342ed52bc35bf33fb2ec24fc82f8e9f0248eab0e212f1cad46abe46e1da6361526b8c3b474d8cba15b33761e6ef63fc311c4146f4efe2bf5e5d678a9f03ab0217341f93d20e4f7ce1c1ca8114a3a050c24498fd74a020e65429f7a8ede22b93681d7c33fc35d04428f29fdf4990f51345f203b3802af0c1c983990fb630ae1730a995b388956ace74d8dee0f78d0ed7a0c7fefe903cec953107a32bb368946aed276f4bb203b00f80fc698e5c1d1afee379e63dde47550aa98957d87a0df62a59620aece4f60b530ba6902c4899e3a56010fa651f31bd9d08f29dddd11bb3cfe812d5d62a09a758bf62495ff50daa5734703fcdf7cecf042ca660fd60faaefdb5efcce2b7d560f1b7fd955a1fcd3c1c0aa83ef03ba25a417c515b1619c9dbe3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
