<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89dd79ce97c5bdd39f0d1d587aa52227daa3979803a1f7dd201ccce06b4a5d11b7fe7d2d145744d9744561dd823195790ca0fc48e425c99baa576d6f64def07abc31ba190d70647e158e758066d0421542e7a0020c2160dca812592284ee7e93c0f95e89d7cf1739528978fbe57bcaad90da8db10cdef54f5103c037585faa71c74ef9bed0261982782bf067cd6bea09fcb4de6e09b316e9c9090dd919ce363ffbe9b8104afec46bb2ec9bbe505a455c1893e6dd47c65971111326e399838b0f1ebc2cd7f7ee3918da313ef92f101fcef9d87c3d8deb0ff9c24a914e3b57a130f1df1b4ea4c4d65be8152468d1ff04870cfd8a3d627daa8708c778c99bc9e564c3eb0a8afb7ae03112a6e971581ccffdba91822314130f894b38111c9e2efd26580c213563981b049c61d3cd5ee6959a1cfc989211bffa9afe6d5ba5180604a2db20add37cb76ba8633098e7b451b8fdba3182ffa13e7062127964e9dc316bf12b579c71c56991792c019fc1f74a903fa669289074bbcfed24aae6a44992fecf522d86d5d2dcbae128985e3b100a402d5818a3ac1e941aa90f6a07bea294d01fbf4aae9741f3ba1bdcc530708e5b1d8d8b7e7e20e6635fc3ffc71906f93fae0a96ad74ffd537285973ca6224d54017cd4582d81e9a127f4de431379be85d1aea50fff971435340b434e4131d42cb102c7290341e57f6a6b0d75d178fdd260e145b0f86f536342dee42389b7f70af7c5c340a75a0b39d21e590a35a544b03486c978a32cca3ddd799d9923691d39ac4eba841ce994080285f3c69df0e314fa03e2283ce95b6a35df7d11bab55d218c556ea6a5215830c0ef0b5e9700083be0eec1d018d098538645ebb2becafdcd900c80149a84565266a506ad9d7c4ea04a76bd158f0a38a2e9d626f0b195ee544f5803505aeaff983cd715eb67089f32b4e2f84614aa8c5681c020e2eb323b0203f08b6f2a78d56319e5536ff48fddf3c1c56e25ae533a016085b60aee62ce2698952fe9d6c71d2ba89ce0e18da1189933eba4fd6ceedbc5f0733b3c1a458a382146cc5f1b15c2b5d4aad5163132fd4a45539a3022606220578a1d1137181bb28e5aabbef6573eccdab4f951baadddc3cf2acdd3faf083e1525525c93c4766aded6003db45e557bd8ff4e47bb2dbc393fa07c32a76d6a035238e7e53ae04dedc00a3276e9671b7efff9248fb8ceefb5fe995f816168944a269a30bada2b37300f7a25192e0b9cfbf42794e9e98e2fd9a314b86b2abe16734ee4c16df22ad1b2fc99706bdf7d1d1632a8d8a07e831c9cda3c58f1c22eefa371ea34f1989f0407325f1f3633bd98a489a60525928afc7dd9edc4d21ea6753bc6a85dcbf385974592054eb974d57f85638f9bc0238a451fb1702ab9a9c728e2484c311f68972fe00db522baaefa417ce134112dff877522c0ca4f370521ea1a88a08472d6b3671fb7222b18eed0ac4dc7e198d5d882517a48fb5e9f8aa28c1bf86b314c2109f9388ed53f574e4f57bb1efb5f31799321ae6b1e915ac8255f432b4d6845533feb2fec786c09ce657b0d188865cf9ceeae32d0af66c8fb38265bf47e41dfe44435f9addfe7192a24baa9167d48e752f7f2a9bbfcb7da58f62e424d94ad145fff2af8189bb857fe0a46adf2b972782f9e16095d5a63e7ed4d146a73583c6eae3fb19ac581cd7eac76052b995478bdb55ccb1d0da0a5fffd75d0c56cecfab12659034b663e9b08f577284d1fe4befb43c1f7a236d01815d62f3ad19b53657f412163fa19caf645f9a34a08265210b217d0084096230244db4733b921cf4f360493a346d2d9d18e87209766cb8dd6d3c49436625e469d6234501aae264380d3b4e8cf2664bd26204387b775d5d1509c29ad61b3ad8ec434c9263526465bff3859d20d7314debeed62d0e476e9fcd2574e2f4ce49573bea3593089f133edd77f68639ad4ceb877abac08665842ea3ea3085b9570d614c144d83bd79ce66f65650bd4b44e73796689a666c298e28e1829fa30019854704f43ef96efece4476d9ed269bee820589aea525d646bd471fb6aa05fdf5b4fc90b7cc06c219ce36d72e8ebb22ca213c1651c4e8c160bbeb74bb60c85f515bd0ab5ec3a6de0d5bb800e1c00b193a16155d881856cfcf3b73b308412acdb67f364a5abee30b4df1548616c7451781399bb6babeef092a5c86fc851286ff9f9dbe5ea39c0c1de49c2dcb0414a711d8b41c0fc273110787d400e1e3edb232434be3d2f8230feec78f7312d6ec6a5a79551eebc4061e477b1276fdd3c2a841b00b2915cd3f53200b6158b62d9baf350c63927d82203d4811f000724fd313c759c2f56e3f738e48f160140ef357364e135b226642cbe1ab3b7b780e883a9a3046d6ce000193f2752a1032739e90ce7d39f68d7795d4ce34b18f63c66b0d151b5e46abf06fe1c79d8e6ad64f15dafecc00adcc377233c719f002c727f150e9bcc15f9fafc42f82869bce700d8c9e64a764f721175c271e487f3416a14a8696a5d61b89677accb9ce61382e693734de9fca5a7183771a318e5b79d95a344959ab1c73b8318825052c68d5f51f4568ec54d033917b819cfb6520e2670d5115ec9f5b61275ca30222436f750a1d2783965707b60fded1805ed9ec64e0d79979c23e5117579e9e7593c95390f04c253d9fae6516c65d1ad8840d29038e114ccc36851efa3d1293a1f87503c26bf0d096eb6900e83d7cde26266f4e638a5304c96787c6d9f43c50c447502e47e00f31e3196dd5230179be34afb44fa51e11377f8531b4913e13c3e493e9e017bce0cc75c6846859952b32cde099cad9770b62c03d99ac55656b21c2770461f6e846c2d6aa27a1a1e664fdda6680275a92afd4c1b8aa50862a40bf19cab7ab8945e067794519a183e44e7e48c4d8b1f7a2cbb4c7a9ed1cd5514dfd0b395eafdde0f5053d3d589a40fc0aed908778550bb314377b65fa8684c694badbf4d92ef13695dc7b224542f5b776a9f004d87aac34ee7040a0de3324033e1c232c74f1357c775c4f7cd4bcb5023de24c79d8e5b826cef6a49b95c6a217cda2cee15b413c8c94f6dfbd8c8c7a1186276f051af154841d7698ce90c75401f9be0d25b1c08eaaf6d028f8ea2a550ba55cf4f55abbdb16f62f657d2b90275978cdd9125d011dba5106e44cc338ff8d68e753db798852d3b0b709576b7589f95ffe0d8d186f8c4f21aec0d5f5444cc5882faa121d36db5e98a1b2ac415dc0f1d956b95b866dfa04fa18abfee12648a65cd22c2f3320dcb1e2f48de6a5bb8b3a8965ab9b560e0aade6925d0a5762999b546853ffe478f74da3794d7032ebaf708b32ad55fcd06c1fe3430d3e0fe39a12aa820a4e67490b2bfdff28af939678cb05580206b94077662bd6e95f9962e195984d5154cb93789ab74c1746191891783e6a1d9ae4530d0718690b725c9f115f2a92bec2fb40430628cb4ea25291c68f934ac37761a32b2837ea73f7010fbe2727ec650d9a4b7824642fc4037721c39c77ad6b823b88c6262407b891f7d5c9a29f5c3e2bfaefc66be605caa8b37b1e7d3c6c20d3f532ccd2a74ce7f41b29e5854a099904e8a1826c62743a2250c84be70adeb8b7196d151198145900aeee0600ee8758d680365944c9f3217d8b7229a73f4323a1386dffdb11273a8c65b4dfcff9b29e79a271ed29305714b516502f4ce9247d2e8e3d25875f3693dd1677476822b9b95b26deb8b19381881c27842f9f7e590d74b8070ec95cfce17b3269ae9257da46311e718003db309244bd5af315993c958c7bc94a07815d458c7fd81aae02ae95c809764c37295af2e857686868a750488235007d090bc15496fd78ab6ff1fc3cbafe744a102b70bf4bb0f5c910fed1d1c6cfbb537c23f19e60b2e3a83a4a9c3c5fb9c86106c092ad600e7b9969fff6eed14473b32ad12cf7429196c2b297c6009fcfd8561a28de01ac339ea9e910603ad2525da05159182959c13861f387330867c185a32644e509b1b7fc3f6eda5b611aaab9b304580129863987cf79a54bbe7041b717556f3e8728877eaa81e809b7ba782abe9ef2f2187c2838c5e22f2dc9589d572a6b8520f544d4c3a788a2c63e53787bc22043c654d223f35f3885dbb5f8541b1a86bbd1c2ff4cce4b6d82976029c406c2b9af1164e789dcd08025bc8803ee739f8d97e269600ea9e567fc2653fd9634dad72611a43b5e13a442817a0426d0c0122df38471c577d934b56ca69c914d41016c6eb90204a45ae6292f5bfac19bfcbb39af9abdf09247b1be86c0e5fdca2c2f0f35fee855a7cf95dff87abc8e7abda54f1265503463abfa28f41f0e77b1cdae66e0e2bb676f4bc2b62a29026e22fdc76c2bae3f96bf06b88e441565fec63457e24a32bf90030eac41cb83b48709d89ef358850f27f5b47a16eeb8cfecb697e6d9bfbd9ce2db073499ac66924bd51ec247fd06db7a698731adcb845c9a92c4e7fc2d0940fab26551223ea3850a0c41717fb97ba4d84c816eb78bf59f34518d128bbe3f1dd6ab58aa817d2d2d7e83b47799b14f0f7add1f8e3fa83b33765336c574dc6bbdafe8c727e933ddf49a9269c5e7bf7ea70c0de7623c7f91d48d9e22adc5dd140687034ad91e5b7e0b32bc4099c7fbd57f41616dfa415add76c1bd736a4c8cd3cbb41470c9d89137fd33e81e44f1cc3b664d946243ae687705f2224fca1124083ceb0b654574978252886f386246fe06ca6e57dd06ae300056da04803c830d2203af93dfebff228b81b5f287487637838b33b2ad39f2b0b7611b4f6259ca39be301e8a4d291a36ffc0953a9dfc1a8a612320a718a453ed76ead37af3c63642d9664e34ecce90d1cfdc861ea43157f9396bcfbdfd8f9e435e21ebc79134706dd7fe3e83d78b23b97773aaa01065d9d7697787a1fb3f7886fbd7037a15c4c8ae193495704c6eb7972d2afbcf983610667f9fbd08e679f6a873c88aae97b44243f6f052d83a02cf012d66e4a63ba307d71c9032c4f7f79a3557502d17fef7a111440c80c39b86d728de9a826d861f444fe2f6e801ab05e3238ba35ba1ccf1e2720ab059e290a445e29ce2af38c8ac733ff4cb9f525fd8b95e2581ed43655d918302743b2a5e9399fa7a2a17196f9d698e4a8f15d965dacd38060d46006eff1b621bf40889a7c104464c9f6d7e79f5957c250d1f3c0917046b8727ca060d4cf2630943c87be01936baaa6d261fcf92f73ab9de6b76bcdd0fa5ea6fa6ccf802f3aeef391238a37338975a5764b8d2c3c395d6310dfc40247eee2c6e2a5b80f36a827f3d44d2cce49d39837549404740e4c8ca82559d756cf0b247b888d683a3d2c29129bbbe41bd7fd303f70da65c4d7347aac4a814d4295e849db6cefa3de29ecd8b0828a435d59faca9ec8cdece77f53170a997810d3fe0e4764f744417c7490f0cd4745aca82bdb4369e7b17611a885ff77fa88145955c45e6a0da77a1a1145176337b8dd3fc4d71d8e9cc6af84973c6cbf60a795749c8773655b375d730a5f7f813a1a2fc2e2c5fd5690bbd1f74dd4fe2d2b5c6457c86503405017b9dbb37b577515e85edef8ac96b036a51acf98cf30fc5d67f2738a826e91e70a258786c15d6eb9d2e2af5120e1ee37a4b710bf9c6fcf09b65d28d01896a7ab90fae86d02f2e9be6adc982517cd0a0bf57b514a902604ad587d69cc69e4e71250998c874e019c6d42a202dc08810cc90fac80815fbc92f6a0a9866cd5b67c6a50edd8db423c5cbb667ce52d4c85435b857d793f1aa2d5b3ca9d4606393038e1c001116299dafe34b45af13281ca5476fa9e5556129dfa673fb259b5b0b11f14476f068de0a83332fa0f0c3c31f5bb0bfa49b4a62ed3e325321605071243910ec5af76861458decb05be40e63f6cd3a479d5953158ba81a84cbcb6b3d255b688cbe76776cc9e0594c680398010673b187e1970aa6e3f86e527a984ce748e2a6b39e122b61f79fcdec8c889e2c2a160011ab2a13201243f9599fab89ab1c7f319593addef6fab0df647b1cd6b291544df1daaf080c4350934e0b3352e2e7a72b91836e4b28e4691dd3acee7adf2b1974d903b94a19cedcd6b54f67fddedb0039b208554392aca729c4ee7ccbb6080aaea458b315b3c399a8298f4db40470f085de21a06d24965efa424e52ec68121544bbb9b6a312bd564e6193cd7af50fdce0b1fcb3aaea005d935dcf4fbcdfa1a5ac98ce1963491c8193b8a185dcc6f7b34c07eb1dc79cfa8b57b9c7933c26079ef6b5921d2fcd8b1aa49d0abc41cc774a57347464b29202c06f149d32e3fa98f0f7be33a828d6a3fddd7dab306207af29922307dcf23526e10f5661c630dfe0845f6d9dd9003b74bac16355706b59b53f9c40d667ec7791c36e31f3ef4536f971c716350502fd3fe7def7edc2fe28e1305a59e75e1f946fe5004a1ceba8e3d5732992f581ffa22199c252923da22ee0536d898e9c8dcda5fe3b38abc0eafb20c0ed16163a24cd193a035227c57f9c821e3d91dfddf163a23ab8980ed402777b74d729921a42816ec245ccf2496d6b8d8546a6b1d56a3e5035383b0cd8f8c6a8ee16b399eaef78d1a982c9ffb67970d500c02419484ac3e150d5bae2e3ccf666233e0967d73a307a9eed82f264340d3800316da619d0496a35f518eb60fa005c8d3a75c40e4fa2cd1834cc7d40708c7d8a75b5425efec7f140454105525e63c16a53f9a900d97cfd9c1c08137b7bddffe35eccf46ebda69468e9ce8e6f8e8686abe98681dc9e5ef9316d3f0ed416f6ca22478c2169717e053c16e23c84098eff89c8af8c507c64bad7a1abbedce4e098093c99b2532d727690cef0befc0b58789582857073f46e0fdd6999ad950db047576dc67f92c3c181df020054209cf317faf65e031bbe229d3f9fe3628313747c0aed9172b6e18cf3d68a2fbd71cd853843061113e348fca7c493f9a9e4911eb7fe01cd15ab124a03b2f2e5c9ed0b696e2a692f6ef2bc82b06e6960660c15d03d4054160ab9c4c44e7436e6670bf265d9d4071f1aa4b5f63d86900a77ec1146ab5ae7c38683402cd902a72dbe9278d6a95e7168316784687cfb1887b1eb95eb09c8bbef59a1c038e1620eddc949e4a42d3c817bc8b2d68190e2a2ac97f55e0b43ad207a67e5ed85940e1d4b879ed820e4c553c4e8b9058726df5c6505f965e6700f49ee9032e53417c6cdaa6b748aa485bff8521d59007984000ab5a3e4dad98c22954529149a304166edb922c0ed061760e64f0601c6d8de513260d1047cd84c2c992c19c1573bfeda614c9df12ca699ae54144a5c5bda1f80b74907807b52174636f1646e6cd9fa70c18fd3430aff22c0509eb09443e2acb36351145e9d9909b1d9ec6ec9e33b5a63b2375d2f66a9c1aeb17b2c2b5d91080e04362a72facd6cdc66dec592f627520f0143128760597248c35dc5e0276e61553802f25bf2d0b4bcabeb894d4e6abcacd3ab1502a8c79589e54b70f5d4c1dcef4e2df8332c9c17b950eae2d4d41abc773a717edcdff566bf43bcd2ae83acb419830fda788c88ccbd1c41c41db293a576372acb951dbcd1c33884b58c5c206962c3e2bf2c1a96627d213adacaf8715b94ed7f46e1045a6ec4f10d56152200da5e86cd5530bf489a9546edf06a8d80e6723b7edf4ed4f7e3e5abb90f1f991bf8e84eb14a44a4a35d1a4d4c2aeaf9118de6d508b138da69dfc6a8771e6dc10aeb396f518d7d324ea94b634bcc1c54f070156f6915d11d6fb0968b80893aaa2bea3350941982b63beadc5fa576e142daa83a9a97ed4983e53814edd65798c35ddf44fa0976f75dbafe77efe44a931747ba6cc539634c95f4c459e08d24b64593c9aa68a4a8ec8e78c6285aae0eec92c9b6a42ec8ecfd9148606fb4fda8921a3262a923b798bb30b76eb5d13f1b68b0573e1afecc8dcaa930b66f147c6b353a2353d8f607ff674d7884436886721640257bc468133a5f7a037f565bd290c95e965b39ad3e4f24df62948fcc4859d7c8e620c3e91ca22d51546295aa14173c0caa3a96d44cd4592ac7fc6700be19a89ca3967c3dafaef0fd2f1c6635d305c03de4f6585a917f1f18e3f4a30975753ec7eab1dacbbd6d05467f0fe04571e95d73fb2511f20ce7c026ce80a1c8fa6c8bf4bb575279aeadfe38233c9fb09706a8c1ade5bffced109d19f8fb9960d908baa759c33ec40456a418d1b8db179b59b5a86ed75b690baa3b22397f127f1e82de97ff54ae8add96ac66f3a3d14e9d0a584a66e450e8979de74f9e053c95e49e11d252d13cd45f03e16fe2dc96abf8c1643beba608f034b10b25d4c57c21f5c479c266ef8fe2ccf4c4b4a8cfba339fcf3c24683cdd99f514e0847b4f6e074b36e1b18146c06dfab0aee4741a4a6aaa1219ecbdcc0f57cf99ba9a2c8cf120d464c96d4a423bb3e5084b8cccc0a8a374f1773b801deccc4da86b69144b114464265ae5ee18bc287326fca846b625c4a036ce3b0afc93356599f38b48acbc2c10fdd0243eb91694c47cf93773da1a76d96edbe70871662e08fcced5976d33549df034363ed038bab6d2198a51f19e4a0e3970a2843ddeba57a3cf25e503c59373244b86e127724ef91c20352f58572945d22e7329bc412b3031d273658760ae244a23697ec2bbb8b288c1d8a9fbfc67f21c7e5567dbf202c2c3c78f22fe265a7369270c8d700b4fcafab4b460b938357cdf04ce372a963e61036468461782693e72512bf592e31ac669e04c547785e907895d4b13988503e796f956b65369ee528c02b62c1858acd79c278c830b1468b98409de81e373db6385a8f99f10c175abd0f92f8fe52dd47cac0d4452e4a2cb02edca2824b6380bfdc90e1307363cdacfce57aed9a602a0c53e2753e909c6529b450551ec0ab8fbf34d90dc3f048f6a57b83e106743b16ecf677807e8cafe56d302dafee454586313f0a61f3ca318bc24b0b6871e6714c7a00743c1e43de3f6afeec5d1a9975691f6f02023d77e6f72419678b9a788fe62a919bbb6251a368844e0f8a200b8f7fb29cf27cb3d67bcb4856bb88df2a43f03bd1256623cc3c9b76c521826ac0ff414a095d41783cedffa943078c874d398d17fc7a8e2bd2e30df76c56e1ae88523758155957518eead518506fd658c134b2ec05f2ff69dd35","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
