<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c2a7448ac05cd0a0f084a4cb0d8069d3aeaeb7551fed6bd6a60b7bbf0c4010fd81812fc96adf2ff6a565f7c530c40b23142f3ccb192f68324ee25c589c10103114d31a72263ca1e328b5b7d6f8c17931cfc11a87b59da9a270da4d5d2bb5befb95d7e9b71f1a07ff2dbac90758400969c2f51583e60a2f32a8f443380fecdd39598acf2155cb5263d86fa03cf2b77afee0499a0001fbd88b052fdf8c5dcf80b1ab1a1a70bba8a1b4d7014b19328824ac7d6c7f97b3b57d82733e7c8bc40dbf15ce5ea8e91f414fdab18ffb199c79a19496cc6687dae81c253adf3b1ecd976fd58e042508094cbf1d7e1dc3b33bcb1d23e58328001373251e94cd99600eca8e3d98261285e4be110c4a460738e82047e3976c09c7d42a88108a1ebf231ca8dc9ffb233c157d005ee7f10a4750ae948bb7817219ff2dff18f6b12784f42cd7a1238879b21a2046b18b9268425946db7a0cfede3fed9d8f1a9ddaa7478a34069b664380b3afd7ef77fd05f6d06a0f133ee7b4fe53ed3c6fb31f965bde6226f2dc71e8d349426d9125cbd17c3994ecad376d9af7ce477c4df9ed64e9693065477e3f510057b5fde5c757dc96af8ca3df5b1ed73b2889bc4bddae89b32641e9c2a4e969378701c57eb3b9004b846e320e13639b6964fc017268338f3b94da071d811be1cc7325bfe8617cc309f53903d8ea4053bf967b74738c851a494f9a7235240ca469b4d2912e759fae30666e4eb03d9bb2fb890fba12ab4706682111c84d1721d0b149950ea69117a48c89ae04b78d696d7164d43fb4a613be08847ce96c46d70e55d2e6fc88a991c67676a05451d73cbafdef55af9f97e8b4862c5eee45b8ce50709deacca016e96a9bd42971f518f1e7a7d511a6d837aaa0bbeee661d7129549e16cbec2140dab64dfa86922c9cf89a955687c49d772a2fd5d4f98d45d8214222402183be44aa6b2717bd8b9fab398506d1a251895fe8bdc30b89d58429d7bb646510a2a22997e4050ae46d4e6338203589b5b251da6c0cc10f0962e14d4cc9faab71e5ef41687012ea611fd31072316e138537d165d4ff7919b090ea14ae14d243504c362d95f195017b5b72df6c43e58f926d20e2c87b6501b7aba863b3f176a6fae8890c462be497febb2d510502dad537ae8436806e0cce277b95b705b3ca28bddbc52eec5b5dae0ecc852d0c918119d42dae53275f5edf5be50679977d07cea886f77638a673e6296fc3a0e433b097be4c62e0e75ad863ad00b7cba23a1ee658cdbb97744c40356cbdb99d440aeac90372e337fe714e1f410431e097af39fd52d30c72eb1000f651377838aad10c4093c4af3ae83682e75e6fbd70b2671e7bfdce7956ba98ca86a423591274083f728e661e68236a6f1fb5d0bef9c05d2f85a795e45d28f3436f88459dcab5de4c3a6d8be2510bd58385d8acf6a2d674f49360c5c462ca822ae2de6fe7fe2c2aba71695e4ec7dc34e1bb41dca7c9efdbcb5b4bf2f104e7e250992b9dd556da7497bad0d501508757d8df31330a03e5c99ab2e5069bef1dbc924ed51f169a9d353f72542a512e4eaacba37c1534af0ca23c2113383b2b724615d5756ba7beb12ecfa821cfccbfe662d2913b1a7f9dd05fc57b48666480a188b045dae4f4a80297bd4ea12bc2014c50906064436dcef082c720f05a8cc82f1fd5ae025a8aaf74e4324aff1b52ab0bf3d7a6d7956a713bdee4b7ab59430fa22cbd0b80aa0473ed3b3fa00b4485065a49915deeb69e2014175edf1b60fb7194e3e9aab52d759efc8f3ab7742536139d8b2782ca980646e70e29f7d4cc0dddb8a0beb64b8b65f3ea7a7e83a5a3975e56a6feb49fd1d41b8ab50548e3a6e79ce6a67ab63af8ef647dd71bd7a4cf1b6696866f57950b7f4336d55d0c830927907f637c439297f0e2ee87d0b391bacda260999382ed4ca213f0c62df0aa16b587a4cb6c04ad83b891aaf61a5e9aa9e9a8fe01c5e25d34d3fa8a3cc6a5c535d8b0a647fd15fabea5c460269b0c919a8f7d702ff252d143b6536d0ad18ae6f99cacfb2005479993e4e316f4f4eb2b668c17f5125b5388e7a7faf1d6b77d553f5e0d0f77614107b2a01c5535c70b131a28da8d0dc7beb9573aea276065c91f7cd21ba3afbe248152a20df0407d094921351cec83c8c145514184473ca9aa3f601f56f8536c34b5e8363542602d0739b905f4f58d8fd162927a24882b9acff14ea0691a751f1c13a7d3b51a60325740dc5cfbae81a977001cb73a2e9677a0b8b1fb5301247ffa2363dae8620e3d672aaf23595f81a29767256c7f6bd3fddc2653fb722627e4f2cfb18caaf9f2a57c459075e5c130d3fc9300f63ebe2a6b832d5afe2f0ee5b8c9f36bb60b9ff0c09a7edf33384bf415e95b45cc0c3441abebe7592d675643bf7a6a86d11ba24d946d333c80a527fdbb11a397193a57f84b60d733cd77cc1faeba9210948af5e490834fa3409a26582ef2da85c6b7fbe273edab187d6b8389b5174c01bc848b4a8cd2e2188ce02cb08a824d743d5e0a2a71a1841154bb5470e07f123f19b4dba4a8f9689058acc2b43a0fb96ac85d6ff48e0805555a3a84025e68e90e19d9e94aa79a8310c6e4416a59e3e5c7c15519e319c31f41e217f40532dec8ecb992db975733c458abcd2b13e7206c047be8d01363e6b3d4001f8314e7d9a149405f8a0373a93ac90c62b6d54938cefc1f6c2921817ffcd311cf48ae05bcee7f263e50c0f3423edaa926afe94b93f1a3ddb1a6f376666f2cd3af5b83882b6e0dac94b713df9ee9153c3b187c3415252fa1126a82fc05475de4006fb970846b8fbeebaf1c2afad195b16b718707f8c99cfc762380c8b807ffeb9ff30dd3478d5552f4011eb14b1c62c71cd9fabff2514c95c39795343cfc6eff14abeba653320b86434175b1509f6eab0bb095dcc573f3526b0af0d9304ffc28e28266d9542dc525ea23ef1fc890683f528287488fc7aa2b36b6a9c8a31a8b27617b563d20436b9b7313bf6019a8047deab8cb4ad4e54b38a86f64e80d2fdafb091c8cde3e6339bf2ea3a36eea07a6a9070e33257ca6a464df6f241a6baf1d83e3e119a3a27b003ee9d0a083d64210887058b9adec2b737456bb4dfab3a535eab4e492ad71babaf653d4d101841a57b6733d04ae1ea94cb170bbdeadcf17a1c6a427ff15690e5cc68c8c83353a3819649bc8cf5cc44bf6f4b2ee3007628208aff197c9a90fcd4afaaee9ed1fafcc548de8e9db173a7e3ddfba5f2be4067ff4732df4201f7d75dfe719f1508dc76fa6846ebb9a216372720bc495a0e9fc1af8dda39d8ca1028541de2ce97d7c11c06fff8948bb04038014f6330b1dcd682466f2731234e64eea859a5ac039a7206651e86b91e3571e228531f128835ad237b533abc096f06bed336544173b653bc22b0543d7f0aa3f8ca9f07a333cd03972f9de698084e041fea1b6fc5d13a9d26f0e61caedff862629a9819c0eedc1aea78415f2c518f0eb9a601b614cac76a4257db7767522d617a976e73a36b9b2c0c092459d299e6dc1a786ed599e1c36184bb603e8f04a8819f9f486c090f23111bca165b49e16cc84c9d87886ee074a7f83ee27d222c9f4476e902dbacb4c93c53b321247ab2def8aa22c3519a9cb04cd6410bf36c95371c64d8d4e4728f17b7161f33435ca691e455da89df5cb67bf6f7e6b90e0070ba30f16919ccd67ad61316bc203a97d148cf55ca5249ff9b659ade3cb03248e48e43f0ed5ffadba7ef6ac8fbe4fa829ac15b05c7729bed7b657d27662c9edee42713b92126fef8a9ce95a5f3967f93545a4f1503e99bff85b881f912b9078f2db1be9f92f4f0ccf32ff87bb39e4340983f377d56b2c64b7b28d27edd6aa671861308d5af2439984ab3e964b4fafcf24e99be4829d7c73b94387d4460c07fabd9ccd082dda24b4e4a9066525b5ecba5d3059974acf25f44513af15b4df77a664f2ff02c2b7e955507ba3233d5d405204cbe4a4be8eeab64ec535ffec4c1fd2498ecb8dab21baa9498b616544e9e517416720bc5f5e8d3def6e8075a1040884c228813ec83c305b9edf050a18622665ef4bce851c19afb1f540eb3739217dd2512b95255d04540ce60e6f44cf3382386d2119748c7d7afaad63f65bc6d1edde0a90bf5295751bd1104cde421c9cf85013db212547317c0533b80b12f2e0a33ccbe96b6645b70b9e9bdbc8ec52d24ae894b0478242dd983c994a2c2be7cfed260c83d921fcf850bd74419d6fb6d8df26d2ad3399cdc7ff86fab0176f3c1ac38cc0a13bac0d7887da33a1faee178aa260eb560e97815b86c81acf89caafcebc269faf79219528b822def802aaab3915afd528df117f94031cd01075feba0ae43749c3ce56794a294a777a29d97d0c82c3d613f4b576bf9cee3a6e5e7152ecf5b2620c0ae0e163174be95fd9e97fbacfb5ebcbff7edf4c7b8bbc129ce4f5dac77d40794e896d1db16da245cf84a32d9739fd1320a6c2460227d1134a398d874eea0da12b4f2151feabc5347b54a43f7770c3a7e9584a1126bcb20f7c0464cd194d8312b7e5b01210e244b25341e8b7f0d9c2d16fd979c7d1071299ac8246f9e1ff1a06872a94d4ab9235002d587d3f8cb07ff91c612765d4ceaaa5a516127f59ca167cc99275dc64caf24422c69adc3c051aad09708f04d3b9ade64337616c8549e267de93501a69193ccbbe017dee517fd50881eebda6618b3abc59d1ccae3eec206f3f57d22fa3d6198174750b4b10ef53979bf6cd5e9bafa6325e407ccb7caa5c46a2255330865f07d5e07c5c36452376b026b80ed22d1dc9cafc1ee8ac6dbabe5856d0761007a3f26f46e66f916ec01cd8290fb3ee6e350494fb2136d2ac6160e2ce2c2292f4732f20fba15cb6dd1e085eaf8ba35e95ef767d568e8690faf5a4a65fee2eeb69dc86841c3354b8fe306c2d3e61100a0e9ed6f29be5eab6c5916459da7e764dc41ca844c7abd746c7fc6b78921e70a1100656f3a45e59cebb4efcb1c864fced84b437a6967ed79dde1d1354c2ceb626a2a038d4ea51f68e410f9d97f9c2fed11012cdc503ec70bbded38785cd3eab000b0b92b2bc5a56d3f1e40940ddd916365e623cede2bc86f625e7f41897636464a74f6392b8985098785f6e8c4a986338ea532cce7f9e9f0917bf2963862effd6a1605750782630bf3c4762ba9d5e06a3016e8ccc16ed68d51eb9b1be182e2f12d0fe2ad176574008fac42f7a361c784a7bf8c634d39d1f6888d6d852b2b7f8ef153a5eb2a4f44021e359bcf2116a2368f94f8737d9b3041737cc7f43b13aafee0059de3ca5e2ef23e0b5d90bd9bc11e0ad09bb7e2dd45e942fe2e559670e9b4e56a715f97e01b839cc0f34adf2eb2272e42f504d0ea9fe0de2b6e46f00ed31a9e1fb56aec3c54e2c17dea19dd0d47c22b7278bc64b0a3da8ff74ef154766cb39ce8f17850ce2b1d76609049579ebb8d9007c59f3396a5cb069141f212b4e1aa52dcf6edc09ca48ca3f9880efebada244fbfee4525c42d3788ac17786b431fa226b7961314a0cd71576010cb4c1a49126369c8c43d8414362e6fdfcb2738d8050c2e33a81c43ad87a18f709e674077495c1cfc155d2a9c797b6eca1ced5520ffeb50863c4a9f649c1f05d3deb7137c7d6d64d38aa56001402898c46a4b3eee9786ee7cd4ad6d7629d2f5cbe5b5498a97b558cce90b21650c06fac0ca37516983f7421e21e3741f51a020d5b82daccb3cafc141ba558fdce5bc796565757b2ac4884ce74e19ce0d17362556900075cca43c18c2f5db9ca3693f486638e8c1a1e32d8657c91199e0d22f883a9419c2401ecc4666c413d6b76160921f539ae54206da5970e40733550df7198311e634fbc9f823f97f11117c6389087d82ca92499a1cc14eafa9537a4e2019537091dbc5b18809c4595346ad0c299c3545e41ba772093c6a00e920c96c3a04810faaf182c508a9b511b28bdb47e8419c29c44e5ad07683774f091108da653c687d23f9e083bc6c9c0fa504589de1f7373a646e122888da162716d7bf36a197701c63c73dac2e2b678c1a0133b91324ee87daca63f3464bbd5ecccd628815bc5007421f1a94f50e25d8fb103c7c765f077cba89b3ecd74a2a00093f51a521dc54b0e39b2e0eaad0581c828bf473d760ccce15fda87702def3eb4790c7d17cc663d824898b0a634eff35386ab0b92623efc6625e13afcca56811df0e751964e3844ca37b2d3951373f5978fa6713f30959dae8edde08dc08f2497ae4f93d0f14b8d1664e53abb1011a43adc40b365917c257aa98149f196c2024295caa3cc39c79f107f49b21642de3afe12b35adfec9c28bab18f904c570fe2e4bb3fa4cbdd5f01c9c12f742006c816122f7621292b39e1da331856a6b454e038b32ada67980f6116acaae6355b77c6504c046e70663bfd2a7745faa1629cc3d2665e50a5e8c8b91dbf58b2d9e475dc0fc8a495435fc70c2f7549411279f2080ac742ba11f2c6da476e0d24ae154c3d7355fd80c97d9ed7365f20d8e4dfb1e40417a8f379d8ab7cea5d4c77fe56fb42042bf20b99a5273be9329c3d9e41d90d193ab68cddc2a566545cf2a0e58aa52597bf033674aed2600cc53082bce94d5b45e081540b7417269c127a74793f5039a664906f2eea6d78ac9b296e8db2ecd137e9c94c5ea3804fec118c326c28fe49f1d12c5900c3575347072d70d8142c647261206442ebcba00466985bc068d92ea49c388cf06dccd1f7eb8ed917f2a847f4e98605da30378e04c1566d26b58c7b61f9cf8f3f3fabbdac343b1be9bd3d4009cb45b5eba896af469d60f5afcdc49de454684c0c357058f47d77be4089a19b7363fb6abb295629e78d05ce38fab8d0326e18fff2043029c1e00dbf3408649669407f825347a635ed3dea94dd5cda172e344435d898239ece1a445afdcde0b0899b1f3768659c1cfbd7854abb9244d0a55c76a7a473de933d77fc5ddccc922e84e884e9794b618e7f7afc31a32487cb5fc24c32b2f6aed96e160ba308950c0f015b2b4a8382bb3360c88771fcefc85b7bd245a8f757c4e2bc82e0856edf8048543818df684256f15ac319c02adae423d17679fe4969ec574b369f02ec2fc70c7df81c14cc6a3da9ee9c700ffa3eb700391ea562dbaaf46cf9eab7d50d2e16709bf7ae26468fe036029930b2cee1e3ef0a9b346fadc5af2b272d7181d52fa52d16b4207b318bf2232234c11b7c4a1bc43d815bfa61f7fc0cd21405f5ad1931f457ae56a3f05ab24f28a44886a675377f1707a891894bc1081f51084bf5084a756e24c82efe6ed475afcd36de956aaedae6c8e358dae79bd5fd9124f2c59d0d16c4f6f07bdc778da18755fe287b19c14e8b3f491f13e4a666add4f67fb18b35629b555cad2293ed06f4945bf54e69a8ce96e215822aeea998d0dc13d6c785ffdf1dfea78ce607044418b812179dd84b772f5c29f80a715c188807a40ff7df885fa89748f7d4fc8be049c629c83deb14ac80122dc370d64a2be8ef06c213159cdfb585694c867127443786ecde1bc4eed6435ca857475cf2c0ee700069bc08bc90faf683293578f6b85c2c628dcbcb0bf4114e88fc8fb94d62eadb38027d9d8994b31a636c013c5770b8e08435b89a42ff55f19a4addbd2cc28f7e441b87c903eae100099ffe0f1583ffe5384349d878a6c33e569b2566ee88e50779d86d2764fe388540fa38c41b749f129b7aa3b0420ec71367e9f0686ec6d4c8aa48fdcd8cee00346ebadb826a5db76e1c785d4fd5b1cba59573e0070efd1039dfa7dd3c9f8ca19c984914dd1706ba33a266a7c1e7f533d2d0c10bb8aaa87c354224cab95eee5cfdfef53432554551cc9bad74869ec877ee94e11aefee245181985b4a1e18821e1c51a44ee4387c675bb0e9fc0790416dfc09e722f4c77687c066a749e0dbe2e4d193611a0d2e67e7fa7e8f7735db998660c027beb8107ba302cf1a8210ace2b1ea550615a66ae97158564618c2961e360b40215fdf95c8167afbf928aef1d8a691cd0c4c8f8c71043f2f2325141463d581f83dc45157a069b13d66f601246153c2e515a3e9e808c1d017bbf10faac11e0d47b508bda06782c12c3d6aa58722e511890e969a21c647dc5d7b293bfed228ad4b73e686010c84b81b07c76ab63e3e01997b8a07272f1728faa15a535f2506e827adc303b6ed01b6c94c6c44c6b853a79ab4c0a44e496301c4db37a11c7f1f3e2830dec85204a40c761af4e43d98d34d7ca487b8c370b572c2c449e4b274a925b883ef4b0cf73d677a735a65be4d877d4f0f91963817ab880056ee8e5917f27fd8fec5efc70a6844f02fdeadeaa71d114c61c2a54a1aa008074f8439e78d792bcc0db2e97459dbb79d1805ec42f0937fd0e53bc0629340bdea79a1cfc0e99bad39c2ee74d8155d619b35cf7a1a252c30be1956938410a92037e6f18cddd8a4cb690c09c079a5eb0c65bf06bd3b0404d2088f2230174aaf3130f7e46b37af7fe3a5ddef738716a7a349bde66955eeb552b4c1fd11f67a0c21eda30ff7a773096625041ba5923153b973ef76088ea8a8c72c81484f0754708fb521f6624810043f4f27915bf132a8e2812917532ea8eeaaadd8a03653a6ea40cf2d61573c40c069a838e6bdb5b2cb3cefac4a1395ad7ca6653daabae35c36d8bc22e1245be676b600c82f1158cde1c2bc2c1b1d56d9afe6314d772e10c211e2e668c18fc42db6107c2c7ff680270ab8220dea5ae268efb709bad8d5541e645502551d2e494489c7155f6ccccccff8e1a739a457b8a6ba05bb2df750102695e1b5ec5dff708e387a5e8d28b6ea6058bc98f24f3db9a51427da6871f89adba4ea609962c5074c1e4b53e8094e732c0103dafaa1ba56c4e0b1e557efd7d2680e46b004e01fbfbb5476b2ed85aa3f855abd36b84cce042aac260d15eec112abb740d880a3fe31d46943441c352197683feeddaf1ef36c1a6c7691d41915d7644b67d649e712288855836a5f4dce501efb0f0753b67860fd45bd2be298a3d62d1c870a094115f503fca76a1ade63c841b8aff7dbaa24a444db86e4f81214ce21425066042597ef1e946b0496985dd5f2702db427583905f019e286da569781a47d94b69fe7826074c5209e6caeb299317d62b8148844b2f9d94864ce19a9629caebd058c21803b83d995304e2146b73a132e108034bea88b84832ce1a2f98e47b786e69a271aadeb16ec69f67dbf25441cbdf1891052edd3f71f88ad4a61cdc69957e9a90a3c8879cc4ecc79c240de4300d0d8dff3da6cc42e2507466ef8efe62abf5a45d6beded9113ba88568657175a8d323363f22385aeb64f55df586adbfa34a6330d57737ad04583b5abc4ab95d6368402f153d939a9b937f53bcc86ab6eb0c496a2e86e42dac3800c0d3543deef70fde27cb7c93638cad9fa34bc83097d5a1ca064214515397e955b7925f5bfbf8a3315797bd7aa7ac7efc003f1c798c5cc02d68296b853dcdf353c459d713aa961b169941be99e884d443facea4623b5cd009c60d76674994cc4c78499df366842d7f50e7a68c54d2c3f326c27dc17a5f84abe405096dc10b10632ff78421b1ab75748f1a31c9d2d286c31ec39ab042de1c2f6bb7d8ee62e4c389904fafb979ccc52503aebee37d3c4de35fe5302c0a30167ca846ea2e160668163c89f539b5b4c0b85a69ae91bbe693ddbbefc64c6f257defb53849a144eaee371b50c8072a718c1c4c25bba5ef57270aba763df65d5e95271aa6137c61518cc95fd027e35a249ffefe363d6e337633874a9b78162a5d4f83939de16450086c8a81f665c8ff24f62183ad6a3896b3b18701e602c96e08995f69590bfa837b9b7f1a3d514618bac0bcb38b50fe99bdd2a5c93aad4225bc00e4e67cbb4da16a12c1876947ea09525505f70bf36c93456e66988a0df9d89b8f97e0494adf530ed8c36d8bde62347116e2675ee51a2ec566f68f7fbefc59a26ea054314a4edbad0313873bee9bd9855c8e5f8399c57ec8d6cb5fe5f7d127bb10caa728faaab2d6d5c9acdb671d5c6b47bf7d9fdb9955854778011350d025f0efafe8a38ecc3d83970d3296681597556fe87a73175a33a618d19dd27ade246c0989da084e9d63df2a45293b69c4fb3151c7b0bc92feb972114f7464db4aa252e8079dd788d19b12a95e80b044a9aa2c1cb421455f2a0b85ca1984bb7ac4bc80280df84e9ed78ce5b654bb53dbabb60796a7c0a13239b6b81157ee6a0bafb54f9646c90b65bdf145d1d42ea628181e9747e23773e168fd5bd86a74fe19622550c1ba420e8ddd9cec52452abe9dbcfbf0fc55a6e1c0deea68e58e511711ee1987a13b71cf59a643628e111c66630ed91386b8c4040b5b80f761280a907ad7db5f0b070b96733e8d2c1a01db2d062ebf63a1ab1ed73a25fbe43583642c2419c21aff9032f0fb9b28ca981b76c92ce3389d54ad5f0a462e0d88abf74342d279dc80392a7a4f6abd17a49c64fa7e0adb03e79ddf635199f6fcc0fa1e4bfba41daa69af80f252fa4acf2551be1fcffdff6f4cc37c62eff31d51018bf2d4f43dd9e20dbe20bc733d102f705ff39fabb35fa70161dc21755061d4fd621da0af864579c57aaa861cc8c036abf401b144ee9e1dfb59a26e30f79fdb0b46c1896b3bbaf857c4073dbbc05f2d7328a8697acc40a089b3cb818fd94f70fab954e2fefc0c21449522d46eecb3e338443f34b301fc4084e6ccd88e804073fbae339d2292731e8dfa3724ff15b7b7e1fc89266a802803d10405b357ba63d877c5b2c56af022e4a579e58f60c9e8149153bf07807db6ee240aa0e5505e347b4209a202dc07472a7d1b3442cbf24cff4abddce8aa098603b34903f027ac1c16a948989ea3d75b5c98b2e2801579a60034b582f91ef8ea41e0aa7565c2d91c0a37852ba1b7712850acf965fc6681f3f3d1df0de8c72be838fabffd61f39e04c1f4ffe7adab85d598573488f5de7073866513238d5f67ffb96b8ac83768eba67003ef4d9779f51cea07a414905128d6976d05bbca57cbffea9fd2f52c6c8f9178e6b22ac97aea96fb5a09331de7779097bc6ab7803af7d66e8afaff9091db4b0d9b7b51b57e53d779ec55d3d8a0d8af367bc37d83a364a6ea17cc5a48b03c6ddf07c65f721957f384ee2911502b7311595a6ceb2663b68bb1c1e331a5a7cbbe3676d3ba9792a6fc4097c3fe4f6f8088927d0e767a4675d1f056b230301aef48a6283714cc4c5868ea1253d04772ddf99b72713e0b9294c751d5c30b0c84468b7a5be4e25767938c611d6df3c14e3f532d9222a6fa95c6e933ca15f4d4bfcdb79617596aa3cd9d884f270435e22cf1eafcc317d7abccebf8b53a920f6b55e28c1649e3eceb99cc1ca5a5a6f9bbd2e905ee269c59feae94bb4c929f7af9330ca862bbadf5b73bcd22015d4af656788d1d0f881ee3911de11323a766d8159cbb781dbc27bb1d7ed989dfcf6445ec5d28b0914b29c927433bea37401ff3311b410ff00e83c592c5e4bd3036bc004e2bb3b7f57bcddb5f5adee1b295e6661c685fb0a7ec5baa43311a4b9dfedf70f51854e66578812542e94f0cb22d9d086cf093eecb5085e14a6d5bdf248d38ccf5250d12db7d827d4a6b38ab952bef6ed04dc708df230d149e22dc3a777d2dcdd5cc42fe106f63d277ed88ef85fcc7b6d6053016181635221a79568f8bb05edf56c7aeb1a8bf8e4cd722334cb56b0a6e7e6dbf9d650516ad60f5e014610d68d8598b9b1e1aa291443edddd08643c3254ff14b986af0ba6e883fc99c2ba1f8e8f3017f3c3d9a38b2dae80bd86a75103e03e4bf3904609407f1d63e8af98b81ab7f8d2d862c0245a886f903ba25148776e6edc8eb8f01d102d4aabfd37e882d6381588fac20995279f1f6c9dcf8490cdac1d034cc01fba96d510da90e39cab499e04c6bb8f69c9fe3839b5b0ada758842e2d9fafd0a1a84d75e97d64f959037e0749db319e32287160c2489bb5451a9887aecb23eec3b6866d9b945a25f19914077218ff7ddd19031c3cdc458b7fc939c33fb4f45b7874a33c42b0f9d6ec857957a7e2ddff4c731bc2905c8fa25ad6fda5fd7508f0a28c8f38c98ffee18977e40293edb7d0a9f5282ee9a3ebfbc4d56917722a0c95d6704aac5d329c38a638f36b6ba5b5e4b215a5ddc5a7b1c6cef6b0d498b0fe3408368e58a90a082f9eadc17ca34166547cb89a2490250e9854f38a4a9aad43add1ec3e4d7f72fbb8b5c57f2bdbf8e1a883a6942f6c8ef0a3881cc93b016ad2fff17a76231188a79ca421fe7da8822615d6b334b1ef3b5f470839b648be1ba2d183ccaa1857d543b9914feeb75da37c0d88f156ad0ecc390f2c810578b91981b208ab895de2afd4800f2f60e9d89ae3d13a73ff2d5c3fe768a322e29887fef3dc4bd8f5bfbdc78e1242fe759aba25efd0fcdea4accdcfbb158857e69cfc7fa438c11511597594e3c9913120df390ed6a5e3aca265858bbf7feba67b3406571a8da23977703fc44ed0423a6a8fb1da6fa0b19d45a4b0a20e52b35373200d1c3967d0e55e2a29179dadf40eae1d3444792415563316f11fe8ceb816c630d41ba0312862d57e9d711bc1bcc63cd1c4da5e81643db1b3908d2e00f9b4e999d896b401d016391a05a7eaa6c567b7de133423b747a551d2dba34520eaa099db9f4120b715f5b36fe29b9d9429944c2ee6f45bcfff4c4a6a31d45c78b9232f4dd09bb9f4eab1fc2077bae852e916546e6fc5f02fbf5794b9b2e3bbdf211c10c3883ca1861aee09104694d77253c89e82f3c0c0824aeb5927d0e174dc167033b2aa52727468e797c20c5648971a9572b14b6d4617303e3d9d54c7a24e1c61b240d244a89bfdd397ab109df8225884307f899adbc84436b08b2b426f5173eec8b38b1b4f25fd5efe858db673576ddd1c23bc93389ae8947efb1a1a94bbd0844707f77c1a152dde68f29f92156e60da681bb1b6e386704d2fc6d0af70f95296a9764200a787ffcfd6351f23897e475ad7746cb7b237a1437a8f83228f0e8ee0fcf12b3758c7ce9f955e4ee1647bd8a887ebfa9e9f8caabfcb114e7d5fa7ad91f89e0157446359e3d2d25699a5916053ae36efee038746abcc1bfb00f0aa689a84a391fd84b656a119eb390cf9cb15a4097de92d9e602ded77e1233335e79ea38dc96803a8e1211bcbf5ef2d6f08a5a5e2ab853f4d80f5452c0cb1ba690194ecee8c467798b4d81d7c5c94dbda4edb4bd68c1c79a2ba68a1f69eca39b62e1f6c72d55adc3c7e8505a83f3cf51b1ababd85b23bb4b5b95ee9451cd7281a2384da9e5224b1360dfcfc06fc6b8c26c3ae1e036548eeb719682bb07d20f686f5824835eb3fb9d92759958746973812e3daea7f3fc81496fdd0be74d36abf50f6c47f6f036118628908485b3c871069fcdb4ce947105b78c9be4e53e322aac021116a5070651bfa6966d12a0c7b40da4ef7ddc87a291b78c602c20346957d2aad5811c53d65a2287dc7e07853a4e59c4f06cd4ab6dcaeb453fe531ab9c9fc5ff2134c1879152089b8c8f0d26493213f410f236ef46fb2b9bdc3c80fd1fe49c663313dc783d2901e444e57deea7611c7ef625793419c5d5055b207e436fff023ed043ae08d4ba84e1e63d7c19eb2b058b963d7221c8bfa752d5de2a5e258511b94f2bbf407360bb32f86607f708727054897865544b2585e2c37edaba80dee899c4b43fe049fbaeb057cd66b01786cae55830a6a870781f90d050af580eb262585b9228f07aee34f537512254de4e09d818db48936e12bb3385c4f6ffb6df351242927062c2e5b1d9cdd4010b5c5bbe8ff1bf0dd4483aea1f9a0afc98c4311f54a4e6d2b708f2d9cf41d3f279d32c107e6e1ce6f28cbbf4b2084f206710e6483b685d97b71cf30a86ba91b37dc0959e1e09984567884c652532cf29b4df6ac2c2c645af84f4977727944bb157ae07cc737fe5f9223fb627cdfd13b881d52c7141e6a06693b6df0ed3ac35ddf6b8a7ea5d976aaa4b04d3f3868d2921e9aaebc24ab2a63f6ecd2209f0ba8c4f86145973783e82a72548bd08f840f5f22abde73e291ad1ee05d4a122833e0387c5dfb6f41d4b16dbf662453bf5c00cb36fc24cebd0e5ea7fcc7d8247f1d022654c6cd210d68ae2638030bd875a8b004a06fdc455fb7c8094ce61845f5ca4b72ed02afd1c8e83d866611b8709ff06a0a3aac428c032bc0b5e52f544ca75b21adfdfb84ba737d2a1b83f923878dfabe","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
