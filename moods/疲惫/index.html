<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2428d31adcff0aa59691f51cb93b5d765dd699c1b5145a2e23fbb34b40a2822a5bcdbea54564bbd9dacc5c2274b6367018b0a553cf88356e5594837480d1e78f961fdc5b3401f38874dfa4b3c96993bc6817f31a4fd57d2ed28b9ca34492d49780e9b836f9da3bfe7c6c65a9cb28a1fa40757714e0626b042c723638dcab864823826923722a4fd9d0e22083806d731fefeb0cebd8a2ed145026895fdbe8b082509fef88a64fe0b5064e28dc914c3bb5044a89ea719c0118d41a3fafff8fbf7ed0166c70f300cf4d890af023445212c0a96342f0f71074113a6d42e5a785cec0e44cb6b1efafede1e88582dd443d8056c2fc28191936432900b7e36593d4e8fcca6f69a1eaa2611bd6fd6c2961a3890caa781e3d4dc6740187b121d829d37649e07c1d50c94a034a98b32d67e24e7b6845dd33c3fc2ef71ded072144f72c20624524dba4f8f7ea86d15a9f89c62440070f11b0bc54165ad480eedef4b4cd326dce646ba8adaabfb7431617c0b4966772edb71c0effceda8d14b2e914b6a381a02aa76673e68565814c9b18d4fed5849ed7f4f5dd9f0d98bdd191bd377c7ec8f5cb5be444f9f1ae45817925622df98b4b99daec4b67c76fe8ca493aa732420ebb72020fe92dd423702d3f89be15775193f960cfeedd13ec518b2738dea751c5d21c43fba7d4ab916f5be81ce4b8d228a92b18110ff7bf0c44c2cf252e5cc651ef8177762c7c1bf442d495024423ade7d9bb87a9ed86423927d154bd720ddcb8f958c3e27927884e1d671938770918bf72a003d78cfb1d8d7ea43b29954dc501b2e2782af325a52d15bb0fd2b934433b77285dd9c9d1439eb0a8de325ac821d1742afd8ad5e852b17fd1f47cb47d78aaae677ad13013654a795ba8c2409479e8d6d7077f894b50ca0af79c2f83cf2614e35219850af041dee30d3099e218058fc3dd88a7624f0efea1b00b5f16638eea330b359c68d276756cdf7f4c92e33037beeb78dffe0cdf2923d42f6629d996d4614b01a86c09a357bd4e16c30fe9f2ef82f2aafa22165920be5a38fa5f53096c80440ba81decff3eef7dcb04d559b740e865e68ec5a746be486649227501073ca89353afdd6c5a70e846ab6e36ae25d115b1dc482b2e4a7b973a964c40a3d7d5ce0c043a9d3ae0d880d3b4f750f92651173ef214452d1cbb9ffb4a1a3d1c0b4ec42b85bee8fb8bac904eb441d157e82a240cf8fdb8e3889701946d53b50d4100ee83eb43cd73cd37247ab4c5a788267fea112c2ebc61b2a9bef161ebe3d93d59a87f9c17d42760e1d76dc646057d38058b133ada36ca02f2f7733dd9fa8bec4c60490b9704f3ded207d84d9793d34259825360ee4b8d628bc8f95e8cb688d727b6e1d9b045f3498e1838a9a329ec35b90e05140561cee6767235741c1a355f171ba0a4a4aa491f7a1b1dc5ad64facad7f950c1fbc1da293a76f111d9d2f2a314c6198fde0038ab4aa2b16168ca9d3a4374197eebbd178d4715d6a53f5507aec31c3b251f3ac8f3dd7c712d051ee12c9423aeaf8f54d84e3981b0869fcc6fddd1a93c11c033377d8f38269512b3786ea4ab197cdb1bbbe6cd0297ebcc5ee99fe0a8baf189713cc00d5273ffab95ef5ebd436d15f0e92c5b7395d14183a6717ed67653905dccb56c46afb5fb9606fd4183724c6462ca2c2a429f5b09644f4365f91d5e28e3eb66e559af4c177520184bb0ee0b1d14244a52f2200741047d705e322c4fffa8da5cd3232b55d330ba890c7f5d9f5124e0ee36e5084d33aade8bd7e86f3ce7343ec4d982be7b1e4fb40a3b6477c8801a6b4427e0f47aa8aedde88ab9e930180024bb66d61ba3fa850f3e8ebf3a4d582f2b76b168883a0ff7fbc22c8635d0109bb5e9bbd8f707b67a1406302a4c9e110d2a6ae2310c72788aa38b93e16548cd8c0ce6b053f1c20a043f13a8b1dcae4768cddb0484453693ce5af7cbab1357981d4c17856ad88578b1d4ff02faf90a3201cec170b3bad9833b38b7919aca967e49e0991215dc6fff1b03d8c9ec1e728782867ec997d933e1241a599b8d40d078096db502aec212aee3c704dee3c0bcad44acc31eac5fb82f8ff879290fb7447581724f5adf62fb07ff6fb3a76a0cd5a2f6df99fba6422499559979dc5fd80ed987526d4cadbc97b6820d488b307794cb25ec822c77fc0616c22b1fc5acbcae6a906ff3baaa1de92929a273d32eb1eb3a839b26a03359cc64fb78d45b334927fe49cdac2a47bbf95b9f50f3efc736e6a1f7801b0ded38d01ebd6e10cddc57b295fe1c6c29ed6b75478c1dff0ffe691e00aaa987cc1264a5ee9450fedc86a9579b7ea30097913bd2e519e5e3ead6db9d8348e07661b0885285892bdf91888fceba3f2bfd56835b5c23f0a00470abac96ce896e015ec9f9364137739f3c7d846c2f71554307e47bf99a8efc60a340997d7845dcac3f2ae15e1a175d5b2a9f1b62c990c476ec895adb81f9abeb5a515c42e00668e333d7d09811c71c48fa536e418ca210db237456bab122921aa348ba603eba15b39789a0260d4753c99f510c41dd75b2be8b48d8265b7723241a0ac3f294a29bcc2e8dccb6ba4e3bab01d4eba151ddbc73fb332e5f159d3d351c3d075cff8794cc66173f792bf35445df3376f120bbb24d8091c257ba2d486aa1386204047e3fee25c3ca19e124906e45055f8485a331423098c37c6fdf09fd82bd3f1279c3d7efe73b6544231608ceea9e1f697e4e7355ba4d3bddd6fb4f849e223e8dcf6a56cff93c91c722c34f0574b9324bf7cf96738dd4e468692f25177b965a73f3ddb1ed4a884005cd523b6d2b478b8331a9020cbfed0e5e164a0c5fd7f8d14964d1629d163c8b91d9f86986476fb672bb7098235e12759b9468648784f40c2a982a80b8b7ff1944bff4571a6dbc09e83aa6621f98aaddacc05b59327eff600af4042e426ad83c2af6f8aa39f4ae1c2c515499a307eebb7b510726926c04a7209484def6f9b4cd70b8dbc147d28d132259ad185dafeb1522d61d80edc9327a5c81549581f87777e92c7237ae0e66a264ff1459cb0d40d6e4d56803e072f8863c195cde96bf9bb450d72673fabac5f1cf30829d29a27c9df0bdd68390ea49e15e209df9224b93c16957738f7c443e4bd8025e17575520dd962183dd19a6c4cb07c6390efb1c3e58233026503bb24c9ebe9eaa38f63329ca2013337bd51ebca64861482e29a27450d589af47be4fda90abb98fa9fa5d9e9c925a4836563a7791a13d007a0b08718b785e659c5b0db925b6281c530f051e6d67eb3a60ec16a613dcdb6dde2b2ccfa3cf6a592460b6da64abd3e6c140bae01a2d4b781f222fc4e2fa7627184b9c063f175dffb7ffa0f5a67fd16814c1dc67e38abbbbd0d945282cbf1e514b7e63b81bc79275d8792c1bb4dd5ab1b7cca0ae3cdb95b147ec1236e4fd526fc10c5821bfc016529479478b3c947876926a24aaac8807e7e6afc1af7f75bc1eedebece5b6a10b1375a278bd7f7fdbcee9846c07bb64689d22926102649466dd807951b5c450ad88ef77e5807b6a4503ecbfd38d63ea84a2332816ed91d9752c671d81dae4f68061d1af59a2115f00acc06a7e16fcc24951e8824c9376c725cbe2d3088a059cb97f127b0747f8c40e15f6e9b38b62a85b165e82bb69f7df1b474c272b69b201a5aa43bfd53daef8f41d957350df79274b794dcc4e783f8ea5b69c14666f871f5ef86d7c189697a02b064a65c010d32bec147e397607f241ca1768769f4920d8b041fe61d5f927123ba93b5f4d75a29843898480874cdc6a5385aff094fcfdcb120ea4bae756fe1594e628409a8cc267bd481ff751c4a26575e0a9d37b9b3573359a101bfe663521654a47230413bcc5c13ff48b294a4b82248c8e7b54a803b45df6d753d73aac73e684a963dd549454a4fdd5fca76d009b988a00308a0e76746ee39e239e48527486417523512af8be3d1345f80b97b6398ea5274c2a87894c79be99447a50fc73d05273c6820a021ed281311b41b4d65b3e4e8941e53f946c56062e58200d3a2ef876940d63655df5edc0a224d9330b656bc3ac7244b2424aca5080271bf97b6572c6f5e89be0349cc1374a685cb3b89d45c68319599c5a1f8228e0420a96c7df288c8437e150ef59d55ce1641f9d65eba89140603a78826f72b5b3d84715a4a443e2c060d85bd2015bfbce2574c940201c2f3dcd6c6261a5f78ce7f0dec3c0c6bf8cbbf806bb6446b0910a7035dd5fbe82a79d1177d678403061d6446f2f8472c4a2307471619f3fb5141dc4296f169d380106294bb6fcc714aece3830a6fb833eb18dece7dce4d030ee4d30bd48b4178bdd937dcbf9335e34c80583cce0ecda51875234bf882cc3a58e41d7f5b6afce0bff0edd0f560caa8bc07bec1fd3a3e8249c42f519ad6f4be703c93045e920e0386f198548c0001271ee7a3e26c2259047cd891712358d598799301c195662131d8637c0bda82942e38af859f3a6e3084045d986712290e71309df1110b6f7ee44492105b5fde600b2de5aad65dc7a38ae15cc18c2bc26fe3137857bc92d36cde0321a09e0760192dc144226726729fc539722001beda58ad5304ac62ec238d24aae2cdefd82732c75c2f47f225da4d1ff926dd1044acfee44fd54f6d9701aab43af36a2f9f1dcddc2b7ad61483c0f483839231857c7e7029c61e313bb036710059ca18fb7177db2ee0ad9585e503c4066ceb98fd3b3f2f8374d303c75e93e654a865baab780b463a024e5e7d00e5b5773bc824cb672681c2dfb7633c2da0be41fbc721d989aef80b6cbb6bccccf22ab5c641649bc6e747e594092fecddcc5300e131a1e997ec727a0a764afb03bec7b7ab83fd265c2a31fce4491bbaf11dcedd30e3affb49205f1c6510737afbb176c306b29b183c0b06565b7604e2050699debbcf73fb7ceed84bcb17f751656229fe0a3d114f3368002447262ad39d73557334d184ac0676f5517a47b76b69c3dfc880f25498a408913418002fcc44a5cb8111e1a488071d0d40634a8259040b76e80199b55bcd3af39e0015a46db5528d12dfb6989e859372a51cf82d76dad06388025f69b437db60b001f7967f4091e9dea2db3fed9efb2f105b48282a50e79d89f7b4925ef75f5c480fe8f9a231e3b26426676ada40b6034122f86272c55d36211cee78be534a7268413c3d4d6cccd0400308c337fa5954516fdbc3bdb9a260e18e7c16ece65c10795fbf0885f5d80156a0adbc24f204960faf394e3312ea6c20fdf7430cc9f7b9414543c99779a4ee10fef19bebc8709c31809a0ac4a1d78111d811b8b08bc37bec2d67649fb19d88c1f042b73ce86db93ddb4b396d5d3c2bb03059f0e9755877516c0720699e98613452f5570178efed732e3051e36a85da9a28bab07bf57634739b5d32e7a835df042bb231866893c4240436d5554376db422f9fe01dadc325d3a3258c850a915cc2bf997564ed0a101f5348d7dbe74ca92ad52b369cab1afd00e358d7a29b9f3e1c45b6a826eb5f086ece137dd0fd69205d258a1d0c5bff79a5bd7587081c65642b4fd060c02d1db575db2e4ada459160deb0be8fa2ee972d98fbd72fd816abc9a8f0474f7dc20643ef876f1687987def1ac87e037ae67b92850643a1f3782fca19637222c09607e2fdef615af1b3e754698d7b7d7106d190de91e0c0e6719b8f9775b3e0c770b25e5d3d3efc1847921b4009530fe67fa4589732fff86cd180574c6ca7cf6ca2cda0ff3d75eb4af456873c22f509f1472b59ca81c51ec864b60134982189661eff8f1a4d9bfff2f79864fb63b2cdfb2658a691f45295e07e6751230d4e4c4650d99c379ba7d251f0a033c60a6457d1147e36f9c273d7c8dcbb1cd26785c2bb612ce585b3b2acf4dc0bdb82a9ddb832307a85b411727e0a14bff24713499416dbdb14013d481b61b2caa252aa7d122a3d5d3f878e0ba2157aedd120aa7b4ea12086b463beb1ae5b5fa50624f7d2368d81d360d2b98f51aed23769d51dd7454ad288c25a51b0a5a151dff3a136e06d3fd1a685f8dd28b67030d2543221ccadc7ce3e170e232bc9b520997065dca03b26056bb5dc5a6d2d6fa6ea806dbfd470b0055c6cea7e0a0b32a0f8400321522932311580a18ff4731ecb007d447e693c22a1d791cfc68a0cb52dc89db98429aad15d5ba28bed37f5e8b96057c0338d280b9333a202718090b94963820c2b0c8942b68faab75d5f1183bc1d5c63b10c575d867cc2340ebd58847f06952430d02086fc3dc9f6797d51ea17b76903a1b927c6a411159e3c3c2707d706a460e2912707ab4daf2aa6946c8a0a81adf10728e81fdf95874e95836253ac1edcfb3f24495bd0dc8e175cdf4c197f9ab09c3003bc9f3de5fb71aa511dc2daabc0365c7a9f96398b008de773ba06020935f7e380aa5a1b7aa05e3261e27b018a977f66576026e5aeb0813630e9966e536cec8cbe8cd4d7563f819d75b8ac93a14966ae15428da35a902b260718e28dc5f1cad42876b8a85e4907f0aeefbf401529c5603057912f5873a6655738e441d3b3557b64b294a418329b86e5813fb295a6c6632a92d6f962359fe1392aadd54d4846d25ae7b0be679fcc57f6ab0e088943bc08bc54ee24ab6079314f36ef000f6f318516a37c3fb0d3458788f3a3d951eeaf82a296139862d9859842aea98da2bb7d9a46f452f4cebc1509bf3d6722e2924c51aa7aee256edd3db7dae5d5574449c54d7a4033555a1fc37c3c9baf038bb2bd03a2ea5ae0ab7c2ec0343db0fb11094d208433f09e19f9a4271e91429782d4fe01d54b9ad90e9b72264a521b5248b5b672a47c0acb05bd989455b1d02f43ac20e90c476242e66090633be631801f140e519c11801f56fb18a57a9687b9d04ba1f57363fcfc807ab074f314e0e870c05679491dad02ce2b6e128170092644518683b41033942b0386b9ea8c38aae09d3bdee13f810a1b5483e0a5defe0f9841ca43b51eb757ee697900f9cecc5070b0a53630acfc5c281c48387ca71af8cb3100be7ae04f9e76d1c5b9b215d001f6cde346332b09fedf78a68c5c689f14205419afffd2e2d5c6390af0d31f42511dcb81bebb2c9a493ff042f9a85341d6870c312ead842a9f4a3701309b0b1e754f5627ea3855662460e90f04016ebc427a79250a8eb9d0b375364c32e67e2352698ef616f82ad1422bc7165d19a1d1f86582505afd49f5178f2e94caa8e5d181840f7fec3c085f001f62a7d2d9475578d963df02a2ced975c9805e12d0c28b212b5439293cfc00fe78d94fcf3415e8dee28db178f968e8c14087ca0e5b87151e43ef2c46e54f5bc273b77a63e7b969143cac1009aa187bc93ee8e94b308d8c6ea0724c9e45fe8e403dbcddbb424601af21498f8e6e73308016e54eebdfac26c1850a1e8d61c5347072609c7b3a4d69b5a891c125592ef15d31a99e0f0445be8a426c5d58fb50e820456052762847bd4574a4d10d8d260ffe270eaa63912ee1850344d27e95560ad0405b73b72813d986090dd97a91ed16713d7bdd9955e60c35a39535a2c8ddc4cef1cf306983de68d94543fb2014ddf0a62743c4e1f7c62d977ace31630ea43b720ec775a6dee7e77a8b7eee3eec2b132a80bc227c545daa144a8b780db79bddb94f413895402439c40f41ead12c84ad438ccf89da69c609befb63edb3b5aae2d6c7495353fbb901d85c395705ce84e16812490a8e35799e572b2232b9f7f142ee33e6c9d4cc991ebff5cd9218a7a0c95705a158a27176a8db7ef89ff7e602920be57ceb9d8377d7072abe84d6fd90a0d28206822c801109dbe9b220dda39bec1c10c4e37732b8387f31eb5d5afea3ed4b0338a32d19d4f9050dc60b9ca4278c914c7c9918379fc614a0c1979c49e466a2c0c0574f72c218026491f13e788bfcfbd1e74d622df87bcdcbae50f49051fdc38859665761f33799449a334f53e29f3d4988c5b1970771377a1c0754467ae6367d358945cd061f527edc943c539975324560c256351047fde81e43a0693a26a84b9da0d32a97233fb60f4fe61d0a7ea52fa573e50f8ebc80325891e760f4cfa0a074d58671b9dd0ef08a2bdf06002d09d2d217084efb9e7c3bb4787ca46df4ce6397830a6631db3f646681e620f9fdda3c8df9627d798297621ffb85e60f0d926c208097bfaf94f6bc78a29019b39e651f63c2a6cc407f02aa7b8ea7a3829e6517728f2abc151a8225417137d2cb164bc7ab2ee8e356ae586b65b6cdb6dac2348798e309726ae539e24086f8a383da1cd8ffe268387579cd571858fc69816cd66a839096438cf92d1c879c2064dfefc17442694045226f2dab31598e56f9758b2390dbbef045ad1508ed7a05969b602bc469931c125a155b7a882ec0d102df33f17c1aaa2b0cbd3bb9c2ccca4a09f00bb1f91db0ec8314e7e41c732569dc610675fbad7d72399b87036a60c9c0b94db85745f7e768db395b43a3a1fed4bd9db0f0b685442186ef42898d0535743e58dd61ae4f5b405e22da5b0061a813ec998e613517add324dd03c022ff7d57dfec51b86b4fe6e7dea4735b025093cee35a2548c8f9a1d6f5b9e96e86a643d1a0579fea4f7c873281a9bc6fa90df77241e81c1b59c4d8dc8b9674cd009b40606d63ce1df81474064b4642c15c83720ab3c0411ac446ccbb8e1cdce985f1e9b1fcb576c6b456c01b089ec4074f8d323131e5843967f20e059340e64018da833b4056b88988345572d25d1589152798b108cf940fff18d2727286b527f4fe12ff3af0a0ae0c42cec74d0e5e1f967784e2118fb771836f1ac770c3a25632d227f2ceab681625e05430310d42658a79bbd67ae4a8d393fc108f78d190666795ef600b503da305bcb2e3ca96719683307b06e12b51863a4c59217832ddcd4295c0a03bbd378f890c197f15d508e5c05f25a8a14305af6594c3e6ce91747d940c53e4aed3fd3d24fa497ab592cba8d75c79f24d0369388f98c099f29b51554c95a9f2ab746ff75e58af7a7db0e9bd05a9905dc9385f919cedebe229d2df487bf710e3c9476e95a2a470d533e50134a3dd09207a2fad2318a0e97eafaef85772f054763f86e1f4e5981dda513adba0cc93a24f40e25cc6ae908bfc6437b4048b962c9361f9b6c3a597025797773312fb62ce1bd93927258e69382e312e075078342ae5c578dd5bc3cb41ee0b4bca359270dc70ab8a7bd9d48c5c1408881a8db1eae3422f655ca32181a0f4812b8456a04f12616f5faa1d06fc7363b593c132f8d48805fb14c2cbd7914291c227ffbe46f02cd1bd51974ec87d6747dc9f5dc9add485282043221368c344e628cf17eabe5a8ccf32330966a2b362ff6f1c3a25726fa2c722b8118275cf6dc73e394eaf432f98f6c360edd248f0c3ef1c945c1eb0ac81783b3c0e9b4057998d302402b93ef60a2b6353766cf3819714380e8b25203b84190a4281e0b7f94ac73d8168f75d6dae57fa30205040841e8936905b0c5332705f2c3655302dc052b93b8a6fd2f78ed5900d7d5e66e1696eac4c4038c03d821af30c254704052a274a93ed949dcadaac1f34843280c98b9afa51052bc0fb1d6e804f2be5da4f9be85d82afa2c8960d0ed6e2c099435a498144c061a9be3ee326006be2162ae07aa78f3ba490840f2e49ad19f4ac00a43ace583c9e425d946c007a5ced4ba4acc8374070a0790d0ead368e345a6797fc5581c42e778a408f727e68e8e8c8fc0580b1f5ab5edefb9f2eaa42f1704e9955cb20b41ea41ad3d2f1a6d7c578c2631120c40f2b0ef20d85ac460c0b3de2a4d84691f9bec47b4f8fe948da79099f122e61f9df25183481828ceae7c07be38bf3032c4294f4ea0752d83db4f69b968c4e24df7f4b418a537e536f85704f67ee8e7fb60bd95394d61c500355eaedb6ec820b29ab3fbfd9e94eba012096d314748c14e06d5d1fe40171902d2384e5a2e35cc8bd6ec5540909baaa290dbb9e38f998e9432260bda73f79d8def9aa77e20fe84155a0b23de98df80b6b38698a72b7406d91104917bd8de6868b8cbc64b1fe0bc78badf32e9502ac89575ddc568bb6b5214ac2b9d600e9926e9518b3dfdc5b5699a5b8e05d2d9b96ff7bb8c3b916a6f0b08a576ce30350b089ba200b665f2be32ea8828db1375f9ce284ca12e3a306f81f9e4f6209f89b594709153ff432ff78bbaf378daf62359f174cdeef3c7ac4c26535350ffc2f77edd3cd7fa28d63f4c973e8a6710c3df3a505c0c7872dd3eac443713168b286a226137a817af787c4bb5ec123959d09d397cb6fea5d500ba3e7ad0bf02930668ca339ca37fd50fb4459a73dd1f1069dd8966333feae678942666e0cdb9a99526f97d527710508172af5f81e74e15cb779031823b9cd957371bd88349afef421af6cfc5eb9a1aef4e661ef66113230e130eaecd451c2c6752d41300b3afc258833d2ef050441f9f040f3a761254cce2c494839c8e15d3fcda0b8efa32a3adcee3e976e15edf750dcaead422f55b2df14f1964a7d50d8b92b523ecb0c6cd13e61ff6958724439b08df531b9868e54434ea294006f18913a160159f0ef3be8e169b7a3463a2582b4e7eef8a4caed66de17ae35efec195a35ba2dee710794ac1e76bea7d3889729ccf1f9eb0222ed8d37ebfb51e2b5ddba3212fcc4e89f8653145f7b4f6945b49e72a24390223007d846ed357632f4fce49cd80fa67e3a5be6d006f1d4eff3b0387907f716fc0733c3ceee3b0cd128426dc0783c85c378cd706a630e09e73695513dbbaf93876ad490ebe195c53116e06b24d27b094905f1c618cd8b4c526063f0d03b1e31aaf19d6aaa79a99128041b199b5b86d8dc148fa52158f3b115e9b4c7f7bc5f73e921ddc893562ba330ece886f281a589ca1b7aa936386822a2b1741cf532b33969ee165de755d53298ac58725ed23d22c99abe07c3549339ecebaa106c843474380190b05969f0007b7c25db483484e1374431398b751ea8bdd874af2468a56fdfc81376ab43cd744f873a2c244566e71d627d2b43c88bb22393ee43de78abd96df250d4b420180a9ae731d1d5b24550525de44b3401a6aec6bd202b6cc86785ae02509857b470391a02895d9dea2edf61e7a39b5999cc277f4c880eee29811eb397c58d8f8cd26d003312875dc25d252b3f92a0e281aa0ae94232e52fc4a6dd7a2bb2d18d10310cd886852813088a373386fb598c9bd47ce7db8a884a040ba8333857d647943e343125c0fc674b3767e63a4b5ec5a47ded327844108255dd4ad943fbd261f7412212cbe63457ca28caf175912755046ae729fdca47beb947bb88b8b6c3faf7fc9e0fcf9b8d37021092c32769c3fe599015999d7baa01a030cf1bf62c9708fd83792e8660458ed1e9d44bb38a27d96cb9c2a8074b66294602f47f0cb1323fc8c488171e4e00f2ae60ba4a9db217cfff045bad531545d9e6cd3a07d51c04c9d76cb9e3da0b07cd13f2222269613037771c9cead40bbb6b30095113f2127e819e49baccac8c2b305d2ee934807d31319b141775901096018c0ae25b43db348c20e2fe81b40243c2907776506ca711c6b55bc69e671bd2b2ea52b3317a390b63aa84dac0b33fd609fa289771db1ab096e0170f5eb0cc1d4d33e7e8e3d706d37e033490f7e253ab9a6b36f9c67530e93011c21369ef64b0b890a34d3c1bc8017def79e8084140664d5696d15aef1b1bf98c3bcae39551f04fe220074fec64a385ef6b67ae7af2a07e25de4e592f8eb2eecc085b93aabd96d16d15b93182f0263997c1a26df1d06f556423680c9fb70741bb341385c2deb7876ab1837ceb900d08c8925ab364f2af3b75bf70e7acff0c76c954379d0d83e9b7d679993d82ee55910dcaef50b31978a672673f713d181e2fe4ce74108e2829ad19691d39ac270181a76310745a17dfe98c4d14e703d0fb4674489caccd27be513a3ed899910efdd8ca259224c936196c21cb9e0885b16eb701b9be1ca8d0d9ad37cbe122dd7aabc91e4a14ceb54c0e7cabdbbb66682580e4a1fbabdc22b1726523bc768b9263a22867dd78f37039a092c8d6a996aee01ee2c46686095db48e6fbc43fa0a018a691e488630022b32092f759b4d2ac524dc3b670ad04801504c0e285b8a6a76fcf56f13364fa37258ba77d80024b8352f49bc7ec410e4a1471bc60cdd5ddf548c7ae4eb83b6311422baffc1251d014ad8f753a5ecf96fdcd0ece539cde23deb0dfce77f6d3da5511cd6d5da46b3f37ae38b33698fedacff5468e23e221daae6ceea045af7481756307a7ba3823f07ed4a5d302f95abb21c3cf8e37f5a6bc3fcf007cc1294eeae22a5a34d0ba91586576162b64abdf8ad49bf8881524906d112855bbc1c760c698a768c2796151cbe2a7726580096e6affe05a4a560b56de824c62bff5e687b64b972d1eaaa4b9212815ec50075d815b88d2a5195e4843d2342332b1f743a32f2dd199c01ef5a51ce8dc0f17166f9cb368c9a6c9c9de7b15b36773a02e0702db6f8a21f37c7de8204b9b4e7169ed209f5f8592d0ca75daa66fa79a171e8aa688c50207b885396225d51af52d23b3b6e260c407acfbf5591eecd76f8e43d66d4caa73e2eb5cd0425a0515ce92af5aab978799eb9821c81ea59453924678a7e9ac33d48907429df9e39b7dfca7e11421e88ea2474e9c90c93a274a02f468c0ac7a022ce1dccc3a377b063920c94b24d9e98acce3a60c93efa99ab668165f97819e4ed06080d44a4a699cc358fab01338e6eeb160c6b06323420c904aea1b0e46a547b10248013ccad1510932e675fab024584b7503802d6b5edebcddb3f03653a743eb3d363a9ba2b0f996d6bd08e48c167fae3f7fbe1865bdac6a7c93ad0209992d9f5411301a7eac6724b746634e1f5b25b607579452786970e0bf9b4b83c5651727ea04887d2874cb70bbfe8564121e43041c1d17a71c93c9a5265c717da14d14e7022f79b76412719fc581be02d8e7e171c6ee716356db8361029a9d307a2a00e37dd4f7c55bdbf7002b255b5df56e733af1a74d895bf68c9bd06393f9546e033413307d113a754f633624f87f1649a4c18e4dd60dff898b94668109e995ad195938a2dd01c14aea16890445c0c333cdb3b9c1caaac4bcf4d1f0e4aa3bd2db2eacac528dd363e0601c458927b5c190c6a38a55f367608f3326e5266c75f9053ec266462d946fec046f964fba207d74db094ff92c43b638f75391024fe8d55eb04b5c0ecc1f0fd8c66f5dd99f08e2e6020180c32fec313be440dabeb0ad93e14561c330871473d97094db621ceb0c4efeb636feae69a16a3ffd0843410536fdc6af56a255c0a79d3228b33da3a3f5fa6bee84e762a1450ee1dfe4578d618daef07e7f56ba4dca61e961b7ec4f04a9c991af3dac24e7ca91537bb3b85553c81afb42041727320706a8702d6ecb8138f1408e40bb9c3c00078455ba7b928510381c5f11e7033e912056069031dce35166668f218467d9e87c5335a8355b188b8019df1f5007271a9dbfe635db8a926739106e44b2ae5eefb2eb86602b4cb7bce3ab7c1da9bcde54598f4a8a58258c66be88db14a1b758f9d6fed33bc830ade820805d236fc1ca7891c5f95d37a848231c55f9fb94c623cb9d49b97cfbd26b6be833b3480175fe1fbf41bde06ebe884232b79481421a433e34bc5870d9fdade44198d722a3ee0c1a7923999a94c4a9160f020c294cfb0c08ebf9c9bbb4f439c2ca18162dbe3b622211d0978de47241930fcb78c62fd8892bd6a477e70a78f0260c5b40aece6d682a84b6fd8e0abf5514333352cb1a6144f41cb313159b35d718ce32ecbaee894bcd2af7f89c228728e6d7a986f919add6b4555386eaf4748239eaec40ab998f71635eb4b4c8e12fb5689d17dddfc4b846818b76b05df8bf7e897c78df34a89097979c86e0347f302080ad2d328bf4758ac6fca6ce32036e3cf1aeb4c4893f83556bd8046c01dab2eb77ceabc068d7c70c7ffff942151521718de9a05e166d8bb821cc6491c43d74fe80b4b46ae103c0eda76761f8f70132917a09dd20f89906c645f5f67fab004a4fbc8b17054a79714377283bab71d3dd5f476e73620bff710c33f44ecd44c49ff5e37fa5a056fcfd1304238db9c5aeaf10d6bc7cc7d6bca49481c52afde470b6058fb2a0616e7cb2b3a00eb4920000a29160965b46a27b094fa6cfaab2f2078a8a32e67e05d2a8aa316870e40c99578a20b810764e495f7ae6dce51dd42a2ee424f4085637d9eb19e950f0a7d96ea36e6ecb666c122a83633d4718b6ef3a9aac69521ee9cb3c0ccb721b82f2dffa1a5ffa8a3048d5f376501848acacee8ae3f1b5bdb67faee2fdff832ab102411b7bf1c99360d8ae67da4056400b727c80d12f8505637c66d2b32eb4d3f083a287f3472f9c775c4eb17dbb0a93d93b660b5087ee28d85c6858821aab2e13567f1c2c711f62d1eea31a6e6d1364ad9b8d64fb0be421eb36f22a32cced50dd31881d124b0360a7103ffd140ef52e48c42dddd12e0fe3ad91ff63a2797814108ae950fb0694cafff6e3e0f925a7b843c0383cc6dfb70d053aa9c8dbc257d79e4cbfcd1d53eb2943e1b0f0dbe2d59f3fcbde526997e016f9607bf90deac045bfa256e01819a079661755aaae04b173adc08eb28762db9e933153fbf85ef0701baed3b4073d9cb92c799fb133b2ce3abd1bbbd57853df3918948143a21be3856f5ef01075f49dd2d950619d40295b4d8bffbd134c664b9e1182d6c86aee7ea293b665db767a27c4f4f0583d47ecb186a363dcf42b3babe4e4e0df8463afbe016f8c772171c0ab6d31d34934f8d39777aa1f5efcee7aefdbabf4009b3b91624876a2749a93ca6c6e55086f33b1ba6ad56cd77843a8a0888ff5846e5ef02a711e4b36f2c4e718f9ce9dfcb27fea1b5047bb57a7daad2e91b5f06a793425e8e452ec8f42400c4b31928dc20b03da1e8036e1166a52518a713b1ec919eecfcc26f2058c8422d652dc039868ba93aa7a85d193caad31226f9540a81084ab1f3f50a691f16c1748fc0d3c26e4c3286cf20ea5a02ebfe6709e94384637569f00eae5efffdcd6c5a1b427e947a16813d1e3cfe7d1641044cdf674c5e17a94745cf91bd0c218efbe346661bcb1ad8259105f1b984c2df3c190bf6759bdb3b0a385dfa1cb9ac4048304dcbc4b342e3cf238d2b963cf6cc7233a422de84d13942e481fe3d22168d91eab6b4be7ff3e1cc06a12644f30eb8c2373216c5106d5eb6cf0ea6877f08f2463cc5f83fff400999c3309378968f6d673c0bbbfdd55866a3d2e0398630e5b388d9b95f9822192caa3cd7289a24df03a706aa11f2f2850608d37cefd548c68e7e8eae25932259f5870072b20a3864e082bc14cc048609e92f58b7343f888a372cb4b0bcbdd505db9b6a6dc2f5ba41648007846bc44bf8bdfee6d3a9e05340ec038ed2148c97e63397b2fe24acaffdb1d60e7b32832420b443e877133b9772f0e6f7c45904bb4823a7c590050cf4835aaaea316d6a1c2a50af6df7932cde24d43e8db3d59075711e744821a128c5f46300795bddda165d82583c185b9f450369d8c83c77dd48d7c6fadfb33a978d05bc929933aff2a271b53a0fc612fc0923dcdd2bc6af74e8381805d409b782e780fe4ad5ba61901dd0b29da17cc045906e9af02d8dea88cf79214a847ea3d25b0d0feb885ae56aefe20cf4464e846967e11bc4d02251ad89f0aac89ebf7128e09f2e1e25367b047772d74db1ad15784ee02e81ba909dacc8d230a9528df8bd1afe5c0bf60bf873e2cf48e9e8dfb5c8747e92dd549bec7cbf2ddf33f4167b229317102d240c0946b45f143cbe09fcd92ffb9a4b10b95d59b30f4a843a4267889835331562ccfc3d599d67bd2f663bba78831a1940fdeabba9907c27b4964e63837d174ebc928df66863327de0453b0308232f64402b10b474dff1e19ad874b9362ca596257f2b0542745cce4adf1478ef31acfe14c4eb0c54b25fb78a7f61dd50ee61932ebd2cf563e492ee3580165dfe4618f17fc920acfc4b890c691382b67843e9972887ad12897b70dbc1aea98fe7e6dd20055231fd752e908f5943b313eb5c8975499d0e66f3263b8bc330c80a1f36b70ff0c4623190fe2d5ea104c8d5bea22a979063e8d20f7c8e9a200806dc67332feaf5720d7154923d4aef6d1c1cb22fd72730a8655b23fba9bc002f3b191561430e4b82e764f43d005eebc69c5b9ca946f26c53e5939719a2996691c191402ce973299d5f1daef969f2fd28655b887a73a9a1547936797e484c832a561fa1710a90d8d0613db1fe37a4fbbc3267194e86d0d3bef5bfeb2153bbf6db070fe2714f3ea3f86ba94416bbd77c1956e2d6d21ebdbf4d24e38f1ec09af359fd7b3a92d3b238facedb90c66b035ff1b61202feaa862a69b667886a3d0b80d01d85362db13d06c8196dd187c12057093d168e07ab62606e77cff803ba9e810c4d7d947ee7b50c8c7f3508f40657eb8ec6de77d0ab245f6d8021d498e9c3fe7b0f2997f6745d08c25f0424d01489b0ce82312ade783b718f3e45f74c4f0673126b92b0477da646d0672040e99beb18067711437bf0a9f8653f6bf8a48cc45217a1dff825add703e6d7626b3d42881ca6f0176c199af9e70c337763b2f8aa8a0b49fef1c08ed0541358316bbbec05166a9d7dbeb7f2b45c4f8c33cb77e80ab333c7bd42ed3b26f5be9a721d6d5b75e46a48f3d62e6a270de5a84917d1d4bc5825f60a849d4da8bf89c5548d0ab5fd625008481017a783aafeb8260a9839becfec0af8ef08905b65e08ffe7aa5391f83f0d959b90a4ae87fca5d6dab749e98e421b709192b3fcacea751d052c01365aaa9f9e78d4c4fec4de3dc3723e738ffff87f4aa77d767fef4835edbfa50c3ba296acbb267281f6c69b44512e0e31e65cda294932dcd25c9d4f6a9f3820517bb58aea49524bf2b35744dad8ba59114822601fa0eab5ff345496fea38d5da91127929a2295dfe81afefe94d5ae04ea9a41145c188644a9e2c0b01cd4298153391e91c696583c0fcae6dc86d24153eaf80e7712678ed018edff1fd10309d123de718dc4e8754ec197003e94ffed0b9aebaf80363124b23a901e56d9b74edde6a4aa7c7fcd420a5845aaf14048ac26fe27b2cccd6b2239071bedb23a467d3464bafb3ec57a72e892366fb999a74f2aa3419f4c474a10ab3cedcdce52793d8ba425ce275210491988b7298d3f8e73aeae7d086f3af9907f1513d17ee0eb576c7c636c5f75ab76ad13e207fcaafcaa201619dd76f98763bc68b2e6bb118026f6aa9412e78f62ab9fddf122fdb7212667fbc97307c5899dc4fb42a913518a304d0a341e1609388fa5e5c42f382c1e2855081aca0a69bb7d6e6e2bfd55e599bce2b8a32b233f365b99a2c34b11b99a7df9c67ee42c5d84be20f1418124981920f4ed86fd842ac847146a949e7f64f2b681a097c4577cfdb29b6b10cabd54fdde4ed42585720e338080eaed26d1f44703a4f67d4134679d9be9f6e3543141ca2b607a928f6c3a64a22abb434130bd0a9c3bb3a88adfca0babb3f91000ccd39684e7b0ef86f8f2251664aa190d612df3c901d1179d52c142c0769b2ac8618dea14e5c4cd1f61b5728df0cc0b83bef73084f73dc3b8e7b367be21573fe9013fbc702fc5dcaa7fd705d30ce6f5e4ac76f81b75a0ee31e7bf03ea20d4f7fcbbefd384da6fcc2b8db702be31480051688b4cc1444cd23190e6eba831de7840ebbd25818f9f3447d823eebe28c48bff8256d03b9a4094c05407057a3fd34aa9038ea4be33014ccb42895f2712591a010b9e7b0014e1192a0f7a8cec694c5e9fd63d7c50b0a33f96a65fc919cb3e7c2429f53f840eb8cfb7df95d564bdec0ac54aadf7fef740bbc0c9bc1c990a8abb7a82ac0e3dba5d6ab5011fada937751a3c660377472158b8d6377d29a7eb1132037489fac0c16e7b9fba01c6447cefb221907349cd953e0dfdf639942fcba2f180af01614a70883cd474434f3b2eb51a0ffaa133aded908240cd8a95732085c881161295a3bcb13a44ac4fef9396a17e3fed5ce5ac45f9d626dd7421e573ae5a50fa59f113fb31b76145a07d1cb3de56c62e55a2d975297d892a1354023b0021ea96f216e2bcf1b1cfcc9f6016d95e7dd83f72e15c6165d2d64e3a53d24682cf41e10d7ef144d49ec0f68c0cd40b35da366d136cda7465f7e31ba43ff516713190abcf8d7f806028e612e45bf1670f877195672fd00fd459f5c597a9a53422bec68035959cde0f8f21584f873ee181c0af00ae3c705be1f4b514e23a3e970e3b856754de30a525015d5b42a358832701b41d6b06891e05d3cef27d41b0968100ef16630a1f05d58d3820bfbc4dc2b87aa6a2a9830371c19b4ecd61512abaf941165ab5564399813d46ae3ade507ddd54411ea7cd8a5ba662f9c14c5d2dbfaa19cd8a021c5b396e2ab1e4ed4bdc623797ba19f3392eebd74f30b48221635267d0c2c731cf49f1b2090f39af125f151bf76e8796f9ccc001ea94201f0a22adfba580ec49430f880cc5b5a2e091b1e29a078e9a76e5c35849c97cb79d86725ed79bc55a6cd555cef6192fc838e173971416424309f5082232bc30fc974b5cde4129f8a9975efe55fb123dcf2fa8466cb0240b46cbde0b62041bbb770ba2435a0be6b887c57e9ebf9fdf15c40f153eeeef7cc0075b507f8c7ace802f923d105d89f5f18aae7af5b6e456656a00bfd8107f0d0825a52dc650c051a3c2ef38a78291e9e230792adc0e8d43cee39b56fcb97b600f4a321c034da3ddae7156456e27a6a688ff123b6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
