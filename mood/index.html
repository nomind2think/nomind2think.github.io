<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f2158b633b9e72496b8e606179b468b68317ecc5c337eb0764db4ffbb965f9d5414242e0dd3e57a750fa691bb288be1bf98fb888b75af34d9679bc18cf8697ad622c180151e2254486c20bfe7d53936f279d942fb54f1ca81bbaad0c3c15a01e0b1fcfc34f159d7ab8f01c04836b7c4b5add91f19aeb17ed64b63cc416da41e99b9202ad4218058ac3f8bca444b9110247a68f622b3ff81ec2463adf573a1a556c40ea7d150d2ee5850b7db712cac7f2ed47225255fde41291929707e742b2d7f65b1455426c7c3bf597283aa0bf6b894d303be57f8b19ccba7f47bfc8976b4bc4c3fd238585be56a69aebe54a59ab793079bfdad1f5031efdf6d751c989ac50e35a51d99a147509998613b939dd66fd4926ff3057f92f60a20f29bcb69824eacdab00f9bb2a811dee9506d7cd5afd0cabdacd8e00f23b53f7371025cfc6d0f190b79fed63f6e75753c497ca6794f92b316d0e4a583bb0ad81592df417db618493a229d38314fbb636a0aa6b025d7eec8af947d55a0eb78700d31cdefadc1051fc896e997a974fcd867d9eab4eb5232b007a9cf55647fd53db4f9a9936e75bbad075a847a73fed26e439b2b07038c29f769c53ce60980f812b60ee8751ccae656e58cbc1e84d1bcbda4b5c93d74db6b1f0eca8bfc2bfd9788ad682a904cca0ca0553e965d340bd60cba8fa9a4b25ac78d9caeced1afe7a874852c138e49b31c6422c2284a169b4078786f1b4e1abdcbbd34dd686344bfc6e454224c57360a9f8a662e2944dbfe0da4b03b8a1064c5063e097af5fe3478bd8a4a2583009e13154dbf23d88af73d95c2e4891f81359b84a441447a539c278b1299ef9982a5e46d36a5103ed614036571ce60f9226d173824b29eae88f1f47e851c9d2a12f4dc1650676c14d3b62687c9b361a9366f535a99b4585fa03277290acf7c4b5d82aaf4214d9d343097d78da7ed3baaded8a30fc538742917fa43cfdead2572187a9ded4766cbaf848499fdb266cd8aff06c7af4c4ff7c829d446da2c197e171b3ef217b77fa0931e9c98f8323277cfe48b7f6e344d0a8f5cbf62ac20b556e460eb372a37af905d2cbb7291395de667b7b2b1b36d3f9d68c255776c7f35cb34750860a3ec737a04cc750c7930d9fb71ce18c1948c83b644940071d51591495d4107935e3c0538fbeb3f5fda6f7f8c0f083a3dcb790c94f218316b56bcd20e6a4f9708fd018ecfaa9b9d7025922ffac5cbe75b172675711370ec7dcc9315d7da693f34693682e5c2b1013768cd4a90b254c86584b5d97fde43710ef9c484071ceae68a3c18b03b720c12abf1d0874aa49649214a59b8b667ca9daf46168d28fecd8f92f7fc1a9b6e6fc7e8d528572a7d8bf76a47f133d0e4b0a5d33234901ba6bfc7519537b801e68cf445baf093c5394ea7fca75dd4a3847edfb8c2b972ab055bf1a2d1b4a65fb2f0880cbb968b40073b7539f4473cd866b01ad09a8f4d43ad04ea3d421c162bf93542d2078601047cb7bad07d9e78b6a80d80fb473354410f3dc5f6bb8403f9517b9b8eee31eca1874028ab762f8ca054978cf3df7f5690adffb5bc38ee6ac07b0abe4990d5d41b203dfcadeda2af2b2341fe90eb46b1ca8f46385852fc6cbbe5972a55b87b7aed795816cfddf517f5b18c87c9d3a413508ea3cf2a06dfb80b04978e279c120444533539cc6945b9901de635c758c990ce3be2cffb8b5ef0e027ffd96bdb5a575d37dd6964e3efb9f616708517c9c2f956188c3d33b6008d895a7481e0efbea6a365345eab87b2f5ca69332b0db06d942d7669772d02201b3e459b8434771c0fe7fbc468960af0a62beb8336e30d01bb0f548beaa758af34e2c208c40a7efbfb62cc001bf22e0a7515950dfe9d3057d25018d1a2bed844441c7ea394286f1cb0642379793964c03c5e79130ce19028595f225f65014f5fc09c654dd0f4a072c7389a3da015615cc42e2bb25ecd124521fdb35f905f7533b4367aa032a38e858dcefabb431d83b66a3e25ebcc8fbc0bddffa921c8135d8ef68b47eb3ee4e5c561b6d86612e31c1ad5628187397d017da5e0a09bab41bb0ace07fe204e78868328ff42673c9ddde6311ad4c216710487a20aa09166c0ceef8a052c487fc6f06c6fcbae3d11a02eaf1bcb8617d3814faec02748aaaab1ab8cfd56cbd41380efda6634ccbf245fb973409f765633c6a4a851e3629437a8e28bb6c2d0675223d0452f92ed8ffc31f133b605344f9edf332c9d10f5827cf8c72bce78400eee3161be5115a3a370aea575c805f01b9a0b0eff5358c4b1e80ae8d8355b6d847031857e647284b412ba5252fd3b7d62b8a0b74047b94a8479ace322cb2f4fd01885b94100d7798c9cd036f3512e889c841bf2f5e3e122fc443005ac2f6453e59316c4866a1e438bab9103c561d6e4a378521b5caee09656a59c94431b3f678cf99529be2109e06b443b79097ea62cf0747fb9e2b409bb489546541cdb1a838259160b60de32d2f02bfa4a4d7cc9dd3ea8fe091895e4c922a37aff73aa14466f55b7e9cf94e6e0ca95b550b74eadc56fc1446e3f3e6d54b8f94fcc3c68eb3843758f721d07d2f934a3cfa051fb0e6330fe3a65793be94493c86dd3f4ba5bb7db9a354f3e390ec34450bcaa88a12b4d382424336a665febd46d1538302be4a2a4d3f020f2a6d4b9c383c4ca216071aa471d268a8c023cd3556b0d110c20a2fb4141ef8c6d91736851920cbe99df38de9a3c3caf1975161e4a979a8613770971d2e5deeac49903a24d267e79202c6ea882606c15a12456064a997eec25ccf64e3b4664c2d1f4a5e219c959bcd53beeb940f15d12c68666e43b8ef664e8e9d224bf258f1987a958d0521bb2a3f41e8b244e7c217a16306d4f2b98d23d5fde749dd907d7dbb0072a88a93f6265cf4ef6f2aa74853f4772a4e484cff120daa6e9c95ce43bdf1093f3bff0ba2b78a24abaa885c14b716d56b46d45346071fe7d36070cfa509732e58605d5d17298efd5b6648f9450b3265872341e301d62ba9aaf060fa916ac8f9cda1b874ec9a51854235290faef77bcc67095a7dfd80581ec0d68e3a4421e4e9ff7355adce15dd073fc701db9c3d9bf9c78a915629bee606b2a142b08d68ab52e9022f795874a7cfe781b9f8914c07da5c781b83df9d1525ba572d5d2442155986da460a2fcb635a6c1bf4a81d7c79c3147932941943d3e78d4762ed82beaed48eb507791caa73ba46a374019259c327743817f949986507695f375314f192b0647466cec2df49df6cedb8ecb812a3bc6a1840b099d84dad01d2e556280eba7ae6a4ade9a96b3629c332c60e7ed4346b68119f7adbafd7fea744e38c1e707db52387f673ca6df868ec1d563d6c5d414236332ce8b81518aea9730b5cecaf99c5967b61ba04afca355a7d64daa9a76d9877ad3a1eb8bea224f19e3383711ed8a1d12bb97d3c8504f0c009f117f3618d47f12ab1fa2a797a01c992dc7bb4b3a1143b061e289c18e71e3c365fb18d087e3da3dff9110a8907ac7564b1520ae29d8df96e96234a4eea5470bbe84e9ab7aa599a5a49d06fb312906897961294b58195ebc601be3acf2088bdd8dba40f81bbe1ec72f63ee93040a5ab75a3b926b115e35da9d17125880131ee47ef97d7e30df0f7f4358c87dd86edb32887787c2ef6c5f79883a727ae1016722e1088c2a511131503846eda504dc72e5381788384bd179e4cfb799e895ca1c78a9d004f0b885961f9b901dd246f51d13ac4bb8a9f306aab7b2b6dcf6d75bca7db0f507fc27aae18ebedd1fe236f87d3ed76a77081fedcece340e333ad628e7b2be85801b2bf6df4641556fe0ffb3c5c9011c99820fb3eaa907d7149b3dd8c4e571f1f04ff2dbf7a1c842ab123d20e8726e12ca9e1f0fd63a1633a09cf6399e16e2053ac7995c0fd93ea0c394524155c20fda73a44e626fe88e2d68c71af5665d25fa084f006d05eae52c23121c66cea72601726db13264de46ee811c6cc45206f85b79c7406c270c012b477b0026719ed30a8b9d09319ab2460eb77d74b225f0dc46827ea71726d6ef89153fbb5e9f5113f1d421716731439e5eee3e7c7f007d4168f05b4ea2386ab0976b642fb99627068f6c5f7602d81cea2321513a64314cfc7b89b9c0f2516226737782e59f34820f0da01de581147357b3e60c9171f3947d7f215f681d0966a67702f0bce2e267398a1bff616030fa3d754be7bfaba3b2f09f5e66513925a54c8ff78c14d9580b8285132f29cb97d5170d3434b78adcc474ea5c2cd268da9f6b059d33e44006627ffea37c6c1bb46ad94decc800b0ee31e439a7cc5adf9433ee4814f1fcaaff61d40e08c816a54920ee0a2fc1c09367ec19cd0a79e3bb46e1b86a20fdf9b97750a9e7c1d0ed592f1040ccc14867f0597a3840a284cc155288e0ff2ceecfbedbda532abc30b4d58bdd63e6501d9943cb4acdb87f49c76484906ebb0f9aa10d017e4d21f406bae856c1fedc3909cbaa259d2f99c6e4c69744d160c34b105a6b6a50201799160a34bf8b90951751164c318df756ed2f2e49694867a3854808911d24970985e737a2041d50201c7cf72e2514faa74fef00c4e5198954305f34226657fb28418eaa346618f200b6e388f09cc494d8b60c85659f8688f8c2dcbe856616aefd684470b231af17afb1e4f85aecfb5fdb3124c4b3e5ea3bb2102732b9b5133ee7f40008abd5fcb0ebaf746b1670326b1402c734310814807696f8008b79a1da60c2bb1b8b818716edf93352574b417e85173648ef8bc10415ac6a101666991e7f08462c16b8e56e9dac90694a83411a4e9ff6af3a0b0774e44ec2d3228d47c346f8cbc5ad526419d412ef8e84c51f91f12ad8b2538406194a1a6ad5c8673c2fa8de029be50499cd885952d9cf56840b628d5033a3d5f0e06bfc363be0eb7bcc035ec0d1a506be5fd975dfb458a34ae944f1d9d5eda86434c723d61a8ce38d773ca1da2f5944e278b17a39fc25b8aafdf6ce96b6a0f667a58053633dd49683e5fd9bc46492b3e2e5ba3d825c078560a7015b662081e4e46c4017eb89bace2fc92c73f037f1d4ff00c38fbe461fa80d36f7617538ab8894510e7279c74988faa1be11d65f6da91d041f20921d63a43a5fb5f10826766b08f954f40256320af00b730264b87abd8b73cc6aaad17113c3a7d532a8ece39878e1de22f59e9511eabbffed9e74fbd1040d2d1fda4f7b01b79c59638308c59db4986e1d6f31748df3c93a971acefc94bc066b2278140daedefc630eab4e4f9308d1a67e5cffc577d153d71c5abe0275480b5f1a599d72c4317b2e61e4416a81ff4bed92b2b175c3852990fc47c3058d4e78a40d62e2daaf5b793c9e5eef663b7572d465148da14cfdb1a9acbcb2ef11c5fda27034372f2fe86c0d840304b550acae36ae1953223af792abfdfc439498d800821d4a2101024075de5b6240af307cd3678c7e975cc4b910f019b8fecc0307fd75ce8ad453bbbe281815eff36210e014e2ca72d6e04a5d1ceaf24991b5f371fdf3cd50cb3484c0bb3c8484e2ada42f0ccf9c66527cba15ade0176e3085e892c120d2c44da2929e2ef4cfc041134cde653c56281479001ee86556185513528e199efa09c82037c81b614462f69df3e13f1d6603fcc891b4871341563068664512bbb922594d9cca0941293fb9dc6b0b9bd25e1e4b4e7d5488bfa7b20bde31bf8b639d9b93cfc8ec0e52deab1809f14e414a4fb28f4cccf1b6a7684bdd71c448564c618c8cf1276a3d2dd0c07bde8235513acf8a11fece00c7fa2d3bf7fab15d2fbd8ddf1a9bdde5b18e5793770c80a3962559c7517b2b8daba761cf8cdbdfa319f2bcdbdcc0da6792d8cde2e7cf6281067374283085f3fbdad366610a1db606972f1b643418acde93a13a039f255f2cb3c50e99621256fd5c15abb77235e161486c9df0ffa82b9e4013a2adebc01ef531fa6c0c3bf8f3e5beed8a65017b70f41645b81be36936e2cd2506c1117b24d0b33abfbdf09f7aea301f59525d5e124c2c8c5ea22068edc89f316fa92087627409e18184881f0ef5b77ecea626614b63ef39f3b0b1cd7ae716931c5b509e61a398f69a7a7aebf5796b9076d408e159050017bc3f95f46601be78682aaf136b437d1d42f7894cbd93a4d7628cbf7bd399933ba28a011f07371313c8037aa277f0457a3bdc93b001df817df9607659bd52434f218cec5c426c552a8c41f2d0b0d28536969c9582516ea2139bc3db55e2db2e6c7869d3048737f191cdcc007a90f55e184737a594855e97be8ab6355e06b83dec491905ddbb3bfc3ecaa20b3c1a00e9b295445901268c585412fd59102db10c699abd1ad1767ae7df98f57a777f114a1bf15ccd6ecd33bb8dd6947971c71aed580cd757a4040e191ec265521902ef5325cdaec73de1ddb092d7604e514d1d5ce408e88c7627760b572bf520de43b16f2d525d1d4153ff46ab8be5087a1986266cf8bb3ad219cf387ff1deb42124929d0a5fbda0ddc7d0af4ee3c6706a186ac437962b9e04530b96ce6c0a5e62bfa96eed4fbf8a4c2641e59b4ca54fba3b6cc67f04a127fa45590946d92b9f68c58c3f030d9b81924251bb5df00de59a4e82af7c26a644ec5bfce9eeb51b6f725d39f0c3174fd6e436fa15c5453e3ff74cfa87ddd05605b92eec5a01d7452d70f8c7a1de3a88f7e2022da60fd83eb4811dbf2c43384467fffdd299117c37fdb41867566befadb6d5c2adfb8be5cdf9931f0d9afd659115eeb699cb80ac4ee5204e6bfa4312a9f2264ee209d3ea3994b77d9f1ceacba6517312c8cd58d1461135e335d7eb220f4e1dbb25489f90d04ce038dc8f9b23e4d05df350d636654ffd227b5d241078c358af3d8f40f976861b356076b830e0beaf9393372edf52c51bce49a930ace83d5c599a05c197fe2f6d792777dd5645681cca5d99ba81ee445a03f2f77f3dc53c646e879e58ba6ca06ced150c2a83d6e9a2459a961ce8faf93e4d7a7f3a41f8b752d832d3657e5fc0d050e652a1c3607f44c967c334026389c354f55b918f4d75a84d4a2274460c409476f55adebdeabeeb11dee2d6c3445ca97035a3f632a3b2cbf639793c0847c651fa62610c02c34a190f3e41eea1173123368133d7399203a70e683c11cf8474cf82744221de2eff79ebbbe3fb7a38909651e258946880f147f8a757b5cc44076575ab9b0c4deb58853cef941957fb385b3401716c52c1f39950bd71e984d96d7b2ce8e17aaa8bab442570351342ef6e2d013cbca5537b4302cdb2982141839d3f7d5bd4a26d890eed6ff0977dac52e5fe25e17e40f88eb8372603bdac25fd2f07665cbaf23204974be30df23eac641641ab6b126148062dcd7ee735fd8dc375de194dab6596f7361c8eb1e36c00747f88db73a36a5cb18d654e4b7af46dbe0593d3d618ab1e7b8bd8e62a352175cce6c757bc987e5b69e1630a194e79f8afb74155474a907b67ba487bccf38f39971fd2060c1324d25386a1f5c0e80eacbbc5483f68b3ae6be2055005deb8508f6bd9832675c87423e58289aa8b9ca7371732c743226cd2da9ba281dd5e6a0dd2f5c4498a5528b499e99c32cd4765dcc8ee090af940a038cdac110a61d7fc9855ba8f849e189b269aa0df27aaf766a906b779f0f76c56c465b1174238521d210132858a641572996c6c4d830535f4086ba0ad1f7d5885c5d5ce4ec05121f7d46a951389daffaaa430de1fa3f57dc6920c1ad684f16aadeff636160d255a14e5464e79f6b4b0cbd2c1bd9fdfe914198b029bd7b4a7a3dfb71ce49b95dc3793d0c3a89fdc55768f8e255d35fef879222c99c7e0c2a07bd94451b3a83208ca6e73f5c73e03d5824a16c65ad30da27b5605fc5cb4c2d0acf9dca93409c4fa0cbb0c90f61eddbe6798d56107b2a3687a7a033f365af9f204faee952f01d0eea647cc9783a9aa5b01520d28a075e7fa8046ed13771e58bc3460ce2a9657aa19a46a82afa994eef158ea2df8e587b3eea0f5de3dcf123f4ca84ed58c99bd210e1f549592571f83641fef615cf51669b3b2a793fa159961a610f44bbef3070fab21ee6db6e65bf5dfa11bcb6bfea7e9edfda5bbdfd875be3b396ebd6265e2c407dd3816a935e88af62988120e59ab6a5b7a543b2e4dde423d0613550603adb32237f835bbf44789ad8bd9ea23f4bcf6ffb7ce2e2450e4afa45689e1572ae439a56467666a0b044e72a4bab6b57e5c14fd3ecb476d9c7b1ca4dc9b2476c2c972cbd7b864aef7af98e267df76c120e83ec320e1743039b87a57e08087212843aa80a3c32efa1842cca4852013e5647911ee1c99985ef37026aadf962d48975a76315bf263c9001f3c449272caed845ccabb64934f58e6a1c726aa13fb752eb4c7161510bc356e9da90f0a7ea2810aa70a7c79c22fdeb7ab627ad22c18df5ee31c19158f8ef3d621852b17611c8a18350d1606c3e63618dfcb2c4d2562feffe7e18efc297f9b350734e4bd9958baa9c2c45ad8cb268fd54eb70bb9910050ad14ac4959e78afaca47243c201de867eff245634efd2173feca7e10dd411b24c026b731827361db488d0e084b0c57ef63856d081121dac25fd7b0d43c85eb631085a028f2c198487eff1f6394b104dfc264c97d5f40843e6b1f900f5e4e4a41b2bf2b79467c4c57be4661c2c7c55e3cc9f8d1eab7b797788395cc33a6d562a8a511132700554d929c6f1c7568faa979445ce5cb17d7a3368c8fd2783a8c5a00d88ef11bae0418ba478b77ad593688dfc05f1ef76ed5be6c1e16060a98bfbc7ca9b773f5ef291c03c67f53116aa586a3ef7aeb576db36d069f23a0114c411f3dcb2a0735d9842aec96f44469db0dcd2bd11983b4c10d4762a07ab6cee451c983fdf1d03925ad97c97e61d10f640dce5937b0ffefaa97ee6f7792cf9c89f94c0606f312486ef739f03dae0a6f464e9f138c9d8d93c8528ffda4e0a028506f6a18d1fa769fd19e6fb6dd4b7fd4d1b039153799bb8953baad266ea9cde6e4db8e0bf67778c29320d4b217389884d18002293d762e0cd0c09d394d118484a1736b0f4ab16d960d88ce53888eddc2bc19ec40b9ef74a7b60dee02218e51cb80b0f86d63de98bcad3aa9ba89ff532392b01c55b0aad661ba81c9e3c2b932f44e4fd3ea5aca17eff30491a91d5b597df0bb0f82cd4851b0e3ed49e3e7478b40e9894b0dbac1f53704ddad0025c047cf8d939801ad357019c3540f65e0f8abe1283aafdb80136ab06b2098a99167d2780f6edf25bbe34adc756115482a2a288bbca9180c3f0c7a601cd879e96cb2383977a6d7ccec8c2219e055ffc7f8983c8b5ccb6bcaaf8ff2a25a496c3db782f8f0955b53a683e860e3c086e6b7d6a17b6f238553e90062b4589a229564fd478e8b4a03bac56c513e69418da5811da90865bfb2f0be1b643a3d5fbb8454f494708f2f7ad75be0e7e9f0cd68b5de84415c2ed48a7844a461af018ae032f295176f9e24e1be0f6489bdb82fcf01b52fb9fd2e8e36ce52468ced5a004980c1ffd3a28d0ad4649b55c05031a7fb7815eecb49077721295a51fad0c6179a595c0efaaa6507ef3960b30ba9caa068a21cd06d19f4be518fcbad872dadc94ae478601fc651375e6826afad68f1b5003e7fce0d0e2a736979d53403715c23adaf73660dec075df90600558a6cf4d6807adca2bb6a394d09e7e5f079254500212101c595717ce8357484c2d4178934cea108ffc0f2b81769c628d95a3001e85aff0e0b49e9bff08884a5e9fa17cc658fbfaf75605a29e1171dcd726991070c34f5a693e1ad8adfdfb42ba49f762498889a96fc6c001e49413563b918ad4be0e0fc1b748f4cb0d6977793dc401007fe0a960d1055756bcd9f3441bec4a0374b285eb28979801c7819ee8e58f21b3d4fc5ebc905c2efbb56afbf91aa870b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
