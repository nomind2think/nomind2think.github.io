<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"659fd4d5e8e8f052846009e7639bd5b2cc75ab2ab94bae7b46a7e44f326763f5b4adc7d43b5df4ad9336d8ad2dbd3eb04b2cb5a18c75090b13f64d03c156c77eef3f6427c0b5e01335b881743f1400d2689e02342f67955110e0a71ee26d11acb4bb97c28b47438edfc82e426924fe77c0f9fd7cef176304b7a18acc1bf620742d8cbcc325afa4f7bc0581a0589f05f68b057b3823e5696e6d0723b81f755763d6958d2f1b0543cb7eb6776c9b0be8b4d85f1bfae637d57d5d41e7cb37a9d6575ee7e4d318ef0df6fc7051afb04823def01581c0b0e3269451fc5bbffd5af626a9dcec6c3da2408112a2624a339c4d1d71dd449b420ea86d3e85f7bbab8a3684c6569ca76f829e3baa8ec2c39b553ed6ed0e7c6a28d260e2b4a9f72bac46aaac361f6af076abfc94dee6a12cffafe5bd1778d3a54ff69a53deb1495b749909d87f66688b68cfe508485b0749917882b38960de7fea0c65e624ed210e96ac61c86cccc92260d864dc0c9fc0aba4c1cc5cb563f30b4f0a8d2e2a9da6a2b26dc562b1314d1a0a3a4c67ccbc7bd86fe85607da91136f3aaa25909b5bb448aedeef6c62f68212403e3b62fcbd9d551f137f120950f61753fe4cac7056549b359cc99df720bb9040cb6b00a2130a5efa6031fa8e1e80d4dd12d105e7fa69a74bd848a7cbd221d52481e0cbea1c86bfe1ad7a1bc84395b628bddd4136afd64cf4b6a15ab26b676a2cac3df1f84969b915f53dac842ed674b9fd90a0a67a74c4e80db6b150ecdbc5ac3e8868d2839a65dc8b887b1ac1b37981537c4e566c731ce015b6d69ad3b24726494bf0129bd399444c0ce1c3d69a37891800a2b5b29dee4591d960b08d3145cc2344b59f87b664efee5f5f1a4ca8b3c14f5b71e5c5b745e0adaf44524d388f0e4f00e0c4dbe4be6c2c5f5ccd7f2351bbfabe46a4e63825e07628a1c9871028c1c750e681f48e4e543f6d8029d1fcd9791ee1f226f06278cff3aac6e69ffc54614cfb17faea8b7c1bf124f6bdb364b661d79bbf354b98d87fbd66e1f48c17890f951da6650ee61d401934725dcdc17fd84c309ccba66cf07a4b24b9299b5c66e16ad3c44db2e18dd7e9e4b1f56be9942cd2053c81e92c12c2b78973cb936ab113132d7368f81b442841516f5c6e2448fcf308778cf4a698fcf1a987a1a20a119476f7da073a9eca9c36d3e2a8b931be8349fb7cd123fdc3a83f6416c17db39f6e2d9faf7b152d6b0b58448ba9846e381aa31233fa008a82ee1ac71cafa8dc6f5bb347c8ae615a86dd1f67f10ca35b1cb2675debe799cfab23012c89fe87651e53e4b1e1442df0e872ebd555cc770e99e842170623d5a53893ca8e839d561436fb27dfe43d5bd132f1c6035432e72ffde008359d73659f20ae15ccb31e6fff26b4deb53315707281b0d27f3a450d0688bf5b98a83810564cbb74da3543d0f49c374823fac4461c9f32346ee091f2ac078d41757ae4bb27c59f83ae69f5eddf26b6020a57a6702ab0651fac5aaf73ae8a240b43dbeef35389880dcb60bcb81ef819c21010e5b55be23ba05576fc2b18f81bf83d89b53e6a868eb42e96ec1efec8f946cc5abe2a5c1922e60e519fba7ca66365c7de48a3a581dedc4a2eaa021908c8b224043cae7353fdf3f5fab130ed145824018c90594cd92c4ed02620f943d99689a275618083dbe60c3413ce52b1ddd0fc982ee6adcacbd336bfe5c2a54b000cb06adaca2b63c4cae737e01d6d870b76fcc27d96ba626f64c899fe99e398218b4a733971ad6a7b441af8a03c91245f86a878683faad8a62ed897d5c2dd2e0e105261a743cc2c47c1c84576b86c7694c7216784a7370dfafaf7bbb777face7b86fd36cac4af96c3a892103559cc2a92f342dc2d3155ba1c8c3f4782bbdf714d816557d7418659bb1ade6f70a67e30f9728bcf58fd1377097f49440d1b2d767aec27d3f2cdf72c85c4ce3bca956190f99dfdd9be76a5cf9fb46d5e0c22c75ad0f57f8eaac47b26cfb287f30f987a79f1ca2710b2d3cccfd690cdcfe69e1b0ab77db60567aec50e3dd5318755b8f22b016e98296e6bd99cb4c09f29de06a28b3c660cd0c631041802b4801b35ac36adcf98e534ded8a0a06dd1bc3b50be25120b24aff8cc72343ff8c3d390a809ec984207d10a62ee9e968f66f11d8ab2b8875e8d94d2420c0f452ea25c556365f61acf0573cf3b22da85af0cfe5b1f8b8a3f05559fb090f7b229c6c63163a119ffe532ae4d35f85d9d735ad892ecc2459e8cba1febbf7d8f5426f877a0aab047011c8834f48821fd11663e918b93c6ff66cfe0800b2f5ba1c1347058ab76f15c1700132e40bfce390e69d71c4d79bc0566abef7314d80cf92604dac2b997f5033aace46b10b6176646c03b0b4a883114b06f045a0cdc1ef92dc1ef9136bddc6082ce709942f4a29bd049a0fc928681fd6c4085275fd0f9eb9a5384c5352f1fc9a0d8ac9a122b864a6ae134aadc5a43f1c1a7bee421e9be585a807a92387da76466c4f882695218afdffc371c8e1e051b830d98220d0cfadda0aaec7aa254340eb895104096a70bdbb6ccbdf7dce1db1281db523d5a4b0f7ec43b7b7db40ac8e8a902e8dc51a6c24539f7050526be22fbc8d9a222b6aed677e31b49d3a99c33b7a3396f03ecb594c6507ebc8818301a1e2ac11a3e2569e5ca78a9487a46944ef08e5db881defbf12305c64118d47ebebc5643c0b51ab0e07ad756c87432851fa9714068d852c05a6ee0939fb145f6ef9355d28de6a57b075a4a8f188a61c4dec65e699d4a6d760fa310cfaa9f417fa58b04d1ad557e866c8f7bf713f778cec45cf21635952624ddb34fbc3db1f6847eb476b77e2497181963cb01aeb73973aa23b38d942f906acfc212d1eb39c7800290b7430b095f97a731d52e538d4362c0b2689b69a7eae3e6ed42dbe80d10371c26acda9ece7237109e98a8e1e559c39ba867bca28346e59fe33817290bca4151254f39ee2c8345acbad140bd672aa421c37bafc0428774d6dec163b4e52d70e950cba04a47f099d5a1b75d4e3b15a9ccd2adda8324bf657f763a98faf7e0c2e915f8545e0117106fab6e71475f62269f2c6d8f7a8ecd8ac6d57900a6a37a31c2db13b0a9d6b2166b02e502c3ef1242425218806d3a2f81d49fca52bec90a511790785a7b30d6031b4c84cb80a284635c33e1b2320612b434b786e3ebf3b388e1daa961d5d9a8029a282cf805739cd6dd2969e78187579bc09668daa1ecea6e59a9e2ee59d74b8a14b83ac8888d326b4e0f898e411287805b8c4862e50da0d45b89ec137d1073974201c288e85a91620ef628c2e76dda8bac89ee1ade0fee4164d61d38f2e445b235146afadebcf3094e5b92b4e8800f0e29a981aa4847524dc979a170ac3f1e731f7f99f039805dfa39f9551b0e018c79a1ef17fb8672d06f11d430d1adf7a6263b731c6166b8d7ea4f40c83cecd2d6e0ddcd4526af686c356ff21883b9f6edc51c388515a01d3f8e0da63bfd7b7f7bc94b8a6902ea7cf6a30c2235865d9512375f42c31e7a0f0387d906fe49c7cc6d932dc64a149ffe3b5f8f43ff41b04f06f7f321203c6338085e5805979c3498ac3216b5a14366931f4f89c275d6bb5925242d4ce654d894e1ead943176235ab87dc19c3df87674694f715b3d8d2fd1cde64183c1b57afd21b4e62c0faa5ec00bf7daf684005c6c51b3cfe8c624e8b50014e5483234ebdd8d0ff68400260df301e631c517c22588978c93f20dce46b43db6cef0b4205c494feded435cf54935ddb4dee01b13bcf835bec11f2987e1cfb58fdb515a1a3415e12811793ebaf5d81dd640369ba503b61d32ac2124257387e8530013fcc3c3981dbf898166c3394c50e1a77012a5ded2af0c9984cd2aeb6ea77d498fe7fc0b08c76c3d48feafb860580f8b27212a03e3a6df6e2e80e7919321895a2a792f304fae2bc079ca4c2ae27581338f9b5c9add92e8b5f0e40f325c13f239e9f52aa5b7dc5f9cd5f84b71d21fea356aa97c9065fe608b62c20d68fc0117ba5b324138c447d3b1dd26e8ec5af00680be557bf57623885c3acb45271fe4f056d1951a64fb830569ca0a272425e3afa53a8846f57fcc0dc54a2752379ec75ca6a06f83c77e37d36ece1731311726752be2a698379812f73a3dfd56b8b0c6a1333d49eda30e40b6e7e6f4c600d7c5bca28e1e20a8991210b4fd7c71fb65615a57f3d8fd35d65ee43e4a7c1267bf4ede15333dbd1a035b3e87e0545c92b6f19d1e7ac28941ce3cfaedec2a4908a0e44e8a468b78073da8b77a36917e1d0b983ce01863c6c43e7a00650a87c98f72afe64356e6d1538f2948cb2156fd965e6510822d4c5e0b0604cfacfde91b47690516ec0dc72b84a2ad2ffb765c3ee9562cf4a349eb7a20a2ae5b1e39caed792631622822df6f71156db1757140fb9f9cbf2fb9e15b44edf6ecc667dd6081d22dc7d2953ed40ffecc0dbf6e752e9067f2a4a8cbc488b4727db70c48348833fe8f06ba8b29c68d878f3fc45becbf0694c76781b373661ece9989c7c942f2d94e8797c18607fc490a3049d7400704dce9d8f27b22c07ebd961286ff3ede5ab944f4a25302b06378cf1c3eed6e8b4e4208fbe97d66c1de7ee52451785e658932a92df5511898d5fc080fc7e4d6274215bdfb5856274546ac2f8c5ea623f6c20934ab0775a106945673ae5027cdbc6682b27a36b809168fdbd464df7f0f85db6802e2bce1db8b801c22538f11543f4a31b67aba6e88fa5cd9967e821357061851c4d99ea7282fb7743fb148c6f87fc4d1c1fd81758a6215287f9cc186f09a8bb7cd74b82f8328933146e4579f352d32d1652d6ce9c053410666c0008799a6a513168bb0745eae02f87ad75fcda4d938f30de9e3e640c7d7ab22ddb9c8f6ee92f096c638dec17e441ee265f4eed8890feffb0447f5be2e078857deabf2cb12bf21ae376681a11fe2f0b0b3dcfce782a4dd643997d15adf8872c24bdfae8cc6e57390ea0a7898de4bd29f14b04a6f5c20864fc39bc6c3c3e001edb086676a1a420a59e6bf0a417bb7849953ecde64a93233dec7fbb1c22716b73af72212fd9b79ccd7f441d143f2a0ba00a1a1207a5a078a5381dc25594f7c858ac1e30ba57fb725a8a9d001b30a2198cdeb00cb185fb26d72d9d4dac5e2748a0b0ae5f432a6a31667c93fcbcca2e8eef8e58dbf1b50faddb9332169b5c0b8710169f78096d08e7a392fb3d6a423e37c4ae4e7436cc78d7f1f0d5b02a862f21986e839eef2b8118632e43d4fd92b7c2baa08d762059ee8b710a8c01991187c34158b372360e67d1547eca22afac579ecdfc9c1ae1251b1bf0f590f6b3bb45e4d59cf294516907d0a5426d3a225607dc603abb3ae941528bb1b9368f2d3bf0c7254cf9020cd509d6879980d3df92bd5999d1c7faebf072b0e4ccc128b7027ea72a654a0e3c75ec189e5ae8fe967ef78edef7f7e30ab3e1d0efbeb7d180a313dd052eceb360be7a56b303c828b93206f59e71b538cad1c7f4febe2318a3cddea07eec95f92d66995c671b882aa9ebe79dfb1713614d5c8609fb2262bc72f03fdb9eba52bf20eb64156d00eb080df0100e0d2f6f500774e4e21119c799ea11cccf34103c68fb692bd2bb98f3fe8ddd0efe4c696dec0a2e343892da577f7c3c040007e859a8f0405424f3241403080573a8cfbe18377d2e8e1b6418e6a2cc7e52d7c2579cb235387f9ece9b474533eacc66ad62693e6fedd1a5f6de207752aa739291f45f409ec144d70ee1b32a016e44bb0566645e9b01f79eb279d3e1050743268c9d44f65c4611333fbc7b0ee15538ad84c5e961361b97498e74ee14c653e4351a24d2c74e1c8dc25f9b5ecd332fa85d383ee3f7266165802fa021b6e18294c78763f85b80cc01b4ec1fbf379fd0c5c16d426abab3276a0ee38d3a5471a8ea8753688c32d8962d6212033d5a6f5eaef6f276a9ba7ebb99e551f00f53f442bd0e6f2ba3e76b3f438ea94cd4906157c8e693170ef71268f7adb8429fe44e3bfda20817c6aafadbefa93ea3cd0d3366e9ea6462c1dba37875dd3b0858f40374cecfe807414b05fa31ad166c75098e610b69b0a41aeec10acea636347d7228db961157890f93275f45965e70472d1c9558fe6aea83b2cb7ec570133ebd055779ab5e2f9bededb496806c334698d1dfbe1aceb9c21db46d13d29b01e1fb33b392c22e76b070ce5ecf07b3c612ba65b5b3763bfe5e4c27da178a3d139e68ee2ad59b71380fada260f90cd4504b406f5f8340c1aaafcb098712908038110cd2a0924646bea62101dc3bed95da84044edb508d891b453dcf1e74fe397e61955b29901b591af434932bdff6ecbba021ba2be013ddb39dcbddfb41820ad406a43c30bcbbb8fbe4f1db52cbf3c7e6be905f1efd762711abf4281f71f0b3d9bc1fa0d65204971c6729362f842e43ffb091abf1d8d43ee550746c10399ec85e05fe340e03410263b73d6d2b7091c6147c056d6f40e16b7ab59e152c075e7c7bec497819e6dcf6105c73da1a7f0400fe88cf2480682f8f0f8c9a88265199489ddbc392fd8e1c68cbc12c797222b91b9c051a9e5e1da0693ed1acd872e67714fd67d42101021567c534385caaa07234b158256b04e12b6fb349c5c30de2f43f6addbad37aa84a092ca04eac1328d117dd8dc4d14ef8a23602cd26bb212faca89f1e801bc3355142009efe55493c2c57d2dc3933b2ded8b01f86c534dcc7ed9ca3514d8ba409bc8479ca5087981ccec026f23745bbc7c30f02fce4b88a0df517dee96d52fff4d3c7557ad24b4d188a722375e7fe656f047272c248228e3598f593dd951cd4254b83236fa47ca00f0d62caceadd1de98f1ac36ea697a54619ca6aa83e6f76b147e9f36a0a5eded1dfcf57f480db831fd1f82705452c48616d2aa9e9795395d848b475e654dd41c4587dec15a3bb5cb5c751f70eac983e82356188f1aa10698d9db3be0b78cd9a584b80a4d7eec6cc55194b94c3d359d0e8bf194f330d67d4d76ea023cc9899691887ab4630850dba6fb678fb9662bb7f46d0658d1e160eee101f647bb5670070c6ef1e37ecb520c2b554675ca822d18b0e7d6d9a9b8b715817be64b03ceaa4140f3d191dda70a863b2cd449fb4d478d1b8f7c17f9df00520b4d403366e70742ed0d53b00e8b04447a024a8b68c05c34c97562a17b4ebbec415e3293b3465e2e301589b3094b19106623047cf5004bf5c6dcb4796bb9d27fc6421c5ced57f2e933f33b35791ef144b7895a79829892f2d7f38439fc38100b7aa8b328b3a68b4d314c19d8120b06cb07734165e8f65ee3683b2cc96e86570c882101d85fc196ad362dfe0489195f4686c8e7aa73f26590f482940d2aa51a5d3f2c603dca0e03783660b5f6a160a4ed9b0db48e2439e8436d2b729e2c491beccdb2fc486ae44e879739454dd8747b69ab746356180728233a62abf70808f5916d254338ace2fe6e73075786c9351833fac928cab55c701058f7e3599ffdef5c320ae75173af6baa3cfe7b8163f3dd76f01ce78aa72b14757074f54c45ad6aeb3be974ad5d8bbad709bbac1c3244b6327c1bb8656d9081293c546312b33a0b80e90c4f64965f47d527461bd76a960c1efe966878ee6864d13acf21c8b68935fc470e91eae115c4281f51c590200494e87398e577f3a81f2252ca88be3d72bed58badba2f1567624afa220fd13f3c1e63a9d053ed440c109cb36ce52afc2060483805f59364b4bc0d93e5cdfd575f87935c8d135379df7cccd008c063b720212e44d27f7141c2c9e2ace2baebfe6bd8f1764f9371de3469b3f900301816c22716bf518d8661281ae517f2ff5b10d08e3d35f7b6db866462a2c6b28ef068766e2eb2cae2adf92f48d92861bf2a7c37e23485e76659641f429f9e6fa81c4f4662db7d57a04c4f704c9344f3f1ec7ec620e6710310470eb5da7a0b74fc82f95c429b0f99af18e44060ac7c4f56df1e4b8d96a75b8a23da73ac4f4af81a66390aaa329a778e5bdaa45a54514161febde8d1eb5aef7ae8f61bd5dd125fe7e16a79ff12965c18b80f78e746296cb1436c64dc93f3afb4d5b4e9b66493fbbc4b3b687d8ef7f5411b81882a7e287c9b51b3d357a7f6d506466c167e71c1e9a195dd8a7da6931a835573e9905579c6677cff6a132d4c7c376d2028ee0170850ad4b911d3da36e7cb6938fa2f656acb9964db07fa5dcd72c4662cacaac11c30fa1c8aecd489f83f24bf5175ec1e3f8e57cb6a1ad3c89b324335b9c21b3e16d49d716275d6dbef42e5ecb91f2033aeaf1a8c4d23cbd83127c54dcf705491389812302e221126cc563cb2e9729a2339ff015044020c9f90bce03420a474e6e671613c19c45ee05920313a40180f2d5a2653d96800729ac7620119667e823e40f2e63d244e71f50eb8b485e233ef826220d9aed562ed06bcf82e3576e29a747747b281b9780dac0da7b66e6ba83fc11e3038485235c128639eef66884b526fb5a12b6aa421ce3049042d1895ae83c8ffe3c65dbb95ca8378d30219859ef0be70323d4936019908a7c3c816436d50c058650e4d5055f2e0525e1e03ad16a5051ad3fe3b3c17bf51f0b26189f7b19de2f8ac518f248f055c906cda4485519223606c3bc8f334e3301c2761d2427c8ec295dc861f1b5495f1b64e428dc64b3f99ebd58b486c6b6fa54e17162c2495ced1b4a8d921235033140587aad86cf688d917b787eeb91661881da10f7d8546aed0a0da4994f8d149d7c52d6bf73576bb0decd5602b34465f058fa85698dc05fb98ed2a4667dfb98ed5b310756401a05369f3717ca9289d3349219cadb386721e1be078bbbb3a829f76d0ba5fee3da23ee2c812aaffc23d1cc05d90f2e5975f90ad90be589ef1f823f9fa9ecbaef396f446b1b93d9a0206dce7430fc93a851accb222c8053a47b6e34804c3b00d884efe253b3dfe4f8ebac43c63d489550933ed9e084b7728a1028b9e524860e9b6c64286f9f2da4069dacdf3ad9c08f1e5b886a536c365f6153f6033987adf3f5d7157b8358557409badee5eb6b76ad97901905c45e588a4a639aa28b2c8e7e80cb13b1b6418749865d5ccdc177151b9c88750695b1ca452888e107ab2299323842db46da108e3cd35556ac1f5c0c5561b113bb3a7e21db70f2f8297aa923610fec4c64972a82e757ebe957561698405f22057b422c1bba3bf0c0d574c935fe5a7d4ca968eebc62cfea7a2b4d5b701c1fd823bc6ff7a49a557fa56319e6809af617b5ea517ec9000f8b5a691d88c16483438b0ef177ca5581f8040ddab5e97ff63cc1dc388d5837c345c17c90a92a763d6cc97c3428f7f00e61acafb47044e870fc32fe56a48a734091e25d74938b0e374f580ee90c931c9cddeae039dac6cb670169020c9f56b174560a952b50aff5ccf25a5dbc0a6829b45a8348fe5fae3aea6aa313ddfece6abf5935e3e837ff2ce2d3f2ef4f213720766048b98799e27f42e556773f4cab789e5217760a7f7302066294e08b4096e71f30155beff5eb31a8bb5075a3861480d0eb38f0d55e2cb3d3fcc8af7a25063ed57f68003e08a8097e95800efbf56f4d89a0479cce607fe6a2c36e9d7dba0931ff500b73e4c156afbdae018afcb7a55cd65fefb048ffe15be93620ee87f35f39adfec531ea2c20d9857beda9a38696d7f562891d949192c42805b591b266aaedee5595c71d9a4d75cbcdb6dd38f6dd4ab39dbea144cc9326a183b952952793a86966583b1a16007fe9c26e7bd5839672b638c4ef63d7b25589c39bfc3328ad259041119c531850ff8f5db48a3f9692e77dedbbb5546e9f2f9fc3590c68463fa7b04b503a9ebdea911fff6426c0acc424394b195e42f0383bdf1c33d6c889e090c59a1174acc64974882664397ecb37d69036a5faf8053f84f3970590843adf74cb121bd91cf94ffa308f356d0c22a19dfc64fa04b84cafa33fa48415a3acf62a8b57a3ddbdf866f1de44b099fa3955c6e93538b74744ebc02cee2814224cfac43fe65cca4dbcaca94c30f9c595c90fb4920fb75c94b1f768cd38c4f8f63e385db5c8e2106ba8cbd9a09ccb4549270100e255610f0d8a67861d60a84a411f347c152a4633ef3911bb7d8da323993c8eeb53a0bb4b5145405cbab0278eb9e313364055198b6ea284c3c575d2e43c6456ea99b8d61396a157809349c229c1f39daf8d8fad5246c7286463504a3801774c0f6e32b56cc1e23874d5322002f61011c5c150b27a8dd05a8374d5f96a86fd3fd970148fac5f5acabba9e0ffdeeae0b28e9bd1d8c2d03430c53b9169091510e7732e63130583d07898db3b2297597517670d229fb60603aa9da19b2750e74491471e104408110ce92be2ac9c5dc856d722aa95a33a643dd2910fe008c5400856739636838f2752c505497508814e75879a14746474026150ad71c5aa5bc52ac266cf574950b80725b8b98eac531483433a8b040b08d266309a64485f77d3f2895f22b73d30ba1d12e2216866158e972b8473a8d44380b4fdb817a70f765d0f8837cc1f0fc6d00844084e71d3fa4f0bc3202fa09fea4d729b474573dda46d49de95bd4f8c3f3ffa293dfda6befe3d0a79d10ce44063036a0919becd29d2fa376c94c9654e797fb3e53478cc6078db5fa1e8b971b08da4bd7642d43e26171404d26e66d124c70ff25b1a42ceba6e539acba99a28be457ac3b97091576b21c0ade4abff720e2dcc9eb24cd9735565151c529e4ea2ced5949a7b7874b5e7c18afffc0652d5d9dffe57dee42407fe4a58d8384741289e4b014748c9767026e64b79617044c08510745812c491137edc33fc268d5b9a4a4448fa59f3a3f3f6307ebf3f3ebaf3399bcbe5254b5f13468b5fb7125dfbbd9c44ccfe0bec19193e98dd3f8c45d1a167666bb6d2f52624925c061cf18a677e85f4c18812fe9a49ba806c1b56b7ea71bd64d0560c417477427a5b46233987735c71985026afbcf1c33fb221627c88e71f57abc9eca74b0c91a109b361ade7fc2330b9e6dad8083cd07384560ee7f3e5f674c4aa94d282004e7c19f5626b9416289dc2dba34d9ed2466314609f282ade1d96a95ef172575398df3a7320a69f592782031dd114af0133419f1aad2aa22a4ad8816e3a21f07b27ffe78396edecf9b22549417655ed55817e39265730f6863013026a4cc276e50b815e9a5f26dc692b81ff28710eda24caf554f8b6ff117f18cf8208970bfe26a5b9319cc249f75bc60834ca6a60bbf625c3fd1d3cef23c9d1bc4b42b77c7f8150d7b57421b8eb253ad289d34e07a2f79eaaeeeb45c77b7debec9a4bc6132931c969cc989bc70d5db06bb20773fcca0a5e72f9a9ade10e7042c8c4602db1da87f330ae0b826520e2c69d4b9389ca400cedd3621332c664bde77224c42077bf21c16ecb52ce14121ebce349bc76a30103abc6df0a1e08d3213469b43eeaaafed6f8553c542bb6716a93e8591eba58b0c05f80effbb7680142eac248acf4e6acaed27d139c15abf471580f2eec9b139fbf70d008b306f47263ac10b6c3e3da6ab14e3c05ad76247604ec4ecb3229d965f3beda30acbd8a6cc93fa862a992d5450de5db189401a2f5f2f255176c3b09a957f2ad68a2142957fd10a3f559a89c12f4ab1330c8b21ac3d2e0ed68b1797d6e9d5e4efb3a25937e28ca4950818caee24d131dc40794deda07ba76cf0eb839423933bc5dc26ba8a28dae047aeeeda1e6bb7915916cdc01ba387497baa41c74d3b21179aaf5930b99169454b913697a24a7dba5d66c64d57f20e4eea7d20d16807d719e5bd28f62a6603dd1bb01d56e065d889a9b0a1e91fae1647677bd5619d2b5521819a75bbdd9638d0fdafed6ab42bc5e22e57ffa2ad7408eb86b95166dc20b42376d069222de1edf6327e4a8299b29820e31c60ea9bd0df9b58b7f9ba19b48cb8396916df6a9d5a0f22c06a7cf22f162fba22ed018ad5be33b13313b21c77254e9f1af1b857cb8194b50a8927ea9b716b63e8bf9c8240289af8954ba9bf7a38a89e1c4809490093e0daf27826d5d3bdd2fb278ee25a720c67d61afde59ac542b5f47219b39dc230da275590fa90a7c1a0bd395595cdcccd7417eb3412193e3bef01e8548fba437171fabea63aa52a5eb54b8efde5ab81353711b4a656ea038c7b5d048fb4d4f40b6fed0da6ba5f149d394c96a6afc4f22f5f368938c9e3867154df75b6c07c847281a4f9b12d8544f94d7fba8e80d18b67b952b5f886df65b20d07e816c6838eff7d30f00bf528d3706b40512e6bbe3834fbda68b6afc036cb494703b6ec5845278f53de29f7bf6c194e7ae1552abe0a7e81cc9b3babd27e8d07596da904fb75ceac3da005ae251c199baec72c8b8e786f82c4b3048089302482ff543526db31e2d74f0957027f11e980dd9c5a8b77768c6d0f76454673465191a15847ed56bd637180a9bd477ffc73d69e7c93f3364f375204aece1cfc59b206d471d21316ab712a37e76279cfd70a15c5eb00aec354d4cfd3ca94d5c43361158033c37997e4152768e3ec8f8e56847dfbdf2675a22787400464bdc58d76663800c1c242da96c0cdcb23e06c3b4f0fbf7ace3a603ea36e72d14353c9ef59c139bf6f3488997580535d5a000c46a2386b31d1718e60f9cea641576d56100e92982b5b2e390359d7543f1eba264324c826ad44ba59cab0a734dd6c2ef0f8341a67659b995be5a67ca8a3e82abd90aa2a278952e44e427d3441514c37dd30561553c5be6d9ae3696bfbadeba9f3e71a3b71359dbefc6b856e24b5030e1a6dd1ac2657e48f21ee69a58b6067b46bc835d62f7a5b27cf55c7f03a13d6b9ea75907397d51bf882897a14eb1cae031f93dcec555fdac37a1a09c9f748cd2e5c3b529f74c0798425a7cc6cbaff0001efe96005b22bf9d42ae53a993f7ed146b6ecef6281856c227d7433f95a01c200a462bcffcb99d888f89261b48e6002565545042d7e2a7fc475126e959044b48ba6f4232597c9a770dbe4f76ae99915f5b328c9b2279675751a8f5c34a709670c9382af5830374b9e7a6af8df4afd6d5980dffd5a6dd23aa6bf3a7667c16b7b0d91e36485cfa45e5fd4e8ce75417c5bcbf61f9723803466de8e2b3f2c87dbde0fe067ef5b8983096f838777f6efe0dbf0811dde550531e504f96c137221991211c78865ac7853a2e7ff21f2d47cc764371d1abc9449c95eeac98e14b9473d6657364426438337aa94c9c322c0c309281a0b3d527a6ec1f4b505ec97e3d85cb351a38a18f3d05c474077c98c8ef1cd84590c464295b6e84de97ef6dde0cae18ee6851dc07bb6008d5e16026fb893e4a10de49f22466c4bfef394871c6664cb2a16eb0e5e8b31a7ac72f5976d4823cf4befe59e82cf2aad27709624dcbcdde264f31f32308c2ba97025fbf93e0f4922d99fe2a6f2601fd5658bea393afc21e02efc58dc02db9ef42453359bf5b2cdb68804047492ede831f26efac60cd183ec59490b3fe73e9b77891d3d666bc4f6bb6dfcf1c71c68c3b85f8fa5342179b0da68aa0c2d9760705adff902025d2285f83e0c1b61d5ac17bcca2b084e491546867d3ed6b0f9e94b08b39a9fc52f4cc5a2e540788ed05f9617ec016bfa409309658af4eefbaca737b2239423a2013c3d4fcedc05e0fea84ab9c83a0e3b0b6408e02878867100dea1a935e45ce8d0ea30e82b015aad911a221472f5f9ce1db589dd60e1b5e2604bd3c082a47bcdab0b01e7f02877a3cc45847a2e4a7560c62fe971e7dfbb88d9ff18ade5c7372642b2cca034e30e67c596a3f8b6f0c8da259b8874e0113226c71de7dae22d9ba46e846e51f85ba9f73859948b4e2654b932d01d0ec81be4634e0534692b14e21d718de8cd1936fa8c9ff73a0dc144c0dab2e74ac2c2c02fe2bcd10421a18dfb05db0bcd2f2d7efb0985c9608fef99c2c344f10f6304f8a82852dfa39519270c7a2b42e7f881560b0fdb6cda9431548cfd5cdcdef50b5f19bfea4065f739864e97f78e5db47faedf09be6a492867efd305abe447e6d4bbf51cb41fe8c1acfb4c21b2cb67d241ff05a2dcfaff84b894b6326eabd1f90f05841f9e8efd882168328019b6da846dd1812f6a15d0da29aeb18ae2002cac06ff2a49a99b748961083990a331ff135b263793d2f85488fdcc6380095fb7ba76873e34de87f7bdd1f85e7071853cefa07a0f4e554f3d762595649ee675992f970ce2e5ead6322aae2f2b36cbbbc68a0fd97d94eda378cf98bed856a1721ec3055502f90310a6a034f80b0d01e925aa36a582d6c1b52dd2e1e6d82638c4130eda53727f7b821bf341e56a02af8fe7a19c0e3a4dffaf38b87378f4c2303a0547b83b53739a811b7a2efae7888cd34e243238d5b7ffbdba9a90c9b65d1b109fef0077396ae4b420611ca53057e648f1e31d38164796989fab3a8fc06cb754b8d5505954fb04522f1622ab9d2e244117c8b869724003efa5cca541300042b35deb9a37ce41b404d40aa0ccbd2109b47d6aadf25545ea2f6e60b4996c7d26bbd543fd16c72ae1a8537368bb4d1b06d4687cd4e0f1992640c32cdfa4bcf4c0538dada30054d52bb3fe24375eddde3952814199b8a7410fcca7fc63b9c57a60afc7f6717034a2cb0545b0e1a85511702452b87593f6552be1d00d373108ce148e55151294bb60a606bff6b558dbccd7878c9c100250ba5f4e303f3f828cce169fe90fb0a13d42019d384dba2545752ea3d8cdd91db7182fcb1399d4a01a6ca815ad7b4bb2b18a76a0013d975fb147541a79ccb08b444b38c61865cb8378bf61573fc8f5207063d3029872c5c7d0c45caf85e8c0e159a44f2e8d7c154b630e53e2618f63019d89e8f3aea46e60abc9de358d2787a1c0272f8b290cb6492726dfe32538e1dbaf58665aafaec245837e7ea916d6f9bbc9c9ddba4a86db951aba5d293eacf7bbc205b94f2ae1b8a4632cbc43994b656f58113b3cd890682a64c000ae5cf733247f4b0f1491cca4071d1688153b2a74989be406ef6a6145128765847fd0921d08f82291f27e522c05c5a97e9258d279ec8248da5893bf6e87c7f2efd2e6dc9d400e71bcf96bf672e93ad3e9a1816d8edd6fb2892ea9f10bcbccdabe1ece630fbe0cee32276e7127358728ee07acabf622045caeb7528f2b3babd12fce99ebb716250ddf475bc63a1c29ae5ef221c3b383157785a3cfac02f4f9c4ab68b5fe78861a4b60ac256d94c5e00783bba855d010ddf159889124bdbd45f8332ed5367f08b589f4d7986037858a04684c1c51241b5f7baf24d7c88398e925c2f6bb8a34b6496bb4db9c637d9912c84966c4de12e2ec5b2adce38e406386172bf19c888c1e403866c03cd1172ea35dbbb7620d72c2a685b3d4a26f585c406321f4ef1e49ce237b4b1fc15859a52c9a6f1b3ce7b23fbc5bdc1a19f1b78ddfb0242bb3ca3902ec949018bb0ba51a2eca4b967c21e769719458ce2a12bf40cb13268a05e66aeffadf6f0346b8eea08fcc0311b8e3a13fc6de9cbbe75cbfea5104c7246a786d8a28647578b730877b12d2392b07c615e1f6df7f4b96aac2da5661f03ccfad0a2eab4fb5be4ee7bfefbee12db690e52c147df15e7fad4da1709abe25cf3fd224151b571f8f0d5b022a1dd6cd99b5dc306c4ef15c1345338e6926d544f2ee447813e4ed83abb258cade251e65e5638cf855d8ca924b2ebd031db75f158311292177aa47a061de817b052367482cd29cb773fa457d08b24d8047b78add425fe8975373d60040e3286dc42215b0cf6712827c27af12c998269701c27f538b1f7844aa0534debfa80c58fd22a8ed505cee52026cd4fd9a0fd709844429e0ae999b60500f50ad4c4662bb174e68bf11eeae334dad4522e3615391242bf9160683170c7f0a4e51689427a7c0a5a7e02ef527e717a66f126dc8cb4d9773d1c06ca1826a6811d3ee2b7c9b5ab9b71ede1a14ebcea9ed3a5c41887f76900fdf6bef365ac96fa0ae08f8e30a64443eae8a63f3a5c9064bfb80e451e4f4a5ed544663a60d42c829bfad8359adf38a0aa7132a5706f0b5dda0f4d0cea046c3189a9e92dc04009389d963c7456d90a1cf3315d8036a9d0befe594611eb941452ba35f26457cac938b82ac831348e908076ba60cb1ff0b5f87cee15cbb74cba2371212170c4f2d10a190a754468fb6840298f50e824973b54a52b2301516d8e6a9f1205fe2bd34eef3454bf39dd17cca4b1dffa217bf84de743d5d935d4596ac8409fa584410eed5bdd854f838a6d388e44de48fb8db4af9a7d4a4f65c8eb0c1dc0c9ec41a0347e298cc7e7228499731da3d8bb0246cfa838f1a76f8b1bdb75a986e317f0a54de2c9fbb3ee88f61ce95a8c31fd860d661eba50be93465bcd2f9b8a5979b16f1b9aba552fc8441450da947eefcf5b91ca4c2b942c97e149074a4fd46b8c741a7d8319f60207b35a1af5c96f1c4c69aa12d786126c3d32ed87a1d94911651b49cc8c22d2d48a108c197cba65bc154610fcfb2fe7b2b69f2fd2d9abdc9b65af802ff78a79af431ce1cfd37ee54634efa86cada34e909d0e3680726c16472473dd0f821dfae5ec98344b29c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
