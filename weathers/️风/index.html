<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe065b4d26bd78a08e62bedc7c02c6eac24c1c1beb788384845cb029215a0df87b1016e7e8957de6829162e408ebfb1ba1517c5612838445ad106a7fbf5a4facf41a5cd08dc9f52bb469fc58b0622faa43bfd8e52b93a56fd8890de6a3c363f0bdbea91b557ca9c9b96aeda92f88ed05367411a0749141be21400ef96e3fbda8282692254dbe791037b99dbf22375bfdfda892eae957e73c9180881d75217a46838c6f965879596e803accdcd4d31e758bb1fb64c56e6639c4f87a39338e121212e6c475503f5ffe604fba17c93d020864bf6ddc8648c75f9354b6546b00a2ae6b18ec95d5a9404c92bfe4c0559e25705c4ec5789c97d9cd86b840be13e16b5da8d172adf40b16827b3363a9fc0c10f012f2495fbd18c6c596f57f3392e068e4d61834da1fde62dc313d0c85feb57b0f3792d0b47626cac35abb52065076ecb6fa8af15ed9cacd0cebe96314a613acff13380c60d62a745d8745bb6f666734a7b7b256d8823b4da16da0832698ba8eab37534e31f2025d896502683b5cb53558cbc9649e2cceee92372538925760a028b449ba108649038240cba197d1434e8092ab058e34199df856593f36b57f4ae4b02cb10706c3fb222a5a2a80f205046e7074b31e00271f40f1b5cd89ea8c561fb245ace8db65ae248b8ee2f5c784369a222eb5a8d2ae66f3f115960f91c82d03fb0bfebd7d9a4a9a8078a2307961e15c196163dcaac9d17fbc1316fd70d5d12b83e59cfddff6d21f895fa595ce9afbd5bc7ee28929ea9d7aebaaa588a5998b83d356212be74a39d8b3173fc82e828aaaf0f398f7c91189e0a8e5d7c1cc0b19f0046c052b0b2cca65f5020ca5c175bb10417b01b49a052f3212ec2646099a53236adb6100abef7f75454729a16f08e60d3261af2a2e4bf241714c8f1a922362d01582873b8e6fcea8835721d4e160bc8f704547663bee96c0f76ef4b59591a67d4d02fa727ac16bc0c42d8330a7a2b89f99d5d49081b9d1c91b874b44f7668fc9d5249ba3ca317dd9b57d47a19aa74bd7d10fc3477718c2097ac4ddf333e3b46ee8654ad81a977e8d18c027e4acd6d85337ef68b239f4870c2241d6f5d56d832e2cf47d5a678fc36198f367372f82c89419c0174d2ac5040efd7f6c58dafaee7bac7acd4494b70aa006d85d080bda33d388caa8096888c82a7c2fdb4b41f1652c78845e96434c3be8bab042a06b63af0d63588ce409d3c242063e33cccac5edb9958b31f79ac05e8378439c96407105e1218a3389765b3c0da9a27bbf40dab6c3687f06732e969fd30fa51f5f3abda5338fdd0785903f240555417823e0b4481daebb7ef4c053370a23f232af7a63cbc35fbeafc682eb916f7469651db239de90bfcda2888ba9b6ac67389e92e8b986a5c9268a90182b7fe8ebd7ac024d537ccf055b427464c046eafe97b7ea107ecda160289bb805a46585566c51b4bf978b2f8d4e84dd5c8fe98fdfc9af684915b810bcf630e163a2e3bead76bf55cdf47a8b0252c48ebb524a5a3262c0b755d3fba476e8f605d6343ec9311bc71afbd5b893cec6afa4d61568f24c649b2aeb65025673213a679eb79c8b1cd318b0e74515b7a71357ed121a0568a287620a72a9347c511eebb8787db8812f3f1919aab8a97729f2fde0d4421ffa39c5f783f8559db43b47a0a8c9d8bd21f9aa49d0adfcb8274f8f8b61f6c80b45bb50059137dd4efe0faea92d6665c4a4d44bb439c6fc7a13ccd866b1baa9360f48bf551cd3bcbe45f67b17a6cdd28d686a6be57835476f624ede2d43f689df5733c77d687848dc8cf387f36dcc7b7a1c07aacd86da5ec68a50b302742581cb0aa1974da6dbfd13fd22441bbb5e20cbfae48ae7117d712e8ccc9e62ac726a7dbda6c1797dcd6cec57ba43e2f1dd787e44a0f8229daba1215bf0bce82fac69ef3a15076eb03432d184be9f797bbc267848373586f9cf5176eae18b944c260f3c39a0756b8423ce708c684c0c353c03fec15ae4593c413f67358252d28a20ed825be9ad5671d559cf299317b2ef640de349a2175b6cd0d0ca566f2bc7c7d148c10ec3d3e33fc227e9944d21b937b6d85ac5eb76863ae8850fbe2df7b15ddbe37847891f5a79e8fae7ff546f3307d7302f645c85daa0d1f08d66d59332d6e0aeac3b039f319df0ce7f61a92e865bf621c4eb303393b1e976b8bc1d6c2ee3b6847d78562b59f44676e96474129c2d693b8ccbefd9df4a39b75146513ff4739e848104fd9b38f1b3fed67687d81a30d94b69fc2076b855e10e44133d6f18aaa4da4a3e05f79663b10718e62ec2fbcb061cfd8d8af969a05764fae947f9896b3ad1e4ef93a1604e8314ca19f231bd3d7ce72ab480d586bb756e9bebf91d08409ca82438e0e9852eb16fff13b0e88303cd708599863f789a7b6647290868269609a248bda08ec508e1de539bd7af453d554e7c15015791cd7e77e24f22641e3c4d60a4ea5b3f62b778b43b0fd2ad64b70bf5b97083c0496283c505a00ed06a5db64981fb5561760679f60f3fbea8f64ab386f8f24622bf338a69b18280bdc09cc1bf04dbd7f88cddc20b041a46cdb787bdcf23f5433289bf0f016e6b188bf5c9e481a2f5421ffbbcce4b00cd541328be8aa655c2e041cb78650083728b2eb1df22220e4758fa9fbdf43a2ea81074817028927c9bec1f731d6265bc1b956ae111e3d75a4bd33699c2196c2da93840fb2c959d06314e141905f52cfd300d02004466488fbbad9d2c2f0b3848cdd52715df3bf77892155e6b15d5f184d4a0ab4d412591e473b4cd2b10369d351c6ef29cde3218d76be32e91766c58e12d429f19337d97cfc8b04ff30a382bec551a08dacb48f16ed082204fd0183ca7397229d8f3d8d8bbaaf3b053df90a84430bb5bafebdc8794a7c2fa9e85ebe48fbe11307cc8911ecaf0c6985fcfe6ec89e49f13a9aa3b78652f65fa5afa207c3b96b874b355213e4767626770b61b8aff2dcd8058cec1f0bcad35e7d4e4ff63be74190b442bbc100a4f2de0254c715ffa92235cf8b1fc0da982366f096e6031d5623d2e546ad64a229107f561c0b730c99cc88d3b995af15175cb1b0dc40ede3237dbb86cbfd8d688d67f5ee493906cbb1664c01da699faeb27e06dfdcf8777fe517256c6b2b32598bb02b334a3cef8348e51d205b93756e53c25159877716ebbf3d75dbe0036df6ab78324da8b4eceebcf86fb8e17d8fb686eaf3cc5716b8a250528846c6e97752a6fc528134057049e5719548f4c4d6af44adec1cdd0e84ed358b124c21de4a8a45e4ccba7fe4dbc6a6df9feed11093ee3777c5016c258e83e2bf1703023c24b73c3ba0c8991edf861382452ba938df0fd7bb786334fc2c029bf8c317a6bc771c5366ced54c22c1a917f8b831e138015eb19b3e4a04edb1fc5bee1ef66fdb5a9ac724e5ef075a7d181c687b996e731f379eaaf894af1da9644d75727e65570ae56a8be900c080d98faf89d00af2a5c9913bd1f5e4dd49f7e0ec60358fd9874e5887bed384bd1f3b44fa5f5055b7fd9f188e60c7f57924c9a2f472779ea290c132f203d4c15bc4c47b71c34a05e962d132afa5f3d7ce2ebe9060f3aa732eaa31295de8919e05f5887a845793dd330cf866b247b6aeeb35e68a5b9fcd268a91ddf37588307275ce4bfbb0c161b91f43161c95d3b40427651e3e0b37a53838ae7aa6b722e93e8a367aeb0379d9e3c5f9987d76a2576dfbb4e86ffae7082fbdafdbafd2a9d2a3a2e5f6b0f1b7061c25e5b34324c7886d00b7a6b8ba10b88ce81249d3d077f9ae32c60aa52eeeaa1608be22f9478af8b14a5b3b2bcf0230a77c6e20a649bbda3ed994be9bd54b1a0dec14aea88efcec2638e66c4834ddf00da1abc5cc64c58097b26fb9b645b7a26b87d6599f43433e6bb21c07f9ce2c21436f41db61a60cf20a2044a06d5827dc2a90389b4d62a2c30a497fda47264712d84278713377f5e1f85b89ca97b81b17f6099da13b17abebed39f4bbf6159d9bcd63512ef9cd717dfd9570121f697d8c0dcb3bca4f85f9de2245ed582d20fe7aea3cd83adc2c28e26729c134853481243ded8ca4452e174ebf3adec6f00c02053c3e20a4d7ad6634df904b973d0ed1f361b56015f7082a26d18d14de3f349b115e9acfeedcb73399e323f759ccd4713d75c2409f518374cfdaf8e989c709aab4b454cff6347b4cdb8f5812762016f2db9bd163511d7c19916dee21cc5b4af246e911985091ed20f392e98240ab7d0595f46fd9a135740335e4c275a5e8974225aa2d33ff6badd814ead02013f3b6ac46158e5234610080d6ce9b4b03544302e043303c63f72975a1db4fd6bdfad778038ea1213d4cbfd98e6a0c5b81020bb26cc29effe1809bfea74e5ec4e31cbcabeda0c1b7d101ea1f253e94e4c5151879f3fbe53ee4bdb1ee96ec643ddbcbbff4ec5a2e6ce537d3a1ce5065ebbc8c188e2080ab100edf8a9a705c21abcdab6db1c9711f2f754038bbab19c5a9bddd956f97498da081d6b24759b396ed18c1c4b29d7c93bb9ba974610d1dd31a576b1a1b03afe5a591020f2a1ec6e9426240e0a4936717439c4c2c6c00b3dcc89415b34e8e22e7399d4c99a55eb67345580bbaf013182944212898a9dc07189d39ef7e113e13960e87cfb2bcf8300861725f75e2f359df9305838942d09264ccae8ac424beedbb2f143d7f8c72ddba2696201c5de1d543c2a2bbaefdc22bcc65e2a4eed8140737d1fdbe91bc0770a6390ef9ca6eaacdd3d30ebfbb7f6c4be6786e6687cb37e98ab0ba27905b5526c0a53ce5552ed410f12ff9c7dc4b883d47f828c45ad250c28f54432d83ba3350017ccbd9d52723fc43c1c195f7b06fbdc18ddbce22d0006bf05bb4c89fc547e0b103e503af205feace2953b753e3745ea5ae3fc90813a35c4118050f9d5aaa8e1e5d58bf8edcab6b35be78385e167885a582cfd55cc964d15e908940976703bfa3e363a91a6cec1ec4178277230461b007ae18e9973c1657f5c7af0d228ee9596b48f6759fc0f374203d3cb71b7e7c205a279fd68a91545e25e113e58f1e5ba2dc448fde125d5f0e7ca11051f15fe85cda128ed0617f1c5b749fe549d21949b63b3dc0400b08abd6628e3bd2eff279eea5018f25636b64ca416bc5426fcbab2e540dd9e87ffea4546893415fef345c85b6ebbd9dc6e9a4478cdfdd97a3c4e00e844aaa694610fdb83caeb39eab78420e44065d97beda7fff440a62559e35c5952fbe4970e354e8f3f039b78f383f7c496a53412b2f1f0995aec5e462d61da2f0765b4ad8ed58ab40654afc7619d34fabf6b70391f39f1d025292eb7d3d8d3f40bb08a7122936ef3e81b584cb15352abf6e48ad89b612b4f83a859b9f4eb8d1ee43dee1da1f137b47f4a3604d5493e4002481a362ae0bde54b074ff7866d2828eb3f0dd6d2b504b956b69237146a153934993df47c6c5d1903f22a033c9475e902419482ce3eedfeed959448209bc8b6ee669457062d8994817868a0a27f9a00cb19fb2b7fa9cd9f8ea0f7a2f6db7e71d1ab299d21c767404c449102b4d731c8d38b9105c4ea1f4270403f3b0d43d595d62ea85632d08111e1b20f4641784a8375000daca4d3ebc5fc89d8a4bed872f30286ae89a734056532fc8e1405f47f63c5929f2041d28a19b239157b088a73533b9a1ba43e8664877eda95ff431a1af3fad592c345f7edd7c0e7cdeffb4d9a16631f03c80065eb5bb1d01e0b14db13948c5d5cb81aa4b88a84c82dc6212524fe2f3211fdfa36e8d9870f27de544d93f93a52e14f9dad1a5b5a72ff6e5de2eaeeff7cb174aa7fafa2ad5b2f764d4f512dc68f3ecf6e3e87bdde5670dff4e3be4dd0cb8a7bbea10006522dfd72c26f65cf4b1cb5ef55912a04110f0a89a7cb02b715583017c5ed63ccaaa9e04a993fca423130885648f9a1b2f056d55c853238934bb7c467c5d8596068247a8d3b12e5035fd4de2bebb95ae9d2a793a61d287b83f667756a365f789f40305d9c10cf2a64ef22759ac785cf4a1e7ad4575d7cceafb232f0f65ab04bd3cbad7b6eb8ce10ff24fe53fb13e6eca814751c90042a7c500f8911ee094c74c5c6c229714a6ebdd77ad1dfa7aa0ebdc2f9c31777b4a5a3810d82bbcbbe89d006cd83fdce7c21ad75da2799ddd35b4abe3f099442e5c845f42d7c0a6f53cd65dfcace65efdd02dd3f7b9916bc183e5a5ec2a07a31146995bbeb4cf1e42a498e186b0fd5254fe17f62c0c8d8cbc7f4fe6cc2b56b726ee2516d976d84fa903df039d52b8b56ab2a588762db2845e6aa8318edabfda18eee6fff861f7c90cff90b2ba156c8d2eb19f6b5443e114157fe3507d5538dff2da9a05816632a0cc0d9a0c90da454207f010c0776e790dc4d97ec80a0f1ce65cf83e996774c6ad32def1eb600d7d9f5c3394fb3b7634a88932ad4c1443f4c27b4a9ab7b7cd9a7acf7b7a0664a8567424dbb015993720ee36b272d3916111707b5b518130b394ae00357a7d66cc1b077d467fa97893be1f7e8ed31e77ec43d8a10fe329ccd012dea9e4c9c9ad40778230e07cfa8ac3ce0dc2dcc8db9caf8e580ccbdbddea2077cb4919c2ef73d47f99979d8e58eef85d251fe0bd847808171158b56e79a6923bba0f2c78140fbdd7047367443808329edbba83488152a0c691d0fac537961377b397b32335c89250699a0f5673012b2a88f7ffc11f4953691fcec28e3576e30212b97b73552ad884156a1659aa67eb2997aa6d5472a1c308b4638eceed9e3aaf7eb58ba8f0d921e8721788a757ef8fd5735c027399faf2066579b0a57c226b24df5616990431602b02292aa31372e73e2ff6036de42fe07e2ba087e6edbbf1ff395ee3e121078b14773818d93057fa4408d288bb70462930d0ee0603cc0d20940446bd3f2f2b81c799cc53eb16f563ac8cda7f4d7fd115cfede1360a4407cbc0fca2bb8719c2947153187e269da261883c378a2fefe1fdf01b45b65d6810e86e2f79750486369e56c9555d1c094f0d1319f1193cdb1659776eb75eefd2069ccb24a91a1223061244a4f7cd738cb5d9b5c6f1fb2b056c4df7e499da5aedc2e4a76dd61a6ed709905e346e59189f8a6ba722e9becf50db2ae89bc1d84b18bc9a28d78cdc1ebf3d5ce57a8bf5507d393486ed2e2db64b5589af6345a6e7207049f1cd8457c39db15c6ba7d2fed013127cc04c27008cb6dd5c0735f0c96e2b4943847b961068b5c8e13391f151db62116e583daa16138e2475b8a664847612b083e22dc289c3795d35b65f7e200f03e7571c4bc844a49be7795c9c867de2f5861bf6e2821aa2e6cc759be3a65e5d0ae98928f72a99b95b8080457cd313930dfbe3aac4449b76afbf8bdded6a519fe33dfaf1932af24570b45f5f2849d9d2d26faac09005d2a58d1d0d0cd8c670185003511f05e40df8d2f1c33ecbde6532c6ef0602cbb865f4c17eeed8d1b8b16c8542f218cdb135a346863f61a4ab71860abe60996d1ad3840ee213f38a0d5e6ea7ad78c19888eaa17bd759f74ae7406d4e435fe6bd112d696509a10a37f9c4c5b3bac82f8759f372cca92ab7887510c1798d0bc595af6d4e26157b0599d20a1d43d74e3c08651e2f966b9591883414d209ae6f50b5bd18541fa57b516a50b5775315ff2ece5e6b9cc8df31ce361d516a69883b27838df56f5371a4d328e0982181975aed373666b56faacdb5a6576109788fed0abe41abc1b2fd6487bf1176c78fb4fb709cc7e7e30dd49b58e81e46776f0542f3fdc700eaf8b2d2ec6dd3cdf05b9c323f15c41779317df880e04a81539c96da7b3acb7cf0e80f2909fbb58005786f4139e9ea4118292fe0763d0427d1e54bb825c44466fd2da4404b62bc518731ca62ef7241e163d1bce80d2b11aa418216f917109cae6292c3c4bbfeb5d77a4d66ee06399cb1ceb67cc4525b62cb9fb817e0be76ab7e5d40b9c96bc907bc92516a24027b9a0dccfe7417056b51cfe5e31366d680f8a2f7d9a9213cf2db03840b0c4f3fc17693157e05b6d90fba841355349055d74979e2060724405e25c1577f2cb0ea89464ac25592712b0fe2b555b4c9157c2dbfa9bf2754edf00bed0c5d606bd65f68d9878be49b332671f8c6b1ed4a1678b7ec8479591f7a2a53d84767df0c477d6a93927f62be899e5abf6a4b7723ed7910fb64683de112fabfdecae02c7ef72d595ef96c5ace1b9e034d8a2b65308c4f6d2e194902d6cd8c28f8e02150f6f7381f25eba067008abbbd644be2f3da6b65ae90fa7e63154cf58cb3eece22226e6d4a457b787a37400499efe38bd5fea3544dcd4ee365ab8336df38c867470577e18827793667a2c324480203e66fb43e4bc85f78a99aa097043cf97111b15ba37bc9e91ddcca5e53106e2b71768542227e735eddf66add2c8359f4b394c2331f5c776d68192d9a106ccb406216c01ca1cb17a69802679e683ccc025491a7f04a4f7f5573ee5430ef2735bceea7364de9155f2ec1bbf76ca9223ab1ed6fd7f4c12b1314ff82fd8e27bb48fecf17f20b2f46beb07a3f6f1924f3b6f938dfa6ef77177870eb4f03a2f89bfb21f4dc18770e3644d70581ecbd9efc9bcddd918e6749332411a9277c27f84dd9e532602678a0a1f18b287f5f2226384cf11ff02bfde29eca74d7e2e382213e942bfa98602c54ec68676b326ac690f48a95321f0f62f0e2f0276b2a6dc54ac21d016c615b0c08abf4bdf6eedf4a7bab18e26302fd95c7672956e17a2d146c57ceaaa8fdc5a324cd24a4e2d3a7211957ebff55dc51b1c2d1848d64852db508d8c163b8607f0faf2bb063c904c6bf9d27d0c8b03cef6017dc3145a145a1b135ea00607417276830d0b23314e51bc0dcf2854d54221989efcb5a031db69ef96623441c8c9cf53f04f0721527787ed98f3d0ba3cbdb36f4f260194b3ad343c537d7b2ac882166ff27e7da26ca6f58f18e6855c713c6992311cb5825a1353f3b0db7ba4a531af78d18edc3e8a56b6fb3a745acc8489c402092a48fcd0dde62b9267624e70248cdd5cf79d85843de6a69c4a3f1002fedbc437af634645ab63ce0372f51c47f26b7dfb31b9ff54d3f7f3c7b4f3051f3e14a08610996bd86a2e3b83a7e5592d0b01ddd8718523c5877def691cd2ab3d0373cbfd4b06862dfd37e7a4241c6d887676a856761a6c7e76482a9322f9c559925e4529e9894d0e542527b476a32f233dc739959c8030517c7e8ffc9e085ee848d3f0ee4545105eb461fd1f9c3ede947f74151bb668bc27533c9f4fdb814cc10d3b9c27d6a60f3e1dacbb6ab38b7f57cd665886b2f23d97c8fdd21c19b6964f932cd7c47aaf2f46e200697b2a0f02d027e03e652399c27db451ba891615e397ca285d705fe77db3c92adc512f8c58c47c515e459c9932e350fe10f3e71fb053913fd73e554d5eb0d898b1288a2791cec5661e83155dc6c4e24d271ae3e6a6db2d8438be043c858634d74c2badafab05240d8608960811b6598661224e0d383fb488eaa65add0a9f23c4afb9cda1b3761107c64c24bc686f83e07e5b772cd028d42e3aa1d01e5f51cae55cbb616ad0f35d46750610a270f47fddfbb985b65515d48fde72289f74e30d2d7bfb67910f5ac4fbcb50ec2e525101f7432c085daf69c74fe8a9b1b5daa7e48690e95b619314d34ab889a64a800a090600ea20710815d6b935369c26fd1741af3ee1a05717aafd68352db7fad170a9c5f8149aac16cbb7ba97eb8c4132b88809977076653a24693d05e8dd4766223cbed7675597ef203cb5336e7a748da22d4a20f3313f621f2b2a2928a8f32523120ab5f2949e63a3ec239930c1fef90ae688ae86a55889c7191a0e2fb33aed6caa3c902744e0c93fa6e691d65c35836737e23cacdfe3eec2650fec2cae877efa3973eb0f25d94d3d7ddeb306240132b7900242561c26dd00b7ab6f42131ad7b08899edf7509ae3e072093ae5b148008f7e25d27c2981609fcbec8a2f8106cc4a020f5347bee5033ce5e3fc6e62475d72f433cbda3e7973403e04dd41892395818f057d397d0f51d8b5b045240f2a6015728648c1d0dd92f318465994e172edfc9841ae5e792bec5cb43f72ba4115d9b77fd2c26ef8814fefd1f08e00001efdfdf0d8efda9813d761a90bea64b0255e9c7a3cc99e68f95353a9be2e5c829ccd4f382d117aa734618051e0b0b30402cb63213bffb6a22fc52cb5da16b6e317f7a28721743eb06383308201ac97c39ed61864466eafc0c3567260d10b887f98a72fc35c2b2f7394bd9775bae90d0b84452781d5d2d12395b2069ba0906a9cd70697529e36f01ba6db60b3531fcc55eb9b143f628270b4a7611bef92bdc59425cd9435d204ee8670a167384965ba763c20521d8f8bf6e46e669329e4db625914f1164d2d038eb8b6d6098b4609948b439e64c21f0a7a5f4e0acdb0da0b22525ef582966ee4207c4e02f6619c28e6b7a71480efd94a4f4316b92291830e382112397d3def6de9fa31ee4e4f7f6b0ff07242bef7f0bd580e2cf5ed37cf3b83036a27d56c009ca2932e5f86163584c800db855912fbab0f1a7db71d6b52a2e0921969fa41b1b008f7b41e064cdc17aabeccce70403685d51fcfcd0a4119576985c61b323846773c091612b8909348d80394e52698b7c013628d95b11ffa6f96e6a198b9035fe58dee30a64efadf7a7d9f7f1512b4","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
