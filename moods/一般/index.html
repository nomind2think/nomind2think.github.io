<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dac9338a10a887b4a4c77a66a891dbd10ca058319af990c56acbb010883208201941ae7e6986844746a4af1958232f4a53b6e9e400cbe5f8b50b1832df077eec61d6eb1869aae4dafa5dbb6a52653e4f67de965360fc95e626367c35ac9d6fa18fa26c358acb3fa0cc315425c6fb8ffb4ee27e1a11f4df322a581320a470f4b40a354afc5be753497e402ffcf4849ce4bce01ebf3ee3f33c5b59e787944c20dcae98a129d4b3e44f0ad6d8f69edfefa30f7b024a289eb3a5f3623ff8b3aefdae2ef508bc907baeb9df38f0386a5fbb5416a6a1301a0cbe8baaaa04e73fa1501d11372c2ef27c2c717c707504e12bfbc7d2311a00c19b4bc527f561888bf8a4fe49070b0bf4799d887f9789864c0347cbe82ccf88db621a5848fbd646044353891cb7bc604ed95852f5b0f229ddbb6dfa4ac74b586eda734d0566fc984de30a79802eb454e52a1211a4b5bc3a3a473c24e93804b1252038b1bf4a58601d661beb09ed52a5196b37547dc693531bf6bc61758e08913382e1d234e7a69561c4775a37911517d2fb591a605572d0dfaa611b09a20c5b5131f170f1e6f20a37eb096fe8141c72fcff5dcb21652280f5ae97285016809d1f15ae23b3a3d11d6fd7a9fef3c0e1d4451b48084f0da4c82528cccc52d72ee5104ec0308b0faf375e0055a3b3b62f4bc0832533c4e72856802e40b7cc6f118d51e35007121e4445f97afbe7e1a8c3bd1ea4a0c21dcbc9fa4ad03ae965aec3ba766d9d40c988a5f31d9008499a8925b50f2e7870763410a4ee055343e0ea50fec71daaa90c2fc2c6019ed8fb1bbb83831da0213bc77ed5be238fc5f601c51f56dc84014ee56f7c5bf9d2dc0e827613879fca44438c3ac5e52d2273072b92b762e31b55f24ba2518ec51f475129242a396ce4bb99f506674721167b34bccba1654ea1e5261009d57d9a2afa4efe9ce714aa53af4e08e1eb0ac9ef2abdd349497910989b622ad89465cb53943a8c314530b24c06da14d2cd0a39d13d53c9377c42fcd100e823551c679e101e45c17a899df2664fad04339922ecd52339968374f96913795408e3cc91fa0a6d3aa48e8cfc886c4a93364c31f71ad88ec3e6267fdeed58d0b3a4b8f3c52f3ee05c9c935703f14764f8edb6e61e270020e30c3b44a6b49e3556dc36ad9eae9cf130572f5d27f763c320c8b83e35f18596960ee13716f803ab6d5786bfa633ca51e1b772fda1c6516346270ff7f6945d2a3177766e82ed4d62b11d504977d279d43c846d45fb80b9240fd7e9863bff6ff69fcc6d5af731e1f1eee4cafa045143b7c4de55416276959f31a6e617aa941ba7124ad3cc522bfa1ab600e472038a8abea68ede9627facd736f8147ef886f8fbcd55f8fc9021e2eda3fe95f6ffc82de39c0d4eda66d26854ac088c7f018ff981a0313be20781dc55cc5b1fd8002b6e8697622f1a3ab56616104702f4c05acfb5850fb055b7a876ef5502f13539d4a71de8a54f01b7d50dca13a4b5eabfb4137ca6e306083f3980cb0acb65cd26bf54078cc431930d48984c2b1a8ef1af94283a6086d1472cf240c6e6d48fbbc068e46aed3ff4397e4909975729a538465dc7f96d83922de6103ff8b35dabb49dfd5a5f4821f9081f1b613389c0cedd9d1fc32c2577e3c6e9267cf18473edd44a3cebbfc5c44aaa95174ad32249bd4a72fcc45f871d6908c5565bff10df4ca9f88d36da15cfb8475d4dbb9cfaf943eaee670952299fcde3c6d3f309d9f0d034fde167e074bbb609a312937f6824b85c021830605fb754e0f1605ffd3262c6e2a1a59fbe51631ddc70957c5da31b0f8e16e269d1eb2050bcdfac7b5162e0b3d970b02ae3a5518c8aba9790e955a82e1cb2ada668ccae71d65d79bd5fe043b68106ad7cc918f8f051b2766752de25846e7ee19d697a42441e5f49b094faf6ee93da7068cf93becc60ec476ef6d4ef3ff0bfbb0f39d0f97d79765efec3e0890ae72a0b66200220ed87973bdad318e72a0f06d70f7eb7e9cd118671aa5e82f4627ee0dd98d63cf1607c74a46181be664ed66390fdf741c6fd9d462d2cac1b9b9d14823735253ac7d500cfd99ee9f8e36ad98c7d230fd63a7fd22646ffedd85091cedb0bce07fec81990aaa36e4abe87577ba916a9c6b09e6acbd4b76e96afcff1c9b97646bfb549ba06b73e36fd7f5e193e48f37299e300975952830b6072a42f2b5b81e1de55a3dfe83966c51604bc24049f2543c4ca64fd5d9195e209147ed3f15543078c95a8d80ce7dbd758408e91438158eacfa9d597141a4e93fd127e6ffb0ed1e39f79fadd3ab5a6770725b4c8f17ecbaa232e11b2be89eafbb2bf1e711eb1df517b70d0560ec6d2dc4c48d9ea910e3260548a67f861da7448b37e970a5cf93b9a1de0e129f98c6616550b1be30ac62f6d21ee502295ab857037a6b29981ee41b64bea44fbeedffbd6a1114d4ab1ccc01a8fd0fc25d4a7368d3c05ef3c98e3de125391b01ae4d8226095ce96f78b78994eea0b3fe8ebbfecf8a61c7fbad29f06456fe5ed3919fa18e463b9063ce660dae36c7e2d6769724d879fe7a44482166e5119d7ad24f07411572fd68f6b8534b88aa97e08a086e8ac1e8fdfbdd616c80807ce83492a3b5ad710aa85c27361722aae1355879b5070279cca0a86dc1a9e84d0b2b9a9bbbd70815a52d4ac4f3e2884a9ba6c30142dab32dbfdac750ec18fcb450809f2da1bb848897afabb54cb8641108db22a2dc16394102e9b457cbb7a8cb26eec16cfc6eb49182820bc5534c5c59ea5c735a15fda61bd33ed2a1a80a3dfb9006efbeb79931ab96ffe8c6d18fc128a5e409b1a5d892b58287f2b8aadfc5af0d4a500d9ccffedb42374cea5d1c933d2f697db1f9a9dc1651473531bef3bb3967fa135dfaa6eb974e1e7745d9e70fef76df29aa6abf0da1658f2f6b91115e0d594e6816f1ad3fe8ff962cf417322abbfc77f763c6dc613e566e892fe3cc619150136d1024fcdb723f0b389befe39f6a1a9f9df52ae664125c92aaadebf4c8be3d2e8d88661b42a7e97c8592deeeedbe345a38c115a8f714145355be1693aa362d908f41d22600f7ba59be282c716236470423588ec4f5c35ac540e76c47a2669d9990fb75db16c52dd2df6f4bd261fc3ecd4244fb69342e3f3a2ef77fe7bff54871983a893b30d7df5bd60c6cb910ad6b14abd59052cba4be56e0ea740548350e7af93afc56561e06ae33861ef4d40d2f754250ed3cd74f708ecac569300e506fbfafd1cf4d9163c24c1014629feeecc420f8dccfd6ef7bcb3463503a76903f04179d13f61f8752f68d0f40599122b0820c0acbca648d2f7e4da4b8aab5c562965230468f69e0e2d63a49044a3f69b25bcc7d040825275dcf32903e183a507f4bb205c8eb3c9d891fb49918d62ca5a826c58e65a5b09fa9ebda858d344a34ad8f7d2a4cddb1a2b83572d664a86135e2a20398dafb1bc36f0df6d4c825d8d2d8e17ab61f30cf1d41a0cb66546a8f8bb1a405ed969abce375d116837492b8450f2dfbb2c18b2613901fdd18d0d7c3520dd8a67ecd7561e4bd2aac5c4896680605751b4617c9aecbc159a0c16326738ef90e820a89974260b1a363bc9c0fc8716bc67eae54556adfd6b9cf8f72bd8fc67d1319485ddeda1e623f016002f3cc466a49a94183171198a370618d96d3781ce37140a9f882ba1a30d9802a761e2ac8d410d5621296da67e3d8838de75d54023a66a98c2871da128e84025cd408bab933c6bd3af78143fa737150e854829095b54473dfd4b0223c64bd02bc8f5d4d666d10c9126ba1a6d69be2f34639be90d3f39e6830b6494704d0c122ea05ea8f2287e2087b5938b1f4efe89a09607c9f066c5f18c9c0ee7e0d3fc2976709886ebbb678500f0dccfa34a94cbda5f49f530e889392dcf3828a80a1bbf38a169c5ba6bd62213c9b4602d240f2ec7dab4567708c46a9bdbffe0492773ab3b15a824462f1ccdda502ed49d993e997b014613d5890e77600703c8865232d742ca004ceb4fc7dbd902e21841692b4bbdd117dbe8ac83edfbd93e5e5f406663c6bf0e699ccca24aaa4bb809183e43e77a52d8514d82ef4e00208670af230f7af46904ee896f75aa06d9fd6fa2157563968b72563f293a7e77becd17d8828c84d89ba1242657111d8517768adb7782c21335f85f1944cd50cbaa46ceb0d26312f3aeb8f4b078ee9788f5bbdaf1ca5c83bb930ffebbc04d8bce8e221a2620307dc02b15857d553f83b6ba05fd83dd1a5e12162d08810a3e13680c2180a1856e8114d76052adb6f9f73f1654f33edc8b8cdcaa92dabea59b6947cceeedaae92170c7215c9120c2fed26e2dd95d2a131052a26ce2c9e06bc13fbfc96efae97ba4dd135a42dd9e06f3ee6b15268481bf0bc2072a5e1f4eaecac66b20016aee9f276be5d2c95afe9b2ab2943d1d055aa4dc49c94953be59c5903d761f6117a9f19d29c58d3fa243251b701f70bf5c9dc5d0236f5059518f9082cf6c4bc8144480ed7ac3fd4ead0904ebee8152f08d48563dd523ecf481e70ff5a3f8b13d806890be10ee22dfe68753145c027f8b41f85ee72960b69e510df14979e5c2b416124c472f9742fcd8813bd5439f3709c0bd6aa571214032a32ee1c7e4ec9de017291cccf8e6cbf3042ec7a72d33fccb2edc65e75410d9cbe46a02cffcc6a4e922fe03af1d8caeaeed8ecfa5383db35236b0dd197e85bf606a58a6e05516c09c5855c218128df6a6634d0999c2f026c5fe1fafa4dd0caf18a8fbbe47c416072790b5f9ed2a8d9e8b5ef6cee786a4eb2661fddc5b0dae38218bd53ac633c23fe6e2b99e32545c883b059680f2bbe5ab56d7a3cf009c61ef98c6d71cf390fe154e10f00700f58221399a7d8d0e43b1b1d30becc7bfe6e3836385b1ac6663e5a837eb25d9b5844115cdbfaa8aa60b7034134ed073a660580b59742c4c933032715885346560c24693ee1492397281781f3887393d30b9c30805d747c345ad83b82ecebc97895cc70b33ed2d4d947660c1e820db9b444d03ec41b5c50b6b6e886e2b5c4a90722628035929cebb0a99d2edea885c48818940eaf00ea7280678100bd1d023e46c54e3f1dc793a11a81801522a9ed270be741eca80aa840e655c7838dee8eecebed1b728abee7593b9066c9c94ce87f626264a2abe9cd62549c7e5793d03be6b2a257e4893eb051710b5296f4c786483a0439cd4a86a31d341498d522c22d0a40f393a669379fef2bcd8c261fcee3d7c0669932c066983c2bfd9716c11b1bdfc36dbef6886b3a10ca13eaa95ba4304bfa4e34d521c826c75449f0d1894fd195ad601b5485d541e20978a6818a76271ca00304f677e73bfc9558d1e44066f60d8e4ac323b69c83ae9652426457736207dba8a9eae242f60ec6dce113d65075c95a69c85724b53045cf13b27debfd3beeeefbfdb5d73fc217f5b70a4c77ab1c40cc8b364ef73ac03068df33b46541b5ef505df1c71bae89002ea6654dc14500c794a2972708b88f365c981feb4627d6029cd4eb35a65430524ef07d6b46e43149e6350918426f19fea35f7afac01ee5b45375a19bac8d12b1e06abc24135af969f600af6788210043feacdbe4afbe9bf19c4760d31c1c704ddd0c2fb66ddfef94fd789cd6a97f711caf126dbeaed07bec850e4c2a1f47680b6d2008b6dec26770928cb70d6c12bf4eb312754cda9f8c5fd7936fcac159c07c67f8ee99fd6f8eee97f7f761a309025d116dafd5bd8bca2ddcdb9d76d615d390511babde30e983c2d654a1c0372ee94b884820caa1562afcb107f1479a6730e3ba0db79cc6853dac60b63149c39b7b10a9470acd640319c9383fa9828912ee8eb8bec1ef3b56830a0d5280478243e66339c7c843487aa50309d433692b29276940722331beb1803d0c70401b22f98cad8a4d1d167bc27d63f1446b782b052fe62ebf1c2af54fad2fb831aef8df5dbd86ed6d26160ff3271e4acf3b1c1bdaadffa1d1904ce698d6ca076af3674a7be866c2eaa7ff1637db0b7a146b4ea1da263729339bf7783883df181df81b7a68d03900f433d51f9016474aab9f39e45dbcc8b3713e17a45d80f387bd7946830d3d643e6623eead42070cc3e704053aeeeb049a5822caae0270d683e026ae8182cba8bfd6ec8f2e66443d2c0594f4620c11d028eb49899c5bc6e7db98d67716178d4e74036d3bd8330c280a46ce6f487c3db1c465c6da1ea8f1639a71fc657490fc569f45e81154dc4d09ac05113641a94f740e72534da81d3d08aaa15841870108723f3e3db38d673c8afb7b470fccff916e2e34e2187bd4c88c47f84eecd95b19848d8beeea7f4ea3fc6e36c8d11dde71cfbc14d2957c3bd6a156e8bb2be46960b58621ef8cc75e54a36b57ee8100a0bde4c5ce18e0327cdad5ea1ce8f4acf39a80962087e062e67f59648f67fb6981e4805650416665cab20ec815c892448eb5d733b0d9303faf4bc72f0f6da9c00a0e31e299904fb620c5a51f2eba9ddb8ce85fb29b1c1f9f239870728d207bb3ab9a7f997c2eb5eb65cc20897198a4414d959ca31b2e9dd67f7d3b1bd222a64bc0591bc087badf8a94053ff09059014900c2b1c9889fabb2b8ed0cfbe33b3477470194d4cf5dae84514d8420f21744077937f3da0d345ba913cccb9bcda6e8c265434c8b9caba2243acab0ea6d9b312cac79784e6234e98dfe121f48fd67c1fcc11949969f4728a31fa319f6bcdb1ecc5db5abf8ac4d75023897e9abdbd8f45c269d2b4ddf1f2f549993fc8f0e1b77c932fe8d9966106cd2316ace5e2e2a76fc3de6f48279ad086423b0995e31488cd8bfbb3a32094d6e25f3138cbc7fcbf883fa2fc3afbeea3704a7361505fba274893357889cb8eb965e142c92cf4c4931fbcf3f33b00ae85523416a6824adfb8250e9e70d31237d21dc11e610c03f913a24a5c226242860b76ebf0ebf7b85d479388cc41f17fd5356803cdcc974f1250b5f004d6f5aebb609dd49dd199b5d1fd0497ee8a3ed6d364c316cddf5a5847c69313754e8018dc4e2485137f0e8fb6d0be8bdcd00bb5860ce5e28b2ba2f008f92f1f8a89d1717273853db7c793a15c7af82d6e7fd209c64ff6b7af88a413879c5acb0934a11b498a35729ab43c9aa409b8897ae944ee88a554d712dc434ac4ac95faed2910f41a72bffa09ebb1d58c5fe6698ede06ef6fa8eb08c5ec2aafa0a6cbe5c639f8ab1e1cb2b5479becc9551f1d7ff726c5eb9e1ea68a717804d92abec09b8d440016e9f8aca02079e95d0839ed2b2f96b344a909d31c53c14d2de96b5478ad6fd1f9c63476245b8ba6c42d025951151f347fae02627abc373290067167274d1bbd01c9171865aba1e43aa9d3f7596ef040d11784e8e52610a7f7c3f8c440c3074eec1dbcdb2ded5601f6462c533e1232678171580be7f7072278197c97ef937545e313f7b83c402220170da1e91c6bc5a24874741c2acd2ca4655d9fb75b39f16b467a2e3e5b138fed36ee5b58f2f485e673dadf3b0f9c4128139e714f379eb2b797d4d1e1a97ea5c1fe11b95d3c00e6dc89acc530cf4f46cb1cdeaa7cbde6924dd3343b0b0f6d9f50ecb7b9aa79c88cf625e7405d307ec387e03e89148dc758063f4efffb9ed6b25767252dd90af7f75f9c0665ab894d54ca92ff3fa33de4ea8bfc96754ba5720bd1eb148f3363665fcac2dd83741c174525d5c186ad4a89521bebc028ed26906982a17494dc5cb32b879198e6c51a333098c797ebe9f19bb03cc85de368cb779a8aff45c0543e837f837b6fc5bd0b83941cffef43e4778e2762c4b60c9690931730a6ac7659ed592e5369b5ab01ab710a2b2cd7c936b58ecf1d307c7ce93078567d36b6c913b64a813c69f153e30b49961bf5ce8cdc723b1f7eab7e455ad240530f0f9dc804e5de01cda60cbc4571a4428cb0e049aa0cc74dfee714b456c6f9d2b5d05b9d35c107210122f48aea2ac8aaf24a0b0cd5019f9ec75cfa53056a305c9145dd6240e12789b7b80124e130471aaf4a1133636054edc31e3e5adc023962d31e7bdacda6094008ec43df74b0ea2679eafb75a2996be2dc926f63f440b861cc47e5424502fd80cd32b173e0bf6496d195a7d248284f876b60bea6e9f6fac59ce4f71afd3c5904742d6b5102c87e7584326bc66edb45d5326a4da430b0aa3c982b2c6c6b0b9b45952d0963f9551a38328b8f30c4bfe6c78510bebebc59053aa31ea1437d5c4e82f4e63d1ddca2475358c916004a9d9098dcb8ca47d4af6722c399dbee21c78cf1d063206dd8528f30a3905eb93379990b8ff180b106d998cd457670a71e51e3c4571072ce043de04490bd3ce66f0572d05de0d7e65f6f4c7707c0e3b06f0a290ea4444a87aa1b16db4d11b49c70d05f02672bcfeba6503ef1fb91edd9b60054f768ac3e7f9156544cfe8d811ab1d4d2752a7c0154a29302c4cd0f64ca87ac65dcc5117af5d0adcf87bdab0bed1cc25aa12a1cf2ff178220c0435f79cad091c47156ffa4bad1142ffacfc8b1be0afc0268170aabf80d08eb9a93e03e177ecc7bf538fb2d14ae6eea615fa2177f1f7255256bdd7ac5d9eb0043c862f35d63d50266b5c1fe08c0fef2dd7d0c33c7f5e426ac268b9d2c2957fc040dee0ecface5012f4ab81366b84cc21bc57b7ea78a5a1546573c869abb376ac5505bea52418b56e900dd656bd72090ab8157095db27a19bd4c6bff0aaa0fb809c460fd755a22338716ec93aa3adb6e122bef981a7cafd40547c3c73a83c234f41d0690f7864a9991c096efbb122cfb1e311f4b6d40cf07240acfe58b874b2d9bfb5a661e2a62444ab325be7518742214645799c7f226240afee9909e9448f490a3f83e738395028ff3572a3b066c24ad62a19e3efc57ee4522327b82d9ca5f98b063292aee429be7f797ef13653dab3bae4e917a297a381dc2cd9958ab26b3db330736539fabd5ade5adfb01bd581a93054af4ee326a6252a52a58b5e7fe331a46c9f1d6dab34e264326f57d012466fd377da4f86a9ddf2d7dc4899014abfa0516f8c0c68c097d43fe4ae09d8793e74197ac6f7c609dab97811a0f0adf833ffd33b22d94cfe9a95207e8d344228f2cb82816fadd8c2557265379fca5c6279ef74b16e186f79dab2b4d3832c01fc50d2dcea229e184416542411db894794eb7c0efda5a8d696023e68a491d4fe02991bc12b22328146f269f6332e96e14b6e5f3b538818d957723352e059525f1dfadeee27b1af793bca0a6d45d7dd09e40ca7ec76caea0f24fd98cbed3f8735d7806b01917656f694e9b6db81cd698b0b0d005feeb04587c927f6be188569d45f1917ace54b8c6c0396e046a4e3b7e92f0844ecaee623386cf603014ee854ce9f77794700854c6dd9e3a06957a6fe8320fddb21e74a531f6e3ce75d5f35a6176eedccc0976660119aa374d933b9cdb8aee33b799b45c4ce3d73500a620ea74ac4a7a698950893134e9eb97e686a4d8cdfaeb8dc9bfa0d5be21d9702f47cbfc4210f5187ea8f63560da528336d213c651b552c7597bcf7fe4553345ad9376cc1ba7d22b1fdf0f757f97e5a02f1645ef0d65678263b57b2db123ebd72c8c7ec3e426d9547607fe290b059aec0e985369f96156f2502cca50eb7193e73f536e7a2a07fb12f05ba55da80e4d3a74a923dafc6dfc001c6908c6d00d050c4eaa4548b629aa710fe5af897d199111a81b15d0599f2fb5d531d2a1532a1671e321677495fd1e0189c947fdcbd653d47ac44b16591f4409b96b3f1decafc963b7e73d8dc203b28055f3aca2c929a59f7301246ab6b6316fd94592d3ca62ccf7684a7beac02c8d3879c65aeff7110bbdc6211ca694437b792a8108c5d28f42ffa55330659c3f7c11d2d091255eccebd0275175769fd0be42302b028c28a673ddce1fbacc37daf706c64b1f85a4d402db0b97f0f9eb820b040b0a6555b05c9a24af98e06a2251022e1f9d06dab327ca026c3e2fb0765b14e6e1542e5b4bff4e356f50119d7f286f9afd438fd3e83bc81a04754f90342dd2e88d115c73da8b8351fec1d75cc824eaca22217d8b1d248e357d7a3178eb8f90d07fa969a27fd43f4d6fc5f6719fb999b3c832b49ea3dca16d2b75472b13017633beeeb24d5a988c0a5e45467ebe83a48f5ae27f083903c1e19e366d11117714f81ead2e3665af22b0a36c8cf4d71d9d14b54788deffc493334aadda90efd7646d74f2c17d7f15ab03c18da4ed007e006d7732aef237f2679c38eaf9672958d5b3b75dad86c6ab1358da32a2c2e0224d04acfdcef8ee35a32c2d697f63417c378175d436af6c2335606b9599f060b8f6edbc5043759d6f097e9d90f42d6dea8483123feb701b5b75f28ca08e38077f014c59a05e753e29af328ca7e7ad3b031fdfdbb5bd2b3b8c7ed36206c828edca096a0a6ab881437c28e9f066f19f65e5f31280a63b9b4d820fc3da162ec75ecff291063a365e36bbba13d571b82836b592307b5f2bbd08396f66a2ef06be7d03a6c945651850784c67c3fb39044a223a583c339925662c077681c4af8ccbbfcc2fac8b912cb638af9fa6eb3a1f837e7f19d959e4eb018e6cfbb616feb2bf0789e3c7d39ff40b39871129cd28429054aa4f4467089225d50652b09e22159c1a844d86481735c1740e3e81ee8e70f9ed7a8a3b63c3da2f769519b25d0ddd0ffb0f48d84d19b19c23c1d968588cc531fb04ac7a671eb2c053b5dbe1e197842a9a79ae50dfe91f58d2211818c60fdc8e5d83739f72843880ae83ca9ace9ec5cbfb9668e95a2ca6de14915cbade40016cdd1c8b753fb838f1bb28d1e3e6e6c702c77d1b280237108ede22e32867800399a8f57f633d020095d9d6728b7caeaa526005d13653506e485f5d691be63ab9d7db217a0574b94a76d18e87e0267f548afb25145e128756620431fa5fbb8839c0124deb20bf19d71bb085dc3e67fca753cb2454d6c1f61c07b17147d08e70afacedd3281306d0fcdf7657956776dfc0fff1fc9a18f89678da6eb7a62ef7b5464f2b7685e24beb7804f9326ec558dece01da88bbf8d66bde75e859d7d0324bc4aca9a1393ae751593acb8632ad51b8899c0c09120e27e447518ed7db834e3b85cfaa5a6ffe301f41f650fd159fdb87b2f071173c826460ca76d3d7ba2770cbdb11924a8b32062e8fdd2828cf75d5d7972d8acfbe75bec5b7e9d2451f7eb581284b35d62d69d1d55577749b7ff265065816efcba0158887d1cc72d7bd6c2a0fc0774a3475080c6bf589626727ad054981b38620fc6daddf267aab61459813ba6bdf3ee29731f8dce9e506e731e4c42a2f006e326d5deef2fd0db1400eb5f82646bc885ed45d07f800b8166243323224d13588d2336dffbc548ff26f5e9b4d613398d92b596f0734a1403a758398cf9463d8e4195d190f8473a198f53a0d49c9ea13a9e97e0a23d73584335a82c9519e54a4f7228674d0ce0fbeb8b8ac0810142c652cf386b2eb263ca9b9ab7e2b2f78a3f4c5bebd1dfab130d85f01b20d0465a723e98e0ec9bd7e8701dfec08d288f941e91ad6cdadb8b158fb15d4f51e853c4d7490f35b51073e42d9323abee138e58444b12c1a04c832448e699abed28a5590a6b1c8035b53026b31f272d85a82e471d126661e4a9f13e17ec90a9e4766e872c86d9b0db1501e9884694ab627a39c77c2d3bb4a45f6f62206baedd4541c8a50840610d2f9338e2a3c408feedd20dad5a7c6a36aecc4d523246af1d5c19b0f1c4a2e74487ecdd7e2daa797f6d2a55afb814275c3f70663188aba2e865caf94554534ec2a936bb0a4bad98d7193069023b5e94310495c312696694d24366a3a7b106ff0b4ec988b3bfeaab886bef1f2aac6d257440f8c5147e5ab71318ac3662c7cc9d76fa2d056c34893c60fec54bfedf838f4f7670509f09c14a267a6bf704e0e795ef6f706f31d2e4bc90ce7e9998e438400e320569218ca6324587ee8c0eb7be05a5a2eb6a60b79bdaaa83fff4365424b86764055e9efe492452b064a92d516809a8c6398e7c419eb8e5c7116aed47532dd617bf6163b2c3d2e8769cb83efcbde32ce275a1418deddcc45ee8a8d952d3a6f3416cf5220704d40bef94077f036ef117262e59974440152b8799f9d93b742f6824f74da279ff8a014c4aa44b0a32","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
