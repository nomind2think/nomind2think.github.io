<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c156ce96fdca64c2ba8912f64910bfb73abe4fa9f4a144cfa67fa103a63ee2d441f03114bb971e180447b9e9a765033ae02c4176a2d19e345a76491e71c454878a20fb79c5916ea826059b98808cc33ab1103c736bd42da3e6019e2b431c4718f30be978e3d6b4effdaabbd9937d39d0ebd3a80e5af73626ca8bc2e90662ffc093f39797e66db27d0f10e546d80d17892b7e5e873b829b425ca344344bc9c9b57a6503d71e09198f23e0fe225222d8e8a46ac512985c34de63685e7f9176ae9ba1f48386a41431fa5b2c2bb0087ab1123977347ab0621d5f0852b51f65abb327f5d8e01ae178014fc3e64df999a1432746485ebe2d85fb6a8b6098e0cf3103b8fccb5154bf3165d613f5536ea872f99c1def9c4862c843ebaf5e7096c48e5f1351ea8826b559542b157e09153e15614fc966d182bb088b2e8ccdd11473c72cd9d704854bee0653f42bfbee2a262dadc3eae90f9280880fb1e00ce9548491efcf31d9eb90f8f8e1a23a497af8fdbf4e391faa33e6da85df4900bbf3875fe3e29ac27316924f1c317e31a6689fe1c638440fb59ffd709247affd7dd397650772cafde684122d81f098965eadfc7d125c7797c2e7f770d65312962c2d9c5cba67a6931e4a7316ca37415c7aa40d40c8a3ccd09f3b45b019ab2669fbbb6459854c14749f3ff1c0aa8141ecbc5567f3279668bf35bf6b275f4e83aaf50ef32fa89728582597c50aa02bd6a2f80a67dad1605ccb67bbbd7bfcbb5815387dc9dce9fa77a8b9222eebaadd4c31da876bc0a149fe2b636ddf669b2cfe9c9ee17d908af0e9730076ecfb3883e55aba49e76fb181a7e5e1cd90ac64e7a3de1df6c8fdb077ba95421e78f690784a4a2d9838cee7b68210a892c25724feb8034b13a7754955a6e238896789c29af8ab24e3bda94a68a764500956b4f53d71e437f8584c596c6ab5d01b4d599266c0efbea9dcf4c320fa516389e7def8b533974a481493a70995a129327036b6b0e375536160e73864e45cb50967f1eb0cfb610871343dfbade679301b0e17bd95e48a727ba2b3d0aaa361188f9cc138064098610e1bb6f350b143e0793eed43e407a5d8793ea061768d966cb44f7562e1808a0f3633e2581f4ef4f44276efc3815e8e44406b01906b4c2f55e563ef80e7f2426d092737df1b0b53418c2fc12635c138b64a66bba539c1a6d5a366cc2e6646e1648b3b06d2f95c08da260614b4f8d6773efdb0b37f638b9296bdf9866aefcf455ee1a10785b33028388e343ae21f7e77b200bab017cf92c1c6aecedbbc9d7e9afa852b96da142ee883c991208bef0302640ccd27b5096f3d81dbee796d7b3af9658e09e9b818888fe2a3b4f09a4e4b7363bd8bbc92eb59b4107321fd123494c789f5237a218423c5b963e78274a4508483626d94d943b0e5b7e226c6330c40741bc811fba7a331615536571f7644c2f2e5e6aa73c36dea2a7f0a4472e4c0bccc4789bc0e44a09a02c86acc1eb3dd1c49c33484b0f78ed3705fedcaf5c8fc66a067209c3913b0a9f1dcdb092aa946a02456155ea3fcdab61927c99882396bec475afc325eef75f8c88bfad74ff3f9db1097489c8ef0fd223e4b5376620f799a6dc14a460aff577d5b031e0df5ec6a99b88b09125f72ab3c2dea313cbde2cd456631cf25584633c103eefd610815da83b28dac8eec683690240e2371f166f64964ac55a3fdbe4d9914afab4ad8bd0ab374c57355db2526aab51234010e36547bc8315b2ba62b8e68554211db396db6c781cf80a991012f6df27b2d89a0798be54b94c05e7659c9a22b69139f9d58d979f6a7773a4cf7e59f308acee8ffa3d2b43012a6e6fa7b863c896d82c3745ac00a05c0b78fae9461ff7d887c993636ebf745ff7ea1a4fede06aa44ff6ea67e8e5e92cbd88d034911400817044ba24ea2eecf46b315a7f8a46b491f2bfeb5208e8e33da9f706cd992eb30697433758c7068c7cb681c349669b195886bf1cc5ded583ad96b8cf11cb0eb4e772d1049df90a782dbff235b6c0c2edbafa457f4c91f946674c6059b5fa5995c4bab4abbc819f0252280be42728fb4a2c16e821826173ef02f9d4af78386fcb35eeb5764f70befceae90d2710e8f2216ec967afc22f0febe91b59bbe1c98713feb25f385d5c71ae215a3a7ae7187a9634ff4f5de320bd0d903072ee532a5afebd96c2ed40b4e0703002349bb7423ca0b9024ba61f326591c6ed95807d8018d655d4e69af30ae763187674ae427531ddb91690aa12af693a05b1f279108a1cb96a6ddd07a7166253f68b7981600c2c6aac7bd25598a6264f7b81776ae9a036d7b2662cdba371fe8a0de8512e68758b5eb44ed8c51180cd5878e333162d9eafaa113412b546d6af2a58e6da8f26820bdb412f0d1a37e3bbf572e9d1c5a10d48a0bb235ca1726e99fcc3e1e91c387e4e5364e24715a89492ac239433cc1b5df17d37604586e8a12fa72622af916f5e4c96760dd57eeb2f94f71be14de368975956f68c490377374d306b3637e5f242ab6800910198372a8e542f65bc4ee49fbfd0ade51354ff178a9832abcefc3580cb2cba0ecb29d11ee2f4cb7dfec54df442889f34e0a76cd54a2def3fa23edbd251a0a08ebfba7ee803e980345faba8b568e77e06ca3a28446be1a40a4d5a82b872dbee1215f8521df367ef4984055b1cc1766025516972e882e781fb17c6903251939142edbb28e1d07b2ea82dd17cc65bcf2111f424ee778524895670a21c57a868ecd4b5b2e44a6508ca65fde91d29bb06bb0459b6c2864e288049e40f3caaf151af300ba79702ca84003873419844ef9fd83969a8488555eba3cbdd6ab8970ce4e68b1132fed79cab94d53a682685cd9a701de55d98949a2c74a696a624d176177985f65dd5e0d97b4006b4168a3700ccb8cb025d7edb46cd270875a07385b655a3f57278dad64fc7b16e044fdbb46a1a791dea7b5fd176366a7b9847b923f9f8f76dd3eb9659db47dc8d8e3c91b74225065db886857eccc8e757b7555f0749963e3b5e489454c861507dbb05f5da3f4dcf604728b7870b347fd3f5fd708cf2d4e57f672caa5c4b861c2c6c67133ad201958713d4bb7367f8dbe06036b8ead11495e51471e25d593ecd3a5c0f84ce04c0b002856d242bd7a4690a8dd13efcd2839ad66aab99b4403d1b71a7d8fd8b43ddb88da5f0d5311956707f969880dfcd06635153b19b76af2d6692a974ae0796974ca15373c6d3261158464a4663233c3f94f5bca58d7e6f60114ba4fcb6d370da230e628f2b8e03c30f1cb5d2afb671bfe88af5e42c54d5f6174fda5c0b2797151b95b70d5cfc094be7b37b7dbae9255ae95c6b6184f731b4bd3fbb8b1303351341c4751ac1f89abbf5d2572150a371279214408f1fe669f792624ab7c369a9990bf7567b2613154f36b09b4dafcff8cb48d306c0ebb025d75c4bec66cca4fb79cc95d50133e6f88446ca7b6322b7a6a9977834e310b6a96473247af15e3190b5a339c46a603bd03c7dc13f9e3da05331a51ee94d1097b40a1aebe1862e7239f06773c1f0a483ed160c0cc0fa6103dfdffe589ed79e3ea75a8043e3e2cbc7e545fbcd393766695b0fbab1c6cd118408d66cdc68c88e605a8aae68b62f9c903d7d139b690e7bf5393f063d82df4868aa9de3fb8660d8004c1e0348acaf8ebb3f4b841b1221ec1230fb2e51972c21b3b99714eb3599eea1006f04ff90110f5220f8f79c65af87d7d9c908a36fa632ad30e5aaee9ddb72f0321026d0e8e5b3ccb05e32c3b090de7778e5343d9968c26b788f9185665013d165c1ac74ab1d03ac84965365d67fac9969b2f33e1b47d12571bc65be35d1d0ad30d025a1c81324007fe93ef11686b54c0a3f7fbf373138dddec2fe439bd98f2eee5753a0798544610f1eccfff3d769e23b9b36bf782ac15df8502700d0be63d481ada8cde2bffa00c46dc48123df8d93705afa38c53ddd2058f77575ae12ff395cb1a7d11e88e6561190d1933a4ef2ed4c5bff596cce0b7acf7b263d8c70c9ac4c0ba7b8470ac4f58ba3076171e9bef3b4a9fc8f965e20fd4bdd96549bb791c32b2361338cb32fa496d46989fa576fefaa852e53fe519b38f731411a4e5bb377452874be31753290851dbf8eda3102a50565948b22064185031a17cd5cfe53e6f95fc9602d4cb313e474d8875124b586aa5eec88a477eff98eaa9ec7477d733c06c7d8632d5a63a6964b01c332a3935ec10e65dbac164328e744a52d9cf215e5d6bcec0c7a0197775230aa1c3366b9e7c0943ef70825948bfe6d0a1ce9be9dd9518ff90e00c2b075954ecd75d52d6868ae2152f19d5925d29e4d4e6d884e66275423a076244540431813946bb6c8abec0207b5e222c79ebf6907a35a5f87642dd48572ccdae21926a0b876658d822e4802b85145f4071c37526e173505e00066aae9e86d1e2f01b403fc10204337a799e6eafcf81ad719676c81a0917e4bd2c80bf51b1ae7b7cb14d7c3742f52eca1ad1aa8879a941f910c8aea5ace3ce81290698ee559a900aef3c767a71362512ea1c5e6e58e673acf38caae1de6b03136703b8c3ed3b5be686b681bbc0256cfb052496366b3c782fedb8fadf1750a1fce665ba68aae18551598ff6fcb3dde4cbcaf8decbcd4c1fd81b1bb348a4bf9b54f8e4bcf10a6fd7973bf92fe799f4414ff5037987d816f8e434576a1eaf9452eb9d6e26502895bcc42d1ec3d8289ffd35839fa737bbe7b7fcce05b8cf9c310936d4d31f188d592eb82d210213231cbfad7b87bd3e073b44e9df089d825c88bb93eafe87eb15271e7a562ee6dacf1f8ed6e4121ecadb107b69bd8630ba9fa5b013e3b9f995952d4b725d7c43caf061c1024122c834350173bd51eabb7ab7f747978a55be7337336185854508531893e2fa515e27a8bf76f96558eaaf59b9211093e5141b17cfacecda9812fc53c9d3f2950b42c5027ee23d8c477b9bbf0b3de1110c71306275808dd4a4a142ca723792ce248edd0549dea789f69fd455c3f890363ec2dce890a8165db9547d133e795e5e556d1b19dd4ffbd010cd50f02472ea03f452853bc72208acd6b8acc6442f33e2c005bc9f16c3e958a51ca1917b49fea3b4595247b1231e73fce966435ac4cff5d67021ac880ed668530cd5eef30036d6176afe14a24cb78f97191761cc511797c1ac83c9f06f50facfc83e376cc58d376eb7ab909e64bfcb3396853e2b0adc5b7134eaf145f53f00e7002d8bdb1b636a23a23344e9047b786e4b3c19c549773f747b1301061333b3bc9215ffbabd1b29b1aab44c398c069f056bb4223a9f763e34992b0bdd116d00d795db2a3bdef21af87a6cd8970572e0ce1469e33dcf85c57d37184935501313fe4fa9ce8898680df89724f5577ebaea4a1896aabb6e4fd8545269ed655e22ea7d760be1430f708bda27eb05253caff4fbd99e8177a43d231d3a0eebebc1d05dc0d27ceb37a1c35ea5af24fc6a76cfe43907b062712e477b4fc6e9874979df6d1d63e03b670d5a54020621d0462b7428fcedbbf18c31ba6ddccacb7118ff216f650400abd6f56915b5b3bac5ab2309a9f46c85fb8bd51ecfbc5ca4a12a84abe43463ed69829917f2c50c316e68f877f519201b3e1db7abbfa74db7aad30e55ee2b824566458aaff4e8827af210d4c2bbc7717c2fabf9ba8dc69c0e7242b69c10dfedca65ad15d2defd534c22e837fec18e5359a5f712650a725d510047677f668cb7bf9474faaade4756a032e420af00b47ad2b138de3348a5fe82cb806d609e66dc048bb740ead1709a7aa42d290d93efc7f969f3a950c8e6a08f2a7395bd9a586709ac04c410f99ffb659304642ffc9b04def2aba4dc1e3d9bf98772c9d843d2e476264b5b51107c0e65fa357f985600e09eb72ecd4990da731fe3c55b2b00de06595416690d037088bb3f9389d4b1fc685c6f13a8d1c14b05052a749f4f39d2d9a163410d8086e7d5c39e300ee58bf1c14b92f98ab66b983c52fcc68d9b1fab85b03e213510a9f9517109ce23ed2b1003218dd4afd5ecf2942057817a8e11907079741e944a160318b9bd5dea2db3dd231c47a43b6345dc7c4d80fcefaf841288a1d616f3844b103e22c6943625de721dc6356f59c2a4f6b3590dda4c6de54cfb9d0bfd07e996ccb919072f4bd932a13580dce5acc5dad601606f11e1f55dcbebb81d478fea02df11bdbd3271b0ab3d695fa536a3e8157e724c58ccaa2c9fcceb059121d289e6302c45d8efedfc42d84f93e92cbac3b93d7acb7b0814a79dfd56480b120d056f39cedc9f675195684bb14375ea3730ab38384672ab6bb164b623013a7faa809cddbc658f0df8ad83fdf2a3c63980e7814f474b85c5af3e96f9bebba15c27366dcfe3f060e034c90d3501f46fb3bec51f6ec657c04e0c6a1c370eea7337d953b0d7dd0cef2bb849b93cbccb73d8e5ea05f785b4d25204049b8e2202fb9e1ae97a0fb4e3036a34e4479e5d43e974306549522f5ad103c30cb9d01ac4ae061978d24d8dc2549f35f3f3bcf8379cfd91ed9d95e44a0ab4baac9f7eebc444e867dbe6c126f9a6dee744b599e9d613979ab150e4cdcab9e1bb9f01fa40837d867d71a9ffc1b8c3e66e4332acb9b903c7616f608bc781207d2914963a720bff093106ba5e7b35ecd4dab2439a58982868feeac7d9a838f482f5daa86ab4ddd337b7723f3f183c2df85576bf074c9f6d010f12e8abb6ddafd8827d00c3144304e24ca0c546a782852d04df724090f257935c0cf70822a823af60161b1f8c99523000ddff55e4daca39328abc8bb3f025794a25b1ce492811e77da8133fab1c928103a18496d48134f0678d29c8a95d6000ec74fcc347c9c1ba23c545da96f3035d3f2db43fdbe5ef922e12b6ac50e0d252f47c7f2673586d435c502176fb0c7223e109df1614c40988aa09f62a1f38e640ef50bfec5cf76378230104e377db6f812e01e3e4f58c301ae371a7e397ba8cf663cbdee66cb1b365349abc556e3ba23cd294debd9b634da13113ea0be1e91584aeca47da5ff09c20c70774b5fdfd9408ec00135495fe51dc947f1cca6a4a360c9de2fdf6984383dd42b11a3b9fe7424bffe2388fab38982dc5dec695ce921c04f25c5fe57018f25ceb096c8c59350973347ec6c1278740a1a073e50609c731ed4f2c9b8e58961a6107378bbed54ea7a9bbcd1833fba2d6d584933749080063b0667ece5e6c9f03bd21db82a5be8d86e65fd06df738b966388c11d5b81e78f62748e08754613fa3e0bdec53014e32fe64151db2d8ac3b8b0869a8bc633c8ba846ec6874dd52c4ce933ed8708bd1118f2d4540d172bb07becbad1b25dc6d1bf999336fc6c56ac223483ce86d2760c577f5c15e86e8dbeb96d8bc2dae033c7e0aaa84b2477639bd98c9c01ebaa34561315f4f877d7be9bf8d2b2035babbbda6676d71dc6e67fa3aebeb373122d0363d28fb35a39adc6595ab5570acead60d5597a1ade443928ffd0db72d1348877a5ab9418fc5cf2cd3f3b7d2b44ad4e7a6a6b5355e7387f18651a47247ebf0eff4e068ff0cc25e9c34489af4ecf7f55fcf3286a45368b60deeccfca61d2dcb54842c610942d5175d556e539bfef5f7da7e77aff3dc987237a7b6b438626995252492549d44292aab446c6ec65dfe1f67a4be909018e77ed8ba24665fda28953de3196347bfcfc3d975c681e068a18a539917697fa7f1f1d7571b7d5a9b4135ef76b6ba1a0c97fe5d9ec560ade3d9d8339e35ad607e060d9872e31fef9e4fde278747042b5fb9e5b1c1883280ba3e46d7764e9f2b50bf0ca62ba38372a97c58831bdb4c1f05979aab9ae3250689e859ca83404c7515d8de2f988fee596ba7410d8273751841fb7b8efa1217ce5a0b6b339d58c922aa629669d1ad12406bb7e98478ecf847b1f9dcfaf3a68a2dae07b74e8abcb815031d32f71bcd8e56627db493d50988ae2cad92019a902a4a8491334457742c21cc104c34e9758ce7e4dcae3cf44b48d9ee2d6d93a4b2035f0d613a8755e63e7d6f0eec3c80ca0eeed207c0ec687676d8eff89ab0a50bee62d356401da95e74f8fd3470abc34975c6663c072f275718dce19f7ff7dae24a422f3214ac76c135abe72df3bd9691ba08a2a55c607715d8ea016b0acc3c1086acc737f06b56b4799039fe059a554cd943ff294c0acfd34ccc77d567c7a8d24493f60b3c08707f36041141a604e749da135933ff57967d209c48d3ae17564d7f08160adbff1f959b1b4815eae8f166d86a3f9c6771ba891db744c5894bcaefa2d8c8f54adb768f6b972ac621a27d1e452cf33a6efc921b9e3f1d2d89ed99fb4ad3e4ca59cf5a68c2e4a8f3553b866eb16f6db511896a36741fbf5298811434ba48e5fe7d029ba522ce79073a5cec187af746cde5409d9882d3de5473e2033b955ae8f614812101e6e6685ca826b092c4f71815d487323868fa16b9247533d228656229eea4742877f5ab3a87662e1390ee1c19da576e1a5bb27665480eed18f55d1917d74314c62c830de73a2e3985b70c72991cb69c5fd5e4404c6758401293cace4d85cffe3a58eff830f3c7a781608a97df534757e3e04a4310b1b682cf79f87af3e940603239ba418d0bf4fe0fd9c29df2b0e5d190ae41ed02e7068dcb914a01c5c715e2b1f6bedf643afb75d01940daac5a01a4477370f18fbc4f7359a940d4113170ee2148c569670de226c7b7d9060701c92d94c65ae93984e27e79a3d665fc78594de6d0f01e64eeb0291e87f7030a514514d52cc366284e1e5b4735bd91e6da9f867406cd78ee2d2e2ae2c508cb30d57113e7dc2e9481d55b34b9189a37ea66c2c702e205df93ca657313427600685a5ed1f154a7a59c1746d84b928a86e5d4d35b1af8a6928f22a32d01e63b4633e198109920774f1bd5e495a1c970314332a317b9783e728eafc876a1dfd7d34cd3e27a31bca0d7811edfcbb77c9f88be21918b416f2f88e7eef0c77fdfaed01d9d9f019c83fcf89d38533b3d085f3fbae5bb96df883afed1f204721e6bb5487fc1dd16833cd29cf2a2269158a6ebeab34ef9e59d3950bad42e77b74044b70266dfb1785d451f6b0012b1b7b093c349b4e081b2308849b8bd0602542e949dd70c929dde42bb8585079eb171e32ebfa3c200db4ce4cae4e1296e0d328d7660285c7539c58d129922475ac72d5b7cd629ce1d5c7dc4c84b91328950cb8919228a417b51d22b3083fb0de7bed4a9f11b29306b5617a9a6cb31a5d6fd4e2e3025a9201e5c0e148b20bd27bec5c379defa38e18e7325f0a737d867d500521b746d9f710097654a680759ed579dbaa7f5a20a8886399391e2c5b84573dbe2dba34c0e6ff32e0bbdd83eaba96f4336b49c36b251930b57fed48d8f87c72d497aaee8ff358e2522682d98ceb2043244ac5f3bb3fe15c3ca451df9f00466356e51df425f526a3f4654d36c77252983b45b724c0c2127a2ee635cd3c449ab3a85741f3de654bed4c23a377261a127b2f779b49e72ac2a9e8aaee3fa3a5aacc917063c3f6aa3703471e1200823e28bb58be54829ae1b3119e3a0283bbf030d1b673401bf33532fade7aacb855410605c61cb7ecd773d655959f103736ac4e62407135264f2aea38387b170fec63ecc85f4a93b112b87984ac2addf34507428c562f0dd2fe9dcb1778a325ddc91599bd7dbcdbbf225551aaa562a5fc42a7416c3ae6d231a66f295e5425d88ab2ef044360ac9569d64676b346d5f3718c80ec8501054b23c915f6bfeea6ed13434abef62a8dc8e9af340488a3d37218cff99549621accba5c4d2e5bc52a74321d3b9a0dd60da3ff2c5900935c8026d64b3dd0ab50d21e1eae58fc7396e07b3d7a7b35e42d7062a4b29a193ffc2b28e008f62e3c840ae52a057a6708a15385db97681a219c5ebd7df110d78cba6d783c322949c501ff38967f2ce86cae63545056c10c5a2b2680e075de82eb696011bdf293aec953c138c1dcf53ac7e82e40699036c84c4d883f244c78ac682c050a3fb4db708902eee0e082a89c55ecf269ba6c95763bd7b0d6711b72f1b3bfb4ec1730e2c63c2a4716387e1f0af95a1673a58518955f440fe0c6ea1a489654323714655581a6f2c5e95336aff6aa151d3c1367b9f9c5b714b20a48c8de8ee161f43fb5b958deee09654cce4ca989db2c5b85e678ad483844eacee06a6a04680530412bbe030519111ebfa807e2a4665600704f78b1f9e351e70caf6bb663b214b350b55d0af34788557216a6d3e80608589300108a9ed05c783f36b89c898a712fdc3f00732b83dc2bab0e55f8cf2f4a4f7a9370c02ad28fc02d9912c142cc3fce88082a6b572dec8a4fbdb3dcab2377452acdc896cd2f35654ed0ad8cc66405ec48dcb6d2869c1d9a636513e854e55677846035ed256a905c68adaab4e8bccd510df8e7367deeaf57d1301d1ef43bebbd586f2b7e424fe63206432f07a942f668a44859f4a263a415e586807f004c4421a7a60ed343c0ab0ee6e167c932982e64f0c69cd979d837b7eea4845a680565d9c46c0a7ce256169553167fcbba9fbdc4ae3bb6efcfce0601bfaf40c2841af7e963108c065c6c323038c33c6b0f1889c4d8d666c4b2147e9faf00642c5ce7b71349cc6e91c688f71b3004f5ffbb0818d8ea3c168c48644134fa8ba1a474507fa4b5695d37aaff635f501a6bd1524301d9607c7b28d60da90d745c8032bce6430ed6e1c97bc4f9d1168506adb07078ca3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
