<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7dbb6b7d9b042dcb9a2b0dbc15101eaf6ffe2d671a25b6eb9cd8dfe9585f681e14c3ba78e6afb0d4a9a6fa1f27843539934946057d1ae136fd9e4ade6339c50158ca437c2a1a5726da04428923b6340a11cb00184719a9307dcc9ae0abbbab2196cbf61a77e30019f78b1d38aa09cc01e52341604ae3e5797df28e096b68e814189d98275fd25cf2344dc53bd773627aa1194ab7b4270ca90a0038520bb56017c2b5acc269f7e7fc597dd71f6b586b0d264df1bb01b9431c728330e9d88789a76da6c879083e02fa360938d42df3449d822ecc034a6af9c598702a66c45bd3c806b7bb35e9aaa1d948ebf5d559f95aaee7e6397b75214f8dcf9b68e3c3b1ca2e386c0ab9f69be5a599f6df7d0a7017863d0c164ad0d6195c5ee7c728f96d07237110c745f9a04fe539ebbd5fada2e3ed36f6424a3a7dc736e94d39c8d263182b4aea3b4aaaad31b4ad0a05067b025911041064e7eaa4ee82d713acf17b2cc7edc573e537dc6c3a399d64c14164e3705636a56db7d2055d8fa2f0d7502689c47773300179fced659d195ec73ccb3e685630a7199b414c0f2363c72a681676ecd84afb4fc6df6f386d2c6e10a05f2e3e316a1aecd4b25b26118dd5cb4628923f6c7a2af733c3d7db0a0947149919739856765643a150d1f203d6038ab93aee9e6bbf9bca81f9b04c66bb7650fccebd48dc951495ceb13660d544bb4edc969c597e512426fa71d1242aa7d880a3587a3b0c24e25ca8c56fab58eb5480cae702c23e04fd73c79a30315115463a62593eb886062dbfb9d9696c9695b3bf97784df578eb9f07ae10c063b3330fc67e7d61cb4bdfced14aeeacb789dc0726e1513247ef961e9dbe410b27ddb00fcfbcb588be47fd3434928c49684f13d688e6d0f842d57f088dafb26e417cf9c9fd0796cf23274c46b4f5c9b8844c42940460930514a078bcbb0cd2037dd4f90f0283497e228d73abc274b01cf8a77af18a2a03d6ac923e68d5ec1674bf644703faf75a0ebc557c7c3c9d33189678a7f8a4848084718c7d220614ea79ec4b3a830e00e39f4faa081551cc18aad30138c33f80c68525bf4d56d569b56f86891ccd1545be1b01b0d5b4368b9fa1f832446340e88299b7ddc1b7a6b86b661fbd00f60c7b75dbd8b0f3de7cc49b83d7eb95d2408df00a39dfc0685c39c0ad47eb4022e284503926b31ab084852c482541aedd1cd9c3af0d66e3d75cb2ce56ca201ad7e98ac527addc53517a36b3c11dcd8d008e701983ecf89d3f318cf8fc3619ce44bac0141c22000bff62d947f5d0fe5dfdb2fcdd9ae590063071bfd48c0af38852c5b5bb63c0bfa60bdeef9b14bdd53a96dcb184eb6b5c7093c3c3d67a0af22ba4ffd066fd8e976e637033c6d0611c64bc9907217dcaee42138046c76a1d8a2997d05c2307ebe445b21b9f4bbb8e10dea7c14bff79f1c4ae11aef071cfbb1b829e84c98bccd0b470d9b2e8565c17512252c095bf0b27d29788ce0ae44f87ab591861cdafd94e45aea608545a16b3e187e71fc0799df38dcdad90eee34096d7304787d35700d5784a04d6d4a65009a1f716428c2db24ff78f0f2b35dc129db4accec775075ae7fb476b1cbfaae92630b2e1f1efa01791f6da056e3200dfe460fbe9342b0e426bec650ed25be5ce2e295b1e2251848e741b70ddfcb47f3b5887230c876d8b305f44d831bff0c045590b02ed45258543d50a6a05ba92d511614be15dc262cabfe38afe9ac1c8c41bde0ccbdee9046019eb60b784fd3248ff4a21e864207845b95ab586bd1c079f3131e63accc1b70b93a79a05d4d45466da8faf7c144f3211f1f492df67b51b80244f5831ceeb145e55fc9449884e655a188baec1e3acfc5ae8449011323932b5fd2089331fe7bf5957644ec45524835426db6dcf41fecb2388b46cb4f2840a291bd961bb2371c61b65c0f57d2c366d4096e23630721c5a6d130b84fd398cfc5f80b816b260eb1c8b29cc8db95f89d6a9fe3c3e4b49e0050ec21059181e9016b963c48c01e1cc0701d8642c5708ff396cd803bbd12b8eeed75a901abe80cfb6b2a859363b728fa27527f63f46d30b0b3147eb872d52fa59ca109f461816310cbdcdb099996d36215e5a1a6e1b5ce5b6a4d5efee29cdff6f9507b5f8f9f7730e6e5b219c29c869938947a9eb5668a712823a3d9ee6c35897c8898120703b1ffb2b838befdcd45dc54a39c0a649885d576b5b79048751855cfd93a2e660a57f75ad3619364bb64544fbe65e086de3f3512cd017e88581d63ce91fd72555dd0a0aa89481f1222ae604f764a6f49b84121627802c7ef5017d23d22f409729f27e532183f322b99791fdfcd9f7df0f45989f2ff13a0a280a1dc877d8b9bf777199687a959b3cfc3cbc2fa45480db713b426fda599a5da2f76ee5c6a884a92ece906df1a30df41ba998789850a1958c0d42e6d9d4c248ad58420c6e3b23bd4a6a43526c56972c1b95896e53daa8adefe129a988faa5a93af03d5a13659dc319dcfb0bbc29feb9781c4b5d52abf8872198d80e2589424b8218616f1d11c1ee128dd72dd4715783496cc8ab8f80686173ef8066ca94633e9eed4c6a63e290eac2f0b1e9f7fd487d9e87fe2d93788f498b2692037c539d37069134ede3e9f72858bc292dbcc2d613a68532130ae54d573e5128b6087d65407734755c077ecdc369b882c79fc9af7e654c3d3652d11a4ddefc461bb2a1d93d70a5d73b8968a0ae1f7fe18aec68b036ec49d3b15521d5b670433aef8f7030935380b856c7b67be0f087a9b2673f6d4d7ceed6d71a044bd19c872b92580c5a4319b34739031a11c3baf9fdf1b03ef145592c531da6b6678d4232e5d174ddd6c960b632e8af47f605e108c06d310bee3ea7bd8dcbdce0bc32488955e7dce995fb9cd7f39adeb260dd02dd65fba26123ee435619627c92874a63d5f70fac28550b9ff0b2f3e3bbb4375130fa0167034cb9d0f15032a6a08f9d39e8e31c4bac15495dff59976aadeacd80f1fe5f476d6b41a2ba98a19136c2ed2bb31c0e3c4d650ab167fd14151f7666676e344523a0acba982667f3393153598043e5f82e3c90338b14415f8a63da9d043c94e04c87dfd68ada037228787edbcd5a4647cb5605b828a0854716c889662fb90b9aa5e620095b219ce86580658033ea679da16dcbe82260ad204b576971c69c5f0c5d1b12ba5d7a1109472b0a8c41aebd8071cea2b189b8fcc0fb8fcd4174a36e735976badf41182fd853672c725d027d737b7719a60c7cfd0f2c39c863c9f408954fb991618d0f6ebd82226d5f872746e4815798f7686dc9903b942591dd97035d530aad1559072beaa5fa4bc59c3bfc4f4563a94d0d7bd60291f12485cc15f25688d07f14e8aafe9e1e593908707bc4251fc329ff27217d05fbaed2edb4da15f2b368e97f5f5601fdb2f9b7d8207639c95d16193b639b216f456fa7450a43e8a4fa1ef8fbace8f4a4a0c0310a6c8b175fa1d277328318a926c07ebe7f76549bc13613121968acea7f655682da46a7b19f112204b174976956b4040826f008b9cf1ce757f3d0d64e126dad268f8ad711360a325eb3b796d9341c644c1ac85111b1ef83fa872725a8a106668fd591324611b121659ae1bf563069fe3632e3e175c5699694e398ec2eee2a162a371a0f698f3830148f35aec1ec9d51328601a122cf6757001855a7b68a004a9062cd6d75e4c19a825942ef767484049aa0f6787cbf2088cbb70979ad92f3bb5bfcd0e26b496d6f80f4184215b98d5c053f4b7d4c83c8ce39b235617d55ef4e597a29bf0b82da2222d886b2bdaf934bff85b9a57966eaaa5b1718ae2fb60829a8dc4e43727b96e90e8ce2c87053e05dbb753c6a4f8b30577f1358f7293b3c527bd6f57e2b5285f1ed2994f57212e7597505e567c861601eb98f3d741473eeab4660f82edc311f30b9a51a12f512f81874579463d01241320cef7a1f20cf430b8dbb5d0af47662bdba84ee25d02bb7029c5958ff6b0dafca2cab96aa7cdb5220daa3e2963c7d961fa2a5ef3099db88572c088d4572222d3c60bd2f1ed24b7a9fd5ad28f994b28a11386ffd5e4f18683c8ec57c1ae326176f66e24b8c4050f13e03af215f3b56d60b7d55feb68003ab82700ef97e4a2786ad46059ba6ca5fa038eeca6a78883eac8d927a756edd570091be2ea1493b56e82cce78b7dc3666444b303ff90d0b09a7e17d001d1bbd5193df6e100af5f8471e1647e61c1d055a73bee6df0c96e61848b95edbb6e6f792cd86e65e655ca3e68a609a1f4f58a0e3a69561a73c8811ffbf9535dc9f3a0419e00c01138e08259cc7d35439ab43dc380f034b94f8bad0f1dd117cdc7d7b2319671c8c5c3990beb493691c4a8e94bc0b1c80223c00419c5d4a279c7c643e4538be7f5f88df7e766979c8131ad5fc63790f3a85e15b197e8af2f2cd47d556d1ee37b333c81a721dea8f441a24077c5de209d376a0590105c5a3b68e40705aa47a1aa7b67f24157e9349a89a038266f2bef320be290b5dbae20552698fab391396f0f2612047f47c4e56de87f5eb8a03167452ef7d1e2bccdd454e6d24a9cfa816ef6283f9bc0e1783947c5d37d9bd6363ee160dae3f8b6cbf8c21ae9793f0367e2af3cb86c2bcb847d808e57c28604f8245c1bfa1f9c4d4c96d97e2a8e9c7e884db6529fa335791096d6334d7bf5e685f1e263395bfad548bb24e8ac0c918b776bd52319bcd53783221f9878324c088fffda6607e925faab76beddbcbc5a326d071209e628d0bbc1c7c1a997feb566b68dd7096f94a37c9f38c754ef47ed594e9c109d67fa601d22cb5cc12b639fed3b709ee3a8cfa41af8fc52741f40d53120f3f8fa2df456f89084f124ea0ee98a4385a1bbd3785cfc31a9ca883202c62b212867d99f268376b4cc54a9a13ae5e732f2bf636858c77a5848213ca2b310235ecca4647dd8009398269e13331a28da18c6a9879c8b433204c398b3a5496d9496a5f15796d24bd7b7756a363217653589e25753513039f4ff72a4c02769d9d50a472a3d78c05547e99e630a2ad517ad670c0aea237b6ce81b270913be7516e78c486a7c30593c32c180135eef4a8e71654ed212438af02c4a78231e8b86f08b8b3706e3829ccf05e9b3f17c3eed29ebd2a9aaa7f2e85bb9c29014393655e605edc5486a6d129d3cd7b0ee198d3c5dc334fa1fc1e984dba8bbafad7423e0597b2bf841fe97f05c33a9a2eea5fa124b4f9115e6349f2a74d5023bd01f9a2b6bea5b489f76759c6746fb8b1ecec0702d47db0876e8f3f759046cb813ff6aa41874b2b12e75cc69335c7352bdb5ba651da8109efe8a0cd740067e65016981f2e9a07adb59c97cc064f61c5cc247fbed4333aac179c7a0d0a234684bf22455877560f24a910b7b172f773fcd3dc663c6a543f02cfdadbcfb62d57ec827b26eae72ebdf09cd772423b528dd780bd0721322e69f6976d5287adc4e18320f0e6830a8f859f8c4c79f332d14f1c1d6f6ac1f80348e3d13b3962a37f2e2d54758475272cdb5ecfcbe7b78e79444959ccad7c5a6fbdba392de2a1acd266c9f80648efd7076d5790586433aea41a6ed8cc4196f0daa9d40ce62884ce2973549a7acd30876cf9a36c3840a8607a8d643745504213486c7a0e1ae9c07522da8a9b5df6e289da2b2d1696760be51ba1ce2539ce99c34212d2551d938164b2b3df26bdda252328b44513ecb6394f66e71c66b3374276be328376586d6898019c348317dd4020d7d0ae96ee5958c30978e4f518ffa71107cdd72303bc7731580ae7b3cf00d68b779301d3809657950c96557d822d0d919c2b78380964c422b87d29f704a4bb7212a1a84b59eecde1e4003baa0fa35fb9c8c667e4db3955a9079c50e7692879ffaf520491a3f79c530f4a08b3171c99ac6fd645572fe692b383352a497411c781603d658432929437e6b6d3eb89aee4f09b7f8158825c89c27496b03a13e75617d471ca10e26c9ffef115902e414b33c3d47c25eea31ff12840dbf148c3363832da64fe770c5c169db5900c9a2c5b7026a21a5b2b25f9b6045f4f1ea9797c69b12c3e5452fe54d28f82f9c0a0aeada79136a1456639e804fbe8a89c35331a124281b7cc443e1f47d51c4e21de31af72c9038afe6aad745a771407caddc8bc11b7ecde983834bdd695ac9a96c56d75c28c2e67ce81f738c08103fee8338a9d02af0cbfdb9f552a828f03b54cf25744a304c3b540a8d76dc29f0687d4f6f89d5a81eb1c6b447b5a1a7bf0e852d84ca6f7df5cb34155716daff8334bac89b74c2d52a34e2557ba50bac7351f6ae21ae5f48887550b21b1036ce8fc0daf7fd1dce9eb6b8fc5e2463480232e9228fd08744712269c97b08ed10f7e0919b3fbb96abbb38eb3c7e2ef4e06004cf521df0a00bedf91f00efd9e9799fb29ecb05e046e472f3b0dac3239be9e352a2c84ac8d699ce436fa06b2c36d8a72512150c407d8fb32218433d5da88e89d5e1268065193e7ed99e4f3a2c41dc3e60734e112022621cba559a22b8a002cd197a99ba3b609b88c260f52a988a3a3a8166bfacf94b24aa61d953cee01dc311dab2c95201adc4f6b5ed7a31f918b6645ff34da86f86136450cf4b3e5fe70a4048ee37c9d5d655858edd388b2211ef9727fdcf0e3db1c9350b99b0dbadbc9d97515397eb3b4a230d8605164a8a0b59dc739d9351573672dd160d21310279b712ec140b4c7e65733fa7a45bf958b06343104a14927fc04b424a3e9df8ea19475bbd69d4cd88bf7230aa7aa086a1fa169b4ad1e7550de771bef8b33ae4e80bed2a1fe659934d6002a425a8f3cc781d17304e6f5cb97e2972d5762ce1316c12ce557b1174122b811cef50d5e5c7f5f10813df207f0be74a5d43966d0f098de1aba0c5d01ef34613980fd995ff874e508bb90295875114e9e99274c0abadbdfcb51807218be370a6777cda89ff0f8052fd63efc855a608e3ec9a3ea97bf7ad6eb34dfd919e838c958fe9f88b1c8e90c368d5b81908b0834d5fdd4cc537df93039d737df1e8018e8644b6885e7c090fc75494817814d3c9076c5d6d10a42289c18fadf021001b524cd63b3bb3b693b2f707393dcdf6e161e4f25543ff80482fd62728d43e46fcff798a696c5c33b98b8487e5ecd12e8103c45bb25dae7b7d518b71090eb395a1cc628fb4ce56286780d962c4aea84aede5ed7d5259363fd70df845e8b70256f5d424c3e7ce8adf3ec9609708dca70bb79b6854dc4e38e6741ce0d15ebde33e911e36b17ca023cac9455efaf44c447956318993285e86efd125838d8a9c87a64a77f14a6bf41d69dd5f4445c869625f95022fef4332616038e55668959776cb2fec724e5099fcb1328541a088f039532f62f6d67b5e1084d16b6a4ebc6ae60a512c045c9d37db3e50b1e4c036e8addba58ed52b9c2cee5c97a55120f587a0a3a595a92809bbc0ff2b636966cc91d9143451ececa16d9f92f74886a4512a4fef00fb1e8df92689064faec90deb849d0fa6c3e99da74b2b7dbaab6152334c9fca25ef9a61978edcdfd4597c84b564bc4d49fa91718fa7a3cab6543d9fc4c5b41c7c2ba0187f7467f698ddc5c4a5c29c26b61b6f4d2673513202b914c8af8fa8f50621f4bd9448bf815b80a6883891feeeb8e71de779f5642d41e8f69c59a4ed7c2c378853783ea4a1582812c9948721208905e9a40ba5fbc966664e6a7fda40132546ee5a6fe5f56ad373476ff70289bc05de88da43041d1a4511f4ffeced83f9b71ead7cd421503db8410efc5dd877232b24127ccf9e82e90e27e11db879abc9c4d7e51ebfbbcdce52cdc7073d0e6b1add8d86742a5192ef86845f9767b08ba8d7baa8355e818c8dfbb331089781b4f344858af2a5ac3e78154b71e001e70b13b31e90ddbb7dcc548518cfed93d14f0fe707c738ab1842b50095a7bd02b958c9a6510934a678dde46bfc19d82e255eb04d7bc0919bc20056a046de236f057745ac714cc8d911b7f155947e6b9b1ac3b0aa6750051f947b19c22bd200ae20d40ed0c5f82d14d27cb138f284e0757f689abadd0e232202b610453bd8e265671054c960f383e1330ac6c6416f5c0e82bb76c3a3b4e730622888c0c25f1ce6f0d90ef157b15c328ae525c4d6b878594afce82d6418479d50f0aeac1d90e1ffefba1f4cf3f18b04ef0462f3f9a920ae559083285795e234f54bd7428453cbb61c47f3f9ebfff58fe50ca254ff028c8bed064b501f0a868950836557fbabb9fcd825378147ef8d873a1a98b4bb09ed14bed8edee99f50d4758b3c5afe68ebfe511383e7b7d5f6320d758a77a366212a082ce2749fccdc25694de939a6429e32e3e7e82fb4ee5f4ad36e2f525df03aaaf5f7f2acc8dc228980315ce55aa812dfed43ff735fc1d085c6d38f88d1d0083403cef4bf377519f38a1f267c612ecc2856279df5c6ded50bbf96f1e1c2fc457d0eb1e23cbfe98e08fae1b3d2408f764d179ee1abce50b56b62b8df81cfe0443b55bc9bd5d941970d28a39c36419faca06d8ce0ff6ec29e41b8b70612805ce9f66acf32ea385e7bff560fa7d48ed735e98be3695c593a40a19f146585851b01aee6587eed83c647dcf4e253b991f13b835cae87bc67c6b7306de3dcbccffa5c2c4fee2c7d8a1814d4dc49d20e67fe890e7b55f3f642b375eb8ed3e2e84acd6426675bd590fddf5255dbfc44f34c53cd83e5bee3c43fa3090801b2d1bbb85273faa1de2fffd8e6da9d3bb57aa6d2ea3168be3fdbde70445047b7e68ac47b17b781fdea64e7c64bdbf611521eccbe3e7589a6c3fbf2811ce394e4bbe1b31b0010e346a5c542f1a74dee94c60ca082f2e644ccfa739434ff3e0f1b1f4ae14efc5ea3a9532e9f5a40b2a429c40ea0abc6d2ac6ce6380ebddae05738fdb8312ccc4c2cb8828e2d9b1114d0e495f5fb3e6eeaa517ff98d1d8127fbf96e5ef085de15fe13b35403500aea36dfade85927e8036f133b903612fa2767f0820f7c5defb8f5f340ce523f2aea73fe2ecacf0924dfe8bf1de12d2f9751d5407b7f78722d8e2809aadbd80c2b269ea5c477015a772b88dbcd5392eed80af040d184809a7fcf39737c5f8589b4e2e922b838eefcc3605eea2ec0a8db8812eef6e315d25f1553bf1ffedffdbcd9af5561d8e2c66423ce18a7157a7682858d5fd8355d97cc098485a2224bedf9138da928b9a3b50ce3dee5591f0b66acd219d8dd734d62e1a9b294f056b76874f40dad0dd30579d5d883283cb29d749ac19e93133d914355589a24be9cdf962e9643b502703a072848b9577496910b61d10b68040a24283bb056b877527beb7495410e833e0f722866a0e42f9bee3648c9d947bdccc81a83db32b5ae9d3aef89591a31ca6419f143592f6a205448f74061656dc88d2c924417ff74bd52b7249fd83bb47e645f60492ebbf6222bdb42df585f31f46abafc2bde1d30e23b051d07ca0486bf09ac607df22a95941a92c210f740ab40e84fbd10f7c31656f0125110dc14eecc7784497f5ff21e3d9174585ee5d009a53f6b8ad06a20e9ca339fbfe85d798fb16fc27ff4bb7ebb7f9982e022d2fb17ce24fd540506ae933e028a47ef351be2683ee1da2e5b67a25b689ef4a3757696382e8b5b712dda7b569582a4c774a54488a96756a7ecf688a8e11feee9351881a04a1563ee45110fee98c49a599bad16b6558a38b93baca60cada7f3586f0bb8a08a641492a4ece72acb17c3608ceca11b879629cd736d5666ff1d1f97396d3a14f2f808b4de048fba58c9d213448518ee306700682fad370a1951525c2e163b23ff783bfe115547c6b2c590c3cd09efc85b40534faac303cd46c53afeecf15ce10e39e09ccc54845d3af9fd36122ab9bf79c9eed90b55ce8d1b2a4d2406929f27fa192bbf62775a9c74e13b741dabee443c5b15848c1598bac6291639b29a8463a6092536df846134b13e8b47f89edb329eeafb7e28b74e91b04b06a0ad1690d8b9c135a76b9d38bd43a7b80ad729367c8619cbd8d4a36757cb7c8c4110f2aa7c94f5e0170690c9551d10ba0ec2d27131588a5582621cc81e3ce1303cc36c428c4b957651a2788b5f8c0060ca48b9c5185c3c54200a812860282b3ca741233902dcfed1c9df5ffbf101eded41672a9c2f1278a1c393f27522e61394fba6f5946a8adcc8ded6ed8638f9c73f63641eedb9c0f0e308de38e67b59385c1bcba4b70d02d9ae40d1d7db1d8ecd6e7b400a1860746bd2494253beb6c2e1be9d10e197cef5f0be33bf4c6f3841a5883f161018900518551c07089292f0ef55ebce3fa3a40342191b55061352edc145173056a9ec23c8e4b6c34a15d668841e73ba4de3313400168f8ca6ce2e74ac9add8f8f3d454862e1dd7a08d79933882dcb45c8ed64383fe21930c0b74de5ba73f9bc0e96f81be191a74260a94dfa8bb23de0af5d4be39c8ed36b12e4fdf45a7ccf4848c612b6818978db5a52b0d60880f0e7dcf970e80c0cb434c892fe1185c5f750c4b24c50f8209df0ef692aaa8a277c16f1ea2b9501bb38198e4c41c6e4147e44df3c0a70f5861eb21741767cd38995052fd4edd5dacd978cbda9c73b4eb45673dd29638a262269feac8ef16084ecb83d2f3c327818cbc67d6317e7b16b812c1e1e30ff6a2c1cf0b4e8c326228f7f176e9cf5a4b83031f569bbc99e873b854d2b5eab2440a3eadd8879eb0b3a1621f7446f658d7364a019353003153ee9ad1db547acd32bcc84dc0a2fa156afd634022d556dfe8386dee664e9b3f7cae6b1b67e721e33aafbe6c8497c11781b635c0f4d9404a6e81051f12075666ed53fb8e1c01a20bdc111af44fdb4fbdc13c8b43654051fb5b7de8c1234e9ee10101b0b8dfb4cbddfd8f42a5a3d413bf8721715d20e5cca6c5632610209ee3275ef7219abebe2d77be171d229aea1ac115e0a5b116fada5252d4eb93defe75c2ff0ab8e5d0d1ce105076e00826aa9ffc5112923252414d1ee77215dfbd69374fe538c6aa4f408fd26a3183bcd6710fe3c6eed09748c290fb8bd2967b9a8b2691c42000a5552b86dd02a00974659b0c1ae9cc2a549696418f770a2f4a1191b5bc8ec454d5e8596d702f55ee23797b09d9bb4fcb99d12f3735f0e46c7143362732a7484c119917494d3c63cd46fced922dbc79d78f709afc2ba01113902d7f3daf669a42315dc80dd629d47867028f3860d985fb802b3c6c00eb17e61f3b8ee21756f593d45232fea9189dfa114a3929d6d656e4e717d2c593fb3782e29f6d9d058dbc36360133be35ebcb08c36fdca5709e9e9347ad737b60ae19863bc39c58856a2fd27bf7f94659f9d75e706e432569c62119f8005a4a752fff71295fe9c545a47761e88b95fe3e7342b943c805ba73dafabd216d71eef04a98817533c839e025268a9c18ff51c9aa4fc8431dd63d8ecb1cb301148f2e77252fdb80827380501d7f2f37f5ec5be9afaacfe4615a8dfab8493c332ca73c1e50050e530bca0a96bbdd560ff157615f6d2f6e6d0c287961d354b903c06fc535855d92503dfeab8ccada2ffb6ae353d0ceb162a636406fea56be89fc791ac48fd33a1daa937b2f88ad24cb9049a8411f150b7b509b7088680fd7de089a7bf296a53f1832a00b0e636a2fabfd887616fcd3f1e0e6e66c22ee9f754d333577366da22e19c3863a5c0fe39c9f2e630d6b5284d98d60c32cad178e9c29ce97d89c425b8e340c238bdf888b81003eed2abf900e13b2485456b4b467cd4f83cd59541d425afa93be22125a18645e8467a8368069f7d59df62c67c92f91ddab3c5d96ac9c02c9f1c62e76e1fdade8a409dc52aa738b5bb1ff465551d843eee8694de6a344a605ed7a4d8d16a7268632e8f1f415c2c28a90fc2ad33897db5f09675b42f78534e98c0ac9dbe52357b8ffed9c80c53fe31b6786a06c4dcf1a83739ac1e35eabb26c4addb0b52589e9547f359ee4750b4cbdbbcc68f95c6f80acba91f512102f52d928029d42e33913a0d7b6fcefe9950729cc2377bdd9bb18d4739b660188b351827687771da0f4dce2eb4f93c32222b023680fe03eabd822b922762c72d42b8866c2bed76e4797abf3088a369d94f82af706bb8ce7f53503c5fac0505bab95864c109648989f616428b4123887bf127e10fd7b12c1453666da9d40a86619d302eb02ddac278d6f2c65861d4b5d36d05f06ed46db74cf34df3e7112e29993126cd85cf9b9ed3e39ebad63f8113eeabad8f284fe6ffe85bdcdf4584665ce8b1c625f47fe1c68e3dc677fc3e0846867355e0cc5fd9791a591e665db8a41ef6e55572687bfafc82086eb83c172c165b00a9d45a29d4053bbbc5df125b3e9d91f0a4a7789c05e600f95d692f59958eb6ec8e6fe8b518f8e1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
