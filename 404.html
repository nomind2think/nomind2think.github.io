<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d767c49af75ec6e8b9f0b1be36e96c2e577e7a8e2366d0978cd7dc2c6856bda43116b26b03a181bc0e6a9828d9046abdfe9de29030c7b4f5b839e6aef0c7ec6ad67a10ce6f1579c9e0e91ea45730bb0996f365a7c26c3e1a820c770d8ebb4dc32fd5652789d7bde66b7f5c0baaee4583f9da872a5b337e306aa2b8797e4efb99e9f15cd1efc4f2b76b51a8ab0b3cd09649fc6bbe293b3f82cc6bdbe44c6e75cbc9431f5e009e1dcd1c01767d36f06dce0280b655bfaa708de3d79cca5e799243122810d7ab719ee37fbdbb2ccba871bb486eb674fbfff1ad8d1c4f681544ada3d586311c7b4c50f1fa46c44614091f672f755880331bb49a14b5d9098689c52a790a14107c7e9ba0178fba8d4c26d2674335c2d5f6d8f8063b33318afecc2244cc8760db9d8dedad5a25ec5278211fc8aa49a09bc3b5459c8918af1c040a0206888238370d1f18a6c68200e52524bb33793950b3ae2ca56314501bfbff711e275154bc75d595797695f204d8bb7984d6c2cd4003297cd37feaf36c633feb4c16ace2e440f6d127bb80b76b75e42d77dd8c5d3dcb9de8471e7e1c62882c9524d2a5e0d9f2a707b46fa89d0e9524e32de22e2032bd6ef88a00352aeb5574d8b520c025cbb103a0e73fdc7833a8977101f4a5c5653d30a2f92f8855435760ad3b0cb688a6489c7029c3001b2b38e0be1a411e045e67f2cdf33f466787b4428bef719698d6c56d955c7f80cfd208b0e564b75e0ddfc6cc41b4beef3343f743e3ea8e2aec5005586910c0e86fd141ca289bad73d61c4c0f8c1bceb9bb5f947bf11f5dfdca605c1aa94a52c5af812915b8dca8fd09dfab575366c15766fecdeeb8e680041bca74ed4f8cc6fb5cab4b4b5876210c216091ae77c405a425811f69ad895d4653ec2fed9a1312be90e3ea913a4dcf03c19dd636108701b37f199c9e2c9bca0a70d56c55cf8371291c2e0c06b46f4983602e10ea1da3a760143d36fb4a6988231575e497acf52b3e04a2b8b522e351594b478676f723d6fd016918645908a2bd99a5933664b4b09f513cf1c9fc2965670ac0d153c7c0193fa2a0edc5008c14284bf1afaeea38da8e17e930cbf344414a8cdce12e54e02108cb3bd5a63f57d3ad3331e0db4fbead0abdf3c580020253f4f5001868c7512036a59d6c7230859370929bc02ed1ab168494ac8f85166b4536ea39abd21d8b8aa33563de4b6393a308e447e64dfbd37bfccda3f98d6a80ece769c0f33c0b4c85c0fc1428cd4bd6f9bf6abfe60e699da352ae1114621d244df07d5195267607daf1fd27630a6514e1c59cc7987be362ea1a0e455fc63e8efda8fd18340531acca3b43fa83b40f4937f25beb48e223300dcfe06335a3f8cd8a684e9f1898409a9f79599536cb31b08eacaa56dd63b72ed0a4bcf258f7e65aeb05e4df4e2dc18ff5dbd2f412a24b7acf278de5f79ad0763b6314ffaf96a0edc1ac2ca3c2dc7456d9190bcdf0e0b3b86bb80bafc162cefe8a2fb62931882d0dd1d0392d4b73611ed93b382a71a30fa183c273e8e1041c1fec26a476d9ac85ce930cbbc716565bf3b5285776522bf74792399a07e9d45cb9746776b5adc8cf652210705cf75ac44b66e8ae204877635063ee7dd34eab7df4a78d71cd0a7fa92e79fafc12ed19f86e8b9613d7ca2484a40b61e693781ffea377248288d75c6df7053f22d490597325707f06def118af4a0b363ded17f92e37af238a2757561bebf501747c052ef6e4788967320a5e689e2e707f681ad522f5802a2b58a701c5cb8039308a50a241751cd0ee3aa9dbb47fc577c4aac21aec3625735bfe49468164c5272bd1a00c5c8bce5adaa0fceb398085204739906877ddcfe03f2d178a7bf69218a9b04a3ed8d7d6014622b80de732f7cc41a2bfc1cdb2788bbd6d4a02f613ad58f54c485de855400f23b870ea25e1df57cfa9a28fceb3870fbd781a493e810f71656084016c2423dbf48f6535a71faa5ef8fb18278f8e2c679c3d42542b8e1322408907b877841834bd74124376179f0e0fb24eebfc22bff3ca46580ed75391094ddd303f67758bf01596e5f8484b64c50ffae60eb0657f18279db76e7122ccfe6483a1638cae79fca496ff4e7870007d95e4c3104dc4b564c6d3c584f2bf87b3675d7bf9622ae1711f722a51579608c83e424ca6ea088d8dfd574c06c3d97baeb80c20fbe33234fb09055bda5a497234cd727a296be65283d748193480f86bfbbcaa6b1d8bb8e1c452a1356011e946c49090f06c27d4e25e24beca9d6584c73ed54272524bc5d9eba3c8a5c318d851cc8d6b868a915ee9d2a8bd7aca322af77586b17c827fac81b58b8ed29e3b5626e69b969e058ec8983ab0c36bc283e2c4ebf5b11a781d7d76c900ca4ac1a29e5f9fdf431557cd866c9a34585c9268d3694c1f4732e8d2c3400582c1c1473be7c315f9bacdb6161047f8b0e54fd80b09d602c2ceb1005400abd8c816a1255d6a118bc94f1d244009d77eaf88a645d010e712476fe2ce9cea17454414f5c22d105060e951f52f3fe8c6a26b330499c770f1bb4d1ebc7ad9e648d555f13facdd1081f5f71e361e0dc4f18a61c60a001ce3d8e4a494a521826e0978826d7ed94d3e5ade2ff26d62e5675620b3426da584e173fb7eac0a62309051c684613e714d3e28cbde51bfc8f7ccfc4f03cac456597e465fe9c28c4e1cf7b635b00aa7ed3c3567344cc87a6f3e9122cef55e9694eb9c633323672ad21a56c0afcafee6371bff90f394060fcad2e0c2d8ab4310aadd3e537a1065b480edf2cb9a0cb32031cdf1741b2575fae24364c57fa5d7ec8579f5adda88fb4503617996c30d728825c6b49ede279bd6637eeaf7407f1dd0b06218365178d2b22589eea0335af27e45592c1bed37d5fdccdd8f8bee909c6d694320a95b2214cc514220792132f5c057c87dcd1e7c9ffd958015695b180b57fe9369db327d4ddaae4f03d41120bd29aaa5890b27325314c4b0761d438d239c8345ee8be60c62587c5258f16904de69a1bf302d0fbcd29e8f0f1b447f761e543a2fc648188ca39f83a40b9edec910345874e4cb102850cc6da12d01847db09000c9a2947a8e4ef14f3547f9b0ba95dc0c208556dc455ea86e8edabe876525bcb7919b618eeb85862428a1c21106a53653390e5c3a269b94a8cd8ae974789558e5e9a8a79627bae0f51df7315caf75d9057a67c048acb5e231ad321330b801c716f016dc9555aedecdc170f71f8a2db50479a439422b625f192ec89c18a77626f0fe582c62ab7292ad7899963afb88e654f34f2996a2ad5872590d4cf62adc3eccb51a8c38c078fb8e0ab559a74b24260c1d27af3313fca7485a102f0a612960eaff24b5aacf86128f4200b151d66b1437aea5e510c97727c2cc788025fd8e323cf804be0c74b6eeee47790bfc574952962f401f5fcbd56827be6b3da92b6b3e1db8578d0790527544cd44102f43dca4577f0f22f2f28b5becd90f19ce76e1f3c2526b57e4e54d30cf53fdf9779f37e3f3f3c75a4ef1fc1ff7dc229a0dc59ae36586e70627520cae8568792c341bf8a0cc8406d4a70132caa9ee01f7fef7bab86662b3a817e09a91222381aaf4fbaf1d70daca9044982bb4c974b5af90e4b5c39fca5b97e7243c745e25ce13e22297031de008a58e2ff2c59aa75b9434dccc21825171a8697d5aaa1ae48e94af138f8556ee19d442577f7db2ca590b7da519b927a1f8a2935953b685d135fd31b2634e0ecc3e49ca090cffed469fce362501b44c5d31f0dad57c61b37c03f4704279924c6858d54d23c7af65a99f09ec6c26769fce2a9a461280dbce06212d4281bbff7f431c83c38289b178be8030622be10fee024e311965bc233c1739e72cbb88a9386a5c7add5aa811f16ffdd8db19464ef25df1d74d66fa09293902d6e919eec05d94f3338480fbe504243347f0a66f262a4b38070c59688e9b0deaaa19cb68a19b8f9d29e3f102005652d6378d7c948616de5fd776b78da95fb24fa604b9389fcb13ab2e73cb9f88afad5a59c043681891dcc1c233491fbeda8f9f9e4c87d1574d946d8e0e4bec5c619558f020020c41610621c0e141636602879fecf9943cc5458f9669d9dbe2f288968da07c51a9b3d15dc31f6fde90f6e0e3f54e999ff5ade3f33cfc18766d3e51585528cad5299c13582d88f44ea78cf5e911649b75081124093e1c9d99b25a0bec55341fc339b353b551f8aada3a2e5bbbade15b9854c5796d4cdd9fd7bfb7ffbb0d83cca7cf4bb44f3a3a02cabcb9bd0b5b0a2c33ef2d83acefb104b6644df4d0d29cf27caa11ce93cabcc43ad20cfa3ed6e4e1330591e133df324eb8c87c9f217c20f3516fc8c21b5736e1c07c1ffb9f894d6ebaed78ecaa5676ec0244951ca9dcad7324cf3edb8945dd106a0dfc8ad3cf1ad0ebbbba3fc0415e4fd2dcc5ab5a54d29adb8cc49dbdb0ec6106f4a16d8a1d99df21bc5625603e1edfe19c6647bcd7cfd504bda53dcf6885675513739992fede20b7ee426f31ce534fe426a54650586616d0e6319a0a3681d16b37c0e4fb95b28e3019949363c20d29b614449c667d7cf92e7a3e15949cfd1259c488cf70f3119b033920c01a345814c19906cb368f2afc3559207255249e8fd273bbb42b6010a286f6f22dc54695716e1d09c92ec21cd6bf359553237dc8c9e229cd8402ea0f85a6c6d96926341692608805f50a5863578c4e2e68c1e44f32b5c7e75b5615278e4f54c1158f9884941f07d21bb46765653491abdb716e1447726d4c2276bf0cb1f0ba1e4ca75c4e07067ac460dc486b5d1cfb84e26150f8b02d331cf94d977f5ed09162021a42b85018e2f7d737c07775aa2b83842ab560d0eb5f99618baa665fc3870b1513cccf0d66c4fe6de476e0863341202514516711feffdb7e1de3cf96fc52aaa5e8856e60f3ef5f3d44933a03ab7195c99b70449d4c7fadfb252e8cbd0e9604517e421df19fac6a2f5d2471e5ff627a2670400e070fc5a77ff41025c8c5ff2b10e1ffcba3aaaa2a1860eac2534dcace12a04e97d207636ba927bf8eb519eb6d0b50d23ee1ba1128b290b1c1003a62dad93292e63fc9a05de96c8d2f626596fffc914d6f9a7b885c05c139e18ce97bfebba83b08a7368950eef0a77ec947ed56c36a8da07532821b9e3d5438591d6dcffbf362060b98c085962139755355e75eed5854322f2bbe501c9bf4c236af95b8a86e13a03e4ec4b35af1e381a549807c98a370e6d61cedb718dbe071934f187892eca12ba038f8c2fb930c7335d4e3a15d8ee382870a2c99bad5580b1c9d47b5c8af2e40c6b3cb9bcc8cb319978d85bad4ec759bb572c2b24057a404409070fde59b70ed00abe67107f6303179b7317329973b96751c24bd438e8c266c0579f318864ec5b656a0f95bebbb7bfcd5cf0b9a96602ecc027bdb4351618ff15941ead63e14ff4e693c52df5ba3a23cd00399db5760e4453f0fee9cdaa615c529bf5ab1e2cfb515469e606a961b801dd4e6fdbefed86275a823a9752ca63c808f33a48d576e3fdb144158d585ffae6ab998f693fc78e32fdad4ef20de7a6ce070a364f406a708172de015330047689782f1c30c01dd3182f760c4d7a3410cc98ebad197ef3a772087f3b19639c33b9917bd9b7ca56329e2b8d93b051cc3b88d9c67b0943f320e64c0ae67d568998f53b1d7efe84f6af6eef275aa0d22f5cab898d2a6848322d25874e2b406075ed9f42231ccc2a89a0e852d4b7aec8b5f5d84a0c8f568eddfddd85da71a20fe1cc4bf54ceb69a100fc9283a1949876ac95f155a917b71d2658886d3d7c954359358f1251fad0950941d2d7bc9f3c661449f9710a16b79f979f93d16c81830ba4878a42fc7d5709e870e4f5c6d7de478837dfde56b5433acf319f0fe1de8f3f1433abe3338cb571f6b4632029a44e4d1894e509efc6cdbf07634d175b6d7f575e05b8afb1ae1a3364c0432f317728c07bc6f744edf92a511fa00f6480d64779faf85ea5933613f9027c3ceaf9920ba8fa5e19e9fab046b288c619320eccff2d4597046f2932d12909c11cec829c9b4e1b31bc38e9576863aefa51701be67cc1fdb534769887de3df8f2e5c70ae84e728a98ec0772fe0f3329754ca7b733bcb0909b16f068ded4b1615678a6eeb89c0f02c7dc4f94652c4ac42ce8ebae1e237652f2bab21ae92ce5ec7920b82ca50f1237f35ae23761672e389eaa7763ac465a67f74ba7f3ec08c9b7c77e5849e50d6f4e837063b94609a6e1c450a07f9d3c0ef763c2601b419adb9d6a391c01c592b17dd6344f34c2f83c46f9a76333b0b0bd60c435a159808b521427ee503f3487a034ece69e7faf9c49ffaeede0fc7230bcb5d630455d6688943540512e9a85bc187a662bc6033bf0098b21beb7000b6224abbbbdfd2be2486ecda4242e3e8e6a6af379278416bd2721f0657723e482420f573067df2b0bb5f0d59dcbcc0d878a563c5ce337c14db2323185a5fe0232e630cf04d37256e7aa0794ef5b26dc4205f1649783cb161269e42490f9eb11e85dc6df220429dea82276b1133d26fb71e0cf40e0739d318aec729dab5ba12684166d017cc1b0bd6a4ab9643512e2b928b3fb3dd7af142d77628ccd780ba222c8156e2643a61abedc1e1a3ae1233b8dc9c79041677026d07ca562a0c8e5085ca60d41239281cda7de2167205940b8ed9c69aa08810c98d634234766b3e1e99a08d09af134292fc0f7ba8c144192d63f0b08573300015e3dca7fdd2c7f2221f0fdac633954d497349a7b4b6c15d717c1ee7972c2c45fe25c8596209975e6f7721aca34cc7426a5272475d8e85983f7dd7017f99f9b81309a458c95b03eb7cf62f2e76390b2101e0f5aa7299e7cc3db437b6fb2c20b88f663ecf9e7313decce90f469bc6d38d00f51b3de4a5639f9ea34e4e505047146b42be1126a80b5da03df884cd430b8872faa99d36247be3de3b166d48c3dfa350df0a35b0d0c2ef9072e4fbf390907e7d4837d1eae24aed13e536bff3123c07878b73cc772a54a1d23f9b521fe338ff445e9c3649d6ced7e477f6a0336816284436dd61d021b87a2bcb1ba819d8ed5520bf21f6af5dda6a9ff51fa42ef0e9cb4b3a7f38643990575df1d65874b467c5acd534f5ad5de2137ee20fcb285a2981d33bd3cef06ba4e09e691631ccee905be08b4a0770a9e60ad5f75be3fc60542595c4e68f781007052f17c86cbba027f784b79f1b1fc29af5f6ea62607a8b67ec7a65ba10b41ca44537b7c9bd543362d9986c225e089a697294dcb97253eeaf90afebb23ba8a0807f71598c05a221dfd147b2128afd6f9e0667e60ac7db65079835000f9b902ae3f922461a7ae8891df5623013e3b482e8a1a9e050d16868ac6b1273b06ecadba788906e0efe32bf6659349aa22c9d1e239e4c1aa1f87c1fcf36f19f534eed80c27ad646947a95cdd92679ca2111de50ac93e176f716d9c157523a5c6957054b07f4b7e4cb30b929882cafde067cd45611b5a284ba40b6ea681fe940a322d52310e318a1e4dc29946a7309a666ad35d2874fb99e63caa5791a4931f05973857179ed3aa4ff8f841889deffc053dcab9ece88a18582b08c349d2d849cc881856653f9bcef7083ca306a7746244c6e1b7c2f9f81d28fce555964abae31fb4c3c10849bbf15b5f68e01eec2616d071d2632ce6558b00d94ea61c1440a3a222867e76c35c1851512501e9bee6f2076b5934dcd9cbd085c0b11c486adba3441a2a5ee0a092281488c08aa8e3efc61fcaf3635d4cddddfa755558b5bf0fe2d9eb29a7f723b8a8379bc8a75a99b231498ef5b24e97041ed4bd3cd87753761bc18894182182db6079c92392677d14b3488b251b944b41c2593697afdc2a51a82bcab188db8c96ad20c1cbc3ea108f06f2388d89424ad0167369335adb7b9ddead8bf66ef0b9f462d1755c8bc391b0d7891ddc2e01f3b7de2bdc6ff8524dd31b3d6520f70ae838b2dd38bf81752d15d27297f25791144d995c9039f234bb46d0726b260dcd71f78fe44dfed21be2394d1618d8a0b4ce9957c795508f7fe4141fa73b60c2fb704156244206d3d1a9ce6bfc047c31fc075c327cae0aff75ba3fc8276d915f51d1cad8430cacb9ef68873da6b1c9053d91ef8f0ea110436180f3d395a438009d2c8780b53da61ffc8339132020089181de95af1c8afe37d1b962f52e96195d7e3d82f2d622cbae866764bc1e985b91e6d0f207d7ca2ca46ef973404602811321bef91d7252a43a9dce3bfe43e876431007180cd833b7807acf846c727fa96c9709bc4062eef8bbe5ef050426caa447a68030ac1a51a75c05a016f6ea0ba06c87eefb18efdf9433fac4d5bba9c9b2a4c6492e6d448d358be91b32b7d667fcf3df9f395dce374c6a892cec1a521c2d1129f90e86b8ce081951e35822b05b60d21640b39a57202c0f9cb98371b1f0a588e6e483bd9ce9154a7949f28c066e05102d0deaae79df8508b0e6e89d1092f717807ca0f411adbcf9645609dda732e898980835601ac0509ad35eac92318f56ebece3bb6b48058a382c4aff5e9ae70910f84bc8d06c010fc721bbf965f124ff3f9420701f8bf5dfd65b4800530e30a7cb93326b5d2d39ace0a4a1b0d14b3cc32473ee945cbafb105df4b6a3d91d779860b2aef5b51caeb5da7b7ab6b7303cc79a0bb1c05e2de5925a8efb41e04cee64085706db6e636b233d735e17c0904055e2052bc9059849cffc3cac7dbc5a69cf09fb86b6a46e940954220d24b9c27d16bdade5cc943bc9fb2435fa4e9cbacf651f7d3c569bdc54b0940e513ecca35f426b755d69899a647c4868cf8ac267af8d02f29556446a0085ef967ee5151ef85e9dd6d86651e492e2a897c479978f282ad227ce2d09955aa675094da5896a3ef299cb759","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
