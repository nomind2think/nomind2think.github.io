<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a940becac2ccb55f34a7dc91aadf733bcdfdaa4373622b77ef958adf056d17d4ac3c2155a8a08433e2de04df2599e52d48a78647f41243efbccc9c5c8af87a7d2c54622293da62500ddd49349a56e246eabbf77020d9bce12471ac8ddac7ae7e23a81624061c5a99f2d9ed5d6c59646ce0c67a5841562b6898e1a826703ecff71a7611796582ce019aa560f97281dc920cf4626547fe061249b9773619e8692951e3a46e8ade51805ea3122a57cb88a37a52cf4700d027237461792dcb1b316feb1b66a351887870d3b8d7f522f32e0f27b15a5f809e95ae2274b52d4ad7fbfb1999eea386cce312e7277133ae7bdd225243d74ddb673763b5f40cf74fd6569a05c1f30f4aaa68f2e7be44c2f4e489b6937c042e9ffe79ef8f55aaf56a6954ba6aef2350eeeadd8f3d928a8f645da630a7bcf24ba22f305b7f26a1276901e913353139a9348488102d2eba75d00af665136192d84a729bafe5fbc4317dba68677546b77824cc91ab0348bf6225dfb05a8577c57f117fb6fbce0e531819b4520cf5f41138440bbe7c4296d3b0034427bf8ee5adab1408691defc3410cdabec2a20abe238d21496ee1b191ae0bc71dae894fc9119398237bf453e926b617e9b31e6f63f2e47373e9dd332c99fea6ae6fd954bbfbab81c29978907c207a74586576afb06b0b33b2fa7e400d27cf06602d4ab73c3d9a95b9b027edbc754de74f534da8eb89635ef216513684bf26a34b281ed701c19456dfa936c4cf32b355bd4610fa2eb139e59cf76513f344b15d3851890a838470cfa1ccb5987d6fcd178d0e2e27fc996743dee663d1a3e80d8ef0d0f3a58da47358ee26edcb5ac0cb69ecd79c42b51d9f5219d612f553fa3b67faedf1dbb196a888cfccb2eed8132f46b8c5ea02bd2a2d4263ff626e0cdca253b39ab171e91f8dab4f3f60ce7d1c44cc16ca677538921e77a46cf6de1a3d50309f58cf47860d259da60296724548e232e74a3e0497025a612dfefae5de3a12fdc994b2fd452ae511ab493767bf9bbc111c507049406f2ccd6f378d1fdecc485ca6625ea6ed4950b599baab271718870433817a6dc4a2ad5b95441ed1f70754d958a98c1800ce89bb79af6f5f43fb7aa2e9480bad2e72ad8f43f6347b329fc0ae069d9f979b8036f8665b48cfeeb712d1e711b9b86ba0e626cc9a6273c5fa7ec716d72022ff4796c9f91079cff6e2266954038ab842778670376fee8e6208338fbb253a6fe00fc6c22ec540a489358929b12def3b87702fbcc6ad324bf146c4b8323cb3e5f5400784eb20811c7a81b4400b1fa25e48cf8e31ea6351bccfaa06ff447dce032592c76aa2804fa20371f32485ca78675a592054409ef9153b0d9874dc871228d09dcb98c5ee876d631cf93e6bf76c38c5d7f51ffbc8f672195541a49f5ad165faa501b2e48f77ff30d0999733b8098c07bbffc1f16cd5ec2ac79383fd2113d3ec7e6359e386242c5d5576e807358810719d385e96507c16e7acc49e3ba5c9abd13ea502a5114c039a5282d27333803209747e2d78859636d54964af772405e60d9ab37ac21dc76fd5f36798fdc13d3c7c41151b39c8e7b76ea9c0b71cbc670726c30fd6f4e8c6554677347afc5a6b2d8006a30020479844f19ffb682038e382e4b8e67878d9c550ac7470977009aa95fa07b59a1e178962d6cf4328f66e0e98af7ae59d22a04612b8739c49b10f051148178ce99dd7d8454f0360878be75612b4e4a098828a514d47c29f1cf21b72588dfa7a9e6c461c140c4e5404600d989c401487c4c66b99a4acf41863d894b15a370acab642d9a698cbf79a694793b528c156212f62c68fe22b9d4f0cf286d1643c5e837938afafaa008a06ac43f8625b816e361f897406203efd994360841fdbec2f8e5a8a435e112fc3ecbf0c16492f8919964b98e92887398d440da7229597466439d291aecc0ff0f520a4ae8188a5fdc8808abddcaef89974fafcdcd1e1e7b4179eb367961a9d4af7c40ac14f8e2f76d6c55d729fa2a9e3224087fc8aea6912a0b88a6a27f6eaae68c678d68e3359020e92935da244f26c5decec31dab6d2d25703f842839dade9c4165f2bd7cb12f3f28c1d30a26f9f0b581e7764376a7c3020358b208167d044971e2dd92bcfd2655fd5fcaf4e413ccf1d41b5e01a14413264a7e1bf3fe63f9fa46b938849cd0797091b3c7638f4750f782cfa7035c9ddc74b2b50dfacb4c5636ae51045849d630baa46a6fe855e3ff28b6ec16d51cb04eba8f59300e2376b672f19aaab93ab4a226d2f21bfaaaaf940729ebf540a2d84c62d985d213ef403c8d5b7bf51c9c65dae1b2fd1ce99e1f81470702329d005dedda6211b7e1e8fce80758e79c97048405bc4753e3f1f19993faffe51663fbc8e5df42b2804d5095d0e5a1b5e91b3fe3e5902ca6e5f312227f27bc0378af6351239aa9dc01e50ddcd89ff5a05ec5f31eb845ac3f89650c39a3f3b1269b2fa1ffa171aaa5a06ecdd8041cdcb375202475b22e629de1ed148b2fc4bd5d5fd634ec0305948e8f8451d8d1d1fd9834807edbcfcac6889643bc02e34163ed7b3a9efa42f7eb6282d6c3f8027d71c9feca37c40fdbfa6f2aa43be2b5e196b9299ac9a24f02dc1375acec83738993590ec4cd8d54fd8544591837475e8836309dd419de70b39b460ced7b2929354becfcad95aec15288e5f7adf84518528b6f0c55522c4f01895c8a14d2e9f4dac70d87b550df2cadb1f5e0be8c5cde28ade1c9cd58e8566fd664ab992ab4c4d012e024a31d492c23ccfbd192cc429ad77651a80086534cf3d82d3d1b6e0a430e5bc8929c9dba2bf6f99dfe546ab6663a5ce0ff37b97030f29b028885e38df00341644fecbbc2fe99d4f9bafbf94bc58fda21ebd70e9dc7aba0b835a63de896336e67afcebfd038945158811e3db4b5fc788465295a2b8fced26711eb87fd483c5d951059eade9638523c51a4dde59c3510c75380cf301322d3da28f458e80312c0af4bcdeb2b10adf13a3c577d6d4fd3252633c162c2d5f40a2106c360e5b71e9473902e172df83d0c46f66b3818b8e4b6dc3195e1ae020bc01989ab3098301506ce0e79a95a7af204f8ac2c8183f408826106174cff5ff15baf2a0754ee0aff29ba7bed819ff0c0f81a78b3c387db21298aa767c4792cadcbd274ae9c2c7b8ce4fbe251a5c69ccc1d8c2920facdf207288accc7ecff66047b74a7b3b023ed94af8b2a5b817d86d7d9bb551cf1c5baef08d8cfe2d58f1cca07e2123d90ead38bb7a26e65dd78fecc04765efea7ae6c4b4b06f529489da3c2fc537583a6177e4bbe42e4b1ef21f54137cc3a4c25c3a5b6a3ba209766c7241169ab7f8afcb08c90f3d050a8e838a8869ea35b770076b61e4623de252d9f3c935ad449e35150584d862e5310e85e31e36a70e79714cc8469717f500b6f4ac30b9250ab1855ba43bfca7269691474fa2bb4a4c23b3a37b683309b59fb8afacb0af77410e67df46b18627fc116e13ddb78a4b7ec18d758166dbd796fc1f9a8230047bd4985eb74888f13095624c1df1ef8cc386fac8ef1bf962dcbcb4c5a10c87c7203cf791b3e25a5c9a458ad6073a7419fe372b4cc318caf577b43fa76ee49dae79bbfef6d2b4727e62f7f6a9bb4dd15edb92102b637818cc532fe38a3ff42f87b7bb834905f0eaf5e2759d3b27f765a3d7235f3080dd0682689563bbbd35ee28cdd31b6be15babc568aab3255bff717ee829424700f414c0f2e7ff536a6a24a422e23239b3cdfd27fe8144c862c3d662ac19eeda21d96b31dfc1429df6691b5b09fa14cca7c217f210926add677177eb34831fcbf6c3f6b9df1ab3c0a78e5da11e5c3f63d17f230df02edabc8b6f0cbb21b13ca6e1185c33942d6bd6401c4be98ebf6ebcd92c04a63833282174cdc683fcbb10b0adb11308cb237e74625d819acc1d3b4c253a6eb8feb3f4cf645b83ae6e677bbecf9d6cb205b0803abe302a16639571772284acf0428ec3909695a12b7fc82cbdf0d1434f535ea43163fb85827ac58c20a5f710b8ee1cb99ff024cbe4988c5476b35e9217fc384bc7eda806a9f0930ef82e38ea7c8427cda8c47c7dcdf22fd0830f25cb5d27f075d013cd0cb82421b152d000fe81a0cc5847ab204522b5a1083f10cebf6e53510c48d3be589ed9b9b513ea3e78d85954763e68e46c22d1125d5f73ea34e29059b41c234aff77a98ecb7c800b3bb481bf1a1e1555407a12e9ec54ebc0b51b8447a865ba08a178e64da3fdaabb9355e31a26bb68d43f9bde52090028055f3d7ac6e6c758f40d175af1e6df38c8be0e8ce7f4eab826467b0e930129c1813cfa9ebd5f95356aa2082a2286cde7b4b780c3ca65431df8f79f58fdfabc308c0e76ccbf1ec1d9afbaf8e50b15719397e08d1c0bcc90c9c3a7e7ae98d97e48493ad8c12f831cf66c75bd36d03420723493bb7c2ebde74712a016c8efcee2c268d0e7b9e5b68b7f45e6f80b377023e3281637bf1b3c097c56bfe3ed821583fe2d87fb0397f2365cb59f021c13f6688afc92f7cd3db4fcfdb46d84fc79dc014873085a5e118cc2fcc64360a888e8cbcb06cde2b5584b297b7589441d4e026a1251ece7df4b602b866373471d7b01393daaee5003164b77d30703e1bea4450d723a0a7e3d1a24e90ede59663cceb2ba0c622b6da0e67ffbe6f5e68a00723dfb8f4cf7db714b3bd325fe418d53d82236413950f750f0a72937b72008d02cf1b3a1a61dae20f8647e98e364eab665d87733871d80096e36a1f0f659d8d34db06f4eea770afe674689d0a0af12e13f3fb2873655e11c6330c596f8da1155dcdc3c28605c9ca0fe8075fbb2c13e495a0676ad23cb8e6137dd3e89bfe49780cfe67fa73c763736e6085ec4f513c3af1c5b4d6e1aae62496af57441ae1d95b827751c380b1c9587e81cc6c46db69f506554933035e13cfed06ce2476492554aa3817f3082c5e5993ee241aaa9abd35e8064e9f0cf742d68a477a83d49713fb9247a31625812d4e1038f8e6304f80d421c8f5f3110e9d61d83a973392a954ff493eec6445f2089f1f4ea60d59c32159c14eb0005c388dd6171eee41c17ce697612bb615bca7afc317dc7770738a815e59a2225d76fcfc840afdad8ac7d0b9a72d16269d340e9473413d1f32be4382740ce52beca28379d15b1d50f82e02de8b33008cd3a96c5830ff4dd4ccf90894e19ae974b1388381ec16def5f4a5a26b6ae28f09cc942795755f73ce4370162bab8c6360a3ec5e90ec3bafe38a50dae14c750e06958540b37e49482333ec0310b450a25d7e53f25ebf62187252a9b692262cdd86b020c22641ce34cabe32f3b435f9c2eef25c4d9e8190008e3f8f2ba22cbd3493674bcb89986e32aba342957327e364d0279ec2cf887ad7cf79b4b2100dff86093a7021618d37f9a74d05718b7d77dffa13a2eacb3b7363cdada9c43b620c1bd21a3f6e38c4a10939e9e07ccfcf29e16fd0277fe00a477da8d6e858e137d0361e73d5bc7431fb5f60e1c7a3cffb0a1347a865fb415dece77bc1017d3bc214e2c16f1f129396091f7fca201ea7634f4447c0fd2f7e425ef55b2bd854a99fcc60eff0ce2e00f7003023855e2a447dd6bafb878576c175e92f4c4e74d2b99b14948f110a42430e540f36869f20e73777c462d40907dec3149b67bcdcd2e4377b2b8cf8de172f903d208d16eb585d609637d9827da08464fc06a0389d8b63534babb7a4652d509f5df56c226d455ba12a04d6d507c6df73f8512cc67e69312c09747aed0e3baf216610fa767b22aef6c4c39c7b68ec398906e4fa86fc45adf982366f5104ad0ded76e57ef6998a1d29f4d7f17d61472cb6da87b39e9176799d4398614f60dff98b5c1239c4d05b6d6f60f2babec8264221005fd4a140dcb1b7ad03a3fa20891d2dbc3db4c8886d952d4a10d9d30cdabe34ed142e437d414fd086c176e71c64662eb0f5a1d8426e6864a029579f7226ad45549806b7cb1f362d6d88bb495574cac58b785f9545f3364b6674bc937a1c2b56891013f1a0c2a9c19cd6bcf6cabb3586c71dd7c24442ed6f14d60d6dc5f4f9b935d0964e09b929472323593554678dac01b8e8dfdcfbaa84e466ba7f71f0c8de99013fc146c0625008fa85d9b12a1ef97eae909bee71f1a26fd8e0162568be7d7233a7a1878fbabcf77a53276f85758e6f8117a21cdf2fba0b863b3a0b84ec5fa1e2b5f5dc0b4d081a837a38ab418042b95eb7f0f3ad85a1faf157f26850ae676a567deb08768f12ac348a4fae0e76aa192b103d45585587a2ff754b7e70e942a8a2c2a4a15deb6e8f293ce4c12ecedc0de5cba657bd99067983cf7b73e3959e044e9250b7a5657d11806c538c06c5814e9c869a6d2ad5d87b900107900d50995df3022991786c258568639e5f029737fd8351bf6d1416a01d4c2407689d23b288b7ea16c9296191fcb3f847ce0c15995c541672ddd79383fb8781e9c71cdf2a9e6fee309e16a3fa7431ca0a44ad9b78462948818c1cfe62288c59fc4a0fce3f0752adf487e0175482d64276a1ee7e2815069ca7e7b0f5546364a238a0a5d06a46a1cb66f081944234f34c57ab994fae6b63bc42f839b89e8741bbf18457d50be48a8852955de7df45dd7af667ae0f628af3e19274046413b286ad95824ee20756ea9457b73951a5be5bbc9209fe761a120fee535109b78f6e66a411815e8cfe2827d0861593bfa9e80fe3870e58be7c158b82e65017f725c26533ff81e46c913a631d4f5b6dad211329dc20b56e64459829663777b6ed4f5b7f08b35a6e318979c718c0e928a6f887debcf04843db93341f5fe5c59c86dc63c1ec5d845449ce5e8f56949dca05bec7db028d7bf9cc3923b35fa11b91c03f8eccb1675c35afe7d4f32d570f11f55d4c0869ebac1eb34628fb91e7203f968ae77d2e1637ec4af4f63b747519dbfe83f04c2b987d0c8e37a3a2ffbc1db16758b12702a7da986d99d8a650988aad8354f64fa2a2bb5374ea0f0dd9537e2f2bfacd3c14adde0b3e57eeee57024d6293e11bad32982280f9e88a02338ee13e9ee3c8582ec5be785c86fcf3b07c2b377707bd3bfe2b43041bf7129b0a37c47e66f078b77501c16c1ed6d6a15191867232c76d68ce36f2eb3c4d42412a958b97ea619d3147647248a958fe194161837fd45ad640c6c4c68f8f6b1c1a98f8e3050d8db66a9782325f3a58467548711c62543516e6df0684bb237ea85a77659906cc0face91f798245f55144731583335e8894e109cedcb65dcc9a15114727d3812daa6b8d5e8a6f28600035c552e75446b19d7b5ef5bba5c20e9da8c75c189af7d05ea160579d6710b941da370c448fff3018cc8be6e1cef05b8a4438190fec87c904b3fd20260a823aa3aee5ae4505f7a3061fadfbe2812ed79f23ad0c20fbcd44d760610a54e184d9f92da17605384bc0b2aacd9f60aa165fb989d7e2410e2342a81b3cf7ee71b97a1b479183669edd6a9cff55acca9e441723f4bbfa4dc5f93193b0d7a16cf87eb3b31a791daa572831b75fb712ca52c8a3e0f818ca5d5c193fe8cc829af9a9fdafab9d73ad232d5510f18e98686346161c9738c152b3646a61e5964864a85307fa50c513c670d689ae15c17a95a0c21a2dcd6797c9ff9f795220379c1c84ace9729ac6c8d3cf4a9d11061553e3370c8d1488ee1483f73ee95971673eb3e7dcbab91235f9362f0316f188f7f036f352926aa562aa9fdee3b2fec4bc200ff7773ecaffebb43314382036728537468e251a5e56fe04b3cf49bfd084994153aab8ee50d8f0ba885cb62459636fdf92b1054918bc4f8a3293ff33c21ddf31f71c199e7c06c93535de2945bb274a3860c88c6f4c9a2ec0618894fbdcb4adddeafc379c6f9f4b8338ebc6e60bbf0f41b2ff969ca0fc2d411e946ed4d0828afddacc7814b308981f3d7dd74bab8622c342b3f29d77503f5728509724f39b2e3530c8df332971e77055c909cdd0b46befbf68f23e3cd66b0864c94eb672a6a54f81c3246a4dd1ae0a6bb9088202a6a694cd46aab3622e3e6a96aae5eaa274dcaed4b5dca17687e0c7fe6224d58730bb301a3a24a6e151ae41f1ace9c6cac562bf5a9acfa8aac62b01c328c27bb75620645956c02e48ce17260ddaab371a0a3df98416e2cd1891a1bbd800fc25fb7a9f33abb85df32fc433c714787277dd103b8691caa6ce4a23894cb5a532e7ea8c888d7fb9e8c00c9dea5cdbafb450875d6c60d52e27c4c75e0313a700df460943c635567a14d67842e6d86fc57f44bb9932e59766a2229adee8c1d7e6bb495f7bb59e03520f290bc35a15855ca2293aa514f455746817bfcf9976fa8c96fc8bf73582c1c8d6accd6a5d0b6096399f7cb9e4cae389c54eeb60051634ac3653cf9c34179b607b93b07e4df6a43dc9dffd71c6e14715ec8cbca305b293577a3f6cef2f3f2fbd28d0e88c4e071b4b0e20f90514b0339e61723ac791eeb01549431fc3460572fd1d7092e21bda8915f20a1ceeb28c8ce2dc8c31a53d5ee12d43e99a3099a3c7e6d80ca26af62e3e20bd367a561230d876476a516fecd2a55903b5743801586ad8e3a05ad6a67eef3b35306183345d2960f275dd24dbde988a996c16b921107668ad6b0328ebb6478b10f8c8e7ce19b456f1cf5d69a0a313fdbe335ea77465a9d7ab5f7fe1305c329a80470cea303ed370e721c2e7d3c8c1a1ca2aebb3980f1166591d25652bf7f9eefec1a08b5e7cd1d05daf8b9cf074e38a66de8509986f24b4481bbacee2d6c0a27f2ab92b0ee732764241f783379df03c084ce3b3627653c2ddab1cabced71a5863c905c92270e0e49814ccff62c234585231a1ff6d58b72b7e186fc569517772addd34edb36444bd973f598f0187252e49f6ab1d810fbede5ab5891e8ad0f8231cdbd7eebf486dd0cc7b8836bdf448d1808ce14860381d28a971565f263c8e0c8c53b675e61cf8e21dfb351ca1c8d959ff376f91a72353ea7f04b2a54537d8cb9e85ef233b5663bedd4af13bd3213b6b1ef09d2497f1981e97fe1bfdcf8bd0a46c0ecc3e6ba418c1ea022eb4c6c4f1f9efeac7a5a08c53ae8afc09f93f2cf4931d309453dc77da1c9110eb2f5ec0de200de5643fd6f7724a986ffa2a960e07d9f3657d8103cd309e32abd73f440f4d0d022a2a63d4bbc4e8ded1d25750b3ff4637ec65e5a0e912598226a9788a7b18dff457dcfad07789e14fd3d2af3a6079e797194cb3121f0168516c117ed6d5ffd6b6c05681654babec07936f1ee25ba92f4b7e999448109201bcad0534540dc07760af55fd9d4fe70b170d8cad590d941554c2babce83604750fe0e7c26828ad9bc51bb0a7c5fe6dfd197bdc6ea473a355ca95fdb4be63efc3cdc40bcf7a3d10326b305915bbe1a6a7a3004d5cc4343933086fb9054757bdab75b08ff480f6a51c13668b31a08d8e5d464ced0e7903b3e99666595ad63870f0c3f02f1fe17f7ad7fabbd3747ba4f7178d46bd11dd03d671fae965a967debb653e14142cde626c529b94b897cca0102419bd6ee28cd44cdfd3883db2ef8e0c0bac0ff5c4dd309398fbc3620d0dc807674810874bf71c337fa3567b20096c99c96b154fac44706993f7818dc85d4e5ac386d59d677e5f03e64190936775c85faae7732291e9f1e57e8110f9d7ff2de353e9541f5a5cb45bfcf9ebacb9a318dafda5b643c4c5d15846586847c7158eb8ad51136fa449c6b8031af0cc01dfb617c2460a89dc69de96dc8f4fe387b20439eb87aba4c5cecc3b9ce3181d35b08c53469ff2130b8b232c0f3fb6fb265ff5b2a4f2e160af0aa41cdbcad4e0eff82525fe51e02d2155a48513b0c8b84375f2ee526bb6f1c974e82d075c4be98f20e404c5cd661a855e433598c01983b05a394d7df4c6e94983b432f442e1294f9bd5b0c34a90dcfca37cd89410c969e75be4471c79a317d60cc9a67196817497dac6c1f083d15001a2d9ed79147c139172d0f2d51e6c2aca19192f57421bb37d01ed913513c9073e33cbee6edf7ec34325349debf7b15eef8fe89f98709bfa4944932be6f3622831337380640aaf17483d628a2c2e6bfa23c83332af17cb6a6fc13778201a9cc3fa46c8efec919ef1d7f98fdf75f9c48daa0de2e23ef26e3a5ec6268b3e6be3787e7a3860d40efaff5eed52675c4be6dfb3bed0b3452989bf1833e86725a676134031727f3ebea71fd3d7a7297544a691f1889f4e6c9b53e34d3ca3f0406d6b455f76780cb54b0e2d341961b95962b5b11104e758d9448043b0c366bfaab082aa5165af1c69d0167adc7c986319cc6a3dfb4cf1cdca41cb0fafb27c05a17eb627283fa89e02a2392aa472b4885c0da0e187c49fd4dc120e9d3d6f94c5512c931ec8eec23b62a77010fa053391ebbde42970d09a6a2767fa545714c97b1e0bbcc772d29b576720dba9ab1c6d261266f46d36574465ad3da3df7dff53cb1e7ac95cb858128b58f55f2032714695b2a88d8aea85dc70e0c07b02958f0490d52dbe1e8bcdab9a5ddffc43ee112921810a37440eedb3ef2d39e5cc76cbec3c9b19fc1f22b5bb2a6de99c31587092cf0c44a814eca950c6664d3510b9d86c6824f3e8d3ebafd3ded339221ece3e6df6f135bcb03a9749f3e7e81d75f805db1b2fd05f033928bc4d50b0825abdaecd9faec42640dfc76288e467bb623b5a14261ddd1c5f8159e61ce1571866fbb4af5394cfdf4d03b6d345b660705c1936b4f1ac31d39d69604c708f116293666c2edaacb3e1f5856f3cfbcff191c86feead8e117c709866bb83efa885a885cd689485fac348ae77576875a79bf1feb1974a4c65941de3be6a042096e236170e9033acfe0078eb9447bfa56dd3c61ff5b5188b648f85ce1e43d3c481f31e03444deb0b996227250b16b143278f3f1b0b97e75e1d4b40fc94281c843c9dd9ccc74a18e76ef0a00e168f508bdb4356b93b98a28977c1ab7e889581ae0e782c570595ca3d13af972130b6f9d15d78d7fd3068fa3bc8c216f2b106a1715eca5300b060e07fc10d2a858774776fe5233513aa58c884974afcff45942479c25e94a7f59485fb9acf1f8823fff70b11dbe757677b69762da27cee784ff2061a6ff234c63aef835130af8a9529b5410942f706e9ae6f25477247e2ea8b6f7db75143e6fd1da1095edc4c35c4cc11ce9c22a535e980568e1e3fcd8de35ee588e7a74e624f1e20c6e69bfdd1fcf44f18b2b051b6105dd1bb95913c1975f3f207050e71dfd309a543f799097f7085aaa7cc38061c0ff64734e5e2597031cd97087eda91f9058f2def976ae35212567931cf75f23d3035424525c4181de3d4e8f175b41d0312ea69e73eac2a8866d27ba0c0cb2194c3dbe3c2f9b7493914c0b84bfe0766484b36382715f4b0f28ad98a6d76678cfd4ace0bd70976c0671388f111f500f108132417f13324a29f3027bb34d894e384e4730098cb9c6be455a85a8d4dcdc26adae4b32cb1e44f30d0e5e42c7534bacd12253ee710e990dd01b4f8336515b2e807d0c58ce9b515230af15ed2694ab20f0b667f95725d7ce3b1d546b315095538674a42caadfe34c24010de2279c3172f44a8d666b7d0030edb436c8b578d911cf40e5fb50811083a70fde4f6ec51f2860f0d5e2ae26df4f5578341f10862186e6c11206ed8cb35a868a2e63ea92f3014abcb5711f02e44428767d817b35010e612d7a95fa0b01b7478daff3b03f0bd1334720645f876eb93f9c45eb98bd171636c44d042e2e5bfcb8fe695ed6e90c458c58d6e1293643c3700f17294b53c9555755d4f9a4e5694f880443729d4553b755c97ed81e81efad1a8816d4b28dd8828842e9d5adca2fb213e4991f1ebdb5a0d3eb64927a27ff264c1bb3bf4e353e5fd8049f5d2138907526591e04bccdccb91eca16e49d6f40c91b780c605a6ff040845125b6419e2da62341fe018afa2b695bb8d4cf5e8f55c1766bb1695eabcdede3aaea6c047290b8a9e0d3093d8fb1ee818c8340974d83b637cf6b0736c6eb7e1d750620a31a32d41c03ebc315ebee478f68d1849890b5df11c983a3a85643f642d55d21d9c83b3c5a34cef0ea3703accdaf84b8adc98254aba3ea40e60eadecac84ec9878d83f96ec653cd37cd8e6c8428016dc9a63b533d3be66c69851faae4d05c54c13308e6811c4e1e8a36b2ef9688296d77d3eaa62659af06a798d9a837d27ea73c086730332301a77a38d1788a358de023c0b0780d60e291f1182c20133aaf65473fecf730187a6f0c534815db1fe12c154d61504dc182b3c12c196f6739f3242d766bff55d45e5f35c7711539971a27341b61816b216b853758cb6315e414bd919f724192068aaf3edbf5f9085a32f4829c080dc2c78a2ebe656cd654d76aacfaee9c2eed7430f7fcca592042313ae945af95c18b9ee9ef814ecdf72e15ddae92384f8bbbb912377721237cfc964d47482e046da70a321f260056f0e06e847a845c7efecff33366a2e4debb000bcceb8ef02bbf45e2eea54587db5235a2705b388e058b957ffe0ca6c63cbc9e3c022c60b425780523fa82091bef45db53174d206d64ee967683cf6bc2a1368b111715623a55079a62fda5b097c20ef8d75610187bfe7119c4e1a52f07b2ddec59f875ca50aa0dfaed1bf9c80bcadc0a56b58cde4947cc263f4679a77924fa840f99c522702c03467799848e51daba35bdcd1427d6978071ba3b9139f608e7dc811968d50291537086dd711137915981d02399a26e911483492ee70eaf5f996afebdc3ebab58e0bab01c539d0d60324590228c3485bb953d8ac864ee11b285872a6dc61a1a5d2edfcd736a73abf9b7efa4db3f16de532481fe0263f985d9deb146c31512d0ee9afba33e9c453be761f41494f7b1922c04481336507985bcde42a3a08a6733041260456fff88435c9126678069b5868b1e50bbf14b30035d0005ae8029f550d1d6c825452277202ff8aa1c56ffea61b1e9650c6256565d5f3a6ec2ec6d7dec0dba8d10eff2a05865c864f98b69c090b3c5a75ecddda54b31cdce4de5c95b4a379b96dc4d0138a43c02ec87fefa4d758f923bc08b872d4c6b66b7cd75d792a548699000989dd72ad7620a00da141269afe069d8158ddd23055ffcd1afe4ef6c4df48ade055f6c30dbc3d456b2a5c4846306cff23b95190cc98d58e8f8469959f95b61dbee246abc4cb2af866be3c93e003f7e3dacf3c9c2c07505b18ab1f91eef14ff2eb89358c5755b2517a19b6cbcb9108257d2c5501f4c8a901db371234608325c8a7aa7d299991322b2d4b58768a2202fc384e624744576c29709acb18bf8175d4a8a7eee76f68feb82f4c565f2867b53ac581852111c289905d6a7840444e0de52a935c16ef2e4890e2e64a6a2fd5c097adeec8ddbbd19540f5edd89e90abd2a3c1137b9cde2798730526b4634b41085804e257eab6535c6fa65772d936e66dab89a7ac6d18a029f449575b77bece2532e868ecbc5c78b815f9b1d296eeb8aa3da27af3a81cc246d3382d1b56bc0328bcde44b92391e55ae85b68dd25b3f96a31fa3b35a43d3e994391d5aec4e1e36cd7c7e330cde2da2b9ba585e59923378f74920d7ec07a5e480ae9cca2f1da4a4106d9f0cc9379eff840aa419b913fb236916376c3ca53650266ac0898d04059fc5c870023c182350b9cf189286f573677b0c9335f2be9dd98368fae938fd9d345e8655adf4464aa8916c2138d6bc28ad75e8c38498160451ae7df41952ebe4973f0c7ca523ed6b8346461e685cecb5ca2f1c9d337bb8ce9c986f900b6d86811647aeec76223ca27273a48dd8fcd1deb1a8658b81297af41f6211836cdd30d14fa6ed823133ff8a4b0000e5febb6b1f664f45242c8f304b7640358df654e34d61b34f6fa425ce11fa1d6f73a05b0e35a7744ce40e20e3ff746fe1c5ed5545715278f6e6156914da1100f34b79d7e6e7f2032a65a88b47e20aede734234b131b8068a2bf620a2bb8043d262f958598647d986db58cb22859f73479a3cbe1077a7d8dd2a2a57b70366e5d373be235612999284f663d20bf9329f05c41290a39a6fa2d0cc6467872d38faa06ead81adfe79fcb55efd059942b3adbf7c25694966f51a3af55943fdf450a908170a611a61d4e81ace2b617c68b50ef789f7ac1e15cfdfda260c6fa5da984cf672739949bf0025596151224fccbbfa8690539d0213a7a73fd64ca5e0b5e37e04bc7140e264ac61716190071b5708465d03ef7384e3e999a71c13568f422fe0e4c2775cf74c12a10b7e27c3824d1df6590217892398e5795a56b217827d8130a244f8878e02781159dd76b1234bd68790a007ffa953bbe45a34004861b8115edb216a96ce5d58679b391da4937d0f362e3be9a28d4ff1c703e5a2650a9051bb6b6bbf0ca6eff761abf1e36662cc8df698e25a16ec4054acda09abd16c9567e2e5dad0d1de960447b383c6d8a3902c9b2a97e357eda5720feb895313ed6d3da190ed6a6584b081a2a7093e796521d69503e39d212cba0d1957fe58d0c7d64e50141fdd1fe0768012caa2a77025e152a12f82cfdca9c5e98410a42a8a221f26b3f3e0bc1f5b9b329362fd7581ab4618a4a3ccb827db02313844b73d863a09bc319906dcf12b0c07777430072e85287e086a10ccfeb12579ccd189bca97af84247f0ae986d86763251fd816d57857992afa7cfc1e2ffa91e26c4e288f1a698fc571e96dd15f3e06d24b0a9490d5f5c46d9dd3286dd87ac3bb72b9393824624f3b0e7ee7f6dc25385072fb52257cb346c9b7bc21dae906d6f3a98d7ebb1ab1571246c59d520ba7b8952fead95c1043a51f1a388261a2f22f889fadcb6858d443fc4506b7c9e7e134eb159c36f3042388bd33c9363f2daf25bb2eb66991476a24fea38db5ea3330783214f3fdddefb6da71b88185dd691ecd48d8e8bcca1a9a72e75780f7db5327bb7b870ac3c6dd0526e9bcf3ef6f2ff76556994f7772ed2e433c12c5c1aa779343e28f02e6ff39c61672bac78f9b0e4842463a687fd99a3e2dcf247593944980b876238bb81186f95442e9f94b31e66a1dd2782afc9a80d3a806303c1351300632b36e035781db7183ab67fd92c797de591a3cbec1d51f7c4db8cde91d94f603b760b87f46421b915659a6b5227e6fd63e946cdfd5be8097429d9823714cec068c5eb6c63361e8eee2f110e2e2a968e891badeb4e2a99259bd59a923a29aacedf9b11eedb47048f6541d400b122d93f47eb79730d56daf65062f4d4eb1d46856ea4a5804afc1a54b6ed3464c0e05e1e02be39541200c2df48b5ce025de2ad91fe8e724d06e539860f9b8e8ed649eb95fcf891c5d18f7cbac25fb102dbbb7e36ab6511eaadd49722963764502df6770ab37280effdf47561d5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
