<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9159dc33e89e8be673e7b150cfa59e0adbec85ddcd5d77a0b714a7c065a16ed8c3bfc154285d352730dc332708203892d08cea6eaa46d4963d8632ce1ade995660b3259c7b2d70730362c4604cd4dd18daf9ef3dc5896aed0ebf1912887526405ff7f269175f03582d7a1de70852c13bb1859da0ecbcad1e106bf88c3cb193d8d4576577e695937b3b4b18a6b2406a983592e281a5a52ca15d7862f5d93b5241e3b3fec65bcb5f9f2a85fcb40448504be733bbb8f52be6ddd903a7c7762a3d8e1293773ab68cf88dd60f1cc2c41d56667b3b05c1af8fef86a28509ee22361a8f9eb46354064cd3357344b0cd6e0d02c639c0d8dfe9171b45261cfaec6421171f1b21c1640ed37c205fb17f6bbc0907fe47d4c52115600fa36691282077694ecb771c548589844066cdd6113bbe4fea029cfe514d7de0b70dc5c6f1b59799c00a990cdbb9dda12d94afc2aaf30ea85074bc490023b7e69e431d652e300c8daf86c5f5c1b4e1f261ad587df86c80b0bb80b6da1831268a23a8c94b564394e38db7c2bff464b74783d32b9016740d5be0541914d2a78dedc073c0510b03745ee098661fd42e068d1fe39fd82bba8e3878630a924866242a8d25c338d760f0d32da65b141c5e3235c6c9e27b501172414946b841a0c6c471c65bc0b82b296e6f551da6267d563e955d4dda3c229d388066293a88bd3082c0e039f715346e391960756c25d07cfc7014c09a73877588f9172da56071bf373ae785c901643041426c7cfb1f027ab6c975ccef6f1f3cf4204069d0cc007f2078adda028461fe42e135671ac316139d7e1f05a505c2d1fe5496d895974a848cf69d6b86c87fd10d2b999f6ece8d7e33607e2c41054cdce3d57a90c8c57e9b44d288a7bb48355f1d7af658d8bed0df393f1c859f9a4b62f0ef38fe47df89a54fc2151367a89d76bc5d0ea8317db351b53a35594d38f262bae05f98bf910efe24d56f225791af2361a1a2b4913f30c0e344583f454beaf94926f8f78a05e6516669130528097934a809589210a6808034e24c1d5ecaff7b1778e24070e9a0c0b6c2dfb09f053189557df72114c3c3c86ce439ad2e614ada9e3ecd87840febe8921d6eb1ab6014b960830b4da06d5c692bc54c163f84c497754ab10b545343614b34b460bf85b5be0e44c876d390a6affec42ee032decc4f039268efe2798885839a6360f0fc62df19f79a1813b4abe00866c9c72dbdfd5ab28520aed5dc8d9f9c448c5a7b88552fa2dba268bfb914af7eb1f0d081127b7fdffd4352b41be824931396c55501b3e77d8755402617b38fafe592adf2d27c7bf065a8b64dced31db6d9f67836603462fdc5fb29d77a0a4180ab5efd98b41ec8ca851737f6ad26e85e29c8060fc14d525c8899b151274143c3c00dd09fa9b9bb3f6189c6b8a13c836dcccf2265f9641cd4f03be561bcf6f620d20a60ec4489063864df02113169a0c34ca2a694106c2ecd8214a1403123cd0c2f1178b1b3d00e132a93c64d430eafb622d294f7f26b00bb6d5b572292b34711d56cda3c967bbcd2f93e8807da48fb5551c61adabe90fec1564421de417b9f0be68fb3a255762a600446d2e04fef87aefb96e79316af8acfdb752431a14d147f1954792ed5b21853fe8c1f37b4be90362b6fe3f45e690825ef70ad7851148790c1c2c66c2d6abe9848908cfff85c16d396aff4c2810d1b482630c9d00009534574e6eb448688e99064fdb089f3e59f3da4bd75b16a273f6a2dfaa74976924e376d88fe4f61d05985d7f9393972575b9c012606773baa0910349206efe081092ac52bcfcb082f6ce4e7dcc24ae028046d7fdaed10bfa87663c3f70cbf99653785fce4cfb6e5ae08f33ae6cc749b46a7c3fec8898546fe59a60c883fe33e27853c7f959baecd3bc4f05f49497e7a4ea4f9fdc8c61e84caaa1029dc973a0815a9a5abb042f26a66174bebc848577bb64e077e1cd766649f2fbbcb13cddaf9ef668b08ff55380119a8de46889d1a6b462f2befd0a93a2a6358b2cdfb2a75af96e9ff12f98b58fc36d5a000fdd64ab50d729787b20ea7ee183f16ea92cbb0f566adda8895075e92fc09199067ba663d4810a200f51ad4cd3e8772080a1647b1dd43c91bcc63eb36d71c6fce8c7d8fbd4dd6925e6cfb3ef18fb82853f48863d17c80aac76da104a2c9b9011a1ab206cf17deae95fb23c39a1894b71b9d72a9ee71fc898f8f72f559a426588784effd16ceb382db574ca51e1aa1f7cf9506edea45230320fa32ff6eb4ff77b00e29ef39fcbd9713cfb36629caca7a5cab78a9dbfb6fd859c0933ff1a6dea2e39bccf446ee0defc670393ee55a139c15c8ad4857b8013c2df5f2453058e7c8576500e50a44a509f886f837d235184a7fd2f8ed60b0792d7b5d376d002ca956009527f45517010c6eeb041114958b7ee6b841684268d54517ba9ef0abb1d42737e25e923da56f1b78c4d79a73f7197ab1d79b333d5cde88fd27fc141c87d50a685745cd6b36a269247810979b83fade86e0c7e6c8e4e5e8c8eeff44e046fa64b93dbc94e36e637ce7622bd81fb3d7bcd8db2bffe3a34c9a533f6ade0178f6ee59cf6e1ff794925eabb82f5e7ffad3e3422b5e526d3e3538151e7ab6ef73abae5ff9bd66c1a145186562e3ada337048f0b86e494d2d7bbfada4f3e897476d79fb4aad7870b263f6c1112c6b088a829499a8ea2234492581ed8b57a5a416bbb6cc1f8b69e59c30110ddd167729768e1a9986b62b7b4873a33bae23c77bacd0dfd3e5d5700ce6208eb804d0832ed90d98728ee1e1a02c55e912a1c0b2c719124bdd8ea5b668236f2edd9ac91478d5d1da7643eae3101549f6c1b88b02fbce3e956311f931cd81cabf352398d159181fe258b78cc972b4c3ab0330678266dec7e553fa39e2a7e526adc5876de88cfb959d74f2b76beaf15dff6dc3e7d3ccdda0fbeec9ce9407ce3844e572605a629231736e76026ebcbddf2d7c5e61238ce5438e95994d3f0a0f8905306fda52da6977d1dfe8bc1a48fd125b57667f0efc3d43ff84c011437c935abd15a441fe000129e5b70a6b13a199056b5840dc9b1285151d19298ded462636dbb28ff3a42bc4dae31850cab438f9068d8bfc4606f617b4df18714a26f2ea045969f57bcd823c2dcd13756e705f67a645a433a0b2f516975422b0ae806e618591d173f1b115f51faffb0982b8e3917a337b69acb215d348abe961bc759e65fdb90d4086f65b7b34a0291794d4702079760fcfb44bfba2e97355eedc2df1eaea058d2860122c12f6338389eaec2e94dc86e0dafa2ef6932347d634ed4fbacfc0505478dfb89f4bb8f175688ee1eb8e6aea85343ab736124fe9b9d9fbde5851e6fb309d84cae04f20f8953a706541dfe21a96c4762795a34d5f0b964d4995050c1317f650efaafc7841812a1a1d61b9088a2ef87d0259d0110e68070e5fe3888d7ef195a8b1e24ab6f0492c00f8414d07439f64b94cf3492b54aba5a061fe459ab8c9991e5760f187692c1daae2c267ea81c442973b65e9721da953f1443aed7cbc53f5e7266ee1fe23453e184e8841ac67e78b82e61aeb82b2e94075692e11f4e474588ba0bc0b22e37676c4dfaa8b520f9c407399a1a3e2b9826da71ad3d0a19b9df8f0d863198ccd8b02060c54a95fc7b26efae6d84bdb4f67a6ed60f382e48c4e79c35d64cd77a4dc37621daa6e5d85b6ee9833a1aad2cfa7f385288afe5427902dad58c83320e19d8404b83827671fef9492464165a5a1df337fade7da5604e889d044ab04a883584834bd67a9232769b2d36f8c6065ef422a693b98e3a848ae1f888b0a46146fdd998c0bbe5f22f9c5db0e4ed017d07ee180bf1696ad8baa8110d8cde185e3797f9560433b1bd0a756587ad52a045e229e58636a32b0625e24e7a60ffa02b9d24de92f0d86695db5ad924f20cf4bf4d3a6f5fa8bdec2e92b400a44f96d660226d88723a8c3e4c27abf97e052868327ecaf9ceaf24dfe833bf458bc0161d6356d1901954e753979b9fe485aa41fb3a4035bf5b1abc83b4789a6aaeb39a70c044d9be21a2b3dba8cebfd4da023f56007af556051440c7b616ee49fb9d20ad35c8e907ffcf7284a0237d5075cea5c053219c602e0533dbf1a4f5d6912f968abf05f7e0e75736d12cf6d8a4f12ad48d45e8089df8ddaa90de4d0254112b650c09fece1f6002603384639f216d1f7039f3702cc683f6e092411d89805018629f8c2fab686d134a0b328e2b39f5c37874cfd4f98b3ce79521e5bd4dce3f0f550302f6661c8548df1c3da08648ab102bcc949bf9648ea08aa2c9e7771d422ab2b6298db473ad6a4622a68bcc1497ea8a628fcc10f0d0939d06e7b8168e72840f52820b2c90c48b07f7e105497213d805fe287cc12fe32f2c5b56e1b078b921035753c8dc1b33d3e747fb48782e30be7dafed6d630385cfd3b560925b14ef7368278c574e892ccdcbc6b1ac4db92b4ea6b51446c8f58d39aa1fb8ae0cc0b83c077490ccb299d23a72add32aadc5e05fca7e3f7bd6c14a34ccd5a5d9c25d11c83c274025e7320bc56dbeac534c1cef88821948d6a5aca6f04b46c89bd19af5b9d578bcf85b17dfbe7f7a7043cdada292a15ee0b509d40749af47f6baab366d68f420d5c1a718c1a81fa113f901b270fd3e129956393e26a8fbdb3605d679d876d672d5c3b8dc927576fc18a41b829be2043bcd8e6459937bf0b67137634098859d785a2f6771a727760912d0dae9b7ff43af8bf0ef16b4daf2e7a2cd6bd9f1e7437b828c397f4439c2b18e0c7e490ee9fc3c269fe4fa4aa30cb926e241a5db00c694af5321b78ae83c245c0c47a9293ed254817033874d877a1b63c26e0db23755bd2857d3901ad535997705fdafe165c1f82ed8ad975de3b60ba87f949efd75641f79a045f99209a89106ee3463b15914225da4e322bed5865a6497790a28bc0bfdb421c67436e04b47825192f5948ba282f4671e47d8225000f9c9620350f9deae31c1d0eb4c71e5c7e41042bd12a2138f01e91dbf372328ea773fa756b1eda143b60a5085ad5fee1e1fd2f935b66f437f814201310abdfd8699faa579aa2044c3ade00bfea3636edaed0fd04003444d48db12692a7eb20a8f3506fdf15bce18005171910060d8113006c591d421541f5be62a4ef168e2e19a585e87b2a236536396097d9bfb99d921c23d4fe3e539e309f41d4d86434a102e449e03ce8be0884c0cd3f4a4aeafa6889c3ea3bcd1879c8299ea527aa433843526068a0474c8184841e3be9d40f9db318e2eeafa72f3b29b8cdce4ab63a99a06702b766a576c8e93882bb4a3df6d8d86c84e6ab205aa6758dfb39f84ffb8136dea8e64f27053cde522b4470f799558e80f2934cf3d5661e4f0d5b726441aee7bf5c0c349a1818ef4dd629c01f9c66573010a3eb7ad91bc27f6dc06490a34e686837920a71e53b6d26350fafe6846cc928d22ab340e6f89faca9886dfd1e111c18afdcfa8ebc94fccbcdbd8188e6a9e47ccc3b00e60e6549f9b00a861c35c5200cbac5f196a1b04baea15421c5b589ff10dfd694e9090a9f12462800a3f579f5435f52ab87c25539eb4af3164ed6a24bee1a8a7beea14f662416a0fd633825635b61845894e872974694c51196d38b9e2d3996125c2b0fd7935af4538adc86cbe01ae8151c499503bd1aff107da915b49bf97e4e192daf798f48575091fc46f52cd20ae1dc4f225e7eb741d435d62da3b0adeacfe2c4b39c10414ce24d3cc4c51cf82f3065b8b5b8927adcf7ec5644518268d9754938fe4c9df1380123db3dfe75d7973a847b0d33f00fcb45ad6955419229c52450d7bc8dd28ea55506bf7d4d4cf892addb23d00abe8f0fdfe77a0409fffe36ed9947cdd7b44c11ebf95f6421bfe750dbcbec9faee583c1aa83bffcd28c5c0afd7a0c3a2bad66c3c7fc21013473f8776428334fe039c5b3e348f871fcf7dbf35753ed775e474785a9ab44ad6f0b4a632396f227db48e8950f2e65bf8e979036995371904ce46ea2c513588961db71aff82f5685490df077fe58d5c8ac3520845af37b1448217cea19f641b232a80ff40c859f8e9d05cd36b2f671ad74904ce0d800093cef6f0a2d71c1f0ab439c17f1b8584c25f8f0c208d6e948f0225418fa76fc7e7111d628f63aaa6f8552b907e085c9c7793d951e2e35a6c96dbacfbae47afe9654d6fa7ac311963eb1fc941c86508400fa4411711de845e17558cb29ce81cbccc9be34f15accee5800785116c7b4f23126bb54bcb10c25abdbfcc20bfeb2547a7b0c81756506c9ad4f9d507cc11bad4cdca450aac221ae8e3f869477259e68e8800301fab4c31527629e4efc9262b0f142038badf9f5801b55bca73ca61d59aa77e5e9137d69ef28a521e62cae07c76bf1530bfa1904aabc1cae5b6803dbe736f12b9f67da33a3eebb99a5dfd7f7cd6a9972a855309860b52395adf3908aa07f846ad6f94d5ca0cc78ef499ecd04e0d73adc89f57a2c15446fd2cabbb923f15b934890a0eb6d3afdc41b653a310ad44851b33c9560929c79999deb96bcac759e2d776513fea90448dac11c2cfb171eda81c3fe4f3d8eea789975d91ae4df0e5b121e88e790bcc76bc2dd8b734625c20c24adce4a86dc18c35016fe2c0cff44becd687b30527f1302e6ebe5c04cdf68a51e232e24bde8c074cbf3353e4db46f416f247939b9261ba350220d7767512e6d428dc26a87510d34938b081841faaec1795882a7043b2375e7ade38943be8a9d42f627c4d6c32644e890b5ea2c0402dd2c82a11f78599907486e9d9696fc9fbf9de17403e139437155de6d54639bcc52537220e699f16e96ebc59196fc1081af63b8576f70c5e573c2dabbbb7875b9cf1bde2f35a01356f2f0ed1d7e9f8c8841e1e45f5d07c76af87855d947397fc6bb6c1b290ebebd955290b62f2cbb0065f159d3deda57f42ca3558b72f6bb0f2d63654d567d2e0df06d4965748bec64046c390f1d50b11f3f7796913d3b6897526e26c91d9fced25cddd2669a57321c04137ee26330cfbf72cd90eb58a23fd6f7cd41737ac7983d85b1cd14f0b2467f6e42def8eb7c53fb78913bc9bf6125f602b02e2fdd01d6ae81926b1d29e2f71acf57bedc54d29b6c59ea2abbf197cd42be81e0ab01f2f1d9ee2724615050f46330d3f580d583ae6c6b7edea27a5e7f455ac94ab111a92e6b475e05fe3bbe07b97be23ffbe14b2420363926eff680d29f0ae45645b9dd14418d356c6b57176f3b77f4973b08a67be112eb34c113f723ca600dca47175f2ee1079f39e36f207991dbd7a9f07e8e14be57892c9553bd434dfb0d45022f580577133f192fddf1f2c56bc8bc0cecdb838fd84b675c85d27981bbbc65bb4c888d4efae2592279b30741e2f0a2c36003d2313f27bfbb415f03e62b0dbcf203a45be5edcefbbff7a4722581cb8a54fd22da32e9a83ba995510561acdf26e0f6be9543e527f4eb437ec1e40a2c34fa96afba812403519f4dd4c14f34093ce6d9f7bdb5f755e27c3fe197886e07329f120bcb21769b7a0dc7d8b99254d2bb109e2756fc7533677a7d70e88c76e95307d9e167fb664bea613f4d1eda6c95667de6a027c169306003ebfef7f34e67d441bcf2ece0875d42b3caa136a3159c1c44012025b9fbc2593bf0c2a47f792d07963cd8864bd4d68101ef66c7da2900b869f0b1830971e35c1ec0bd4c819b5a273bf51f5f105bdb5258bfe71fc8539e6971223090e20104b2d9049ded4b0c1bc9af91de597f77ecaef23ef34af5e46ca0c9d177a5fe93216e529c8d8d5b174b1196fabc057061a78f7fce8088bc3581828ec0a86c8697d60970aaad271f9edb5e74d5a4578b8f90dbb8dc4b153042e79b62fbd53b105f2deec72675a3d34c6507a8fed2633c6c5f3dbb227195f21f6590698b9c6f00b571942854bc25e46514c6275125a232e736dcb6c8ef2bc844a231326ad0793527379ead6cc2bbcce38efee78096ed9758e50310327eeffb77ad17521b94e2b8d20765fb536205d902d49c2cb96025d9ab26ce2f33dc516c7ab9e4744a11b3d9920a5065e298958f84e7db0754d76841a07f3721b7f85045d1e3c44f573d91e2bc64d49b0a2e49711af88871b261bbbff3f46d2a802b6599910a133263d966fc198434c676a7a54a693dec257403fdd76eac587781d1031046d2fe3180de1f358141affe6021b5c0c8c61145367debeeb8a842d53398f810e1660d56905470fe34fb87de5eb604c2f7d5a24e2dd00c5608af3ce74bfc249eef6a68fa59e6dd9d0f4a8071b44a4cbfca61612d52b027672229815b01a9d1ef1fc053bf02714f82b01f9a28094fb5ef91b60a8c41438f6d211b225b3165bbf03cc20a4eeaedc68fdf0dcc46941735ffc6c29cab648db40bffa456751224c45a274fa920a809e121fbf0269f5082c79a6838f9dbfdc734e24b5463a2acfe55875148435b7dc884d7da5fa16b8bd1d061d6bc774d9021092c68c8b5a4470925a28a3e4861e7c8e65eb9f382622a29b5b301a211844d71c913b88bb23e25b64894ea15ec7448c4ec6806341afb575a6ac6162623baed4f70682666b561a55e1684f3d68feb9a61fb42a82389d41e9729c0984245ae4d39fff7d34ffd338c5691ea84c6ee84eaf00d2dd296af345bdaa6d5574cb12ffc08c0f3512c35a05af206b454d72be2e24c3a87bad1f41096a577ae29f3f3e9862c2a1254f3c1713bec651cb7207f6607b7f97bd2b54ded4d0b260aaa8933536475e37cf561fa74b8549a98d1295a21bf600dbc33c9026102cb10c67c454ffa32fee79836698171897feb4e25d1c9cf475d55d5b85f6ade7e844eb1e83e90a499282e79bc4a91f37817c32e58653851eef16174cd9205c37c3b62b81c406bfabc340de318203a0b8666b94cb660738fd15fd037a090b3631bc07a59cc9a2ee434592e5d369418c35213564bf77e2252f3dd4c11a49e30408e3a8e2497b55d1fc54071dfe8ed2600631a9c99b564bac56998996e46af1d2398b39088ef86882ff99fd14d70bc2d08ad43ec0c26d783949a01a37372cbe5645f3b2dc58d93bc65690d79846d7fa88420f5b343483152b6ce81b657b41680a70facd7b76a38260eccb1063442357fb4e0e8356abfec7d781c0001768a79c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
