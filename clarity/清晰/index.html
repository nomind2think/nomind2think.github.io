<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5eea5512bb86df1bf1626f24c136a161aa2c67f2312c67f844471c5d08c5d3a749bcf9c5874e751762f8e88c951d1caf957fe9ac5c7d528fb7ea9cfdc1baadd1f5013aea28b4245d4898ee930cc30c495a6e6cfa22a2cb41ae65be14fbd8858d75fb966b5a02a24f0db902567c5da3ea35de43489f857b5c4263d9488e38e28f4d2889da8ab010f48bc071e948332ee3d0074b599bde5983602ef20b0286125513dd3a90e6b098250eb6da8b01ef137d3a1f55886cb32e8b227d642ae706a996cfe5c519afc69fd1551c037f5d27e4843be92c926dcaddef16e5507175c099e534f5248c9f149769dcfc7f4b7ba6eeeaac36f31e4b64a5be6f49db8cfab0de341f9ffd5f94f7b6e0d2f68de0368bc33b1dec2eeea929ea8776880fa23f1e78485ed6e2ae9beefb7a86362749c352445248457950a7dab3763e35807c31b991c5ec21d42441c144d59b5bcd3906d76e9c5e50fdd5ff9021f46d827216f1ebce1768b2fd5590aefcc14514ffdbba1fce8fa60ff18f4fe1b480e000d16701e7505b2b73e46364a2c6aa0c97603b2d940c78df6e99a5a571c158f4d9e706d1169a0940464eaf29819629088ee818d0feb523db83d9ab9c0ab962f5fab55dacc7415b3097d3b81649833acadcacbb2ff0dff1dda3e659709af60b88a9646494d2f5fd100ff6adb6a6824a860df49d9b8a6b203725b1284556561d9e8b9a3991c79e13c50e88072d8a0494bae53f91fa3b7cf83389af7e17bbcfb0fac6ba608073934c320cfe222a8cfb880aea318ae91b2df26e51f1fc80ad0a3d9ed4271d3e0661d550d5f63489b8a6c2b150879d417368de40cb195bf874178de94f9a2d05c257e1cb12539e604f07dd26a3ec24d51d4955b55db6390702d681e5ab58429b8bf23d178f8f64c93636f2bea5fdc1d840dfa1fbb20a83624bf6e2b4b5ca1282a5fc2ed62644a567eeb63949588709d50a6d7e6459d56d75b5dcf514e0d2f5608374ae852a726f289ed695a73ed103e0e296a94e0c1b0ecc0366f1468b13c60e4223445424c1fdc60101aa192c1c237eb493c9b25ba7fb69ee7447e96c58e6debc8ee10a7033f724d8db7600e1e280a7ed7df6e533caadc6fd5f61aa719197b82899fb4bc93e1a3eb38fa059481346f3e704c689420470629c3ef5ee09a640d8da4792b61b54469f4a2ba5d22b5afdc34810611d35252ef004347e32f1fef6193e49fb2c695837b567f561353afee5a7332d58ff84590e2c61dd0e4d2bee3bac1a878e3b8edab2b0aaf67abd6e8c728d27001c74cad535bc676db0d648cb12b2f881ff7e4478a94d29b0e118a4acd767df59dbca877b41d46221a72d544fa5bd8f0cf576d000e81ff87c974138230923518c42c051ce4289e445c9c26232c78d905b78e75f27fa0bb5c9b99f0b629379e8585276b9da9d7b620f5607be105354543c2d276f9b9ca3bd4ad3eb4eef90d4fa9d2041a0b619743b252d3128d922607dfcc4e5805f2981a72537ca2dd5aa0f4a5a665e32bc2c414d7a3c99fe31573e60f481f6a0cc64c10496f05bf8c4e5636a3b0ac3f65abbbe9a5923fad321d8401109da59699d69974c09a39f2714498a4d49c99afea449bb5155881f06cb15481b3035b5ced383ed0273699de476a3acd9c293fe289da5285d226b6619512e1cb7af209af8264860d599a4cc959d05df9b7e217b7d192aa36477e9b054da6ec3df08165955fc8773c751a73f042566e0c3be8a0b6aee4d09adaca0e224ac63967aaa140d111886cb3043a4985ab79a4369668cde2781507d92d647cd2b5a6905d4cede1e81829ac6b576e184c6ac475531e9d71b19ef07810ab3e50cc714f2b9acb52a2efa35cdd505837d3d0365895e66eb49a4e1617cc381876e5fc4768f264cbda8beeccbb14d9a35719722a52894517033f30b6832d3c623d7483b9edb4a2849fe9c6e228d0756503ab4300bdbd8447025c2ca7ab967b3197fabfa8ca6b8cbf8205b74aa09f1d9baa6361084d1fbca9c9ba6e7babbb864efdb36f1d47b28626a4a22069e196e2610b33380f1188e4b94d3008060b1cabde7b3227e09bf13ee072780c23ccf70efaa22be03f03037ff81a8ce7ecb318dd75289d6a6d8631b0eb1036a5935d5e9bbdc73a3d30053391072fae28cf2ce85dcc02a59460465f3d9a5cfc2fb2f13ebfc86029ba9d8a48593cccd37f08ad6c7adad1aee929497451e662082c55fda46c8f402e1ac8ba4d2aaa8cf59cf210ce9e0be4683c17353fbadd181f7b47017212936fe4bb4c761fb427ea550e6670a5d317b0d1622a9b1956874168f68b8a1419c2b0050f6c860017abaafcb3afc1f92db490520018bd98f65623ef7c080ec7467b2c9dc352aeaca60275d5f014b94c82bc9f02b7e82be40921295bc82418c618ad3c214cb55534e45641cd518e7ec7a3fdfae3e16296ca4facf76e4cdf67f16967a9365dc956f0922c76fbdabbb36d4ab789b94733e486e859dc954843f00c63f23ad9f9cc0aff23028455246218eb338aa7c38444ed50e41a684f3735aa25032918b72553a0b822f7cab0df7522733ec8bbdff499a95dbaf666c053e427612cf438dd180b37ffbe9b32e32ed83fd57d3b11f477d3bd88eedb49284c8c776e62d60f073953a6366a3e9839b5600d974e9d7dc10c20fb247be0c17c75824d447b9325e226acace7987cdf403ba2d30d2687ccf3b1440b5423dc150c30325c98e71c4f764e82c70a36929a218745f6a9a0e800d717d1afbbdfefc77911b8d367143e415ccf670bed27168a2d0ce84fd63455121865db0ea69b42693acdef5e813cc6afe7b2acb62f8c811c4b18dae7f7669029b428839bc27a00ac5844abad7b0c00af53b75479661fff4f50492ceeee8060da6776bcf7cd3e760d314cfe5f1bed18abc33a2ce82270af602b3dafc3af0bca0af57eb9efa125d9ca15d5a409191096a70ec21c245e3a552bed1ba08df4755bacb8d62b4fd0652627bf0038784d6f9dfaa29d6c40f4548c4994c585409e29239711f3d94bdf92456ce19c433c4839032f17b9f2a83dd3487e1ab9df39bcc1bd35bddb9e4f0ee4bf4ad6bc80b93cbcf8edf36a7a2adc9164711a0f842faadd058c26ace502de5fe483244e47d3e3022f21aa155238da975df3b654a01aca1d732fd25d2d11a5a7402bbbee95778ae4d28dbaa5636b3048b511211afb3825bb434ec6559f95b87c3e420e49bb751d92888848777c0e39404def3793c289589424698d094c43baa092ba9403354eb9c3c32f2205708897396dbd6e37fd9cf18286f9a5757554f6bddf49384e400cc41504852fd8e3558961ca4e7c2c69923d3215a86b3d28493f1e45a8f361092aae98e3d52fb12bf9654e9a9d1e1f228ef39b46070b3f315e842b7713f88b5102150f15c0495f8b5ad3643b55ef97194ece71ce83742169ed5b219f6e19f3f47dc5005f0716955092e23f72c90a80f1116dabf85f00b7457e2ad0d19b57fa3374cfebbda20cf4cd48ca125f6e88121741e89b79916a694867ed78cd1028082dffac2e8a7129c481f0376efa7214cfb166f161403aae7b7adb7a16f144f8df4153b834771765dd7d507f7a1dda6f2a665b7a673b4d8a05004106a217c0c68c83cb3c223f02d2db906c1dcf4bcf2db248dbe12f06c98647ad52902e8cf998da7515c08c4b16f4d182307553dd93ab8a89cb7043b9d8a36ada2b0147d2e7757570e0e6928b4944d652d90c05d60f0ee51396e4a303b1d85f31c545794246bcfd39bca18d06be82e86441d07480482fc3b450c5c376c3ea21bf2902e21ae33f5ebdfaf88bac5a54d47e2da6f156287a85d99c65f8c60f59489152195d8cbef822f30277a9c18aa8ad3351bed2e8117f47e452685f73427a0fb39f418835724fd678671ff9064a74eb755bb5a996301160733ae336ee6b5a550fef93465f1a6a05910f72d3424bda9291027de6f5d430e613158b943c3420037b298f41e8b9cebb6eed9d72ab6a2b9d67408a19b5710c611e8d678113eb6c13a674a7a7167db4b1cfe43369237eb1876ff42f0ef7d7374a1de2afbf0c60b4eb70a9b144de168ddc62877f6a487af2d39cc6d066d7876a7461def05d5918c580bfd8af4c86e994ca7436fd860989b72c2411b822e97040cf203b7f04102ccf979c571211da00753fa4491521388b0eca395a42c332679b5d889cdcf5ab5605e34eb836a1440aec695dc627390a1c183bc42e4b96a0c018417b12b6563878cda1d78a22ea1f2a964aca3b03226733f2b0a3a55ee8554ab9cd4230959fbe9dc646ee452cbec20afe12a842875533e2952dc5efe59799f3b790d3d5aa4a38165d9179edc1c68018eb2c145d4e1d11a2140a6d65b82c6ce6b35b92bfe2fc05efd29fc88e95296c924da0844e18f0a696086aaad6950c95d45d3758afdbce4a403e2568e2705731908cd8272f2b36717b6bb229c024fbab4a8343ed7fc9ec73fd68c92cb819bbdec8556a9b6532a5d00ba1cb73856f530932d77048ec7afb0de38cc429f582ff76d470a85a6710290aae7c88caf17a1a918521accaddaa69409be4660d55f34c77274ba23503d0467b4038d22643b5776ec31da3d7396bfb171f6a93644ef105e97a366f5fdd74030ebe4307c4f24f9f3694111b78d794751925a3007a9025aac73716e1594e2bf3d7e3cf4417063c829d3b7db5c815510d79bfbe3163145137df9529ac3126715fd9a1bf34908f772ce5c5304f719398dde2e18aeafd3038f700773bc174faa5b9b1b701971845b9daf09492b6fd4eb4be790ed43db0a98b0bf0b394deadded35a5571b8fb3d489f50f3d63938e7fc28bdd08cf190d895e13c47f3865c8a7bc7c8d76baf2f71b91a55a8add7f14018d47d6e13e585ec3c25d31cef43ab7ee9e2d7062b0b09099284e4f1f3a7553a8442c17ea3a90fb8df9a1e232f06069f982e186f6e26972594e17fd0e144bea286f3eb480e71de68ae91c3c47abe008fc7fd9f197ba116fedc7db378d7e29dbd7e3d8285df9e7416608484c44275876f4d6474dd74aa9f05984e0c1b5ba09b59d2a196d0018aa122d42f801cb177589fefc39bf2b08b2c4618c0bdd98bdf0e1cb9d5d62b3c6a2749ac7fa3bf1bbf3f8447303557eeb2c33725f99d082c8f9f7f989391a8bf2511d0892933465caae8d95094bdfcea533e90443a044ca8e061c75b4c603067ea021e8abee9ed98706e4128e5816bf46b0a0faefc8d1afcff4622fe43b6b0ba0eecdbc4ec795a2177bf76a16d97e312bbcdb8a14cff30b18fda80d6e65a6fffe8aac367569b697562ea509f8cc7ab404454b4ef0593f275858a4263c6a043e949b76762961627456a35aee384a209a04bc275267c3bad2a0a9e0d1bd803d0b3020365ecf8cce1428fdf4a0aa87107e280f80f4e86f3fa966c5689c08e31b7f185217a0596dc0d400c1953436db16f897566761a6160512a408355b34a744e7f670e47073b91cac457a75d36bf155d76be9be9c7d8dbaf8c2d69cd6e5c928dab58c9f5c4651a70e36e9e224b904b41791a5849e0bf5d3ef4716e898be5e31828613879eaa187674253266d421eb68fe7a36f4774bdeb7d7a823e925bd075ddfea9bc0ef27303b1ec6c7327bafa784c913ebc7b4d1b55c015e5999d2386c1340c9ecaccd50cfe920072ad96c9ba92c39fe634584f993f2460c0525c10682794c778dfc590fb8299a69c85be74f7df7d01743d88348e88dfdf3f8809ef07ff3893154a1bc57b03d6766010ca6d637b59c2fc9111e0e6348b8ca6cdfcd64987e232ad633cac9496829555d84b153c3924b74f7d0f2c4cd89b0a9ba093380b5286f612c601cbff164897110cc5f7dd18e4b63a4e15965b8b832a8e3c6cb012ece3a0239a7abc65ef2e9672a1fea9b0005c3d541b25327afbc833ed061cb6bf9a422e831b5522d4d224a7cc37dd3b037452d3f3b8ebd83725c57abf2e104cca5050b4d34e126b4d4c45f0e72ed59b2dd458e97903122126a2a96436a6ebcec9b5ee9f8164711a48e88645a059e874e1ff0e5ade3041dd9b52e686f86837a6000d28bc1efd093512e077225626ad3e1f40987b88a469fd8a758a8a401163045143b8092d8043ef0fc1bde0ded913c48e4233a519f9995ec0fa7c5c79dd5afb07027dccbcea717940f5aab9e805599ac99cec04861f72efa276ad6a6e79d79dcc256a21cdf22ef050d5c503931196e1dead035554314cb56f47ba5b0e131e96193882f540971b77bf039c69ab871a898b08deefb55fc6adbc9c63a7d0dd513563a5b6e26be8dc1eeddd879ca38b88555ff0992ca9ee95d03e1fe0245a46de79a5e5e44b7a78c071698a2a4a0ae8c9f09e18bbb6bf5d8c76951b5d94007b7b3d3f4072ec7c8bf9698de7a2f2fe2d137b65c7dd2e6a164390b00d329d0db6576b1acfa27c8a05e4e53bb7a2dd22d810891f9ed9ede151a0f556d2b5a7b6e4b94eee9fca1b5427f837376eba5f6c117969816cd85df9ce5f88d257dc108083727f6e30c2a4a0aaf71ba9eea2b9e1b4eca14ddcc01ea5fd71af7a2c873fb841426aaa874a469f72759d04812f42c75958c1296e9d9bec783fe2f58b18d040eddd1d3ee6970d89c848b699295d819ca4199238f7f8b1f8db98efd2be00ce4a134cdfdc0edca133144b55c4d56cf99a13085cdc127522671e0b3cafecdda0edf558256d3f85d7591cf802ee3ccc2b7cf5dc0d4d35ed9aa044b7f6fd12ca231fc83b5f7546502c16dc90d5fa5e3d748316b1879d76af75029a5bdcdf7987d1e07096f6b8076fe18722d473c0e39ec71f302584503e8a325d435aab076c36986eaaa8ab89585576d115a92be4ee83a0dc8a099f0e4a13e9d2909792ac9d3605f43db66f777be37cc651912d212b3d9d380058e87ad950171a266d50628d4b116a7544de89b91f1a5e08eda98aac2ae2ff8f29e05b16707421aa4e966a4cca69e8ef156e31ea7f349cbaa87b69ae2240b123721d20e3528d800988a361eb01565bbd3a72e7891cbbb03151e282d2c577734695e1017694a6adcbc478d392e4aefb6896e5963c4dc38b27161f558cb753a35888fe1587bdf97da1aee0852a0aeee729a75c88d0ca4131e096911a95092f70005b9ccf963d6a0b2a0fb7eed0da6a0c3d14bfb90b027c2233adc2f2dab7064ecc05382577be7dc3c897d04fcbc7db65cad483fc135870545dc425be6a35e12e6a9df26168109cedfbe18d8238b1e1d7d97bb1618c01a5c1767dff00c0b9ac9105f02fcfcf1f6d0df4f2c6d2fcf8c8fde8723258bf4de9ce7e61e23722e690974c2ae49736036108f5dce8d78b90c3f3447b82d70c3d1238e11189409401b0d3f16996223df7df957fe041533df28f3256bbaed91dbbdbec9696bba861564c6e58a61f988a976d735d691e3905958bc6f9182ac1a61e436f1351316680a3adbe1a1faf0dc42ce24440f273bacd9d95adf7a283d16ad57e621954982cba735c3bc916835b825136ba74c76c938f13e25faee8fa79520aabc0ddc71e65282e8076367777ba99b12be14e801675de0355fe67656cfb13e11bfb01d6d2bc847d8756493b7cb5b120a36af958a2bd553f0bc8b5f08dc30d66a11420c1358c4b643931b080e648282d410117ec13129e8faba1cf03ab1156928765415e57cd581681e302286a049214f02404d15cd6c480333bd7aee61d72a508f9a5ea95e86f5e13133d3264ff8a94b972c35ad2e0dfc751e2dd074336ab2322b7061861962660bd3523323cf7c8a8778bea83651eca28488df88adcea2a10634c8be02c3f0a43d050fdbe36043cc5e83ac78d368805df3d3ea0444213dca5ea908971629a1e6889c6ccd8fd08e3fe4ebaf229c897edbbb13d0bde796c44e9140f651f3c7ab26de6162e4a708b72be021e7822f03a35b6b2af27fe6c6b01165d462608607a8b1c01c60f7251f01dbbca4cda8e4de9248da6b926a6b5898b718aeb634f83eadb276f196e5e79ae214afae6409cd3c1905905fbd5496c1092903ef43efa4e9732b08cca1666639d3566e924227a92ce000e4a8b5013fbccf932ffe79541a158ff2dce156dad70fa8cc007c2875478f6e6b3625f75f32dd1ee72cc63b617f64b2349b3e8ac7fe4f8890769639d692a7b4cc7baa504e9ef222a220ccde4058f9a4ce3b9efd521efc50212a59ff837d1781d125bc8c16c384ac062a7b57a05e038fc29f1d702f033c756164436a041c35f09769d94bc0b43f2a179e028af58884549321d60c4796bcfe84edefd170e8810d05b8d1855ecd0f278b95d592e7aeba1597dab8e92d407550ab57444a5e21ed5dd0b1c85faa5965de59bb136bee3f3f2484c9da6b85ca4d8cc1220aacf346ed8c823f8102d7d8d30fd5c14e31353f4564cd212f658defd3396272f801a4787bc9e1e992b51249ef511b44c7bc99d7c3f8cad06fa69cc3ce5d3a47da16b4e7e776e00c62e0dd9d9dbbd16db790133239ef071946c8beed5f17777a506a9e286cbdb3e357597f0ee564a0e8074791412cacb741294a12a76b9b458cc69be222f5ff530742d0eba649a536adfc1c4285db946d37f26556be1c4b89786d4ff244a9f35b03d32444a9d5156e0d9aed5061b8ab5b8864f45bc9e5a8694b3e80e62f6f78d605fdb30b79dc44e2a2ee1fe5051cfd35b6d34d94a7c3b5ea56b221b16f46e1974460cc5cf07e163d08460faa43edd432dd99e1d37eccdaf1f3b8ceba7eb7f0f16ec94bae1a5adf22ca304ac7c0519725725b55bfd38bb1fa78809cb15a134f4b26d00bc837775372ca727e215e651d434303e3cc2f4f3ab114e52129c3c5251b89b9be36b997554bcf0945d620f6c89ee6391133b1b3f4dd655d31be555990b08fd82e94a874604af4baad556c0242a84f28f48ed1b3d8ba64222fa2381c26d8df4918db304c3098e9f7f47a9d5c38644c916b5b69a1f56591c72b0a89cd0373dce744d6b368d26e7f7caaf1537f15da69a855c6a148656a78c2ce7843585f3a83d1eaec584e9f40d56e908778d1bc9891881332b80147395b109fbc644d3004c3e41b83457f825641b968aa06a29ec3d8f54b54485d0f1c0a642c90249f1bbe16f54e80a924d2e48ceba4d2af413a84a98661b0a93633c3920e7b692a35d0a67c7b775c0a4ae2b90227c54c538316877494aacaca42d4f8cf0445d122dc9941a02043b3b7b22ea05e60b6f1e678875b1ca990a32f3477c390e506a27d95a1c9eb24996c9aface7e3a14fdc2c905d9f0d842aeae701cf5ab1df278e15f5cca15baa422beb1cc71e95c9455d5d8d9470608c4c75664476179199714e969388254fdcc50b2a16f8569ee0063ddb5346d082ff17a484526f43b991d3b39f0c01a41bda4c4d7909b5b193433d5b155f06afa0e10e791ba10879bd23b1941a7b30f15d4465d9db3c1c383f8a082cfdb612852c37343806b360ad9feab60a7e497fd35f02066f1b431d69497093af7e95373bc584b74a27a0a24a390f4b5bb7755691da5422d3dc40bb1e4c7ef8a64606fdfa0f615e670f4e8645b5d7e9469832423a539f406b829553c0e3a72f6a3dde171de40fc923dd7724c6aaf2998c7198af6ac151b98eb67b58174ec2a7ab68f227674d2b0442b9c3d4b1db233dcb9d35ad439d2b55fd0e317056258c8d640ef16efae35e47f9358b973a367a4b9abf879eb353c4016b7e78b8ccef115c559886bc11fc59ede4fbea38b09eaba07a5cbbefda62e995abfd94778e10b4b746864810204109b6e2ab10104daf6b79412f81a5a6ccd49710924b474d3ace677416fccc8cd52ef0a7edb62f805248192874093199b1946bae0d026fce9453e0adea282cd9f005b322591dcbfe0ea3adb5d635306990e63c89a7a4d5063ab39f00e5dc25cd3364b12adbf04826716cf7013c05516a1c5836f9f90c0a0829b6af5a6a1ad8e9b510ab6669f68228fc62c434acdfe0cb56116f0af8943d1cf51e1f86c18496c8be1c10b4cc3e91e4106e1e4264f54dc71d0b9a6f8aaef1b7e0f95c74d95f864a67413cce6c44bef73a3b69a46d7e9619c2f3633fe6a0a91b9ed0540a6e048a8aa6cea586d78d21d188395f90489b6e7f93571fc558ab0613a3e1aaf64fc59e7b3b26aa47f199234f58a1152a65529311cf7e228476c8d5beb08e093ee8ab359337578455a241635e4c944f07fea7f859f1b72e548b48c4aaf15eab01636cc660ff2fe33a8b0ef5f8dc62ef755836ad49df152d743e66d894c951dbdfaee3acd7cc9234b70ebf71e49499cfeb29dd000d8db8587adcfad81e0beb74ab54a9c15daa7a97a286c7cb02a4dde6138fea46dd63fdedfacbc6e8df2c8f232df9ecddb8594f4d033119322d1322326efad293baacd5938564f98485fa8cd58adc26732f455a2dfe57993cf4f6d6fc7803f1e570c5f8b44ed7807c6b42ab0ecbadc68c094957f5fb3e31415e9efc2e6aaa01e97abf1e92ecb6254085730a3371b3985bd467a626d4409a6c9fc7468da563e27f91a57b8844c7b499f42c953d32386d734c03e07742fc376a47c6637873e76c0359aacc29123d1325211efdc8acd071156d87a7a15645d3b2abcccdcafb553079fba6925d5f9669e2247bffe3b962b898a93ef14b964bb92e27ab4dce9423263009e0983b24dbce972bb65b1b35ce3825d4210a13889cbabdd6209941141cd68ab5f7c9d784b7b4b0f37d57158c2b26a9b52a3436156794221659a15133c2dcb6c9ae4268b7fed5944f1a41102db27b439805015cb86b553e05202cd65fff5044d58a7c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
