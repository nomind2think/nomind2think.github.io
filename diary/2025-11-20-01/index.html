<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4d0ca1020c6893d3762219ba3df61a266a670f3a1e52ad55a11979505dcf94d42ac2c2668e36480f2ac12d5e2e838071dcc42224113246a0a256ea4c59542a7720a1db80c2679cfcd82af81e04e911cedfa84b69cf6e2642d2b9de4257b2d64d07133bb5c991ba61f6dc5b777c30cf8fe99244fb6e929d910f02cb0386707ee70d594c51135d54ab02a70c1247760e259764f9eecd4ea29e7ae96b99d726b1eca6d86c0ab244d2cf3c5c179c67ad813546fc89048bf98dca0042253c52498b3ae23cd214654dd375d7e6fb09c84092fbaf66bb4b457f9a0269dbebae3915bf92b5f583567ccfa8795ed09c03080824bffbd3324ccd10751c06ccc55b097554f7e41ce4ed54ffb484f7ea904a237fa5728ba88244d259c75361edb64ac83639c5a671f25956594af7d9832ecfe83424fe09701605d4fe9377b42cad156487d9f317062a6b366cd4aaa87a5d8868900983e651d354584b915389be46e2d2fe0f6e7235fe9898fe3dffab3984675cfe1e846c0001fd06ee2611260698f5aa87feffb1318c00d8235b4dce2e90654413303cb72c5708e59e14874a77d9517f74667d7f0dd8c0296a1d55b3e3bd281a5a2f2fedc1f20950adb2fdd1879889823f7578588d8fb545ce581d3a2d67c062f4aed77a5d9cbd1969dd61d4ee933db55a18cf15c32d394436d9582de8ddd00cd36a5e4f6f44c1b0a9b2c9a6215ccb14bd2e8d5ea72577795ce93815a25f895507a0ce4c16782d495568f397dfc132111b0c20c1370604b695ce1a91638fd6c98f9c007743633973fb6eb5954678c7cc9dfc4c4bf566f15fd12326713fdbfed2f6dbb0989e627ee6a32c895a661a2c28d20b1874badca10d7f64e0883189f93df5a1400c56a04c0f1c1f15d79812d79e3de50a64b936ff6c2a2157172878e17088f74c2e26b76c00431c36a06b7ecab06bd980ebc53b552af484e7d4b178aedfe28bee7a7d919ea6521f9d7c030e6f9e262ab8f4eb0833f9199bd60a1e9eef28523047b48570bc992b03ca52e882c0010fc72df7f305999f8e610ae58e6b6ebb0dd6f0a0cb789e6a1633028c09d327f8552e9feb10424339c37aee280bf37f94d3795529dd9959621e69959e5738ef4df34f4995390cc8250f59395a7121768b2cda0e8a2a81f95807669c4283de38d341b6a518d55080520efe4cfcc187763b4543280d9461d304b87f0d07388efe0df05c4c41077fa341c7fe5b1d31f9f02dba9f30260ebe38361a404152ff6df4eb0c38c6d614ccd725aaceeaf7e7b263494e0f4e1168625aeb9422cf63dbb2d68702c33003ff748bf64878679ab3093b0b42affc6bca70bf947bc71705751e51a4f54e3143767f2f3f86c9b947bf1bb443cc90dc81f7561a7242cc3a49b795417b5865ec25dcd9abdc85d980d15ec2acf6b323e2de3d0f59e11fa726af95b57a86df37aa77140c5691f704475675550bb018285b9e5aa8f28c230e7d9f144627fedd6c281639fa4735b07d1778bcc4e8b5495b8b5fb0c4859ea350626d582ae85050171b43f22bf00b0207d21015b87db67e0125ca84b594100611210726c648d69d24f6509d75ae594f90ca36bbbb46cd663701cd1c561fdbd8a708d11492fd048dfaeae45b54ed029b3d7c200e59107d94af8d486f36b3e15338dceca4f4a837186fe16f9b7ca780996198848ad619d425516410aaa4bd326ccbac11587363833372d84dc30aad56efe5580f8b2e7fff8585d2d750eb17f91664088082628c5495adaeae450b1cae541c9f8872d45d26deca2c8a642d87ccbef16dee26aaea512b912bb2bc8fe965f2346e98a211ffaa6827daec9dd8e0be335bcce25405f7da45e1b179a7d9c6d699e5d34dd0ac9e12aeaa2c2b9afc34b54b119554d90a8843736ffe36e5380d94b36d15220d4179630c3643ffdf55c738f63c8d1c2e2dee712e1aca18c134b2cd3596727365d08fb9001cced19e78641e8705a188f52435e2c33e543c228bee0f19753c6625f1ae263ae16326a1345320e47b661b6fb2a1ded2c396e4c53ecb3dc07008c2a533b4ffd5175fd0cb9484bfd8d4dd4079b8deca485d3926bc35c5d9a2bc5627499f8e750fc7e5576055d27a1f41596bfdf88361c4975f50e37dc3e6dd6b20d62c3a380e764edb9e9e7b77567ee2944b14cbed4e8704c8adec7be16ec717fd693a3cb5094ba0dff7f3e0852a923988bdff243b5d3ec40034fad0f8ed67568acd80c0ed4b057611bf4725c1414b111eee79da061dc0924aced5155968576901ec323bd07c02c094d42c19fe93094d180045300182c13af8ae6df8af39063473a0705daf0eaab27b10988052c14b69a672df6e709d712b8072a1012aed8f8434a64f6b4f43ca5d7cc99de37121d845ab1005e5bde979699d7c427591de0813d61f1341e9faf860cf89d6fcccb9c6ff5fa21db77f83ea242564ce866b55db12f6221e6402538e436dfdaf358f46b154b114d888cebba17fdcbf998615354759aaeb5984dc547dfa6d9353f72c7468579915f0c19ed9c02a7800e474dd5e857309f2c1e702e37da59ad30a7722ed17a73fd0eb69f036ca1c4460844a629a71ba576d3b72ea012526ba7121ba02c1381640764c44554781f7f29b491c3d23a564e7c74468757d816eb2a44168af2cfd9a3303dbdb157304ca2b557e84a4098f88f5a3882a9dbfa46f365adb0b64d12a68861d0654743e5600d629d215f8db69a172c11fac185016ea50ed855fbef238b4540a94c0982c5b307e73f20ce309a0455caa365e6ab4d8786f5de77012a5c6ae8866a064e536197d372d3f9fc4f6fb938e3586cb43eec64cdea721e43626d13d61459eaded6d1673b0b25667115bed399f97a914a431a0a9b25b55b12b5f53b6c285c8300b0e28f9b34eefa7024e5978a7d0de85f30e161a4498a681c2ecbf42226567aef47eae72d83a33f7ae5bdcb618f9c3f811df5c76ccd75fd2446b8ae5527a273da9b5cd3609b382675a43eb775e9e632dd3d60b0401771c60f4cdfb528b0cfdb35164572f213f7bd1ff769bd07c8812027c8656433423302b80ece72f9a58e967e7eced57f5f1be9c3d780bff7542892745367739da6c576b265804a7857fbc21ec05512e4704dff2d55408b66a617b31a9327dc165afa2d32f12c3cd0fdc1b1a56d30ec1c8009d00b012ec292819076d51d2fcd0a4453e0d9a0bd05a29b31d075dbd89f74d88f9044e1956704bb6dccf16ae5ebe5c60df20c2f6e73ebfe568802fad1f44d0a789c10f75cb68d4b865f7d8340842f3406a9e560782f503a89ce6ca89664d86b187e01b49a9f56008981a1495839e342b8927d6e8dc06b6a27de24a8f6c24fc9e82404caffb8b12968fbb00eb8f113fc3f69760299b8d7417a08dd46d60fd5faf0235e301aa5a23bc2a90494c19ed95c01d937b0a8832e6a40fe3eda9abb664f16b3c6ee8fee924bbcbcb40c26fb22b450bf2cc591e7de50f387aa7ef71374a6e2bbd4ef6e1c2fbc8e8dd32e50bec4735fe250f0356d2bd672b6ce032139ec94f9c9bc2af94c66f71e66869b59b070d07ad0492713a52b9d38ae2de3170c91fd7e9de7a09141d34dfccb0bcfcc6c1fb8d84f161aece98672b9ed6b8d863c5fef2eb54a65e61367462c40ad83b6e04cade5b0ac259f9a43534ee3bfd8759bfc8b560826a07909791cdbc5d81ccbfa0feed2018903a090cb41384fa1412e0e165e0ad72d7f525ffacf471ebfa4a7a891ef0b3352aedc265a28c9c6ae868617748a0e54fa114f344ab44ea11e9da33e075f5987f65b21b6622c689dab82a469912421e5a6294182f130702a73adc4c7cca245c5a1d7fa9d3e87e2f0e8e83548d620bac35d08814da15e4d5bd025b5e40f6437b1368852c9b3d1d5bb28439f398053794c2c01edb026df720f62753e0c6a0856fddee1d38e994e92a773fbfd0f24dd7da802595c64bd9e2b45fa4bdaad3f7e33554be1177f97a2c75cc24883797cecf990455c52821ad021a46099b30845c2b0493c0ca77e15dee38d352fe95efbc7fdaf800bf14e709bdcf6afd71088eb8f801d456294690f774545500cfabf44fd61147ea8c32cfb077877686374fe9214deaa45cf3257b17b4b3351ac82600329dfa9df536089ba517f5494335dba0a6733dcbffd1c586920edd630277c084795aeb3e0d62aa5273a9a3c766f32cb56c217e895b879e3de9581174c07d444f2d0897535288cdd53cc1a9be09a39c4fcf4ffcc8a9682427ec6b54ea977c3a35018042333dddd101b39a2e02aa91211ac979cebf9f724834916b670a93521781b0942394c22d10faadf056ce363a8c51139fc378f142f09d8b6ceb6e9f328f18ed0490139a41f7c3657e71f3a859ca3d30f38ad6fac6fdbb12a6878e1ee9b1266df8d31959d81f383e688982eed1eed72ed8a1fc7498f28b9cad94352c61e30df60fec0755465ce4d13c4c2302b15861450d8b5534720fc1a5cd53912095115afabb8a7f260c9723bc83ea7f86bdd151c252f6481988255c06ba8183b850e67cb9557050689f775785311040239b5a0f3b6c363aaf83081d16297e5ba0a655f92bfa0534a36239944994848c5aa7ac3e425c171b84bf4b1e05da3a2c5e1933c3048ae855ef075509a6f04ed661fb0b0bbfe464723461f2f0a931899e186011f4a009e76139afeb733e9102c499a41dc4cbad8d78eada2745eb0c3630f02b0f5097d56bbe28b8f746f01c96141f8199bd049a756bbd22862a8ea1234abddf47d384e2aa646ecf48b513ec847ba1bf436cba18f9d72aeaeef701ed597e36f9f52f5e50bdc3e3b07b43609896487471b2e1c2e2a5f56808e90b9e0ee9eec01646e04aa5bd0840504b7b10ef5b64b9837416a2d0b79745520e446c113e359dc0edbd40d016d4eea898d9e85ba8f7dfecdb2dc79dbb4508176b16857649ccde8b2bac5a92b030c34da1901f2ddd1b487bb862fe90d36836cf89de3f438981d09712b7053e2d692a4c3c02b37b02ae061f38fb08f01a5179101f9a607793e6d26e2b1dbcd94e9f12664caefa42c8df44a573595996b33e6d2a8487435b244bb061d99ff913899836221ce0ab15e9da3f8408699d1bfcf43e965fd7ab51a3163e272edb940155bcc2ea9e8617ca93b34abb56cb63bcfa71bd7190a4dee8fd673add57ebccd0625d687f35eb61bbf09124d6199ad00a78c7627339a315e2092515a9a196dc335a52caf0d0d88d4e7dea0bd74f479daa6643b88115f1e26699f82aaf939886b9b90b8bf6f40dc5483aae94dc95ff3cfa8d2ea832aa6dfcd44667ea9668d8642605bc2b90c299879a03a957cd609545d6786c1a9df6474a4213cb034401984ab2dbc102e4fbeb80b9508a9cfbc0bf70100d808a055f41e9532c9dcdbf5a7be1c86e3262a41cc8f245d62002468e69ebcc5b61e15b5dae28d2d62fe415c1da3bf3853a95dc1475c60f763e17d3288d058c24ed6da6c2b8b4e2f04a92f799375fb5f306614b05daef24681c7d2ed06d9436ccd83a4ecbf123e3ebc2689a602dd6ff597955854f3f8933dbdf7d50a2df6b80bff3b33b7020b497acde8cf0334c1819a15496ca4e0773cc9117401a22dd1a7a835de02d85d6ef7e0ac95d51be25c97c5a0b2ebf8bd4d2834b18997f3a516b108be16d3d28054ce19146345306a4bba0b76a4542a61ac381d18bbe156c9ad804323b3cfc2259ac1b9e8542a89fc17357987b6fc36b2a1633773b4790cb5a759d5ee419297729981645310ca4007f9645ba8e01d16f4adbca613f0c25ab7f3bc22a1d4556ba0f3e2751d60b629bbcc6bfa5c2dd40ad7436e82a3bca50b3374d185c279c5a5db22f546d6daa7dc145b8a961eafb3da73e4bfc6946961b64b2e46885a2ae37b37c2412f12de10c28992f29016c9b22e4e69deff5a465aa63d91ec0ed2a3f810019d4e6df40e0110ee09ce0e94d9d233f5d0358f46609b4ae9f255dba6aaae791b8e4b0949455bc41473b57b331eb7f44af6622a39ca98fcc5b306fc1c310b85a9fe730202a4d80ed38eb8afb9ef8cb72580a24c1b608c8ab96047ce0c169fc8ca0b5e720139b74fcc6b7041c4b658499268af33e9036d5d2e9ad82d01a324c189f99b1ba656352dcff13e190d2619e6c9b3a21dcd354f74701f5532655c2bdf9a737750556a345e860580139baa5328c4f9566e6daaf6496286edf3330efcaaebbdd63cf0bdbcff75691515d795c5ed5a11e6ac663aff9ba8fe9fe9f1415b1db862ae1e9d42f6e506e117b3da23de568ff41a828bad5bceb4669f2ba53552c3b014f9db057176636b76c7c1640547a33c8ee37072bbc1363debbed42c80a3049bc828cb0af0db6235063c0c0b113ef90be524ac7638b3e63ff5f4388e59954407449dc111e64837808481b533da10a9ec8e95ba1eab26f5bcc69973a25b23f57c0149009c4222f4eafea3dc32b6c4407ba747c04e2cb6d25519cdf194d026a6fa5e49d9491eec33bae013b81ba6f75575441ec9f3ae65d02bde67420571cde2fb5a396ce023714644730dec89f7d6f86f4d9d3d78c381a331a8bda6133604509b2a8ef5a84fb8a531bfe4f5d132b0788c1ef110cb96b2163ef6430f4299b8bbc6379c516096e73143eb9c9f40c884df23520b88b10c0b057ae1dd5ca18fa0c0e7f76f4b587617247c4a13ddf1edac9b66f7f4be3597f96690e912471ef37875a6aaf6e4ff7e6fe6e1a7283b1e0c7f92f8ea534b4a7c4ecff58d19fb7e734662514a90c849c6c7c30930cd0b938b8ed8c1629f9170961e8d94794a1ffea60171191e7c179116929b63a2190949efa893b4044da02f510c4d438fb5899804e85585ed613e76181592eb71871ce0f4c33cd0d87a6c718d770caf82d0d78481c8598dc0d84b0f19a960188cbb482c5defad12de0a0e13c83d851c3739d359646115a0b25bf02925352987a8a0bd1518cb858db13a0fa64bc0ec3faf74823c94d0ef52585947ad258a8efc3e8c5e5eeccc9cb39e451ef592ddddcd07010b8b3ff31c14b87e81da0b046931f6935b5be8cff40656b8e1596dc1d86faf1a1d476321974f77b9db49ff095b8d06cde2642e3f09092426ed40cb6108f318d39ac7660fedd1a19d88ee8ccb11ed8fce192919fa0be76b1475182e75ce970074560fdac9e16c11d3b85af251c8c10eef9624052e6a4c4ec7a9f8dbfb0b1f8a2b7ef2be64fba4bd9dcf5100d1eeed3be1f070ae746e70122d8d092a3014c61be85ba24bc860b9b84e1d7eb4f69a63568dd78076dc0defbc8ac0e320fa52e254cfcc24b542e3604eb78ef13e3bc809660fa76e42a57a630a8b5d73504e07535c812502e76b810ab6fadf6b36c65f0a033c0d78a5026a43c05c4426a308cedbeb7fd9d1821b7036f73f3428c3e4b0e1e374f473cf4d2c06b122f5c275492f244fb1b127fc3620dd77720e324b8f0e122567a2ba9f279fa1b73b874b83808ac4a2542b2df08511efedf3519f141afbba2634b92c39862faf6fd384e1c2f2a61ddb1c92c081168e726dbc661d5649272eef270a22eb363eeb5d23f81444026491255878271c18bf44bdc337ec62a3ad7751dceab5b2b82b9bb853fd5c6266f823ce79e4c840e18a66c0d118f2fb8a4ed8f6cd1edb1a3b2ed371285a389cb34f8f37d9a52893452ec3fce4c3f1067106fbf889cac11fbbc84692baab2a9dc2e6e9ac27f278d2f6d9620799fc1be75f00bdbcadf3b26cc5cd042c7a58115cb2f93a632db9db01ee28d1e03a67e4ff3bcb4a6e216afee91a671c3268125c386159d3ba7e5d40abfc46acbafd3dae54e84a875c1322ec93969e68e49ef57af40fe44cfcd6aeb25e6ac8a67a67d0b391bd37b56dc9544936de6eb0c9e0278e41b833e2d8bf166a2184e8a5cbdc2525a48d0241f3906b84f72b8ad27de9749546251fc69ea145e8678b97258b66f832fb5579c082a7aa3090889c19d6fd203128b119fa74359e397daa999a214f554a86cffa30f010eda6b6075841320dcf382587aef18d5ae24a83ea86f92f45af27f0e3e1b45574bff6c579ba4fd0289e764fac24f42c0fd43c125f5581a9044f26f02050438458d9be81ed6c58a2230d5e539f4ca325411306213db55236f45a80b26ff1d919052224a21d623cebd6a7c30ac5e159202d9106113821ee28803c5527d6c0edc87f8ba2ea29ab15c62354ea33bce736b9004dc3a70b3fe32c5897fa63b6cb2ecfdea475d146eaf071e4d0e9afa8eebeb4b6a216020419f9c01c455cd67c17aca423107488be1e3ec2850c433a644add19aca15a81c778daade09787be38e8eb22fc9baf715dcfb4d26ca82e1537d2efd6199e6c5aacca2a82dae96e565e1342a9a754c0d16076ed73eb8bbea4d310719b9c204436c600e33ee541e1566f99d8aa20c830d26ab664784907bfe2025ab94dd766a04c41111eb749e3c45cabe52ef0611ce2e28c2fe4a65e0fe78057ba6b756a3e5c05673296846edef0d4759db5645130e1892bf7cc5c8b97f2c21fbc0e2640619790434fed21292814d297d536f842d1a2b6ddf6a56f96d9d9ef27cd2f06c32da936431676db1357ca4d2249f5a37ca8aed053edcd4ff5d04b2381945aca2e12031be29f155fcd630f15f36f1e0aba3d4121bec6865f14a2e66bde19c7c1b4e8ae86b14fba32f4cbb2775dd5811eefe483da4911f80ec7c22dfe921060e8676cb3bbc01fbc3ad142f76067bb7af9e6212ecde9495acf0bbf9675322993fc7b96a60f69a159659e444b60f1ba28913e6f4617072bbaf75f385ab7e462295065e01baee8f4dc120cc080f4f06c23ee454b8af51efdf36a213e800b3560c1229b068ba4fb0bda8e6ab1df2a40633e4f8bfcde47d410a54c9ca5f1a04d25a5ec224a0cbd1826dec948ee5a59f82617e696e26c7b5671af36c444480e91e7d1a35f66aa015f1598af147b20295aa91d5142170b5ef91f31b9c1eff77190fda27380413d92ad4126c55879ef2416001c379d613831f47d1d7accabbafee16c92a70ca3a87383e90c92b7613c9150c385f9c4404016a2514922cd923dd003d60ff1f5f6e0e9a26a0859176ce65e2f4207827f08548a94aa62d9c732de63f69efccde2d481f141ddd7ce7c4cdc1a71b44f9a01ac799a65d3ffa9a4264ca41a1a6d2441c7b1aba63c666115528b351441cc6dc69cbe70d27dcedf2a4a40d594c40c5b8a562f93c7c87876ef51381d0e6bdb528ffb6f705c8c1f5e50c027e2d2a529666c0548a9af2bc33aec82807aea53f134b402056f9fcb7e65919f94686f4dacb09b5e415fb9ab660743e4f46d2b9a892821256366f7437e9390bbc4aab6df2ffe8d422a5ac59fc9ac62081678f00a5dc93a3ed712b248aeb5ff3d02b594be3926f505bd0366814da19c174e37a412dfaac307a8f7880f5d950ef625bc1e97da425d78d75edc462b5df9b40f720f7d4e3203f662b58d07c8525b3304d45b46bc5531cb6c1a316546d121d1f8b9f5da37dd43df9e1c46c688e0e1d9ecce983ccdd491f42f6b2f2a52e2be8666c24be192d8b36265c13caaa80ecc6f2425dfdc9eabda395750c6873a26fc0f5940ce9c2d4a1613dd98d80762e93766ec6d136bc792f406211477a8413e63d8cee78691f85b35d0fee86517e845380160039aa25a5298225eb1d436229084678100e66f4a3a2517a373ee5d14060dd5246f178288a8d6615b013f19c891487fb872e066d9f3a17d9ea9ae8c655997be29b257af8fa25d6a64f061d632fcf4e59c953dca6c14961af9076e875383eefa80d995432336097acde151ce37d80ae955ea7b3cd1e69634e0cdadef15d3de36d34ea426dbb74cd6b70fa60ec6f2c1f69be055b34cd711d1ebdeaac49bf2d763c794b9c31de17d5231071dacbbb5506b9b643b19c75dad3430f87b0ee071aa36f8e3edf342e3777f3a48760eadf941845755d1c45752246699a914660f4655c3458c693e0e0b2d9d9f00bf1506c69d1b96884426d0d39aafe65aba65bb1735cb606a711351b39ae50fd7bbcddd9fb6d21514cd21b5662f45fbf595a745aa04495f490ef8a80cf954ece9bcc2a1c5645b25e851b0145823210ced89849341dce22705dc03f324fa3d6b61039378f5274bda0b75393068d79bdb4b473c952509dbb4a867928210bb1a4188395e37cdc4b0fe34e44664fc72ff4c03730b2d66675184128d058666170b7d3d3e7155e17e7df4c210369e13ec7d448364d5bc8eeba648119049c1e3882d9469ae65b29b7e358df173099a1037aa9737c1ead1dc7fd77bb3bd573f613ab82604af05e7097b67b091cdffe3cf9a7133d369d72fb369cf16beab271ba5139412bbb29f9c2c7b4f6b2ff7a125ad11b6ea631061374282babdd31741658cb185be4285f9499d3d98b22a7dab2811cbc7d0ed7efe39d841c0a5bb27d32bab57dccfd25e35ac506beb93ab5761f6dba5447f0ea258ab9de172fbc4471a7a81027fd4c2cd9346eb08fc685352a2847681bb9b2bdac4f5ee29fc8bda3d7805aaaecf4415265409f3d48e50370190fe83ee45eb61eafd98b23c88e98e09c97576fa9836ce09a463995e88702eab5ae111d98472ba931677eec6d6b009cbea0ab2f2e940b5c0340004e45cdf83bcbc8c234c33f968ac75a04672a1371e7f0efa1ec519b98bb400499b5ed30d76a36bd4e359f43f14a2c22d5bbe9aafb6b37e2c5c85e71f5c0f883dc058c3c30d2861f79b9c0c76d78b4e40d38197a63cd8b442b4bea29e1be0950f02b9ae71b7ac88dce0bb4a51f6bc3b3f82c43d812f8dcbd8a2b1c92b4495d66829947fc2fcb59d0aac64cd2c1a88a4950c370e92bcc367410211258a13f36607ad6a157edf6b2b3481ac7d8a3ab5e28c03dded962511b710683bb1d9a680bad1fc29b9c6df239ae81395d2a51609b549e37c675a738f9fff29803581494349e8e2403e7e6e1d1027d241a6628e151332f411afb7bc2af2f6703a8e55046ae595717f627a4db28a39d2e7832599971d77c6f951fdfb746c61a16e919ecc083d4e20084120c44bb8ce703a8e64d0d0810bae99357f858ad5ea379f616aa8c263955b9bdc00ba623b2683a5fe5d142e8ca69fafdb4ff01b6db2fb7595ed5ec93f2bb0d8df6662b52dc75f2d16e62155a77532291de9383be0a0dc236d31a4d715c943b989573619e4e0a6d94904481bd323fbccd341942f4903b277a51ff515ab79c4d9d1e1b5da92711884affcc2da5b082e56f4275d6ca182390749a920493ae8b907a1f2e011bcd7d278639dd4e8054e8e43635b4849ed73a2be6453be25595bf9ad1507ed04302be7b3f9ca3206e3dd48dc0aca1129185020dffabfd4576258aabaff59f68ebeb085bf3e5dfd2ac2fcee249023f30e88cb1c97bb3cb231a6df9e50528b8628bdf6197dc22695702d6dbadedb623f54fcef216a78fb5766cb3c3bfe455dac2253b707cb3655209c8bd9885bf18e218e619d32686b70bb4c979aad977384668296a2140b1d1649f40fe5df86cea1cf044b1347c6f09471e7457c795ff19d4aa3d9ab1328efbd2731a86a46b98c273ef1d69a77940e0bcd14dcf95e1eacf591ddcb8acc7c67398812fb1c0663a5c6d49cd3340a1b7a04bced97587705dd3a861a407452200dc5fcebe7489b089f6645c4b5bb253dbbf429763860edf59759b74e07147ac91b254d63841d32f2bb8846b88a04de33cc648e475fa33f8eacd61ee41dcd742a22a8190760790b6f94715c4ed74a91a0b0b54539b2cff1cc61ccb6cacebee9118e478831a57bec6b3c8f2cdd674cc25c709834d7cb1f0e22042e10c4c07ff205bc021f3e8a1db672cccf4e8f5cfaad8dfd369b2e12cea7b885b36a6b51e2670d19f3d2a4e06b99fc9e923eec9094cc042990b273c4736c9ba157bf056de352b76d694d1f5551cb2188e46c0de467b047fcbb8eadea1ab9d59a6387f2fce7fd6197cf9bb63fdad31a4e821a6f96530f1467275d3692795fa6d5d06f6458bd4df4f020432c841b46a307fe8595269c8d64f851615d6fbd68f27518a962d20570ed2cef87c0f34b8d692b04647718af9992d055535891316771086c01dfb50d4527b7e2ff7bba3bf92f407a56fd6e5e5a6dba0096b7bd279f48300a093f87783741a7d9894f594b3661e933fb9c27ced126c993522acab7f1ab8e4cdc425c8340e2598a5b9a7b0fa6c8305aeb0278cbb58fcc91c8c1dd4132a505d230a8bfaf83760a9a8b03208795654703366709cdc293376d426aa007c12c89732c728585b6c198d91ac31044e6c7629646dd0dc86aa4050e7fcd0f794f847f81ddc151875c7018915cb4c4fc5cf57356fa6f055ecbace1472e1fa8cc1f6e52a77495666116d0c73a1dfed5f27808dd9abef4ce1d18d17ae83c53e06d0cbaacdb06b139485ebc703bdb62181dbb29e4e3b38f064e46c4a1c7bac330535342d90db8bd64f7c5f3602bbba35fb29e8cbcef4e30bbb2e9d10f9a6bca6f4a346fc3e3922fabca8977fa7ddf7b70b26692fd505ccf64858164d78d7861d7c9e93f792f619935aec235c66f794a4a18b67f01ca1fa9c809b601e9faf529cc122d374fa81f330977287934b42caa4d5b55783b3378fb690e36c19d73b97cfcb88e693e369d431f94d6fabfdf0f6311499d25a32d602d9225936369331a9d3dae850f906cd90288784e58d739f6a9171efbd7d7c7261fc34e54429fa9b3e68b25cf19b0050ec97aac8f327c2ea11226a3e464d0a2578631ec8e28ff5e1762172bf9bac731be64dcedd4a67d809094cf0f4dde49f9e051de4875dcb5387793b218f22a7f529394041e9fa0759870f9f2c8366a6a6049dfdc8879693042511551c94e7f8e792dcccb4b7b44e4cc04ecc9de4df3067eb7df0b056b3a6c74e80bcc6cf5ccc5778e92a4bcbaa6588863a5121ad65261f7135c1ba66dd869e9044d176b6814720612737fed505ed0e5d004dcf58c1f5320f40727b1e378d7a7e6e60286b608dccda70a86d3e27485fe23c4c2aafe1596004384d1f707337b36c6c59ee6c9c34d016f6f785b5c7751625efab83ee508ca6eae0738f0b12d711adbbcca461d98cd73309fe86027418cda3df1360e73718232be9b9f18a90f7eb3df9bb1830cba67319c4c224b5a024c4ae77274a74ec8ec5ec7d3ad01373d191aa8135b6be46cbddbbfe810e3ac76adc13f3e42b884c789abae5f6371e60b0830d43a86e76d7186b8b3e9f67b002782af3b08f054a1d6f80f7fdd406bc9bcbd283ac21c891a8aa5e41e814ba1a61540cd3f2f064c4155fc9e861a6b9ff48b6ffc7d5772b557d10cec4c6b1f8beee7f8acc2dceb98d024b8e72450858604bb1adda8883d890df3c5fc9500d467ee1265c6f17bdeef9cf31c8a184f685913fc703fa8079b6f3f19019c77a21f58523e203f811619523918bd17de50b28f5adf0c7f997d8bb9ae7fd376390f869766fb6a55005b76c4e7bf1fee1ca2a8ce766fb3e6393b371d86ed7a9899789ba0aa5f5afd80d71709a56eaf61520a68ff408c159af4f2398c0510fb47af3d54aef274d72aea4b91de1b48f381116c573fad1e41c1c5e2dbeeae52e6dce309bdc7430ba33b58798d1e813651fa14e3a189780943fd9d152d99888444d61dfd675d3d347369fba530ec523adbd0409e5acf55fea90b14795fa17ada100ad9f7cae659d73e6eb62ad2e08fb6c4bd39708262820c0877394a0871ce19e72c67dba1cd404b19615276eded3bdd50a91cc0e23c2e2e3c11fb5fc62ad9d28f9d29343a568543798d7f4cd85ff897525835748d08ce6fd9df2d2f16448d1c871163808fe4bd55af50ee5eada438add2a454df6f42e1eb31229436274041fb85cddff2c2581726f17f63a44b73dd06d34c98309bfe52240465b157fee2935095583918180b3a811d71098badddf3bb70e25ea8510cb702c1557722b0908bbe81e6d678ee64c9769ecd30f223b384604aaf3fe507cc4a7cdffd4fe503b8fa8d924df4f205e3a70226f37c13598467e596d3d1d0b06d8a4bc948b1dc80b7a896ecea83cc6a7aa08ba5593575b021b9c5c8035f1dbeddeba24edc120ddc4ef1d44d1d336d4777b373859387a7f943f633ff6c4f0aef4630992011f9e7d584b8547a46b1f2c890155c51c3a7e6d0152f4c898d6e84812adc3c763abf700a3c177fda164bafbe18d238c353d5b5bbe121e9fa61c3dfaadefbf6d2dd9ab123fc521f0046633ad70b46d92565090987fb5d48a3a3432ad52687aa34f9d920d6bee5d1a6e3e2649e5e1ce76217e3617838278c344375158d9054499f1222f5c17b594457d4c1d15bff3774dc06f433275f08057fd51f6d01274c1a510a500a8896c27b679246dbd742f4dfe00cfd42248e68828ff53597d627099c64ef2bb3e92c325f6fd16454b02088eb1045b91d60e12b7c74dfd47430ebb27f6d9658fd63d220deabb859e6f4507a344d059af3ffa35e99efed61dc902ae478b76027e97bf0732fcd07dd456ad7038415a6d9fa87473a18ade04c0626faf1ba668fb787fb62a2ae1d42ec4ee11d83987e433b62e06f381745be73dca494501797acc268638ee095e322ab54d7a88ec37a6d6132db2c60f96111e693116eea286161772de78b4e5153306d3071009313ff38b3f486d89fc6ee730f6c86cb434096466868ba5c09624e22e1e1c1ba43ef3dee78bbd93eb572f451f27ef3fb312c1780f6770de0b9e4511a120e68d53666e5295858e8f159d2dda891762631d57358ed0d6d16591bd87a4fddf2f09c0bb4962bd534daf2b25bfadb4cb91ac734b68b66c3f1cbf8658e2e375567c6baedd1136512220b28a57be92d8b9602235af530f0407d4d2d3bb09564fcee7ae3e9878871fc97f4689c4c0f6f2fcb7f8080ab91a907a9344f80951626f693bc58edcc1e78ef72ba9ccd09826beb9b73483fc0a4c5605bfb23f72dae22108a84f66bb254e09111fe34feaff01f75fc0997a4c32f63f2794480d23419567a54c00a7b38e7122f56158ddc42e2bcde21573114e09d92aae25a9d195e70547ab45b59472acbba5e4c42d261598c56030c77fb05e96c6998546f3e92d8475c372a707a5709a33aa244fbcccc91fea6d8d8f15d10a251d7902744bf349698ed0cf95a123c4a6416b53956f5cd203f8097b70d738f59e0e046ed621b520aba213ed3eb88b1dff206d018e4c7a874ca6dcbb698d05f0da6f719e3ec401d5eeac38f262c0cdd258f0105802d72daf567a33a24a9c965ee6b722b1a749b26f5bb4e7f7d57ee4705f458956f01a153fdb63854509a73da37fe04b1946cb87d7a8c9028ed093e7f46e1e85cb0638108a4a3250d9755448c9c471f6a56cdab36efec3a5823f28d33f9fa4a991546b7e1290149d8a8519e6bbeb0a59d54854651aab86e8b3367d52977cdddbdec918870890311c5598fc7e4bf13de451c0e6c6a716853c3415278067f65783070db876dff9a2f3da87c98e076bacf917d90bbd8ec97be985aad9d25ac5bcebd45b67e59f890bdb677d7dceed2ae4e1a73bcc5722704782b249b54c549d1972e84111aa2e402c2fc2f1e8195a8fcf1d2e7896ed17d14ec52de03061fdaf22e49992887808747f2bfddaa73cb0da19c6db541817982b5d680edde81751adf165f1cb477f3357ecef84f79dc7eb81ccac120e2abdee31fa1d1ec982d5dc41803ca98c2da9ff88e1cb284846fe558b421067b54866b4e777bc1fb2bf66e52a7fc9747ecf85b16d9f428fe4b58b7535d0067a8f1f08690594d1688291603838bc3128bedb2e47606b1fd26d6c9dab73f8cd45ed85c38952f321d637a06798766f1142211939b98479a8992644dda7741e2a22133f3e87c1321e7efd9c9a237b9416155e8b3e5cbe842edcb93a3ebb73b05192b3326d179d6d7ca761c39b21379e284dc89bb22159121854d3ec3dc2b29d886cf84648938bcb548b58cc1d7617e0a782d0b0ad38780ecb12754d9f438d62250329a58e1a54ff83607c45f0b378a4082297f14c29d83910a2664c2509414b435c1199d131b043a93a4c33518d3bb2c52484c675e101f50a59f7e6956a595d7a2ace1f3d8eb3580dcf99abb875a3f215b1b623eb078f87ddce18ffc59776e40ae81612b833b633f568bc786cb79807ab8193566fb511d21e7648bb2ad42cff846777509a3a66359038c1a81af40b09d554f3442f22514dec636d762efdca6fd592c7151f48a30e6b6321925740d381b7d1bd9ab98e2297ecd1cc11da8c6bd54d8498a3c9058480eb8775ac683d110f31ab67ad277fe109058a7b8d2bb60ac177b695db0cabada51cdab4aa6878f35c5fdd6351629fdf362d6ba7a44528a9cd52dc1d986ef79cff10512e04741c4f32cf3b0e70460aa42922c981631cba3d07792114db81adecf506428716ffca1638a32d4d2aa8d068cb862d27d7e154555c221c5969b419fcc1b22a205a303ff3f7c294113c11ca7cd9a3630d0634d42481ac67022c0d6690b49f21f47a630851db78bf688eb1ef3a2106493d9bc52d4db1af0f2fc6f94caca3033e1b92bb051be8982837421de9e6703d3ff81c6c2d2acc0daecfe84b3c97f3ca19c6d8116f6492718c88c50bcc92652d933faa856c641187437be0e46886b916d4bf56aea61b80eb4b7a51424c52ecf90d81e1daae0b5ef9df772e660884990c3a759c4a1ac77ffe4bf9bca58e692353369c1dbe2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
