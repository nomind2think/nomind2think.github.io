<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2f46fa070777d9ab5b316412d7719e291d4958d6c584449130dea1737b678c158c70baa6cae1717362e173c1f2486cae46ba3bdaf32f86c96988ae58ba5152898a7ae20f6fe5d430ba17ea843ce1d556ccf66adc45316ad215154f150e76ba0c9862ccdb056feb46d1a2f498654dc8221fd6d5ac05592e35883e16bdef00b4aa87ae6b27e3f38dea4b4829993feb9649e81dd9ec27fb6c8af66010abc097c55c16f36da4c5909db3913bf3a61e70d46c4a5a8cd15ae89542e68b50f57804fc7f1739ab6c282ccf6e7890251fbd1dbd7ea9f8179a59d5ad4706244374524ca1655a86c82a05d0474e6cf71f989c56d5ff60af03a17c1491d0229946cda5fbc77c9a3747e70453f61421a36f7fc3cfed8ff8fe7f12ddb17ddd9a8961a373d2500495df59c7cc544ebe1dae8ac3d9ba8b1b392a1d1067f1c74bde86aec7c1411596ab69ef1d94f1bd57c94bba4e0829947c3fee3da510c9a4af4aef1267a56c7c09d99c44cc767b5d67380615f2b72a8b3e6d79b38b39469e1003170cd575182f00fb86fadb116bbf8e2cafc5c4f8a1080e429e4a8b4504bd09cb313bd06be4427e2fff552111ed1c786c4d9687d793d84779c705b49a9dad5c963e091973d493ea944b727a7e2d5676b6f1b4bf5e2e041a051f1996ff14e196f528543e0330566b9cd906c5e70aedeb5781abaf70cbaaafc2a6d3361428a38404ebbcad32a01397e27ecaa1f415ed93869d6466a514fddcd2b5e8fc656cb000b587b4ee8250f128e8a89e946ccc2ded4abfc65a8556a4e855d9d6273058aea8417db6bfa20a30c4d7646b0a61288b943166d8a4b3101059df62fddaa8506666c28858e53365cc93c5f89ba82b008f51312609eadd0df09c43090fd08dc6d24dd3ca4933d679dfa8ee1a0f10bbfecf0ef4f6ee82ec9e233de097b89d46e06c1e5b5ec9c5fba38fe1dc8fd1282aa132c9f5abad02170840fb9dfa342db5aa7f6af442ec1a41f1311a178cc1eca12c243def1b56d0b84a917746541c880b3a19acfe220bbee1f67581d58e64cabe9ce4069526d7e23ecf16f36708f7c2c5b53c0c74859430f575251bba9243852dffe026101674c8d2aa6c9f3ddd89aba7559dd1f669a04ada8b35f1b0713bc00bbc1a092abbfcbe849d3d3b9493bd8384c816651788671e9342225bc9e26ccdd63dbe42f4e6e4acb839fef29e1298006cd5102948373d29482ba68605454855d80bc289663bd87a9cd46d85e9d4f19ea62ba742e211269bcf33a314e5abf9338795773b14f68616e3d521dbb30a71f858be28e071d1feef08b294934cddd633692fa59ce2a90a425c55e00a429bc700cbfba9624af3e1331141ac8950e7166ae96f45b740e6c8a7c4da1e9625132138e7bcefc7db91b248dfacf7c19841383412cc9caf627c9c8146ee5175d6f931fceaf0767c692de16df2b4a85f744d9f6ab64dc0569bef221f681e34f49c57ca33459c6f8703e208f6b1b0343f82edea4a3d1b7c635bfc9686760b0e1d0021b5ee53504278bbd37633dbbd1f5cdf6018f7a7fe17f0fe7dd31c77506b9dde2de37b877d111928c5511751b6ad854e04aab3091de5bb2e3a7f89179470b16631a48aa278c5a83cfea49cf3577fdbc344d4e6b9c2f374dec39a947a0267eeceb689a3f6e6b2ad5ef91d529459f26ff1fae93eb39cefcdcd3dbf36991bab19141b8075663896cb82486aa508cf388a7299fd5dbfd986aacc7627cf449297881363b46a437d78c0c8e2ff70e537fc549b11efe4e2cb342aaa1c927d561b8d73ad258201fcc3fa994f1933d44009ad3bfb847bd608888c8686791e490a302df8d1f5ca34b4032350d71be7bf540e14c51102a29dd70cce81f60f46b779461530a7dbddb94bce795ce69f41abd9a4310375e5a9c5892624b2f3d8d7163b0aa5b600254d150d0bbdcbfd4951986142848217f9617fc2bd1b1cbf36d17aceae350e760497c8b54af68cd144807dfb55c2bab977f9ef53bbf7d1836cb22a8ca96ac6c896751c93bc935291247dfc24b1e02bfc179d12073ecd66c86ab1c26df09678ebccd7532205c547a52849baf35886dd078c46adcb6e222c0f0eb990c7f005f93dfd2891960411660b1ec849a2db4307554a4409455183ede15cf8ab66ceeb762076ced852afde6fb14c6db2c19314c18dddb560963d9723d73749a2c5470b3a393063762f3f7140654d610e469d71c8e47c0b215525b9b9416eddf41cbdc6aa00fb03e9eab420fc1dd1196f4973d38ef4f1086bdaccae4c750f26dfe88fd79a5ea14bfede687e61baa03e1e2b5c4ac91570889e8666516c21babaa73ae9efdc34dcc4a78b7f1b35f385e72049b9f5b5bacf8a32b5415047c3a467d2f33b037eb9d397c91f1f15bd69e12b4c4b761396d45d295de299ae670a0e12efddbbf8f06509efa63992e23310fc78476933d5ed1b5651cb8a4acfca4b580fd523ae962d8be140925935189decb9c3b7602ff7f107d8e7b29dd5e9ea88f524c7844fbbe539800cf21b5bb8cfd6c4c37b00f3541c0d6d29365685d344bf651ce3f28bb28e6a2218a5dc9d0a7be16dfb76813d0be28c523a98bff3d945fc62fdd1b6798009c50b98f0117c657e195d5c3a678d786d64b8e16df1c169d058afb18ee237f6b6acf1fa944c7dfc7b5474cf11f9621ad6db6d322e70d2806c36ae4aa6158dc994d258272f6b89e3a4d9dc62a574435f71ba730aba2f89d9f8d4bf06601ebe9fdc0628276a6b373b7202fa393f6cde9fa14702168c2f170fe6338d1c50ea74d8e276a2c3c4f8b53426c8b81770125ba6016373ed1606584fd7a0cf770b31ad72d3d32c85530b1c22fcbe597778f8d8db0268ac5ae773caa6d0bf4fa9b98f5422c425cf4ee2b6b8b6106b0077c8312579e2eb084c8d5530c081fc73d4711b3d63d7affa34a8cf5e93d458c3bbc3a89a132588c4bf990ca0fde7a014689ff27e4d93dc6ed34840ce29093351aff53cbbefc89ca812ba1a48449e00e6a4869e8c399dadd414f2aae177702b23e76e72dc2239ac7e7bbcffc0aefefa911c48e67f9cf8409f0a39a6fa30be8ee79acd59386521b791539562c6034e706d6d7b6b113ad0ab25c895da6370d67ffe98b4eadee275628d5d78b548a18945014a9716c47dadd408f42ab0233ef7c33fb38920805acaea78906ae7adabce7fe5744e2e7e1f1e1eb5bf1d39ea6248fa0765de5d6c00305bd4384ae0367f8535c71af89c7fc5f8a17db16bfbd2618e2d2736c518de0678ba2b274f0dd267edded1956774e654c377d39d5b2f4de4de6c99a0d59dc33e68fa2fc50bd79d8d61df4bbba92e394ce8b912d40717764ba3cf8c1ad31544179e23e5cd15dd2ada476c324ebe2425113e1bfb9a63e1d2e5eaf8c412efb5d67987d73d74988a558acb2131eab164fc0362d4c8bf3fb102149aadb406a2a3efdf6927a0619d62ee7e6fe678e36c5365c60036b193a1dc7a6e763e416ef1c09d1e22f47baa0e613a9e762d093c6c782f3deaef52d657951845cd547605b8589304e777c2a185db8a228d4c00b257786003c9db27a3d27b33f6091d89317b0c02f9b4185f18a9abdc72d7044708524a2c1a78c1041c11d3289a7f3d18b6e98ec930bc7322d7b27678360566d0bfb332d5d35412242d2e3378f7f7e8fa8d79505ff5ac0df66edadf2361fb5095ec8b49083abb3c7c714f855460869cf3a356c90bd9980a5773c4dd6494b24256ca4dbe07225fce7104bc6f67727f7e1ae547b955f3dc0d5257e0f8ad8e573be9dcf3ac9a0e42e26881f9e4381aa20ce1f0e659b6eb70714a3d89b95a8213a21d0a6b8119860da445929eb3fb715ef67bc11f312fe5a4f202a6a3ab796f27fead4d7e3a392383e35831a2ffa5a616f21400ee70b3713026a3108a58a8546dd3bd0b671d75b5d533b43e91aec4f86dff476304dedd69f383227e133b8435718154f94262a994ae0f3d0a1ecd405f7d2efaf0ae78a75f413b9e63f5740556cd5f68a4d9b532bdabb9c577fb1ec652dc495092210edb9ea2434d40f083d906ccf49d1b19deea36c1d7781c1024275664e61ed63f2324c8a31e921d880ced21a722c82e01183730efe0e90af83e479ae93561e6dd3b196430dbb37b2a8ff969c21fb6253e81e6ea1b90939c3adc6d6d8349a4e2d25f05af56eb1e9105c50f857a5799b9ed73f8306c60a960ed3a05c6b3704457738469608bc626a1551a0611868f72a58f99dcdd4c408cd9fc61e60ebfcd70d2d6391d815b7e0d453ee272a2c187afd7b53c6c82e7d69afa855ea9c7e31b795f796a9316f35572c50eaf014ac9ef493d396e47ca26d2ff31be6a27afb522da5faa7d6e608a37bd8e16a800efd0e602aa4437f280ef29c3816a3bc38d21d1230c340a632915e1fe9c62383cd3f5649903a9571f6cba140f1ce7e93d29fe6aa7338bb204322af54d65e173f4bab200cf60bdcf879631488d62d2b19b7b4d47a4c87f367b86fca133ff0f19d79c2836ecfc25c8578bd1b31d25b9a4fe165e8bd40be99fd10340389f1b85c4da29c2368b8ec1b71fd95f5219c870a5cd3dac4b7483bbe7701f1176b6f5306312eee8fea1266d86eab683810e8e52c8bfd94b0f6a067da4ff0e24fa7585b63a5ab9e21d693c5ed08c607a809d71d2fcc6acd9cd79c54e78961311a0e1a5420677d44889193f3c8739705107c546775dc5fdeb258c9b46061eeb192e8a6a056bb86372352f4be91b3d4d606774e35bdeb9068349b6a6e5d549907e44bf4dbebfd34a8cee7e0132bcdffb0613a737a2f7287a5ef799f3bd5db0198c208eea0d9ad6cb7c0f6669f892d9fc84ab3294cda8ece2c3b7d1698b2cc349a1bb7924ff870d6a7f92f23be16e331797b8ece9649b0af03b516cfa047d8441199febdf9ba252632d8e03ebbaac38ef77003b8a4dbd82f048b31954dfe8c9034b6cdb165b9f3c0a310d6b940f6d2d3459760042be12c913c5171adbe9ecdeb789b3aae3882657b850bb0622eff359475327154cbda775b1036d0efe06ad29c5335b6ee6be7bea3662a9a70a586fd380dfe07e2f3d61a23913b2b01cdae9ff96b77cff9aeacc872133b4e682f883ad6e405d766c73ba09754b7f68c722317a5be45b756008e8243f20120e0666a577dee38d5efe64d1eb852dc5ed8fb60a5f0e8af2378b2bc6afbcf96f0527384d18a6805d651f817d0c4c913f232904f6b1b1fb9141aebf790a7ab2e3b850fa11760bd15fbb0a146d13341abfce5a0015ff196461cc8d1e5871109cbd527143fa35fea22bebfb4d7b035089ebb941c4b5ce5884f586ac9f2e5d82448d6949a934217128b2ee4cbb370f7083b82274fd5a92b5c5ac7011cb1d77fbd0059d3b463e055bf4f733b3dc6c6c591eab5df50f79c06779e63810241fe88df256c5d2e01e559ca05d371644b1a92e108fa031d9324363f70cedfde4c2ea9335f8d2b2e3ab91f4cf8e2da8329cc4a868ba6c1f57a225436288eede0048d4dfb60a90b2a4eaa7c1bad3043d189cf2012605625a350c9eea6a17a4ea318cdff1f80de9452cb232918856689467281d4f0ef1e89b6f1cd4b34ba2344227a1effa36efc9b1198fb6164d88658c22404bc086cc0148c54cfe263711bcab0cc5a3c1bbade0b570c402c96f9ddbbc4fe36fe08e2d7e6f5e9679644f03179167a75ca2ec428619c913cd0b9c08647bd8f70065df58d73c4284ac014c1e8a131471a5d3df35d3af086cc4bf5d9a90cbc200de086d0d519becc183edc27cb3890d55a4bcea688f901e5f8c32b01a1d2bbda5cd01fb881cee98c3422051ebfca0c0eccd71b805c3630890bfc8ee77f8e1892ec0ae97fa17fdbce02cce18408075602a4c51c17afadef796f4cff2b4bd84e7b1cbbc1939822e345733b67cf8980b4a3add82449ac8409752994cf4247a69efab6d564d6c24dbb6e1773f34682bc2e8382c4c7c5a3263b4c0176c428b9c9cc50ce549bb92f77d6304461a58116d7d4b19c7fdcf4e61070cbbe8b08856b9424a204bcdce7e251451eff3a32a2abf39968340e4a92b69474ba915689038c690e4bf2a7948be4e031053d6b7d59728e7ba99b585674478eeadb61436ef08ca74ed36b53d4582e637324da7df473bbb6ffd4801e11b495a6cf7f80dc2ed7793d61dc5d033bef8c0600af9a5d2be27199d81e4a3471f3f0a8ebd191f2afed8391472fbfbe023ab4ff7295a28501b5f3ec8dcf373eed17a0d78e0082698a3b197effc553ab3d17b813bea2da5667cc417cc161847450bec110127fc716f0843a29443a8264ded3b4e671b419c8b413edfa5bdfd36f84e3ca83a4094d1ee97b6656e21d02de146cd129dc2e5475bbb3f81b5cf124a27833ab402e60ce49a6167a7be14b80296949db2509dc195285b11c5f317e3a46b8fcdb8b5809e4fbdce346aba4eec3933081cd2d11a32375c462862ccf4a9ace0b3e5834fa781391685ed03627feef58b63cde9465e6dcca60d207ea04cf637e424ec09128507d77c1f3b70e7366cb9b17adf23cbb5ba42737ffc7dba63f239e5b5d476ee470f184315671f6e2d1eafc59a95c0b265be32cddfd60a1fc211960324c1862ddbc3cc8b7d26859fd525284a5bc6987344306c58e545ed264556bbc6c13433cfe1857a241758fa06da67c9dfa7e8e08d1399ddba6d0ef9e508ca54db69c1150048f9509ca751901c936d0130a88afe8ce96d9549ce64afd1b090bbcd2b1abc0a0baf5c205b189655dfb28179828b7207b47990be83348f7a7b94fe60b607fee77d2836357ddbf3dc3e66693800d8dcaa16a86457acd7de9f494a4a6bbb14138f40fa4569ecba91ad00f5760f4e32360361347cc7100338ce5497fe23ed9e01bc46254b0a90d2cde793f33f4ad5c73f2c487774be9c158d265d326eeb0279fd12544262071539656fa18d3e5a074fb70839f709935a54d93aa913f64aa0403591c87b5e2efa27e73add1329dc274dde2641eba5b62a275af0908be79ef09a57e6490ae38e94b9adf7aa88b2fac0b7df3ca7998c67b908aa1c7145a426465e4428e5015df680e7b2ceddbb5fd4a9d7253eff62844ce1ae2aedc63f643a3050e642438b6f774919767f034987fd28dfb92db07a3e4436bcce9ca5f4e3161a070b70abb27070f5c116e9e3af745b7b5c362f9bd7c55585f33ffb12d07a7c5961daa76a243cbd51b2b7073cdb56660adf164d6451a9bdf49c2df9c8626b8ca2a2703db4465a74f28e9d51af181792e3d99e68ef082b85dc22751008e162bbc8da1c2bfdb794e01cbbead74db1db875c0faf94955a23f2d380dbfe538aed42fe2d7a3e0730f03797f397c440e4ac559730b276133938e085b119c195282ed273fddf3ee6a591f0a3a76ee13a659160bf49ca9fe297c74c28b1cc5b36d9ebef50a177e4a0177d08b78f0c71d25ca0d809168df6d072bda407eec9b819f54503d6fd801580d006afc17c7780f8fab7d42f0f8bb34f2c7a4512b6dd8d9c8879db0075982f817c941b9586a8bcc0982f6b93c5b362a4fd6fe8c68026dd71a2058ee690305a0fb701f92da1da10f81e92ca946d3627a9c7d43426d4770c8ee7b9b49417dbaa610af93726dd95846cf4cc939c32c8b1b9be93b3eac73e6d4ca0e186b094b7900bb1144e664bff7b85cfef7a4a45b6081b38d81c04d01e78c3af5008f50030953257c0cb7081cb08db326390c3bb242e8affbb7a423799237a94151fc946d4106cee65813a564488534664777b52a6749fdc7a283e81f8fdffb812764cb8e0f4d63b59d005480bec956d63c0d5876bc1e33e7092ebc1df54ead943a25469469b30a92e409604321e34e50bd6b638d4f55115b480ac9d1fa616f6363903ebc30d79ad265abc20101c374f20baf660364b9cae003d35d86dc54b5aa39d44c8785f76a3f288d5ae9730515ff76556f1a25aeceaca52bce0e6e0d41a776fe4704df02150883b300ab61380bfae026118c9cc36d1ad5bc2c2caf6c167d4196e24576a74d504cb9f82a8638e5e32e96cb11d227fc37e197732fa1813aa488038930aee7847aa0b2f7e6857b572c72f3aaeb4f379f7fa8f629df1c610400e584eb1e400e2cfb5a2d5a00d30b9827617e3ca21aee79354ee24a71e3d7815df3125bd0692405b6ffdc93a4952250943d8cab9a2cefe8468cfa296f85a6b392dfa7f27110eec0bea6a3fc61b053159997b1f18af707b18e9e3bcbc0899b6fd47238c0db595c6c8ce8dc5df65ab5d52e7a501407e02a3171a5e4d1bcc7f2e60a5bd35f2532c7a1febea35faf9f996738c3ea0b66b92ca9adbb0b3c22936dcf3f7d02317df16ee141ba5d8f3f8d4278f60e8c889a9809a6064de03d100b11177ca3f2ac229c1947a23637aa265eb806d942853ab3cd5c62651a1ab1ed924045a5308265f8c3c70e9cbd83a3fbe16ec8179238ba4f7b96c7cd7bea3a9f9a985a10bf8964f1374128cf4332d8fc97f554cdbc773bdf60205c3233135b5feb0453134d55d30c2efdd481e8f6fbc0adad53114d54d1cefd765b1bce5e08a9e00225caa8981faa8bef7890f5e3d9b37e48b668b29c09790176ad73a56ddc69344e70d1d2db2599ebf31c6a68aba3bb269b1d0ddb585c2dc814c13a7f7515dd4d510d783f2083e1c515721bf41de010ae4f62ad995edd535814b5381c4245c68d82a69d051d847704fcb1ba77c85049712b6c81de69fd68c3962630222429337c3248e244a83e43a9e383c9e4157d86e3a93977a5c38abfb25ffa175ea4bd7f0f0ad738be57b67274b97e48823a18d71a0be287acb7bd8765647f68d2fb65ece8b8cda7025e29e3fb8910710381838b29704f1f1fd9e0c90ece894e9c03e5cc5cc8da3a218b8d59364f51bbfb1cf12b611e605f7b1bab3be52c012e94e871da86fad9ba14f9976f0111655ce2943103a459680f5c41bef95eacb5c600110bbc0d0e64fa026e3d4af5c03cdf5e2a861b63439007227770c038b16b1c7fe24ea529d2d1f93317cb0a55d2c957f41c54bd21cc272217d1933669de8c2c1ca1184b2e3bc4fd7b7fec314415e8259e4b0780cbb89a823593b8defb3fb9981df3fdfb78605b756c58dad02b837fb30fa0b1e5e162416b93c57bde16080f96a362e3e7ec2102e47a82e3c66128a2bd5044ab868ee2cb6d26972db7158648c4ed5ca18aa6415642c47266533ac138ca71a3e8f6b455ea8a2b4a0c6d112e82a2adc27a1150cbd17f56c7684cb8486f0fce31aa374d5eadbc26092176bc31b330a2f69b9281d75c792bee6b87ed77a55b90b0fa4643a330d312e54a09fa45bb2a8d9b779b8a29ccb33a844e03b2e46a02d9437023eebcd2b5f88c9108e5130757783d73730c85286df3d5dc33549db5cb013b05e3a7efbffa014c11098401059b0570c479289cae73a35e860401b32ce9f0f0fbe2fb0ee14994dd339a73aea845aa5166c1d659a45a414a41891e3293b2181e164caf2fe8553adfd91e2a9dcb8f8037f6c2132b5d9a9495f73bff0bcedc8fa6a305b905483f5833649ad8dbf811c0ad3cded9ac37b9cfb0d8ae5c92c7533d5d0341bd25f3ba97d775c2b9da167d9f6af406b523ff2f737b6463342cd180c521ff2d27f3cf618166a3e8ca544f6749dcaf4ad3060d34e73bca7e7b032bf5cea2f4fdd189ec97e6cf809a7176d157c46d1993f00c16ff333b153c02bfe31531ede9aafe229064379287a230607efac2154da6f9288b013a28e7ffeb38320b3d004eb7649447a1a0ca44ca5741466eacfe851615afe08734da8773aff72afba50cabdd1b18f400c0db48d2228eb1259400a4d3edafcd19c037f36d89ad3490a25035bfc485bde664574c8520ac99ad3659086b9e4fd20eda0cdb3d5ce73fadcad44be078e04563593deb3a5d42e5bf0130c2a73bdfcd1380be068e614dadeb65c4485a78e0afb3ee670775611b97a239aafe64740d2288e12151e9ce82dc1c6d5c7adb65a21d477b00564d99dff0e0f0bb6afc403a0e3de9ced16eddd36a45af399e837d6085d7d106332cf57413d3f5c9a7bdbc6eca9fb7269ee282b7af87259dbd13c6ba44b571c762552099ce563c338e1397c6607398108b479c705a6e402d7f740c86a1d77c7b8cda712efe4c14b239c4bf45298faa0320150eb9223f3fa39c56f583719db73bb42a8097529154bd2502b4476d6e6ce64bdcb35a13ef19f65240b6f72a117773cce42d9e564c265237d2547c893b5e4b3fd9f182e79c94e1d163072330b0a7211c1428cd9fbe60c79fcbf86fe36cf0b99458db21c8c45d2ffa52c40c9c3b99cc16b0b2f666cf218dbb751b1425e7c0179db1bff54fac195373ad2e9406270f88686bc8d9da37811a0d2a234553b2a7c441a074ee0d5cebd2c2b60a5b7a44f258759966d7bd64ac8b18ba267b78685fdfbcd5473b300923257325c9e3555e4a7973a3ad27d6dff69502fa2f3be230fd956f8bad862a6801ab7ea4ce9b716c8d085cfc6991d43f6e23ef80738e90a12e1eaa17fb3fa99e2cfae0e06eadcf8ee668b3b88a89d6f361ab18a4374f38dc1800d348f95fa03749b82f8157d34e62b0c2e32a7ea6d01344f39d33d8616bc62943e565cd3c57f38cee5868c00272d58163126b3c3916be6e91857697997279db9c177645591d07ffd2566a0cfe81c5e4ee679ad301b7c3297a5ac13aedf48629d3bda7ef73224e03994b4d1bc3f0a207142c194bfec4776aa8511598f67857568fca8369709c9e23fbec56c90174ac0f50506cd175449920f114e7308bb67fab284f818cc6116cacd394b761c97c625cccca70f423383537f1991a81dc587e4af082105b6df68c261cba3082ef12e24d3af356b388cbf9dc3356e73336bc9ccacc463c0a1a752540e6513aab47a9f6cbd9d40cd5f0616edcafdd171a218d22dafbd0ff0a2ffc70d7a3b60cdbe33e54c46d688ac7d9194513fbcba70a8be1ce43562e39ff89f54e592b6f9c4f30bd506013e2c87884a5ec49e21a3f55a8c7e8187d4e6b82313ca8298638fb1140d9e2e660b51d846a524f5f13991ef8edd19998d6c5861ba625509914be20d61763c314931684b8ac06aed588e44dcf2270874880c07eea3d108d5428ed640683be046f0f8f24ddb0e629c59188d828e1b460d9378e5863d16a4bfa521905288eed32f40d86c76dc753e9d0f4a1c9ee4defdbe848f41660fbcb550011ec38ede061bd03edbbc859b289dd1ff46cfc1a2da1f7a63d995eefe6fdc6ac6bf7173c23c0f3c8543a6801ace7ab228236921dc88634ab3089dfa39d8f1ccaa27290063aaa6ccd1ff8d0c7e3ef94e581bd4f22e606e37539b582d0a190f0ae6863f697d7ff98a730316ca5f3f66537b4469488f2498bb97905a38ca4387169c9935aa5ed9cb3cd3de715cf84b0c1a1ce1748c221672dd3dd65e2c8c2d294319d9fababb2e9c8ca6ff0af15c5307716b9842270f3583dc9bbdf04d4dce1055b256d3507140ffe72a5a829eec4c2913f297b40c9a53f912fc8421d4b145e300f02a288a2bcf45d348de7a0569a1f3c6f7ba6f57bf1259c3190737d233c6f64d918487fbe8ab7407686690ef3053a9a81394ccacfcc0b1a60a349d45d52d64120bda2fc35f2747675d6ecd28bd9e786625b0742db8773d18eed8dd192f1a569d3d0","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
