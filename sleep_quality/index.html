<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"059e22ac3c738bf8ad24d51a82a5e15fa6274b4a75900ddf8567d3c71b3ef3e701a67e7be2424e94bab012fc48ca5b4af650a7295ef5e054335d4d1d8d0247cec96a46e4e49f2db42bdd2c271b02d90a9d1e1676a817d4f2a57c816262977165563ceee1de4848739cb5e7d9d2a25b624ac3353c4ef0c8f0f5707b899c79efcaa501b16b0c7e153f539f86a12a7f66e67f31e566b67f5465de120f9c1bc405c5753639efbbf86935a086cb0e2aac49f0b370c50476f36cb3b37dc66b29afb15787d77987778e1725ab390c018ac10540a7f7e207f82460eab63244401840db91aee8f16089c68b6e5cb9240aa2c7af7d6248ef4a355d34be12b03b64179d4e0a3171f770ff33e69a81fdaca0fbf0788af3780595df66b0ad6e3f5f9538e0b5d5ac4635ec7879be05f19e69b89bcf70b789dfc460ab096c2438b855eecabbc002f2dd2cbca4f0f97338a32b13a26f48bb5d7342fe3b6bb8c23a2d200858fee3c9332a735abcd98c48667d4986b0dcb2a39745d4b34d0c23e02b75d1dd89785186894b4f3a5aff8df62fe0385d99a1108bd605fc09397641878ffee3735946cf77353d3f71c4c46c3643643c02cdf0e7ae5ee5f241f2160d0aae3c0dc350bd4f7956efd7191e5f29e2decf0f8625b445384b00b6dfa33087b4c6a66140fdd331e1d3920ff50a048beab9fe182996f7755b9819b9d2f56684594ff809aef694bc11f0c6cbaf21f1b4d43e4cc734ac20dbc37b05f3618b0dfdbf0c412fa4cc6c591a240461450d9350109cf0ab372961c3138b2ce06139aec08d9712711618ec8f7f93c65cc47252d76511a42b40bd744bad2e677ac5f67a94872b6f3380965e05d5fba47c691e78a993e7f427a447088ad012fcfbba33e858d89bf157e2515e1ccdeb8f9eaeda0e88487def5adf233b0d4d31b56d05b414b4b1bcab45231d2e817673eae03124beb26e68d8b7eb0cdd28d809a6d7b94616e23a9b3143873027a9b4e7a133002f8e5f04b8e7e24b73781aa3eefa4e4443537a489c0f3c0941ef832953ae2a82bcc7c7fed8a5f8ddfaba1ae23a0b6682c958191982a0ec075fddcb08d12cc3d4378f1eb5e547590d3b324a05dc85c5878223ff186ab03937fcaf04fd59c7ececc5ea9f0a11db2cffff132f97349036e9e0a6fb9e7e0138f7ffb52eae039c40a177b03822a036a955b9ff3130942adeea7f8b11511b9957c021fae2a3d9ff883d6252e9e2b005dc63e4ad800a3cb91b811e64d6a365acbcd7f8270021783aa2dff120d68eceaeaef60ab404c7ab16b0b2a1f0a5ef74d64c0cc33135b13189e2141ab6647ef8a8a3e84d54545115570efc4ef836df9a76d9512a84a7d0a1a785393238ada9e044fa8856de4601ca36d74d5c87bdc081338c9c38c9fb4774e11347cd990e8a3d685b3022c654e229229ce27c0f530e88077f421e6d640725877e51659111e6f283e9b0693bbab5b208a73a94d5cd732c7718a104c7c28a64ecac971c84255509ffc062f45a29fc95d7ef334f61d9933cc9d40259824158262cf8a0eb4df4d2c377e6e9791a5d2aff90a45633d7c0f6ad06def27650aaca49b589bc4249f76763bfe63bb805f66de6677d3e4b96ffe9797f803171b456b4ad4ecf118d0fa04615ecdf37c5ff29c01b09e54f22569b3d642515a533f0a21e22f0f276b1c114d8277b18ea367db6d720ee5f649b90fff66dd515125614f7a2a18499b4299481017fe6f40148670383a4a5733d25e4060d3f22aaa59b10938fc737ca77eb46b5bf2eac38a8c032523429c1b63492627f93c4b195edb902717a91c4f79227b1a7dcc1f0a0357ef58d80b13f6070c4bb9cd556925ace44a442c44f4f4fa88b6fd46bbaec64bc1dbdbdc50125c26d02cfe749ae0cb4ccbdd30f90488e13ac0d883120c997791ef44484541f3a980fecd9320c9cd9e78de0f960d05c26cd394db4d4c8d2f01127d0e41d77a573589c368ef5fb6028dd94f30701a400b3b48845f2a43864caf85ef9df642b7996fdb061f38e7af23e3a77b84362e1dcbb41fe6f1d3c6ea111df6559bdb8ea55d18dc230624806ba991d513d2d321b6378e7741f6459152bf6d24c524685755616987bf634ef612cced6342f48e3ba2f06c1adf6767c82b6862d9725a2183f688619a2633ecfdca48ffdf5296c088be71df0161f2bbf905bc2a13964b294af7d399c9364165debcd6e0a9f625cf75749c25b8d70bd8535bf17762225ba10c4fd975d09d0a680eb216c2f5b3b468e3bb5e3e575d622b3cd1e3a88513194f1b9d568a0a251a385f01d494fdfda26db3459f42f287ac21d239bac575a75883068ab1ced6e914aefaf8dc06529f87ffd7236b95461017f93bb1f94fff18a78cbbeab6c4bbf0a08a655d3fc9a127098f9ae0685d5a74f9999d5979813e84383356c4a5bbae0a759849173a61dc01ed6260bf5523cf6123ebb3ea709e2ad823232af8fe0d7e05394044d43638d9e549c2c4ffefeb585541ee46ea82c62840fbf1011a82bc008e24886f80e7182a3986c1e88af6d4a485b0646853bc00f08310fb41c5cef36e82fb4025f21d55e6e6394fd3ba12c9659b845dbf4d6fcd4df82b7d17f710aa8cfcb7b021b5224f867fe1796437cde31412cb267055a05c52f827b4db99c99a99cce2fda4542c3cde3cbb7b765acfef855e13525754eaa2efe14aab9360d85e2ef141d1313a343306e26d8844754a6d0f891b3abc2e3d93068c58c4489db37256495602cd5f1b29eceaf93b7987c613564093d7fe97dd862e311f3bc24cd3b8cb705fceda789c295b3b13782f4317ec29edd1b327e530a2762a351f0af67de207ad8b63b10438121c37f58d4d731f77e53f9de3f2c25cc93866b2648d545afbfd6c777ae1681b69478045454bdfd0b23feadedd9251df3cd791a834b713bd47f9674b87605996a40dc08cb16bff89b84269acdfdfe9c0de5cc7dae435d6d3aa9f3e5e88eca764ba65e6e2ea875fcde124883356588f5b4b96121d5fe86f79589a9fb658ac8befd42e9221399a765300a55e299c51335275a150ef53bee0a83afc977497c08e1d3b1f00d6b31ff860573eefd59eafe89b21e1027c2794ac55d77607cab97cefffc2b723d1ed68135cdfe6da443547dd16c74354c4dd22f9b960f755536e766f535c406eb9a3dbb3462cd69fd573a7bbdf38a8b6fbc92af4915f2fd4b82c8cb46a5e8b91978062de0c82279aba33d2b77e8fcbbec0550da2823c33ec6bbda8ad5d850899d408c72571d9425ada676b5bdf800a13f32d4209d5daca0c2e76a8bc813dd6ab17a6411617268ec40e3792fb4b05b83f83b387262db04e05b22cc2b59f152c48f7fa83e15730e9a2fa6236ce07a5d96955a267924258e629cea01bf9f9405b7734c3e6c47ea6193559db05efafe88a860a421e83ca6671061de8199d6c2b696c815faccef653286b1d1758491d2233341e82c8bf1559fe3ca6c091b4223b4d74dfdd78ab3a2edb73104890820fa8f7b17a469026c8c9b4507ac99fa1c51a8b7f2a23f133d41dc1bb223eb0fb427e6c0a7922bc306fce606a5110f4827187d642f9cedce9d7208054e5395cab848d200f2d5991636351012d1d26439be9c6024dadf1bd08b3beab5d2db5d787d3d59aa4392cc2ef46a559cb61fce69d55369df1536848a7215dfeccf23643b181d160eee633b2360e993e81f609c9d786045ac84f7db9a3d72868ed494f7071c93ffa965f765d82e36da7845a8a1fbbb5906f86085867e61dbf0afa2391375c3971de39bcad1443378c3238c74515b4d73ed22aa0bd20b8725340955f3ec9877c08095251078244c074b972ee7a24fb556a57a57a18f55362dd60dc4558ac54d7fbe2a0457a6f3b51c63c33ecddaff734d98728ee07967934253791e97659198bff656bbe42fc9d373c826e376e37f3fb07ec0afca9747e0f941be5a906085fa76bdf7ceab8604e841eb7d476ef26418f063d478e1df46604c5da7d969e90b01a5ee6d1f29303c16cebbcc0e93142ae281db5a29fab024fa5c5ffa4ee7cda48a0f74ad6749c879f0af5c0cfae042498ed9ad2ecd76849fe46b464e263836409225a78052bf92aba5a43d63938c96e4c39839c1ee72b41ffb744ef9ddaf7052b934ccdf390002ab60e1d9ef414604d09ec6cfc8dac29b3b5281640f28e3988c248981db03db9a8027c3f1ad3f3be905ed7be4bb2acc0c91ff126a3f7cbd3dc5bee45cf7e1f6d1f7915069a50ac24287d5a9cb5688685f07630b0ded16250ed7822588463ed03c2f37bc2ded0a81e800e0595a4a85f1203290d7fdda00bfc68e0a8fd38e00d9f938f6e2421a5f4d608b2726c8affc107aea911114564f55121a1d2f11e386927b7beabfca53b143e2abbef3d269caf050d154e231d27a680ea1f9597b9a954825139fbdb47635251c7e9a47d13072c5fb7f01fc1b4005fd99c92bd18de88cbae0d1e4fa95c7fa91b713e75b30ade3c65e6833cfd5f37a32ab899fb518554180728d4a56ef137783367194faf2c337d53d3259942572469018aa59751c279464fd8ee3cfee42dc591c8183fe6f818aad2a55b3c6c1b1c9375633083457c34ab6b87c7dd2d4a25d2f36210bfffd98cb368be406a91865cfed8d96720c4b0030e99656448b8a25708c11a5fb39de7a42e8e5194cd35d487d61083461ce2db8c4066319f98a9f861e2f8537e155b679b1423b2a08c489c9eea18b0c3a440ca67f920e93cac3e68a74823d64c835d664c269f17eb9a6e7b49d10bfee460d811a857d48844addc031ad2511c216975f1c46078c1d583685a05f8605e366203a8ba3519eca3203a80a36fa383571e60c337f795e9dbf0d028de053aa8cee0196372c067b8ad2a2fb5de3435df5ce48e6bdf688bb038f7ed39fc4e517017ac791e6d70a682687c21e8a2bd997c5476f273148e98a99cffe7b18807181745bbace5cc0134d7d9ad763cb8701531cb3f2d60318b6b8aa36b41550ccba6179a4d53f01ddd3020832e47de28e4d78bcf57c5469a9bf5bbce8792f2c52ab921e5d555d7147cfe11609d49874f35fc0167a0408bf53b4761cbb2a2b234ef67cf9a1b01283b9f87998fd720a5b1ce48cacaa654ce4387b444e3696780807ea4baca7333d4ac10fc8ff9f5fb54789df722afd94c522b0d4a90a28b1cfe34cf11a55a8c954ac9c0e25327953befbd6cfb327c3dd22d2b6853e1d2ea42157eff36e30b4779c051fd801b028dc0474071dfd6693e58add15fc3dc03c2a8e795b0157a6c2ee6b7f789076ec64fa4af980b9f592cc44c302c5bbca1269975747fed7b694399e170905b71b200e3c8087372c198081a67d2766aa0e3ff2136dfa13e2bc07c2111f4cc77bba17c1b44793a86f9525fe9952d2dd7fec7193d886f26c7a3a5a57d2e7bf9fb5d9ac70ec39cdd37dc353cb95874bd405cc29fd096dbf97273850097c9c2d86008114c53101831c0d38656345348cc6c5e470ca275c3182d297ef6b7991aad1930ae3ff3187be305d50b3b98cd137124c89b1c17c72a450ce21b9200b2248dca486753f9bd83b893a6a7cf390d3f8a7593196354a033ac3b2c80e8ecba68a3245d8ea80e5958027591f84502119d81f587da0d350d1954df905cffcdf8ec30906042847fbd23232a0dd62ce37cd00b34983f1e40b678ac634ce2901fd7c0e1d3d1f6cf6f7a3db0bae2e1e725c0595c5914736e60433aee4bd54c526138e15d046e32d85802d050a3cefa11d586491d1ca28367d13882844dc80ffe8b192a152ff6d534cb597ccdc3a87af5954e99ed8feeebb8a2018e841d5258e91829118d12d0dc83da33d125ffe44978e36d5cd0c3b34352e7cfe7108cb116cc80e9918643102c5383bcb4cc5a991fb34486d6117e8f96268a7fb46a1f0e0156365a0c82debd14968ab0feb53bf5227351af73fccf0feb0c1c2e7931c6b1deeb54bd49eb9a5ef04e880663fef38354d19b7c8700b21231f065ed3b003a9ffca62e3a5ae5c6fd21cd2ae0dfb4a212371683f135043089982d47d8caa4e6c663bf55f71d1a0ac4dd26ecdbaedd7ec5f85e752b98c61c6e153ff0d47dfd34f9fac323907edbae1bf802212cd6c18a320b6ea286bf1cbf9e80d279459e10c313e977926e26f1a532b65a14f1acf936dd0daba2fcdfa6f5f60e731a5ba2e6af9522cb05a0383f47f16f53eaf0691595ca71a437192076f34f1feb13edd9c478e5b814fdd8da2873a7b3234fcf203535b612c4b2a0d05d3e8b385b7f9769a9aa4d105a13259d1cd1f2a48e68e5c4704fbabff8673a3a70fe1807d4846bc4ff1c872203e6e93479ed6dd814eea41dcd295e6ffca8120e36dd3eb56aff6605c6aea57494bfbe1597376693c25ac70c4bdb22524fa46db1cb8c655e4ec1f6869717ae5aea81f0f15705b52c670e8a05478dc69862f086741c0275b627228a9972affec8c20ee32ddce51fcd7846f4241a790712a89cb2223678adf8faef8f9200b06dc3cca80b35fddcd249e38b37b2cedfd469d7fe8b658cf1b0157c2649000b4b7956ab711ccde754e46a65ec8a2ab85c8e68d8d83436b5724869cd930d1f2f2c382d3a17fb111cddc74095ce0f1562bcc4603c905eb523bfe1a4be691ce6b3b08da521672c5c420cc2aa1717f3107b724811b6ad6d7edfddfc0839248b2930626bc1ea763d4500e5cf17df8e13a9ebdddc36176b2b45395c962629b19d56b0b43c9bea5a214733611bfaa8bfc85da0a749ef12061b6dac5e509b27a16a9f9669a5c6cb8ec03c9d047164c13614456568d28a1214f13e72808a49cdc711c7c60fc343ac61ff562d18d1024fd4adb8a5688800b46c3074d5ba4157ddd8556a84085299f7a6e59ca146591440a37de7ec76518f9795d5e522b53c67c7c08c389846236d8f0938d30d135bff4e7328a764e9c5da7839f4ab40c2e99cc4fb7394bc00fa532e56a6b8ffec07ff3eda84d99d599a16acd1da601a84e691886d8e67a3c1be627d4faf71c339534ef00abf9fd3b1e340cb333a71e904420495c091a00873f879c156ce5d74831ab2ca436c8af63009a9a2bfab42f8bda3e7442027af99886ec3ebad17d33f472507eb2fb6912d0117194cb9dc0abb63db7d83478c42dea139339536c5318a1d0e6b6ab0e12fd559e781f62923f083118ad61f35bffacaf11293d7c3585335618b03cb5951aba617b4b4d75af60fce822c2464c4b672d6843a802cd6565bec416e77568357372c2fe7ed1b081252eeb4439957a8d101f9c247b4e397f02289e806f11bc16cfd64d9f449b478722914608b9f9ca444d9b1c7699edb58c4420ff4a8bb130a28abb7c02be89f26fbc0a54346c86477a5aee186ffacde5a7da56f2cf961ad8e450bbd67029b0801fc55b0f948cc2f3da658cf76d1af8ebfae4f5af33d79e45f7b6228c68316740233b7603feb90466ab10dfa2455c4e398360821b5b3db95d4b9c6356830b4811149ccd6ba04ce1ed2832727ea908edafe32f4ef95bc794c24256da7acaaa683ae0cf9e30571ba8d5a459a7e1d0c17e77aa5a80268025e498540aab53ca16ca3675c0a5f3242c25ef2580794c636c7ceaf1e0e10f3c8ee38b9b93e5f3622296a071f1f22db4acd72f6bca9ee68b6d06241fd131b4d558a52a58e114e848c096f7164ea31dc4f9f220787b0fc94d7637be6b9ee5c6d1e8dbfd42dd43b59048b6396b70de9f67ee9500d16f7ca1376973c82a19d56d3957c093a22a4cb3dfec746170e9dddb254fa8a3850bb766bc55f60597e143371ce55a836c37c1dd3b599c6db71411cb8dcbf956ab8ade8899c07869df931b16e23bf18de783658b3dae7735eff5924f5bf2ae25b6bc028f85556dcf26b5d0845d2db90a32479f12589bcb86aea8e2d6b741739287fe6403cc524b287cb11febb61be30b2f1ba90f8917065303ab2d0b5ec40206518381f76342595349f06c6f599595a33dcbbd48983cd6725bc51d338c1b4446cf28c1cc202d22c5f2d01ad996c6959e67e4be82c3f2d89aa76f8c1eda77ac72360f286735f8e13b4e739496429fdca63d1e7734855bf1c13ea45faf8ed440452bcee31f68e9dfd97051f45303d5b999b72b951db62dc41e2ed961142ff520bcbdec49bb1d472a74b223eb3debd247b243d9d92467800d6f91a13800f0f6db170872253f6db84e46b346bcd49ca1f24af9b9c494b461415c920e600a65c4ff3119076d52fbc31277afbaff7e5eb3037e8c6c93577c98e0845332c26a13c939b29edf1dd948bdf64e192da0c7c5ce28befe85bbba81a330f32b409a30cb7e19c47c7e9f430d105ec98b555450fd5f6b4c06389087b5dc14d21a455125677f0e802d4a16ddc8ecc3c8e6114d8aa1d784bd2ee41f516b8a30704fb905588dc3c5b27a424896a5ea2978505aa768057e412e5f9c857d9f90be7b374eada75adc84d435df6f84d1573a6b33faa60318b0a251fa78ed5693502ab05132aca15089c3655d1fbd9423deba424232d262ea2215977f988dc4587a870602ee128a0a2c60332f8cf6e3ddf9b367a027527c255ec99c8d370babedc52e81b5363bb5c039721c5b16db6aa49ba55a39eba67e13500670508e156714f539b45978f9fcb9ccf1b799761bd2820693ccf503a9f2f1369ad18dbb7e013357362a812f3a27598e4b3aa3eb7d55c46bea0d2f7205ba0050f2a13bf53bc2c220d8f792df403dde6902086f8fcae7063615732f0a8fd51047d6712915f1331ce17c3f21e83305324cdfb328b3bc5fab5bbb1d9e88a19ee55dd43668df3432bb5dca374f9e04c69ef2f95bf43d856e701c9cf407e86c7ef4defd3f55bce743dd25b5e5cac27637684cd8cb2164192e590517550816a6461d2a78cacb28027a96acec5e68b568363b66aa010a233d4aaccff0ba6e49a52cf43b906320cb7b46058640a2e20e6200e278206bf6c6d4660bc550f3b3ff785422bb48acaca43000e419329baf7be387079e3c69e36822033f567ef07bebd4614c0db7b974d225bdec466a8a2f8b62cb686fdd873d5f8faee3da604af02608276cc676078243862c2468b9871941bf1591acbc6c9517ea63b0582eded0a5135b6321edb2a267d1f6ed7e191df5fa045d5ec292247225da40043e5ae2761b20614d84e15761e7846a4c9f006aeaf3c727a14ac1c1afed01cf5fbcf3e4cdf76d5262a7b9bf8a126c4ef3bbf6237db14d6fa00edafa0b699ac5bba88beac87100744b0e15e3855241e5ec89cf075dbc29fbc18aff0017fe8813a8832cae99979412884a8a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
