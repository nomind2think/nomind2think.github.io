<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43e72a3906da960baa466a947fd26e5307650dd21634eebe71357c81889a39d284019f489b6bb9845cd38e848bc3b4fd0e1e41fdc33aead0c4632c6e62fa12a88f82537a5b5bf6d8ecbef1da349c196af428ca833c34eec433813ba528fea2798b1ee29b91130a06f6e474fca97cdce98b60c1f3a2165ac84301ad26f8c10ff26c61c60cd1e8166d8ed5480aa14f4ab9fdf4c84c64b75914b91903550b70d5f88dac564643481fe6755bd72755060f7d0eb0fcd9f2b7910a2fed8a7f19f6b3862f1d81d7e9c5228ffdd09dd3b8df7c63e3ed959fe5af32aee4c9347c9c07c6f79e6259602b3efe369c905d7e13478a75c1e6794ee3172924c85b03a498ce84f0e92850bf2370a9d64907d50b359b879ed1394679a763ad6b83fe2815ad02d1109c41db551f37e3409c3ecb2bfdb094e5ce1272c3a42ba0fad82424014f78bebfbd7ebed10443f0c71b18eff7338efc19304e66a7282838c54299556018fa78028ed338785fda3742138e7fd0be1bf8f38d03a68358cce8ab74e69ba34c31efedee7a095f2c0a0c63e912ec4888e1cac8dffa24bd0cf0429358d839a2064ff3c0a515f57ff329bd304821754a0d29a5b711f3e041fe851663a7837f1f8b51501a8bb7f94a0e05c8e771db1b337deb46091e8ccdb3006cd2de0552dbaeb9fc9d9b419f541b34d075727b7434dd7ae371579a02de2e7c6524768ed53bf8fbeb13defee8b38596861fe70e9afe97d1dd5f2ac2fd05bd6443f04a6ca16a044308c1dc12eed4f5784a805c4159293ed1c25ffbaf4d86837a61335e6d700bc0878f0c081bd9e00f6364231d7880bc0d43e1947039463aae3c4190a55f1cbb1f5401fdab28fc5db5a0b99c8a978a48dddc5540addda842dd2b013567697d6530bfbe0cfe1f6048ead32330be5e88826ca95877302b9f44c4f8404cd3239cc7526663e05d29cb332c3913527da44497e0493b7dd028110a4914f6b75ee3629c1403f2b80617454be54e591dc711d12605dc2312543864301a9d30e86aefcbd02d469ee49c55c88b7160ac3e1b29a29f4f5a8d63e3862bd2b80df0e8c521df9f8f942ac1534fdf0bcbd34d5dd922cc2bb0dcd3ff2ec39a8b7f07b930d47b99217f9a38c2fcd3982cd56b2f9f36b3c2036aade342261729f0ccdc74acc0476814106fca4f888d02dcc7ddd1bba3a8ee7f51f4c18f6eff6c4f16c700dca92b5acd19ddec65b4cd13735b56665449f3566fac0d1625d58606fe374055b676d40010cb699592fba007d64cc6599f4b049ca8101ab8c32ff9b1fd8627ae00eb10abc1857267d2a389e4cf5a79c88a760a662212fd8ca9b36903e45cd475a3f62e306f1155356b80d8598935a31683c38366439d88856267e57476c925cae9e611f36e8cb72202859bdae9e7fde2f2eb4309b76ae5bbb07bcc407534db42ab1ded1f02f0975adb1e57b5ecd09a14ca0ae9e147a387a06245bfadf5d35889da74b24ae8480ea7c4de547c45883268b9f65e42ef9cf8b24f96a1eb69f4bf6bd1f6a51df1109a9adc58387b4d88d23917d7cc5cc8ef308bb65b12e43c6dc4b3caa3d204318e58be78130023239874b2cf0e174be987babd8e8d7a74d934594d320b090420440c92ff2e377121b53838829303b0324988d6e3257b7a5d95ebfd1248a9bbaff794218c6d0f0de4ec10a881fbcda957341353320ba0ba8cf73ca79152c6572f3a4d70a0460219de96cf9df1c800aa905322048102258bdd3e45ee468386747422105f70c52be7757c1e897a213cc68ae0d7e352114d05f5bfcd4d5b6af3765d9523899e7bc355be3238fc6ce95f0c429ea274de792260082cb045b5e229cec40d0df4201b7f335b13314deb4ee13ea2501f9be9790674056fc81fdb464e442feff1263034d177bcbce751491d5b21739830c9b6f377fd9911ceb084ad251d74aa4291a61309d200a087970ce75ba14946446c34f86c4ee36f37b0d0060d821b0be089cc0dda1472e41515166b38d22548304ee1525f54465eb23b44b389f2028461ce3afef8ef9a424eae5ae2a39fc7d33ae965bcc973b97d89595dff647c9eee7cdc761e235f97097b745f0685473e3e8ea00f4b9991400250254bdfff1a799c1db7bbc349fceef7fe3c1c719af3a3a3335969228226eb61aa85fad89e13ef11ee8da969e16fb3c64cbc7833da28457cb08085eaaf98c5195c6413023c0b9a10dba5ef2ea6b8f9827b6f30ad584eccf58122046bda36659214fe5de2b239db6595a982261bfd36cf3acce6987df17106c7704e69ff9da6e33029d3045dc4ef9a8b3c3edcff264277633f87920f3bcc3c1b4afa260a16a5e4c396482d4c61518fae3c0cf3777326e0e4d609ecc2051b1bee0f1908b6216d08b79732041bc0b48c7f82c1274a8071d1869f443bf02668f0600cf0f2f9491d41bf5b82a465539bbf59ce039db4c4b0da98cb67dabc0ed8eb53ca8163a682c17dc7c39702146d202735baea1a891e0993d3ee605985e5ddc6676b884156d528b17919919095010e26463ee203896963c93a73d31cc8c67cd049d81daee75fea5fc11168788d80172aacb3ccc78b715d562c6983b4d03701e8b4582ff3d403776e2e9199025c0040ae4165233dcec8c248acd481d6e6529ccf9cf4d365683e1b983b2a1392b811b3a21eb64218a7615cd1fd9ee2f5883022b19af966067af2e84e07834ffe46c97fbac5d38997769abf2c8d238b367b9d2f38c6253587c281f39dba4572d4469300baf9bad609ccc066396fdee8443618be5b59cad683391e65eb91de6ba7f0445ae18e491f0383414c2ea60ebfcb0329fefabdd398e15197dde47590d5a62bbabac4e71c0ca09627256d92212abde5d3a9026d212277981c40dc8f09070a72fc739104abd6ef26e978f0256567b8eecba0af01a7381865c6683a3668f10c6726c9b6494cba08d09749985a9800eec1f5573b3973503effd4056f8b97db21580f2adfba75b569b4017c103dddb32a85e28f2d56f4656a8e6f19ee42f09b50d8a58084539a9c749a2901a64aea937b3e7da412862a7927c0ed2dc73c846eacaefd6637dc8f0d9f75c5f3c864c87f7615754cfcee4fa0101cb96b4bfdd6c129a551bb81be5efb8288a54ada2c2e36da12f2bf54f380115a0d115f70268bf99f0adc187f0fd3cf29bde6f33a273edfbf1a5a9f8f87103f8567847d87e8c74159c384f432ceb41e819ccb24f0be9ad2827483fd090c9be98ec78a97391321c6afedac5d89d6b334b2369a4bc80ae5e6063400fbd63a40006f22f797a7208546e6d34f48283555dadb000941bf4a6576f4f5446ee7965ad0b2d3c7522ea9a4b43d4e94f7283cf6ce219671031e463710f93149a3695197101ba974889b8679bf718aca9364d9d009dfb0276717479fcb8bee21dd0bf450d3e2a38e4f8d1796f8d0cbaebe4b4d57d45985473585a44df131f18a1613fce04f8ee1e6e71ef25c6c83b88d2849f1c658bf649d4932c359b15221beea4a91adf52150452cefcee65bf2b9ecfd76c6c303334b0576b21e719d5a948e5382c5fcce8317a0c09b96480f12be99f436c25be42c68728bc2650ac37efae41a7e02cdda3846b5ad61bf1eb8f739ec521e44352c46a586b62fb37dda6ab8392521e91b1033ec7bd05daa159552c211236844067bc397077bdfc825f88aebf46d0df68be8d950b8a8ac96afaadaf85544c15b50098953b9053f10c72febd56442350aceccbe1bdfac09c706c916a7c96dc6e3994f90b61bd256c8f8168e38e65aea37ddfb88985bc3f18d9ba27468ecf8e8eabb8245c51618bccdbf1c6e0d4d82c1b90f0ed3cf0b42c856d124c610b269bad98bb0f62e5ea0a0440b16f7068ad301908b9f4b5bc0e96364d5415e9277221ea82e7a7ec7660381f77d0a50a784cc9a0470d10f565a4396439002388c2231e00fa4022c403b399c297f61ab4724aed4e5e85a934503fbaaab62f0530f777492498a7cf733bbb8559dd6ff8c91e79880b76e497a98e899419f60650547b2ca345eb43ef8b742c620dd12d0ca5b69c90fc0c052811ecbf29fb90888c65874baeb20889f0f7558a89756d6df81fa1d185edd4890d5835526c478b8e800358e900f048314cc415c61d246e17c13d430675b6775a29524b110ef7b9df015509621926478a203fc9134575601f32f43b1f8bf9da72e55bf9d52d99d4702e94f96201539de021bca24d5a4a7e8be13c61d9f3210b9a0233d02cdf1c0dafcd1966551fa8bdfd90673c60a05385511031761f70a870dfe7a7e7de030128b30df687927fa7247477c40284047272c9e47a018627adfb7376322dd4081cc3fadb65656083540cfe1fb877e3ff228e8312dba286ac49c462309eb7a8140c3efba8076883c3e83e834825e7476046c198a00308ddcb266e92e777bbb7311730719f47eade2e108014bc4b90c6368f514cc6d2402a531630198a45acaec071628e4b10847cd34619b53e0dc0d8b70c6841b64602069f674fa3ed9385b00e38ca9919ae7fe6793845132ec0c6b6986fb9a88915b197093f22bacd55db808a68ff859092c96342e8fa3ed1583136552b5d625cc61a8399c57ff2747e5a93d29c0370064582531168404822231d7d0da50f305b8a43bd6f87f46e15d94836844f55d98b5517596b9553e72e497e025318e6271cf7b4ca3a5620f13ad0bb58d413d720fb6a636910cb537c84e097bd865a02e9cf335e2639c43d98c16d2fb46941364cfa8c13730df831b19968848d9ca307c8b38a28061b49f0924fa141af3b2107201f5b72dd1db6234730ba3c2d6ab151ef3d7402a3a2590be2353f8891babe6a1acc25545d9dc818992c109729c3d5a1e9b2441c755e7601fa1d73f5529283c7a1fc0f78f754c857d68c78e44647ad1d4bc61574049cee68e0fd9e9efee450af928fcd51b8a0ab06d4681ff93d1075155a128ed35048bff065072fdc080904591c08fa70a184975558abb3ff9153006baa8b56e6b5e194889c3772e445c531376558d0c86b50e03fdbaf2437e94c994be74b2a8c808c29a192afea5da5dec7794ff1a5398402bbfa5e0885174350ab7bdd191c57daab8573c65fe1bdecb60966f6b9ced1fe8b7a053892c4f3ea699a1b4e79b2f445d72c61dd30d1165a651e612fac74ae191296c4a375b9f7678c04677525313c5598ee17eb59ab64510df90e9035e49723f26c4bbc3ac7d7b64532fc72e0d4270a666905f4ec3a138448a2d23df90a4abe8d60eb6a08ad7446598215ad3fde8a3d87217ff6b887b59b471094e45f542acc7dc4f05aa77739657c272ab3fbe937cb265df1692bd71638f02d951fca8e75b4adf02c1e964a2657fb2027a4932c4e3a06280206614a682650c7499a90d8b629da983a702eed77daa1042288d5797aa0535141add5c585cd50c7047a828bee8d2ebd5b7f8dae6ee1c1822c01bb5915dd20d77d6df7c9bfdecb3e3034cee6a313967ab4885949638261d1f59747659e0af3c49aeb302f0154030732d738cbeb68dfac3bdaff930c8811025587ad5600d531ce58459972e8473c009478119ca9fd2d87acaccd386c0570ca52f68ceda4c26dd28482e0aeac6e7591368b1e627d8ab6159fd8a1abe0f9a459b1bed7ed990004ef27e666003b9f90cdcaadf489e087fbb1d1a9855fd8b2371c46274a201c03cadb6f81a51d91f2f857457413cb05da22fd1f9e596b4d30fb6711ce6acc35a21a931cdd7f9f87645d3a784385f63c826f624fdd6e70ca6a2ae2028850ec1311832022cbafc195389394eee7d556c477ac0c6e5706dddfb62bcf16636b932898831db0852f117b0c014cac7b38a64f2be8320153b093badfd90f54118ab25c794da6f4fbe6417ef73059385dd755969020248fa78f308c93097e8a172c725bbf6d18e0e3793e788d97f3ae2bda40b909228013fe8c536310f3c308f5a017a3661b17e78b378bca0b556ac6d6af32ac28c55a19d817761a0b070d9bf87fc951ca12520fbe355b85c9bb2ece02a6765b9755b1645e3a06a17376a56dac5f98a1acf53d1cf965f914269d46c805d2649510320a66cce77d4ab7e10d8e37482d9c197894e55367f6651a9afcf55a24e9e65e30b3f52006da974d06e588bc1c376e245b313d2ca255afc7283cfd8a963427472d9ac1fec152c003f73f1d11eaed533780e5e7966e2fb203e964e9b3e790cc45c27755db951029a59dc5bce092498228695215c4f44b8e84ead023183998c393fde729ddc1209bd81e1e2f499266ee3fc9d5e929e7edad661eae04e674c035af77f45f05434dd0c4211ba77228d9d72f330389b18628d67da673b1695a79c38e821c6dc5ae5694fc0c023d7954e6ccc80230e0fb2020c775d9bfde918cdf274d5dbda052c2faed3dc34c34e149a201d5bf3e606000e9dcecd73f6c03eaa9b948cd8e21ec8aa03df80783d8389034d9a343688e4e519e6862b09e17440fe2ad3510147bf42c4ec2fb939e317e9c83370ac8470341065473d9ddaa18e6dabeae810457e885d6a1380824936fe2787a98dcffa09114f512a06112d930b76e7d9c2679cc399076aaa81e37c63f256351713c5595b5905fc23bcb122e1503a5f58c9e50439ee7a402179d69ea646e32fcc273f07881e3d6374e787d69b8b72df2fcb6477d2aa61ce941eafa1b49a845dcc812472e955c29a852087389c266f4b1dcfc84f5ac8ee8e157099302364b56d2837adcdd74382d52c79ee8c187cbb625415343a7530497123afca2c1d39a38840f3561db957d35827e8c811851f1765ec654d071d6cea59ac1b16024fb06d69a04492ff7950399a818041607f31f8253ad964831d6d22180e88b1bddc82698a5c8be5c148c3d9ff7f8d13b277035d25c9c3ec87fb2514c4198d2a087321865f6aacd59b1bcc2d34925bc5eb6d1c1c20c5c3fd72aea8dc27e7648a0c2225ae5bcd6abd8e737acb68b3345dac0cb3c7cdd7bcfefcef785ed4b6edf3078f64609a4f1e9119cd7abc898f0d45a3037a985649bce66231bb8e42d6502a02d1a8a9e89102b83462bad870e94fb38ce21830fc5d5fbcb37961160784293a571c2f05f880add03ced87765009afba6794b9332e1a23223273bab0d770b1dc82883101e44d629b21a3dda364778122136a10f8e1a17a6b03cecad55c4122905a66f9974dfa4283c8f2b9731c7b91b30301e4056259884ab3ac2587a81a6f9789f6e1e3552eb4dd0ca2d90f87aebd47ac0c24a718254b6faa671f1c98733b34f6dc216cc4528c0778baed4e0413d9bda7fa91cd6c4fd87462275235cde9e54527681fa46edf5387534696946d415efae1fb6852c5a91ef1e814b9fe13653df311cf6c5d2b4c34d0ea9c94e7d810f32d05f4d2a2be8d657c6144b5ee8b331f9433564857d9ec4a2fbc9d97f8fc9181c8b8ccb05b9fc71e1c75398a79fcd1405289ca7ce3d2b57c7a869498682681862c31ca5e3f54d0db0b3f082f9d32d83b2c1762cab5513247e0026370af81786f56555dbb2ebb9227463922d0c4dd60224c9b3e856fd51d85626ec2bb4ac47c7e844e0edc59245cd35dd1b90065384c4bb7d0a59c25b30de02061e959eabdea050710d44a46ef7321235b35abc9123650cdbb378142635fb7694911f2ccc9223242a3cd2e55812c664b7ed31c15c22a99bc5dbd6f8446b896dbbad336df097b3714a7ce9e330901a3221fae0929704226b22976b48e4e3bb5e2eb6eb180ca5db349b8aa7edb20e9be363d9e11a14a07b247de2f551e000624c6a29952a49a3f079ac9b60cbf8902c485883f5f102c02e533d59de228c50f74a62ff8895d8c2e25710a9eafb063971c8f368c1c62e22f4cfd2c4266003f5042ab5633fd2589fbb28405a50f09814d2c4e0a02a69da1ebe15c5199a3d94f006e646362918bd0e2cf89c177b8d50571a9eac19682244c7ad173e1ea1b60bbdbbebd6d16b149a57011f18cbac95905efbfbd84d0d1cdaa4fdd543e8127626ff55b49f12e2d66fee52aff85dd23ba7e005ab8492edc27bc56a578fb49883d9b3fe166b0e268e4b163b5c9159a45967a7a20e314b35a52e918d59452d4db5246be7eb7377b520d6bb147b27636fcf63cbaa75b9c44d9c268ef17e880fcf06378fa73935d8fc4bc7cec2c0665a56b8e1b5587b211104caae3803bbcd4d49d87d0ff655386939136c1a18017189b3e9d4d77137f42fda6a84476ec63af99e1b41a87bb61f73ad61b1be1820e8a07eee97b6cd72447eddddfe37629ab70bc62c4f9d16552dfd474fb3958cbfc93cb1f537c3b7cdd63fbdd842bf657e84589ff449eeb74505d703a00f631a0c370d10f948789e0ac885f4a9cfc2249f1af9501dee1c271c0076e334cd8e6697877eadcced825e855775807fdf3502f3ab86640a89c83f57c0f377e4fd6d8abc286f995bb94fa10faa6ad1b519459979b737d52def2250889b67b7a3e8bae06770100e7182a5fe34cd8301d2e881eb37c2f35e043c329bda56e2bc934ae3f025dbd94fc947637310124e13fae1691ce091e2164ffffd03d003f017ea99cd8ef2d4f355afb18a4318ae4b77c098278752359ebf478fc3a58c38a51f900ad192cea33a2dd9a33a7a62f5804803d90bb65a5ea872790a7af3487ebe816c84c43df304261bd1e2ff285fd39176461caa31a38e2a5580eb3d32a2e01e7ed23107dcd2d343daf46bb50b560169bc9587d01a41cc2387667b528a205e15ebba49fea979cd2070db1dabc136c40d18df51cf369d3eaf6bf2c66d123fa851b81a7d3deb72b7ba924d7eba0fe9f5a2f1f2d53229c73426dd57c923ead8a25b4435cada3b558ef349b8eeac547b5d8c9004bc0133799ecffccf55b2548a272e26bf08c30fe55d60db81c7ce657194b8d65f644b50cfb59d7a9da22c69c309ca76e253de9ab1abd49fb2d9b255b0b8f275639bfacc3d7d49b0b0d40ecb03f214f4b7975689788b221c2ba2e51b83d107abb927833630798f7b27e36e33bb68d2015bdbc5d33c3588e2a52a45a58a5d600002591241f622ee69b2ea7a1337be112d832b21a2765b8e7aa6e87d9742fea70bf8bc98bee5c714e1fa325aed642e618f1578a7a6e8b87c090964164f6f9df59f151b7f1ed7d9f14bc0bc07e94570ecd37936a38d77ced416fa9164e84f0a6da5df9b1e41d4496ed542c07ade15b638b4d958260238423e245cdeedbece5275631564bd64bfde30c96986081c1e412141ceb3dacbefc3919701d5a79961691f384bf02992dfa9c6b82979d41a90f01da3625516495472dacd3602dd61d7f694518a48ffe5d9b9928d33fe27ffa119303fba3066ec10e15f7d239f36e5b4869616f7863b6959ad1176d33b8d06978b96cbeaf27bb368ec904b37adac48bbc1d7975f0815e2a176e1df981c0449a08fac5083cb698d7d4bf302d35db01b1c80e1988874d008e5cbb0541b7b70fd7a84170788dbf56320acdce5b267c25f87512435cb42368fccffc387fb804c0fdb199bad2101368d3cc84eeae3253d15c6a6819e540c83b9ca517f8896b8377775dede5dded26f134dbba20ec7ce887d9f0c560912f5dfbfd728a244da150944739c314e3aef9f4cd34ad2a1a7b6a59d59dfbdc85e5ec6a654ca5bd26dbfe7cc1c3402ede9c6fb0397fc576dba061e302d8a975e6e5c6f3646d1a5bc5c0c02004f7fc53a835ee7d5f1cf50185e17ab41df8479cc388940880854b47b16a7c585534520102a00d133deb3e2451817d6035976d2ca41992366bc5ea8bc84cd704b82a92619bf83935d486a6d24e75dd9039a3514f8eff183ceab9b45a7d264766ed15f424e270dc4ef522ce5aca89625e1e5f834854c597276ad162c2bcf13259f4877b6bc3b554064c75d3c666607d0ab9935fa2501196809aa1cad7e4ed98e50d812cbf813e05f3ebe900d40bfc026d519ccd832168215b75418eb7b60d31618227e9010c248f40026816b46c2d79a253da96d30a4af81411aba3061aab85c83f2f3b428419d5f404a34f16b7ebe4a01329fc0f613213eca25e2983d0f75bf5a0f655038388e8f839bf49d7cc85dddc80c2a49c148ff93bae4d6fe50397dbf9703b717631b899761fc8329c4fa972ad7f8bbcf4a8e0a34e4a255e09647e6f159447bb0f732ef51bbd5b2249f2e5bdc458b168b17f19d3a603b96d90c8e8c4915fff9c3cfba9efeb77b4a1726e80713d1c1f48c08f45bc6db7025fd9b14bc247789004d817d7862ea9e291ba9d11bed9b9e3628f72b60f49c085bfb9d0c4bac388c1589c2dc15f883e90bb0e381025e359b94232ce66e0a1a3f539143babde153bccf6a6f01885a70f32ebb3b299ced19ef7b26d460ad558ae91626a32cfdff8abcdf791ec528ea2ae8ef2d02731e546ce9e37a41cfba14d1682668bcaa9632278f19f198bb1de3ef12ecbc6b5d165300ba09c61c79c201764eefa1257cb84b5eb800473cc40bfba628030e205a87b5ed482280e759c6d2342acf2b354d80bcf39ad4982e9f277f77b4dae1d3cfa28d6c3b9211e03fd801dfe5724bc40972d4da2cdf6722cf33e9e0552da1966842743f20e8acc3e896be81bba01477fc22050a6caa23b2e6e870b5ab90b713bfa486ad8513680d82b193076d4b0ef99cefcb8d0d13b8bab9ee3d32134d4249a277aae28a58758f500d6dd5c2974a11eabb0ee3ce12cdaad8b3e13b60f66ee6194a8107078afd3c56fd2aa2dcbb68ceb4766cc58f4ff71189969f3fba943e159f97060d4ab498e4ebb41f9a1dee77654ebf26759b680a019df0e4e6db292f959ac9315f7da615aaca0fe8126f0c8428f76da1bcdaf4e94e415bbe1cd66abdd0105cc27959a7170ce145f2e27d9bb6025039a3a66c96902ce4784eff4930142fc488ec6504f15b019bc2918a12d25ef8f71bf5518ed626946d0cae7cfebd7ce3036fb0c685addaa287d8c9e4a3938e1507df429e251e810022d78c8e9b74831df59e54de93dcbaaad5996051bcd2562b23e0af3a3faccb5478b8d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
