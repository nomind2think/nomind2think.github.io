<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a099fe23f9f346002c0c5db87e94a103497b2d80a9484210a7072347a181e21c836dc6efc448312d65d2847a76fe0db86be93b24c755817be9aeb704ac0c0f78076f5f6fbcb4bd5315cab559eab2504f3bc8c9c8fedef507cdebedeed8752ffac55a343f5e067bb1193073e10bfc0a9d9e0c9492a0fadb7aebd562d073f93798328555b6ead375ac68b98be02bd12d46ae57224d0b01abe8f0471f0289a096c55e094a02f012cde9cc158ef27b8c32809e5ea69ca2487f371f888b6d3677536e5481c8aa5b6f34bb0cdc3e528eae25796d0bdfa0e3c41b28597d3872c9b6ac6b979e762026cdff54757c8d5a5753fb12ebb2a705c6a1aa210de0d3eb610cde5cc4a21f7a8eaaf880a38c5a2058bfefc45cddb4a3838c5c81dd40c434d265f06f01b62923212ceec373f9c356b7434061de328cd18d74431ee879f80335cfaec47eed614f75fcb2f426700205e66407f5a2f2b85d930ebba88cbda5651a91c8678e8180d82ab25078c52fa4f0f0c6d7d2d9ff8898ff5cef4421f05eb0a1b1313a07fa48cbca28d07aee52108a7968cddf5c4668780c82a66abe1505f5d2cda8b48a133a784384e6176d60d6c5edc8c250f17813ead17eafb4f231e79d6fdca6e724febd3ed012a99af827e8be5bffa7cbef8a0ee2b68eac58f6e018eb478717b663892c2e95fa7c03ef6f724f4c8151d6772c0af2ff9a3588836d3c8cac47e5798bc37ba69723d7971ee1554b4ed3e34365e9557f66aaa92f8af5f674cdd343061ae12f7efd1383d6cbebbe317d6211aef1ff580bbefd1195ea7f6b019c6bad6b3d5b62fb5e5a361ff9efc3fdf045807819c8ea1f9c15eaa83cc4852929ff1ca6eafabdc5811dccce1e62abfe11c6258dee4c51c31e114aeb00b39a209930767d0186820fc854b04fca6bcfe453af7f14e71dd2cb58307f7f39c71293674cd27b34d66de5d9f39006dcd03792ae0e1187d80a5eb7c097594a49115eedc6621bd4f410ff780e5bae097cf3d5a5c6be80980a1b0d1c9ce005815a77a67735a9790e6b6cfec41c59931d59cde29917fe0ecd98b8e21784d27f805ede6af65f147ce97f636716cbbd2c90841a3e5a28872cd012a5a61c189dfaba7a242dcb0f94c282813385d307c1c433190f60cb65a53d84abf130283594abe648a78e157cc68c8b4ed8ea38b5b2a02ec01598cb092c93f17a93913a17428fbc85601c7bbb5e29598785da479d5e34bba513c837c64dfc7f89542c46f559390c28c3fa317eaf5913c066b05bdaaee2256670485813d4114b5efc0242a7e335869f1eef6f7abfd8c9b0e123a7ab994c38d8d043e520b39f37072d7c054574752fdb2f3ba1d3f6cfd1600bb074006c59eb20e178b1363c7a5917148b65276964dd823dab26e157e935943cb0a517d8fb08db5893b8e562d86c10d55992cb0ca4b15fd4d094214f7c5bf71b13a904615a2c71381804447cd2a1cba994e2b052788b7eb03eb3b6e36edffe39d5ff80fa7359ef13ee1bcaa573f1ddc1f8b2b07781c4e39eec78c489225e6d6dd0e67573b1323e2d5aac6882e908a9ce598e0efe4d8ec4c2e09e39f3d24a93d00c6529a419cc2bd0c4d1cd4358bb082f1d35ca6854888bda9cf2d1bee0df46561a1168b1cdd52ab731266626e9d628679736306cd10a560bf04088f18364b06286afaf274a7c5c1bbe213d5eff8ae14e9192875779b269e2ef024d730c519ac8ec5858be3fa7f14ce3537cbd8f385630a09582726898fb11555b046138acef72f76573f963907f57bf648e55336fc5af59f1749846b7a393af5eed482547b98d5d705d17e267d80fc7d4cf77f9371d6b3bc878ab4cb67fb7415f31794209740ba6a00649bb3dcbf02015a633c87460aeeddd50f76d282ae85185b83e5f1d8f2246737a908cd9661f07a4d553f9ca57ce56a0b860cdec2984f5426f9faa565c977e4f817081c201a8231b70499f0e92b97610b260739de4de32c33596282fa02a957137bc736487a093774a2f9d9a11d357cce7b92f9e974cb1fa7392233b48693ef13801bd2c84f269709d94e36ee4283c191e82cbe2052644b785fe90f355558a00c6ed0992d35d458dca4f157b30afb27e96c7bdb7de277495e34d0a0c85607d56392c8ba85e4779ba635d41891662c32f7c6692368aa433469d4fa8ef6204462cc34170fce42e3c6a4e1b356ca4d195724a3df9219e5105b73f0bcd44e87a8c5cf44fce0f999d8a2b08a5d513a5a46d320503b87c31a2aeeebb05bc39fe6394fcfc82bdfb7187a7a154b60eb2c070d695197abbcb24b9de1b69e64d47d3caef589577b8630548f7de1923e4109f68796b1dcdc9361fcd238c3b77c92dc567908d509d713c9bd5691fd6aa5dfbc711747ef84cd42fbe32cd22a2b2f0009c9299e8995a672b4fd25a0ca464e0fab997098efd05d7f016c1e1f1e93cfd6e8edde2bfae602b0f7fe67de81359afc8f64cdd78a1675ba6211c1cf63a9e5bd6c6dab238b590af7a372084c11a2704f4fb717988fd1cd38e8e4fe7e144c95381795a4efddb4c547fc600abd98bd636a810d394c10bc84b3fa05e95a3d44d5373d7b0c6035a1499cf0fd50cdd8a7f9d8fc4128459d2c44ab2f4033b71bbcc6543d98d8855ec43053217084a81dea82546a500c2423767e6c82ccd2c451967defaf608e158c991c451409d2e139e9d62b5faaead5496af2930572a40f0e936d24a4003da134f8f8317ed71d92e5b72f77598481b591b9fd6277843dcd11ba517ced755d14120efb16e00718f682097c216781988b4e16cdf90422cad6ad3610d9bb1b47da0533c44284084328ac4b68ea9c9a7b9d1bb678e372f875226569c7d0e1cd5ff20263515a2c70d7a74ffafdbdcaf99f98e6151040c794ce5ab4d8c9d53aa988533db1ee5bb54d46e9f6dc30d55077a13235a47b06fefa24b76675216c61269bbb19b0da535b1ef2aec398bda60b9a930c632939967b6c361a69de40335119c5e97ca07b2d56e9b2464e8bc10e04bd282928b78fc7a215b22ca7e66e7d521b3d72afae53283c4f342d8963e348e4e07d97ccf2bdbf5181b82be7c5848dfaae7b6e93c3702ff96936d7b7cd41dd7e5ace5c03d468c281d778e72f3deba4a34a8a3c439047b5ef73181f7a9254461903c3360572e08f3b24b60b8fad36e43d39c7d12688cf0b0c1eb59ce7c8338224a6dac26daf8476a7a604e3f7120cdff54f83ccacc89e572bd53e29507241f991ee355b15cb0fa829929d0070b840b4d749d592494d1ad2dd5e1ff05bb70e1ff705e5b86993f938d8dc43eb6a6138e564682c649677f26acc3676f1e14789cdc7b0a6653797a70ee1fcf78700271e52bc8195f2d9a357f4c0f01514aa94c56e018c8949e74a6b6cee49b879385a21365647cfdb6c7d8d30ea42cfbc422977585dff028eba3f06278b4f98dbadbacd189e9c28512b29eaf764e726d0792ca87f9e9162bbe6daec65e62d89d710b55519c9fe159e3eb426e55f27b1ac40d7e264de5e96fa3a6c06e9a6f8505082f0b61dbf2d95ee65d2be44839e6cf8f1b76425f6fc1006fe2766b818d522383ff08bb9ff22981070da05f507106d46c54d0e587c7429889c99e2daf3170dc27036a8eb34edcd95b54c14a6969b295f9136d14f65322358b7f599e3903aab7c1985bd47084ff9e249b5081fb9db021c1a6596e4523e4d3b0d9a9951b265f951652b6ea4ea5be3cc8e1cf12d99a7010ccf0e67ace7464e43a07074fd2405341bbf43633531a742612823fe374bf5996a1ad87edf2099a76d63f637cfbffbf3999ed8c515d2b24e51140602a25d334c1c583e91c0276aaec629e60bfc5e3eb423baa894771b83819dc1789643f807016e59c6aff63eb465efc0244b6fd2205eb5dabf976c0208dd95ab685489c7b671a6d2d7e3f353517fbb02a924e18911a193f388dd8878587d48c25212687cc662eeb2f350f2d1817661913ccd9b2ae9b4bfcaae9bb3bd6165ad061e23b0610ad0b5c9562333304cd0aa822fe8f9412f39fa077d4d5fc420d709105c06d6d1b478b510d851775bb5ac1f9f66f49580655de4062d189501f102fa5cad77df79a7a7604196d16b324c24781f8028411e60da1ff9486fefa64a21f85aef082a0602f42867813821b2fa1646d1ee1208b402d537e6e2a1b4f47b841fddf49986d52a83aa4c4cba7cc6c94c6b75d1d3e5ece7dfe970975bf240fe4e54872083b393a7b46af93e1a7b8a478edc65e502698df9b2f1bd39fa89117a823bfd3d3a0bafad3b8c637e3dd1eb83b33acec9cf14912e2245d4f0531a2c422e1ac7d73020f529f101a2a01b50b2a51f75c497236bd77e5fa70fee91e739861e65ad49429db43b410b9b1f274a2c248ff6b743abdf442f9d4c03bbc1147fa209fa2b8edac8b411e5e93dd18526c27b2c0aa790b493f81a85dbd73ec46c20d3b9e14fa53b8e589d37f6e6be1e236d48476eed2ac7d44f4f198ab55b08a54c2826f9622f1baf9ec786b9ce6e47f496c7df7d9988baa32f198ee17ed44260387af59343fbe643dc46d1c2aa21567f4f060f80ffd6f8736ae29e169d1edb68f82b5d7e59f66ce1b8549bdca06112b13d59594d5cf7b480bc3b94dae4e6a25e98eac7fcb3d7be659d043422d31e972def358c75ec8dc8efd3594966d154a59d07b8490406d834d3f95c99bbe478058bd0e739f3ebab27fd44bc985caca07e55ff763754b8c1d663ec978c9ac696fcc94fa20cd91b66c89eefbb467a1830daf1f2c3d72adb891b49ad81656853089cb2224dd834db695bc710e51986bf5c4ec620fdb4702efa8f3c9de045d91baed2997af16b9c66e44b440849ead1e90decc222246ec4edc9967e8f7a96c0a48d5c62ac4a1c253a7df0b562460cd29cdddbd5007773ff7619b6961b3bb5dd8049516d32c40c5b53e94a722e3d033c2a41ec62b1044d50c978d3ef61ba9eb8c9c9a5b350d15833b45ef4100b6fda48f78127c6af8ee6e85bdff3a3fc0e41ebefe1636791d3cc9b6124e0fb6007c75d330466dd7a88455225ede3fb67038667c1984326970687e2e8a9d580cafe0affd4cfc90aabca69b5c30d926bb90422408e02507c8c199c8fcaf765d328ea58635f23680fc356451a64b434f4a634cffbbec9fd347ea46e49e64bf5652281301579a1280024498bdc42dac59dd00bcdff7a9dbd06225e5e2fa6b0f693cc8b378b3dd66941659f66f579a49111854692b2e2dc4cb9527856c681948f4cc056fe908878574aafbd858e9fe4cf2f11681d7dc2357b43ce24a1a39e735cf0f6e88e0402434c6109c3f668b70e0fb6e78f3eb59a666ac2223e627031e66852b96e8e08634d313a193448a28b0471ef5508b1cead4caedb6297138c8461ea1757fc98b8042f1f60f1327d08d92821c12d227c18427bc8326745ffafe47e1360cccf343d40fdb0da22f0c3aa736b18e8574cbab309d6db4c92a3df1e1a1fd8c804f208f566450fceb5dd7c80662e06026f1aa2862594cb8f21ee59348902b3625cd5945c3cfbe7a098c536eec73a75b5ca88277ee57910827ea9607f35f72015ee7a979e5eb5d8b10d12a3010179b00c902c13dc9ccb8ac2b52dee37e9ebb1b0d637f51a6a50ae978516f98a6eb26e299a1533711adf1c596a57b656603a88cd766cecac1eb9a3548a03de27c22ba5e4bc0fbd93fb137c6c1ff19af5878eda8d6e3c1283f51fb311bb0682b1661739c4cf834306eaceaee0ec7e689d8073e82c11362e530630d16d9441574eb9608b21ad3622b558a619e3c511826d88553d5351829de6f8b51b60dead82a064f83e7ad7cc64dcb290bc95badf6a8fd0d17e3c3b82c2073bc2b49ccab37fe08dbc698ed434a6bdd2e1ea145e6cf408cba637b10e88162352ba9e2e295877f1dd53326cb5a9fb8da95f50af47e495e0633c060fe2b1912b9a134ac5d800366a35b2f6b7cb460f9d27454fa1f3073beabda7bf491cd52fc0d47b291f179660671c51f1c55be61cb6ed523a8bc16380ac409a3d3b1f1a23fb5b3b82f3e56dbc5af19ca12cb51039c5d4d0313a07382fe618213eb4f9d604daf5e7290f34c1df95ffd05a6518c558c919a1c7ee2440c3c3564ba5727675ddaba68b5aebd3a1945c62a33329eab57270cf3cd424e53d18e13deecff947c2195528062a372441837056afd824d6067d5383f248596b10c9cc64872149c18eb14820f113fea419fe2d8e20a76a2ba2f4abe44801494b46b75241e4fcd7a61a0b2def110b25302846e6f478dbaad599734b0a04d73ad2e144fab3c79043dcd904e120ddaf13cc3a5a5ac6a4123b8827927205f56c18219cea84e6f6d8b047eb9fd450d943b6f3dc8a2229fd939a7f4e49f09e515a3a638037c3c51fbea71e69c61cdac2cde03e1123b61cbca543533be5c92be7051a8ee97855d7a72b701727c99cc1d9cb28a633e4b005a5c29ae2c489c530ebd1941834804264843c0e8714a8b691806b04d24d4bd9672980fda78e46d48e7da3ffbe80a183a146fa611504594b9db3ca0b09a524b43b9e2e375581a78a916bbb6eca8455895db347fb05bf69fc94d626cbcd19c29f07789b60fb071d82695830a6af09ddd67faad8248909a22eb025eaa72d2050f5841698ed1283de8895da2795c7f73bfbb51edb27c8368081b51bf55989b3ede49458f277e76b3962053527e9c0be1e9c3aed7528bc14044ec39e2fb5e44337e1b410802990fcf0139eb615579ed3e6d4a9cae16187e87a60ba3ad0ce26ddb0b43f50c6b164f4a937bc4596becffdcfd80c789e3b6a7aed0d9c0f860bd42f371374e4416c08f26c61f552a05578dcc9604f1f2bcd9ee30b55046e88d9e5116129b7c08c500d3c40a6d3db2e4e203e1b15cf26bb84e75523b9de9189a51cdd51ec80792b2c2fe7bdd58b022497d676ad29db6bbd777f49ac329e8c514289e9a12cd51174115fd156cbcce2959a3b5d1da0a2af789064ece4a94ae4a7e2698c3e13f256f76818a0b35b575476378d93424ca0388f7b3ae09883576e8b7dc0b0b295bc2d7ca02e13bf860ce42469ca79fd3a3f4586f9ecadb15d74ef09781bb3fb825966cceb73665636216d4893263e9203bb2c486a1e48eeff249497c28d1a74928580dea8774406628f039c2a476bb027c2350c25fe55cd59ee3bcc5f3bff37871efe2e7f964a1da8a1e158dd09c2259e5229111818e3c400c2c05bf4730f4caa538830c341fc1bc85e1d083c9876707690d6c036bc61467b90fe716c09c02da6fd505eddc074c51dfecedb9d5e41a1aea3c9ae4db8a6cbc0b399e57c79cf6abee8ed59d178d7e05f7182b349807dd9be6fabdfc6c8a4119191c77e68e0a513b044c3315a1f1c963e73e1b94b242106e5f252b2b0e8e2819a74ca5ec4c037cace1f147ef128904132eae14997735dc5d1dd83a2ec2e2d72f4ef02fc3f463c8247e71e7425adaafe68a350b6f8352b1d453acd8372b99082384e28a9c20f2d577ec5e5cb8fec14c051ed95a3331f4be40aeff167346a63a72ce101e81d45950660305862554f29d020b1ba1d0ed272f904600898337eb0864ebbd8a8346d89193dcbe3d209826ae8485a589289de8b8a1cfaa11a8cca382b2b0c6e8461b5cf70c2b776843e47151f73bed77a457d7808e7dcd69fa177a6ee082d71bca64c4bfea07291c8f73b3f6533b92f7f249f5881309518557cf0144ba664032e20b7efcd2f20df5d1eeaee2f27e1604015a1f4ed03a61ce577bd38951c703caaad3bec1fc3a57fbfafb0a64e3ea9d37bf8da37d25a970edcdbe9c7edfa31f66c167bc1f68c2fcf090832ac9a8fa0f319778d16a3849717b9fcec03a77a9fdd0f894a225ec8fb204b196e55003edea1d8eed24ed6565d8f2dbab9ff80063f7734e4c07887ac865905d35a7e97a643ad74fda5da9aa9c52c8a117baff09d56761b647989c1e64f9c214a988366ba62cc40a04599436d09362a9ca6edfe04d10a395f1708cc542d309761ac5ebe70d8340ea073d29decb3a316542879cde18e710e9d712e4825c6501a47ea0abaad795d2eb18d3197637dd0a2d876fcbe12d21a466d9a6a5d7f1bfefd4cb1d6d79a07edfec0abdf2971b354d4ad7ef6058e6d08efa2788c760a4df7189f13450970f083732cf40754b21417bed68e9f583d2d3c12a696c954edb28d32f748da567fe068518ea64a78f2060473e4c1d636484d690f0d9b8ccba230135666f9af69473b9e3e2538a093dd1bf6597029d4995264d67398bdfc11af6676df87cc2003b0c2f2f14dad9c032daf07e2302637928ac3c53f6839b797270150d86d4bd7c47297c7d5aa39c2d43a631832586d331a3219b756af0dd981b87b477191d2b79ef514b38a3fa051c1312673d37df7ba9aaa292a61f18f4f4882903c8734107707035d64219cc285e3cb81b2aa049370084de7797dc8c49de37e312d5eff1a8abfa5e261c1331a65459a760e5acfafab51d18e046bc4abe77626cfb91571f4115d999388b7a0a68457cde4dd18267ccb2373af241c3e2e1a6993376e02a62815735bad41cff764905a8fbd9e4c45280ac58c66a94c3156e3b44330c74472206a145c0f69298744812a76d0aeafc9bff5d0bc4c34dd2faf23b99cea0627e7e0249964d9e89648e0637e07d3b65d1d579035cb941efc7e9a60a7f5ccc82d773cc3928863ec7ca112cae3df68ad311151a92606e0adf0dc4b1706d5a1c329e5ad563e48203186cc29513a3de9f8c007ba1e20c969bfd5b1153ede5a4837b156d308614b0f84d805f6af967e809a73af6c1dbae42d2f283e0c6ff41cd8469a6247eedc62dc4c4e085fceb00b77197ba2653ce2386a10baf0e5dd9ad31c600b66fc09f1db1231e87e04a6e15ac8a5d060ae0f9047dd543d60f190cc93f6d83fa8510ceac8dde41b352febe357ee1be885638f1edaa9cc972f2297e64f0931043795af3c608efc4e5aba859409620328e60e2b9cca46d63494f6b9d5badbebc56caaf490c56860a702e733401e8087123372d3f5c85b07d6a920c1c5d1a824112292fcd6036fb0710e06e7bf094d33b5366ce18debd297f33abd8cf75beccd5b310bf9219a00bd5c45fafd67fb71ddf18b1260e73f26f1764a7fb0b37082bcbcc0596c2119604ee6ad6813e50fe0f8ad8cae45f2bbf537fac4ad4715031a9585d21bff4179c9d7647e678f16a77c7a1a3636d19008bd13f6ee93c52a8ae46af479ef8b10c649f6a9c5356624101eee755693b8d8a3445c565be5d4905de79dad1cf2e10f6e0762c35f747c95dcf0bd4759eafd703b835fd4f12fa214756b855ff3fa7a8d5271cf1ab0249088bb102aa76b61e45ce0d87059964b213a330da12b88fe021af6197b84d7f4e84714d24521b876b2c85128147ef75420cf9d0d6ec9d7d616ca49e73ab1732312dc0b7ccdf15478be00e74a4b2b05dc5157394affaa6ff2dfb45b787bfa5f6ddb3aed0315589f33235c5c7bba4faee511a94684b87863e42fa731d8041175d7c8a0dd3819a66b81935c16025709ca4fcf9d7eb517c19c80b2dbdba6fc3cd16b5ebcf17add01898a84add37ea206b661bf42de24764d4e3e6fcd2a48b7873ac8590cafecee7e48a8ad02923807ac94c0aa05e3f75b2d73c4476109ac4bc7850462f63b2cb4b463985e380e034dc423f1c295eed9c120537f3b89257beb5cab6b621bd59c4a4e738ceff3f448d7f189cc5231398e65e775356b293a95754026f3a4bd0f395c5f2a0e52bb3c5a24c4fe8e60e1cdc7050c9e73a511abd82d0ee5000dc41974293027565ffffc620ba84f290075215a5087d10abaa2fc671d7854ff379dd31117f380342af0cdab2ddd014d719643bce98211b156178a8624dc3a7d1649dd4b478b59e88c24a297266879785754aa1136e8b62d6c5a98e7745b63a804245573c68f86e3ac0d7ead12dcbfcfd00ceafc7c031b57b53f001e44dce71c1bb529043c8b51dda804b59fd32c6daa2bf0d902a7da9a0effecdf6fdaa977538c3639e0da03a11f50fd5a39b7bd37a1669b0b9360869811e5a5d34b2823d6d1ec69e3d74ede8b38621875cd1b23e81c24f392dd28a9d58a099c27366bb1587352780ce1085b39cb1f981f11aa2afff036cd877a07ce1a74e8b628fa4047e282f13be8c362171a5955252b11d32ac5bade63b44dada0dedff644d0ac3980faaa64dbab23a994f275ccd6b509aa557202183612ac932d99ef893b499a5f895b9a9db7711344f9881b95f9f00b6818570899a733161dbba7c8b9bef582bc0fa6995fb9cb46ebe5b55ed2a7a717ec5ff3241cafa7ba18833f630d27674f86d77ebe4b3f26f57f4e3e7a7f103e5209137e0bb016ccedfc188c03fa5a3b69f2cd9a1cd2566d18f4c590fd2ddc618403e7aee370a795e1518521715e1a0ff276d822025be8fd494348b3b464208f94258fd1a650ff01b13ad41dbffcb8fbe487e60c93363faac46385ae18ad3cdc5333c9abc8256d05c07085c96161446d731b79f7ac2cb227e5d233442989383fdb61991edbc272002f4d80f8fbecf397c347d645f43f82ef25095de8785b42f01fdd40d0eb799f42c1eba143fcca8daaafc0caa6a6781bed160b834d8cad7bdfbe690004794bf68cf0e40193f7323cb68c49651be4c1244f51ca0cb4decdd69f250517337a996ce04932113942ad65e9ded6827ee9f83d11c9155262a270fdfa99abcbdfa4ee60e45ebbd6d31cff1516d5649a11f000c734177b0b33d191f50d83c40c0e493d90459db5aa03ac52a756c6c44c41b532b678b1f2368e52f0fb2fabdbf5401a574ac712feb3b2b0dd956cc7a6dc6b683d75e8bb4c2a4c0a24ba629e51869ffa034d2ca6b59c75bf85b263165df35e2329b69457254ed2b8a128563536c5319a3bb14e68a5f30ba70bd385dd71224b46066d4b320ae45f7cdff00eee7dbdb97df0ff39c1471a0cb1b6cf3a9d74416fa5db804d0b2d8c1560022fb902c8ff7b5951455be54e241a68fc974614ca6723c3dd84c5cbe5f2f43ce9159d5c5972288a91d1645ec19085151ee805ca478695cb21ce42358f2c97dc29ebbdaf54adf30436bc45fdce1622835f8b1a945e5c1085e3644f42165a64b729f92171b00b75b97a81cecdd45457b47d8f7b1422171d2c7bf579fb8adacb0eba9b43e3c4d1ac9e91b55e418ac6ae7f4d43c3278f98a4180e940e51dbd93962e961b63050a925da355361b30bbcfbeb921affc5d16c3de600fcddad7c9765e000a479e8a26744ba7f638d4a7557fec58d35cbae1cb690de671d78dcd625d1bbc745615e85db00149c6c264fbc79e3c59f359af3b39e5b7d9e29d416c4cbaba21ce284046aef887854a6e582054cb7c73c0c5392d00bc7025366db2b2e57fde6f352d96d4a1ddb859e56450799f474a3a15336ad3c997b6038d730c8e97d67b097969a87f6e51801a7247a9426cf1015aad005113c5ef71fe230db608e816b36a0494d39fae4e1a4a6be82b2c29125f11cecbb570ba66911f2c16846c5daaec7378914691a1199c54f199ff906785c3dc72882161e1647389123968f19df23e2c82e8d74a0e570417024eae3d7df0f34edce912fe9c34c037132143b3bf9a99bfcaa6336dfa27b6a82195ab3bebac951b1051e5b379fbdad1f4a58dacda08da8d5817167e2987507b12e581d98530e55093d0e6290a3b7715974333095ef672d3cc95fad8c285771759fb825dbbda5df8d2d78cf7385ec846f0ab5afe98c4a568ea849aac14f7b208b46304027cb15273c64933335fee53ed411aae699eb98a552b56279b9ab52fecc87d42ff5240b369b326f05eef34884a9f6e31b474fb33aeecefb5a7b91b46f7fabc1dcf995e75848643a2569d6d6c051e253068ad81f8b617abbff27602fb7fd6411f26e7440c5dfe66de7b13f4ff","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
