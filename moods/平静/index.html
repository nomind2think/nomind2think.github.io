<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"595fbc6c2ababc036ba58952a43f7b72d53d37761971de56f0a574296443c17cf92e071068c115c796ca9f154eac2226546d3bc5231d19d953dd511b1df334e2a51645d194dcee7fca6d991b99dd0f5584d77d078817e05f674344509022fa7e194d2b53dd341b49a81ed7049523f565910d31d6838fa5367b926ba43a590a347a034d0589a383afb816340c9d213395ffc6524e24b36afb2917ccd71612d546a06e729e35d68f0ac96fc48348e682e8fb6919781dad583fbf8cfbc7de82cb12b3682db56d9defc273c3dc385137cb6ed062cf1d3c7e16870680a2ed50e1fefd7b6061a911f84900f8ea421b436b0be35cbbeee6c26a80585a6effd8f429883bc64ab77c4c5b6305c540bfeb425762cbdaaf3979f9724352008dafd23cdda5280ef7c5d4e7bb726fb5f187823d496c9e144defa1752a77d3d60870ee3b2cf226663561897d9fa37e1dea7f1f4868783cfa558442d8235b3004ed524c160e8870b41a24b8a184e34e34a5b4489c8c6d5e034c8d606fa869de2e7cb5c122b4edcaf69b29468c0b800e2ba69b0e0977d8195dfa410af1580c24f5b988988f03d5f94a999e4b2fdf894b43ce229c51a4f049136bfe6592222b8c1880d71dfe6dcec517bb3e81ed8951a7d0edcbfec0f1c2dca1b7d7d0a5dfa4ae88e44cefac1b6b2f3ef11798ae1099260cb0f3c8c6893c0a52f6a464ccd5a286c6244b06a6f832d0f99440d7ffe49ac0f641826e381499f58ba454b6fe2bf80d8be414e9938c6dd572fcfd90e98a8b4b7f3cc9a5f8bedfc9cb30c2c65c5ae878b3e328664070fa06209784b455882fa05be9407eb7b2b5ed09891661a9ff35ab4a88795d66020c6ad8a17f4da476ef0486e8c05deb244c4ee09e5bfb1be38f327bf70c35e1a98ab22e72bfa2f29263cb140b20033fe2ee30016358c254e071d5f044a81f80a9341962c852f26d00ef3b1ae1062896da9905c41b9083da4d3fd529b7b9ad462a9d98d6082c795f9444e0ef9ce1b8000e73e0a4175fb0389fe0c024b310471cf2852df68d68a9ecd1d4d5136131cfcc30cc323a4d7d186ebba3720adbb94d41b66bec09b3f1bdc9d78477afa98482221e3ece0da80ffad2caf757655ba0d3c2a773f1e318ec374d29848de41e99dfc77fa897fcfc1de43b22283e4512ffdb204b46e3d8aad069f6763f204082d486f42f60bc3d87d6ce274c41eddc1cb5647e69e227031404a23796e3b6487c500df2d9cdb1400bcdacc1b8bdd053eeec43c923e046804578c37906d599f9390af0098fdb3c8ec5104bc21a0fb0f2d98de8f269bd80524a19a37f50db1cbe557da8b025c152d99747449b7859081cb54e6e8d3da9737e88416155aed0baed2963fb5b96f6703b589ddfe707cbdd7230eda427cd4cdf0151e368dd69bc1172cf93b0f0facad31bacf9fcb0f3cd998d8f14fec9449d0021f5981b735709b92b1522c94e56b3b35bf9ec2248914b325f032571486f4b7abd32e88f91ac80abe00c20a51b03ba10478dc922642313ac130fe90a83ee0c452d410fe2892c3be5783e8dcce3ab38e76bd8f49fb6ae09d23fa287a3542c0af48e05bf763607d2e76c62fcc05393dd57d5ba77c33f5d411d8aa7cef1ea8c81008168192d985fc3d6ccc5a9eb93b32b1ff8dc924c385292160d54202696d1052b188fc8236236999ce5145617ccb60a7b8d8bb4b57fc3f0817e44a2db35a79607ff2c8eb230d1d3e987dbdda3e513cbe8c7cb147bf60a4a55ff7440e6cbb76b7d656afece09aba4a33b189b0023f20903a7e5e537d8d4f204ae7377d7183fdacdfd9631c6ff7eca374c9419e093685b5208749732c3df05264529bd58806c610cc8dc3a752a25e268614277445ed4fca295c1b0425ff17ec79162b813dc26b47d7bce075f86c5dd98ca4ff99d8a98f8406132a1488ffb72ad1ffe910ce667886598b586958f9ee93bb94940e15314148475411201ed840265115020bf9612c7cfdab0bc649d69ebbd55eecf483e051b55b6f51a4e46425a329ee36a936e33a1417fa81bb5683649d72f223b999f6fa2a013a8cc1b4568bb6c0dcafae6b6b676866d309dbdf868396fe3fdfd669bc7d76918d8b41688cbf6251a3ab93e2c6254b036b7c77e1a3e75804a35f0f3f7f123c129ce1679e48314faa6848a058d8187dac7199c1b20cbd39468f6ddec14fdad16a4db99a663a410059f2c453692db2cf99c958051d5f313251d47dda675d4823967c977ff34c643776d60d7418de3b76ab7ea9b7f056c4d49a6e2c3e269c87df4e03353f081b1ee4877e38949047157c2d3ab8193d1f0db0d7790b7505cc4a90a6e907bc5fb094fe9cc553a279d9f57f99b0c4bdae2cf50d859a76e26148514d55c658935e196580cfb8563f7838a37f4a14120df513c9517c060a3d81f0af9691d022bdfc85faea1a0a0d963ab24e63ad7ea9c67120acd1fc5a798d75e09c3a4e3e068a84907a43b7ad51130d89e0d2adae9362025cb213a4929760f6ff8313001e1869aa7745f7052299390cb712d2e53a9f3f9fa42d58b1d699984083cc2526b586d010270f4564037ad09cb2abafe464e7050c1430f5b5cf00552e0d3f267f3e4d43a9522c38255ad896bef59c015679aa40148c620b0b2e3139ffbed1fa8548f7dcf96656901a0c9d8067172e3598104a7218f3a3c9fbdaf424ae281b92c7a5bbbdcb77ce96e7ac2bc08ff7c760ca4c588a2f6c9e3205f1b7f5f7d2fceccdf3a1ffd6931cbed5ff8fa4eb467baaf47dd4d576e7c015a0941b12fa7a536c4fef1288433fc724f7e4560fc6c6973968782f4537da49afb7d3b9701f706128030a276c14278abae421c10edf7375f937231cd03136d954ce0945eedad2215dca732074da461272e42475d98d959d60375d6b022739cb8c2abc9ade6749a45a0202dbf96bd698fd00f59a1cb3e438f1f423280533d454968aacbe4746dd24d155cec48c9a2e853b529c6f4ca57d3456a0e65334e6265667fcc879bf4016f48de6408360384cf20de62708ed32a63c2c7b3f1c9b9d502652a1689931f69f6f1f133bee63f0cbb2912102cf61807c6e4dcafff1f8e3950c9fa0283055cb2162804903c054aae1707d11cd1cdc6c7f24a5cd2bdf3f8adfb3a692d07934287693c76664571033da4b2a470dcabb5da5e4ddf16a79c867b97154f9163782dfe37167f8409437418f1a65c7a686554ececae48fe4bc9fe4f248f7334770e9576f628653335039ea7e5849ba504d1f71b240230cabbc7c2c10888ab5de7b69b0b78f05b29fa5707fb71c1a3b808d4e9726b0d6e6fe89b65c17fcd03547c0aa765f8900fd5aabd64f99eb3a164d34ea7ca99772ad5fde1eb5c98728a3a13d6211d3abbf03dd07ed6e3e43587eed95fcee5ea74f14c93f677683300ccf4aa416826692b782803d5cbf345d3cfc3f2792af3c0110776fa6b74a50e7b917815e925f47a78b893f09b9cb7669b1c46b1546d725744e87da59b73b231d6149a56a09836aa6b3a37c0271ca6e2b582159d5e734c58c91f9d245f591dfb693f160b20abd764d55df09f28b0506214e92883f94ffdbafb76ff6050f2dd5dc1be3b92ebbd2d63fc9c7abe59bbebc28bcc9ea0d5e7215335f5d2754e321fef94f8c298edd023ed617a3f459cb7d78f04ed73ec89613baa2bd036dda4522692b3307930ba6ce53c4d7aa9d05d1df4f39dec1b6103c2da389edb16b7e83478f87b0d8b52793a4add4762aa5fd74cd469d5a4f837c2d59ef762eab2e22db182626a00d8d263bffe7b0e63e8c2587906cc278765ec4e2bb5826d478ce47ff2429df3e2289595b0f14e292fe6cf1480e41c08d13c075daa72b6948203491f4626aca0f58cb01cc98a710c679b16655a4c354e7f596f09855301badda25ec8e01dc0223214cfbceba775d7b048ada86ffafcd77826403240154a7b00718b90d757c43b3ea6aa0be0e8fbaec6c41ea3d3bf4c11a22f94ef6b546c0c8fdd1ba1fbc47d5e541ed690dcbb4b69136886767fee77ede56c144906e6695d6459570530fbe6854a261458de77a33e0050df92eb473e7ce267ddda2a2aee7901caa4f95927f9372b9b8ca843d05f70b7b9978bf0a67376d50eb4bd185cd1b5651ca51517124c4ba48a381bb23e1f76ea8a2de8028e927a3cef7fc776d2bdde12c0785fe5d9a9fd476a6623811e5146a073e17d8ab90e6c2f203ab4a69c80ae41e07267eaa98302cc38e1b86abe7292599101acf2fee846ae0c31c9870bccbf85c14525e940cd815f8313673e7f6e7e82b38070baa80b763113a72d96fe9a795bd0248a5a34916fd4eeeba588d1a1015544b53f32b9cdb765cb5e0949ac7eb05ebae6d12632abcbd2467b3c49f20971d701d1cb368a231b1e796174504800f32f2e4445f8525efa26e96432730fe924492f5c6fe6848212e3548253a3769e51d9a864f549aab6bef6c62433c610035886ff9809cf2e53b0eb4477bce4b4ad558beab17c35478bfc696d55931eaf30c9dd95a3ecb0e08da850fd52e2bd52693ee87c38eba4724d4ac5cf1964e9c08db971f6db33997cbbd21244eca8061252d9f05af4cab742c1782279469b3f41457ce7abc58a189c0232ffdfdf62275af64e82891c36d1cb7749c9c4c18e4e5c917cd5c72fea930ce2b31af3bd8b8a9675547ab991273e60b53ebaed935ff1688625c4433f69898a41ef2fa267642874e7308fdc981d73667ec6912ce9c30d54fa46fe229200135fce74875c17251e288f9f092c42010d07b1ee58ddf7c92aa4cc150421f4a6be888aaee350c0db21dcaa7b87e126eaff0305bc0b7ac5405af4b1397e81f9a7899926c6fa46a1eb14b543ec0ab38d677bd623f12a49e9429659af5b0620886dcbfd5d21cad9867d563ba6c3eb9c084698cc64f8d8465d539037ce4afa21d9076eae0a10defb0f83c4316aca320acf9c80496ca19057923e99d931dd122cb601f2fc62d491202ef67b935599532b318f646e32e0631c8b076a31b249e921a01a247d87e7ee68cd4e1a2e5f972ee0dcd960ccc35b31fae09208c5bcae29219151f8da3320e1a76460bf099f3d1aae93ce5809918b7c6c4a3583fdcc417e98154db46e6060dcd13efd9f820ecbaefba353a45b70940b045d59b71d434fc2a66d6400289bbe23550a02163900ead2f56cc8547fb9c196f9c5df81b73af96e3bdaf9fce4357911381853b225de33522a04a33a79f59050ec181b822954b98de26bcdf847a9d7e263494994ae74060ec71bf37e5a7e9bd1dde23402c38cff21b74c5749ee50b241ec6d7c256b1697c4e1b369ae6be463be99ae6e362701937be72442065410a6290e10af72a6bf19a3ff1ce5090cec6f0ccb259f166e4e10958cc828b0ae787f011d1bba855718ccbfd42e2e926bbf86415ec731c9bb1e891c23c5f83b524ad58688a2d26ec99568dee902a472ec577af795fa26f528f6a8a22c193263350cebc15004b233f34f812e46461bec2b106f97061dc3b865b51f01429274f718a4dde36ba46dc53798719e20ea083ab692b500dcefc165cbd8ab7e35f203eaa95dee301385682935e48ca3e361e4646632d11b525dd352508c0d115042169aab592e2f7bae133481d3389b9389d2e07afcfcd5fd28a8f88ce88e1c690f60259f8fddcdc45c8bc85851fc98da7a0e620185559569b05c0a0f1a41083dfdf7479bbf4eefbb774fdf3ede0d90836967f875f8c9588264373b5122a326af2e1bf4b8e709f3c8a2a09cbc64c71c3c3e57cadb2b0f7648595306e0d24b78df5cdba6ab5f31ef59554848fcb80dd1f45d1203aac5304c0fd37ad29b39996e228307ec8211754a7ede984aabad0a5b0f5bcdb73dba814e1d8b31ea9e693a57cdc0732c055482d78d88dcd233f0a8ea06f5353d17f1a5e7b133c82e44cafa95cf6709bf53a843b752e549a7327cdb3eac33c01ef3c448f47f844d1cd76597cc6a6ee61872b24f69bca3fc749a5c9b4f5844ddb1857f4a734b22c2dbf16d82741f52249d8adfedd8e1277b0cd74f40c5d3d78382482cceb0ce3449cdb1d39ae7b86aadce01822df56b03af4fd7eb7ca6f2641a54f27aa33d0e7bfa19e26a0b4721fa9e16ee74bc9d5a3829d0cd676ba3e2a4537a597defb99539b007874d2e8d24722fafc51e321436c84d385bf27c45df705aedae7f46726b9030e1e055c48dd2793d931b403921fc8a9ce7c96b09353d55a32c86692fe40ca223cc07601eeeda91293ed9795069737402c66449b0be5c25ab827cded7640346bbef1fa9af29a370276b97f3ae2b5982ea93cfdba93d41684973b5413dd8c5bd6d5261b4cbb9a3dfc58196eb69e08f7ef28a1771eee505d7e72ae4eed3df7026b79b109f7857b2490a03616d774a0649ef34f5ddcbb0f62dd12b31baf4237545989632cdad8fda5b9932f40777311fb45b7ff843fe9cc83a889daecc1dd3831a90a2d82f2d7adc593c9c3b93cb7e1403cf5f12de01128e82e6e4bb3b8dcad8f7094259feeedea05b956746725198b9a8b61100febbb78410f6bf5be8f27e5adc18b0972d2aea87296a0272c759526924790f66cce5285ed797cea8b51a251e041dd1339a30119d13f5a645c23a698c6a00c5bbf6302c56d995fd4b5e0f76cd7a971bf0c1cf3e72d9d1a442b9a872740ff8d8f6d0e7c7b54fb1d6d11758d22581e788c1df62d88e4f4036f72eb0bf378277f92b01540ac1dd02b0d2d229a447b3b663ba751a96abd22bd7fd1495edc954d54b1300d041a7fa06333457545b7f0d36b403f107a937d0281feaf4a3f2d7d63c9e9da84c642b36eb98d0ebc3e997914b8656dccbe3ec46223c65e156944502913a52bf856e4b956652b72dd6620ff93a0fc4271e0b94caa4747a97e8c9df173c2bd08f87d5847142b49aa145b4933e018dd79d012c889d4bd28b02a871ffb4e09e49d6b2ce280480a353be908ae3e7e15657546684e85ab1689c23e8a7a40e84a570a2a81e7d7a85a8c6cabb8e236f42951033a3cb92c7cc4ee9eb1065cf625cb6e3bccc18a10a6e35189b625072cfafc3fbfd787e32686a6964f6c30e69c25daf61bc4ac5ec58ee83d6810f8385d590519a9a94c3a70035abafc29b69ed20055a602a4c402cb5c38c5cbed014e71d7913ae462536a56f994722bb713ad41950cc24ed6c4871d5639ec4c248e9f1058b9537460e320b8c1f3d660cd16c5249a9958604ec6d83e1eafcd763d5b3506cbd71cd433f70268d24bb5f8e28dffbc1e83f364626b11deac726ad07ac7206ec1df1d6722794294cae26c9e8e72d28cf072ec67ca0b7374bd4aec3fabcf021a2ddfb6119f88d686b7be867a48056c48b3508afeb3b930e9823217cb78ceb5f5d2652ec4f5936a12e5a7c9da677c47f7b3fec651d1a41c0db4812576d3993fa7e11a4fbebdbcccaf2a27470a6d49741c948d4476790cd25ee48d5f507a79de100d5a826a516c5a9614a6621ee9865542d3c6c0df7de2e96cbc28431d44e79abeeee41c5bd5aa182e430f645e0e43342629c11f4d39d3e28b0bc708d627ee87816f52fd90f1bbe27dc70cef74b1f2c4a7050e4d5cc132c88b27a985fc4f23d97e1530a4bb1c34a93a809353ca37f13d905caaad97636e18afe3607ec36b3097bad3ec70ff67adc2d770948dcf73bd7c13310ae230b479457c412d3b4bfe2f735f3c2ed09387ad591ce2060fae9a96c331233ea3fa1d7bf4f6f237b50ce5a5fad21f455d817b23fde099000f02b3e515991b4464d5379fddf6afdbbbeb7a4c4dcb25a8f571ed441d6fe133b41a1a5c96726929e873354c661abbb5eb6e75e33155452a4be13bbeadee9ac28e5a5ba6603154cd9dad7188de1c52e640a654b8a4ee7858f143ee971eec2e6ea0b1188cf2d5936a2a751cbce272e8a7ab8609721b7a2d67eb38e062acde5280e236625e9db55da407483c22cff6fff5924b4147a584a56473e413fd2ed58b19c153264f06b9311e6f2ab51b4b9cce1cac17a03b4c6610efd42d83ac2a4d958e0a7d5222f6957b350614a637eac56ec93cb062ebdbdc64baf1f6fdbb6a8067f0d46e924f9e0f7a13668631f0abb4497331997f389b98fe3cb92ce0911068db9408100952293f6c02d3e445d3ecc8b5e813268fad748d0abefccf910e0ef835851fb54b9dba637d41fcf96d35a66c93607738ed6dc2f65240a2c93c96652abf6189900154fcc1a19d88c3e392cbb751cce9708883e0d9a2076214863dafa98acfd0c4f700290b1d3c43878f559df1acf6f4d8969095bb85f1840a2799d74ef81166e301f5ebdf4ccf6366d473ba08d53fb2b15afe98c2d3ffcabc75907aceac6e6a03730858fd2ee3eb4c953a5daf216d6312e79faca64e256e0c66195b2b9db78a297b429cdf3b3adb153a0f46bd6d5a55ab70211a6c201fd0b0eaf1e833edd76d6cfcb928e49e630aa1ff2fe7eb18e338ad631b5d9b5f37e38894aa476f3a561d01e15c61e13d86ab11ea433c5de1c057ff9c23f0d3c3a1c0755a2909b3c95713d474a34c6c51fd84daf14b338bc56d3ad5c92c65dddabcc3c71bc9fe21e43267ba8b23427c4a046a9505d8a5d8d20e09905764fd436e9a19b2af3bef6f3069b5d52acc9c57c68d830b37a11a1a516d0a7ff1deedcb7d0c31a9e98dc62cdae8db0373ff6bef276bd3efe78b4cd7bec5da7114fb65678b6b3a1392f03dbef3c44f7427b30a7789827b53ff10e65c3e21c17e17022551433c6b86b4c14ee8c2d789c1b7e7b77ca1e8d102d063be45eebd8e665d90a9f34aa7deb8a324d7c3a87bd4cf2b18ad4175730ca8df43d48c64a544865b54933e0f518187a966d183259eb6d7183e1b7bd06bf7e596dde71c924dc36207b4f49522d7c561c3f2e0830b68be0a31bd95cb49f5eeed13b416712a37ace1d84f92620a922fad1c70ad6946b480012c4448c0d6476b4f8e431ad358338e4b15e4cc3f539af5b663051e586f3b5baf6c3f3f6023da7599ae324ea56210baa2a916818b7f55dcb15efeb7246fa23680f08c786bf33bc4c8911c0a2d045a2aaf2b93df8dc6047e0a2a56c6e68679c287166db3325b6c8b4d510e2535e04b8528af66a1235ab863a2fd96f6b36e5e4c3de34b012d7b245730bb7c07dc143faa8e214594ccac5c1b019fe236606f0f19dd4069b48f45e2846b1a238104257f5f9d3fcebec780ce2ec4ea47c55cb18338f6ad24787e75f1c93b5d3d2a5b27162ba4663ea7a141e825b4d808abaa6ec4988d9b09d59e3f0403cdc824744fc394df993b3e1d541a7d4c4dbb818adbefccb4b0aa2f511bc01dcf4f5d05c30b3709b4c956bbb9f049dab552c549f5e7e626542b0b2f4a81921873058452472135f06c1821ec240bd81539e83b83632b0ee12029b3e6f8923770bc8ea1c280ad921d414559283685f0161727afa06d818de44669dbdb37221e2123664b39d4383207fdfe4f776a0a5864c52cdc2d66dbbc6df18d3e5911d80caa40e3be419047544cf1bb2addf96f822995c0901b206f497c1482f728b66fef0023c018041b8bbdc26216a413657bfb8ec226a998514be6956419bed8c109cdd3163f441acbade9201935eeb24c26fc6a71c1bc831d56dd57ad2cc92222f8b2d5893103123acb1bfd2d0b6ffaa63da9aaeab7a28c8c730ef322f612070e7f86fc25e114c74c1bba49642d3040a0a641abed0dee58ce22ee57211815ec6f974928e050ee4c753454b0eaec99dfc91fb4d78f8359acf24370af100ae4674ac577a44235887f62815499d5093e4eaa099f7bb1fac71b94e6ac5aefafd0e858c497448954dd3399e9b5279d6f7c238db93c7489575975a8cc0d5aab8d1a7b47a5e6d091cc78b7ac08f8c4e75eee201143f661825c1cb4085cdda0f582074f6c59a8b819d7bd891b437411867cef40c2bd0ce982e05ec6046e2fe46c11017f2f0283d235b0eb02a00ab9070c73a4cf1d974353fce524dd7bf24f3f6f91060f0236a02f6038e6c8b5035a82567250ccbaadd9ee7d712002f2d9e888b0dad0fe2a30e14738335ddc948d9cbc735e622ed3728c582e6b3dacb3d798f1ddb2173fc595d1ec743d4b9c32227c01b762f3396463532909aaab5ab5dd22b778bef3cfecaadc92965c085a14286a2186fb97cf3a21588ebda83696e83961fe0f783bb4de068ae232671420d77930c5015fddc5f177d53822cb5a16a5b63ce9c3306581db781a144b5bb1f5d8de6b9390fee5b495bd4d27116ce5ffe2267df1390e997d039e44ddf2456353f092d186f08a94ef83f54f16eefbdd71a937d8ffcdf47a0ba155b4712a61c3c7862d5bafe80aab97cd05c387d8c5836bb99804f8d5af18c4beab1184f0ca9154cd1fea9a85815475723c4ecbef389d01f25215f3205c512d049d71a15c4f2f7b92297edd48ca00bd103f8136bc8571848526e88ddcdbaf6dc0cb761e1948d95649e3e52ed36425a279e8bfe6abb75aff3dcb43dce1c43a5626cd615d78ef757343ae2a9fac10df8f114dbc60487ad4faf35a0944e378cdfe81fc823d0a132b1c4e043e723bfdf207cf72952b329687cd9b4bd0ed73effaa1693222071d125156745ad4a9048833bba7104dd303fcb939e64c6fb1d4119e1a3c4ea92412be819769e974724981e583ef06ca2c85d240d75586b72df0bd9ea728a510c9a04f570095de5d9bf8027ee5c5d1f9cb72975d5588cfc0d677b271a232d3a5877da95be79e600947259d86b6f6c7fd1236a822b38767d263e57c96868c7f4241ef4aa3abece6072e01fab718e98e5c03ac9e4e73f6fd56df6a13a87d5a97537441f64b83d8e4ed1ce8a9eac9486d67fda5c98d3544fbe4223574dca2a86c8e9aa9a028fcaee371076b1662b0edef29682ef1c2fcbe958fd3360114eedd9c4b9e741bd174533e0b77068d31a0e87f662a7104e84b4e365f2385c95de8b8e9389eb1274e696ff92fd017c7d520bd49d94f4f2096a8a52c555b9fc78b3329c4d59b16a3f3ab7657f8acc2e0ee420c3daec893a197b447c2b3674a0dd9bc857d20d1f63a299eb07a5fff9e9890210ea376bcac5e6d32279b06cc1a64fc2f7299ba8cf205e9e55eea4729278263224b32cba6c9d637c8059fadc2cc1069a61ff83e0ebd6efaf05c84028624e1caec87fab13c80ddd825a9f28b11cd63b90471194fc3fa1d01cbb6837cafa52c960d4c5cb51fd49948c82f2c4f9a6278e5e199b73b93e6b343b06e691611d8b35d886868f406dccf5b026fe57307fffd7e0bec3f36861ec4116d3bf0d014e0ae91db75ccd141f11b5a0a168ed0760c2b6bafb3e2d0244e5a982fe39657b9913ca9620910e929bcfba4f70b5dbb8426d8640dde39a796564ce3c12809303421870262a22ccffc2f4796d242ac058bfc5310973c21a53e0f1100c6ef230de48897db74006a34d44d9f446268a0f45dfb71855aaddfced051ebbc44ca62669349cb629cced81056d31ab3a3ac28b03c6db90daed94d2a2929b64136b77ba7f53eaad716fa33a9921cc96e8d5dd9689be88c6c15427f82741e9190a2e2cbfc6ef9e1f44d118e79abca10e75e20bb56e198bb1c6c2e0d925f1714e6e0b3e7fb29fcfe09ab28c017bb5dde0ae51dc42a76ca9efdc3af95c5596c4198957ae63d1758df24b95c99e3a691619f257dfe2507294f83debf6b326522bb889f744f293b1b7fecfd5afcb7e48e3143f553791d52ea1d0afd2b83631770eb3f9c14bbec24cda88caf0b7dcf8abcaac63b23790dc8d416a0d3b2f215ec15ba94a8da0be203434847783c1d3c3129582cc1d0aea1edeeccbf922032062ee74f5b2989042b2367bb666344b289dd3c468171176391a589500d28ab1c7b577af985df78a06b32191451d14f06f1aaec36af3c9e1e0dc3cc357ffca51aebe3e9c3322d727bf7d4b757ad24feceb96472b67a0d657bb5f297858de0bdc001930a7c52f9d0b97204270ed2122b43d065841e8cf3057d8037990c12c89f0dd14908e8791cc2a10bf59f40cbcdb503130c8dcfbc546671022e305460ef10a6067cd38521bc6a3dee5f14971899838b860be6d58533edd006cca082c430348d5f13016f53207ae96e4846445471210146d653b1b39b5a7b15b429a6e4ab6206ec9742193846d5c10e473ff74968c75c5f5e388c448779f712e0640e1c86efa4d60acc90716f2b9fa2d0a72216ae3730528558604bd338e07d5efc9df4530d143e8070a038960f1c63b22ef8c45b31d8058e8ea7fe8831498553f1676ba6b3028e14f0a44a6b034b63e3f3a7f16f2a6771fe96554683eb0421a4227c30a3537f21cbc44972f2c068c64f67faf580b0ade9f1d592f3d1c3f4df4ea273f02992bd47f66e96ec9d5fecdaf6d7b87506e512e2174ac8e21351198a6e50075bfe0016037ea91ac994537e6aa01d61aa7f43c0fb960edc3fd51641482967099d44d1de0fa2444ea3442025a1e67849e845c7a0f7f972e1ac987109b61b2ef78a3a718677e695ca9bbfb1ae6fef513acd2a510b1489530d2ff6cc537bc1f8bb8221bc5c12ffeca7049c29f90bbb47e9e149d21dae1a25df8251e199926ff76b0aa5d18b884358e18a7897421d53edef82bafa106424f99e0a78f9f1fecb73e777e4c923d901190f33cd22ca42b67d60c1acf1b2448445b73b598121ba5c74151e875789b5f3eb9e6941c9fab8d3422915aa67544434d06afc4ad1d64645bafe8902aa6166d1d37f14ed18f1fbf934409351a0286b25519e44b76b52341ffd57022d536cc17618e90288a3ef090ea489e376b16b605dbd80269c6004447aff2d56aec51d04a2470bcc7068bd7091f43d6207e9db2cda6bd76fa3f8af734f5e83318d149b919eca976e0a265ed27aee87451c0eb9f482d6ff7d500dfc7137cfe02bcee2eac13d84c77dc69a4d784e50fadbcc17fc36a6aa3d235731d299cdfc74b2a46b6bdbe71ffd41079347aa61e91916e966c5da1b055c5530ccc4f27863b6aef1ca6657e9b0bb93ab5e5b8e07ec0e2999546e0fbb1f9bc35b2484585970c7338a393679ed21f9ee4fd4b1f1575b772a8e498828a701a89791d92f8d77d908791af10525e9faf68be720fb15fdc6cdd6a12607d49d1147dafe92177880a0619eb7038427ad0158846b55b4ab5fad7adabf9eaf3dc832dc1aaf75c0fe7b4e2e4e879070940b6546e0c2f12dc717d99a1efb0cbf43205cc2715c736fe483c952e91e1e2487ba91c5cfc6930199ade735d516d56bd5bbc24f42098f30b1bc9e60e7c4d9c1774eaf2d93692a3b9d89d74b1efd1ab2e6a337e8d0ad4bd041d985be4a1b2b62ffd232cb2b4a7d4c5f4470890e5187b30c0a1f2df5ec56b57a9d49dd4fc9f200870a0b880978ae9747fc1dc910d84caaddad1b98cdbb200683d7145da048f253d63e9970c0571c030a73c0605fd4d04522ce83bdf2dc703d83e427802a1d8abda491029781fcf06bfe657150f2bd97dc5d8bf1c4adaac0d96420d3162b246fd6275e3f5ef2f0c1a5e96a032a2d28f144d81a45b7eac20a8ec8b9b5f771ad5d73181b24566e5d0f4fb9e58a53d4618330e0ad46aa3bdc925e4624f65c95a3ca57c3b2679ba9d4cc41d38da0735307c669c31a415e5d15928a03e653187ed9fd02abe5ec186048ca93228149ac53f1c92d424a414a2a7dff0514650ed636fa557da21c457fabe38229794d6c7b0cce0b871913fdc76d8b124aff68eb15ecc9c6c8b1baba654125138b2843f71a51810998dc0fd260c2e307998d1c2a60a9101819e4b8fb7a0b868529c6ff300c1d0d6366fcd8e55ba3ffb46c85aafb6ac087c8fc64348457a23b9ed7cd158c97f8983add7f163e588fa4729dbc8ab54982ace508d0987ed982a08d3c31e7c60d6cdb1f15ce40d57bdf2ca5b7c4951f67a62f24fe1596180026bbe60e341e6eecf6f0d1055379fda9d5fbf2e9adb4683940916c23b4410bb5c70317513b0e59252fd8d03b68fe6f33a38485d1e057d319014db59ee778e9266b15f4c7eca0ea1994c38127b9f09187db956a70314c1e40028322bd815f2e90cf3f3a320dc12204f54d704e938ffa2315fe9c43c749c7fb4b152dad8653de65dec84091dcafcdab6c5b58e21a8113600efe82a4007c38316b69d90fb60a6b5510f0a008ca8dd468246a1b273a14adcfc5524635dc6ea82e70d5f203a1312c6799a7a97aa3b028df90da2cbcf08a0931ffdda52efd7ff028f4c98612739c341d6aca3255f3c024a74f486a5bd3f966a917fe6c819369a780c131a765464730f3c2bd5c07de9dc4f6b43eebc686f02dcad07e3999291a184dea5190f9cb34ab4e184bb5652882ba520f444504491553f025528116e652d8b479e130f63d65c7f1f7ee2310c0f8738bb17c72da22aa9620f72f8ca39f06c54889a729d7f129ed5b6023629d63e051adf652a99f1576c663fdf96424393d4b4578255493769a967624eef333aaa3f106aa45dab55f24abe630b3b8dd09f6d2b5c996b067646f4987c0d9bdb7db9e211f346b2dc3f16935b73e40f7bcd0df324068a36cc129ee1e86dce7a5aecead9a0271c2880413d2a3fcc0471138a1db2d0f7ab38e1f3fba6427194124edf3c2218cf0c1913410424e416b4f950ef050b5f3f1a0c133a4dfbbbb42d037dc3a6e3574e757dc1514234286a664419e224646fba2a9f9449bc32b5733e27bb1a44397e827a52d2be360a777815ad7e7127ad221a3050bdf4eed266023d1ec90f4d53d046a7f729d587ecf8ad57b62bbe02a2624b26bec22ac6505df4a89d82009cc72743b2902663c6007ae2ca76905bbca103529464b1a45467d86312ee8ec5dad49f7b4ea156f89b2a0898bf4c23964c8c83ed0c27504055706ce018f0480de15ba55b2438148f14752b440d007a6bc6cd42b6478adfeb9a3c5e7e28a157f8291694e2ff6171ba190bb3dda9477edede2d670ba44fbd27dc43d58dbf93b161157c338a5260813a1155028447dba0b2e90bfe4ff1b5f1d2b5d6ff559da71ca1ee34135e968b40b149dce885787ff6bb0c9bb9ce262cbf0083d7ac2ac0e56ce6cf628ebc702db26094aa8db720e6f0479de33e0caba66da4461c5152d56da2c219977cd9efde777a8146e9d7f0859ac700cc38f33b9d81f23ff72b838a1eea20a3ab6b1968f2c2a04d4a54ad7f78d5b4f3a2d30e8b9db8e5fbb57612dbcb88bee549c2c76927d2b9a784502e4f0aaae31ff7efbdc57246dba5f8aff41c3456b56c2155ecf31376024833b69f126f03ff26b5cbd7df47d4caafc354e472eebfd25daea5cab22be26df72f5a6b993178207a773e8a3d2c7e850c7580a0c61ec070f2bd0ef2943834d31b437975becef282fcf2645a6a3f1f96498fef7b09dd5b4fe10a889ea925d1b0406d277a915b63e4c59406c98b70d6d6779b051226d6e90caf555766c8e1b5b1e2ba4c0d0cc5f8419884a318de339477bd355e21284f0666e51cda1d7a856af896c7f082f60483455f360ff23d4c830f9ba31bc1e4b71c92e235b99e27aee70082c4eff69e06b1673ec4fcf88fb39dc2835e7947d24359ca3aee7b24ac7f8b7d887c8bcfad5c38662ba6100e7e721b89e46c125eb12addc7d1bf462a173459c81a00a2bd679eed82f2e0c973dc46075ab999c094de52a749aa89b9d0a448c5d3ba056d69886955be71ee24949b718b4cd3c80b16bd622a3e91b84fb1b70ce91c7b2d414135de7e414a3ed66632eff004ace17f806afb4d9945fcbc640199b0c377361b26721e125e0de525d380798f44a2a2afa558bcd053f973de35c365e6b6947687530ce9a9f44a6123221ffad9014d5dba41696ad93f767def736ddd7c34633c65c198b372f923397d3cf16f1ff052c96181e1b6a595db5fe22d9ae5c8432ac4884f6875d35f02e37c5ce3f76b697fdfab80198fa3af8633791f07d50becb3ad5f4880f21ee94eb8d3a386658b75dc1ff34043f2fea34bed91cff618ddbbc83efa98e42d4fa9853fc709ea4aab14bfb906eaae5854d9debdf50b1d2ebb47fc3da7d1e2e069f802fc84a2e7ad930bdef2fd756e68e70c673a858571ac89d03aeeaa01762f73ca650a219a3ae7ab3184dc099dd27ec408bdc8b1c301fa4f0ec421bc395ee019bbc1857c3d4165d64dd8bcba2892b62beb41625203b96d8cab7ef8055e2cb0ba1d3b2eb1fc132cd2169e42a87c7df27aa76af1e96209d89362ef2e55e686ae9b79f7486b08261d3858e8ccb224fa5746d22dfa49813b4d58f2156eaaf664dfcb3199de04cd7071adb5b04c5e956ed71f7133c51eb10b187751a604945fbcdc6d7ad391a71ed943e1894084ce47597e9e9fb85b15af338c5af200b10929c8523aa39db1d0bbc357967b404cff158f37d1171d73ecde8232b3737ace607c92c4bae0db78d041a39338ed7b81ec0b04b898bfe91f9ebc346b6ff15b6a6a3cf535d71124dd557fc7a3405b67641ddfeb85367a322d7bca281395731cccbe3250a3dc69d0565f35ca03eb7074062de7ab910683aef42fe7e369112efe3fc19797f16f5151e166a30433c23a187ce0e4c4de5a120ec6d64895033bc8c6ae8d36633df72ad8ab2792017072c54c29b619f33ee1508167907fd8c86a3196a76301c68889aefdaf792c5e40f57e75b6b9580396743ccea11c2fd6e0b00428f4bdf8564c60992946b1ec7227406774788cdc507608c80f1eed5376f6147e4f45c9cfa537169653bf319bf71e872817b69494c5a186ef3d5904c84975539ec2be8bc1d086a23856a9361c0f948d1e29dd2b8e2948a5e2945355b2bddd07d77df830e0813f6b28bb6f14f3a438c652c6ce4da381bf3d6dc0a223f74dd88ff0f026cec5cee02ce076ad92779d4b5d5cf0813a4e0b6e03b701a9133cc73c4980c4b80d621065ebfeaa672de34c64833010550da63a31ac16bcd969dd3a6c5cd25abe97b1f697f40311aab69cf607aa2221da1ad02d538b26b6470aa633994fe82fa30062f1bf3ce8c6d72d3709d11c3c030322dc16b7551a5d1c18eafbd7fb9ac61fe61116613af5e821f0ac1ff0ccbf4ebea51677dd410352e08808aa901bece9a35ae64f6be35884f5816c557f4e5278781c629aae176e146456ff917f652bafb8837d551b07237bcbde50508ac4b01a4ed117e5fc130349408eee2d104373ea6c9fa5ad556807405554e30a72cdf8efd201e8b7be58c843a2c5ee176fc8bb9073471b64892da25a6fb149987cbfe82022817a175f20d86f0ef2f28b78670be435b4352098336c0bc923cfc3fe12249f348157dfd7a175c9c756a77067bed1db0c677f9e7a222e005058b1c44d273a099910253b38b103bae80b42d86c656639d9d69a5fdcd8cd4a57fd6e8e0c0c117b3e070a310542fa6211858a5691da9475a7e97c21a6180097f9b99052776ce8a68eff83ca807ec1cc4ccb2ea4112a990c81a74f369ff22d018a7fd341643813fd1a1fc8c0c97f54e5ffbf58d61789d3868c35ad1bdc2fae5f9764488c3816bef31c62cb89a666697e31b01dbd20b6af747514e703d52a6fe7e9fcc96610129c787edbf807fa95059c877265d29825a823d31d1c5f54a382d8d2e03fc3d968acbd3174e20a3d37d0d5de30abdd0cf518694a82d3d9d7031c1d13c2356a080c94f46591950fff84e42a5ecf5194382639bfac08daa16a0b698a82807233606e420ff71c2a41987a899fd37662cdf8486cd66b4e7ea470","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
