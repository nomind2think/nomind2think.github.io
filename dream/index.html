<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c158e689c6dcc1773fc4c1ffa6bb194eaf4a2d5036fd079adc2af4f26ed9cefb04846da018b9ebcd99b7f7358edf52b6331b5d466dfbce6269855523595a7abb61441c50ce629ca58ece47ed5114de307c08eb4663a401882c9e1b48a08e59a8ede1835f538cddae315bcbe2aebed0e1081190f854046989a71ab3e3b30a5ac507f402ac5b8a2d6aefdd4ee8d15bb5730d46e73ee75b8f90b763ae38b6ac837487dd11fa3d4187b2be44f0830ab89f36cccad808be0357f455033a3696c155127f9ac314b30cef5c0fbcef7ecdfbcfaf69ed59a0e2be0d88aad07378722e9096f0827ac65b92fa318e37960e16520ba65480ba4318e56b1d92bf96b1dc097d7161dbe05ed2b9de96cfa02860a78ec105000fc2c9be78f383b865be662cc42776ddf555f65c0ce56c7247c0fd37e4e354c1a94bef263972f5948a6ab7483dcc590a650c8c013e069dd3cb8d42a638d36340fb602ff59e1f3aca9939e9272d60a1ac5cb167744bc2a48ab3d4dc2c87191ae0a6a771d1f1f66460ddfe792188ecf51cba790c69ba99a90473a937003f2b053d485997134915a0f25d3fc4de6c79ef55c0c26ada5f20db5bdace28d822cd0eabf87d25b4bcc393703443575234f42a5ad668df7acbe27c3cf82c2d289cb9de890b5614dbae4ef4c55f46a2d00ba13697bece2ed6191445a016c2074c35c8d896f56d38fa4bbf4a21309c7455d7f4d15723a3147eb3385c3cdcaa74e376ae4062012f58de22f25067f9798ab9415a5df06042d0e51b8bf1fdc39d81d68ef35fff333955f8d36393fe6b7e4c1bca74a55d00c775f1e3a8b39d337baff23048484fd34f7c2d0e9ba18bec0438d630a32ad0faa23f9917d7a454911c241a3558c956ed800396a3481bb979db7cebdaa4f2db3a72cc3de7fb4f6896e45e4007ba72d41fd53eb9bfdd2c81c3201452a4d92644c357f2835fb54c42b220719ba4f035deeb2f9eb2b4678b9f89d043709fc4ee431ece866de52a18180939fa06311fe102e28abed64013a2b9861d666ec7b4ae33db371c06a0d584912a7004a1d98fa3c218464e2e15e826f1a56e8e83dfb12ef5bd8af4ae866a6523f42a0fe0b70ce70eae5cc1de5c29323730c1008e60e9ac68b48042021e1b0870fa77da1e361d2edf287fb363550ed77f138aa49c770119dc52bb2b2dfd8ab072e8ae8beaf0aaab2e118600dcd20f286f38b1ffa8dd5ffc78ae523ed81f4105f24b0d8046107b3a3379f10d10640b995179db6a49adaf7d6b6625700e585792731a7cb94dd64c9e3c0d4c03247604ead731ff4a84d11c1acd153e46a6f4a6d11295e44a14f0809865bd0ac0039d3ff2a269415946e3debb968c74c0dfe768f917d6c259935003d6a197c65d70a7658f9e7504861da484295549c7dbfb982f9859268767a8d092bd4db3e6ff5bd7e1d797c668309ca0316c626fe87bc05118623193d9d06bc39f65a53a528a8c9a03c23accce04ac8e6fa662a5dbfd42b21dcf663ade80b6555a24647b691ac130bdcf8ff0324eea7c08020732f71664350f7e82ba93b78169eab193554e3955a4ebbbb3fe48a832abf9f154bad640d24e484b91c135412d64d8fd200950feac66befe968fe1139dd846fdde259cea39cd93be595037cc674ad1bc537780ff9d392dfa4609ec1c80e49ed7caa8b1ba245cdd19061fd7eb20278853762fdb4013ea47ee0c2c0675314e834e60f046c38cea8e84f15ffffecd7767bbd3132119f68213a1724f4f8e5dea53c4b5d07f9e63c3521d0d453243c44f59a58a40cc7224834e426d4a52e97b6279625e23ff685ec626bf494764ab014940b9ec5d6246a75d5a5ddd2c78d10dbf1d5aed15121dcc218b0c435a193d1f3e02251ef7747b786d1eb096beda3d7fa927211b7f33bcab0f4bfc5c07814196bbf3f6091dde4eb767e9ed462479c5def532f0e6ef63c061a91b5c9746d51e10418ba4738c8a1b512e69717f0ed186905a4d2db9446158f953a6b14327e72b3dd3bb0143950c8a0bd122f0eb9fd3f2786d2cf2718a16d930830d6b5a296c0e2eece6c2ea68f7dbcb02592c4d3fcb389039f23fe84d5bf4f2d6bca87ac2fa6ebca7b107bd95f4a464a919c56a45285654b5dce0829202a820c61b108a77c96f471577f8f5d23c56064b0a6833982a562961ea3c6008e3179952c1d946258ecfb865bea8d7c045eae47a2663abdb8ea7fd0440c43a1e1c982263748134dbd28eb43a9ae710410257f33bfae8f985de2b044759a3762166e19c8f55a06ba391932fb7e9e9ef7f192805957285e0cb5472077d4fed3a5e5cc5717c0ba714b43b200a028773f7c855e7ea9d0bc675034e5d8aadb201a3a4b3eaa2bf3f3b685069ffbccf6b5678c48262003e982dbf91f6a3c5ef5a33d3df6a1db53f271e718ddc3a0d769528da56b77291905181da11985d6ad64a5b9d7526c6cf2877dfdc7b22cf847bfaaa29abff94b370f75d28f2a95b569ed5fee6561b0e9682fa1d6466543d08a94887555751efcc07295857ac808c1ee7912a33a67184d1cbafaa6095bbc6cbbcb52a0e37094d3ebc00d8dcc289bf8af7f8f3a8fd9de12792482a08f9c1be44f84cef132494967de3ed03ee539bbfa07cdc75594a103b946d1898acecdd6d32d0f139e94c01a937e29a27871fd6a82e9f14483849b62faf7834dfdc350acb4338c1ed84816d98b3b9810192ed2e050e3f5bc141884df49bcd3f143a1dfe085767543c77911d87a4e38e0408ee911d9beaffecec4c622e9047135b955f64c20ae743328cf38ec22abaa6d449188ac3766e1a6a6e9755c8c32508ab9ed3f29908fe93eca201c3918ad8b8db3e88db763cce6bbce250325f6624d0d36e1a8346e6149ceab9adc900228af504047c59d4389c2a346d34a449cafef37348c4eb39cb5fe29139e2428d08d8464ed62dfdd7e24c3bef831e05e43cb255612c26e9d6a307284151f9667675aff85e15ca7487889ecf546e3374f5c36aef268bc8e9a1a2696431fb9ada4f8a30b071b521e87c13112f9aaa49137f38d301ac52bbe421bdceb822f5bc0e84becefee8f065195d5628e9353d6ac79e555c0c838d9a82775be77539921749cef30921687d480a7e69acc2b17487d2c87ec1af46f9d5cd8cb3b747808de7123e730fad564b9b8bb065a5908e3034d758a530cbf85ee0a891b066937412c0d813123b6eef726ccac1cdeab8e755cda9fc30a7d449eb1f03c6544c04c84657662b9537cc5a2f3cd44a591281cdb7cbe40d37876728d79b2f474e24be2d9383410262671528491607f78198de90402614e17344d423d3769f8d4c6a264f164393f1a68fbb23c1d46ab226ab6b862b6679cae5d32f6285b325c9166e8c634c63a67ed0020286e33b4ed911fc5f8a50f3cdf4b3bad3aa341262469844e711d6652418d90910926054073a71e60e44f28936c9e8fe8c13eecf7e5a5b33304cc0c943f7fcdd5c4827f2774bf146cef6d8e95b102524fdabb33fb96a5bdc72ec63f9826a520897443384715b1e43b167db1e0881fcd7192997744f7b1212d7da6bdd46aabbde9d058a1b38a7b6ae13774de5741b24213266e612c6fc913a36807365e09d885b515642a84d9ec83156c8ce54d620c148c404a62217eefa13407f5014e17c18c88492e316b95561c627a1accad78d23a90af3d14107baff11dca11c8e2b735b065e8dbb8c59dbe10628278d64377d10aeac385668b28635d6d2a75aa8d5fa021e95dc1d0891373951e91e049529f22b59508fbf18a4bf23ecf65ca370f7332a7df8029756c9d121dc73721fdfcd4e358f019c46516f2eb9e09a643df9b7218ccf184de3adf08ab1ce05dfed1a7dc63514c178ccca04542299bbe22f7f2a9ca582e4085a47c3c8a476f6a65d39b676bb7ad79ce109b240bccb7cf01f920c3b1deaa342d87753dc6e0427be3c79f9dcfe90f5c85c17c5e0cba2c5e738fee68f89900b5a559bd00e8ba4518d163d278abc321dba0b934dbc9235c16355722bd5ee4924ddc5fc49bf3fc3fe8017e2cba9a8dd46ad012b7c92f01326971f830ba7de5d2c53b9ef4a3c7cca42cb4b397b22a867e2d01033c9e82b359a24d5b756cf43039dabb1582f635c7de5fc43689048d893fb49d963a87abba380ba0b605eacc4faf2f37795e170975f757b2c570c04bfb8ba6293b8d8e614fe3651273f27648c9dd8ccecc65b1b1eaa36edd5807bb39d394dcdfc98da714094ddead6af452b2d027decf47633a814a821d2f0a126291f882a4fab497bb943505ef1cc2b399054e4bd85927f3412152060b7fab420d048fa6d4ee1cf7ceb60d2d7f06bbd4ba7badf0d277e39a6fb56b24e4f5642b8aab2a802cd7ac46e72b517f7ad8998a89c0303a5a9f04a1c68805b8afa9e73b8c2730bdd53f28b7a0173604e073791e5d549a9fcfd7e735ef96355b60e3a14c1b6a0818bab98b024d8fb14df7c3a9443e02e737995c562908d9b487891e3ef6db2b6c4a6f2d829b47f2b600bc7fb3879461f5de4208550e494277c6774d1a1f0ed5552d0eba813ca645a4c8d4a738e961aa14368aa5af3babf3abc1b018c99c2662039f5c72a0faca226e89f4deae6331194ae655576b3a782fe71639d0726293a0177ab24af3378423c5062d955d36277843929bd126184aca50627062dd17c2fee5c56b2f394bf91137ca13b97a9fd3237d70ea8b0bc0b17e75ca6c9d3f5004b4f92cd4409d598ccbd0ca05c9f3290db39c2ac1a5f9d3b041f71d06173ae96cc1f07c106d8e0fec7539486698cbdbb64928928048e93c5cf57792efc499c0e8ea6663de6c75bc2eed7c6f790b5a5a779af997aea929a83f4fe7a9a46de21e2c9e8e806c8a3fbd0dfcb8d3be92dfb3a0f47db30a3836af66a9f4b87b8e134ef119fc69e1c502bd8475c3b70cf860c4ceefb9a20fdbfaaa87487e05ca6aee40c3550f8f6dafa273f85964462bca657ce4d8a41ce9e935e2d98d35b82e3c744045d3c53dcf554d192ca7a023b1bf7bdcd383861dafcc0c8a38a8dc3006637778a1503c8ad6ce9841eff18e57fc24881ee08b2ecfe356644da25d81d477d3516ccb409707a587d0788641f3b496bd50049ce472eba8224981174ae12172d6ee9ee1d99c1186b69bbd800dc1d8d3c02aab077e27cd3a7f0bfd855c5976c8842a28758b7448f7f48d864240faf555726e5b6aa8716f5ba3dd8921c7b43c0b6a1e8ee73a0fdad5b406838ae10974cd9d6d4c296a9e02fd778abbbad051bd367e30aeaffbab26563616616683c70a1290da7b0fb5726d1b0fa49ba35c27f8b51d59e667f23eea799a5c13adb635e85cc93ecca60a82a4bb61c871870f0bc660aa85ec7b5737d0ed669957d672359ae465d02d4c580878057e874ba828b42a0489bb138a1b62c50b39559de51e82608c2fcb7e000c90f937b4d905587a3a926ca49555d744aa3ece84a8c84c565e560cb107dc6a3037f2a6b9aefa9c45bc6da58d0740f2bb021ec01d0ade9ef7ad5ff05a0bfa1adbb4908afeb00a46b07a9907e8ce876152e60d1e99502893b693fe0b427e0a75c2875cab00deefe2f9b00f2a8dead705f5c6a145e879cb84d2f613600f1024f762a465872568793259f23913ebd5219eccf5a7d10c87338551ec3b22988a4751d83f6d1dc306a7383eb40d721b4425140e254e2ecc6f944aa38c03ab0ff4721cc636bd7128cfef8a1c70487bbad5e60a89a615e6c15d99a02dbd4cbcd17ce1aeeb98d7495bb6487f602f3049e7f72c2d423a42537e322423538ef18c75174b1477a25bf422abc7f4687f62a1735dce89ddd6ceaa3e2ed0f4df848009513f752e146c94cbf5bf801369fa0d248ded80e8765114f59fd3165a517d04fcfc8a8a4e5c9303df5668803ff14e33781bf709714c469f414493f24949d3f11c12e16c1d19d4a52a89126b6f8e1bbd531e44fc2f0bd92c5012e7a6433e60bdeca8933364ff3b6b91546cd20a86c712ce23855562eb74f3143a112597b388fdbe56c30ed61648c6f623ef2c443da27637055525fa54c911cae2b0b742864eceb8b155c9ad98faf64d803131ff4d77ce561e90f1c3edcb90ba19cf31b5a1298e414f4cb39367d950d0ffd246bd1e2b77a437a2ea074f1523fcf3c7e80fe725e4e866805d4bdab5e45766533b075e07720de5a73c671c1cc83896404a9a823e4533f8161944187e193fdd9312dbffe0563145e533f6c9081a2d82e9cb65181cc5f1ad350f2e50429bac4357833efd8c05faf9be2f729de415edb4fb6fe73072cf69d0d4173fd6e2aa2e8ee1b1cc06ed28e80d7b2eb431f8feef48db9c3a44a84b1829473c367bb77af6f387704ccda29107e7d98a9ff6b39139eb9276de4df80ea27288cba3e6b744b6529b1e441d7f5456cf5912fb59674dbd9ed8a4c914ee923a30484f8f8a12de511ef3066168c6d7d1cdb8c27245d33704e064ceb9d9b312c016d02c94eb2e03dd94265516f5f5de775b2a11f54c4c9ef5eb8f7ed1c7c076b0a11a84b367363e80c2e506ef50b4a8e14945425534135192f759551ec665ee1d1f30a73e2f626fc522a0884bdd88b72d7a02e62c39a91e53a0fe2770d146244c8a2d3a4d601d6eddfa91f85be95fe8bce53f42522eea56c4e67aafa5ae8538b17817bfdad34a844d4c6f83203d48bb58cbb17141a29d563afd94453acc49846ebba59366bc55d20d0e50b617ede5d58dc1b899a49677820bc8e3df016d91c2bc428ed6d8522e5b9cef57c68545f4ae4a464b56628b5b90bd45245bc28e758f6d330e36bbd920de81f9188685fef15a86a1f65aa190812794f1822fe971e672852684470092926b2e7567b475fd81b108ba67c62c02208cb07b93d18284065b6e06dc7f81a36a033a5013db1dec26fbf2a0c78ed182ed1c692937a8188661fa5a9802ca7573b35abc39b6ac5103fea65ad2bbecb39c837f5e7690f6fce17ca395c8ca98d7b20909af88a6cadefc3670b91a720ce0c97fbf1a2929c5eea2fe356691de4ce26a3578302902ff93911bbc7001759d7dcb2538c215cc9ff4146505f91f76801cac577b77182016a709f599760a1023a7a58b26d260d4d9d906ebfd831c0246a6f529785f7ad097ab81c0ca281560b5f6e667f52caca18a74624e9c7675b4d0169c5a90e31df9f8734725ea20e942c5bfd531b99d47c86e3ae982db13be2078919d45eaa135cd1a41848cc30f32b603d8905e06cae6e8c40d966087d23309c1d2166bb1db221dac1eb0577f07527899e4d8aab84b7982fe85f0972f2e840631d92e8623bc519cd23458710bfb398912b192ca5a9c241382991b290867c1fbf444d66720195880513325b48652f4614a4742216104403dadbb2f92e4982c92328dcb809e8c161999632c4ecaa50cf6be1258f96cd1d5a679f0d0483fae12be15a3b982a95208c236ec5b03ac7dff4beaffd5ea6eb17fe9983c91e371d08174620800a730319383337f85cfac427f6b05e3241d41b1ef06404a154749caa8940e07b03bcb3125c3dd39bd0b3116f60114c16301863bcedccd2277bf81942c9f25f45b37dcc79a81459bc4d476ed72b432cf5299fd19f03b09d6fd725e2eb0dfb8a9e191320d4463415345ce0a0f84687b916c692930249c0c8614837e96eb6d5c01cd1a992c48a484c6321d9a16b033a8903419a25239ca3916ba845b38edaaee7dc77747508c7a59d2dc5684041d805b6198f694358213d4850f094180cebf3c484ec72c88fa8ec7634e4a7e289c02afe31108e97d4d84cbb7fa3646dce9d10ec9b48630b41aa1e0fedeffd5771b335e708b51e770d173c9ff9226fde5104460edb836c22aa4316b6f416abf7e4d7ea1e80489a2ce3437e6051da653c360b7e34626f51d997d902b017f78de144fa53ee060eb7715963f987611d292ade1d9225acc933832019a852ab605d993c310249fdf3632444ea0a11286e553661857960d9575488a31615712c7c321d7b135e8f14f4c1be727fe97b09d6ff23bc2467883eda13b7a02435695099cd17ae1dd263676e840bd97cc25bf4feb6f1370f3f3058f9b3f3446a37920ba416f63f57d5ad2705d119074c090df10822e1411370ef5f9077ed0d26a9e8c556c238b42f99508310d78cef9d7a18016680c0a945f133fa5d258f123dc502b6080b259b4da7e81cf1a92df0d238d88807656088ca12bf3a5be15afe1d760b534c39e8c3320853da2337c44dadb0ea9ea2d9b2dbf5095813a2d072eb6070107739924be2e7e5a738caaa657e8e4f3e4c2a76ff71901c2af60f72361575a37e98b741dcd43fa10d9f80d0bbb18b45aa349047e56edbbeb9221f4f79e8d15c3aa97173bc5b558964c737c080784e42fb28986b6a969fc5e429ed953579fbf128c9598599374331136162cf42af72c73344be11715606ef27f88a1f88756424b816bd6d77d25510e6ff1cfdfdb43ac95048155792ad926e40825fd4ada5dd981edeb1b75060ddb03c09b9d65379c595faa8565bf5c9af3b45bdac3795a03968e5de810c92970f54f5aa25023633793b9379d8356bf340e6a1f7b5f14c63266c9886760ff1b5cef09d43d75567173fd8ace7cb8bebd30167a96c73caa002e6d4c57a9f301b1d3ad5baa9cbc7a7edf38698c1d6c17a2c4bdcd92fb3d47556ddd3d8fb8c25d0a49fca163e966b8c0aa00b5e744beb7e1c3f2df632e9ef40f2cb58f0a660fd4eb1c6d8e9bb5b8dbaca77a8eafa61a3da12742e8ed410d8c6d33b6261e6dc5b667f2d718dcff1f72bedca89e0f9aee90bb118a22b91b92092a079f6a5343dba7f28c7145033f37a79b4cdd2ae065c501d54d645a0cd2e933d8896985b26f7f36e9a3bcdb4153075126f7919dff6c9cd20f116de228d351b3643ff3dd8ddffa430bf46d9492dfe3ce4257ce6b30e40ce5ec7c3e5d6e18fe8059a8f0cdc0cbdb3d1e61dca3ae7ca329ca0d5ab6b02dcd76b0757bf819a72b3f72e7e2e8377a47b8a6a72d7b4d9749ca0b9eb1b7796c68e6b7a4983179144708c93ec96f29c1016bf793f796b6ad3bb12338c5db16857c47b206c42534783ab61307bec9e3fa5b94d1d7169130a9f436ac83a2dd364bf58fd4532e0916ce456d34fd590c225a5d953d34cb5d5aec746ca3d7f5894aeebdab8ea22bb0023ab0b09519c18bf29a67358a946c640149fde04e7e01db1e8fdf638678064c7711a4eb4c9520e60fdf4651bf9b10506b19055bc1c53411e43486723345750b8f1631c5b0ca69e058c4c3db9fc493c6d8ad36734bc09fb3bd3c086092c902cc14386f8f3073ba85d6d8ded0b3a4d2b4317cc4e3f173e7034bb1aa488e6ad92bf35c4bee01b5384fcc84de14af3370aa646b27bfb5b9460f31026eafd59b5a4460185f996f01fd0ee3fe88d5e3b15da6cc13e28d535ee8be239a78c942b4873596258220d3eb58a484082de0a2f8fbb5e909aa9bd1c44bf90f52dc1344fb7f966e92f03ebc81b2b2aee3ee352255df6aa9b4cd2d2f1c004deab5009e1bd2b90237e37662280c67ee015b40e2affe4b8a778e6980dbb6c08cbb559d805f2bc00c5385ce0f8ec6de5b97050dbc22d0868aa917eb57799d825918a09814556555c47fc5b804929082a40c7b8cc06e453b7a1077e8f2d3a512be628ce96cb5a81680545e9517667bab24b0d6f9265ac76f9eef4063f1054713421144abce85ce5f0796460260a4a20b46f2a127fddfaefd79fbbbca47dd28c0754ce2f99f9767e6744890135f7a83771a4d9e356a99b8f85a62cc941151736039e04daa6026a148c2c36a670857cbfe64801372b678bd0695db1c0b7aa0a1d7a6a713ad5a4004b3b80937710025801bd7254e04766999e94fefda17f0e32c47f8d1c6a46e3fe8fb98fad377cdea3d6bbdde9f96612bb0e8d516efd77fd1d9c3495a02d56e43b875d513927ae4b3a5326d00a42c50051d2cd0e3d720015ed3daf0889b98ef4a5804a651ab7c3e6c8287027c0557544949f55b5563ec33888ce469364b8d36bff33b7bbeffe88ef7189f8fffd4779abeb8c7f90f9241a93ddc935b5e41c44eb71025f0916ac3c9aa4de7a08f1cbb0b90524ba96619cfb09d98beb81a1725c2930cd89f473e978cce129d7ff0c100708e9e6e5a45a15a335bb95c4cc4bdd8f64b5895e9feab6156dd5dd9762fcc24f6c1b210eeb66051c08d09786bef08d6699d8db5aeeedfc685c55f571ad43ef48cd99d30e23323ac7061871189accec9d68398d1ad648cbf5977e422199db5fe4bb74fb36446d20843cbf482901b16319368aa3d794d947794b7566293ff5b518db90c2f4c94318def5e229db956dbcdc5788983c4953c866cc31bd8e10fc45ba2c44cdf8b25377442ef304fa1206fb9509d950835cda026888dd0059ec6aa8349ecd582638a2852eba7d7742b252ec82cc097184096998779aff27443839dd0fbc9735cf512c062bba454d92ced972e70655968e1d81505cd38a960a4af0b65badbed0223b908af09f502ee68567b369073358bc281bfc8945a39bf5c56c014fd47c34c0ff55a8dbf1730f2d0d8bc24f16e4d68ab21bea09b1df19dee6d0e6d9b1e0c66c942b89321fbdaf77087e3102b64f686dfcffa14c3e6c801ceed5cc2fb41166e168467b15f17b440f0e3bef1893d5fedc24da9d6c5d273a86675f25931d5e5378e2a91956f48f4ac957a0947269d8c7ccaba4ce062b4580bdd35b575a320a0355170665c1cb52f03ef57b6e8c54ef3e9ea6f432041e92212c75c647006412e369b0282702d05373e451e6b3c19b3f4a8f241bda6630830fc3cad9443f9fcc2ba3af70dc6ca0094ed5af0332a858c37d71e91ac34bc513bc083c1b24da8f5833d410ee79c9468fb03734c1b1be0b6d1c91f559bda9162b4ca680f2bb12ef31207faebe33f290699c3174145762a644d352d56b4bf0f5b01a5e675629c28b834ebd3d9bfe39c18dbcf19f022a9e194b5b6e490dd49a7f1a402e214c18b6203707afce0d65d8328ff476608fada8a49","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
