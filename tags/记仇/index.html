<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf97f2b48672d8bddc507ecc93e3cad6b4f974f15d4ec3a74cccb37ff9bc48f3ce376f3d8ebb40bf926637f40da304d1a7cf45959f7bff2793a1262d05d913db935512f32c040967874d56378019dba7056da1ab03e8a229a1da03b944f12c9668c2f228e7a9c253ed6c36a61e0aed38a43dacfdcef6bba5bde3e485129e7df74ee235fd710c78c5639b88673f87bc10ef035671f85c4612e26d0c94493bd21e46416377c744be8999915ef69a3753372ba7db06aed01427b37ab7f6bb904145ec5d4b2ebbdc314821bc23e49d80cabcde254365eac2a96aaa390d153555e0a12dad9ec08d1abe7ca380ff7940edcef34ae12bffbdb7bd5b21a487d1465be1b92d186eb8b161e4b9f6e7e1e8140dc96775902d5a76b3404650fdbb811b336db5337f51adc0490d79ed48a048ac20c4c03be8bc8c980d2b495186a24fca99d60b524f9cf397b033cfd8c415a729148aa4f1cb5a33f8eec706ada40fdc6ae1a94a352c096573da5305834a9ff35d251750d8f7af977d05ba99196ed44738dd149b05a6f78024a47abd49baf9395d75aec15fe687597763e760c4b8454de4358fb264552946f121d43590e3d4730b4119464661849ee1051e77e837af11ac62237a259c4def7549a4b01b7d2366b4dbb80a5a5d51563748be8e6722499b8850507ca011121e942f978414b664a89718fc6a9952a67e73074bb19cee2ec1ba66b377fd2dbd3cd41343000dfa874b7b925f4a70e43cac9cd93751ad4d131e77984bc202d0557188e7db54cb264646a164a576a588803d7627b167529ea602b729966e23312f7932509ac26f6aa3d260b049aad9b4b3e63b7902095a5a3148f071de4b338c55d6c819c0f068a93243281216495ab20a2b86673708434d26b78aa6a786eaca7d5cbcc1bf0477ccbfe2a957c31cd5a80576460ceb8ec0e822568ab3d31c75beb19857fcc1174b6a974ea2057d42e113b359f90325f06b98e50bbef459c37867318f13aac10ad522d8dca8b2042306133d0d7130a868a63b3ec9f946abba9954cfbc3fadd0266e432585484a71e8f47e0d1753b1fb6417d9b8f599c1d8639be80e37ec85f4ee53a2a25d095ebbce39b4875a30e3dcd2b23eec2c3d93655bd6774bf5ad7951bd81e371ab72d62d3e0b7854c4da0424a5582f7165078a1170bcdeddae838ca9a31f5dabd37e9788f5bb0069cdfd50819c479ba68f3a92e7a8f8e746fadf7641644d129cb9f0ed2ba89aeaf12496a61e008246c19f25a236360388563ac872995b345f2f2c9f5d24854605a2849223b7e37b7c3b5421d2fed51935299a993e6fe86075d188ad8b963a3f6845bfeebfeae92a9e151b53d8121fb13258e38d68b8811962d2e3ef3d0c3edc462bccd694b65b208a9e9bd8cb0ffb666a101e6bec4ddddff88c14e70833cbd6d1f492dcf8a2028d7c243a73498997e87e5166fe1363dc24226bd2005a2d7780087e4260e9931f35a320a414e50100c7608881e6c53f22ebd6804f6fd2fdeb411e0d3f8c5658a6fc086162ca4dd5bf1575fc9d8c65549860b9e23c2beb0dbe225648e7fe037ea8473726f11fe66c9b9adc70f8776ae4cebd6f39fc3be511c7089a89dd9ce7963119f87b03dce552ddefc020560ec224373816f5bbc7440e104fb52f03d1accd5d4939e9428d2e41314d7bdd71bf685be45bcf6bc38ba9945deccad136169e3c6b508663e4c066bd1a12f724da42818be4e62f1acc37ae2407ca35995ef273b241bda0afa3a1b4c26a5b0d4f6a061f2de5e672da3e4302d8570d1a79cbec4982c2e721cae802865f6910ffd815f7ceb0cb797352b0aceb24a4855adc0ad87d4325439c0c6ad5705d026982978f73c2f76cc580e78e003b7d768e1b4594ef873d1a874ffeb323ea4e1dd10e60dbc7db14a6dd145c4daeebc0f34d37c792f15ebab58c91313a794e935b4b77d80ebce4b229029c42e26d71260e80c795c87360abbdf393500350fd3de18bea0fe916fab5afe54b8b6d77596555fcb2cc0bc827c46bbdbe65a8b93c94af69f32963516f940b068ca373097a8edc67d6e3e91c8568b3a4bb82fd2758d0383e9161bb986e1a7f74c64541b78c8a6ab745cd180d8231ac517bd614748330c57bc2c8633465f7d11461b164590f9edf09f29a72801d13b0298c2a98e677ab28172df690b957e9edff38c3c352cd78bf4009ee1b21473583ae35118d0683f527a6e2974a4744b5395a7cc3607ebfc0cbe68866b4e58f89ce0b321e3eac0a99dc08a6594f9db857308c31269c4269a2e71bda3581984c61404c147d1d49b81449dfd8ef2e2a16e4cf75ee8a995481f980c365f967e1ee901756254054bbf9091bbb6404239ee33dd1a10ec07abf4729b87677a508ec296d938b73d41235137fbcd0f5cdec04e5ec87d2551a46814ad3308b21773b3dd23929dc65d2796ea214f7759381848476d1d93322ba443d271479b8381edfa3c3cd497c489b2cd9b3a2b41e6d8df4bb33a494bfa7b1831fe5f4f89d302b6a730830fc4669546196319b108c18d1dd90784943d2e763dd4e285255b322ab03f49bb4fc8a3a54df39f8f7db761a7c0352c71b5486cbb14cac7b8e00fe4f469e53838896e31de807977862f59bd686a0db69825ef89046c05eb9ec8be2839afa7e544ec19bf8786a9168d89d269854be7dba04ecfa46c8840255d1349c30906ba023cce35e080e55d05a776b6f54eb8d0835d98fc9e415b9dfb66e29070814d64b87b990dc5532f1eed1b1cc22a140f5d9fe8e5474ac38e179d80be36d8340f5fda57fe11840c7af9b4ff101b4b5b69a9d5183fcb19c5dfb7f3aae4d24a05e59af0d208bc5bf249c9eb2019eeddaaecf9f0711f6a386d088451635d6e40f78558601b6fc706384328debdc6ef489bb2320be1b4e12bf3310e2a90ff8a8d6b90aefa681d41557cb15d4d784556ddc0ebf47a5ee2ee24c6271fcf443d1476952602c726e0f68c0e89727e7d7ae7d3cdf1261fb74ce5e15e63b09c72056b0da6ae35bd67f1d57be4a92a270ecad232ee043f9efe8c136fc037090092bb8e92778ec69040a0985a932810d7b27191eafeab991718a35e2408e10b9ca0688d29b6f84ef41cf0bedef46f5bbb476091353e13cb40495050a47c8b0e548cdcbec1b6f2efca2274e1796f9d4932d267c5d4cc017d1daee6a3c535500e0cfdc9df34356413ae9db02bf8407c4ed543d28de52a1f54766e0731cd5de157419a155f50bba64ca729855184fed74cec8de4ee7ea88dc9752ece2c0f4f8e40e5de09f25631fe7cfea1b7434ace76ab0b86aa70970c14fbac2ba7670bd0ab8cd394032a2231cd8d55332c713bf4de0c70249761e9a8728e7d1832f3a31e4a5bc5aac53fe50793075c074d54860408fdc9d608961b609cefa599b1d705e94a4f2d03311eb63f50fe0f2f881bff6bd4353f49c57092a0f2497a005efe18980eeb3f0d7242efc0814d68d4c9cf378eb91cc8e74ec6b38bf9af99bd70ba4343128d60b03393550db56f2d1078bbce592a90140f51bad2a7110453288720e182c49ca9ad243650b024861f8d63c8110f30d8897350eb6a72f7bddc91c888097f405c697a59437a6685939d25839823af58e1d78a41edf11132b2481a08a67d32cd2c62b00010f8d8513da87e2e00f33a17d4dadec956fb6a386ad3e55fd2d86385f2f4542cafcfdb4540efe7a19449f1c43241e68ac5a604c01c49341af77f56b885d638e938a3671a5f91605bc97de480c06c783cc4d0a159e17364ae577683f1e1ac8cda5e8a9b45168edac4db13dad47a8f1722fa0ff0b3ef47c7e5fad635f378c81c0bbbc0e5400d2546029a72dce74f8b14993d89a5410596d3a809d2b0d142fac06e674c275dac9b2d1807bebabb5ecc18ff7099919e901e693d384eaa9b61cc281c63f16bce4c452b9f27f4b309619ba431e8f90832195bc1900f6ec28a31670740126be33b2af60def6d813ca4276ce73bdba115fec1b080a1b60100ffa3a6ce53824553516fc9d1e78c019caaffd577fc016d98bbb3a2cca40ba2debc6417c9771a1cdf3f9b5cfa93ab4feb1c12999fce4b781a9f6a06fcf6ecebff7ff999274612dc2ceca1877ab86319ea3dce6974795e20c87848bf4c6149961a062eeefbe38e37e6d8809510231047aa0da5baa11bdf2cf232c2e34d488ac47a050050d20fb36ca11737771bbeef65d79729fd3f08112b1d16b7d73b0ef40a03150b854c060a53482234246457f061d78252355abfa039867c273b66d251b6df1c0d5dab4dfb304bd4170acc71be4f601c55e0ce5da3d3551a5629055a095438fed0f882556b7060bdb5c87ed06d71c1aa40b014372d30df56e6b8f132506fc669f7b3f8a7a87192592b39e5c8ea0f5c3b2f07ee1f7676c9aae739e19205ccd12920f11e8dbbcabc2192954f368e7563fc74db811f00e12670d5dfe39e6e1ebab605abb571e329abc6afbf56f67b319dff58ce3ad2320d103a0f5bf176dc7d4fbf33be21af1e281529b7c026d67e09062ff217027d039a2a6ded1fe1ba3fadadc586c6844b176392496a57fa717a9a64c91811f926f5f6628c9d34647b3f0decfacb8857a1f6c6551e081a722dcbd2503cce5d8e53d4c9328b79ccc378f6b86690d19a12288a4a8f12e44bba837184ed6e9e18a9c63e04b6542b2a60321fc5712a8849afd9aaf04fb5c89c3714d7a8c506ba377132864e1afb20242568992d81d836b1411e828f0aea1e2be01293e0ff3f1534c60c1e5d03aae4a43d355ba90cbadb6043a424c8d5905207659582fffc3ebf31d34023f01f71ee497d1561245d8eff33b9f071365d2d68d8023fa2fdedee0d1add6b4452350f0f553aafbc798c4b64030835bf553252d322206d563af6ead7c03aae355b1ebdcd0ef14fad223441b96f96ba681abc87681fecb0e0f1a8272c9db007bc67f580d9206eb3d02d121f3561f8593a5dd1a8c2f6398c500a2d459d212ea177b0d498d2f841d7765f3f61b762e7a244b77f4db8a8e8c1e1a2f148d3ac9df29ce2b4bc448f6a5d35ac056f09e7d0bd459cd7596d3a028239c03ac07168a062b4c66c06f9f9942d530c432dd942e9e860bb9bcabdbec61221b882e3a39ce6f2e01adc8adff8c9035ce5705c3f2113d3e7975fbc47444ab0f75159d6dffa7c3759e70cf1cc860bff95784164714aac70454455f1e99aa2d4358186eb30c4fb2418fe0f2705197f216c1b5bc5be7440090e650d38b3b41f643640d334f4fc0179cd201131abc94607f11c5eab9d14053499a763a83837f89e0323dd2ec91fb8c0394670b8ce41c344e834134d02c2707831ab85c4ade531f1ad941cd8685f684fff3e00fabaf8a3d5dfc8e91ee1961ef4150f2738b430fc5743c7c97c10fc4019bde4293c05919eb46285ebe6ba8891f06b70082aa9366f1fe3fc4b34958f7ab91cdf996da0ffed1b08be8763f9d610d0f72469e799f1002ab1b4439d05469662863e9f7c69e4742db3979416a6353f621fc502c8ffc9593f0b23b110b2ddf77d49a2b72d3d8808206bbb1db2dbadd81e44faf79ab0891de21b28f8808a8197ccdf4c46f0ffcf293a0defeeb1fc673d5d8de511b627c347cf2b90a42cead9eeac5c1d0fb9cebefcf06b6447a85d9bf8e25dbf37d910b80b7a2271fe716471fa963e662d4d18e293edf68b4a942583c155318a0c4603d42dc01c4bc158e49af3aced9903bcf2e1493b070af730e9a763db43eff246bd20ee78584c43ff0cd5e79ad38f7d1a42df73cc1b5ddeabdcab29358934309fd8f5f4266b70639f29d1690c2682d985bc11f7ca6ecccce22bfa64c8b0b6c4736ba33fb69e45215297a1e14dcb469db6550cf7f67e18be62b257a2be96a3b276d1f552d5842041acf1deed885482abd0717de0bef5461f42985cc3ecf7f53d55e439fe754c15fed498046e023206dcb9a927ed6283ced383ac50128fde1d56e8224b99c95bf3e440be058b4140fa74efeca8f3f9919300b09010e4d65334b0b97004a999bbc199a20821393be4141fe28ec6e4289e914f1c713bd6ea866c8ec88a667d486d24c2cd890fe0e9b99139a2e96f2f02b3a0e7cd9d0ef58d3d11ff152cc09d15258e5df16a7811b1c9376c012146b9e00e1c779c1d1697fa3e35a45168d6f8df0acc20e1767118643bf036dc2cb51c88d2792ee942e494bbf1dafc86d87a069fa83cc312fbdeb892435ea38be4bdad2ac53cd0681eee7795277fd066e35db55426d0c2d4a12e3a61fb3475ac677b15fabe57e027f143a96c66e7901633c5e5ca8e9afe819f8e3738134b687c07be0f977e8db46dde27dbcea5479ea3c245517d28c050fe0e9ec0a4dc0323498bacf176294dd22a00c28a1771f46fae8ea08f4f060a453de3b28251451ebbae74190dbfa5214373a50d79b2f3e27aea020b43e7ec8ea40903fd03ced7c41995491362c65e0f72eb81442e6fd427e4b7f99c735c3c8f34a6c589a1081be0d46289896416cf23e77509d3967d8a0b18c22b7343893b18c5376cf900b247e5d0dfcbf22b3fe41696978dc5c8585bea04f060f2f243d3d0dbeac0e9c57920d2457184e7dc42b45bca04c3f51ac484e6d6ed752c7b7e2bd962bda7a171b1650515284d5c3f700a5a7e5aa1c79ca3c8d3b186be51ca96fe526aab849aca34a2ffb68ef0ac15ccdfbe215d30efcc15f71b4e16d79d247ba63324ff41526762ee2786cc45f689f40c724c589ca749a350bf2ea0dcd49ded604ed50610b48d08bf028b2d7ab0dd6d6dd9a75b464354e5fcf92920f244775abffb85cb3fafd559c5817225c1c31b7ab706c48fc46c9f2e20ac534dea426948f91a8c4064b6a281864956dea37aff4a8e4e25c55f43e65cc51d8920a8fd736a114bb6a6cc08194b4def211c0b2ef73be67478d8fbd4a4fe3c7f25870118d24afef509b636fd2e56ff92e25586454e0d4ab8922ca28c3708fdd5ceedc1d2516d618ef68077c6526e2d97adc141b57fb2089376e4b0510f1370f8e947cada59176c600e2e0a85227d414e21ee54ac7ec72780f4934a6e859b847477ea530c5c920aff46b5e6f9a321cf65efb59b73f30e24ac0d5b4e9a48463cc66e307fdbd3aca1527a418206753f02eb90ede0ea89a9d609eaae90df452dd5a2a2cb66dc1f810a8915685384465272d2e33d5f0a0261a5a153b9930a24ede49e501b240700dc7938fde303a32d7334ff56fefee3aba3ceea4db9d3ea4e1bffe32a60926efa44a3550122f2d5a493d8864fa722acee278886cebbd3ec10882af7c29c51e2e4f1ea20f8b59b56a3d96bad83e8c2fd6bc17dc83d00add953aae80b674c336668b3eaf8942cf2daf4ad5c770a436f27d564dd41396237e3d4388c937d7773946fda3377aa20486b7a5f59d1d35939abb2f094a72f781c5e4ab932d6a004361a5509949bb1f84f5c3b9b55bcd15801357025c21c3de2349bcb06c4b8a96325d1f2fff65ee984c011cc89a48682e37feceb7538cd2c566a1f4c52646d886ccd15e920914554d5b5b15b5a3ef4f8e507c72f1d4279bb656dacf3ef64827d9c0fbf599793d800a4203fc3733de54107324d1e25a5b69afbcd923634a867af2fbfe8001d2c9b0093619d4150fa0549da0b9695e63ceb53b8e9440e9a78ce3e1b865d3aae6dd2dd4d92e48627cefaa17b0ced6a3eada252283413604cdeae81cc8a856b09e949974958115b7a7b7e89947afae5f951d8a62214f886d386ec464382c436aac3bccb20459d2b72a2bd087b98ce2b8bdf179f502d57fb44301df57401f489b2aac2554d36b7246d0a365bbf2136f96474e874d4a6c06adcecef82b4bf08e81bcf1a06fc5e9004f395d892be1133e6a152eee852f5934ef3519e7e2bed48f3f0ffe4fa10f79fa2c809e13527d250b7332fa7dbf5929e349ca808af4d808e4736443fbd2542d6c8fa74297b7ba75e73d0d57a144ecc2f85b8e5ecfb48960bf9c7add79c69b451c0543c176ad7084f3084d57d0ea8b64e215ddbc8c19b92328d78ed5c6c100200ece9c23d57658c36ccd5152650159d5ea17dc752435f642e6dc949f02139d63c78a46fad08eda0c5aaecd73a34aa6bad24970335578465d86ebd33a1f3e79a3b5877315e9e5208131916b5f345c0b8f0d8bc4fd167a302ce34e1aa1b4d809b6ac3a4d5710218452142e83099b5d8bdd5dc504613f71f09edb333f2e79c4095a349d5b7a3084159e8d7e55df81070b045ac14d3c19b99273ad3bb02471efe288508aa118b553e60d2ab40a571a85b7b38f6af5b6a37aa8b8fe32b441524b20fa95ccb3623d73232b6321ad8219e317ad1faf5cc44f2f20a1ec60943e8129c8b6175bd8a699f0f90000f5f0d163707b5364c7762bc5b9bf0e12acf82800e841ecfb24a6b61e4475c842c517b5ee7c6a60c532acd705c6522ac187385afe636f6cac11e080d37df8e805e96c54b4cab299a1fff5a721483811f199962ca3c359c8f916c533525b8dd0468cc6e55a8a56e4c61fff6264c6cc7595913be259e6a37e60b3f4aa1039634fe1d946200a1d5e92f7490387b856d2243896c7756288a2de6ebefc3ad633772ae2baae2b8aed9b23a8b536e7ff1ae92b8abdf6b3c652f7701e263dc8f85b4f4a48d89b35e51ad3f1209536459c9eba4a7a774ea11dfb1657f8e0db425b5444fb002a88d44adeaaa5d68825018a2a2f7e3d5f42ae24d479f65d9f45dc4893974d9d385485b0e03e471eae2a5de05390cadd26724e20f0b02d27ab9d158e069c6f6136ab5f96e14de649b3528b744c716be9bbb283d7efd79ec546bebcacc12ec7fbcc534ba0c75534b71b11e36f6e27739079c3e6e3d40e502e7d53024e5be7ac55a53e5a95b9083efacab027cc017897e2a2d20066c5a4e137d58dd3974ea14852aad2c6fa84dc7e91fb9eaab0ef3d1a732ed3bf19f89dec9c8f02ce73baaf91f62432987ba1d6ba30f52486301b0a042852787a731f0053bfd256d38026df324a4b46b741ce3238df63d18724864a097222f51aec87fc439a5d0b0a88e1f613ee66d888ea9abba1ae66d5d48b9a4f6d2bf9eeafd4b3b59b97594d49d5fb622ec9eec97219ef84e707c09f5813073c2864eedf33820a618018cc0649a143ef9224fa94c5bbe84b14bb068c4e540cffadef8644be35d2ff93c3b72453c9a76d42f06441daa3f152a6d8e18ebd45b07d1319b2c9d29012c7aa6952aeefec1b60eca93ec47fc0eef82b6eae3641625cb402e89fcff22e86c8bdbf9a3f62afc57e07582dc71f2caf9363dc620ca905fe82ecde434075b72b2571d0463f747e516a950e5bdbcf8c3f82140d5f312129b0f0c0f48f0895e072db82c56ea62fa4ab2e665c1e9410cc5054939f110d535605995d874a20b2246730e57eafee5d64beb1ab29187ae5ba124d84a78f9fe56a80ae829cc59d7b1b9f8c59e58d9b81d41461cceaaf704730a3fb838ab05b46404cc9b2b7ef8dc8c055c296c639d0072e7abada7628a7b2ba1ea44857e044d6f437e8f1ca69d79f3011302f9f2691e68fc7f482204d3936d373b893e3f3614b74cb1369fd05e11df7a4b7b5a72b4ff6180e95cd53f5e7d2388a79953a62351169d836bfbdfbc48b621d004df4ad617023be27aa516113d00be6a0e7da186b36a4e623da84529bce0c3acf8bd4cc9dd5450a7024b0c384c1f95e17bf5d5255c18be3bbe097b09ee1b52c86cabc60b279bc173e4dd6ebb6da48575297d4bad3b00058a567bd1d239b789553aaf7be7e22353bdfec6767f3b8b212f7b31a1828dba9d3b012ac6292e93b9348753f3f5b0da754d7e6c022df8dfec25f114c24c83b6977641db32ef5a644d06a2da9e3095ce1a1ce0a15dac33cd0eb69240c9da8711fba296f7cef553f82dcb1efbe88723a0bb95feb3f49573f352a9e47c7240fe83b6035e824bdcf9c27ddf1a266402f901df4de602ae352a43003dcbf6f8633c87d9ccbee466770524bdbe4591a1674d05ff478300993654fc01db8cd758db6314b6b9ddc0556c83d18ae5645461a3578df890e047270b718ba4d16f98790bf1e5872201a48a806e95833866eb4b553c4a13878bdc3e51c56ee01d29b23cdd3dbcfdc5433a69c911022b879835b108690ab6773a17237d387641101701d97a8b6d1209e28878e35c830c9a4e8b77cca4f511f8b4290e8a385387fa705577b3122aafe1a095c514338dc1f3cfe47c27018bf0e03bd2369735cd6db523606647a9fc240dc7c471d7a8891b931756ee7ab2aee59c7b75b5dc149b42a3b025f16e8d79d113cade2bfdf5bc963a502537800ec5585fe39161028341e8f6d7326a488d412afbdfe2f64a9303c77de895474dc4f3e2a62608934f8c79275ecd388a1ecaee6dc54f2df56859138a4b5fcc0ce43bb12adae0d3302367c5dd4fe2af64070c6a94b0f08b283dba0c0953553852254e025210e558b09698d2796800e264355f970926280a8791c4bd501486accae2a8fd92cd493a1ac700aaf75bdb957a71506a45d1e12a27cba7d51a27e64a92f7ec7d1b18d653e46d1d64d6724287f3f4d568cec9b8a73b8f30ede55e892822de4538e4df0efe5047634d7c6936595360bfa3cbef7dd5d2bce7caff28318a7c53f922b100ada6807a7d0cca47a78233bdedbb0ffdf0ec69fd7e2873e91778736425aa91acdb56fe25256b4ee14bc19336f193b383d5a19aa3248aa9bcb17af8fe3c899b2d4627fef9bcda31dc27bb293a92747cdec2519a737ba37b6714cc032f03a1ce539055a9f6e495bf89af620343f874bc3900ac0c96fea24c64ac319d2ecb6e01459175980aaf8ede750aacd0549753003a2b3cf7adac41520363413a126d0d52572345c0ab7b402eaad05f4680cf25404d152c43e60908230cd4431801c34339c35b84a808d3328e57de757a70a5507d11765a25f1ea04bbe806528ebac3398fd255d6b6e50a0ea9dfd7e96bebd01b6b31849443bbf72f6f383c52a3f8080f08924e9d0091769d1795f77d5922f15eaebd2ebb7e737d2f3ef5e5f9a924b8b78a21d5957ba55673b8d1d1206a9572e200d6a70fad0711afae9b07c5b7766737ffb3dd35605459b98d00b5ecec75de8b3555eecd025f6bcb4ef211efe48d14909e845baf5c10bff2e368fcf85095f2dcc07f00137bbb04b390681d8f9adb04d4641c2444c00aa20e6aed35f9fa674dad664a966cfe0b434040e9cc16fd4adebdccf1c9b80d60b4fda0c992a6bd45d21bed04c214047440c3b7677199dc750ab5f99e8cdb851a6e2a68cabeb48d4190601adffe95f26aaddbcbfee72a56e87a54847975bf65870cf38d5ffd2885c599b4c68df70089264e2a0fdcfa2e4a86ccbe80cc27fcb0654d8b48fc5e5ccc6761b212073d0b4a7a160277b5513ebbd5c9dd9066b6bb9526b7a57c61a1653831df0a2625f1c57e451658664e7cd33d0a31f059235668981b8b082dca28c107355d7c521a413ccb98767a43e81ad674481a8adb17d1a9f58e4ded25a90dd93ab093700ccc44a4e7a4e508288f4c0e666905d59c2dee9176b777a8cc660618ae449c0897347b92af3852342c4c1a77eb0e35e85129160b2694d1c19089ee50675201984a4f0c3ed5222c3ea90e6f6fd20a357c40b7e4e6ed54361c25072223a8086c5d9b5ef0eaa660783866054b7bc749ff8051037c1ae36f18533774c6136cd96c2ead621f6d996eb9bd3c23a3ef2bfbff9035ca1ee08cee2f51b31d5bc43391f9b268bda6e147af9e8523f05b1450da1608dbf926d0033fa37afb0b038989522","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
