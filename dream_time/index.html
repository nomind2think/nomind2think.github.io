<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0622e9a87a00048a3e45c7e6afdf6638dc3bf44e7506f87e520fe192c02022b76c9b9a73d2da35caf7371476fa87060ead8550fcc3834c37a427a97f8fc3a3ffb5eee5ce10a4b7bc313cdf08ac299aeeb577a80d145d571b89abb370273fe16daab2b7627380ba1f2a8918c659a3253a88acf66bab8d04b1d38680abae94f2f11338af73ee1e7c8a5fe30bde71b0952444d16bf5fe1c805850c7dcd6581215de297a19302a7b652506af0f1254e4f19517093437fdcb0b18f91ef5d8f8853dc42641fae5e66a7f35ffb0f934ca5889438c5b9be8b642af9dea7535413f6ec740ac3cdff05f152d3e30ca79e56250bcac4d407f8ffe370e235702dc8d8e1870bb24a8a56c235624e3f6be662258cbe1b8127d81ffef60bd35150b28d40398708330816930cc7a26ab3755840f1652a9e9efcf808fe6f26ae6af43b5d7a932eedfcb3ab542ba2c3a7caaaf29f3e99301ae322cc91a790f9074e17d1264d2b9ca21351b8159c192f91a35197dfbebd1f1e21f979432223b9955bd8b7f29a30bfbc6874ca8f3724974526a4f9f86c4a9324ce5e6b249afe88d7dd938e19000b127ac512fdbe599a0b3de7a47c022f42d454647a5cfebf13353ea619758d5d5388678433a8e7b674433554d93a24ed23c7b81a1242d57582773b4f0021c628c9e8047e7c7c942750ca5695a9e2741a57b65985537a2c7c6ffedadd157c693a05bd6d5e86689a236bf6ab4f8ae020d40b6977925f31d72d1097d9c32bf901c87a89ca15b533943eeb178c09e72e3359b9c2f049d857df037b38ee18ec61843c8574dc7a8184883706f947e4cc64197c2a9224745c3605011bc7153158b1341cf8b1dd3541dc22f1315b7b39344f1d0d0d959db595cfe07281bec3cc0fc23c83d2815fd7aa3bab03823fd5e10781fb5ba610f935975662d9aa56abe69d27067c2d7f3ddb7ec6b3f8ebdc7a47f0e0d0fa3baa2981c5e539632d4291f5c5e00c172850122e7105e31d0686f0ac3902be93e3e2d66bfe428627312d5361ff6526d1962991426a0644b0d3e2e1fec32b2b9599d8f2a7febdb19085d16076141349a1325ce4e26b0de5636700046c24fac89ee96ac664de75273254d2d176e8eeaede0853b978523b8dda9dcec1898e60bec1cc72421940f621d6d7cf832335e53dd5371751a7dc6a8b492a0a2af634d384ac1bef905da683f99bbfdf0093cf96421ac48f53540d118f9c863995de1bd77415e9442c7aefe1a3bc767a112931caad22360e0046471f5d7c4b41e6009bcca80cff91013b744f9677e480e2ddeb2ce56f3ed2f3f6f58e86a331e5b2a04624ee9ecf4b0623d0c840a5278d081bb5ff2ba24a363b3ea104f504d7fb7d3c5371c7d46b06c79882040b4418ef0d0628d8f6769a90b53cfe2d418d9430a85a51669e852a4836685191b33f6e274d712ac8ddd1b56615960b38c63280468200ffc5f4e562c7611430f4181cf804be58225e3c6ae8150d9deeeb8e2027f21405e82a6e68649c76677c687c7e22378ddd6bbd9cffef4bc86dbce4ed9d0f5a26893bfdf1d14dd3b27e6029949dd21e2c73f73ba96f915f073d570b60b211cfd84de648b6e81e2c8dc53b2f3c57fca76285a0377a287647c275bcbecb9c66a7f79d9fa33b04191d27edb7d56c7c93d609802ace4d664c6c9e039a8eb62f9399360ae6c11e8872bd823802375fc02f4e4bf8f5bc3a501db1ab567807fbb8a4fd52a28b152aa971a18515af93e166ee9d517f96373b5aa38858b0e8d480888f30cccd0589abfc0a1f3a08741eddd12f80259d67860aa121f84444e1a3e33863c6e970a93f7c5f7c26692933f62ac55ed91a1438a7704f88a43d1a33323314edfc5e872bf4804ff3b6fec4e092abd9ee00aacb6779b3488f9c120d9c5b6c12370e321d7501a5577ce92ca5a5a46a6475041a92b24807df966b8a93ec22a73ff16f65965916c281df0a7ac0afd76a4dce934b876e0269b4be98ea40fb64c669c06d78b2f650554a2c1edf74b53ab43e449def92c3765d6c36585381e05a280bedefea8203dd49840f029eb11ef34a26205e9ab2f5bcef3ab9b14738744398dbaed1d24b780f6e0314f01b4c0df2b62f078f1153ecaf4ae11a0327d216fffe0ac71768ba600fef604ae51f3d5743d3a0b0dab315c03110ac674ebb96fecf6607c3289bc0685e18aa363b15252bd4ccd2788b13e934a8fbe64fb32b8a41d6fb358d230eb5cc0f640e7ac631daa9a47f1fe4a144230cc60884ae783fc50c3b2a579aff7b2e6d12432f6a001e634c5031ec513b92c31353047c2b3b3775ed3ed892d8b25341283ee4783f4b16e1f5710e64c66c8ae7dc5fd31c51284a8a0873458a631201290410cf63ca1da032be651c858fba0d49c038d2d500ff919d39fa9ce9fe4d2fefc79b7b3b507787a7a25c9dcb295c0d6a071f29fb1aaf260960ff290848240775cf1bfb08892483b0227b1fa2f2f60ba4077b0d9a7b3594c27ddc57e1d7ff353addfc25af6a79573c49c72bf1fe20ef17622c94e2885bbec09f278756aa400e7e74f559ad7c4f33ce6aa88a4370dfb567da67e8d6f5c1f151e97c22c7c0b710cb24cd9f94eead16a5e49fc5bc3c49581abb7e96cbb7a624527545164ea41ecf9dc5e4ef46d89f79faf39f702d308dfa9e9a14117cb565343ef6c744d14f4ade0dd318012b88e6026dfaad5e80bc166ad1d298428deb6a0cab1627101c2e066030fe6b95d97b5d5d8abebd57c8c0904b9e769747b7b25de3bc91587bd8f8cd21c40dd794bab3168002819e4dd309f02d70c7d4239e5246de7b5cebc5b47c87d4b6ca70b802de90e51358820e7016ab9d6b9c434fcb2bcbbb985f88f9340ac067792ee84244c0972a18fc1cbcbaf7c28a153d469db1f89c2500aa38de4e89ae534211b746c435613e58ce47fcf9b17a30f78319813b0590b8bcf1f6165183c90e14657539fe3a1103306683041555e158cfe090caf9afcafcbd883676e29d792bc3d24872644bbc2383f473a5e3692ed43aded8c682fbad2ea132d270c8da5d95b5573166dc0d1e69f8886186c9d14076905863a7884a7c29b283f3f5724c74a9ec121ef8b7d6b1f0a14b4d689a7eadad0b822c03ed940fe2920d649abd985b060a0d6747034c9764a803e6df8b24108bee67147cccd54458ad66a1386e089ebf95723b678c4b8e49f813eccc4a5e6ddbd3c87b220964cc7c5e35b6f0c0a35618a89f94ca43fe9f03e88c1541dfe48bdd0594ee4feb03dd67da46558856d9f54a0bea89e38dbb98f7a2d8155eb0c42f17c2687b1d0a63516cb5bd03625fd78a8b4aa7b1560df13de23a400403b47289a670498fdac62bb6b559a11ac158a4ce062fd5e9f322ac487f0eb6e690830724f98c00217d034192c8469cd00bfc8f40b3b3b2aa1f08c4818fd1c50056ad06901b76ddac9e13855d98302f87efc1e8277093f993d4e315045ad0a037b2d6079c2f5b98afdbec2a7d7697285609936f4fe8b1574772a397c18255989959035f7143858c7349ff5fb1572070ec2515ea5e1cc09416bfa86f1cf5041ecf1799ce4678f8a8c608258416679c33148fdaedf7eb5434d88acc0a2e99ebc3f0d193b2538e8e58084f2817c37c4088bb3bd38fcbbcf24bb81bc358d2ca2e56143998acfab8b16c99f340ccc32e3fb14057dc9c696de408868385eda637071a43bc092ba6306a569ce3da5fd307e317250315fb8b54a1b2726564bbbd3c5e9d456b7da961b78dd0857b6c9ccb923a543a496fdce09f18e723618c5b9a27f3c4799076a460845e8e5f61f69dac32c90cc93b1f6ceee541591cb8aeac6e6913156a37bf39113a0a193cc598125242f2b6cda67a25c56f8d68b4970e04cac264650df39f406f2d19f26c6e42f9142338ec7e6418e7868ec333b85b0b741ece84d06beabdc9c9bab83640e4f973dab90adda7c8b3b632047968798650c9c810bae04bf622f4ed2d4ba4f8851cc6145741a8d000149c310b9bb1f58f8a73d1fb102f4b96d9eaca5be25384d8aeba40d2ed33068b58f9a6d6946d2e924a96b59aa5f4ce9ff4ad7aca1b392b28cbbf110461bec2b63fc77f767bb907c3710ade0658e81c525bf1604335853ced67fd4bf268a1226016b4c46b176544c9b01e5a5a85d3c593dad4a9fae3836dca843e70289f811278e658805b89034ffa81877d7f738647dc26306e83a26cdd5f915749390505d6349bdbbb5aa5b1b665a0565e16028ce958548ea27fd5156ecc0cf2e66abfb202d2abae3b0a5ce76b3734f18fa373671c0e9adb68af872201e21e9f6e5104ec1eabb63cd4ec4ee993b458a8436921259b54392011b32b92cebb9999e07e9d1cb00c2631d13baae0d453f0647b92e81acac4bd025e3fb90f5ba7633b24febe36df3caff11d8c59a638a89d411a21abcd4e024985347a49df3b779f94406dd7912b5511c74e49bb54fe2895c5eeff2ebc003d7f97cd6255dfe507026284bed35b7aac6ade36d27a5e5c64f5a06bb8b0d96182ea2d84cca9ea80573f84477098e29eb0ae1c36d57d5b5e4a09515fc2771037d4543060b1ef5adc194c05abf12c0279dc9ed95daa0b171341942de90636a3e6b41ad3a755e5ef4df661dd48550facc46a38b48788abfaf69b1974886311d0ddd11fefbfdbb2a8e75b68a62b4d1796bfc634c66cbc338adcfc94c92e6da3624689fede23553170a77e49807d5be68535dbca074a35275798c6a60f6b82ffc6a657aa2e14db73c0493c4838c9297a22d347d9148e5f5b74b3e3c0b9e80affb91e0f65e1a0e474336e018b387c8d2ad11fac26a51cce163a8dc477e62e5fc774a0b3f7efd271fb473b38587ffe3682c7bf3207e82a32f3a5e448ed3154397e4f4efd724335d11d84db289ea7cd7af90094f295498dc0c43f7466c3f1dfcfe0332eb4fe7b47c2d35e01bff20d15239f7471464c4e37b5d46f4a0eb7e7c23a517e450d2d9f9c2b667f0f05cfd129fc8d4d6382502deacf31292ed9333fbd566d5c5c19c7294e01f3e9e51b69f53ff58647241b7cc5deccb969d52b93e6e438307f6f4f74b13963df5b849241053c7ac5491d1530fe30d180deedf9e73d45ab17e1442cfef63cdd15e483231f7f72241660870d3cbf506fe822b9039896099b8ade4c4bbdac172f70ec42129aa547adae637275f74ebcd56493b34a1b45b1a22fa9ddb542e330102b3364d06db8d93e69089ee8c30583f1299b70c45078d3c23cae2cde7ead7454e11478f4c1ad1f92b62c28e71913e028b9493fbf574faa909c325eee0550b8b7c26f563d18a7ed2c27b819481cf26a470b54a7c619b22ebdfb9307af24f902deca46525d65b0de1cda57fb6028c8709bbe8610726f9a03dbed1e7918d1b3800b614df4edaf1c14692bb9249f95cdb6fe928c66540ff56c1e0d37b6b44fa1fc581da16353ff7478e918020d38a8bd22081943fbcfc2c49e2fd6bee2dc52f37a133ffd6041ef87a210721b0e45d5a52888c42727d51ae2353afae380d13dac7312fb4142992aec64e0212ee4d4c14e848485572ff842054a7fa0e3dbf633583130e95a36a6d37fbc532ca36c2b2d2ffb5535cda0b02a65c34e94a79552a1f75b9e47267db78b95b8aee9ab1c607ada4492e6fc5b0e1d38dbf8387fee06ce4b228f4884ab2b8dd2cc5f6360bfcbfd7b949d47fdcc2e722d84359123ccd696643ac870dec819f200b8c9ac56bfe1593c34d42ec82dbabe6c1106a41487a458d47fe0e3950898a7c4e5603cbd9ba7819be81530707d90a27475babba6a0c41105765018c84778f44be8c7056501d38222be287e5336d7e24661360986064a24b0525dc6822ab865da90e747ab07863601e7d0036baf35dc663ac6c8bb2488e4c376df27392dc54a686f3c9bfe293e386610aa99345b54fdc9dc12d69559ff4e9d592680e6a9b7a8e4b8b3b26d0df624db675738573b6b2afb297e9d0a1af76cdb840c5a94736d770a8620dd52f652239bc3a466aed54819f9bf351b96fbd7bcf1d8499d0d21eb56202635e638b279d924ee067b1084e90d9bc26d129d3743647bece1bd617768a2e8dc0a34734731df8b4fc4d809ce3d7b83be8ca308fd3aa47096f745b2cd0e6be3daccaf48475ade0ff3328813de5a0aa7f8562d615b70cbbac43227753a8150d8f62a5830b52355c88569f79a0baefe9f2aafefe4f91dda2d63b04848e937f09a6423739ced2bbcca4c866946abab27242cca8565ded24675aac0bdaa8c501edc5af2d2af09fdd3e65bc508917db37fc9534ad6e43d12d8c838e8b755620e7e62d553b6f7e07a1140b68ff51b79f2d42063c08a4099f459c3f2c3584255eb142dd6d7594c63e1ea500f5893536ab0fb9fadd42fbb407cc0adfc45346cf86e8789331076dcf4e843456928e67717eb5fee1940fe9d129520bcaa041dd6655fb57d7dc88bb447a26f7cc049df8c791c52dcdc60ac53f0af385b74050e442a816cd7430c1ea2f36b11b0666ceefddcbffd3e3bade0ec874d24234ebd2088e793a2b8303e5c90aae1b90b673911eed5279c740d64028880b692d57b7f107db8f23b2dcc6ec70e9ac5127e3b866706ec2234af3bd649e61eb3e38ea73f947aeeae01e9623850e8783b49cf6b87f4bad48889e6bb7c279b7306090c437fba25dd76020e1561c85f254a5f09ccc71716ca65d157221c5454d6e991eda96b559d0ca8f36a7b1434f60fefc17b82f0ffc2460c5596c736d2f9c4278f3e9a140162930d8007ee561b40ab6ad16982fe907b77159d8e4729a430c5f4176344fb17d8d492f53012d4057250f3c6a8757ebdde11939a5cc6d91d2e3847ab775038609a41213ed54c817387b997c61c65de2ff91961c8a908a8196497a4d874e2b26fe9e540b28735dfc81ceb6eab00d4578b8118622916ca4786b39c6e0a82e8469513ebbcf65a239aa0a2925ab0e41b8ef6c051d5b006c80bb15fdd346feddd740709f79265008eb66a17c7a5feecc7825eb77de020d263105caeb0ad107f496617a1cc31bee9be14fecb9c4122edbab9d11bd182cdb9fd2a86826b9b1ff0e37d5ff263bbcca34ce263e85d39a6101b88aa403632d2564d8134146a5a86445ae7b332cfcf9a714a8ed097c9fa4dce51873653e03a66591509be3fe386053e18fad6b7f58c893ae7fcf0508753bf23449bf73069a98f5460242554a33850a738bd551d24b700fac4b3004f4be7f1ed25afb25da9c242367de8c6349695aaaff6eb5b07d00db7a58004f4e71044268ca68cf623a88bc93e65a40b49244f89cab52cececd632d5472f46bcd2c853b59ff024ad883180db6d1209c18950bd343de7c23e7b9e0bb5fdfed8e5142101b8bd0fb6ce76c0e4ef360c369c073c358841aaef4fd06db910d9e1de26ac9bb8ef721682d951a436ff1b4e89adefb78a91c339fbf7506055da64016fba07311863a4f9dae2f07fbf52583445d5be10d318ec2f10fc24df17dcbc8a166e7929e5f1c21724be28029d441d4aba35a4d5b0ac6aa0d3a2d1a6581958a68642b6d41f781a228fef884703559075372f01105bc1c8cc96955513720cf92215d1e912d3b687e30885e6a2a1b9b05b0d1d70def5d88dd6faa6fe6a5a484f3d1c9ddb644f5964b6e38f75aac389600638f525f3dd46f8bbcde2791df91339e1e6542f6060d8201975a4aa1771fe966f8ddf2871b6810a63e4e4651e6e5e66166f72dcb59c195324b8e7f81ffee2a578672862ad47ea3f25f34e4675b2e83cec91d2593306faa093541d7d2a390cc054f6fcfb72339e9a6afa71ea63ce24861db335a0e7ef9d48adaa5a875688e4e006d8e31c1bef479cbbde3eb42370360773e28b069fdbe2acfd7dea44d6ab4e0dbef9a99d2d4f3570f5dde1f97d12a35d2bfce832d8a8d55a1bd75d639694bfc00d0eae7c33575a16adbc1b742dd2d6280ee1e6cad00743c0b23398450b37ce019bd0badfb2951282211cdc46161c8ee1db687990e760f9f713bf5ae6382839dc05b4c5024a420a22c5b9fb23ad20fe9f627e87ad7c128b9d18a066d7d77eb006dc7bff308ace32d75347a34da586d4012de2f2c1b4cdd680deb013a6e7352592127de79ba9b20cef91bbb7bcc047745ef14bc755ce9446f6ccadec7603da45113369d1450f422488a4da9e4f59734d366efb22dce15f24c837fb46df564dbaa6fc0af8e085d5f83683a399b73de65366dc9e1e7f1e1b8f9c2741c3e689cb0f0c5553ac1849145530611c457fe5e98811b3a84675642c783ba435a6a557002e2b0da27b88816e116f97d561a16d53998d113ac312addf2c218758d220b647c60fbb00ce6f99936f913a43b77030d5c37b4f7b2ab1e6b08b8002825dfec94e60218c3f392c0735bcd59d85a48327988f2d7506fd825c1dd4c7d7aea01627866763be92e55976f93f4eb914d51f5db589fa1f7d233e9c459086b84c5d929568a80b01dd3911ba4e2cea259a90bf4c82bbb4df4099511b1e14c156c3bb7b36b7ed02ee812f9d6d28a26f5fad5ccda1a38770426000673a4b887aea020f69c0423374d163968642cb0d997410ef71ee90063f8b8fa35a375d37f56af0302ef7b39439305b82c762a36e5b294b983118024ec13ed0136e78f240f58c186313acaa5e3a5a159c5b3b3b8641c20eaed9bdc59ac6168252c59865cf756721b5cf508c3b5d7a83db6dfb3bb6624b355e5d9117d5a50d4370bc690666c3b2c1c71941a6393fad40893855fab15373caa8f1e27ab15dfeee34c3f2f4b1f739ff04c1f7c6b6a47d44412b11d01875756bca4a09cb573dbe443bdd24e8f9667e048b7b44bdead86141f2ca57687214937fa9d66b9c642536fc6f64aa69cdc5d49abd688f056a9d2023a2d54888fb271833c9cf41e19ae897034735e0fdbb8ff09b4a9c2e4ef7cb110da8a500bdeacfa98d6f346e616925f20c8c558b9b0fa1a3fb51c4dbbc09f4611732e4e9008a15be6d347e78e75ad35e881e3feb8bbf842e8aff108b5e6e242c34a1dafed0ac4ff872bc60711bcdb65fff34623720347bdf20edfeeca3b9d018721cf2ccb5dc8e5ad1a2d919f84239149fc9585013d9045fb435bc390980edb4415c578ce43f3206b50213a1d4cb335d9a6185b8e72f4197820279b789b5e0e2f28106cefdf551f37d5c419843c9ac2142ffea3982eda2afe3091f5b3a624bc995cdf1a7ed2d6bed4d4bd0e3c99d415194580b2cd03aaa49793466a806f4039fe07e216bb6d2a995d20cb68b7e442d1c81","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
