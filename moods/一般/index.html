<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ecf2c12cc84d4cb37cf6b28a5fd78083812eb967a36fdfe8e242266ded3efac8233f22e4d4f31002f7f8b76a223e81d64f8245d876f98f39fbec06240a2ac0542bd61b08cf8afc192ac2d0e399dbf9b9e99d44710e5cefb2a32f1d0532da198605a7dff485f58dd3bc04a459dcce2f4b07937f58311c94b3e34fd42f4a602f4515ae855305910ffe24e1782dbc2d028a55af343420a2a9e2857c3542e367f1afd831c0049b5ecf0be80cf4ca46411a33a965089898113ac23884ef7ec60c134225f4c0f792750990358efa50bf3b2d1cbbb40b5a94cca18117031f5bcf209bc32bf3903dd6bc551a26426ac43fa5572beca76c1b79aa1d7536576ed674a8fd13a74f358f84e0e0d527a145de2f9f1325cb5b3d18f456651902f64c9936cf2dfc7fdca92224bf345d4453e898511ddbef09c471af9b02abce2f87e9824f6d7b8d46b2deaee0b6f02c038cde2271ab5349d7decf783d449fb2ef6a7d421cfc901a0156bf96f7f314ddd20bed58504a51e7d2abcea01ba613899ef1ed7694bf9ebe60df0ea0b052412c4caa66d3f502e2549096bc778363e38dce930efffd2b4dc4931c49ae66a965fa93546a5f563af0bbde1f44d8999901a70bc98ac0adc8a1a2eea5e392db962faf3365beb57e68ebd76e4a87c894ba7c67db0dba9305b164d1abbb75d70c838426e64c74c2577b062f637734fd8ea6b52bfdffc99ebf70c7b6db242ef06cb5c7748a4dc32367005bbc0fd9a295dcc45abdd3b8c8bb78a38703867bbe3600d4fca2fff95e9cb0dc7712de91abe5c3278032774e4f9743bb95b377e2b7461c24dc6c42c8b441c36387b6123cf5d96dfbaae1c653374e163ef1049c42305df9900085f49b625d9a568241e0a95a1260efe36ab90b570909be62d78b6da8c650b7109d93ab30bc65d46fdffd2b86337bbb229521c2fbc853c19458cbedaa2c8fea5eaeb65b413e74f5bf2ba97877db9258abf8533e8da8045f89bd222fb24b42244e66eb6111c0b4851fdbaf44587fa9cda3e5e1284e208223c13410e2e592ba7f3dd344d9941dbc0b75c0dc82f212f9b91b0092f78b5491a1702f064679a4826dc72883d143f3a8bffa1c89e6b69a7ef69d23edc49ddd3f5c633875d8a5f2b8e8ebfe9802ad8922ad980ba1aec515ff4cef531895bb4e88a1eab330ceddcebef4d34e68cc19ec1ec86400dc853a8ac8c083643e0404eb56ee5d0140700986af204542c5cc74ed44415b30a6171ac57a8a5390e5007e273d996ad8348fa7b7984b73a679f7ef4701f0da997fe9838e0081e6bd14b9eb1f39d7ebe23d5a3d8b76c841bdfd3ffe25a3f62d99d432e5a9d6083641ec6eec26250de09d69bcea59f706783bfffc5d77bf0349e3390f3d36ba1db5d8e5b52436338bdf409a0b76eb8fa0670dce39412e1ae309304c8ee89a4a5ee2568b8d9c28a2382a9efac14577a6ac2ed56f1d70ce0446c780f96dd5d96b51c9d0b262d60c4cda856753b2fa755650d92b600c4afa12b9cfead9fc29bf16792fb7221931322bab8604b267c0edc1b1e934b51a22a0f9cc52f046bec62660c0ab9353e5a7b7e569aa5b0695ff745861ec83f91c343e7bfaa5bf73d89caaf90626d4ac99a8d429aa5f646b793ef7e12faf0bcbca4a67bf67176fdec4ec2085868a879e864ce7255e84a788e93adfed70a86d8c770305327991c5cf4e9cad58ed83808d0785c3670b600b70c4d2bf1e48247a5d5aa750af58da228dab7df77e8b3ba5fffde5009a603b75cf0283e7d702eb845b74f46b5beb1a4d40472f5c86a3055e2b03db17428f29eaa38b32f9c78fce1d2e8f0653aee7c6f16f8b9b58f87fcf50c591f27ede33f2aa69d9ca34334324c48ef0a7533079371eb367c3434bec51100fad9ffb6003075e13a1696f4f847db73ee8eed1690861c51013718e4d2af7b19a0b15222b299dd6b012e5b8af1a142aff84cac665ce1c01e5c1cc25154e2fddbda3a309619c2cd39c58e6da19d55116170605e0bb89179a0094f83d2c8e0eb702502b2d955391f0ad6101da8b3ea8fa5f06bf3b7c996f7697f779ae373c6f9872450b8b8119f7569ba290cc3d017f2475c3275682a20a864837e0661e40cc6bb3ef7569d117a97084fb372f625dfb7b8c9648b31f22b79c75b730701aab084090e28442740e3de925a33f4e24466181d902d50ef4bf17d18cd403eab19dbda049b63da28dfc445bfa94094b06a7e630adf489c2566534badd54068648c516a0141dbc0fc072c23b574210d8b3cd66c5cd42814ec2aa42038b8bbcfac89e32a3fe65c2b6ceaaa1cdf5bbbe739d8dd2e000e9986d3dfb0593eb64483915dffdc774f9b1f910a20516738f7725a90568b954ed6a4d6fe87544256781ee1bc0a511f0da12e8433f291158211c551544eb6827f95a34f5c6dc318570f5ce8469e28b368ba1c2767a4e3cdb039c59c43895376a3c9949f10677b787406fcfeb7c27d1508246474c707247b94bc941a2fce86748c64885a44f27bad9a19c8a28c34cd8e05d620bafc40954bc1a95a3696d72c06e08ef8339d4f937d0560edbe2c481241ed2290e45765c5b5519b0c9fc7d8ead5e4837ccf935dfc95559f1d9bb2510f16d4db96b0e4c18dfdacd04b9b58ef73d0487c6920ba453a48f0fa47c7a85a947272abdaf651672753943eb8ea112f0268632324d02643b92f01341a6d5542f91665c38b6024644cb39337f753a6e8c71bacf1eb5fce99c3083d175962f30399317473d85c798cff8ee9fbaf30513505c43ee6edc90dc23539e13f9e629f153785daef6a9c82f46a02880bfe91adae4a083d76b4a6f70d56ba75d40d3236fca1d4fd2e5048a7350f94d4bfa8db74412f1e9a7d1c1af0c14fe40512ce1795ba4ef04b5aec48447ab755dc7a0c42d379f8836b5d4276e7a14d006e40339af98537ac9a29d3048f8deab24cbec05262c7424cc93c98917adbc7b1e8af59313d9c71c27653eef834785f31bed5746610f63dc6e12e725638ed37f7ce93a63d70ec4d0be20a3b402cca63e023bec4a267bb6965c08a10b3774b03ebd61409cb663839a48edcbbf20dff3ebcc4aacdea5185a0bc67e80fbe83f92c7b638bd6545b7b2bb0ba5178d4e3aaea5d0e26d38d24bf082ea22e3af3863dbec6a26c84e10ffb26c036f1ab9caafd7c0ca64f42fb6472e8d2e90316604b3c596daf2d9cc4d8d1c6769eedf7ce5e3aa880c309bfc6076073e1243d3e9d4eb917effcded25a675ce31bf0e7e530ba294bbaa995868c56c048a03476d0195e60b81cf5898fdb09cfb8b5a989be65f39a596cc171c3030c28d7f4373f31fff8e3f8bcdcff4fcebe1399c15d5d3e0bab2cb6a9fa6ce038e346649d4a4aa745fa70f5d3f472bbfa62552b1ed0eb66a57a7a7f236f2fcfe31396a6a5d56e53fcfadd1e5c85b96fda24b446def7f56323f27b4359ee91d39087a20dfd066701a5bd6d317ec76ca3717ddf70701643122722f1b1941ce0defa05731f02072566097dc39a301fe5d52b9baa2cb5292acc2f0199d0dc6a7404dc124d46ddef269a9bbf85aa968e99616064dad11463a7055fd7218a7694b4bf19f6c5bd8e95c42d5dc6e3de6f7192889ac7398dc3ccbf2b1eded2c33f4ea3d7ecca2c87335fee96eb336b796a1074c649d57b5e663030a103f79f64b38d818e37890817b34ae47732c25cfd462c78a78aa48cd3d643b214785992e07431b0c5c6c805280d225ec884a142cc6ead523a17619c818d42af62785218a454d5f4f3c5647cddcdeeee42a0534178db7edf2f856d38ecac4874c63a8d6a109a1c0a4a4b50717d141a5acf06451ce9dec73c1eb6cd022a22b185127aaea4b8ddf73df30755b74323d58d2618fc048c7cc326421dd9c47fd049eb6169eab90f3c8521c03a96d5b72d2292d7e2bd602b31bbfe584bf4fc4c1c996dac5b883f1dbaaf8efffeb86e9da81371e615c450e8d47afdf6d2c78ffa0c05c4769a1780681dbd661716d31f8e73e36fc87e3732b225161c0a6eb9d0a3bdf8b0c781a3b765adf3f1f501ed69bacb463e5bdf9d024acff42268524d4654cfc9f8bc71fa3f4b91f44de3c4cc6d9fe161fec21a08e31a1c4a04d1098265bb1646ad1bffd524c1363a0d1eb619fa8e5e5bc26f5a179d02b0d13c8256359fe5258770cc83737843155e94d2adc86a7aa8375de88299c94b321edc494230ac675bf05fb4b621af7bf8d1b34b4bdaa5f13d9f569957a97a508f38f8ce7a32b939e901fbb8cfa5eeeb888451af8127602e7843845c18c40ae5e2bad131372d6d0aec8811927b0ac882dcf6bbf7caba31d2a8d5738f54c105a216d463edb4e93a8fc4821949c8cb3407ef7e98c1aa26dd7c84d2e3e823d96920fb1d0b2047a735814beda568cf3aaa3cc1a8006728a073d9037335997bcb0dacfb41197693104f187df7a01248d6653aedea95bed2fc6ed206863cd0699a3a794c059120b5dadc8ed652e979cae9b81b860e5288bd40c6bace239d076bf3b1f92c424dd5b162c802a3eb1e1be8270a35e9b312f3aafb4f803534940dfbd15f6b48ed4e2ebbebe7c67d8d97a93be0f253d528623253bceed53c684bf6673afa9daa83bcb0ea9f60f217f43fa8665291f8af6a034be74c4d531f50db145d9f41531ee6a83951ad22fe371fb5670a4055256ef565be7c0aab25e5f6802a6eceebcfb484663e51845c8cab1d42a5897a50213157952ef1029223b233875baf8cf1135c9f843f2cf4c15505a4d9b22eb55f70ca65d3f6c5f1d4b45b1b15ff34f42e24e741992fb0e3e77ec9221d470189a1efd6d705178f0c1098432162e2551cb0a0243996cd207bebc24b22b9e9f34d9bb2149cb90fff2defef65608cdea1aa6723a0d3e5c1539f77f016f351934266027beee594b1b9919669f1969929515b8b2749dc975021e0eb3df72715a11e8636b7a3846037e51f4da27a1f5a2e6a94f30f1acffaa25e8311b8140cc75f1bd10f1145059b0aa504ced47a6022fa146d7a68974fb778928074fc27bde7858a7a1e10677e8cb985e860c9e317e122e0d02e7c26eeba5823adb6c8d45d713316b6a392cfd55f25112699e1f9fdd5f0d833baff873c0939ae150060987acec06b08d74d64ce071d26d24771d8307ed6363d558944a82db14c5dc1f36feafb8cf81b96668cebce5cb8d56538b4fab6ab59968a9540f04425948efdbdc43753018927cad8d14c1fc0e3f3692739e6ae893441be18d4a1c2b7883119164778b1eb05e86467500a450e17f89ca3c77a6cf6ba74c7da2d1fe8e104c4b97e3d3912ace6a4a79a02710b81181e7da67a521016df71c10a4ebd719873d9ab4413af87d0ecbd4aba0e343d2c2a20cdca0615c2647103b5b0aef5623be0e2e46dca6cddc07e7a8b803ab590a3a4d6111e75d41421a7541d2d9e694da6e689db27f6a6ac041cb6418ece1de841e05369f34a0a5640abc55952ee1a5f83bdfe16de887edafd147671b487f4540f89576bd234b1904aacacab7e083cce3770fe38901a00a94fd486e8b443cfbd96706c0f28afd5570d07540fd3d7d91c75e1410d816c0de218be080578daf079e77036a2fd9813b9864c02e604961175ca4be2367d4d67465be6f1c25c48c09b4b92b3665dbc6bd4e03585e9606d6e352ca7864f6d40128ce64a2a4134b7dec34385ceaaa4967b6f28a6ee72e62a5af48a19f69adab2648f66afdad0063a6f4069958598112c7c03e51f336441d67ebcf1dc5c97d2a4599d84c6cf8558236603e96a334b7409f695584e4b1a0541a093c2fb9ae303167def7ad68a3ba42b031090c99f3fc21e7e3a18e2d748d7481ca4228bdaafad31cd50916365e727ed8722c43de21ff65f9e09d85b0c3d9b7b8079d07057c799932d23854495c1093f9dc8303e0eb77fb1aab7212d07e0acf36138c86a6e89b70851a0e717dbd458c3668a8a630ca8bad4813c3b44ac4027758deebb9e1b9960342d4f16783d0c3a00e0148fc2c9097705fc685ef8ac22e3eeca88ecc76921613febf4097860679bd03d576312eec2b623501c0d77306f01cc55f36b7683d147f163eba05db7414c17f7326c531799ab62f1a8598bf5253065c94b101834e72c99042dfa5256412eb276a5463c835b6898f3418f8cdc2bad865831bc83ec5c44cef3326a3a8b3d80a0d6c541bb885f8f3c94beb015becd81a3d5cd918d1376658cd82bbb450a13d0d93bdf6706c0e5b1207fdf0ab08b9733f53820f9acb21aebf27255d947db3191ee89dd8ccbaefde3886198f28bc5695536a982012e5a371e73c2fea8b555d47e58fd61471f3a0690189a93e086d6ec1c594bd643313d5622504a344c1255a40797bf3127be5ce87261a4807b2691644634d5a00f709a324b08ef64ed10ed9c517a20b282972ec62cd787c93358ac894334021122497110a6a325ea9523dfc648f901056550ad488376a8942a6ecaf85a9df3caf7814bde81a83590005b72618e39b2115062bee04a7523ec3a2baea7c4ef83614977a46b80eee39233bcbaa8de54cb309f3b9e94ffe8348a65455afdb1354bdf828afd5cd38908dab074c73bcae2f9d4d1b135547add1fa089a2ddf8e2084c40d4dcd0411eb18faa732b90dfb0a1a639843955335d52a0f43502d8aaf00924e0ae3a2ab4ba72c8d5df314599552e2a015d64a196c025a085ec0aadb0d90e452b2d910d3099f1fa05d7f8ff6080c6344d4a7854e5ec249e0b3a0179895107189bf67f3973ff7bafa2ace7a63da0ce949f0cdbc502fe6690cb58f6ac2c673c5db7e1e9ac60f68666d8ada43e20f9cf57806ea597932a1eb042214cea1f569b512e167a5f08183ce7d886324369d4a1b38d2dc78a80d60711b2ec3a0084f0a694c7ec261cae9b09e34acf7e0bfe36892c01acbd244cb451d4759237fe11bbb12b4d561170a07730b6ee8c204105a3bc8658e6cc1ff6eb2d60b68bcdcf972eb80f3865b1e2e5623b8a0080fcce898a81c67ce72754cabb04f0ab6c9a132f9418c7d01be3fac1f88a0f0f30dbd9a6aacfc002880df68696a2e6fc59307378df92aa6248df153a53b87773f904b9e1764a6c22c4d1cbe47ef37ddf357152e97588e0e822a0317205520ca24113f0cadee4ec036c9ce13bf1e0753f470d1152698dd9c93a1d54e75522af3e9778b8d7aba8b416f73279a4ece0f9a479101e2a0e6a1c470a550fb717ca2c0d2729d9bbd593ade59e2210695311b948335082b5f86c418be765fb18d10406f4b2546fd52286cd0a51f1248185930e8de44f0615ce47f13e38e177411757eb15b823de0f7e504b15fa99a4c057b4a34ce9faecfc81f842dbe267b57b528b7fbdb0a5a6f8d7ed3b1906bcb3d9bf37837c92014cc9e2d83fbe5567ab7e58f63e11b6495e392727fccf6e8fbd321b626dd5d7eebdcda7c6c80f7e7b493bc190c45bbd9c64bb9932c39f0377cc31eff9ae1b2feb2f688940dec643c5e0c765e4d40dae6e546843000b871eb70bd7e16aa66a5ea9d9dc7eb3c2f71fb3d55db7ad91da8eae8d8223f54528c2bdaec1f27de4244a6fc9bd23c52311cee72428621998a003ad8bd467055c7f66a593937d70023e6da3d5cb0633686bfb34c859c62b81dd8340119ec79862188d4ec483096b6aa90543b0d2e7dda3273ed0f21d5e8ae822c9449d0542736aea30df6a19b77f922784b3a4c85dd4c32087bc284752ebe4cac6140be2c1f84eaf43ed09466a63534167f779f1db2bee9c47889412f63d2ab33f35912aa4f1b901c321591159a99ded0c5dcc811046fb8168f28b72e6d789308b85eba0a0acd322414834f7df95b1b47da42d0c7956627b64d385eb941f029a62bfbf4929ba1b646b66de2a667c6bd57400cd843dcabd4920b51b9d7e0eff63983cfdf369c21227a10745248cb8cd344dd09b1184995e6fb9b9f0f5afb34c94d815aa3a51d24c9eb3721b1c4b48ee9ed936f9b5f77799006ad872823e61372aa2a0ce334a376b55ea3af44a61c449b6142a7022ff61c8c35c34bf5986f60ed084edc0aee6e171d68303c853529365f71b8ff603303b49b41a0f3dbf44e6ed9142c6aeeaebc034192de7a3faca5d7e604e3ae80b5f8c68618fc9ef5474f27d0c77a7a60865044dfa465756bec05813f7ab193294aa53fd695e5d31e4e332ed491ccac8aa151537556c0ce113bf95aaa2501eae3910d2aefc13523cdab78f6bd40e587983b34f38ebdd412ecc2fcf2aca45163f3b103d301418d186a26a42e08ddf92b3d1586df55fd6c9d882239ae669a20e670e771ceff8c58c76339784a5a4e5443cb9133cc4d33a79cbaf2372afc03600b3f5028060e877f9d4aae01dd5912bc0d9d639177fdd318d7ae8e32c2c30ce5ec99165f272a09b0dd0b7cfbafe85d038bdb820276d384bcf49d68cd32c9f425039d52707a4e12bc42a510ce4c356331f323f8b156f394f69b3ccb957941a6fdd5fa25c57bf03edfcb6e0d93b903b2045645ad515a7510ca1f88f1a059c1d338ec57ebca4c690b440e6d59aed2a03c3a8b02e87b4827c2a97197404aec5e093e03bca43aa33cb1a547f22661a0996feb981a8850e43cf50ab37b5a95f2a11fa9e648a8aad8f35761535e85e6b5c0886f80a334b82cf4e2c0edc8ed203a06461a03e6663164a6e6ef7065fabdb78b7307bce94cd0b8e1b7d8f7891cdde00c7851d50204c7916eb575e8c71f3fed220af45bc6f8bdd9ab5d786366af1d78151d06cec046b2665b08e05e66ae0d10b1a5b9326f01f14b80b4f68303116338d91520ae11dce2b173342b423fc7971b8f863d2a1a006659b321c50457c128a78bf3db82b9038eab3f0e50365032dc4bb16b465dd30d59d2d606281f37b07f5a8456f2ea86f5224e88ff668e90d1837577471164c2731af3ca462bb1f97793b1eba357490cb25c84a5fa2e78230c8aa90f0280c237648e0f9e67f6a3478c053c8948fdcf013c28266d9061d2870d577b1a48452edf812fe5450702ecaef815f7c80807e5a5127dc2fa1e21de56ecfb5a9cf24346b5d11ea07ac4a9035f27767f71b6e5fdbadb8bb3314d427347c144c7e6e9b523b283ebb903c8fcda0b6be84bcf67b99c5416024ed7ec02b474733e8de7eeca8fe13719434ad97d25eab7bc7d92bf121ca4763699c0b3aba926305451e264224d227746c325c44109d6449e7dfa14efc01f64cfa825022fd5a69689e5e1ffdbdfd70a4a8a460e71bf6fb8e80af3c91e000aadd079ba40fea6844b40fa7c91b4f8d202fdafce4d1ffa63483870556ed40b623a46a605ce409a6be89f767f4d3228d07e726929299899c36b192af12a1bfab459a95da122539df681ae254a9852b39216e1cc9e4a5cca64a55d6e3dd9db9eb6fc3cf7130cf5a701f4cab5ce64e6473afb3df0251ecba73e2a5cdb3f441b8da94fd56141b5738f0302439b399f557a1846444b53c40fca5cedca522cd55d67210f17d642bc9dba058be7eb5e0b8bb2a773e1e5ab7e2eaf4e2d8cdbbbfe9413bc3445171fed8fadcd518fd06934c6859c238bcbcae2e3bca765c6ed63232541fa24fa4619e28d4c117aeb1182a6febf64b43069c5764150cc2e4df0285758dd47b3cb79d39808c6c3c084792904311fd16723842c4e2b9a7829536f7c711144c0775bcb7a1cc04c356bebde930e38f76554e6d65afcd911646c5a230fd2063fe0b6623146092d4f259cd0fee3a3a60fa98a37a7af539e490e60ae14d8b2c6765ee619c54b62f41266b5239e3b62a1a27cf30f2eb740219436a6bd05f51515de6491ca4d231192242c32d4beb89e503b85478d0438acdeedae2ae3e20ac71890a7af1d64afd865fd62ef53f873cde2cb2e64c8451a898e36056a0c712bea9225b94182963f67708071b49a132a8b63f3d2d26adf1f5fcdb770072a8abb01298658877ebc0ea1c74b70214e362e691ca7c64d9eb681bc6bddac8ecd561bde9f30f1f4fffde10e6cf5f1823469fcaf6bf8d756ea986157973182494272585342613061ccb909356c5be82169ec92f5eedff04423620193e4b5972995685945d99b2c6c02836f68f3a8e17f44fb12cfd77c061be5faccc7b2fc8f8407121f6b91793f61bb0e64b09e35a892c603666b9d61744d81925f2a60518ac06c94fd3181d3c814f32abe52899bfb330b6631bd502923c0dc8ce4330280c0681fdcc24e5b3409a08029abdddef444a44ea000d414d6faf383d7553f11ba160477fdd35891ee04cc28bb0e940be800ec3c51359a91d45beb4d91dd8b1de075415628240df3eb6d0ad9559f530fb4fa07a72934ab775177cf53c5541b03d94e95adc3870352f8177f00befca38efe206ff7ec113954f9c61942cff4682a7a710060d916c715c2238c54583b6597fbe094a33c380ab1c0583c200e87b1057dee65d628d459ed23cd9b3211701f9fe9f9948cee8e8444ae0464b62330389a55a168b92c9fff1363debce8c6c01129652a3fec0bbc3828b35aa1040adf3a661954b6a08ecb6c60144d5e4f0016fa6465a9c797223e6fc9b7349925e0f1a144e9996c09c81e0d3cde20b906467551c546c8f7360184d2ebab70d3b8602cde821519d24df2d8501fee057e9bcaf931c0642e94ab0dfa5a1ff396350d6ed77e8bf9a8b39b30bdb23a8f3fd26fa528b0d9be506845d306dceb37113dc2d035795191eaf08ab68ab9dee25d8749faee7c576f4aad8d55a390dae094a52fe4f4559314b62ac545deae99469dc1b70dcef73ca54775b9363f0e12984df40e85e999c152ad0c2211ae1ec9f0b0e5da340484aa2640bac26da67542168045c0c96b1957e3ac0166ee89d1f142b4e48442bce80cda64ead8ffd202fa17808d76ab538dcc40a69959fbe3f9ca473f06c9e2df66d8540ee50ebbe8269bfb9e94853e01f60d0c679c113cf8ce2691fdb749462b8850c0d37ee8e09c6e79b1a0c381cf9b0b31b8f1edf3b4459801df8c3ec036330c8fa7f5ecbecf3f9bc6d3580398557bf1265dd8ae1f5b92cc4a832cb5d0bb449a59da72ba4ad8adccfb8b0bc38433b6110d99caf1ae1cf99c05cd7bd31e66c87f6415f3791e36758b4a863792b1bc2b808a012c8eaf3fe3cb517a55cde2bbbf26e7dcd054b2d0578c801b1218eb68c43d3ebf858c836f8136bc53d2a46294596cbbe18c228d5b53dc5b3492669048146ecf3e279bcb43c7a7a247dc010b31bcf185072bd748edaa93c286e4560a064ffda6ed367441256ea2fe5b0fbbb8e19410f5eb4128eea1c68736c30963f1b5900c11c2bc9fd9bf920ec4a9b883d1222918167df5f7187c50273f2783c4bff7ecdf6cae095f99503c4bf74a97c2739d8d8a8086e6445dc3f42e1d9e4999198ce0f53adb04939f9e94f7589409135c7a897c2ccd5094077c052e12e1a2b5f532dcd989e80a01ddc139248141dc2fc66d2df9970038a10352ddb4b83025ff9f84d97e5162ebb7fc3409fa07f3477360e74bef7177f372e708c007481fab6ee4ee2e43edd591bf22d5931320009edc1ab08987c7ac13f45229d11ad59f8564ea547e661cc92bc1e4edf419c8c3756bb3ac9dacbcc51b42c62836fcaadf0cc21ed01c399356388f9d5853a2f5c7fc8557fec4bf11a348520a76448dc1a091914b23218caf65e938a3baaaf8dd8ac13224055b291da0489dff210477ca77fd8b80140bd31f4143943b18d248f1214f037075af8d27fd67f886214bb0502a5430848d191e474da82558922f9b670571db14a81e7b7fa7d64ee012ad556be688ff47ffbffbcc1fd97f26ab3466c6a36822c1ecf24831d01d379321e64809a2b34f5474a03534df54c2d53663d2cd8c1ad5fd5520d29361681592fe9c8771fa54b7ba4fb372ae4099c39250721929c14fdac9da3037e5ea13b5dd6ee49a5575bab8aa8d96b6473b8c05b60f1651c0ba8262158cd661cb2055cbb7daaad181a1e4ef28d40c7498c170199a81e70e56521a6cd4fc619f5251fc75270cf21ea329fb547de19d5b3ac71e4cbc5d9279b1dce01cf802d6968310d368612181bf5a542f338d9fa7c6012b570cf53ccce5a63633518f1a913c4a1115440f75730c2b8877354a10dc820aa004bd715af17cb68b5a3c9811264cfffe75b8745008a32e0c8a629adc4094fe278a89d6c503ccf5075ddc0929ba2581d8c07119f65f9b9abf2cb3056cb1559373ae6eccef7f2d8226dea30","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
