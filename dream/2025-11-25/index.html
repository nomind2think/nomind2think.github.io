<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"112e48435fdf0fdebfcb11d7a05aec9f2e79dd1ad96d12c15f1c2fb94a905bd69813fa5601bcf442dd8b3f2a9fee23772bdf0b062a4e394905aae79e58698e5a48fb36eae5bcb47a692a2c08ba735e042a6f62738fa1c323f5b85f876e3a8a81c7be23460e3184018a637d559c50c9d2853f545aeb9ed41adaf4caeadcd8dd752674bf7a4f4dc9bdd45bba5f008e4b579397a55f42183116336580afab820fc9ea4e624144ee0f07eb4aed2995370d1f7703c51b66a1198fcdfe05339661844c775fd179cea70aaadd5a223de72cd05c15dd47ce6ead60bb561df3c1432eee20e157ce4b1a8a26f3dfd7536ba91ca0ffc372f46ab71926eee6f3fc4d83b532cc0785ea09da5325f735b83934921b09ca7633e750e4a238c3a6f9bb57dd153d8a2f9f51dd1e671eb10f31f5480377803712d805751e3e25499e8ebf5eadd5b7fe7ebb61ab1808aefa8d4a985ef83f7c1ef7de7c5092e75e416dea52d8718106a8ca4c452d1fa9a111d19d0c1cac0d72d58c14e0acfef189c9dc1a0effeee532bf3adac303c3218b22b38b3e0360e6d90c31069737f0bc89b1a70c42e56edf098a3f266e952b502c05a5af20120f2ac3c1e4b61a675bd69e8d2dd795f7ac0ccf3583f486041720b3ccd21ca10923e15a776d5ef6c67575caf4d98afbb87688ee248667a646476cd5ebc776b54ac9378a4c0e779709066b7ef1eb9bffa51f2d9c89d6a2ada748b435893b68fba2ea9a617aab824875cbb598c8f899ec71242f6ee2862cc1a08f60851a2690375545835630b64fbea425320f10b641b99002609a547e0710b63122e2451819d846b22ac1d813aa9c8caee3d60d6f75face8ced1bfcb7733873c376a40a2267337b34347ad93d4bab627f94a88e8b88e1a94e5ee277aa09200e53d171a628002290d6c8469f479e63f8da02787089058a63147372e6849a5cfcd3ffd2d3052a523d4c53b60a9afdd603528ecf879b9d2b279aaceaa38387f6711bab572a98244c5cc41e21aefbfc5abac884a4e45f29333b94fb44cf155cdabf22f6d353c9713d75a8442767b7cd2201e2062b61d0d09881a616763bca6e294a41fbec50d2d018a975cd6cfe99cb4464744f030bf8b2350935e70b2acfd5aead043aad8a5214095fcdda3edf6e20bf8339f03a8014e1d333b6fc152ec3040cb1aede144ebc303c7fee7c7078b7d393aa46bd4e4763913909d5e7ea3e36846d7505404d0b3da6366477f2db1e95afbe8a8fb30fee2d29e59cb01dfe767cc9b32df32b9312c9d0ea5c7a2e6aad1641347d47699e446fc1e0d399f5edb76551068585f4c6acf0723150651bea88ae217b88d0955db9a403d9ef991c054e6f2ea1ebcf7d7adf8c5b38b19ed8f20cbb7d5b1e014858a0e98414764605c174b530c07dc833d228019d1ed886b3f04c5c810e927b3b9d40bb2dc973284b79afc664dcc1dcd14ec39f64561d98f9b01cd4ae36a65e57b3f6661ce30f70cd334d419ad70fb48ea83b0d1d0ea1c061a06ff18016f36e100f841a3554a92466782ac12529cef772b8f1a237953e0c1f86b1d6131514bb3c3f81b830fe68558a3d289394a970cd743ef6b7a890cbf4593c80727e417495741f2952a698c8bf8bdd446074d958065e68507c46b0faf850e1e6d5c35bdaaeeb4f709bd17a5caa5f7b094542c7c6e5cfff385f25132655b12bd57d160a12badf2748f282cef331352e3f3e6a18ca575b8fe368860ea2c17fab5099daa39ca7ce7dc87f0def3f07edbb614fc465cf1073c0f113e3ff94e5387718c0f412933af0a593bda8bee9c633488236056ea49640d1a8f2c4fcfb04f1ef9544637509acc08fc2bad7085787e60aafeaf007466b983c24da8865afc9abd30e5299d028722fe7ad050fb1af02949226c22245bdb86e9a28c59b553cb81651226e94719db0806581c6dcc1370fe06fdd3a4d5de8c9bb0a92983e96f6896186d6e08b619a43b2f36979471db811d081f6ce412243b2157136eab3ebb1020b085aa4ef5170956178606b16a653af1f85c83785cc950b5d42a07bf7e5a434fb71b5979b83ddf52cbcb10b05a361251f9810f03ad4e15d87e27755b546641012f56f8cc081ace0760a8c62ea2edf05e91af6a0cb64a98f89755f6c1155829b331d035c07e372cdff9744e44e5e6091f567b6b90f4addfdb7877c6d19804881a68a0376a039b02a8dd6ca2e6a2d14480afd7738cdfb57f0e5073adfca7fe2031e4c9685d3b0d6fee2dceea0be80caea64c1115c08226399806ebd6fb0e0a234a3093f701f6652c5da7d2fcc8f74cb40422f5eff94a03030200206e6204ac657e6994c63d6399640cf5a265f3ad027e555e93d74b793d6adc7be5a238388c8dfe42cea0f6d4565efdb89bad96c77831a6b9299c17ac4727e1f20060918a2de649358b05c98e4e670d485fa814f289113dd20944b4454c7d34caa94c1669a4b25883e5afcbe419e3fd50f73b11d41e955fff9ebc4344892bf11650b1ffd8946841578749d64c9579a628d5f09870f20750df9215a40eb37af5a7eaf564ec28438bb514834c2c69960217d585194a31a5ecc4b1c945ee4e09796fb2d69d9f6b8c58f29b5e72c4de221b1c5df8060d83bdd325fa7f4af61cede33ff97b83c35d7e5cbbc10277b52462a1c06e5ac28f6ef47c03cbb39e972fbad716dcb09109333c5f789b1bb65502bf85af6066e7f2b56d16256f66e83c47d95d743978dd70db3f4437e134d696dfea619fde3890da74dfd760d6bb50058eda94d55922ffd3aa3dd43044477f35bbed87e82ad224030b3d78b2c8bb46e61a6ff40f25f5820937a20def46242ff7c27d59bb8a0f8bca2ba18fbc2eebf9c76f3c9760ce5dd4158da963fb94203f98d3dfdc5fb5a0a302c4b667de1ccec31309a30dfab8555ffc944eaf04ba8e54f7b291b6113fc1ac00debfa4ea2e824f5ab3ef1dc248eb41eb28129fc41c7bc11c762af3f54889df5303c491f57b99e759be4375212d9ea3e0cb41b99d71de2ae103d294ee6d1269585857992187df46df3dce34a117d4a3e77501524d866f805176eb841803f2cf16b729b2c33a23574512a736a66a40019312f672a40daa5bf05fce6bb76e18e7d0db38839e5a52206bc8dd95efd5fb292b0c8e18a4f746b99b90390603a871cbafc72fc5305ef92857fe293357c36443bd2742276a1ca87911037f5f653c627b2c71c62c7179f973f61cc085615f387c8b45c761ad403dd000aaf79e8b00896bf7905c1c24a5cb938ce8af5c81d2460747547d2d09feb53b37c5f18928d51012ab92b7d7223c7e42c01076a75aa2ab8105c64a3e9ff31200a6e8d4ae65c5652c511e96df3c9dc66cbe69add444508ddf7ca907ba0389f39bdb9aad024004ed3fa8b5d4400c043a2d8da5a84b7a591facb92c3eec408c684b4a4d635b59a6f8d0cdb74d81b24fff6f8bde7acad2b9ca506db2c27cb555b57a68def1b6a8e21a8e386284a03524aad0fa1b7303d28e6c70286cf317d4965b91ba57e4d5b1ba76b8ebd5b3236133336d28f365d657fd41c90d032ecf022095594a407d9c53c01c5caec79374d948c355a066f49213c2096250834f83d32e5bba3f7c72cb0d2eedc324534ae278cc6fc9bd13eb6ad249d98fba57138aff521504010ab1fbd2c5b557d05e973376a1bda31cc3269885214a068a31eade475a5e21b67b247a016c73fd5a493e7cc8041a98015e20b00472ab544f568eaa59763ae23b9632545020f802916c50d37fc7af2584b55885cbafee7981b56932abf68dc58ffb82d550158d4853802962619760eaecf17463782804c2142e3a7a4175f4d009383d3c57beb2d925ff97f6980fd0e7cf01b8a3a2eb32919a857e33cfa3b01663c49a6e4bb83f98ff706ce89b8e898b61f5d76210dba746d05fbddd21e09d96197eee8ec89543a68a247ecd88bbdb3a21d730bd687b7f57f64e0c3608a165d20451f916dbe0d0872637bcd260414aa70f8b535c58864bce0530a4eb7b4eb034717c1a5e3b6ce556ca2b0eaeeae6f5b75ac6a009c9285b087cca6cca166b7c35cd3fecd18e9c332988e56e896e7b775a24d7c201a79f1e34ec2b53eac816abd24eaf31b56266d788370b74959810678e0014c6508882dec727d409599e2bc0a5b9459f8fdf9d9eb7f888140c68a99871f1ee51fb4ade055ca401f3ab666d451b879526e20de9f0f0a0d3356243e6f6f08f85477d2331c137d2e3acaf8693e88619adb4658d73af109fe830f4e5ae60ce6878d0b3fb2bd58d337dad6718e1c5b943d862493970a7cccfccf3303ad786496af30508bd51185cd3aac5cf305018a9df7a466218c057fcd58c94903a716329c6b7750d74f51d29b96fbf753e1ceb7222416248a2cdb56f96849574a9f728ec81fcf1b1b986320d1f0209c9ee46b6297341f2570de7cd219b93a5ae657d2d6e96898f2fa9b92b810bdfb6991dccf863df8e33cf2879c0310e6ad6e2a44c21b01ae87e25495dc7ae1edbac92959efac8cd8651b591c1abc2dc5d0e123b6f1dcd3bdc921324a6fe0dcf7cee204ad031deca4459cc1b814f0dbe5f7e5bd6f47c050dca5d5cb345aa8bb276de05c22fd10aafb6df917efe390f6bd1fc0ddadbf9acc44a05559ab571b5297f8f2b08d53efe5676b7e25cde54526f1fe7be11b14cb4c574b318c3a4e80d7551a75c6623b711d4262f15cd0c55f1b09a9713e47e0342a61c5668f203df5f705586b5012bbf93b5e4d4aadd0eaef7c54292993f1bfe094a2e52b4cd19c48b6d65d2989b659cd6906f42c56c984f83054887e2163af1ff52aae926597157df8d9af7a517bddb130dd64c48c039acaea2cd3a681e82b02a41768febd9c05aece9c425620cef800064babc6f87af733dc87451733cc9d8f54c7155d5d4600c08b3679c870fc55c2c0d588da96205a387bb52456aec447bb92d45ad991bd12d534a3cdf6c492ae1e951809ba2412d10306f5c4e540402a0cc9545d8267da281b437cc9585da8bc24d6d595094397bd1dd2d537e57857d64a30d272cbd14150210df7d14e5207f3527574c094fc153719debeb3de3d378af62a050a63efa7995d19c3405c632136af439c18de0ada83ff9a7f27c2f8a5e44acfa9898f4704a79f003dc019578f0ac754726371126be7db238381b13bb47c462a8ec27ad3393ea91da0aaf7cbab9b91e560457f16ae95f311999d9ccb1d8fd14e2f66cec574d7688883039a2de4503e0f9d078a330c83a7bd90e1313c0c79d63c7c0ccc781cd982a4d9c0497507a99b77888a8667911e385ff26386f8c11deee5a3742754219469cd54df23057230dd75255ce3216943959ac113c030c226c817655fab1795291eb3b94819c941cf9431d3685c8e3b4e217e809bff78be5950d0506180f691f7d0fb95c0bcf0cb4abea26fd370f4d126661883bc064ba96953a6923f7dc8ff9224dfc9d72ddf1b4d737f5b00147b74ee0d66848c1f545d1c0f64d858a4f96938d9db223fcef5a70bb5572c0b3740bf23922399c15ebc05e4df2cf57a5ce60bea0d520110f954440d5f9f55140e6c619d1669a0842e9be19265b45d7545872e5ae719137f71ba89c8e97cf8968c6b35f0c10286d7d8eb09373584ae1f3dd7f716fe662fcd684f88e6823458f188b3dbb006ae303ed92a0eed725a49e3684e7fd8644c831eb1daf46bbde7dbbc49575406784ada41001fabe103c458382415f5f4d79af59b4f2ed708de1af4a40f6954b952b5710e8f6b4561d109cef6cfe62dbb05329d388904516f05b5e27ee633f94595ac532e8281aaaef85bc9ba1cc8959eec1d7f850f624512af45d35d8fd6e461597760902b59dfcceb5bd633dac25f66c2d2ccb4e044e3e1f6be674045271394e708cc673baf4c6280e689f6110ad37b839539316f3a707c3d3b77412cebd2d190e39b82d8923daefdddb6aac1d045c0f1bd8fce9ef8be4aab99ed3eb9bc44f0ac639344e7a94ba115aed2a739120b0c20acd0e6da5e346b850056226b1d2c8ad3b52d105fb77d4373df3b1cc489aa795628cac182ef7aaf3990f6e6552ef4ab3cc2b22047648104f475991c957b81f7ddf3aca992d069c0ad165ad5d7fcec7a0a96f5ef600a87e3b7f181bc814f3ac8f51706f4c02b514b415f292da4f115a2190b0cccf2eca4bc0a17965a97857ffaa926965b043551e5c51c10481f58a31846d38e4b5f67b80b949f2e5369e7b7303330cd6dc26c97b40faad4d655eee229a82a9f14e23f7b150c936eca7dbfccacfb74a15784749352889801b997cea38ef23dbc1114f1f5cc7c605268f015c36ba3190485a1a8cd355ad77bc91b8ef10edc0d62f5ab7757be5df856890fb795c9cea8bc2758761d5e3e5ee4b4b8fd1b192ffe31721c7403d271b182ee816e59ae5e8621fbe2f7c43aaf19920e364fa6946b36e612946ea2283f3481e1f0a2bc44dccefcd6c89fad910529bd0230fef39491ced10eb9e11950fd04cf83073e853b6ad13f5751d2ff81060a1572dddabf8e941ea0ec50e5bc34f3ea3372f2fcc19884bb263ad4f10714ae7e484d8c64302bd057170065efef8d02f22d89a9e905e0177421ebd63827ccca928de13e837c4b97aaa51134692a802a464ca8d9487a56532d08c5e6e6463f7bc5db1414e1fc7ee661ac55cd436f29f21e4a8172bb357ac5f37018cd49b0f7a4e89ef1b41e3aa0475da01947df5f522ed752f1fa4bf4de942dda7b7128777b42f719ffea5a102e8f9d42a93c908f04d58f444470e5b8c3190dcd841dbfefbadb2cb8e8a4b87240d2814635602642ddb540d055d0315511e60aec3b04fbcf3a934e845a504f17f34a6030cafb1f1c33bdd7c68310c8a663bb2b95556c76491859ac247d838d492f3842078c439621ad3a6ef88acbc32af836b5059e2b1b1bc41f376d174136a22a062f3a625ad8a9818b08f252a475d151f7de20e5727115005b9081a923edb4a4af994f59fca69ee72cf6bb247d87dd90670262e36edd86439c8d7eb4053e25151727f47214573a049e1fcd6bfcc00738aa4236bc6fb287d0f701cf9f7b937b0f7276243c221ed63256929b275a1182552d657b9882f59e46656b9dde1d2e5b3ee3a6de9b6d01de2a9ffd089654d06c5a7c133fa22972c9dbac9a7a16807754aca5a377b3238a87907e9b3ce3114825b4172fc05891e2fa3ab61448bb8b4a1ae4f325faa5634bc816ec2a5da04a95a92e6de47a831b1e2ad837f57e2623037d060edf6b3db149b5d50111df0c9b68619e49b62e1ce43d5f0dab67d70ddac5d3b90112dd778a2cd21ee03e365b750d51893b7f8cf0325baff5c0f1f7ab132d3f4ed6d43e4818ccd307ed4b85ab3ebf0fb63d7cd24a1b902b1bced4edd5bbcb3bc4a9e3c6e6870fc4d73b91a100cf780eee8329bd1986ea8d7f25164886af24719fa33fb959d10dd80dd854b1f25a95e68bbc16f338a472a59cb2dfcba659874392cc8ef9e1b136932d15f5a8d9ac7252398d51445b8158d200cf50ffbaa26dc499235d8885d5d041648afef9d94bf5d24921b2db73585cc320373c51e1cecdb3cf3f1630c42fad42bc53f70f2d2ee6ccd958c1c9307a58312a5058b8f6374ec217a7b4cf284bde659d1481a542686d98723089abca1e1c252084b55d3d05069be299ec25683c665fb352d4edfa4e419574d93f24c0b5fbf5b82d03042fbc165f4aca6110d0d728ee179cc5ee67b99f3b9b30946cce7790ab222c461e8685354b191675db0c5c3f29cdae0adc1fbc7c9ec2298c2d626a7d99df9ec55d20c32249e7fab3776ac4943a83acc02688bb4282a9af5c87848bf7278c5242e9dbab61a7de89b2a6c796f51e59e490edb17db6c00a89be6b0900b14e345eea6b4ebe09b81f5db5639a13c6b438bbe6ae2e0975744aeba6ec120d092e730ea383938cbcfb24c38cc260da3425ec87fa4282640e30d3b3e3a50c039c040ccd12cbee2d042c7a7318622660b13a02b5345f189200431e096e9f0d2a627f7fb6a37f544ee2b5c76eb50773994519a7b95d9257c6c5300f046aa41bf862804837ac836bf0dadc3697708749f5806122ed268e93b306caaf719fee26b99c99cdb9e62516ffaa08f279885b68ba1931e2c162b8a34a200509c3a21f832c56e29aed41e4c0742993b1020f5d2c459a1d09fc082a4f5cce2e188c27ad526c884186ce8bf7446519e3313fa44cef1a6959c5c1a5fa43077043b6ba0ed0d3128814d01d3038366b07b97401dc7fb323fbeca2f114f59a98f13243e0eb7a7a003836b487067c98eab7314c1783073162781b75e1252b749c30d6bdd09ccbc0bd8a84df899f24831b0670db0f0f8e461e0539a3dd94028c251035e6c07f770e4510ed1c2cf01708947272a3de3e49b26c121a221323c1ccf3f774260da9465245fbddab29227dfbc6f4f454157feeda2b5516e54f9a5aea71e149c27af96bd5a3ae715976550d3695ba732105f6804c35123cf15201beb4a8093a8d28a50d262d063222870d5dd1d9bd1fb5b6b66e2475545a025e5f628db3f9c91db1bb99845cc8fb140b0fbe203830a2833eb137538cdd9fd4b8d1c3cfdbbea4c878b49ff3aae1439320be11157f68f3abcad9f6f43214a1bacf1d4924fe22d105a24700614d136cce763aa5f2a390ec28b05d3f103338e2bc7f24b362a00f34da9be12a36768ef582e438cad3b1b26a7693e96d837c3eb53b805dd6386e92a3c9e478af2f881de07ac587bfd469b2d5181f2a9c2152bfc3db40bda619a8a76489c601a7d3bb8cd9bea3862223914ba443ca754a068e0d81f29b69c77d30c56ab58cbe824537f99fef2e65978b52ddaefb5746089918d1ec549c64828e7266294f5ae88b32174277fcaeaf5932d3a4dbb63a22bc38822d0ec7a8553cdf3fb9ddc17f35a998d613e793c0ed3c0663596f20b1921e1c517a69e2554b0276a742b165303b57017e06830eeae57f51fe18e26104927bcfffe43ceda5a938b0a978386cfda49e8a08efb0bec38e424f0696f827d3c8a2503b372ea02e80491a2f1d0cf00162a90fa3be42826c9672424778515f00e3ba56850032e87026c72197245aaa7a3f2560159714da1bcb7ac9ee74e05835a9073f59c68f692ad4d885fe76ce921846d77e54f1284e9ceb9eee0543f7c38a9b5a0697170e43280c7be4c22d8036db83791a27734278c938c76a78117964a0a1d0019fa0694715b4ad2897a3c47889bdcd6584ede9bae39823f9dd6277c8a3510217875fad86f1e7d3ef0a462b8521a1b0717adbe8ba8e6ccaa3a0674e1de56d3d2a7271348e1b8bb14eeef5e60e2a445f09cffdb66bb80e81739984914410c4ecafe03d4b6e268780c951f7417a2d814292c9c0f1f30d40f0547df9ca182100ee1b2844b78f7e2f323c09db67ddf528167bc45bc5024ec8266907f052c80ec5c56eebb9febac8f055b803fd1ec03f0bb4f6c365fde105c965febd598a9be74c914f0a34a218e96095fd14e079d2876593f0e10752d152fb835fa71cc3449de2309a3767e954a4cabcd3848d911e248977a0bbc65e8062254a42a04b8f98da225db046e47771e62408fb435f2aff4468d414dee4d6d9c194936b780dd585195772f6616a507ff62b89e9c1dd241c46aa208837f6fde3ab5793f6aa9d6c29eedd249804d81b54dac0a9b89e0ff26cecb9d35ff9a4a289ee1c50c3cbd264add4ec3829019f5c2f5b51070729fb6074492182767784e6afc545244c5c3995229c69cf421e84d14e99de2ad2ef1356ccfd58b0f1aaeaea43d5ca7819d6bb0be0759daec24c82672b1c32698fae156e138d573a11cc9ec446dfc49f48858ace1d9de86736b34f5485389e910de691588a5227ab2b93e74bec50b23b80d8e493b5f51a246c902ff629a0e1754ab5a1fae82361e0ac146deca6ceb0690cf61fee59cbc2535c1cd365635e7627ddfa3714106e553002fde0eb3d436c417edf216c035d3c97545bbfc1c5ddaf8ad438a2be175fec3aae984137474f7fdc5a8fc65ac2fc59fb36e0e5bfb5c78c284e4926cdf889e7442c9e5cfa4c95030221327b20007d9ccd88a1042496983ce0189b5b18e2d27f5f6e84589f89634c582fe9a65381c6ad584091cab5ac53f67fd943f26e65c3fc65340ce3b6cb06bf7a13a5f49cbe7356b1e21936d2600331391ecbce87cdcca9d778a4f36df27e3f50355b03b2c23719ba5696f57a3bf125cf7f82c09b53b32f167288a158d3ff02b83140a1d62fd3d03ece1bc4c802e2f94501dc9d2e6c99cdac75eac5a4b4b13c00528c36f49443ed5278d83e3bbb1d96f7a4e36fdcfb44093692d93fff8a2e1fc04c3602960f4aa1bde84ab5c6662fc6706139f9062904210a557127128d0fbc7f0d172431e54ad3d90a85f49545bd28eee47e9a2f328827f4fed8c14469cde769228fcbfbfcd63d5fd00cbc086f2ccdbdafef7c8fc76f8383c9023157e362824365eb470c72973b876974d502c5681b9a7ccb919e5ca71dd14c00898d3793a04a98bd9b14a3e5d062af3febce1112e2fe3f7884cbc34745b06d26bdc177b4d1a661cc19badcc148a91774c181a15c912dd3c95bf8e5f2080da8819e2d0152411247d1e041d9eb1cade14ecfa76afa8abd61229277c5e416bd5f98707b1f9de941807f4422db3fda0928c8081a710d42cd9af98efe59fec0d4b7fed900d0485f171cc87457e91c722c09485547470969ae7b290ae09f25b9953511c20233dfac214228d7ba8d313301b2609a4e36fc7030216d9e0b88806fa887202d43b2826416fc93b34a124c9aed737eb4d9d862b924627809dfbb4745065a4ff8ee3dd43f82f34d9f40896b42d6b0963e3d9903045e6feeac5d8da31b26a3c5ea5c073ebbba85f7be93f5d4b1f02dd30788d26c7165ca8691d7272e55cc2c197a47ecb943c42676b166cace50d76575f405691a4d2a69a2543a00a95ee6d521abb7ead023fb7da06bf805547d3e9fb5999577301a02ae66cf898af4b5265eee912592210b63182ac004a7565dc79dfde101e5f42ff73f2b23424609764bd4c9c7a477a3950444970b5dfe796362b2b7005f26cd70e9b525083365068618d7f04f0bea44648cf655d3a9b648eff5dcb5d30694745ea70807832d95d0944f11413e4afb86ee28d3cadb1aba2b9908276b0e1888d40f9eb5538aeecf8ef210b304aac143273e0c08b9b849e87d79d980e8c06fb4b87321cb7c3edc144f986b25135a811079e7b27cebae2ec6a35176b0ea17b9e7dabecb55a9b63a193678650f64b559dbc4af4c252749e1def92132efd2087aa2cfa16fab3f8005551365e381b2bc09a74e7e5f996c0e61316aa406a4e95e03e1bbf38e697b539e666215ec9cd8c3279b513853fb29631334459ba66be43819ca2b47290ce01114ccdfd766bd93bc6d5cf62cefff680168b1e18943433de48095a83bc9870ae70234305fd415ce7551eab27566af05795f47ff8c80bb28c1fb1a9563752e8c1d7c2c0de6ab4d3a17128b1c002e2d693c78f6fbba80a163742612ebb5a5e706f60d6778307e1040d73f854e8e60a73df9e95ed5f9b05db528bbc919372f954d17c04522b91a3671530db47f780ab0cb6597e94b216fcdc32e43cde17fc3e704fdd6089455b3ebd6c91d9019b3978a0d8bae428bc27693563a1030b1cd6f1eaad38d375fd62ac73cb2afe92fb34915344ce877f0cd44cccf5a7ebcff0a212814ea52c165546e5120d94c0e5d55f0eea0258d5b3863a3145ac43276b96f67e3dc5f161939389b447ccdb270d49a091f4a196207f88a0c2831df14ed8306995c9d2c33935cbe4b3fca4bf3164bb7461703fbedcab8b0fc6e05b32894a548269e865d582f1ba06b9ac7795e9fd576a9fc1b27993aba51a0515bcf0829f1520eb6a93c93cc34c5bbeb299291d16d8bc840a73d374e2a928a546ccacd922f356d82e91eab51e8b194057bb2f3ad0f2b14c87752adfba51c59187376a403fe4166b25559ceae1dad27dcd6bc272c2de683f897b00ee79ff8a16c81c655dcf2b3d4ee6f935808866b5ac7ac17568e93c0e5adb5a04723f75b58ed47ef6abede85dcc6b62a8e48d0eb62b9e1f5cbecfa53a0334325632a9ac40220ba7251a3608de18cdba6dee4de9f59a3fb48731f11f970cc7e56561587057d79db80e5a8b448474fce5c192273820746fe6cdb801e0f46722ed315aede16a816a4c1e1122c14dedda0029d1637d818e44ab91680e15e2e8daea23e05b10825baab7e9ea7abf928efd7c68fbb29c72f610a6173c1f7020e3aa01f8d1855fb0813ad313cbe7e251fee58d5d785dc86e65ef4b18dcb07015969495ea7d0a962efa351362cc7dae0e7665822cbe748ecc7cb54028c7c7be213808fc417d80da9c7dcb6120233707b00f101e2b3fbc3cbb04d45c9bd64cfd5d0eb1a3cc6969a3b2fc7ee1e278da93dee219b558bbffeded2aa33ab29f7102c9ab95a7b3dc5e0b6a55a7d14bf21fab5617702e99542beee2f5f8c0fd48aac2b7709825928326002ec46e6147e2ed40378ccff2d0cd563f7d90c7fadf674ea214d25ef050259e6f5037ce21e669b501bef6b93991841bf0e4e2127e2e253d5d09f7928d2d1fc7620c9e5caa62c9a90a4bea3f8d7f202b11740f092b30758bd8838bc88346892cb6fb91b074a485103b210c46cc0884c8a1904274884076d0e9cf50b4063d140bda9acb709ef84358e2554a40c8b1e0b9f8db30b055c53d2bb96fd8d31d416e5fa9cb43374f06be975bf32c3f7df6b741bd8866966235707360c9ecf8fcbb0dcaaaa1a3efde4a26be5f7d3516f7dfabd028dcb77f52617ccc51ba184d96152ff8e0fc8ea7daf84d933cbb474de554b7bc931b1064f257e31fb81b7034e9b0712642ae61c5bd26ab738f99a8d56571061d70a9b59957f35782689a1d1ac22ab30d0ceb4a9cc4ced6fe0de3cc74218636652f8352ef1d8ddadccf7ec04e3041ef76a50b29b6068bc1ec84fdfcb81829e114d9448bc292fcfa9c53bb85b986a2956439b2797c76782f538074cc5294a3c1f84823cf34b05f3d2b9714b0a6c34b80f09811decc1dccccdae3869c2e19d8e02410dbdfc4015834fac3b2ba53b4285882476271255f9919458f37dadbdacbbfe156eeccbe3fd937075f67bb1042621bb0252bd7c1587866c8966fc2722c83a097ae09b6a1bd0c6133b3bc7ee2593756cb7721b240955d4b818621bfc3c45a30d79d3f868d4f77fc629bc3bad7d056312e0f3fea2eca43cc06d50c3a86a106d19d7938d541fc786a94183fb667a99ef28c57e79c4a852c8ff70162fbae938aca9b03f68328defa38339486d716b29514326155596f59be6fbd420948e0d7ecc37154c2823e16204ab81757e873ebcd09642917eddf5558f1ceb899589eb877b3bd09b7e51870324c6b425bdd33e0166b17dc7198945496622283d376761fec17c3962c67cd92c8ded3670fd321719670df06c2e85881420a4c373915d7e3f324631d0023eebf4681eebe3859b9e3a02971a55358aff8fdc0962dd65244bb89eddcd3dc56be5f2ceefb86f316d9f961371bec2095427a2877d5a2deee4c396b2918fb1f407747fefb5d515df74519caefbce37ea8ecc34f4f95363575b0cd1015abbcc122c1eb16ff3d0b9a976a57adbd0b93df97aae70022431d61e2aa90fff1d75ec8bcc79f50e9ab7955db3fc8af06135c57fbecea469986be5ee286984b7a0dbad3b54bd21ddc95cb71b34b3f1d898eb479dd7d1d86b774cce2624154ae97ff91a7e13b987f3012142b80400322f5b1e4bcddb3f14a763a73f79ba75df70744e35c100abcb93c9871ecc92fa1e8243f077549055f40ac064c5c658de4f9b59aeef8934552af8559fe5fdf59a786fb9cf37b68e8a7ebd1c590b0c91bcd6f984a4bd7773a780e71f3918a88ea6831db4cfc38bc29d8f5ee0c7d17cafd0b1c10485d7a69f3436eb7be4b4324a6173a7b4fdb87829e8b261eac1717ef3bd7834bf607c9601b4bf8fd98602b22acbb2877f1e101cfd0aa1840aa0fb2e9c648eb08270a8885efbb5dd0b46880b065283575b028fa8b63e13425faa413ede4de5eae92735c69cac4cb84009872af006150d74979c8231c9a51f5bee495aa486b8b77544d9efd21a8c11b5fccda9a441b84e8a2b017c6f1c18b9c97414229fdd7d38e1ad3e01b92e4a3f543b53cd73a2638f0762be71443f672fad7998ba6f5906830376ddd7465b1a5a007131072bc1e0449722630c3d8e90b7621a41d66b954943bbd0504ac31b6a795e2c600a13a157405a85c5821c4e713c5bbea3771174bde50d36d5df734938e3a9341b132180ef082ff68e01492f4156f71551778ba4b78791bed02368955df0133758b491cff27e1fb960f2704d3eea8e4e9cf86f02406a9792a780f99443223b196a85e68d8ba56d4f2b5297d7a4813c2630985aa2162f900a8dc2957a6a2b9b2f3cd572d62d8c786e2eee6ce977433ec0ee0487b44acb424b62ffdcba1db30fa164b760d649f4d590e905aca4f1ca20e9082adbfd3217383d544c5eee95e1e3f61924bed518dd95f70e2d1f159229b47aff86716cf4904a2671751b9038a5a9e131fcd842530c8731b062baab50ac0e3c5324bc0e58a22b6b918a224bef5dd327ba050cb2a077ab8d88379e621654e383c9eefef5160163292a73b4da05e4980a777298ae7583421b8c0eeaac6fe113ed2d1d002af3b7ac0b69016facf19a31967437e5f9f8ff14bad8e140aa53bbf32c42d6e5dda3f08dbb102d3946ca284a61e0489916e6e80f4e3fdf4fc0f44ff3810c0880f668d11db8cdb107b3910c632d341b4c82582c020cc2e091c01cd1fe150fbf6474a00aae8a79f03663cc23f4ab81957418f6be2af92ca7e508f12885d3502b7a30b21e13892f0d1d2396d3f013d9b08d6929955ef0b6462027d474912ce4c429d2bc95a9a5fa8518a882e4be875db81282ed9e88bc7be5470b1c4a9374cceaf42a4249f8fddfd58ebdfa91c87a24464d5f4cd20243eea3fe490f0d09d4ec2d27d6ebce8bc325249e74a60c953018401ebf6389fd6da05ee8f7bf4a8b8191d9427a6591b3dee9369aa2a645c80067666d1a102b92eae69ee8fff0bbf79f6a1c3fb2ff68c8fe46e69561621496f61591464cfae010d7922c94f25e0caec0571f16012cdba23010ab54389f3bdb9b7a9ae16b9c694150ddfad7f7dd5b13946bbbe4bec9ca327fb28e4267b2c09c0f8bbeddfc8636dd94147410b5f567bdbca1895ae8807e6e4a2f12019f640d6bfbfb5d2b046a35a8376f59f5cebc78b9de0f0d34c01f1022021a903cb87c694a8d56d09807397049c06aad162e232d862bba4abd67b2510f2fa318e3ef94fe1c3570d467cc3903ab6605616801393251b5c0689e5ab9efa36627107bd06f3e204bd9753bec008105984fd77a1d71634ec98075fa2644b84ce8fd7097a12b278c9f4705c66575bc69f82a3bf9082174cc35dc4d6c66e3ccd00fb3bf2fa979cf52692d8d94ddcd01d1ad1bda0faed8b761be0be188bccd6ff0b12f14c704f405dc514481d7ed9b4e2829ee8799265a50db4ea1021aea9011c4ca217b130a44bea670ec6e3be3dd43507d267d2b5ff22533f7727eb925e939a2d4a99b80d029b5255ed7cf6416946f99ab9c3f64d53c60aaf632852b289b2b087f68eca33d536b1ea802264de6f572dfc2cc6d811145613aa207494fe3c96e03604bbe6ca9fb3b247b9b880924c220d5eb6d3a923352af15a74872ca0f9e53772368044c0d850ade3b621c775a5bcee8e574cb367e17096679d3d20d278bb9db7175f2d01e8f402a8a47f9a32e034c688c2fc99ac907a847b2f8eaeece3efa4ad6014546ea36401252f4d0c1d0fe7b0a09ebb48c8543834667df0469d40e387ce2f62fda2960ad7d893438920bccffa13c42ec48220e6987888267eff2e02efdac90ad3993a01378a80e060b8e78c4b8e3f58fcd4f13e16e76362683091a6f73b605d79438c9cc24d2d357c2b1419f0ba0667fefbc3db39c13614a3603891d6477c4fec1d61e8e3eda811062bdce2351aa1b90810f84251eceef426a0c89bc3e6f3762680c53b0f4d543c9003b4c67405ce990fab9f0e1a634f25a58a87c8dfd4e865ab7aaf195a30ad3ddc571c593eebd387029619ff75b72fe8c1abb11d0bab25e9370a660ced58cbb10659edd08f01f85f501e98f295097fb1aa94bfe065888fa4c69f5f01aca9a18a1565c9678dec61a7c723cd92bae52162d2fc3d23d0af8b64ef6b06446b6a7ebe10c2fc9a3148614ee89955af1f811a2b015c9e2301bc17784fbeead693dcd35f9e9f4570fad3a07413c43753312feb21396039d77db5893e1a478b2e4eeb8b31784c59521b53f540fdcc69a0d53218e06a6b9e1690f23cfc19d6b98bb975d0941ef9e8983a1b8cd394623c4103d3454665bfcfd1e49b4e48b9e2b0bb89885e5c3ff05352e1105fab873437a4afc94520a3294b010b606dd0aca46994ecd9cfefde87f43b4ed11027ffb5802da9b655c913c018ffc8ccca5e229299df09acab14e73406c5c54057c029b549d1a10bc86dd30b246a87ca7013049c5f88728c38621f8e0375bd1124bb6639bc35e8f9dc1b15e3fc67cc3292ba7bce21f0a8b29c320203c7b29f9868ac719e6c7915043f26d12ae3ebf30e8dfa60009f0ab1e9e370e51b6169c288edd7193e301f25a084c82a0b4778ab5c950f73ea237e627ac9f06c8dcba8a6a606cfc3597d9d065d5987d8e6e175da06d27a2d151005b554bc1bf5ca6c3fd6a5120e9a3bfb838e5a1c1ef0dc33471d86d32e45b3c3fded304a4459d6a0473b48b2c4222f47f6b44ef38345f0fb91de916c20dff8f433af07cc5fb5519c0e41c17b84f0c90ceb7ac6f74f37de61db223d11e7642c15d32c1e7b3068b0d5186892583a5e57d6933df7ec1269d5b9f78afcc4a681a1292fd10bb340c6029fb788c0850fe59f1ff329b97ada5f2037a0eeecc270ef9ea0e2e2f2ae0c74e0b5961dfaab8932a15a4e59d99e7444a3084a98fa514c8f527b1766dfc16fb0cf5dadfb18bf6822ff809ccab3960787cf8fd80d0dff64599e5e7dead033062a1d73ff96a418ed35945167f6af38a3a5b0dac884d235550633813eb4880363ab31ff74a3083786d4977acc89c8b9e1c50e4d05fd98370bce3a91b1504c4dd1419178e79a3a4fc10df700dc02021cc0b1c990cfe9fe21938137afd13141dc7ec657d21a01a3c0f87651608d1da6ce99b41ae37e05f2df2511f88d1c5b40bd31733027ecb729282eaf356cc1b6d6a9dd1109a2ebc28c8a13fc89cbfad25a5d68753b886b3b619739f5632e02fa11242b8776b4a2ac57d7b21b1364aafb0a9798a74fe8f833c4c9b3d1c3078740d473610419b5a20767a7cb9ad0ae7c867a345389029ef47a12d05f9e6f64430df7eecaddfc9e2eefcea2284625208a3aa37de86039551c046f7d9d09cf60137f4750037fee97305c0f57bd0f9b61ae895b845a736c3bd74763dfd5e335a235557e6410916bdcaca94ea8ea54f87f42a4a068183bc3d589abdd584a338b44eceb2484fca445e942575c27becc5af3e0b43ad173f1c3aa76a1b0eadb4c2231874a0945cdd9dee145638337644b3791d016ec2baf6c0aced69dc49d5f124ba931fa907e789eb08212f6d253c2b86cecb030df3249539ae6aacf9ef6d3be9a4497d2aa08c212908d09be6ecea03e7f45a6ab57a0696d878d22179b734d836847a14614afcdc68278a205c340ee889e986ac7855cf9975628b00c5a5b3caa29da638e664f84d101caa379a7da6408fcb612049139263c7de0bb9e383702396b14e3099","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
