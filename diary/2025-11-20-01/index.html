<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"681478dbdfb3c7b5835ce7e834880aabafc8b82d090c1b4fe92f12f45528b84af2e65ce98fbfae6b86315dd8844efffc6439df206d690281abbbb05e0dba3fa5b54d7c3ff42e7c45835510930344a5c27e426571e9a2f4b5393c48094d3a0026d1125d3f4e91f37a054f5aa550f131e9f502fc4e10c4dfb2ebe6d28f1cc65739b97342349ebb27fc0b6aa7c0faa36a2ec272251b1569f9e1641a993b31376e22ec33043e66485af09c0130e9b1053b7a32f522c843e6cc26aa94fd8bbd5dfa38cde23f81e55f32a1cf4b48bab6f96cdb9aac6d9ea1f8e737009f27f6ea16c509d7da178afaf4ab2978dd93599c04240c927fe2d77e52645f02feb81ea01f6966bdc2317ea9550fe0567ae93334fa18ea2e5e9c95f9c5ace6d943d4f3d9ab566dcf5bb38c53dc1a52793973f265f9633a594b3c6f18c398af96c8fea8502f776e36479cef13b7c67a3ce102fb32eecd0594c4e8acb771bab3c61ffb1089fa454b919b297d8481cc931a72643af384e8260ea0a10ac7c3a96b8a3205378313976414d679c6d8e9b38ed07713ebf47f29e55cc3a85bdddcc5089636fa2b9ad59a15d2b2d9ac19a7314394f9cc34543a35a5fe0a8dd2897ced28a1c8c5250853473a45dd8a9a4cedad1879a44400798ee1fc91bf4d4b9d0e57ae9c4c003169fae897c8f24e59211ecc8f2947312e328bb69d4c74f541daeabbe6a5ec3be7c58479474bcfdde93a49799cd1b456e3166284dc44051a6e540bcb8de7dc51d79575919947bf1e878d21b5c2ae44eaa819f49f2816dc71ff190b5b1184e1509e99ea4e23718b3c4b5e5f66021da7158a38899c75899ca5869462e75371e84d4ccaa994906e620a81bdca97863c6a3ef65a5d8e9e0e622a7f2ab6fd8d913d2b0e9692abe6b9f199d6572dcc1c9fca6e9894e5a479c4980607b194385f4b275f521a412aa2a2b54f2db809efa87c86afb3c7fbd9bdc33a7acf3adeb57181e3f19b87feecbd91d8f4e6f561390702ff651947bc96bcff7f932a03e8b7cc57438966e3b4a0f44f998ec4586c5a7e4abf86d777048d07163d573559d09530ad244c16f293db9bc309471100f012d208744c5183b95a9413e546d51b55f2075a99768e19aac565584b9d35a355b4105c3a6137c4f29081e69983eda534abc9a87f06d598bc6fc4324e6097462e430058b8c15862bcd1d01a2bfbbeb51367acfa0bb12ccacedde8f36547872415430798e39c245694acbde11cf089de708c60f9cb09f30cfe6f9060bb2771769df4a801ec59789b31b91a93bc2169c215a75c7b95ad70d50e8e8afea653cf101e3b851a30509bdac0653bd966956d354b7ee421be3d263c3387aa230a076b76a7a8d363ec915840ac404332bcd9296542cc541cacf66adf11bf5e35a3fb3e4bb5cc09684e6961c69c92d5a02bcc8ed80e9cedb96d76c7c8bea3dea09a8fcee3f7e9b4e84d0887f177ce13038bbda57cacad5494dec1e8e9983d402779ab4feb84f945d4e25dfdc2fa3b3b3585b18a44bc907566f5335703e096a55226b551705c29336a1885c637a30f41acc1e9a7d22ff461b2e593fe066f2048a853db1460366fbcb470c2624b645eeb4be1117117b13d5dc66d6828ddf27740d5de1df956c535b14dadfc9296af996fe0f6194e6e8c080b0cf5b4c0459f363f39d1830e2bd33ee4229f44f565dd5d70a6c39a6aa6d4a1b7d34581cb10a09b63317016e8862138ac80054438a1266068182fb649c32ee06a825252416bec7cbdd2eb7c16f94eec4b83a800360381ff9e84d574ed849fa5f297c99ad0152d37fcca6508d847ce281edfd7cbde4380ea1a0dc1975e6a0b92bdb5af969311e976bbdfac9f515b7bd95dd5acd4ec6dbb917f7d0e4a9de285a4c93bffa8749a60aacd75f6d752678e2991d22129a984d935db6c7c6a397668b492c7220f1eaa33afca9a3a456b434daa3c96779b46b4b28da3fd4006da609cb9989c88229f8a02b760dc18fbd44a1537a95f9a5688350ae3effe53999d430985ed355e868ef374dd33e8b9da1d0ce87b9fd994a25d611ed190802ac8d3d4a4de6dba3523d4bb7cf897b7aadb368f7f357545b3b3e98094a9174046c72f973773d2f6eeb5277167fb9ae6ed7bd890b5f53614a0d903de769ae6669d5ce7a04e62a95a174a645c0caed5a27123a74be4f935dba2660c172183b856adfa382c00c76bcabc0fa137f3fb56c2aec371ca5aea3923e1b6b5f21fda11736faba0223ba84c74f620b36b4fd3c4f1f62217f04077e31a868ae73107efc70d4aa78871c2383db7a0ac8068ce2c18a6608ffe09e1999b7e9e4468b5020ce6dd6597c29e50700bb70cb788a9200373fe790ce4f01e24ce27b1319fd073393c4318b567526111e73b4b3be90c0d68179c6268695dda18910a9a2970ea2e1de637c709af99e993126ad83beb8f9b42c5d1c8146acfa37861dbe87bdce6349e5bb71fb9f44a1d1b2e96168072f8c54d8f4649e0340b5fe74735ffe842e35222a4a885f8419d838f6af0d2eb8848c2b9fb2d27fbb4b0d92f7fc8d5f0b14fb1cf9312416198fd4777aab9b2f6157a709a3f9723b371d1210695dba65dcc9f81b3c3b294ffa59c29c27dddea05a45073fb49b6ecdc34d20fad10f6f85fa30e1b2072b1b2ec55ea421545bb0cbe2e47d407efc4c890769575f8e2f88a58cf07f3431d67d9efce1588b3acdafd97fc1eadcdfa190ea18eb303e005e888b6bf8071d815824dbe05a283f0328f4563c456daa336559849b48e770678c19545602e8dc29fddf8a85d5f0daa880fac9ca154baff10a6d4c3eea0dad91b3d2dad3fd4443308fe2046b7aaaf2c9d062e05ea57398557b3ff5558cf4d2a27a1c72dcd08455eac33908ad742d72f2d32dc96e92e902341270087468bd6045214ce027d73289e4df3320c5107dcb9f3d58df724df78a7b893ba56b47c9564c732c99f6d688b889033d206a1c8c6d0a5cc3e0aa3e2e14e9e7c6128f813a99c4d779d739cd847610fe722c03561d5535bb82a5e2682d190f77e0cd313923dc9b4e2de0ae4c8fb38eb830b4c43b2f4e3dd2e8a7428394d717546f56a38cda63ed99814842b73f74242c4fcaa9e4a64af89534ad4340c2c8cd74a7c17732e6dd23de1e8b133532fe0d17381085adba2e754c6cb98aaf87742e006745d803ad185a0909526a61b7fb9ce7460858d6197fa7846e1d2a899f7304f1270b9ad84516df0459d52caf03de7e0506f86c9e9d0aa61f92bdd17c004f6915226245278c611f0a4e7d6a7917c7130801da78f5f8b829ddd28c13782e84074fae3f3c40a59d699c4e3d56a9ee8450ecd0eeed1938cfa4bc7bea250c8dabda48afd6258deed9d4d41680f7a49b6b07bbb823c07eb39d6420764649d5a57c57a84c8709e3b6d6bb18dd195210311741e0eccc2e59a6f373d6b3d6796427f721e1eb067c0d69ab6b2d5f3b522d83f554da9bb132d63c9f6ecd89540491fa01248c9ba7c7313aaa3b79534461c91d02d8d07d8c6c9b82da33c7841f3c74ae28d6a0bad943f00d8bbdc3ce534972ec8a7f90ed7b07199a0fb58241938286a10e956eb91de56c9464726a2a1a43a3b934e83774725c0ab147dc2622c1277d3c14ccabb83247e36675e0f19d4f7628345367d820fec0b93b88d8c6dcebf01e0869800357a2e6ffc7f363605ddd8cb6cfe24349290f929c57cf5cd8b59aef491ede22803aefea1354ad4ba84a33b4170d1f28a71417e3e988ee86d61c37a845c9a1d3d09a1490f55687cfd0abd672a3ae47e26cf094297a2abd2ccf08a5dfa7d911cd35f3ed70fad97f90b21ffd2206fa067e677758f12eec4d1629ccb2ed646a1868dbfd665ee5c1a09410766b95bd46269230aec2c3e27f5f8ecf6f0eefa74152b955e91d7951ef948bb24c381d536bd97a45208b26f1519621ee5c72c58188a78042bccb0f425d97078b44d9640412a804009dc0f9848fc2fdaf66032d5b6e17f978c1bddf5454238591eb54599080dbeebfde7e8aecca33bfbac01bc3a42f35ff4cd0999a9198ca39bac07cb138dd14cc52bc36920957cefce676de3cce4c09e3283bffbb02c88f1869c3384c9499aa0d363eb07194c146f5973056c39b43350a8acf83169ad730c8beba5b603ecab6f114b736f901cf30d5aa95764917de13d4a1596cc1f17ed12ef968539db1e699a69bc0974c6aa3bd0292dd96f10a5b43b92be89f343347f14af9d1cc341d48864e5e94305b8de9469a22214fdd49393bfce3a06950c2e3f4092d2928c22521951b7aef15ab0213e4348a75abf019123669526dcb8c5a2b5c3defb79e6d33a416c9f9e1135b473882f5a7148490e56dd327f6ca6e13635e7fe0c1a8d6076b7aec871b4976bbe4b2ea43e93c8e9ebdc3f160f0686389ee662fee76bd8c653f830674b005d53fec335619dc9fb9c0334dc7befb21a12a236a28c4b6333dce4d26dcff7423ec7e54ec9d6b80f70a6368d97cbe3b76ef73687e031fa2189c5a3a1c50cc96630d012526af07b26d78fccc8c9f4b110ddc1f36ba9288a97c33297d9088e09012a79465ec831dc51d318c42b00dcc93623fe6b4dcf7de4a282e4359a97fc0ce63c014d5c9d2b92a45c6bc770f0b49a16301d3629cac172e5a0e686b179b598ffc59396063f2bea11374be8eec0ad444ab2e31c7c54510488417d66938b970b91896a19d69c433fc7bbef8e1678e08f898ef7f5409afa69a1c079b9fe11610e16aa88977f24d38b0f36f4e1023a1def361ae5f9c96e28877e2a2e0a33245ba5dbc60a8a8a851359e0b48c00506cb201ca6699df2b5b02ba22a8d09065fc099a5736596d4a4604ab41065a33f7955445354198cc5acbd2b3ea76b559ceb7635f5c23e598e1c1e4b1bebede4fad5385a6fd61677019329bc2da1ced6a3de2a01fe3a254a1c6a821fc81600fb218261b59aaf2628549c00aaf8b3be579d0cbf5b62f62d92bb04038a86459260b05ef051e5dc6e6dddefa93863e39411cfa52e9e41a944b362ccf214712e537201540f908a788d926aa3a7b232167615968d3c9f19256cdd23ae799debaae9d77182113e82ff330ffad3f58416777308d88106185d9e45bb47a54fae2070359f20882b7292d5cb0945a5e8845ad92f8ea1a0ceb70481689b6dc1ca3506196db7104be4778545416650e9a775491e61ee1d9834c14b32ac96705346cb8dffcfcc839704aa7a6642d8f07e9bfc9d0b82bdc05d5041c3a231b9467c499a412e9b3d05450a3685f7fcbeee2dfea702521d6799ab83ba2730676c5f404620f1eabad300c4a984c3ac9d905ec597318f0d9fe36b10095b8238b1915bca9e7f76952da01d9cd4290cc3a362517415714bb6e3951f46763ee9c56f6bd11b4f761133c042250e963ee754e5e0da8b6ab412bad023b137f16baaa358c7469b85bac5f6bcef2b7f234f13e744663d58d6c04da7e57301be6c0bd942aa2420fe1635a23447be439d7d151e5a6d4dd5c44ba9cb5f6fe17658826f03641e59733337936950b9dbfb025e48e57459f93abcccc455e30a60fd69498f6c06cadfa2dcfe2a73f018d6d6d80e159b2593f3511c721098f4f4f2603cf264406141bba7a12daa10506a18bdb1227f7bf269ca65b9796b3a2cc60cb73da04ea714e53d00135bdf8a2a1dc7d30e170fabb00b7e01d8399aa760b411958e3eedb471feab730cbea08490095e25bea974c04fb153d0f2caf8fec0355c73964ac90c087ab981b1d805733214479a53456b5c5514b41f7e8ac29a72bd55922a4bf27d1ceb4855d5739396b83278df5f9472745fe61eb030f753469ea9dd097229c34b69960cca1e2dcd3b7a1f030aea22f240e0ec58288e2b7249cb8a8612e6347bb8c730cfa31d49e218b3b439a7c421e582e1dce9659fe8df8dd10c524d70a04e594b15ac29f87f7edbd5fbcbd8a15f3173c60cd7a788909610667507bf76a3559c7a5884086747c8179ca007f0755737bf9aa45bfebae2b74300b7bba466e237d8476b0d6a3fc9ac26020bfebdf22a9a870f8fb56b7058deeb1fe63d17d222149d03e14919e5b5e7998ab1f3f6bad7a6e2d45ba09282623fb96e04c8a488dec9a881e69c1d3303e22d80d3cb697f2bc01991dcdb33aef02876216d9223ed1246ee3097c99366698255e63c02095a860cb08096b5cbb04fcbdb8759e09a409617636a81e9f53dc62f09fd339541c6edba926cb251df27851093f1868e071d53bd9b687f2a54f0c43efeb157698940d6067ad2a2502e71cc33c7530e6e4c93e761c21468751419b7dfdac4801963a1cfb9062858354f44340e89b68e6ec64765052a937f4fcee20c51e981f3b643751b392c65d5c41d26ff87a647fb5731beddb70299d467932703c45d05b2ded363e68ea130b82506d00f99cfa14958335f5352b231708ab62ec2d0ad9c2c128ff6027cdd9fa4ca98cc8ea5a491b7bec83ef9b395dce6f9d43cfe9506549d9ec8870eb4c26e94f44133fc72dbe5fcf2d9dfad1a58ca8b35620ea04b010c567b4343c6622f7e8a0b023ca58633ad58fa13c25c98d7c42f1812c5c0a57ba7232e717660f8a679d3ca751590131bf60297cf7d9532d36a6cf9045bf119fc757bbc37c6d2a3628c013d155ce25cd97813671cf2d9e7ece67f0d790cc2b72bd79df567eb692ea32afa0900db0cd034a0461224c374101792ee1d67ce35abfb705b777b70212a0274992a80bb7c64cdd8f715549db5c0c9bf026f65f779aaedf816ab54695443360349f71b0cb11e2dfd9e6aa2ae3b7392662e9136d5ff3fb2cfe55fb52f59e0fc61b2528fc978af506d9e0c4f6a0a22783367365ded55fd7b39a155d9002004d9b05fbb57f7851e64467c249c016e6260c353f90b62a800100d428155f9f1a015e25696027dfed19e5340c341ad5e9d8ae4b467996be8294daadab21448eef7a61ff0838d799d5dda6a276e376e34be2294e72e1bf0c5a4457abc036ea8d0608b34f17c858f80283906c680b7afb89fc5c709bd900e7665d510843132fef14ae92bbe8deec573cc23e9a0ca7f54f57f6b44b33ffec67aeb4c4c2790a03eda43a8161d9b50bfcbe2aee744b340f6a00e4ca748514f39206ba822b653a0d11861945eae1f2781b4a1a34d5f4ef77757d743b89d08e4e87160b5c9295005d36a93280527256958683f617ded33bb8f97f0e3e25ae812519417be5c955c7f2cf20db768fc092056d7f28a3a430bc781fc79bb2d1926d87ae7b3330e732525ce71ddb63b0fa7587a4c47a278fb6d9ab866f65ff64f21ff0b1d665f63833a8d50b868d75b4f6caa63fe196838131c51a669bc22af355334f71a40e159879a51c686dfcf6b45ceb059e7400ad5f2523c66671e92b30dd1ad8b5ca00937b40df24a7e0247dc7523206b19c05983beebd908765308fe3e29c31dc6cdc1179f1dc6d5fe2ec75d744a6bea25ab797f96e3e4e189ccc3c49d7a18a4f8f3d009e109730380504302172c67a72c046661a656ee5ddbe14b8c47ed9e8dd39def37e3452b6edf4ebe7b8133b470b57c2591378b918e3817db3dc5e34f78b79da87e251b9c3a3b96c4812bf6323e306486a6fcf4afab87f139c7b30e7969ac0c414500f793e5ee9e9e344a8a8388b8134cdd8cfc5e81818600fe9d2a8ec76172b34b0621a64de3c225e5aba428c0b03f6d5b7754f9c018dd44975c8caddb579106e5d02a4f6195c35827baff7def853934296cc47b6ea7a81f5f9e1472136d5fc2a7faa099a97419f99d302c93ac380479f923ba4edfd6e20c08a28106c3133684524c30e017736f555572fbcba2fad8f30ea072b54222eac1490dacf25e14daf349beb8f7487cca6442f896b298d8cb737101c1b599e976141bc451dcf8fbc18982dce450c25103fbf2a9fdc42a0ada99210d4860271e7075527e6673d83ba4e02ca61fbc68cf8c27a74fcdd8e21a6213533e76ddd360d1da6f1e368a71b84f44eb842e96fe65ef787921934bfc81978a1243d1d1a9c526753c525e7cde34ee2ab6e13af4a543ed8850f3efb36a14dca7abd54153a46e7012bddf6b7f630bb04db450462a623592a875a0c477b4d164b635b361fc1e19880fe79abccb85317ad6d73fd51915dbe8720b01d6accdb28c46f43abb38c0c4073c4abae4b2cd71f2211cd052de5a591dbb1dd8ec859c4c51cf226d315cc5b40ab12ac0e952ad9c995e0191560490862b90787db162eaa0615b77b9ec8a3dacf4887a9849c3ac55a6bfd80f1c48268b4f1b73e5a8f81e0a5b97645807f6263393f8080dc069ad224dc004433d6c80fc6ebe4a9199cbea406c72e17c1ebb8e66f8a47971e53db0f44961d9665165febfc9b671a69e940f0dba31fdf57bebe58ea3f9e8a78baca06236f422dae5a47f8b75b36a9bc7abd0642467859374868fbc76bed6170b593a8e877405a4386687d125e0af10b45d9d7ae779490decebbef961c01a5dbcd85db64b3c0257ef0c2e847454fee7685ab7530b14765b2aa218fd145708e1bd99c836a000dacb5bb078d1a3289916eaaad4a301cda1b62d9177bf0213172995106ce1d73d1cbe31cc396270c1c2350733460d3f4e350f86549378746ad2f6ffff4d1c0dfcca40299a3b1e597e6b87ce5d56d4fbb6da67b5b0b55c490d87d8f01747255280d61b73de34d47ce4cbc777454728ff7cd5708266e323dddb5c326f1a4f7f99702722c842d3a02747996dd3bc77b2040a4841baafdbcbd550b58a987fe90f5bf396a607f7f09755d5be65f79b570a9a445140d60dc4aca3bf5f1f63ea655ae8784af1217196fb58c3f71b960b923f722f007094fb6435cfc773eecf65f8b09e65382af26a2cf474e456bbdf8f620128eceee2673a530ef7dd7cbd99da082fe4e0e524b4f4f49fa6217f2abb3e51b66686bcdad43553a311f87245d2e78765fc2095bd9fbdd73c750362867d0711087d77b7977c7739eb183119e0ac00c748876030ac1d539fb291b93c67961b27ed0425152e115e2dfde2adc5e51da9259a4c0a2afd9795bc6c207f2d20a8a341f7532cfae8e89276a12806679586572ce591a1ceda835f25a3764d4de55a8e213109e1488dd00294804d2f412b85c3b96036f9d560698bd7eda7c84f979b1b0d90975fc478f2ce03caecf593ceaef1a8684a34253f4331b2c1b749a502f47e7e5f95b5d511ca1fcab9056d47421028cef81314b1cd9c886cec6aeeab2c11a35e0a40dd39b6f5033d4054e902ecfaaad0677ba9970f3cd40ed1277fce89fde37873ddb6fe6a404d78a3b76762a812e08984f5862ceac1a6f4d53ee3e3df5a6773cd7d5a3396619971cb9dbc0e91b0c7aa48a5e3d6b1ca2b1b824dba0cac0bb637b68c852e2e69c87bb56c8aa9fcf782d10a31104ab08013e78262e436035a3dde887c5337b32715ba3ff887dfef900eea22e0bac3e6b8a9f32c97392c8a413d6e4dfac4ed2038356fca85b79c249d22618d0c490f66c051c1eb9ab0a68b8a4e832b2a661447cf839fbdf21c66acd16a9ef56a6bcbc8ed76c0d2744905e88b20b709895d9db296419252d8b6f6cd3e94edfcb0ecf33f7c22e52753665e2672971c9fc33e7cf0e439e5a1175752d963c92bd0e7a8afa350ece606fb15bdc25993b6637e20e8741d3795c137c1fc93e3ec85d2326b93f2647451587d6bf3ffa63fc677ed288e082179f8a3973350c9ff656aced7b207cb90c998d10bf6fad8f0c4cc55837980256c54a5ceffed113f2142a6cffe7a19b616df07e502ae0aa1ba8566f00177bb83f9706e944d2172a425c92dbc16fea110ee2e82ec1e561c5ef71d7fdba61c12613f8b83c67688850134be47256323545703b73cf5f084c0255e74b2436b87d82c826398a6006aa0b196d7cc51bc14121f987277596d37d4cc281025c2b50f4dbb7bd6a2e855932323d213b22467f61e8576f34628a150631e405f2137219ac1e8b29c2a2e26ffa08b2c85d5b7edfd787c13046e33e9076ea93c1eabe757a85b276ab80af4e7ceaf03395dfb69be669fd619e851ea7db3f800cd8d72fd18fee6d2f77111bb4b5b4e56e196bbd8f71b3bbc0dbac017ed69c58bac6c95dffe30ee0bee31c176ee9e92bdf51e74ce9efbd37e98b3f8206bc87d9b5edb8e05fd4827a8393e07a466cadaa5fe09bd6aa9c58331f4cd14d5c283d7027f571552cec3f72103c3f3c5577797edb5e0fe6079732e1e98abe70ec2566ae742ca5c91fdb2b9953377a284c56dece25a6210563d5d61576fba4f4dc9a1adccac506cc957b8956f6e76d558505e1daea9b1e6d36afd397e0e631cf8aa8aa2c957463e1bf9bdf5eb6279bfe7e52838f716cf67efdc616d2f7f6b974948d845f1552842329c00be854d28a3a77712cfff1b40ac83df1f0677bacc4f624039cccc94e6f86d0d6d37029dc6f3ca62c624788614c341b13dfda84bd84943049cc6bea833b51689a52dd52be4c7b2748b014beb4de2803e7c0cc3af7a167406f13000035a0d8252c9020f055ff3b8798ba790aac6b77557c657a8a5e1f34b48c5a7796b4561c92a21766228ad8d777e412645b7c639ff9cea0019efa8732b85a6d55dfe3f570751d52f293ec19de797ccfee76b2d4cfb70b58a0dbf8237450dfc7d933e28dc69986fe5749ca2f67fdb075bcf3aab8dc8fb09c136945e0790bb167afb61bda7299d67a1e77b1b55b65307a3aa086bfc767cec8b6891bd3586f3b338d583d71f2266610008ea3b72b1bbe576d72223418b4e8ce2f03f004bc9de78c3beeb645b977d05086e7194aa72efadd2c944af488e0ba44d915a3973df945c3ad03c409b11ceff4cf266ef77349f549e4e844a1bc7e90a1854dd359ba2c7805836a560ed8b597fb72510520ca07a246dc1cded4cbdfd9471bde717c3e4e88e8f75576f3f93ed463cb1dd5892413ea3562604104c74e37fa21e6df68a96caf50a4321641c4a765d979c0a8dc2873be748776466299e2b0ba1fea463b63bb052e8827dfeee1b3a4d1458da09f91d4026e514056ce9fc1f585aa67cd5c5523c81dcadd6bacbe1ffcfbb24997205c13496814e881af0c16df64c1670603aa5cde8540691ccfc7f9b6b62378f2df1e70e234b968e9df7e0c8517f2ae3d7e8a1eca3df2c682e0e1d33e3e652f89a31b8cab21be063e805d121e4c3d41639f1dd63979beb10d20b6ba7ed194e25b181208c0bff22344f338ef76b0ef649cc55a00907ce95d56c2acc04ea1de02886817e2900acda6d1021e72b98f76d9fa20ec798ff360e303418b8af07630579a18dc1eeb8c0ef3361bffb93a44734d7eaee8b2cf3f54ab98e8d5afa22996d40621ce32c1482118401fda7d8a8198d5cadd0d285dceac3c0c7a08ff73292a121621ff92e1edc424ebdcb1ed7010e5c5692302b2217188a696777b02a5fbac53d975909a9a5e8633f8571d7240c7d9dc1c33676de7881d4a6975c83fef79224ba8489df9410f5b27448760fdf59c48109505ffd46feebe9e9f509cc1fd8abb3dfb9da3e539ea7f1340e40d435df7abe7e9a5563c83aaa40f1066d9b7688e7e6423697f0996e08ce957cb73c4cfdfdc937aab22b41512f4dece28bedee4de46a3261ee9edecb288269ffc4a0beb5d67af2db02f294f318aef455b46472a9c4dfb84021e7fc88c67580cfb65e26ee81a1d432326221dea1d1e1595d8b808124758d5ba16914750fb9938f8f60a9f2b7cdf04bd7d758af6aa49e62da49c85b5964264db311e7a2406f4319d110e83cbf34300cf21ad23bb66177a1513aa8fe255a351f63d7ea81243e8220cdb84317ace507730255fc8f2f0359e209e89cd39008f6f083335a9c2f4d05cad3b1e2f838266149779362bb77a223152049c5a355082cff0b2b17c0709c12311701960210a9125492ae005c9f3d1b783cc48d67aace151f699ee61f2d110328f66eac63945212f20e6c87702acacd1afb44c64154f952e0f18b297fc1ce05219229ab5c7c626708c5e59629e2322f29ef76f79375aad5ac359e248f5dbac06f4a76dcd1ce52915c5ff6da07282bf5f2201b93b598391bf34f7f71d6a46b75a5c2fdeb62cef586e1cce3c627ac853f0046be26cd1e6443c8ef6811bfaa8ded3ecb72a3676986acb03784fb37be6d6bce76a716a7abec4c9f6358775467948ebe40bc52241fdf1003725368886bab61b5675b1c0ec2308be9703c08534803f3b2a32318f36df52563a0393477b6f82972b46bffa8e5883a269130f36a9efc3fe7a8ea8a7f6e1f712290ee9defa237acb4c8fdf14b577bd58463068c2a5c3f3986cf54a94edd855fdbeea3db345d328d5dbe5760f6b62d63945443af2f256cfc643155ffdc54d7ccf5d7d2bf6b473726b745e9d0bd11c0acce4bc8a8415f6f84dee175903d40f53081dd581242fba2cd52f79de741efb4b4c5d9bb3595dc2d3c486ee2fd6bc7fa63e3da1d2878e725ac94dd89ba7bae6f50c6a217d602eb86b9480bba8f9cab5237e3d3da1b2cb0eca75982246627b7909485c49e5493f585b7c7c95a5488e9b203dda9e151a4399360bfbd7dafb26bf363a554c0992538e529c761eff05090949fdb8f959a98a8237ad4bf9d0d1a0f7624dc8d69dd501933b5f6d5cddf9037a249eb8c742842299344def02fa47583979f2fd4ef9a0198bb7f4dac18f627b5bd607b8284ff7a5400e677c8b079698c17d7719ddc6ccc8b2cb03c7ff577805d3f9c029c22e3a122c32ad474995d7958921abf2ee4d83eed96da01faf52bd148a0d957a67c6811ce1acc434ed11196be8af66b8154416351a79afce0e6b50f8e9ef7155aad94156310e8569f89314024a4d89a45a48f5c3d3369a3595105daa24322c3d5201a34c85f0b7c84d430f0c4458a9161c7cbbd7842529da7ed9541d3bcbc81facfef7dfbcf7ad2cad243199b28f9a661b0e34e6c879682295e04ac5b588bf1d215c27ff52b11e99a7f65e829f0954cf74ac55cf5b66e6b778a86316e475d8b24bac92ffba6bf5397167fa30a41538c51dbce3ecd8ed59536a612467ed5f8ab6dda1c8b6fd3d6c479ccdf4f1bd7821a859134d829828cbc16c25333b9753bd50e2224a5ac51da206bdee8bbd4c51bc421a5557cfcd0d8c3d31f617f59b49ba0699cca38399a88646e808098aad80db7933a7f8da2ce3b3990b0d9847bfc469fe1268275854fa7fec251d47c718b54ddd09ad745675bc9abcd7ffc971574ece259500d6e03a966d451c80123d7081481205c797acb77c51657434b82d9e0aa05cb87fc25427581c71a88e6c40f113d2ba3c98428dce8250fe35bd48312df469d7cd241286bd9c6324a25381ab18c55dc678af98c38f9c0ae270bb35dda61b95bf32d173d937b4b0b098c8b5956b2ef8fa126eb22a5e8177612fa8ec7aaed0be4b380b4819a791c7fc1b1e488c726d272d1acc975b3f3bc435dd1daea91995ac777a38d66ab4fe79ccecca9ca54229163ecc37e048cab8ff6cd56e3105a0cea317921b08920e0b3193187b0c602d53c858d259ed6dfd4091be6f9399be19de3a54707d1936c471efbc4abdb6448349d9213472eec0d92faea8a3899ee5119901b1417f4d4bac3b526949912375fa6a5b61283507563a98d9a2c7d5580a877ba7d5d52c0c527cb8992ab3b6db0f6d9c2b5c9d09810481dac323f3762b86850a30adb6c575f1b60c20b0997c7ff96f51fa22988613a4c10211d2f057599de27a822671ebdbb15240839ca54a9647a6c8ac4d7fbbc1416f73d3ebb3282a622672f59dd7bfca976db4a6ceee61e452c40651f403dc952256ab1ca8effad2efa3613ad29fc50f6bc5fefe11ae9757f098a78dc83c59e364ee1b688c25f8c55c1bfcd938db5cd7fa2126248ced4640bd48690fe1aed37bb7e62664413f1973edc38f26518298c07e7ea6c5fa02a0637bd7d6de8c302baf3e8c6a70ac9852f0c827b866e2d3d3a97ad2bac38a6897eda6e555b1ac0461ee96cc1d3b0364e16a691342a046806de2fad72e66a53bacf98674900ee2a93b0c16b3b2a5dd85f371125253886f2f92d596c42e385443736c61c20bd590717ec16819e5803c9773b2d075ca5cf721e5481e73f9f513657883435438bac2026bac6d1e04aa97ec0cb5622954ceb1ba5011c7054b3bf973520ca335bf72b4d12ce9f67b1f5ead6db21ad80892be307f5f570346946179daddb45b40565eb7d1de861128fbb9d80fce95aab8f1eed34af62cb1224e77bb2fb54a5f93732e50c99e1cde8814f1e492b6fc448cfa10b5fc88893048af3889ffa2da59b0039863735c6c1447cd03333d66cbfb0b3d80bd9399a100e6af3c4884eb37dd9517058bcf07de3f065838913f5572e8c63d92987b0aa87efb040f2c9e9e25d7ea64ed36a057a9c459bb9965f4731cf05d304148f7501de9e614ce642ccb7c4894b71fdf8e2f0203668aabf9cdf9f8edbf91e17531939d7d5278b2db679743687ec963d5377df245433e9c35edac6e04da85772e9ea526569d0d15a169ead1dc8c38879f6c94036a7c9cb97b41a5301caf121883014777b9dd2c675d3db14406fdf378d84777be446bee5e25215047ce2b245780b2d25d7bfbeff5f92cdd595511fa5536890dc34d7e3a86fd9ccc20afffcd898f924eb099c53a8701dcaae26a6dded5650257de7232680f45ea79759d58c3ab9f9b20dfe1cb5b6aed2aa42b678ad4d8171154e9f5cc155d27ba83734d09d5e96c3a86bf691f317e027b2edc92836b560be272c65f4a317c41f72061393d3650b7ed63c3d86e2a54386f4159c5d99895dd5fefb9e9e70be070c5617bb1c6598b9965ac589b13f83cac023615af9f5b68c9090693580aabdf5d2d504cb0082612233e6e56c8519238e548f8a0eede9af7ac3303fa514137bac7f974a1bdc6556b925277260406ae851df165e70e50354c5b85e8f15d9cabe608e2abcf9d9a8bfdbb1ee23809116abecde429a72dc58275da2536b3224d2b2dabe269253652b1644c6baf61743c729475c57c28a7062aeb5c0b61a3ff11cd46616e7736aab11747b1ba4afb472d72982d438f8b3310e25344d4ca0aecea2d28b85313ab3ce1c551d7b4ae163077dea340716452591213a11bc195c542e8f6fd3c628e8020fee0f42e9f7beecf2a4ef24c37ea20966a04f06da6c6fcb3ddc1f5924a42d82747a97e42a93604a49a248ae1bbb50262c7efeaea0350517eede4c7c13468419cecd765ef4efcdb88000266a4d5e52f6f6b9207de9455b6b9cecfd120bbc0228430db1c2eb8187f6f4b3b2e374b891e287b0b7300e607002296a9db5ecac8539b34f09fa644cba69a54e2fdd5d82658281aa0976f79769498fcc0d1b720ec38da8b8ea4c565fa324ba560409d29454254d3c0b615822f250ead29321d8023048ac0ac8b19a0d3473aefb8f62eddaa720a5a6b8f4a7a938ea52b80a82529cd0bb190dfae0bd28de6d98be374afea48c9eb45d2e4f4de3fcbbc8841e15b5e7a220afecea6e9f9d3ca62a0d732ba374925b297228583b9516efbc86183e68f9a6b8587fa5de4fcd8afb43be355d650ffa3fd8d31fc398401299f128a721a4808c7ffcdca7c20e31eaeb52f7a384ebbf7ddc7ff13570511296321933bd10bb807a89432cfd6fd9723d8669b47ef23fb990b57d3a5ee47063530a1c1b86ba5903950a45f11115975f1f1f6c474956e8f3b7e4d2fd51d564f630fba2c23933493888bb9002af4d2a501cd8abbd3a2ae8556e6cc96b83fa09ad3e7a1a0d0b67a3a6b050d96c4ec032ec7a9c6d67a6d6580a37e0f0cc7e40df6d58a25af13e0045f9cb8900355de8ac62a06418445f73f15689ffbeab9cf6110c43ad4b3146a7b90ff686ebf1ea0866f12bc1482c920f673b8b71ca14b218b7c15af87d926c532677b15b4f04a53d13dbfb5ddd9671831991c9b38607558b81faa88e91f81fba51ff350511b1eff7feab53a093b93ae836d15f7ef1467a289f21170c9699dffc0c4ba79a3a4342e9e0826cc99b941f2f3cc9456a27c790e5f0d5f5afc418b174b4219a31d13e00cec756eda90da43d258c381f5543ed39aa81483f8b0b28635967d13ae2c7145b06709e4ade4a1d8a1bde33135367909bccdf612e9ed26aaac0f041eaee6d6cc7f25746f6397704ae10789393f41b8fa12e901ec9ca651a1024c659e20f8b643bf4d7471d6dd1830d69240a99b990b6f18304b61bac69b0a1bd584c548f32323e15ef7123fc81e4eef6f1accdba918c50ca4e7a400e47912c9fc9c859953ecee0442dea7794906f68af1c8aaf86eaf2f0671d9362ba5d76b9285d3ff3ae4eaaf124efb6dcd26ec9b28e1c483346ace7361b74bda9b8c5d29e06b8f664d033f37cbbcb538310f960de26869673ff7a7493d20cb2f4c3ca9ac38932352996a91501d439723292688a36ba8e096c0a1f0ff3d4d3a5137c65b0c33ef3e305340fce4e356779dae696a7f018558d415c33b8af09a6cc563a0071a0916cfb013a90cc10f803a41b64e9052d0da7f6785bfd0fc2fdd702bb6634e8b871f3e7f82c00a87e50eb14f467c9fc1061fb896d38c239e49db37a3ffddaa94b12dd7b4193a5f6e82494e9f331ecb30588876e745a325c16ac95dc3464041d6c4ee3fa4ec8b85324c9d7c7902f834acfb90fd8281a7ab1f2f4c19be22e9a9b85e516c3feb4878f1bdd29dc991aef2a48b0666ddb004d816ab581a8198","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
