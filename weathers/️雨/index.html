<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"633600bea4667ade33257584ac2b10d12b84eeff7c7791f846a00093bd2b2cc71c625fefda411bd1b4b7f277979718bc4da81ffc5d32fbb7061ddc99521aa2fca2d55771d1acbc5786178c6df1281f06e695aa7364967d096bc09f5b0f7633c2b6e39298842ddbb4f2645c9b36ee96cc7a18d5753b33c8c36c38a29cfd8ebe96d40c0833caab679d15247f600ce3df2f873ad38042b82bb967688e8064733553450776d8c54ec71dc0761544fce87f860e9726f182947abe202ff8f4b69cfed75210d3dfa51286cb0189c8cae543896168aa415869788ed0ca286b6d73123ec9497b637eb3eedc9bc0bcea6166415b77b536e169abd7a678accb52b5ce1e66362d26a5b6b44acdfcb24333e7877c9c38477828796c47c5e0e13beb9a1034e09fb4d297b7474de9d5622c7348e530248bec0746c044e222dad02fe7ff0e6c6cde6247a7a8f8d0d1e4b816e5701bc15bd70c4d6840d12efc3716e472a372fbf61a14cf5669beff804426f490176b5e608423b233bdb824510ffd48da9a3511d1a776487a23a38625310dae4db9d418d0628bbda220a9dc50d59ad9e3eadcf61c37659275dbe49ab269fba66399714ec08bb9593b9c28a4c28f7692436ddf8ef51f8ee70f9a4a4b34ec0d123138a9e05e01d8ea0c456c76446997bfa85f7a2a657e7d8cbd0e8b35b7f8b7cd901f4a484465d44e8585fc8cf11207c50b5b865a758a0469a30719072dc906efd1e3368f7ace862e2cc38c0c2716ee52040760a7102c6acfa56eab9ca86656dd3f8b6e0bec757bfebaf36b749c7e914b2579a05a78da6ed32ef1b3da09e1a01f10dd693a7c5df112aa4d37d723b3a544b2bdb78abd64179a7c37b41f68a564d706091051dac6bf219d9c51f9749110d69a665c7781f8453506896c1cb97985ea42a9b4514ada4c383efd52cd250ac3a3309a36e079e81f84323ab75c148168aad537bf712f3dd90b1fdf8647517ed724f48ce3ae9c3c5f5c428b7c0f65fa8f02c9adb9d08a39d8b1b81255a1156d8fba8ba799f237419fe41377c109d234dbd7ec902eec40203bfb0e8f304e9b8e941a5ae0e4676a4eee44482573209aa81afebcf743cc0f5d9d8d98e4bc0a9d7d11133a2c7713749c85513c8fe822ffa3c30a27be2d48915287ecb30cc2a999e5bf314cdb439cacc610cd753d12ac2765f6baf33d7c8e796c7c930aa899850998bd3e77dfbff9e94eb1ada1410be331115f85981c564c85e8099f2785646e512b7a6d32029a3c389c36e36d4417ff159e3e15708d7629e22c57e9f045ec17a87dd5b476a461b9fa05e5146a5acbd8a0dbd274ecececbf19cd62d9e2b75cd885a935ff2a04611ccabf32eb622cbebe6f240c859810a64d03499bc2270817076c2908f7a25214efdb6012ac017ad2664603a8ec72d6d22919b61283b8d99d3c5e73de759859bfd37e12ec1be410e95813e7f69cab9aeda9a4be447bd2deb75d57a47e62c7145ea6641890dd34bcaddffa86fbf148e64a11373c502719ca28f700bf180d41fd4f6cdbe05c06ff3a988fdecffa003b238a265a0aec84392a7880f18a734efe4ae166b83bb8afe2d89efdea22251446b087cb1cca067b27d8b1eb72ab54f9979577a3b415205791308abf50caf4b101a298fd77635a02972ae52598ec4e84224f8115b9a388b2c20479d7bdc16bd34054b0ab3b8f596a77c45fc26f64beb473182aae9292cd9ee89ebc25c82fee991e9054629f75b1290af16e193eb3f0a716c657f0227124c518bc80513201477a0624952f29d117e5ffee8c78c2c684f9279622546e2c31e4c6bf35079dd1fee63bdd71c4ec58a08d564a2d8b8cad6788c93907af414582bcbfd65bb8afc163c77333482bc969c1862a4d6e0c5db7f2f7f65790cd9b48a43d21a69001351181930bf9e237083da0da21b76fe8e0abfd89459a05e463c1e90bb8d781a3a53f5a6aeb6549cf1a59dfcb19115f554d839576297917032a66bf4cde7f6d9a028f21413a2670fa6dffb2fd26a9165e49cbfedd007ad3e731e622f47ac97f374d9b62cc6677f98425b8444606fda814a846cad55917d9651bb5042aad9c3034a65be3ea40d29efc38920fdb215e61ab9c340a52804aa518fb57385a070d1d2dac23505fc05fb878e52aaa21d9d134f48846f082ea1116394dc7ab0ee7e194408f93b8c68078d9f44f183707364d865489e555c32ef36aaaff0356d16b2b7669a5a7292a4152f7a2a897f1f70dfbe25ca9d1254d62bac9721540d30842021af3e40f4236b07cba3ee6d501e963b48310b9b32ed75be85db47dac55b6a4c85fd602c2c09b808f3837013548cf1358754a2a2ec06c3c5c3d316fdbac27fb3a3fe8291ab457676a8aceee8b494fe84c6d61fe994e9098625f0a1636a66c92f746eef09bd38ba4d795126ed78b95e582efdf2fb4576cf7e8135881af0e7e75ae99b52510098939d8c28ead43425a5f0360ebc3e7695729c4fc7710bfb05df9f9de1f1ab9e3370cb7a304a8d4963db18be67a6f9acbc710a1c49525ebe3877f87dad48941b095658283001c07d738eefbfa8beb3105fc906d02a2aa2a60c171283ec225ba2ce36c94a8e3b61ea4638def15a2417f53fe77cdc637f8314a577a854e1d5b4c99ed793f1fe7271304b87895646b8254128c6dd2a9dec6ed0285f04fdd12eb7cc2ac4144aaf99c8b23fd522b1719d19d11d2eefd2a7fb47d4617b799b80cb4fae5a0efb4ca9a9cd21e72703738dea21d3306897d8a0a777f9170f80e7bb7c72b31bf618ba973f70db7e47802346b0fbb7b6ce36ad1d77549d1707c5132c049605443b1be0328cf2632d879f8b13510816269ec46c7425fecae0ca7040a108e98d8ba5032ab00800701ef836e3acfb89deccad142a16c66a3b2996bc7281de6a01b2ce3c4e5df759acf498db2540d5c317b51383ef232c6e7448bb3afc7b4bd09e9e6d244f75ccd548ac44ce4403842c7c73d0ccceafcc9b042ff5e743643e3a8c5d617d3592402ad3137ac88478d41a3c198a1bdb3fd96423fa68c01c0ff0b1ee1327d16a01eb01df1e4b880aca9bcd04726688ea749bab8301698bf2293fce19aae1ed73f2836418334c4190c13757643e1b9a1528e49d8d2e8659a39eb0238b7cb6f7eace9a4420325852140f4c3c291868b4e2db44cdad4ae4fab346faf0be5df383b1b3a0eaa579050a0c583e2e4774f4c63bf1f8bfe86a7b7e5c2eb0b48a39b05fefa9628fcafb779ff23a13cbf8b28dafd7011c425f61121bd651bc20f2bbc88418f147dadbd0741b376d435cca530b5025555efcf74680589ce3fe3ba0a1e1abc386db347cb1cdc70ef08204b70513dce55cf27226c8c2fe67adcb0fe4647ed00a057ad08a038ab9ee4f1a9ce4c915dee92bea2a3ea0f2c3dac4dacd09ec16cebb459664f83ad28582f8b56cd7e62669fcaaa8ff300d8727750adb330d17efcae6af59cca2416d029c0ee102c7e394e3107d7bfbfb099777e71927e4d38d4c204854ac28b1d16aeefe9f04e51fce9cd7d6aebc1043a3ef3dfc8179635528b3fdd536b437afdbc70b3f08e80a4cf4014c5d4a87015b47f5c3067394cac163369abad58754e7db9fed4c6a46577d59f91d5ee3104ef6e080f3e9d2e37c393d35813db1a830333bf7d6ac0d9e2cd672a51527fc81b085427248db9204bc098148f0cf1ed5ef62a4adceaec9fc43df2c905649ff0b394f365d4718b365260bee8bdc70ed07f0328d82b584df6fc01c5da5c9649f7a92b3b9bc2b4163fe765af09124ca3563ffa6a40f9ac74de31280bddcef789ad6300079f5f9b0520151f4fb7b8a1a493d03b844656558531ccd0ca77b26ff4bcdcc62d91b1dac248a50e88e58bea96c065176696e5b187097c0c83f33e51ad860b7e2bd60ec9adc84fcac8054f861c9f8c4a1092611d2e434f7875151a5a7a4ca4b2c545362077d201f0b5d3395a2552380c6b1a74e0ce39fe6bb93648b7fd387ef8e326b913a5847899cc1b9942303449b067f62b5e26e6c3ebef38c2ea475a3dc4b07dead117a42dcc1e84e2d724a2dea6cfe2863edc977f9e3e538305d255c436b32615e5394476944c5db6dc5585d6919e33a61fc10f5f4cc394e2405b3db1a18f5600bd14523a4d1d2b1dd6d343c493b5c545ed6a17d5b0cb8e4c04963b803709310f911911e398cd91a7058f90728672ef730549b4364c2d0a2343a005d705ed8eea449a18ed96350cd2cc6b18d54f2b7c481b6a94d18e4b3b06417ba86254b65139b6c1381f805f35f57f5bdb949cd0c996460d283f6031dd25b3ad6168f5754d3b5260935df276d73b5a963e63c4d060c875c89258d6b6a2d545578dcefbb29d6cd615fdc0b31f04ada7bd9880962c41293de4dd94d8c403dbf1ca097dc76d7110c6df57e4106121c567c1617d148e29fd6d37bc5b3a9a063227d1043f1e566b2be6eecafcf8a078054b334b32b2a6a3a0d42e9bd7a4160b3fec25ea273b0db0a1c581edb78e7b456d459a6969eb7d7eb77480dad6c4f1cc54fc4e500290c72b67eb737977edfea969f34e91bb49b50c31d7e8423a0fe11f5b2d5f92f2014cfea4ba8d233b6669947a7cf76c4428d2fd6ca5cc0fa0949e818fc657a3c1919de6e27a2bbbfe88f5fe7afb5b98cc92db8164a6a23cc3534f4e304549c2680032f9a82b0d49df21d75f5c9cd50bd535af09ef708b823e98a8a2a52bf3e44743397883eae758613d172472a50398e8c7f969badce8221bb88fe2d460277af5eb42059216aa87cefecd6f8de7ab66de5f318f76021527cbaebdfb37411967d21e7bc1ef053976f8732fed97439573d781dd85e81c7439a19f6cac850200939439cd4f2593b289851896924e43ad434d5a5d139292b61461263e7376855844414f4795dab4cfc8f73ebf0287b9a302e4d81fa97366411024ada46430f40145113691e7b4b5fd2aa310df75d6f1d99b6dc12970fd513d0ebca243d3b5557b0aff3ab71c10692f64c50c45d3343c1ae1ee1a595cf255fdc83e1026a6b330c1756fa7188d5e36d5f7dca63bf406a30c328a4804407ec41650a9a7fc6338bcbd1118c4c0f8b775ebd2f5bcd25199310eba988e8c6f6890f1980aec2f5fe5af9ce7d4883753c006890466f512443e4480bc28dd41ffef72ec4f81039a0522254a449d8f6c802e4b3dc0d30d552ed2dca8164bd47deaced7f227146f229f77b89ad5f352853f9a806c5d612241bb81dc7f68b5bb0b16802a5589d732685372e581b525c19d79e983b7ed43ef814e106a26a5e793b71d5e374b4dba51b3fd8f7c9b3d09ad2109eabdf7ee6b56c3865d0f1e23eaea8531717d6440da790a7f1d3e035bedf24d8e863dc3aab43ccd51b52666ae72562c4326f6279a2f9bf3df7e81b9ca5fc91cd7a9d7bf9febc6eea908112aa838eae3e56f9656f6f3ac288205d7507dbd44f25785b9d319da018ddb34ad154b89211b061f23f946afac4e5b9748650a5acc683c634677c4db8e687e0880206d760c33b734893294a5bf93d72639a5d81109561194aca6c49ba2240ee58e36f8329e2eaf26cb7f1e4f280942766ed69db46d3a813b1aad8616f96594783bd9a2d74539d3dea1e73ec721885d94bb89861e1497b3c602a0b35548759c9e02607b95efc59ead7fbb007a998088a28a7f9edc871af7d8b8b331302a9d51c7d86fbe4e595c660a5f7f9db016335c5519abc0eeda46c7a0ea3a86f9e05a3d14a0c863dcd3921cfb6aca74525cf1059ee1e03a6ed18fbcf65544b93a85b98eee4629ef3f00b05aa2a1cf10fa998aadc85a3197ad1a3899c069620704da6fe02d8afbd4cdfc53095114a150c47f6e258d19dc8efca06e651d43d6ff17c90caf7788d65468741aa8a596ddd813ffc807fa3803e7cde5edf1a32404cf70f03443044f78b9e8552b02367768ac2ea9ea8f0234b529478f07db3e8a84fc653b1abc1efd512a2f906bbb07e4462b6e2b7999691dd09ff862cc9688e5325fe7270affdb158c9986653193de304bff440481870f413a2d64c979f0f3277a48856b1e98f5791e68503fda7066ffa6cf893493323c9d9d9713fafcab913e43d366168e8ac4c401cafaf1192caaa654556cb3f0fb3e0293bf9f8bed058b6cd46ef42e81d8ac4ffb95fd4fcce9415d889baf9caa9856708609dba35dd22f6f95ee65a32f73de3742632ae583fedb928b7171093c99802eb1cf258a8c497addd598b6adb3319714e691fd9990423d0b398c07b8b3386882055ac877defe071bee80d3e1b66ce57971683acaabd4f87468782fd49bee7337dc2c4a4615a5699807f25b947dd400dea35c4be0546ff322a3765bbfd4809baf7d5dd610d546ea08fcee50036469e012006ab6c23cd454a3480f90ffaa283b761edd554b98eb2c6f5be822703d69c5f14ff2f2c1b5463fd82817829c9202c2aa857568ca8da5a01faef4b6fbfa87262adcbfc7bfa0d81e3a41e14552196ce18d67ab7808f1590e93ff75ab9532d2287a4e5aa0ffc9a0a219ed615bc251114874c3bc2603cad58a06cf9e33936ced21b621ef1fb56def4163d1817cfebb909078d02008affe70a30c3769dd7686e1c4092abe44bf27b647963c5a2afcf8a100d8db45d8dd97ea1925e163ac6f95afac100ca9d5b59d9e6ddce1b2b4b8022954e89b7dd3b69bbcc1b57421f52c29125d68b6aea9975d0861a86685e23789a82723ae06bd084624bc077559be28c0ed54519d67957562667c48410b46924c6452d85b242f8c0d7f0609f948fcb554d1d9852cdb1919d3efb97f8ab3d54adce2922e7c4199cae2a97b27c081a7b31546cdb67471623ec27947f9342457744a77aff5d6e00b57e6a7be1eecd6ae118022fc7f07e70c20bca6fb0a32fa45a72bf968e78dd8211b31dcaf9136527727508550686b9dbc12ad49dbc0ad24c5d856cc440154d322ec5cd91ece6d28bcb8fcae8d869eea84468a1c1b9f71f52b3ef40b2b4e5585257fde6e45fa4a1dcef1fe29c1df160720d859cc5e5fb918dfa3fab4e4a8bb0d173fc14f1d4e5ab90157bb13a9bb7b8714834eff6a68166844caeee14cb9d37ed9786027656bfdabe7ab3c0f1706859d7d4e366d440fa8f6a50c12768eed08abc56101e59a134b0a4584b269c994f8f7f91799f2ef6aa5706f62ab9e58faf50e9f39dbb5ff844d3290aeeed0987236712bbd62c1d1fbfc7fadf707b1aa7e6be4e623883fc9b414edfae526678c87a9e6e19b2a0dd04db5d20aecb7f75a63d8152bc6c4dbf1f8b10497070d5314302bcb4d8b69c8efb5a79fb5bc57773f563cef900dfd979892bf87d130977bf8e3a56de2d346477de04d243f23886e1deb791654724ac46472299c0fc65202981a7967da2b86ee42810e422f91021e160085970150bfac068f5ee01223828386f8960e6e954e5a3858bbd1be8a08b45cb32daf6c220e1a26f03789026116d40f9fb091af21b874fa10075645c77e758415ada167aa56575fb5023c0a660d3ec8e0483e0d87f2a31df55de180f56429fb8a117895377c9b45b5dcaf4e7d92a65364fbb74a572c86f8df1a9561d39cdc72ee93e94ca02161eeb1d0cc1f9dc56326f7e47e50fcb95b00aab0df6fa31ecdb76bedb1949ef657f4f72327f7bef88da1b2bef573bf9d8dbe4b287af82ffd2f2738e9e65df7e4c6adbad10e3d06d34c2b063ba03ecd7b57f0a136be3dc56f3e68b83543c9bec3f0d2ed87991751a8bf8a383d8b095a91a031c3e66b4bf5e95a587a2b1f8faf26f3d3e64623d7633a506b813aad520584c77d7efdf82976e507ab00c405b59f460b49cfdcd3d06a7f8c9577ff7a599d867501584736cfffff4ae124c81ab4105783fbed87c97c54c47b043f45109967f67ec3fba51a3edb5e1cc2db8de97fbe5b2d5ca799474f0ad3012eca4faf1533a711babf4f5c9e54f7cc769fd6d27a97cb0bf63d5c4f8ff42d35cce5439bdb9068f596dc810b077d6cc2f99b289071f68333dda0df880f0010ae62d40cb8a55ce1806485948a6f306926e86cb7e090b18cfe1e61e784737b56ac72c51a73fd045f98b5c498e45c23b29e5e706ae46532800b7c120077acbade74646d4e0f825546480c51c4a6270f02a14022d21967682232191c7d4f830f8c83423cce849b5ff7ef2a7e1684122e9cf2f37b1c0321c607bb1402455063c44f6822e6baa63e69f60a1e97132f22b60b6def4b2868d9ccbab5d56c3995de56e4eb09ede26e691cd43480df0979e78676b2cd1af2f79363b29b2ec5ff4632ac0c54625783e1200809f990e5fdb68fdbc561136cdfadde159e4df17bc2100c5e0dc0f4c651aeaff4e8607c2f9bc220bd750aaefbfd38748fd600c3b7f849de5774d9fcf91967bea6ef488919108a0e14bbbbc5e6c6d6fb3cd3d9622e7dc7e73212bd0a4a4243782f00e88dc12353845c4db0ee363ec1372de8a70ab37646e8c0ecacc1b1f671ecfd1466a4b1bf0fa4045c6ef47420f6d1fd6d475806448e7252244e9a083dac564a6ee122c73d0bb648df9e3dccdb2c26cceedde7be873835faca0cb9ca56b2b61f30f2945064a09731220056b47386002ab3f2d49e59f140421320acdc1bc43f7a8617a00c0c41a6899d39e08f72f32e3086e10f5ca4843e1ba4645f45be8e08e84a475eac68e16b22be82821fb1a53fed05cd579e0268a6299dac22fef3cd5eae6dc880aed3a71be209ab4dd86cd502542be1e37ab90855342de2bcde29aa438f7d4240e69a5896e91323c333f1d84fbe80550e32369463908b3f395a832aefdea00a3aa75bdb3e0276b2400ab9e4e6caebd120a1449f8d43aaa7db672369aae02782556b14e40aabfef1b49d2870aae875826ba30b6d953b8cd39b46d5e9116d7f3d83ff82d451acb9b6d3d2f4b9bdd2db327e3cc4e50f936bb41a3c63570291d1814adc462571a1bbcf7b99c80aaa98988ce93c955f187b4675735de340c6639274bfbdc21530ca8c854ab60576987ba0eedaf45398542bab67653256d392a3d2c1268c769b574e0ac653d7c6eb286eec2cec5d2644c2c4815b60a6e99352f346b9b212bde758d1c5472fd62ba3cb072f5fa1ffbcbbf818bb77d6cfd22949c93914b1460c759bb54261d429b39a30c9843095b78be6fc08af496a287c20e32debfe32f2f30da288eba1841f9d7e4555f6b0d5e31322d79688b44304e4da75898f51847bb51ac4eaa6df26f43fb69a030abe32e02518e71a302cc3ac79794777d85bc47346d1bba33a98c5c3b12709190bc355a5d4bac4dbbfb10da7be9673e2075a5d8bea50d3bfba8b979d3ee0a34b9818c4eba32e930a752d5fb41ca660868c2f4333ddd8fb9763888bb08f51a7de3718a1ab5a67b3bf4ee82ac1d00d6fd7b11a0952863462f3a3a21d5bb32601dac33daaefe263c1b62ff984a6659503de8586d3ee0e1b6a1bd9b1e6dd2a1c4a207b8c22a1321b7f7d67fc37ee796a63208e249600bc7c184312f716d54ffa3b1da92a47f34a0c105b83cff73458c3080286335a9850c3b2a0aed0d2d85d24be762dd5bab96f4e1b7e9d973c8e9f1b8f0c31079c1a666b2cc24c29b6c2d2479f71eb30d77c500150d39953a45f0fb9112c97dcdb208de5c108943894b3010df6b3e2618c4858b372570d82970fe7e0975e8a858f613b2bfd9ea7bbd0f1b2a0cdff2b4d09f2dbf022a215a72d6336028fb7e2e0555bf18dd1f95c6606326366b2b2b922cde9203848d825ec7ae35e6604205fa45473df6b336641882538390ad2f9ac7969426a60df62cec4c06f18c5165cab7ffabe2c261ad0606895ee049d3b999416c7764e8506a8fbe87c0991a4dd79c9cd2525ca4327a28cb18a0bf9d0d4c35ae4366e853f53fde26a4676cea19f64a4b2c65f75d95389b6d96fa9c1f95567682f356e80d8cc5e99d198ac94ce2e70a0d6a9672298c98c478fd3cf5c754681eae2bb81f220ed53ec0ce5c701e53df2b8e9639a73d3f23be595b43332451f926cef01e60485f616e070c312d5f92e3b171b7a9f14e1ae2182c800ef3b85d4b5bb251e18c1fec92cddcae13f78e5084e8513d138218d9ccfeea81e59c512cfad000e57d4d80103088191b234d91d5be72ec1a60c067f3c6d9878fa8281100b3f7ef1fd45c8a9f8a688fa9f7677f1a3f07016da2203606bb33e7f8a2737f32b329d906ec7463502df6b2c98be7bcd7d512a9c3ff4c17f7a52bb51bd91da231e3f1f84fa0cadccd65bf83fa3959f4403ebcd41731c595a5cae2c4341569eb969e3bf16e0829168f76e7e071dd72eac303f1fe6cc4ee1737ccef04fb639e531b232426324b963abc2d3d31facb8fa73ad78e153d7f4085b140b683b97d777c5e966519674b16de25203ce7ee48445d06b06eeda6425c839a912bbc750f315dee12a0d59fd3e0212b5bea0b028922e4c373f4cbe6df40e29a4a32f0305f4f6a466de8a82087dbfc1cbfc931e5bf5757fec7b90bf692c8fad496ad159a4de656809c5e862e7ca0a37ceabdbc48072e85d30220e7cc799291bf6e7e172e94c6bb7b1ea055206c46975b21ae943c10d543f790c7af31e1df589f565b9ff2bae651810933e641c8b28c771293b6988e35373a3901b1cc0cc1d206961b38faf97dfce5da5cf2ac382d0b7e0d56e4a198211e7e260a5e187d8e1c1825da0edc7f48bfb19b6e6ca91d5ef32eb18e3c663cd6deb2efb7e57ee2a652585e4cf9d9eeb3f0844d98e3aed926f34983304135fed3ed7cc3d64ba994f2098ebd5c07558bdafd247db1aad5ad2ce0acef1d9e51de450a299b02329ceba59fdbdbd9c84908c962eef558d86fb449e0803d1de80f85b8dfc6eb369570885e803ea0f369e2f7f308faf20d741aae2754206d5ecf4e0431d30c76b4b76404fa9a8c8b3732eab3f3aca869b309a29d94c542d98c52a80f43d46703d571dda544221db0a5dcd4ace1113e5ddfcca3f924473dc56cc80551ac39facffbea22bea29ab61316e0c3c4a57de9f797553ccf0f46e65c8b349da1f5afef085d25ea44535b62adcf8599b63901be655adc4a24b82d58b3835f51a2ceded963a094566cca53168ffbca3520d046830c3956ad8f171992214b0b163c0e85f174d9214dc4d11b2924e837b57bdc414b735a94405b4a05dfc882debb6fa2c1b760586b48c15b9d60328abac57ecf8aa59e264dd3bcb09bae2ec40624888bd9a67c431674f8e7d9d5ec40b7cea5a2cf6b71e7caebbd393cb701b1e00b727356bf4ae1a56c0a49dc02e6a35c299ee0a197fba0239b298e4a9e4a93ab03b3dbd023cd8f2bcd60be67b0e2bdc5c319fc5bf61a5914de37e3d840090dcd6d13260d88824714245da226ba40521bd23781b32f96119bef498a2f8673364fe77ff94d0e1d5c360c18a91fd9fa6daed9c31dba44c498d380ba689c3924244d372507d5db65d947eda42495d222ed7a586f7ee4ca609e8571c0cf046b794e778163078716ed07d3cb63bc92a6308677522d3c679cc6e25256fef3664f10a8db2a7499cfed086f72f0fd18ffff0928dfaacce7b01bacd199f54a140009171a359357b2e5116b84f80e1f9660084faf6c9924d2041284e6e4ac004606bc07ce46e3832a38a80bfc2a4200fdaa5ebba27cd1bfa7bc1b8ebd1d82b37f9a8c95652048775e5ce7675e710b6cffaf8f5497f986ec071362d98a8a61e5bee0f28a900ae80541274722913cf1edd08a30b9e66139d785940886b2b2b55c36f2bb765d30715a05868c9c20219881609300afc1216a0faf13e97a7f1cbbb3c6ed0820345f20530af1c3c12bab20f6c2dc2b41c64891cd02b09392291b15ca241b857eada49312eb23e15f1291be34b33fed1243febf60c84bbdd7e32ed5a29130bd12236bf2a25d6c10b7037bb135afaa1af99cddfbf3ffa74bd101bd85f9b96f659802f8618e59118c418874516a08e233bb6168ada030031f53718967426480bc399fbbab6a844e65485c0de6c5639d0e498d3b30b37389fec52ed4bca49d5f11567aecee1ab2547f5c66fbef449224de7ee3f8e607c5d0fd57024c6a968a7e094f6ab5f8aeda74085742f077bdd45f411a48672e92c5db4f098c9f9891fd2e05201cdb0480b354d5e25a79b595fdc142c5a3f895770e612651e232543e99ca5cb4317abe7ff9244cf43023b161a92b6e33699671f4fdca97f752a07349d6a871c43688838817dac8d874181ed3c2e26a6ed93ae7dde7a778eddafeaa92a6a418200c07dc52732c86c77b917fb2beadd2f456e8fbd9af0281a0b0576fc35968697429346a747a16043ee71533778dac390e40bafdb294782116c9db48b561cc01ad5f2e57df0181e268a45dea269c14f2bc4a6782386cf2fcfad0d5b95aa7e41ec93cbebbaca0d4158fbf970764d62d472fbae6ff5e5528aeee73e019a3a23e5ae6571604fddee21e8f7d32cfb8a5aa5470ec5b2f2140ddbcd4baf977f11d57eed11f19fe6751fd7b7bfc85b3bb44396e820d44ab785ecf1a384edc987f3fd4c87f2328a20dfd4736b15c1dfebc0e1dd41bd960a861e6d280e15773920be1764bf1d27010d425bc98c9bd6373ff0667c8990fcd32620ec4935be2892b9636967068710565b3de773f2421c722dd5a959ff12841fc4ee43d313136b9f6da308ad8649c03b96e30bea940507cf66d5c013e6eb0f7d5755247628fc0848b13f2bac3d8c8980dfb15b84ebd4f263294e4c899e83360fb5110fca8ff796407b1a807f1140cf1f45aa6c42366599a15806c036fc16fdc44c63f7f402de8d818e2ef7d2cc02a549662b2aa5333aa49d277a29945be58245b07b12f1d6c0de9662ca182883b665132fc8ea582e0a38d0c160ff9b43b03deb2271e30d9878fe50d67ca01d37b6290dc156da8d142037e430b6326516675d2fd3c244dd40749c956a2882be948bd5e851d340ce99de00bb22ce08929438ec187d08c2c411faea3c63297ea6d6598d8a61d1bd4376dd4af304aa1a68c32bdc1bef7bc5749062852deb8c72f621f814505017a9722fa4e4c2830c48a1af510bd6c98d8d2bc7ad632546beade437f9134c92f1e9768f692d2108abad3ad028e4fd7d2c20af174ea9bb66271f2c1ce928e493503ee4727304e2a6536e237f7b9d4daa2917172110f60002f7c919761ebc8a963b0223d2a36f9575720d7ca278351fa4614104d5aa7437e813bfc6eeaeb89ae48737c3092ff0c4ec970ef0198b6ffb19a24afb9732e37b75b0962cd011a4eba0676a9daf98372e02a560c3fc4c1927446b6650fac466d99fcb8b659438c024a2a5202f1b1763cbcb7faf2c62fa866e1d1838863a0c979258561b18338457905ad006001f5c58b79c3817be952c90768ea1347529b9d23e0a10f7737eab3687d0aab0f20e94b80c4d7b7c8f2d0ed8644326095177515117d8b3fc61935ebee9dcecd8687dd3440a570eed3b656459b3a171fcc649ad95dfdd7a80106d590a281a5a8147c08ff9f1accef02bcd145c4334ba30a2e3859b1cc8dd06657282ba7fa7f4a5d38cbc1ad34fb73e305708a13be3f55d4004e991d5c6f41f53c04ecaecd47d2673880f612848848efc82bca7f20405d39f7657f76b3a01b90a5c2047f8375110d096cf8a9352e2c14fec9493061f9afbc89f2f8c270276ec8b216a8d360017ba35198ba0d9cf044f2e5e2d2b3aa7223dc78007e141626fd9be14c3736f733a60ce4c9331e1868b916e25624b0fd718c0d8fe853f1363abf9889a1015e1f63d2e5c55aa3c3b147d009fdc0e32939ff20345821f6473bddd675739f7d3abf0a62318f37b42b050acb166732c3ae4366d0fa33a80af0d70cf94c1fdc99e0502ea712cbed731511c193823143e09a9756016b182d64684a2d4e72915e5aba754cff6131d289b67ea52bb53bc7b4e0af2ed5577f8694d1fa5bd8a606008cf83781622ac8dda8f0fbf7227e98f83097fd0efbfb4d2607f749bc7771027d5b97b40107936ed744c372ffd5478f229564b927df6ae29026fe1de2af207a169f2b50b8ddc95d18c5588dbebf5c6e8acf093dfd7472ca5cf68b7239764b2820599f38b7bdb8d4b5e4e77db69bb05b56a4d426e084db250d8529db8fb9fc55849f24b0d149a9b59e7f6a168daf67bb72ad697dcbbde0df3c6bf9f3759e374720ce3a5226007d098b13b7a7e7bd2c660351f6aebbc97796ce888b89be527daaf1ea6437460f2a1d922a5b84616a3714efcbe8df14e05e350ed9f452514ab1d8b5aa35e3b821ba81459a0c9810f5c391d8a79c21c81986876c834949e6c1e409c8cb4825e22dbc73565b9ec75c3e9cd475a8ab3d5b16d4d42dfc83251a8cafaf7bb9efb80d14429f622ed2a6ca81372e8173b8dcc4a4f76b311206960604089a280ac8c4601452d76f96ccd25ea240b68affcc50d1cfb6237eab2caeaed3d197b86b6eed33ff3e1e2baf5179805d11e2be948320d8d4cc0f151a09c0f9b547e6f72234186c19976788f0b1b9c6c9fff1307196bebf369187ac002c1eac8ec7f5dd2b528de711546e76a57781a7d34415589a0d1bacd3116e152f71aba294fb14c6fec62d604fd032399061a928ba21f696b58371b4ac4eb27849cab088d8b34d84b3f0fa61d7f2dc961","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
