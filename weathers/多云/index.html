<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ace4590c660f79ec546b0553a079ee9e119fa34c42adddffb8fe9b241d5b49e070d59f6d17e5a6d7c7fd5ae28afd95b3d11ecdb79afe1a854dc4ec8a5375c88b78daf2f18e6b7dca25a62637997256404e4f2e51240688dc23502cb267b0253981ee36579aed5427a3126b7000919e1312fcc583b7724844244ecb8c226bd4a24ad1f54cea71386110b3a18e65f7223dad46848cf19d2edf1ec9986bd6085aff48f8b3f2c42ce0a987a16a53843041fb98dfe49efcdc253fe09b37e551f90d78289f046b57409544ad4663dbf27ec7001f099526372fbd3271a6c13466507fab6c190ccea47cb3ebaab030ca5c530b2f6e35770f0ec6e834206e283b845fd5764e427dd106faa9678e880429ce44a3ab9b74627467635e8312ac9633a16a829bf7783bb16d8c6e1c028389dc414ddd34382dbb2298d5df1929b4f9d141767664c169465b1e4bfbe85f286feb6fda668d5a386522fab5c2e4953f15fa85b6d2ad8aa4ba1b75c0fec5d123cd7823b7b2cdc2b92aaedf8ac3431e0e6fb2ce01b9238a2e3e7621783ab9928fc50785b5dcf6fde4fcbc10893b139c224ecca08579198a9a3bf8c539a636d82a8a9b374b36e3095af3d0c1ac4bf8ed21f0eeae573f8585b3d3a89ad6db37591ca747bbce0a279369a5fcb8413c98f8b44ffb9969859c3c45a57402e033e19877ed46cdf00f4bcd03712e732fe3eac47e4f5a420438fd1e0f5598634f37722ac0b11b12c933b1f367536841c8b7e456cb8ab868069b62bb5475727a65f6981ad072d2ba3f2fc1313b76cdef88af4d8983bcdb78e305c28b6e213686391ff5a1d053105ff2598cf6f05a4555028c0ecb26677d7f3fc797a31751ace318fd8365915567248a7d83d2f3cc95e5e838adbf738e62abea64892d859258f8f3e644f3d49b9b4a58f38272a73ca3c310085ed3c4222f6b673493d9723bf3a9909cea12d5a100791267091605d37416b3e88cb2a4549ca4f2e8f31344638caa9386dd5c4c78f7670df65191e073c541360b9cfaacb32f553694a465b1d3bb0628923da7025d43943f2fdc62ae2f46cd91ebaf7035860eb3e8534e7241f53d9564867173ad34d21d2581ddb8ec6c622fe99c438cae35914801d23245dcae8966aebb0b301246fb2862b946a3ac4f7e47b3df3f61c2e1af372cd9fc50b2a5831ff01a0f0e98e931aaaedf5b539a17ea6bf802c6590ed57b53281ea17389e8d45484c89eb055b8322a3f1818547d8d072d27d586cf61a93b38a71758a8e63677840b1db96f13f345b0790759271f76a69b99237cc4a03bbe0ff36e804f8566149d19f10aaa1a2854bd7f4141b22840bb28765b844a6b5334fe36b4bde081b5eba6db672fed1a9a1596e684ce72e1dd0aaabbb230ed29849bfd99a412a6b0668042fdb3f0b6ff7848015da7e4d01d8764b0544ab865391adc14576dafa2d5f516bc73afb7ccdb5ae332fef9c5e518f48522d4b654b8a8ce1442fdebaa9b0ecc1bc7d176117feb692c24cfbb8ad928443758f538343c19a49e84e81057e5631d28344cffec4df21f9646ead63d114984fd1e1715cfbadaa302ad453f5c2a9a77e15d6b2e4f99bb7c9df5fbe9a01e1cb4b7b85bca93dcc45d179f3cc54bbb9c4ec732d2d4e20624e447aa9a90e28b2a856e6f3e11ce00bec4bcbd6eab44aca65be6244bfa2793784b8353d125889d1d068dbe7cc073fcbc2dd49374155ff176db8d4d030a14d825cea9806958cf4619d79cf3b79ce0737bc567bbb1b7af7d3766312ffe8ec32d22b251a332d72310f4809ea3283f997fb0e350429e856aafa58e246a49e0aee277d8361d705298334c815cf4d16016e41dbbf9d6af25a03366209d27ab77b56e15ee0ba906367ef6417558177471e6a790b28ca76b3b1f29c45022f7f73def5dbd76d3cb7d38c486d9257506888a05e8f512ba87d78917029d90b833fee25045fba0f61b12fab8f1123f39d963f7cb6862a1546949f07a4089baebeedd9ba8db85a6cb5267c59792ed138ad113ac3a384f4b301c4ec99f610fb87a39d18794e0c511a26a239a2efe996361d3558f71ff162094caeaa43ca1524d2943706796a4771be70be39ce5c6ce04d24fb9e7ea0825abe47f20161b1ff12c65ec47078db6a08e00a621cd87fd200f17dedea66552f55563b33b520cb8c5e78c64d2461256ad5d5494b7a14f335224ef2c204f137494fc39048f3b3d0eb0b597dbb4278cc5dc137ced4ca23156fee3ed1b2635f522cd960ac7ecbb7142dfd6447ce92290b1518d17a3d0517565cf8cf69780fe3f2d3ac77c7b1108bce40ddd3545d9f67fceab0a3bce2dd452ea36dafab797324491032928769381bde0a988fdd2965ab17198bb9fef76eebdaefbfe66997e6c8e7317e8980c9b01feae52e005bedb834ba13d797029dc194db6c50b56a755459874789b1412fb1aa0124f35239dd20c34abf8a1fb788ee4fc54120389b1d880098b54c06f984c12a4625a745895cab6cefe8641f8a8ee97456c4732142de931ec79cf38258dbff2ac6ba129b9c093c9b88fb0c285950f2b054df3ad8b79d470d3a998c4a585b8f0ad80a35917a633a0a78e5c29c9cfe2e60a7c6c294c3bcdb779d6de3192f64591aea82a1e557729d309a8fb3e244e81048ac76da1615a2648c78c4f29f714cc3140fb904c6510ac195d11c5f06785ca119df83d00cd5075daaa58d5a71de14ad0580b4a48a976642683890d253c5c37332cbc6d72213847e8f76601b35eaef7f31b8bc0a7cc3a79877b9e0c74b98484cf81164cab08bdf7867e29e70a8cd00d24ac23aa1c9b78aabcdf508746b0e005648ca888ed17706488d1eac1cebc62d84c4799c8af8d0a4fad6bf65833de990178567d41699c60fb0b3ec9d0edf49f7f598debf5594e8cf4bb5f633ec5ab93d07828a5ef8ca50a0135d24b48c6232019789fc4e239f02026f5f2db62ff8de9401761be22e57f49eb999bdb63c30f8044d3b8a9b3fa21821c2155c1848b9a1487a86c3db8a45d86a3c4ba7adadfafe45da917b1601dbbd3d7a227b6658fa2221f8df08cd5a73abc705c2941cea550b9a053e5514cf2f645431facc2cc0f0f077b1d43fe9dbc323a4ababb0755c104ee62574815176f2a2b182b7f276cd12554758ab0480d80bdedfc38b6bedcc1fe01d69700545feacf14a7a107dd60d353f20a5f3d7ba70c860a2443a6765645223b9c100e08950569dcc60d74125c1bd4d169e6852ad958fed6118f1463f1e9930afea80ac865d1002b60ed3b0108d294d0551fd6469b9d76ba252c40059d1e3632851de48fcd822fa8f260be5a09cbb4097b5bd1b02e038282bace193239fe2313a16c61bc6c335700532df81e9f5cf8ad3848094b161b07dd2f96448df1291769dbb843c69fed5f0cb84d012115ff2d71781ea80fd32c99f3a6239a0695b9e4babedb1e9d9c8c719f3cb5a24f82caeb9a8aedf258789312762ba701adb11705fe6fdfd8fd1f969beddecfcc7392c979962540effb3349d985cc2d90534474778965358be5a1268dd57c3c2ee590879364723fb80fa89a58694900cee13c39f90489164d662618d44ef47c149c6703f1ab586fe9c81b6cd088a4b4cc0a07f36f77b8c92d4d48b22b40a3c7c9ec8a1ee2e90b008b9bb8f8c9d62a15b3f9f43084482b420d5aee29c9d4ff1abbc8689357df22c0fb5acfc5781ca0e84c82a9e237f498e1de031ef0700b3eaf5c3437da8764f73ba25877b9d648c0acfad8c92e1d2d7800ca9d7ef6bd7600c19b27cd090125ce9dc422f271b8cc5788056d108163202b21d59d08f7e7015e844e746778ab1e27c792f1456c458d8045405caab9d29cb861342a1e17d6f7c54b60b11801cc652bafcfd36ca81e24e98c117fa785fd9c72d4537cf042e2cc95ad356c5ff14180f56e76bb255118b88f759923bc4582667678cd5a70a47e86c4d1eb36b6cbc20ed828d1e55974bdd96f5d02c25c82763803fdfdf6b5bdf47272160634fe39fb0b9814b22362d5090f80f4e336d65ad86f67eb66b789a05c9d6ed48c6719637e9b611cba2b38a31ee13dd41aa10c1153db1ee4e20c4d28393780fff745954c0421a9b1d1bce97f19ed0ccb6604f273067e3eb0e45b18dfa5af950e6596c36a82e54f0743a76e8606a27c8eb3595cf11bd68d1063ac0e95fbffb9599f0369952919abe7ce128e7c529b3bd3dd95dae3c2314dde0c635cc91193f7c7e694bad0bc888dcc2eac2e6c1f1f87daa88d0dec24bd9a4eb8cc59b52565355745340b7001f3aff7a8a9621806d70f1cae7944b9f573b402aad87e4a6b8b1b3a2887650d5bad3335e20df1276f225ca9a849109297773c0db25ddde1fdd05136a88e1b0e1cc27ce0aa7811a22bf8db4cfb8043f738f7a93a84b35a12e3cef3577808927d9e5824824f21c4882df0586d64ada43999dd6925693d146e7cc7e36ebf2df18ecb2134e2242fee9b7a3f41dc5a3a9f9e42a6dff2acce9029ebfe10d17d651eb9271191e11c0c235695776177f7032fc45858cae44de8bdc6f9da0a0717736e547f64813cbf7f51510573d94fa26dad16990c34804b60e3466340afada4301fa50867dc85ff6f8d04d8c88eafae3083b06e2feead0d5984d0d2fd7947271291454dba01c7fa5642c22bc52597beb7e2591c628fb38b06352c1a714e795d3531d2704c586a395bc6bd937d62556b78917ebfde84791243c59a6b904a55527ecec5bece8409aff69a39a9bc27c8ae6bde99355c76266e57b164d3b664116db5714f21dfec910383aeceddd3c61c39429ad92cfc29adbb06420328a0780f4b855cb8a3e694a11b6e0b068543e12d286ce0c5eff05c36dccf112cd52173172099b3f19cbca53abcd42f66ae79dbc0b5b97f3470f985e5503b819d904e4519336150eb0734e7f930d043f5eaf83ca098de0949427deb14ad1e55bc42068a5b877f8907cdfde81c62664c409c311d7710c2ab6bf455a104ebbdb75c25b5eaf73c171578c055066e640e8767c6fc3fc5e2be0456b07a3991034b134085979b71ae7ef2e7d12592c5763978adcba0d0831b3411823282fefc8e557ddb7c320e21ea4c25dc4fd3addfb476efdfc02d54e9d60d3467f298bbf1f1b61fe38efb49c27ef3aaa5127f7053e56d7d9085158198ca2eb531dfba9f804b970957578a6662f265f329d5f6a8afaaf99af67774fc387dd264e1466cd7fa8504187bc1dc7f222839295a9bfa6830cc8562a0150c434102505f49a996811119260809b2a79a77d5ad55b086c0521bd78dccec2fe8881c95111a77bfcdc0dbbbc4c18c97102cd9e088fc73eb31306f0a56301e3be3aae208e35cb48e43b0eeaafc9130c89534062277ee0d38e5db06f172c50010426ec9716c2445125cdfdecc704289f8d2b8dbc7790d9b2781520068f67b21ec5fb964b9e3cb01a244dd3ebe799053f43ebe9247f0829785d6b65553f0b729296dd221a9faed8284e4f869360b323ca5518a2dd97bf539389c441ff33643ba42dda2a2a07e66437d49c0cbe2616cdcdc105a9bfae96126c5de316ac705266e4ec5257fbe807be01e54522a47f0e9a8cf0ce1f70060e49c40751c171cac28f0e50ebe7fda1c0b415a8a5ad65e5a7a60ff859f6d53a86f03d15a5eca8ad4ac5286af9d49d917bc2084ff2e8086437455fcdb074886136c8774480cf3ede8c8d752f254374bc4edb0472da23c78378029b8c28cd484931923724a0439c35a821a47d4f12b9485ae516e17fc6068f9c4330b1e09594d8e1844c108594fb64fec66a7dd2a96f5188214b03413091ff567c2db335da36444286965ddeb9bdfeb81646d443a3fd6d199cf9e569aad95c55783fb506ffb0cccfeb33bab44209dbbb3e87bdf5c793bdec911c953954e8b922ffdc9d46bb405c26db676912939918060fb4a731fc0f99a1bf723a3ed436098e04e9c855f364bd5d5c6163c4620e9efa328f7fd371b516bad8f21a804f82aa3a225ed925684714a79e3f189dd48042c5127bcc4fa45f1a6f73fb69821711934481aa7e95f1f1573477826e855d8b5bade38f7adb558c48891a17a9786695dc3220d83993ed951627cd31cb73bdcb52dea8b7f6237746db23dfe10ec809bb8b5f0eb9a4130d76084ead8ec08c477663aa88756c9964ffc668d1e2f5121571bcc596f037571a961d31fb3f0db82d173a54e07d9656ffda1a3a5cf53af1dcc52a1c83cec58c974d55aee7e2c33811a43141c385b41def908387fc12f5cba7181a982d2c02a2cb4bbf55b56043395670a6fd4ec4a14178dfd8cdcff2f55aa84840c77880713e934d68a61d97d1c844c1f8e4dbbab617a7190597a17950aea19e0a8e0977b0a549f92b3f235d8b7438e985ee5e340f122c51eef6fa7d33af7c029fd4404bf119d8678a3ad33d5e3a173cf0cab5c4071675d96234b0ef570c4e8004ac373c9365c6743ee3118b0a756a61393e6738ef1a7fd716aec31a4bb8e3fb9eb487aad28b966a2fa129431d2ab68b18c25dcac83d5af3619d06601dacf057c319fd1b6b4fec6f22154553a398172f5c5ffcd65805160dea42cdf5c99574fb2db78a1e903d6448f533e2e37bb5ba99352d5107750acac8239f6a7f63ad97830ce4ce1fb5aa9d9260a89b4fa216b72772de573857bf0edca28f6880f0299217164d6af0dc1890486c56d3f12e12a4cd8b8a164fabcf240e9aa6d23cea202be1270dc1ef8700a6225a5976271ea6074d3a457e2e535f6a48184af0230f18f78796c855802d2ec04115fca205c75c635bdfd5ff3427179022f1d76e6c57aaeabd2e4499a7bd6f1ae04b29d26a3704eecb57cd884b2ec748f0ceaf4db226c26c385bce740c3a5e9e9b556f8809741eb114de9c348485bf9ee46d10d4f79073e4e3ff2cb78e0a5f666d00e3883553bc92b615147e8af7f24a1b0132125729387aa20525ae81b34de79b7ceacb0fba0823134249a1d2349f397ec71cec4b92a67b4052c2ff98319ae8ce46be3bf537f1835fb04cebfee76753a084f81db1069accefdbbbc2d46cd8cdfbf3caa368e4644747e99322a8f3934ab0ef99eb8673ed74f6b80835349cd020060ed1aea36df1baf89e6c56b264cdac9ffbc430fe4455c9ba8f261f8c4b03d5e554c623cf7f3a70f28ba6d46e39584fa532207924f29c71f3cae0d21d0d0e785e0d1816f6d3a004576556d79b0edb395f0d75556feacf56ffa7bea2091e0aa50818b75d033402facf3d4a2a53aa67ab67cc3b7b29352b6ef18b613a1aed5026eb83b909785b5115e68f6b583adc99a9e5ec465870f1fa91dac4e25f60cfa0c40cc00ce96407fed1f1830d83c47290e47c8e59b2f523bb84453cd7360016a80410258a3d043bd92cbd688629b1cd085c0dea03f1b6c3cca193808307b56ff6d99c103f340108abe46a2275ba8953f246f96c537ed328314c9ea736159949239a3ac916ac347f511bd42c11d243c43f7c4610fb3b5e73f477928a9497760843f205b5247aff3566da154ee66275fb6d3a481ae2205ed72bd7973f8d71a5727c5d6a50e40760cc3bbdd53e5aadb07a1345893bd59b4298abb58911b9958a656e4fa3879d18efde15e465205ac667acecc48f3d96aecf28b7296154bbc89c51b3889631f051e994c5eee29263d18bb5ecb52224447021c6b4c5a79a8a36d9a41a746e16d413397bc11577bfbc15c2802917f5fa279070651dc0b67218ca26692a5df8b9bb327c9a23b95ffa860cc7275de9afba851396fd7e87d0e6562d367f5d47685b490711074ed48444acf2afa77a775a88e0557941f4d8747b2c387aca8d4d15e0cd6133f8c6c499708498fea02fc4aca2e7a81428717c61a07d09f8054c64a06c7b04030ce448bac4bf01ffcffa4b078545a64b9a0957c30e91f6f726110428f07980fa2a22ea6bbce64d566bdc54db1c7585e406f06a6140ccb1df88baf7a16793a7d0f2f1cd94c5007ea77f7c31d9439ba6b3eb4e7717194db11e1a3f893ee34e1df37679ded3fd1d352313663e9ba961a150105cd11f221afe22c0970374145f3f34f93c8bd0e2ed4e6d5bc86d5b27111986c348a9ac889396ee73385618f01f8ea8c06b5e2c17677ccda41a930862aa77e828667a179498f3e6676c7aeae27310f4dfcc8b7be382c4c176690cdadeb10a5090502fb919a3eae84b6f1beff382fc7a657a7f12d61ce04d9cf9deac783414e041036dfaef73fff4cb67b0a33d089ddf1e993e3510200e81fa9919621e72f76bbb285a4f65ed7eb6fcbb3be51a2db66b27a292b417bce6fb8dc0c19ee23196e0de4cdd5c0866a90578295c6c3ca0dafa69ad08e6eb42c7dd5d173c1c8a6fec46a35e02954b717f1a399d6037a7f861748b5590a5e2b8c0a2af4b9a075110f99748c4cfdefcb3d860831af899a88a654e8021fab8fc0cd4856139d29fbb7ffbef2105b68d47210eb3ffc40540e2db7641c7e1ae7250284be8868334039f0c7c74e48f0d5a9590328120244e5a7217797a75ca5e2c46f89122f0554108059601535af894497e64e070d150b26f9fbc4a26b6d4a2e3da4ebf7024b8d56e07c23f71b321d4f8ddd749efd3867ab0917859aeeea96d45d64b372c5b3c4d9472bdfc4584cb739fca8672911e2bcd64edb5bdc59bb555f90998291963fe75a9b75f4a9d1974bc8bac1bf657b332080c4cc0f31e322e9d8d74fd922b6a266d691cb7b0799593340e07cc0812f8ff96e3d9832d2f785aa1bf253fc048b7e0e7864459165863d9d2db38b5f3ae604f931536978978d320957f6a7070c808ef15285b4bb0c89fd27534ef1aa0baab514524539aa9eccacbe0a218d28679f2cb5f53930a5a90b592015aeb0be87bedce4e57523ee4c8a0546d3532f4406f518ea23d9a4ff0f755ed097d1561b5c1d6e75c495aa32c3bf38fb7adf8f00dbc3cb285498e63626499933013f1b758bd74cb4587e9e7d76f35513463c6318be52be5cd5a566e25493ab1e6d41b843ab42cbd71f5d9a2f2f2736c0ad8630b70a703d9417a0848c0a999d2174f4b9d1883966b459066f93cfe1e76ebe51c8774b2e3da4a516df10d839df515c2957dc27107912a861a42cc6e0de28f5cef3f54fc2011a2b11f741666b3b012db93d99677724fdc621949dbc8d6f3f718d0cd6ad11953b8bfc5751079685ef8e0441e76c489c136d746e093e6543ca796a57bd471f114f0ce81ba8ae127d44035439b4ae59fd6b395f80a6d45b2cacb47d5009cfb73e9560062745a486958142a64c999ae7ffe714b26d8c8b92b5550aeed8de43ae7721a82f69e4d2986bf4e269a293e28d3bc62dac7cfefc50e101b78579453338db0857bc819ffd5d21afb64207537576474a3756710883ea2d2f05e2dd4cddc3a3af8bc35ae617658a741c35077a457ebad1f6425ec044eca6c76d431e435d2dc40dd4954e3866d59638352921a063e6f4159ddde79f3c2ceda105aeb0296d385a3fc490be5f8fb0011ac680998c2d0c29e5d9e67a8e0a9e3b57ee5d0d1420511e4ff999a3caf3ad1beb5cc16ba402cc45644fac32555a78e70ab7f081818bd1fbc0e1898e98dd45b37c1a7be2a93d53a8f56e031a71e23998c023a35da0e31a254fa17438184102cedb8cca8f2d8f70064959b5669da3973e25bd5bdfa8ac5ca1a9bb3ffbf15791268c10a2d9fd124647c656910a87a5ee813f4c786c6dee73f199ca07ac4e908f834a4f822811242d128ac448d3259eaaf4b370f6da8765822667497121af941d50569eaa25e9aaff48eb4e5bec451ccb40d47e52c967c611d8e0657fb3a29091bf97d653be42746791e9a725290664c87ae788e6daa5a3ac00170c249e9e1215f8dcedd559f45a7c377fc8989f257faf95e2f95df29c2bbe6e2c4d9c099f63059d0e4073319857774602eed287007483e24b465dd23a2f5ba4017b2f7669ac24a9f3607024dafd2c125c8f2ee17af68a870562cb60603ab688bcd392068c5f3c58fc7125f49658d8e6f657508718489b804aa1a2f5f4983f944423c6cd7bcadbd66fbaad2c413a8337a4a14f23c1cffd73b772591721eb2c40a93a0b2a54247a19ea170bd2cd517e36fd14158d670bf30f3a28b26cb6d99dee94da2ca0ee7b13ba24645fc0581e3de8e1f5a526aa39cddf0a60d9691362f00ffdad2a0ba2555475c96f212df18c13355db308365225bcb734328fe651f991eed55812c03dd0e2d484191fbe7ac51afa69464014e14ee7fc7636605dc3647cc747133998010cfb719718d45bab8d4657c85373fe26f9321089be0e1005270f2fb7112e248bbb946deb4a38427ad0126c79f9d89afe3cccd837ad7cedc94bb3a3f0fd1b3a39805333126f052dd6c705e7321e6f3c7f32ff63fd17180f18bda990677d93cccb74e3fe61e1d5e929320160abc9b4d5754b3c43107e911b65a90c638582590fdf0ec424ffc3ae149a2723bbc69a266d39cc6205b7bb468dd5d91c0891755650c1d44336c2e84cae1aa705a42ec7996d07e445727a7fce38e2b1ca92a06bd9779d95c6fd32fa1939d52e04f622846c3d715c82ea23da17e4d38cdee81b03e0746c9a433078f4d5653d1e3e4a4a67bc6d4edcfc79141e3d59cbcdf2ad8d7f8c0428637e0d12433ccaef999627f0525ea1d0c075b82ff8a2bfaa6996cf757edc8d4c35441a23db03155c6ca05a56cb991fb1e668db39a9f4b1262c7efb003915a5d9a24db23a8b1b8857db8751f2f65cee65abd33025a4418536b0ed1a29cc5dda24a185db53a276de844c13eb01b0fd6052dc4219b24b4243069fc79c1ed6591bbe976c6f2b3e2e066f2d6bde690b194363a70c7685837c55c9645072615e41014d59c596ddbfbd4390ea646676f9a524fdc296438fe95af1043f85d74e569997a914ccaeee3d90c8b9a881b49bd5a086c101a39c2d0cf6c3a12f6abd67588af6187438bdef8e6ce44346b5d73e8fae86e6360b84176780356573506bd6b2fef88870e118003534b1b301e6338e5a08d96049e4cadf18c70b6e04a84f9310191752c257545ecaa7405d25b605e7febb560f6fabe695feeb53da956e1e673ea0412aa37d74a02591fb48bc539ea9b46125c6b72ba1cb7ed0f90520dab9aeb920f9e2a44c484fb70c7b40c7f60888aae5e155274f25c5213d4ccd0f6c8948ac202e83f847895cd51a20accbc2c82acb878b469159971cb739b6d65fe8396f2375539bb5c5224fa475151dc0eabda0513135037c86f06941923acbdccca2bcdc8d470702225ac45f652288ada6a8d5cb3841d91129837f43196372c9dc1cced5d7c957bed9a4a8be73a000f81d6a65a51fc81291e919df1e2de40c2370c90bc318aa8b60e8453f64fd21075400081edfd56ee2567feb3feb7d67dcb68cd5f3c938caf3a5e5b68bdec6dc7f80bc33e0fa6cdce249abc617e573a8796b931efb516f8c423493461b675cd77591dad2e0f39a99f25dd6bffe1df226f03f55657d498906a2b8b2299615dc11aae7b3cd89dbb8625ed6e8907aba76e1f7409d22b94cb880f8fd2a099af31cb1655eed8e80a04efe6f96d4de7b775310247812558817ffe47cfd8de820c606975418fc6ef966d30bddd86fb96723d882bdcd22443847d91bac27384aa05d5157879b1a2337ed0c493df2b21f352333badff160ec7583bcbd0eef61cbd9defe0e86b77e800b4509ccd53a0a604eee38c18bc86b3126bf8103b8af4cea0a90037a12c9c7728c9da2333f56ed9685ab367a61e72d9055752f831a87f4526e0803f41d165da38589b23de9539a5b5c69632e11bae4b815ef68682551f89406b36471f7a45496f2fb893aab3718c0906d0bd7281109dcb0e83894d60e71e2e9d03e31db83f6eea90a889f6a9c9d97b5f5c79ef52c3d2599a2622618a7490ec59614f60fa2acba6204c694bc7fe1e22a2ee7e46a204e7142f18d9a9057688c37790fce5a5499741e3f47f5e1c997282ca96addfa6bc4771a93ea5cd82aab9f555ce8102fdadd7cc32fdf2566847e1302deee70dc7441121d1efeff727b2b3f9bd7c18c34d20a9030811d5ee3de406840ed885a05d9a37a50bcb0f0ebf80a55506a77de6cb2c22a2cad41d516b2306dc8e679d2dcb65c244226465e96047917cb79d416fc76cefe9e382f0598dd87829b2d866e7d5367e78d3d2938b8f1d4a33a9200a070f23e403c5e5ebc0ea88220a0e4058b0af031ca4cbd04d9ccaca10d8aef60b65542742bfc274bc3e77e6e641b86ebdc3cb80a5ff8f8c638650356d6a5b00733de48eb271ab7f36f35815545f961dc4b3d7db4b3acf342245ba108979030457456877e5e8749d3ec0317ce2f352c4bd39067af25a2b4a01801e62a6d58ca43bff94804bf280841ee0643e0df21b4bf82ed70cd48ccff33cb54e44b80b52057773d6e917be92b594ebda8dd8e2942954a6f249e68ce9834e325db0d3fcaf18074d79b8976209cd8fc46b3c7e3b5d7d3114f6c15bab1c00a0ec678d0d9fb3432e8ad645918f48ceb0e4b42dbf327f6eb0b517f3faec4c3d92401362022541195c45d31c6e88ad0c277ffcc2866282e77ae8dc949247cedda571081ec23c83725ad8c385aa8ea34009efdea24355cb3e4563025779168d200a75b454724299550a95444488e83317fc62a26b7cdfc660078b28947723c6a20a039092d0604cb8498b4f98b6e52775c27d93d7903842bdd1293a4e149f6bc3dd6e2d684e80332587da578529bd27d7aff0f8c5d4ec5afc7bca5956b54bccfcdbf0a2165426586ea04bf3d20a0181aad19f8a171434e5b50eef71260966bb64b90625d6c97779cff581c26dbdebb99b9a2f6ff69c3bd7023b842668ed4900304893fd4bca18e6baba7fdf0da91b7a9f5f6a06e25f9a675e8ce6d534c0629238738c38fb0903fbc50f5395eb4466791eb3e237b1a1ef84b6afbd503d3af89aa1c4088146d5252b73fe16126b08b7783cb0e17f718bc4b5855f4ac545361bd9fd680d1a1173a33eda2de8143bfade28df42a1fc3eb21770cd40de9562c726e25930184baddc1028701fa7240cfe8079e114ac3166185b876c1c738f738fae08ac3b7e3d8079310aff467cd5ca68f9677511c48ea4df05e07ed17f3da70502d087496eb9ab0f1a2b3598f7e06c25665fc0b03f0d1aa73c176f500683e1b5b5a5296aa1cda8940d3b42e497ef8ba996808959f6a4548deec9a2fb728126ee155d5678942978790f821ebfa62f4919bb34c9e39912cdcae1cabb41fb811a463cac00c5e7b6706904f4b52b4dba3249104a3e1547cfff9f3c4e87ae5628fd8c445e9352715216ebfe8e21359232f3bf31a3e38ebd32a5f1773375df3314f9c73d3b8cd9d23fdb369681bf08b13dbec5add47298abb353e921947ddee12b18dc20f2c6968e30b33b8b835932b7601a1a5355c3aba45221fc94212b7f31e108073924b58865a694934ce1da57dc41b5e0e9f69fb4b060ec70f123f4f59bebfda7f18fa46817103f823ee8318b8a95eaefec3fa9b77b0a9ea9132af688b1a47b47b8d911442232ff8f40425632dc81d67e17e7e147ce594b300474a2f0be1c535b2a40604fdb3233744f2fe63a19562c824b22e88a57938b6daab9cdeb4e632b3877fe1a7d8d841d84061662f2085d5f4f8e0bb48624c71c38e157f26e96ee54f975965146964578c49ec985eda453a8910c3e0a860e729250fedc2a5a029a6e769e3d5e7151a9a11b2d404c0be05ad08e1dada8b73537f5141fae44a16aa20cd387e6b19bfebf8ccda0cf5147771aa867befbff8bcc3c74df6d7f516f832c8be8841485a4b8febc4f473afb5fc897fdc1c758c5a7cdc0dc2c5a9fc631fbe9dec75443ae36dbe94980bef700de5d1586ec3c0e7f54717da89e92817ee5cc42097935437d33ec6362702062990d9df8124c82ca24272d8880a22a8e3a0b87a0d09b9f18be75d75c1a6f809f07c5dd69aa90e11cb7a3e6bbd6f1aaa18dc64ce322679d8cf9cce2fcb3d6f443754fd160a50d951e5999aced5691ae684e6cda9877a422699dadfc5b9c4c69b231e6d1b5d811abbd3cc68abcdcaa7e69d08529c5a068cf4579c5ed337dab5e009211f5ea945b7e2e684e309fe04fb7d33e0eff29677c452d983b707f921fa419b1486cd8ce2352055e37a8f89738a2043bac7aea6c1b266e599285bdbdb19748ea9f19b1ac86ecde325b80a49da78c16a839a25d2cef6fcc17edb705619dcf629d4dc40dd29576b9672f7c6b0d7e19910a41dd35a6fd9a7cd3b22b6d78e0df9708eff9171bfb04ed5edc4f0048b8a4871974066323714fab3e63c2d6b3124e8de795c14b0702a09c56b639832c44fdc5eb912917cb16282b43231825ee2f177d4f19146f67365dc219e38f71056e7b1c6ccb7c7b0726ce6520a457a2ab3ac7492b649b3f6d4c773cb2d77b91a80863871e7856e88d5e44edf50e792def0d9a5b85b51b69bd9c409dc89a690e9fa4fe6059e3743dbedd376410aeb661fd4ab6288cbcef07f1fa19c4d1a173eb35e2d57c46738e05a9e4877637f282ca39d91a2789f9b8c18189bbc5ff566e1b36b975d452a65321fc9078e6de3c46c19dca3f7c375935dcf7005b36ee5ec0c28e98ed906cf24a8df13a54639b713333ba2a51564698e129f16f99675d042b3856779ecd9190b407dc287ceb8d9a406836cfd37defad404d9eecdc7320da676e26e05f7721304c15fa7caecfdf99a72ae45e99eaef2a6f8f81ee020f9c29b5a43d4340f11fb8b100beb3928a9c14fae9cc5f2a4264600efb772f749c666027c3aceec58815a570a33ba8eee38ba052d59b18e245b8170f5583eb2865dbcc5afee6d10ca93188bd7a54a711d5f02820f9491cdeb8d1010dc18cf76760de9611fbf31e106f1b51f1b99131f2e424b60dca5afd6affa034ca2ccabc26bc3b93267b893572a0b68bb5102948fa9788c0cfa38455f395b989ebcb983a4f00b78d8a068a37a7598c41b3df9f2c5030764fba63784955a9f4123f4b69e90f11abd2a1f32ea4a1a5cc253a7b0d5e155484a3e6b42d9ad970b5d9fd4b3339c53e04cefc76b28c9db5901d8514fadc6324a6150caabf0c0a18b6c220bbfdd23326d7a01b940d78349898e3da8e3dcb596731b8541e4a53dda12f37840c88fd1c9946b6ae6e9d57e650806fd9346642bc53a7451d8243329fd2c75f959b1347354066df11e4b564c35cd93e18bc1d30821ff3b489334c8cbfbc011bfb518b5d23ebd52f7f997bcab65e6a2002b5a6c9b197d9c3f8ca87221bf918eae1744ef6e2c3fee8ca142027129dfb3d0441231debe65a2f543b3313efbfc0737e5bc8e982224ac10c5704f9ae7f5664a161dfbeb6545ec3061c0ea6882aa595cab3902da4ab22788906d4ce6ce15f5c6fcd590a53a9b6dce65d9adf4b2dfb64724fc5a6ab5a6236438e0a3bac045ce14f64482713af781b9b0e8c6c3c61873127485194428960c939a34d98c67660ad1a733ff011a1df612c404b2e2b8db0fb517ee5d7959f7aa384c151ba10b829e99d4918a04d31af9d32f677b6f2fbbee971b3a37053b6c7dec3d3966bee56545676874783182e62401bbe8f254995773e68815663f3aac737c1a8ca41fb37258927b0da690ded8eb556f3cfee5024ec553df858e3cfe239c9be7e35360d97096daa963ac59a9a5dab993291537a0ba9ead06c157c5f64d5c80b2380af76121febc2bddcef1da6ca816565fdda0e5713c3e61a170d2ec99546cb82b60d0051b31b5e6cce960dcba9ff37524a50ec984bfbb25d1280f65f47760b32d4985f9f9f32f47656c5f97fe8c8a39b2bcb97d5758d0ddb76ff8c2abb9e871227d83da5ee00cd65d2d2162605d354cc14d8cbc2c319441f3fc78c727fcfa6717151c728e0e8ee8e2c816396ae7f5f06dc8a6a07d1624b7dd6092a2a9338d3263882633015037f148f3257d99cf0b9c3e5d93220ee91a2d586e6f0e345eca400384c544a31f2aae41c89d9b8a9bf89620971d8e0cd1b3540c5008c1d5f825360e89d434dad430cd9c5b18ca6c09aeb60e0d5214277e2e4a1ff70da7c3ea4c734b1ac4f2b76e6a795c62b2be61588a96ab04b29cad65b42091c6705fe7bc6fa351e9a5e18724634203c0be1f1b7f337c6d51dcc6acda7d2f9556f58355eebf167ec1025ce6b67ffcc2a9e5798cb764ca5e4f06e21eb7ea1e14961a63f4ba0acc065bac79afdbe2958a014ebc53619bdf296ffe078b0cab1852f48c981743e0e3adcbcf97bb0596be5a78ccbe603f7a47a49966a8921a1fee1c07dcee7ac0f35afc8538aef362bc443389af46b0d5edb0401a750ccc29e7cc1b142c83b4bf46af3bd6462bfa34c94a5437aaa83b9a8a6e665997f08cf3c8d5b6c4231653981ee4e45e385b56ff5c3a40423404a4cb8d50e8ea048e67ce265cc9f58e6780d2da70f7e9b9f07b883b5eb12ceb06aee21c8227a98f9dbf9799f2940dce1dfdd36df30fffa7c6dabb8240ac685a071b4dfbcb5cd27cea586552ee7c3589b364d0a5e4b13f9bcbd1cbcfe8463ad6dfd11a5fb82eda6626f9a3c2356d82ea805a01b336c4cbf8c269d6520ca63e03f8e0fe43a7e8e63775ceac2f676b129c2f511ad642afe23fb3c06e829bc56f2264386df3ea347d5bef1527e4551719611af6c9206fe67e3b4d82a72b10c10e62a4f42bb0144fbbbbecedb44269a417bab2e0724e5bf63c9d9dc63dbbf74ca818f5c1331cd4cfb9944a0ad67db496aaf39bdb4a07eff0d58c927d676d235cd3186fef2efd273a0b0f13b18fed1362919fd0fca7c3194ebd4ef77aca85d7b08c3a7b5f24091ca0d8ac9bb9707c942ae0b2a71bf9ca1b82eeb6fe9a5b07df24098b71a90bc623975bb2ee8f7404bd73f8d39d02ad4a2f8987f4f7532a41bb45c17c85fe079264e37dde2e59461535d92139c9423c89fcc6c2fd926cefcff51c4232dcbd8793e031771d851a7546b7551ebb1b208e6cbac2331f634eb03810dc7014b99d4f095933189212d198895cffc078ccb00da0b860d4720e9d91b1de5c6010af3c6f492f6f3a082e958547828847a295704fbdad08f392de0003c9518f79d8201070780d8ce8fd3731459857df6653cc98d2cb88b30d6da36731b7f79b91af3df8f60f714be4e65c6e121ec9d3f561ab11c9119295ef4df2e9c86de5818172f80baed3a216043b66edb5c271e9d542f0ea5ead353ba921bd157dffefc551657b8fbf256442e1bf0979be8dec8d51a0d6b23db6b0b97d9697a93aea338ce179eadd7c9adea1ce359790478a13c2b9a1b89c8c28cf0ed06aa2da4d14fb96551b74f5ac4ca17f7198d20ae336fbfc22ec59e1f5d544a2c30daaf2eeb5be3c33a6ba2b132db815ebcfa4b423b158c7c0b1af09510d418163dd3e9943433ae54a807bb4a65881624ffd19590049df91dd9c6af1c61d3a59b739c650024e71db4615fdb703e4d547b95af22bf7c39b5819f298ad575907214c6dbf2977866014e488fc08ea11d0f5a5edd069464d4da9ae638c535cad3b2800014ba918a2b60bb7b549e7a6cd0aeed079b6a5fa5cbe4a28742c79e8b9e90217a865c90276c990b0a4ca02f82d6282e7f4f314a047bce33e689e0b90ed687f64c2b302f0dcaf017cef99f669c210d23173f8860b1cf24f3d80697a1368c305db85107a00f1bbc9fc4a3416fce251f536c8918d534a41d47d18edd4cebddd0cc69f497bbffd2d9eb72a5f285c02e1e5815ef7478b00a07ba31bdc72d319c1e81bfe1b57dd4ba1682548388d09d2f340fc695e13caee51b05a23f9060bfa6a6a4f50b0125c11ff4dd5e00b14fd5dc9e33b12948778feb98dc47cd9246a6ec214df2146ffde1e2f7dfd3a59ba3e4e32941eed3d59829bf5608b550b435c310dc7bede93ef041c8f4bcd95c9da43fb142225312605f0f2b62bdffba0a5004d505491b3f9f6380891f88a642f042f1f57aa9df49dd571bf175ba006ea7b70e94f15557f4a2cdb387d46e420cdbad46f1f2970c36cc0e689551b7690be41c229ea0b1fb2f1c8a39009f218f3a8a3b4b8509e8b5ef86d33134fbba21d020fda877514264397b105d0cf2ea5428911c74ed38ffd9ddf08f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
