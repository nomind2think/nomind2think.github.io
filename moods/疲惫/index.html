<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7660e1039a51f5cc9e0727bca21a0c1d1b42e6061c1dceb3c69d2a735048b923d810f82b9f13320eca3f291ebf2f055af110461bf616a230f5403b2098704775f9961fc2ac1f7d6944894a20bd2c1fd4b0e1c0c42dd56a7931f1062e469d8376d714c3b2e136910c18801c128175e0e72bda6cbd4e3edcf4dc3281db321f67c7bb2c32dd009e92c45c65f8e06af43709fdfbc0d0e2d7958e1d120312d725597698edb742d3c8ed85ab726f4e7c46d808ee02077fd2a789bb4d5dcc46c9a8a8d877fd7910303993af9cdf60441139f47d6a495127d60f1f95c431f9e82b19f8927b4b59853782d177b54916c6721cea3ed3bce1ea8404223a36efbd59e643433bee8f06a2aae62857de4288ddf209b6b1c51a758b3dae69e9978528d0e70f570b59021885c8cbacaaf930950e7136b69dd44d83c327b58917542dac59e0f14b2daf53775a155f3577693cd33d1ee2e365314aca5b72315af6e44493647c313dd513430e8040665d64bb38a79a6d45c2f598e6898e68729c249422e938fcbc7811f5300fb2cc06b32561b16596eae5ce6469fdc13b9e541d7dd40fa84b2d4987ced41aaff638051b142d1a5c8e71ee8515257942affddad52fe6585c252e410c4c6fb268dbf180b075f351e82e649f5ac364e8c5eb5cd24a6e2cfe91a4e3cc82d69a2be49bb1df44efe76449630f76e4e8472865431270f888337b2ad35224d101c06944f9eb2cd01db9756ebae4c6af7634b288ba4b751532b0bb4a60148239b799bf3363961198784cd3b6587557aa748c0261c4f534bdc4b0379b0aea96b1d6e9ba064ccffd4c4be4341ce993f2db4cd052c28081275af041392607ac82f4ebe271f4edce67573bccad16756760d7e4a8c14cd3dd58c1127800cecd62ade11c0e3b683d56eecac4d32f815f045694ae1d7076841508cc98b765372838c06f619f934c2b7e15c89b06f3841fb6fd3556711205a0839b663d96cd1bea5b13f5ccdc4bf1640dfcf30db72979a388e0e0e31b0bc7fe1632b31ff66acb15482a85ab88d176f0374d4e78255a8e68969fe996c80ef8af272bb029926c2400c89b4025c8f40b7f75ef89fb9511f001b80ecd4fb4d9ba366a4e2c01f38df6f2e67c3d2e98e3852d4d90251dd1e6d8acc3377d7a30ab4d5ad557395eee7aeaed4abd01f5433a57c5642a195d9354f523f51c5aa22e4f925e661a9736f64f7bfd947ad953e89596ba81b0c4204bf03a7a81b89644b47142283af18d111085bef443214ea3ac3faec5175de43099982f5f63e3a439524c32860305306a1327ce0a13e9d6d35f60855b45beee727b7545dcbb561fe5eaa8753f7cf3460356f09a2a1b09fb2387ddd7c7550010d9f49e71a7c6a5a1c0641e2b9ad2d3e4345e6c6dab3d7a43aa72a1039ba255e22a59cfe7288a57cf43d48fce11fe1e317c7023a4fb85327343c8810e65e4dea8fa9631fba83c766bb27ec94bd6fbc4b8e5dc98917ee8457645d1a9d821d25da55cc1b4f1786e5e9994ce569bc8a8a957b29c198e3aa348cdff874f058a2b498a9c61336a5b9969fcd26f149861216bf8c3231a53bed041a5bd6c26e0c9a0993e60915345a251b97c27323bf75463f97993c04c67688a60d32022ff9899bda70230679982f604f2c9b5e5c7ee183cb2bb0e261f181a0cc10f700689db14f1f9c7194cfee098588c4c6da40cc5c861181c83938e783af5ee9505dd54bd8d8d032033a8a880b467bc9d4d30bc00681510ef25b594bc2b7cdfac3f3aafe5ada5d89923afb5ad3ce8d1c7a12db1c68f4379fa794bb6654653ce6e1d9a24d9d0c8cecddf0112195adebdb31db1c4c3e87ed6bb1e96f26430d2fe227b02a3e8e5212b6059fa3dea3517a5ef72dda28d15c692413a2b662b6d05e91d43b5ceac55b48a6eda53d81d838cd89951632de9ced2cf33b4dbd0d5a553040af0e9e0a9195cdb8e1902e77ee510527b18c4f59146ff5cce39cf5cd62b0f7d34869808f2986f32d3754c049bf68eddebf251407336f62288bba1e2caa73c5cfeeb49cdb27e3b36e0a0b594b0fe4ee0a936a308db6dc0c7b26bf1f18498ac07450ec4399eee79f3e4d2761b7090de47296f1208e5488165339d9277aba0c22278a0ad7ffd1db0626cb75d5b5c64367f691b254262f97503def614a54dc6ef58ce8b4b35081ed500e886c3344bfbafc6728d98de000a8d492b9851af69d81e77975d4bc1159191cb61b71a96852131ad70546edf70b160ef98760577c790250fadfca91770fdadc4a9f5d6f60a7e39be60f66c5dc9c717a1dd775e03422ac40acec6dedc5b050453c40d865a04a470ecee90296db378287cf8576ccc5eae336928043bbcf450ccaa859c4b93b2c1dada3675dc996b23b045f5a18b3959830e3bcc10b752d3b2e5be8f2e190c89e21a2426650caa71e0681f0978ec03d5be6a77b696bc0388553524807ebb1fc803cff63289111e1b99d1f021cb83d90c0a0039ccf8d7685b0e3d5a257a9014560bf417c8dc75516e97244db21d4581e9d5989dd17f17630f27884122b178fe1933010ef43eeabca5a704e3a4f3308cd2481a689233e5bf68a9555e418a53d0dc2cb58ded2ad7b0cdfb482544bc6aaad09856f3298fd9d855ee19cebeb421c7da1fae9accc77f331fa5d45b979da4b70d3337c5ae5df19644f9fb3c2ec410446fe6d105a3c9fa2246bf47d6cf57d1acea2d4e6f6f47b2ac47430399453501fad2c829a5e27b81cf9701c3a737cf78fee6080afe9be40bb4fd1885b4df335d8b88c912ab957658d9f0460c184474a0a9353bacdfa545abfb4fd1ce85491aa03fbe9fca77b8f037d9573189b6e705c2476d86c2af4c180d5455f28a5b5d83f757c235642b9155ea2d4e9e55290ebf9aa960baa2473879dcce4c78d5612bae5879c3881f5f60443af70d7ec0c3d796bfb05922627c554e59746e52c33e22c2747c63461cc36d0c6e132190feeef307140c506a086c1bb793b6705e16290943ac35b5019298cffd0e2505906e0ac38e3e3e4139e90333cae67ccc9eaf3b594ac2f75dab0cf373197e1753adec2d961175e81801e7351b669132ea1b35c6d9fd6ac5798bf1e15d17e6f18ee404c11a34684b7f8fc9a763753d80136c37e12d332defd657e7be160c9872300383345e04ffa8ee378928252497c7fa7ca5a1f0eda144d690e38e1ce9c554987f92ed98ce93b46e60ec9627501396492a32089d6f019e0322ced3467587ca80f55333f3f5a2b9b02cc06c207dbfb4378de27b4fbf8b327869b6505b1d6827ae4e83848311d6119766a66442f30d762b5eceec62741295ade3f3875dd9e633d5cd3d18cdec071cd56d088d5541a41839dd22b64bdff6bdb3eb16f3392c9a2d496bd5fc6f5858a047cc27659563e4486f53ff60907a6f359c04063bf44d6ad620f404900a2eafa9b258e197971159168429d78827e8021e1aea455d4c1eba41966e08cf56c83adf5245c37f61bb014c8850d525ac1e3cf7a4ff382a78b50988829b94e0384ccaf4754934ac1849d25b1d28481d5e257aac44bfcae49c5c93fc2614b0fe7f48356c8878409fad96445d1b14710f5fa931d4fa47daebd84d43918eaf83db59503303133145d3b48eee45ac9fdd77287dc0ebf53bc83cb92c59fd67aa14e188b132b2cd69c57289835d2d4a771d7fbbffc82a588264239276c8bf42f11ecaa593edd87d858e9345217d8c3f43c25131b58b54a085e336dc8f3d9fb6d2d626cddae8a9e8ab237b2cf96999726e3e5e77ffd72dee5e90aef42ad8fecad545c66849eb31bd8c6e427fcb6ac15bde824b28ce9e3cac94ceebaa17cc41681b6fdc3de26acadde00c64280f22bd66805e3f0be58d6dc8986298f2a3193d3924564f016dfe49e1f01635f3c739a4f8589bbc95a57b35c39adfe19e98c840608112ca640a24dd6aa830c8365a9c347416d7039b739606f63208c22e1f5916869e3b49261d776ab6be5a888f989b4014f14b9d8df55f6fce83e3b1eab0a065edc0e558fb97f715bc80e99b130025a55b148bb92f98c7ee5130946feeaf66af9512d9f273013f7ce96f399da7d4cceacd71006e6ff43bf48094789f271a63e77c81f7ff43f89ebd4cc8ad744211d75eba27a3cbbefa291321ad844946adfe2ab6e55118a83aea2c25744257f30366451bbdbcf0a5e18072ee37d1a5c93828686b92b8424ca89d51aba52951e3da93bd401153c2bd186620d06b4e09e5c0bc9dbceaee99dd8d6e9d1bc3b8c816c1f7fe34761888462d0310fce657f6e83e655a0868f72ff912146f68b4e9a6a2f37430e9a40920d2abcf378c5a788e1580b626c4bf09d74e63b7fcfa7ebab2ee609b29b54b34baf57c329bd1516e268c695b54d77df3f1bdd90034a6238e2b1c64bbf1caf11df73146ba13d57a0c345e95360ca4c19b7c1d1c2eaf7199c79477f7453f91713feee4d3cf6503479f8d5b22301b603789c1643493d927b733032358825b642477d964b707187bc46d75ed0cb27a0b55226679264c156e2055b1f2818fa4cc2ad89452a3c7e6869e8a76ccd5e6d9cdf0d6be2b4991fc51f0b0a05b1e298ac7906f91e2711a6b24eeb9b66250f9966012599e4c235800410d82c15ed7d4bcbf03a5ea4015948db3a51f2381d17dd24e87064ba333f1b1203b31780e99d38a8ab499cec222d0ecde364522f8e26078235df1c1673f3e5df98f013c387ef9eda3ea0bcb6012890f606035cbd8cd2323d9109ab96e7efea6b6fa68cbab83f37c368346e8ff61e4aadcd6ff327370799bddd3b79df4390e76edbe2ebae11132255bc99cd78337dcf0ce16b4ff82e7daf948d199b2d861f15d9b5ddcb8af3d8c86c64bbcb7165e83963d7290bb45fc6a0370940dbe07d74968b4518658d3c165e007ea5b4d96e2c75a6a8c88e5cb8defd09c4e399ded0adc409b005ffbbd486a5058b2486855588ea93eddeb07a6274563a08c13b67f31e343c2ed4b5c16daf978a428877e74854258667373088a6aee366b08890f0e3e0294634ea75546d9aec28af81f5deffc5cbc9399d670fbc26e3aaa33800095cc5205ce618db56b9ca011a55afdcf22931844a86b55264d07739b8a3077da35e492d7bfdc4168936e9b69960413485169e6b31169e12b513a31dd5ebfcd673d0f346d7d584a796e14cf0b535bf737faf26340f329b7dbfd666ba5d6349d613ac7ba40776ed228706b804fcb4b08af9df71c4fe80fa9f648a98d1b51785a19905e2caed5e87edac091046b96977537f407d674e06a483e4b5b500324fcda3d42dff3348e4a3a85d8adb9904b76c2962eec10dbc4e3639b1d7da80af483d4e6d28b8d1a081aee0408be81878a031b685aa54ee6469c0cc065c3f90ca1caf7c19f895b6bcb607865a309d7982ac7fdbaa2e4985026cbbae6b1fd0a06cb97ff5c811a4d440230d3f5956b9df46d91cccca75e580dfd74d2d092c305190ed92ff21b50782be33f10bb12ff26a10b5fe76c2216de6802f8577c11316d4d2b2f775008060f1951ecd85ea7466ae911319ad77adb70c24bb3043183905dcdc2fc76c898864ee074de4f5ac630e336a369b27b71d6c58d1ed643c9193a4307a62ce061aa08f8f936374c2c451c3c1d20ef5130d2e5c6fcaf844c5903de2018b171b005a4739f5fe6295abc80ccb9bdcef9301fc0b488537b8e86abe2a324028905e78bb07356c19d8e684f47bf560a7756b69d9543de3beec0d587617944ebdab24b00064c5b269fa928c035450676c4b9297a779590d4d36e7752b92e2170200541ffbb3806a4bdd7888aa404cd94e675dfe81cb1f862c56adfe1259f72615d488f18f55bd629c9a2e635f283ccfc8a34bc0ffc472ab2992a79f35ce491128ee8a5f0de93ea37138043aa6f7e277ce6e0ed55996dcfc362d592fe2fe6ad245fd02ed35e68d466eaa4dea8e17f0f83f05373c1f50090e3ee5cb97eb7290d2a49758604cceaebaa85e5e78e3f9458df3b7db9f0a86ed3cb4aa037cec645c467aba23b4f03dba16a511c36bc237c4c4c4349edc1f223428c4999ac7042114e4e5e2a58ba63ae0d0dd0e3930396505318556b042ee7c057ee919a3ee37e9c350cbf377d991e4cf58048dd37c56243b2dd018b539b453b6f40a6141102488955e49c8573d4444169365ef6a675bb03f4dd3c0c7ce4c9e1eaea71d49c7787ae3daa8ce5b00a44ecd3dbcdcdfc3d91f31259789f5bff1255660ad0b7949d03e2d9cfb77ab36bdf7566076a52c267a730c1b70878d2d0be39912b0045cce8dc4c678a65791b5fb6ab02d593ef02b683bbd89cdd9ca6bf46ea58e41399d7ae31425009896b5b361610ad38ba16aba66f7b4b438ba9580182b00be66fa1ba1ad0605b6503d3021d4985ad4509df406f2ea610de31bc6c7575145b874949bd8ace78a1197cee853c09334f2b7e4f4cf01aea17d5060d2a8742ce17c4499b9ec6c9f37bbdd4da9f620fa5dea0f1bde10baf8ebbde3948e331e0003b5bfaf4f6770f521075ff741aedc44bcbaf6593da02ffc3c89db26820a3d51d6fdd31e56fb1774cac37b03bcb97f76a7c0258bd392ce7a8db9ba7f787bef9d0b6722195a3229a258e7a84c650dd8fbc0d46d04849d372efc94ff6e44b97dc385a0f5a7dedc3fff5b4306a4583a27fc7de936123b742538287f83080bb02e6f66b35fc5a77db3dc6fa011a2889634244048cd024f852745a6d696b4afc788d8b1f5f37f21f4ebcf2418639d2d26371b4404cee70121411ec4006171e7c1aa30c54d87b7f299de3acab5eee3a545dc3b9d1e81dfe308300a08911a8879d993a0406e5763b6754d0250b2ea29a44760ad95b2f3bd6539937963979b84f8605cda333e808a873bed408d6a5a9b75ce74cb064bad8d786cc8878b6667f4cd2785e10d30612e3211b2070627ddff263ec306ac7230a1f908bae6600f863d2133332aba97fb9f0f37e3e54613eb0975d27c7ea13d7d45af21bfff61ce53954fc107d5cd8754999159184bbcb38f6ddc740e6df3d89544db314b03dc04f75ebe1e1e86e43790c5f2ec6ffee5880c6d7528296fec4d739de3bd2d8aab8582412bcad9dcff65d93e6cc20f6b075f25f0d0a84eebae8ff7b0dbfb88a14fa399e85c1fce84247276cb6714dc555e0f9af4c059437459f06f0ba88177936f07e10621e0b2862b287048200bf3326672e2e4d1885c6d599bcf9ce1cdfe9f69ed4da68517cde6d423a6793489b07a03455ebb9182ded88fe6d815f182a96020302a192d68c9c2af9be08283d4b3aea4f3d05c601818f6c1f7de410be496da6f1623c70ebdd23dc3c9cd9735ca1b0478fabb7fa47300bf8669f070e6c1f42870a28c84817d2bfb2f4631fb710b64c2331cdf965ab547a1c6681990159b95d591334209927607f08170e0ed483e04493244b008aa6ed5499f86defa10870a026388d819cc700fc84707085e1edc63e1100e46b75fb2c57fae76867de5637020af5fa3d7bc388ededebeed9b624f9ca5d9fd611b9d47bdb77ab18b8163e04cd4150f3d0c426ef826f995d52075f1067d8128ffb7583f258065be13164972836ddcf583566ec3268b792088923be4f274b46592ad748425cd61ad6119fb4ca1488a83e9e0c192005fa2f3bf61d7204838e57e91cf2c796112795e5472ff2409d38d6f0bb4a26cd1858db01ff90cda5b4c4c99d5c9bb30d500a42106d77d1685565bd3d0ce47d9dc757b6f75441e04e6c692e3f618ec16f3a43182642fa408e15ee46a9f7edcfc8f4bdfe4192c63a0703edfce86b27331b9f1ba1d3e238dda5d94dac86923bb832eeaa9d36e7ee61855318b510667cd824b6e9cb2fa2ffc52ca726023a2cc635875bc0345c845eca0e3589660845a90d41cc53f48144de30d01e331770dfc8e2574308324ddf4ae34348905c0fb3de2223a322de7801da01b8f7626ba50ac85b6fea1c8e45b5ebe1861ad92c6c074bb40d9ea254ac715cda6131d008179869b7d0ec6a50884584db2472409e0aee298df00749e199be28e01da340dbc09bb097d1332e71bd39d76d23ac5a7cdbb5caeec78fe4681de30cafbedad5e1e47b18de25c4a15117a9062ea843c2afbcd2e9cf6d96e7f29e07ac6dfe828194a7aa27524857532cca0ce38f23bfc9ef91158b15c9dd1dc18bf69d6dd82a7cf4fa4770f0b8b04435ea4602f1e88802b5ba33ce3c7e634b9e20bf082956ad098e3ca2aaba19fcc19e32f9d5dcc6872572e53b417b9de922bffd6435bc40c2e8e65899c3ff67629e61c6c48a8eb1c983fefad622db1c68f3d2cfe594bf733384193fb1f817b58e8953dd783fa4ce2e76baaa603c88afad6d1ea0206aa08cce01ad3dd49bc832c20ba2b4efae0d5543adc764d9dcf5adf5c9d3f8bcdcb74b89f9839b39416dc010f439c6b791506b7c3e4864649839a2ba0d057a3f8666bd6607e3afa3828964705f199b51124a83078c74aa57fb5e9cacbdffcf722a18e81e2b1c7cb710eb5018b46b848292dac612e715aa45004a6339061d2ce40123870870f9c78261e447de6c873d9e2692afee791f3b8cd4198aad3e811be600875de03de55afd8db83553993d757cb6a2f70d30da68140f5100991fd487617226af79822c99b6b666e6f4ea55be5aaebd06fc8cb69845d7ddf899853d35d8a69d6068358c5271bf652bc5304b80d039f141a51b7ceae0cc415ef08f6d05ec89918ee2a935bf10f204eedf1f29cb0515f6a77825889b7ea97bca47af02c55af8fec871f7e8bf8f1370d8bd9ac0431dd7e198fe3491c2c35e6883bc454a7dc173654afdb86b011c9cc9cb144f14cd8e74a5ba4c4a01586c168fab4faf599f4a161328877c300ad07d7d6775ce2b5f35548fdef086098a81d2aa6bb647adf0a4a056b5e5494de87c744813900401cfa87db53e568abbb15570b46db83678dd84cba06b9435d6fc4370b5a9e9cb515d99742739db50ef7ed6c17a01d183909c4f522b1fbdadcd1055b2ea5ce2b921a01861a46962942335e8c7dd98f9d6ce32031d00d92e5c78061eb00d7c6bd7166e04e8ae38c44b3b551193a92b9d47c5f7405289e3954e1befb9ecd351c4045409db9ad54ea82f1a58c74f3ebe56975ea698c59466b92da07badea28cc1b3c382d0dbc37ad4418ec3cac3a160e232e7d05cc2c29f29e5eecf372bbea65dee51d143b3f37bb15546f488fc77fa37df3debe950fd6d52ca2cf5d86285835e5ab71dd31c27ad5faefb34ade7ff27d4d610a1d1e9c49d4911a839e705fd7ebadf570ef22bb92c08534ec592932d943c4cd240b882b7a798c48084389c1b5645b6b33293ffef8252e9499a1bd69e5c74ae4565ff727d9ea7fa6e4daa44eeebcbe7b64d547eb3a1cd97aae0ca408619bbfea78c7abdb1bffe0a9706844851211cf08fe83134f49e16276aca326a24cf3af3216fd13596cbf16532eeb9771af25195fda00496bb5da03926d99c569050cb727e7ce382577381cee86f6f8e827d6dc047675c6779b7f632cda6c8249212478207673a0ea649737daf45f4acbef749eddf7b07d91d8d9e4596a4fd73c49d42c5b08470a1338d1eed49629355a2440cd5d7659b928efcf568bc592f407d096f8aecd6ab9bcdbb20922a9e8602a0650c6af8cba585e3de81b270fa657ce73693ded299c79a23b4fe086018d57da92877527e7d0f393b4f36db7339c3364be02eb6c2d48158404cc4cc632e8867aebba0ffedc6357893605598b382250fff9ad382ed48b5b1283f8b61b52b2410b94572cb639110bcef1d9cdc9285f0a9a491b8c6ef2d2e5fc171d61795309efe5bd4048a8806b7437b74b9fb2694539d87c08dc087092468c8b34ea32770d3c072d32ca7578be274f691fd74e39485a4703223bc36a2f63143ddb46e6868c45d12469e2b685bdf3d0c5e763252585e3b66b1b324586787370d481df46ea864106838845a6c4dabadbd51f84cd6a761ac90208a66e40b3c3f22a93ca0f3572b37c9e54bb04073003e07e74146a101b97e4035d30375d0be0856ed6a59cd8c5f3110c9bbc2205625d9e564b70ee4434744b1a0ec646513b809da368050dc201968c735789b292fe3efca6d28b3e985426a25bca2942b62b52b70c09abf608a652b9cbf7236d5c82865c5d0798f5edbef84a44dd9b5f4fc36ea105f8d6b10d48ca6992b5c5cd14ee3473460b400cf0f248b076815d221c367434f4a6d4241a1bd6ec645e511e0684623b8d12bff7ec065f4044ddc19a9cb1ae5c3af97bf6ce78f7236887d355959ab12c8e4c8af12b5b42c3dbfe0f89b2e33e29724dad8d50380c0c422e2e7fb2328d5293fdb8aa0007db08f7bbaf97cc6c6463cb26aa13c1b80df9a205dfde222165a3d9288e6573de807d0ac54cbf77db331de9a98a6d6a389a245b7875e52c239168c18bdb0f42c48ebd9e43618829bf7dc072bda2570b6826d93a8b14530791a9ad127a64cd1b2613f7c589e4af6b782f0dbef2a69f64e217368bc0d19c290664ea00bc1e2504eb6fd3b10af856098055bf6329a43afaa3877ea0fb9958d5e0681e41c4ae67843276156e840e3e14cce15df40c257e73f2a2006a4166c2205134c891471273b17be3f2199c7fbae7023cacb8c6d97a53bf52c51705c36a5fce9fa04c5218ee84fc4850e602c1111757190e50881b74015718b6c28be1399c626bf3fba592b4dfea9a24d237b85192eabb6b6171ef8dca8e9ab4323cefbe5d067660cf8f7678f31655bfdeea5452cc9476e6a53b58f9fb0429d0301a6607a846b4866e6aee9b5ba993e728e48a375e788c2a418d8bf8f8bbae51418140fb698ce884f69847b2875473ab11fe11d4d0475063c0c8130ea308c3ca95191c4de0b346c7ba16e889f416cc24d825d9118de5a32905df3bf9683ec07bb78d06e6440ad4214aed8ac91993ab2219a4bdbaaed22cf1ab268887de9fe85fadde09ca0cb1d5be6980e264f5169edfcab68d93ddb08c8767f846c166566c770126351e99f364bcdf2c7cf31f0c7b20695d18eb2a45a84e45fc2cdc316d00f0b711f8d19e882956ed7f69eb00ea1b19a2740a4070ffdaa2354574512ba1e42bd83f4f8ffc3361776e89318688c3cec3cd71ed92c554e181b9103e1faf389ab62e4074df8a1cc4137d338ad6a0d9c13ff532d3eb1f1620e8ac1743035bdb1ed9aa103ad68dd9879d93013ce1b6affcb8146a820acdc4b40796cb3d972efbebdf41561862a3d8df9adf5efa5ab3c09869796eb1e2122efbcf8008b0bd569202c486f7ca3f284811dc99aaefb00ab053377f7f6b3787c896e8b86f37ffedbfb716402924d2f0da796b1ee1b373e92ca75cdd5ae1c1a94cee00deefde31fbf6199583107f9f19471bd14ac695edd80e239e3264898e36543b49f9f07e1077be4514c11ee9b789c012b8a30e8d79b18dc78d7a90d032ef6fa194fa6eb29be0926129d0b804a8175853e369e2759df5e2655c307bcda9a352ba2e9edc52540b59835bc543cfaa475ba1d9d78b53f4fdcd492013d6854528798fa9b631d8c95d7c097c129a2873ef8c1056ae3c3de5006bc73a46255206430f1b9ea109c8c7b00e1668a886d73e2402d509b22560d242cfdaf2df07444068f629e9c06f2b3121060d9f2751a92c20ae9e516cd5d27b901c9efbca0a5b31216c11a2700160eb17c26d4916ce0388e5b7fcff70cd507e5b400818eb364c421c7b5f411998271fe63eb2b99c87643a445c6f85184a74062d8dee8f9c67ae5ba1aaeb12322db0089af9f382a54054838faaeafff1c33c84c46a80e20f9d8b3182d06880d1bc4f03860d0a0246869f66d6772af04ffab32edce7575d59a4fbd64771e73f17258829716675318eddf9ec132786bf5b9ed8d10f3944626991313e36241142512159ce3393c5903063086ff03ddbe668b470e9145cbb1b42d05cd344c0ffd56d32c6c3f04f157a315f428f31f529abea3b39172203819ef4f9752fc19c5cd331c2dea4135d8b5ce955091fc7106c1d1acb6f25403e681882afbfba1c7d575a9755e1778c8f3fcd70d1ee2a78989354861c6785b6da0ad7d29255facf80a8ac08a8449196c3ff5ada4163dd2c9d949d6b05661e7393ef69de90bdec4e9385449713cdf4a6d4589c2734ac16c6080247c814e6972ca9962eaa6650bdc4b3cea7fe7748207bf32191a8259656b8a4628ff8a089fd070ebf2008b5dd92add06c3ace4843e7da21858cc1a887c11c74df94360ca5949b38296d080d58485f1ddf93200023f11ad20158fd77a3577b9315c63c3c15272d69d90fe44807e818785983359485abda91bea0a3a814ee97a290031fa93406bd0b4e565eab5c4e25972f28f21a404e2e698cf0784f12a45a5eba51b8a2bdfc22e250bd82f684b51a3c1f81eb0bd6904f2732629ee000c27c9edc665c9a095e00195c366280700f3689db64c93a06b0fbd2c104a48aa49786d52ca4e481e264097c514fd5df869441127637886fc0009a30c826c9ac58413d5a04ba2023a81abda32f5d50fee25f0e5764177b7096ba10594a1cc3135f288cac13fa4afea9440f7986be3be1491f5f21034bfe9f450ec4d3f9e609ed52a0298703a08947e2ab28a6adb739bd5d6b36f84eae06ce85225e862b2732d7d6fb5d10efb456207290999243e6c26ede2f1d1c8e9084b82d0308cb6f0bd48755c21598064bbbe29ac0eb14ceff65b29a0d20eb2b1102a19c458e9bb26b3ebb55389c2d17f7e54324449098d9bb11584b35893019b1548294f861d8b7633d03d443fca2ecddd7eca3fcb3e81da3089f91c47ad9bf8048acd496c4e545b657d95d14a3f3595580c4b3811be0a11bba46fa9ed855be0a2e41138e99850171d17982a3e0f8252b97d3bd44f517384e8270c3806d8430a041a8942175a8e6c48065e6d18a0c14bc056db08a9c3537ee54933f4d8636381666dd39b2b928a8ef70c1a1453fad0c77eb205a930a6c05746f438ca0d48ec851e2ff7a6cc0ace91fb639b713672c9e740dd2d8ebff6607d066aa8405459dfbac96759610c0522bdbe5a2aefbcf2f04960a0a2860dd8f54cb5bd0eee23c2332d55f4a66311a6de6bcb5627128c8c2132505aa4ad24830b7bd31c9b79bbf6ac75539e7259e75e1a55063d97f156bef84120ab9b1c1230dc5be29ebe74760a9e4604588862756bd22e719073fb6b22c73794543abf7c4ecc260ccff17424733c9382ab2bc47c1e57b47d00e558a8260b230719f966c998991b927e5033497e2f27635ee134e48970fbf411a564d46ec48c8c6870e22ec304b0153cb7538f6767123d54145b34da7cf8a944e9458c19950f6d4c1c3c693010c85dac959a80ca8cf262180b5f7a2333bae32a1675f502bb992c229e2d430fb1d54093a5cbe4428ff4d1dda716d1765dcec7fdf7f78379c67c61e4135711e20ee8f556bb0f381907f3240cd5a0840c33fa37c2a760dd2b60a86a43bf3c5642a3d1acd952a161f0fd07ddc5451fb96ff0afce44be52462cac9c2b00d760990ca0755882cd7c839237577196b3752675cfc6a8a7548bdf99878606aae440654804fdd0717d45f2929a84e34c4a5ab43e48d33c709bf369e32f8f43815aaa7a751436fd5bde17a63b764be999acf030521501b34d0e9a488e74106141b95cc8bb61888a93224c80a91c1986bc457040e923690191f3f5e7bd90567a76b5011b63a4ce75dfba166a21932644bd1e9830bccd690173c9a1b95cbe29a6ccb8d17b962a95ffa5a88bc176456af3b7c86e7d830351a041f59b2acd6d8f1a3cbfdeef02449e89408a70e6057460598efba8c7831762752ab37058c385c0c90beca72cf18f0f026eb12388a59dcf21e5259ccc4a9ab30e9a04c466fb23f9b9e99d6b533852c827ebee73d390bdf59dff38efd2a83d0f17757c65764fc926eccd79e220d082968c6860e8beed69ab0a4b0f9e1fd584a1aa9eb56d8dace6df292490913acb0c6a9bf6c8a80b8f620b3e3e84d89976c388d57c4a55cab8098197c51f9bacb7a399b5d29b8d83050c1e619c679842e531a17abd4caab64d222e6bc4d92316cfdd48c2d2a5945bd24308da12e08a08ec18ce4584174faaa470a6e533b87f8ea7e28ff8e462f4327bfe1d486ae4c1f15cb6802b2ef190abb6aa2747b8727cc2570bc19d005b091d510a655a7ba1c898c53e441f4e680c16bd6aedda4125180ab014fc876e62c3b83629c7c5a94d78ce3948ea0d649382a5e38fced0c06261e793142af337e4ce6755cfcc447ffeeb0f947492cda67eb1aa0b3f547894ea9f50ed662e4a74c38ed2d7f1badf51ffa658ecccf9a0c7b2d48dbfbaa3368fac321520a253ee307b3a79852ce3b88316b23a2cc709cdd731ae106b0d5bf830754d198aa6f29ff5519e77285887951051a960da12e8010d376a8280caae800b3f7ee1eb2450f83fb2a01348e97fee5091c624ec7bee72ed340945488c8027cb3d1e5c9b3c0875d089616ed57153b3556aa8b9ec379363c549c485569c5aaf6a9eaa0dfe0b3f6134f3caf82aee3aee0fd7b1f8f42d41796ae89997e843bd76efbf5c35890cbf91f3c69fc75f816164777d9d94710da330e81d8367fb277081ed6351e28102da891aa490aa9e8460b62cd43da4120a6018a3b1f699b1824c07c5b5479da6bd89511298c02805f893b9cb57be04f0732c62f7fa2a5cd48927818196f403771cb974efe2b746b88ca83abd045c392a62c216b75b94eaafa9d41cb165d6ef7bf822cb9f12b2ab7d7e38ae1d7e6d4c4cbc90fe657bb3659d6bab8419efbb90b8401937b604d906bdfcc99e806a889c55ecdaffd9c2a856e2b3c4385c33c71857899a92f708ee9947f93cd6d2c096086689d74ab28c749e633278bc55170aa885b5c6bc251483f4687f41963751d5f54b5062617009293b4da58abbb7e626eca426aa69f0e4b101562c572509e2ef75e1b01bc27dbd32ce9400e4f1c0de9ec90e1980ee5f9ee7aa7e129a946f3d92664a1f1768fa6cfabc12c2135ee542b699da5fb03b6f10e99eba16f90f8dfab6032b35fbe1e19b785f3859a4895c02b7a0d9c1afc6779011432b542d728c72ade882ec416dd564a7d1782351b3b4f0031a0c6ab0298f7febf68f0f7e17683b4931830f5d241a69d01dfa586965970b63570115eaa567703c8e85caa4459be91050f1cd2337aacd6c2dfa095d0cce7b6ebe798402d531cce788b24088ec79ec54a0a5df6bae9000e82e6717dfe583ee3e2af494056ffec351aaa17fe099f6d55bab8a135f4bb22906905040ba5fd2cc4d901a4fbb4c212c5276d9b69b5d6056994f953803cf57bc3e5e09a9ad77ead75c791f95c1e1410fe291f57f47373d38254dab31d7c1b31538552da613b3d34bd102db5a434bf1d96555217b90bdf7b337c23a3d2c8de099acea5ac886bbb45eb56bcf6794cb31a442f5f56ef1c19ff5fbbb7a188e3bc1352e30a5014974f57f98eb5b3d7866602d54372d85029cfb04f8a380ce1b66ace08a37a160e8f4a32b6a2c3777d41e4aa3ad009e156ebb3b06d706e0c378b49c6226aec58fd72a671a46906ae24a944bd0ca58bfa0a87c7d3c1e1e2e82f635d6526cc3316bd4631be07254322f8c42db1277de9f6952d41c101590c2183423fadf94dec43571e66c38143a5081dfcee8870d1e322203eaa8f2fd5d2d63f9e0156ecda676020901601f8d51476736199809461f09aed57a725aafd989c318c8782c2bb3efda7ead10ac061df1910fde2f932bc74580f68cd272aa533ca7a27221f0a9bae2f2adad8c0aa1f4ca36450cd4e2cda946d13258d427bbc9f2f20ced7065e011cdcd14acbfa323be3687663e2d2dc035488a5ca4e9a781839e30a2b36eab264b27320d1c831debebed6769c41d5c66f3e9c44720de24a21a0964fcce094f8dbb5088782fdd57d271005887b21988eccc07196aea0bb51b13d01c409f2b7f0cd5f684c2de3fb7b98ea2ec3d2271d6fcb22a40eb03c11ec71b4e8d7f31ced1e05ba8e8896c698c9e02388fbecaa738873122e77fd992861dbe3bf4fa290e86632f3e7e629903651ab9b741562e67138e9250315a574489f679299c175985d2f31f9814f620977cc8ee2dd0210ac9812e59a5cacd8b8844578a6ba3143e6c40573168e092330094f6320c304916efd848ec8c0e08dbcab76a03ccf0bfcffd212cef6b21917fcbbe960ba611f9e44eb1128d8f003b320d0e924d3d7b4c6d5d41d49e85075ab65f945b730edf3d604d82924e932f4747b11522cff1a7356aaf17533a7a2ddadaf0e77d4ce6b01dc57b8f593fa5116cf6955a93bdaa46f467fabd561de38993f7073aa60bec2317a43596728596c1e1ec69e95e0a1ea7ff598731f665b2215cb9b0255efa1de782ca8e89b492c0e3589ca357fc2e7d865d40da63f4b79093f7f259ace363fbd08556752a04565e30da23330c3fd3bdc8b3495d5bc9941bd9fb88914c47d78b8b717d82ccb9e93fa0eef3a6ded8af792065a911c6db03a2cc9e16a522117bad661449daeed797ec0a48c5c7fce2e9d36a5a101d290fe574ffa1e8b289d0628d40fc8cd39a609729ab411af3179389e1936c8906428d4b1e99a5442a695af15451e854a3917ee935cd67fc592c26c836e0e16762474dfb8e5c9e96b8f2a431dc2eb3117018a0215ae446c60060092c79dc0348a3d064b9e54ebfa8388252674cfef08c1703c61ab97d19fbaf72eade2220fedd3b3404b117a1017134bf030","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
