<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f28b304679b461ad228fbeac73ce083fc335bc0db7e0a546891c957cdb74d38333a012e5e55625614c63072a7113cabb3832183b1e794094085063db352ade2cc7b2c5fa95ad2641e4765528cb24c912829e140135476e9527ad5ebfdaccf47d5a77bccb157bcf1bd2305fdc89508bc6339937b794786a267e8348b2f62409d26aad4d3b5453ec448c77694c0cca84f54fd0890aa827c46bb7278f3c60a835e88e150c87b3ce223b9252bdfd40fb3f08cde0654516fcbb9500fd7c267ac407c57f8dcbbd2f307040ea71600ec2dce62523b5a38e6f9d28c8a51adf02647e4af27954564f0e8c38f3dd58948fc3190e5fbff5f20932a9c18ea6bed55edcd98ba803958f856bbf9da9adb653a6f2bf52cbd1f866df521321701ec23de4abaa8a14336a18071c29e8136ecd8e2788bf42467b0d05e3f44b34bfb826afdddc2ad12440f0949783578f9e29046756d028cb55323e88fc7811b1dc424968c1665e035cb379e02cc924eee324c7903c66f81a03c0ba2a20020ea4720b191ab3848680d0f6081918026112d697c8aa8678acc1c617586f828e0ae3390d6bd6de3e4496b64976be033749a3dac3a99b334fc70eee8cc4e5bffd4938fbe8a3c352c8430b166933517f9962a73757ce597159ff316e9a9d933e6947f0762524c5bb712bb76f06bf62fe13e4e36efddc1e06ae25b0447322628f92a626595d2dc253403b32790cec13556d3bd5fae589b83952f9466b59648c424d98d1e74b61660c15c5822436bef41371f7e8c24073962aa743c8fc705aa5b59802fa44d36a99e8124949cfab78827e5db39899ac09119d1930e3abcde023389f8a14fd0f4b5a7b243a2eeb5b9fe932208956be1eb1bb64653426d02dafd3f076ada4d07cdb34f46944756f46a91cda859cffc467014e0666a101f31eb914dcb8502bbd125f6ffd31a459335debb0a13096968ed5ef15338453d0cb8a5ef14532d42939c1154278dc9dc6c8333e4a6f8fbab9245db566c17b57845bbc0b6cc908ece30184480eb0e1f6cada5fec7383d34060373660c73dc58db45e45d0b547a0c5958af47c92dd6bafdee129c6026c4539fe12a3f0a5ab761b199377ea408dc81129e5ef4f50556a9f8fc5d5e5a319ad3b33e517fd38bc22e13920403d09145535a3d675b344c2ec940d395798cd5f25edb0ea12cbc0cd2c6602175593275989c05af605ce8d014e233681c46f4366c3fd7d9f384dfb8d21a75fec4d9c996cca67e81a2605f6851df640bf68f9422531a4ea60270b05f13e96c66528943318316048260208b961d8f39f888b69e8c7730ab771ce897e95e7a651b076977a49d5a08d7f0d9237b3effd2d529b1ee5a7b9d9673187e09e4abfd4615236af247b4cca6a6d70a529a83283c1c0626214574b8c43993ef8c12116a797dc239673d6aabecf1213c08212f82363a98b1e1ac684a18abcf1c3979321e417674be562952f5fc3346c7d963d5984b9940a8bc761c7fa0498d8aa3f12adefc2ef5845c5078d3be0af8a0bfb6f7c13490d6ffc6129741511172539488838fba89f41a04c7fec6430d7b6f0984e983c49e319f4e1ddac5636a1bd5018bd5c326c4ab942c152b91a3d10491b3759f25066cd3782a135d2afc7288446b5c7ee14b65e887ab760c1205740e69c2283e65ac78661cb70c8421258bf6a323fec2f06a53573b95cd2795029d6450d3dce9a25b45d8aba63e43644d182b5abead77044ccfd2829dbc790da596782fe249289ecdff9211672b0adfab512c35ebba5c9438082680200bedb25c54c4fae06cc953ef87ca816e400ae30f12abf45d6432b4aeec0e3b1e723237879eee227e20720a43e694ba6b3e8926765150b3e6e5092fa08125f824c68c5176cadd7a4c2c9aa29dffff1afc7b7240584271440011776836383b5af20a758a1f957c2700e8b367080efcef0c8d3592ea066732c1df402c58e5d799bcc90ba7e7a657f29e702b78f4d89065da2d70848d8354c5b6fee4e18d736e09b266f878e1f5bc877ad6c250235da11c62038288e4ff37050524a8ab7abe319f52d091764d68b0e811f23788b6c85769f42dbdbb40c0f86fdc13f277106ace5874e1cc8c692cbea6abcbe19cc6f0b51fa85c40d2e2469b48f55eadd6383d3fd89a6ceed73b02cff960908a01349849c8eab068a68d383cb1d49351b5b81ce7893c4af6608bbb8f684ef0671f92a4787c458a2a4fce69f99487c78ce48ce1e1981a07e807f7d42caab1b8fec90c1a31af50ea995781596e1c1fc1e7b7538183d430bf64dee3db59ada95d52620da1117966f8807cd48cc0da6488201a7c16b3dcdbd379859b45511c8d8315ff79fd1bc9a07cba16e9053016e350a918eb2c1bce415b40e4a77c4742483b16647beef1793e287a6e12db58c265ec799cff2a39145faf8623732258ecc560e255bd4e56fb6f6358a2c1adb5c0702ab5ceb596360f90886874b80fedf7dab92e915e023341c987c083aea985b570823a6b5d8554c9d0056fe65da0b2110c2c136f026a14c4aa9a446330955d076cefd4cba2d8fcc96ef8beb67c07b500a887668edbb875f7ad63a6f820b0b57cf27d11065ecd03ba4cbce44150287f5438c9d661acc1ea64c32a053b3f7b392377e2b9675483e0b207d6e9cbd9ac20350df0a90b4b9f6eda076c2c7cc16558408fc745a959282e7ba1b95fabca17b51b8595050e057efcea9032fa33954dd80937237bebbb0ec4fc4879f055d7ef4deaa3b023f78c5b2b04b54b5fdc2288d36538086b67a0d68a526f6ffefd90b327aa4990074aaf59ac876195c22ef6fdb582cf6334b3f35328bf24414825b562cccbe27e8336252ca35bba91afc988a2acff553bddd8d3fcb2621c640f393da0bbaabcab20c6169c3b2b5777ccb7098fa2acc1e37cfdba6ae0602397be3957449af1de0d3a18320cd9ba1267c6db6b6e3ad0549b71b59c17e7c8134fb2a147ac3a00968d4dd6164f84b7301a82a3d7af6de61cf26fcdd242c67083abd9873bf67928f439842f4e77dce20da8c606afaad499eb677f57f49d55e784c85c5cbc2995a65afacfe4f9d625bb6451a9e3e6e9a45c9c4f7224ccb3e441f505b91dbbee73f1a4802988261537d0513e40df1ca9fa859863eb345bbe8f4d96a33b07db658c5a91dd19826eb6ed8396645b5100ccb71b7f234f1c9bba39e1984feeea4a28f7aafc323c691ce1fd2b904e3c471ee6cee92daa5c12d54044d60f56fb3ab4bb4eddca5984985f9ca29e560309b5d036686c1bd466b135c973d63812871d31ef0e9437fccb7a725b2f49c08f81e537056e49ccc8c3579aeb6d96d6cf06de6eb5a716e26e9ba340af2112ae97c247217b3c4e10039caf8a70e56702e3743de0d13870b2e11a7c40aedd64b9ab13a958f530e21df7b3d78f6560270b22a01db5c8c599c3ff5c3c25a8408ea3649fc14915402917193446e8be61f3f552f9b66fafefa4f6c10aceedc75de17f01ef1075aaba04819aa6d01ed41ae807d9b00480b36c1a76f9852f0d16403c899a3f09359c3493adecd31ec461b726d98015294a54175fec75bf6050cf90f973e18e7e7e4d2b479899c64252a9df7a80c780ad67ceccd29f3da8a6331caefce5898fe2a81cd8085e406d3f00f2a583ce7cd98eda9edf6302b67fb024e1b1f65675b26bfd7b217f01bf4d7ac43fc8efe690a8b38cb94cd692ee361822d1888054b6dbddb3ac498425e73e4e59bcb5afc1bfbddc955790537ed29aadb8f5e3c1f182ffc45da496ba63ad0edc72d26e544cab0fff38bc6294502d4760c538ed0ef5250716cf2a52355e1647202f53c15f9f68bca10db61cc03be792d2cd8fed7061bcbb647394f706f5353da44a8c6f79523e9a2dd232bc68373b61d2fe22ea648bf4afc480cd78be74d7ca51fac6b14e74ae9d93a48e535108cd51daa50c1779ef3409a0e85d397e8d0c82e5e26499e50c3125b6ad0fbce50d9f64f7c237c66893960fcd86e50a94b0ab079cb24ef9e2499471a6241d10d91a0bf01956c1bc18a0ac7f4df557b471e186bf8fd2e618d194ef98ae77a28c1c22e817fecfb41de555c040900a3eae68b6fc9237b0dec1e6d3a8808ffa11f8acced322ea30c2f89de4eab9a8c82d9084929a2ac5bc14b9a0776e61aef99ab98ad3cb51c840d784e0d667e468dca3d1b64db64ad1ef5f8a0a21ab3ab226ee15803679d53f9c0ad71e5b0ab8b778c11b6b397e77cba8654cb571d6cc0780753eef626f888a1319300f6287a19da7ce85566686006b28273b42fbc7291394ba0d7e1f6c39dcc0abde9af1c27a8306240c03d28387c59cf355c818b6e803abf857eac85b672d9ebe361774386a43f155cb8d404378b346d64b7cf39c75ffef61fb94f4051598827bae684eaaa141c4f7dffe08ecda77beb3d5b94b614ee1a2219b741502654ce590194469e442f5efdf26cfc4d8f7e16145c4f898791348faa499d6a2c39b924e80ec839a4b9ce4437647ed3b06ad97b58d876e4751970e211e62cd388cc16b0ddbe8a8a8368847bd46dcbbd9b86492e24ad1208c24345d158b89e4ec8f8bec6660797ae5d6e05076b554d3cdf76b21c04521d29b45672ce65aee9ef569adb68d22550b4ac91ea71d9d25c2b24104f0cfd9ec9fdd0a13ad6bf0079d5e4a39dc4f8c9298e4af4b55a85c7ecea54ca83b9b7aa84524c3b814642894adf147789f8c10ac62e890259e9cb775f1a8ee7b61e8bf94202300203aa0c8a39df9a47d18619b7d0a3373f8938bedfa2beb52ef96ccb14ae353fe4876b5e1386efe06e52ffd069ab80ddcdc4585ecc823946821ec90ca59b957febc8c19d2ff7e2e424685097010163c9e543ec25dd247e92b0ef01048c10d99dff1b90ba98afc2bc26fd3202ae72544867373897db8cc7d3c7bca383475682e93bcd4e9a486963b8a8b60f4db9ad76939306bd566dfbe923bf1d7d65e80b5515ffa12122756219fa5eb3d67420588869f56580f6c3c26d932d430bf192c16ebc9321317eaaeb84de880e8a552234dff97708c455540fae1321a49c636aa64a584fc4ee586fbcf1dd31b59790a3dc41bdde1a9ee679e0e102cf26e6874b1596ff99f87810eccf0eda8a34c659791ceb6f9a57bc9e159f6c080a6d36a58b47ba20207e5c08f372f1c1827ccdc57bae129e86ca3cf26bfdbad961cd2709dfa468eae9f02a2d5e6a9524657343ad348d256393ccc30ac6c2d3070911ef1ae92fe520c5a36fe199296a0556c5a42cf62a36d8cb3bb16a10990d3687f6240c53ecc3bf172549c9e0b51aae56ad28aae79e5430f4a0db0ee3ca2144a9e936d64c783eb976b53ff6a1dc7cb08f19ea23ed2f71a88aa84ed6c2eaeed90cf315a934ce62a458e685fc22ee2fd139504233b48528d8399cf5e296e74661ec83e2055530f6a9cbd98b24cb936cd9e5c3c259ab35e5a79de07ab9b486c77ddb40aa2cd73ec81e0ea337c4a5522b52499228e4178565236c947af6d1de9d1351a0d826ebbd7f9807e1ec106263f92ad3f9913d5335d2032bc5a567f8ea3420b3578ca296617c2f7652d14cec2189a12a85cbd2215e1ea24ca4ad5065c9463beecc76737165aee35b14af1131aefc316de42d1e66acf1e3c86bca89f24a13368d30e03d918694910fb1ccdffe5180bf769fe797210635258e4fcff836f4ce683340359f10360c5e766e76846c583ab3987153ad5ad1e157929911b5f5785a93ec50a71e898462438b2e6edf71b701c0236ef34a24c2d2cfa5bb9a7a8576018781d82d2341af36fbbc9b4bdd36aa17c4cd12dafcb107cfeacc4bf5953b25b43435c79b94c86e967666a9cc7671b39bbd30a70d4b7dffb3983dbd9aa2860b92272b15c9a7e0d66fd70d4114d3204b643158d348a70453a1136f7f4ae67e3b393a449f5cface0423862f48e58f26645da68e7dab0cb81b7bfbfbe4f621f85673a5d213e8e2b5576a1c6d2c261c0d210563c2c3e70946cf349319c7003bf72b44f41167476d04821301fe3257ecf07d8ad544fc255a7a6515557873c382d2357a9bafad479dcbc35a6db48f271d856b57f95d12128878ccf39b85a4cbaa15fb74d9cf345d1520606f126bd25f66b6d2852797a898dd0fcaf6713d58190af3ca2ee99b9e4ac0292a4580e0e51781a5dffbf45c8df832c680988ceb5bfe4aad8dc412d8cf52ff1d469fd0d6bbda4016740306546f7af6dc0666d043f9d057d1bb13ed2c39a05eb76f8647d0284d278dc9f40a43897130f55c65f582f01227d47b8838ab0de8e2a1685851cb52eca78b4e8377b5439b54a1571a42ccf7bbfb010d58d99a5cb5315cad0e9c62155c33978caa680f2ca53b656482315510654a74c134956ab8398d1d4e46a06541a87e75a4e5ab086e553768c4dca5428bc71e0a4ff4dbddb644d2c1a744ed11aea747da32580feff9124aadf6b811c7cbcca6b095792d94c3c2642cc7ef61daa7bdbd07f79c8bd3b7511a07acf547ab98302be95037ce47b86e3f1991c35de3db6b1120373dd7264aa5f60dc827843a36d7c1b8f996d03208d8424b42a87f24c8bdb4841c739955d8f3eecf7e0e28cd5f9a8dd8d300c760efe9724540f6869b01885cb68ba2f8f59d363c0384c03a795d02a7150cba66936f5838ac89911d03e6adabe8008a113d29a6fea99e8ae90b0b65d813cc6f2442a70ea8d1ec9a6b4968e344408e3801f19dc9d454ed86619a421c1408555d76e3f973d4f682019aa1699020ecf5d5db283c88a9ef12c7c8d933c73ea432fda276254459793bcb5f9d0437a50f346191ee62b062688a0da43108357af1ff1a92799f0e031554c604ffa4bfad3536e3f7b44f5ce99cc220bed3c7e84f6f4d4744fd375b6dd433776ab3f740fd0be16297ba398ce00097213b777a01b1b1fd8f816883eddaf671562fa16b46c077db9098a0ff94c4b2111da0381e7a53599236eec9c22438bda59f226ab6b8f64c5273ce0175216bfe2a0fbe0aeb4465b4ee838430c372ee47d29755ceb06454e13d4f9c9935dc473d89a7e16ca8570f400c7350cc85729dce9638ccdd7b8598a42da8591718fad2bdf850ef787d0f926d9615f181365f7fa9df2055ce507fad61ca331eec81bc8274aa268b3d815905fb9b13ef95956fcfb3b121d071c9b394043c0d7603e1909f9da5c03d058581584c441b34241c57f241de65d5fecbe5a9a1e8cc003d81b197ac147b7e408611a3ca46d8443fcc536d91b8d0333427019e5f1da19b8622c5923b15b5363f55c341fc2fdf0e484f5d9e8d97e8f0c3cfaa7f8bb8df75edd65af004164a1c2ed9909cc799dba554ef3a921cfd9d7c9cd891e3ee79d7dd86d9de71b88f1831f94b40dcd2c3c43a5c18e6773a6139be3664f90d470861caa232125f3a82a7b4b96ccd55fbb8ec73a848a0f44f76c892d55de3d48df854962c5317300ed53456667d6b87ebffbb48a0ae077373d15c794d6c125388bf326aa1d46ccb71f95f8ecaed0150fc3fb458f18e792c93c50091dffcc486668e6ffe9565b73422528911903bfb7391263bd195e3d020a1b2729a41dad719fc7b5c2479ba00fb0142f1968355be33e475bee15d7edf1e141b6d9359a0deeb6f1780d41eb357285b2414bfaab51230b25f113968e150a69063389dc892f0fb1e31400272fea50848d50f09b6223e82668b6872ce2e94cd9b8c11dc38043dd715efd1dee3bc61f411e11161395cd1f4b65800b841a57b76abdd0f969789c0423bbdf816e10fbb3dc3ec57ffd70407cc27a9fa85f40be0ca68d4c1f4e4267320da708a02d882a2588a553ab4d90c2b16f44d026f139e844732d47084df620857f1bd221ba13b6b6c912c3e7fddf7224847925f0e4a9b8286b448d766093b2e035ef946e5f133040840f89b35081cc24a006edb86631bb17cf912a629797103676c621198427ebbaa60ec792846b44deece502a7bca58d01634b5bfdfc37ad35aea40fe6eead40ff02eadb548380014765475626065a3e5563bd39fbdf574a798c2cbb405dd40eaf741f62c9808d992dc93f26eff243637128d8429257257ba34302c82e04960bbc4474235e7f9e71856db50e855cfee6e4576811963397a5e6d44b65512807a9fc7d3429e90c357b74c2ee9cede39c7fc0e114c4d476fbf1b8fc5cbb60e2132ae56efe33dbe68a296edc7e1775bccc1eee5737785cb32d2873d0b7028badde6e3e1ce4b8156fcd71766f76eaf3c6c998479c83b9000f43ad54312929dc51c2e29c52ae5def9000190a8f1d26e9a35b800baa2894931a19ea0cb4e137ee8c752b7bde66ca8e4f5b9fc74e54a984e66362a9f002ebdbe4bc6be19078af7a3180aa25602db23770f76eb540ce025ae87629189bd0afac826e4e0e8864139f041e28b66e0862d906f807789c343811fe6f9f43db25c9b325b882b721cece1c65657769a79617f52d038665a562ca2a760b4588492dc90c642cecbec057c165b899b4e46550ce0ce37888f5bf60962ac36b1c0c1cb46c01f7894259100025003e12a166839d935faa431567154c19be98138e962fab22c6274a30044ad304ab2f07ea1f8debd163ef880c9e58ff7141c6248e692e2510f9c054cda011a2314cd2758a85e2938b4bbb2fe00f4a12325a45df1f3b60f2a59d89fb9618668f6426427f3a4cded7661df998defe87f1674f1a004d37185cfe7dd81b1ad70987720bf5c55d6f2e3627ad95667b9d50146ed3a9e82fbc6f2a3733890246ad99481648fa5e81857a7641d3b3ab9b198a56a0615ee8f3e65b237edef6bca24558c3d5402a61f9d6ff0baf5f4110ac83f50548c0d21f89d222aeeb80dd48dce0965174d05e820229eb716784ce0196839f676ea474783c75b6a0f251d1ced1bc4f512e05fb09c7ea022cc923b35f042efb9d43428961f20d68af98ff641d30da59cad28fb3d85ef5653","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
