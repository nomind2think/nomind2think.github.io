<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"92fc4f76cef5fa10c31e928daf4fd6973af1ac5e95388e1356f3c1a97139c23b23e7f9d586cbd8edccad872c2718ed2cb279e174959da8a96536dd3593f4925eb231249acfca1d157cdab85f5467f0540749e8cd40f3adc6000f4befded80688a7e3a2657b7efbb585dd78d84f853cdcffa8bfeea7cf29b294a0be4e65abe685de60d2706afbd11a1dabbc05a5fa1db280c7f0c72cb2da629de842a90f785d1536b793f8632a80f5abada45c265b19b3556f14caeb4e59c900070b030826ffe84b23d5fac9fcc3b2a01ef1813fc0fba3f91195d46294a72771b554c527246aa7e5860d5e829c54252359e61253c377664edbdbd2694851bba5e030e7f1667b7fb71626b0015919bb7ca516c85fb77927d94a0db6cc2e24a3a522b381834020525aa017129e06ae5ddb53c2cb4af2405377ec12bf105b156fbacee06cc055b4ef28b855878f245e3dcea8306bdda996a67d754da5dd7ddcd8dbd1895d149fb1a6ef830ca4a5a89040c796f6d6355f2ee43a74f15b45aafdfb5210ce8554e900345bfac8dcbfdfb7263c9c3454f68bc135e9c6945a62f344da8f9d2091ed1c03c404681b34e0aed731794e92566dcfd79e60c861457630db989eb0c06aba40e166812aace3152f26f4f1219fad2a09280452519fe0864ec7d12cc588e8b737095ef25cff5b536b4f1640f4deb079e64fbc5e9311da9baa60b13abba1d59d1bdcd789de0c158cc8d96a71bc1851cf2d19dd42b5e70d421f03d5cc60f2407c50d61854f57e526e604bdd77313357c51c3d44f378d25143253d975d8241f0ce5a3bdff36120db42090bd564b63f1462a170678b463229a40e46fc9b4deba9c7354de63cd8498e843139de660f7111c799672d05dc5adf1e0c544768c00f8265f132b9a292a4d03e65685bd079cfe07304257a7fb5ba3bfc4c8fb892cdfe34225e1d086564cb868c4fe2ec8de1a7d6fa99b4d6a8369ddc7cf6c1468c004f04cbed500dfef3b2c75418e1a3bbcc91f128426482faabfe832c5b8a23f761f61936a9ee68de288e2dee47cdfdc815c3b9d9305c09791553655872d28535fd551e9695a8c74453311d2632bd01863d33d771ac2d3c55be45138fb722064b5bcd00085ec771899ed54dd0510545ba26f6483e3c415d61064396046055c075b28abec33d3950f85ef2df3cc643e9ee2b74286db878e657a25e39da4daa365f2690f096e1fcddc988bdd987f6ffe152849ff315b692576560cd3614fe469ee061ac05c01f3a7e6976a85068ac0cfb4079ad0ad5a66bd52e346c464486e3762ba8ff5c036d6435230e8eac8009e4ab9ce57fee59fba56c3f8a8d6e3bd0a6b455bfbf399ff7e45a43306aef36ae0e6ea56ca8e4c210feeb93f8564001f1bd52ff416e4169b39e6ccf4d41af2bc7b4104e98aab3b16d0c26388043cf0f3bd0fd32bda42b4dbdacb581234d65dcd6e8b15d5ebac20e29a44bb92c327405476c70fc2337a4f37eb606b2b9c1818f2126c99372ca721b4abebbf28cae95b0727e9e20a1c5566952a3fde9aff72b076b4c0688c04765ac207ba6039773da7dbc0d6f651e04a4a7cef29a914a01c88f6d789d1ec47099782f9c8af505a9dc650dbffc8c28a7cad6d15f289730fed31e8154b1c5fd080b0f668490bc476f3859da8872a0ccd27c45bb48f99fc08db973106985e5f369be28fee11903d48d014067428a53947c9b934d0c74bd5745e341efe5340da47970c5ce47f9d5c59d86e84e57e0591aa001316691e8edb4ae93ca0659cb0b7c98b762fe335cda578456aadefde6dc61fa8662b8bdcf338104987e8274de23b6317e1b5a53dd8f6abaeb7267bcf1c34846a24857c00b51dfef34a3da06e6d745ca493574e0cb43f6cdc40f2497e8ba4593e7c45a9b8ccd38dacd7bb75d68bb90c450f462160640a3ceba31962d39146ad4a25d139e494454bf8fdda432f8e1db3f4c6207fbeda37fc38012ed93cf6056bdbf7f580e98f483d8d9bd79613936dad0885cad75f63d059e7a8efadc23f6701403c38ff2024fad64b776fb48c7e3f84fd28ad39c82d9f5caeac114ecd112694e36245e28b0a5480e3a6f8717b502083a14fe21d8e6756e7a1a745f6df0d3554415d474d9d2ae559813283be119d6b3b53d386fc6b846676d3e6ab8a62d9dac09ee109b56fc7520b10384008f198d3a4e9462f815626f15444a413302033e3637846f1684841915fdc9236e337ddd60dbef6d076ab0eaf6ddf7349654db83c104b98d1332316b08764202dde5abb9fb0c96220e67e639c3af29a0981d91f58c003cf3c471c1a2f2c7d75f50ac24bc8e6149485c0a708e04cfb7537c5db8854439c1247a63fff993298b1b7b6d833279be14ce0e7db6005568ab51754e317328153aca4ebb21b9ca52e535a576d3f2cbf7cd097e729ae0f8cc6bca51e12a7086cbf77dfebfc602a7f1a2d860791dfe1513c27756e94186c8c659c9a85d07948ab33a278c512ebccac81d5221109b8f54b0239ad206a95db7afd245ea26ef7ca06df4d9e7c90f0e9446ac5e52b82eeec6e550888db7fe99362cde88c7ba9e6080fc2f84997097408502c4ea6061e0ab0dc7a923a668d2ef92341bace33788d0adee392895983c42fd62caa294c397619b891bc96d5df67636adf64b34f6ee02ab07a7e3df9898d748465810e4531de258bc2128a5dd6b730d0340023d2315a444e54b02e6df835c62358eeb0ad1644265951419c16d2aef9c4c490475326b8ba37c6d05d02c46a347780c50aa7681208b12e40d93cbb24ae8ac24ee7cdac4dfbfeb73ca78fde6cc5ce67fd64930e61f10f4e37845e644a363840388a0a050997eb07a35c4d7cdba022c31939381f055eeb663ef70f5e898b6f8a88bf6fad2a9d0275b5e52fc18a0342c2155fede2cc6b75be8f40c7f8f2a4f9a87eafb9aecf95a145b26adf62c9ef2d67f6eb6adbdf11cee7d1e54c9c74f83b983a67436c56d0d156775e15b4e5c6452ea639d160208d4e162cbe7b0e6049fc1b148eb746b3aab3d386e09167dbbc0f28d9d7afc8413691f37714279c3d06e3c7136a15f957195a6eb263be974b390c7d635ba9237d15d8c8dcddd0462a9e02fcbdf71e6d48013e9ccba84545aea7b286e9f6cad2e4fe170f0fab5dc19ed50bc94f4a0b1e435e7773c5e5876cff82f449ec78b0e0f7bea2d60c6b509a684ec5d455e9d551e04cb5f57c6bf31447499fb459fab5ef05010cc23b53cc2c1566ab3a9ccbd0dc72ea25b9d3f1b622b804f27aa202fca6440873c944cd7bf718f9fb88042965a3553061f90e3c54a8fd6d35bceb08e6b36f28c8b7f50d517adc2830469e9f6da851df50bb83190f5ee3530335167e7a429429fb4f900ec48a4368483934cf9c33af129ea1161f041143a635ba30745856ddeeafbeb798174ed9c823a9a1b4d61186ab8979154e72d7763d2425f687cc073ca43c786ea989cc49f9fa9e32539c35caa9861be1589d2d2a5523446d9d73c416a9345d546f94a5447da08813c746d0921f3bd5ed7a50c1d2cc6e43d68a31491fd5429b544f0e3865be800b9c40e7c474ebff672ee3f6ec7dd087674a19f728743b8186f86ff3aa8c12df4e889493b1290c52545e1b8ae79d08e8e54f631da46cfde83984e52b400bc662b6b73d87cffe2b4b4c6ad86a9f98397f7d0c787384b02c3020f702ff4119a52ee78555f4e8d70ee720a98e9fc83520d8fae01af04e8aa1763416ac2e98e986f8ea635fdb202333a8cebbf10f17bf8f825bac2b39fced57db435afcbbfb62073c38e966735e8c80ea63bf79dc71f11d2162d709b143248ae5a5728732fa0a00d942c7acf23a0fdd023007cdfb3bc3fd6d162ac3cd1d6c4df48e7121c8ad8c0c2c2fb8fce900f1326e30617f4d07c0dc32926648b23c1a4e0ed5d83be7d06141b046101dfbd6e1b76f71b17ca6ef72e022c587af016ec34115151fe02e7a6e7090e45ce24e7db18da687a59432f6158c95669886cd70515dc701881c3d8499799dcaefe3ee1caca8bc63b886af901a292e51e7c93233f9287a00545709bc119d50f142fb6ac53451e3eeb84cd459b7f7e20554a627f234cb8e32bc822595b7ea297beea414000fde5b306d0f35ba7368b670201f9b45db0b0c01b97a6d7531b0e59de10fe75493950376e415a9dc78aeb08d288eeb1c606821a1ba99f1cae25123f4ccb2f5257b9fc9085ec33ff0559713e6e374b329318b188b7e922302f3928342ef65161f71bb5edb5111614e734d7f8c2d7754282a8775118d50aa9a9b586a741354b763699f1f7d6d6b749619a5025f0c30cd83d5807212e8fa318b9a9614da0768dadd952abc7a851f29679e649f55eda18499ffed46104c4e2cc9a5e9cc8cf12b8f39975c701006d5787760a14d2ba9867a8932ef1c3fa188c6fe82783a39709926fa27b38608843f302fadcae7d2817a87d4f84720852e547118e236c0acd74db11228fb5fcd50ff442c4342bb0dddc88e64000bdddb9425e6da926af30725783f8a699d00baab948fc6954c97f2b5039468e605f7c03280c2a0c219fdbf2c7e7fd9cf34e9e90cb27361ce6f28608a093b5cab32ce843b1c775255e92b90de60c6f30818ef42cc3fdcd84de1d38fbe9ddd9aa902799c95d4125e4b553ece8c1d11fed72a58808a462c7cb6ea4b30c7481ff3dfaf36ad528e49e5d2a9980043fc23b09cbc7025a4dc56c636d449e3fd7644dfc45c73f55fe90e664db07b8fab4e277042c0bde1b3cff9fd8b7c2e209835f9de85f229728458e8c375d55f5fc6510407e4b26c03d960187c25bb576ea3c62af887cb7a1b3745cd42f3e6148496802231d3f3c93825814305e6da0dac0e778101eb4aefc13d49b2a5cfb34274ce21b30368b344f1be2f2039740c1771f535a4b3a5c483a2e741bfb14c4b785a998f3e9c7e8cf1d2c339c842957b042ba67f0f923f0b5d1a6091390de43cfe7124747f7a678b67f8b5276f89e06ee5f20020eea11ebaee20e729233bab9fb7f29c784e379eeadf01de29df70783b50b072a6a96f7a10571cb3660520293f0c5a8c1a8ce79d1e5d3a028c07d9979d9d1c1fb94b3086b04efea5222270fa593d6711c29fbb7386954d5276c99a58a977ed057b6bb8a8102168c2316bc24883f36aa85e818c7e2cf3d5cb2e3ea8a39558d9297e4f645c3996460229bd84928a0eade5068c5f85a7d80d62f68c5cdf5b4d7b25468dadd5be64ae4befd443d906de88270de1fc6bb190c9d76e47f20338c95764725c333356b4eb20c1c57ae0eb0e736744a290b48f3aa7204fef24566faef54082aba4e1baad875f1a17913267d3388a75210d8b09ccf565a1c439cd6d6536660c9629559c2e8dd5531fd4fb910397c77d8442709aa51b54cd9f8f154df377e18499bbafb517606fc6a058fb055c9d8aa6312fa0a59a78969b55123dc611c315eb1462cf612cb1765ac5e9f76216e17e3c8d315a54e954fea4ad4ab2bce75f7adb1af50b8599d7bb535d53ad200ae6a8db8cffaa63a9fc7698ede53e7ef69aad6891c93796092d5df6a024fcc084e865b92f2d40aec0b3af8e0d6e906949bf73822369da21bf3d58a85477b92c908eaf97f8cc2bfa46e7841fd50d6704f17eccb7789b1c6caa3e1545c2c80f9cb5ab920c5790f251b54b7e17170241137870ab0f6458905f2c77e313762553303b8a89c8739466ddfb6dd3c71b377606b8365e8cb17925361bd2e53101a3a5e092df5d83daf56a7a84a1d1a865ad806012c3a6d70c05ba21c6b5500c56c03c8a08f41a942db600d18be2a8557bdf1cde31b6649f85b12ff02096de2733d32c32fc3cecb6348f5eec054963f438c6f808927c1304dc66f0da98a9c3e8868c141ce51a842bbd84ddd395a0f13608e5295753ed3310e142c3fbf3afc751f51f567a10f5e41e1118e513d4281c632f9a02ee2c4d7f234410cc247e36588899533818c2b870566d9ee63c1f8af4ff71ac06d01fabb1a4b15fe428646ec275497e33f4fc5f3839d43414f9ce3aa165a132c7d6ae663eef1fcca67027c0b8e30823a943bd779a2d4dabfea546afb1ff61ad2a84dad0c9b76a69d78437c6a596ab959ddbd499d250e5b625b438412d44f3c2f94dd841ae8235ae403b303db92fc221aa5da2053f68146019608f68601a2bc0a36cf371c3dea298086fc1cd3e4e93231ecdc90c78c5ed2961330f03e6c94a22a258f45aa11a10e3510212b06da82b7a79cb62b842b3fcb3000881b6d1d5dcb4694d85b0de4226921a00824970256dbef5f78924610cc0629096d0b6363c08a8e604d5c725d3e59817727fbf0d7142f3cc8925137ab831ebc715d8665d84e94e01d4c4a978206d0b76c5ba025caa0194d09918dece76c399de9a989669ca1a1cc03fd76ecb1c7d3a17c98036e3925f98ab0b92d281b7b99cf2328926af424bfde882909db8fb3480763aede6cc51154be401d2597757334a222bef3d17a8e81f865d986133dcab8b4b0365d94628cf7916c455653f1e62f320cb2f3d89bd8ef24f93cec1c1daaea7308785e1db8487f5d80174f370aba63f1e6f5308d846ee39338139347cf715d029b9a84ffbe711646e80a3c25c9d6a059ea328f7689ac9a4d3188da2ddcdaa643ddfa83bf993d3a75d82431b18cd155f478422372c355f504a72ee44e1d66197d7f9b64b4a189a4b9a18b86f8bdf238dfe190f421c18fa2c46b41f267034eb1a44e8b9bc885c93aaa4c70533fe07a9f559e81e31edbbc00281e2ddf785e9d801e9117a6365a23057ca7aa2651bc2289ba0791d455c6f0cc1631835fbbda1208b51c89c602decddd72dda082cca05c72d77e6837f2a51f26dbb814a9c084bb101fa850b90304925c47d69549c386c1b24c745702dc7dd4b700d5fdd8c8812a52390004ffb5586110f19bc819caff8cbf3c68b776232ab6d60788fdb26b5c5afd72cd039419610e037519b2cb30e91dd69a26cfdb21f2dcc97029ad0eec8569194f47af92deed7cba4733b9bbe7e284f44d0cfa501c750ed34e82c9972fa075820f258a75f8ca97a6522b2992d483e9c9d6b79fa1feb22ff455225113cb458cfde019b893b7ca4c6d6dc515df32194502fbc43222fc66fd830e9621ca723acf1b73eebc35a07b1499db86d61c5a916a2d7e48ffe1450eb30b439ea27981eb28234b4d38e752f17a5a3fd5b758f3cc78a49af17b05d7ae1d2312cab15f88787d3fe323e993211339a36ebfda23047e470f1df7cdeee30c85f424da6935ee174aa55b3bd55665b2a9f376d260929535d8fef8c5af0ffaafa5ef2763c01813ff114fb77b1efee651c98f56323582ff0ca1456f302ce768a9b1db04c931e01fa7dec85d3635ece3520eb96ac81eb2282d2730c5d7b1201435cb4e52a4c30f1b625a3610b2cfc7a4da6b36e7d2bc547098d5e43beca8d1b25408167ed8e50f9e8fdd3fc937843ef56b3571480d5a5bc9761eceb796e0f207218517cda52896f9169e18229186a41e30e3b80ab86b3602fa1f36aab6697306b94c650eebe9936ee95e4983c94b69929509ef19f81ba095d246e4ce7fc38795244adb73911aad46b8bcb72719607c0454f2e50d313accbb28f4e3fca1d1448f022fbfb65085dc7ae87cfb049683595b6d72bcebd6a5d6ec4ca0fd279b5ce1bccfb125c99aeece1671631ce4b4abf8cbbd23b7ee4d7b1cf1127efe2ed8332839314f81ab427e16c422b1cb620496c4d38c6db814cc23e26024b0461e55e82ee431e3c5777dc5d921668211c77145ac18d732c361e63848bf85d804dd5d0b1a8ae98214144c434e6d62c6f93fe191e839a15b61f80d31ba6f28520bf8d2d56399a66eed8097735816165459d7ee4b437a89045b2dbdca1b3f7b696b7356a39bb78fc7cc0d99a0594e885b0ff636f81cdeeea2d4fc37845f532546644a3157bb6dd58e589b5bf35a69f5bf79ed0907fd8aab398b07914b65edc76a65388b94aeddb99aa6b0341e0f8ac8042742fdee938201f2763cccdf9b628334ca06e803fb2e9ee6ad8055b13fe7e805c650e84f0778d83b99ecd54aa7ede618594cf1ccbcce6ccc36c40645f533e85f7200f78d2c78d04e0b6854f15a8d184c7582212b5dd0ddfd4f83515cc07924191546f2b4ae54c3679139084ce1b6d3dd97ae448ec1b4b46fe2c3b7dbd28786d3578aa541f530442d692f41615135179737a314739a2e729d44a256dacd7b1d395242f24800500768dc14e1e70762ae8d3e0bc9c2acd2e1b0b1a6dcbe7ad338fc76d9693ef92d5e960936bd9e0ce30109faa46a1db392881e5dece8b4df64cd5c6f30fa94dfb65f4cb0c262eb44cb7fe8970c5d1975cff6e3b5d715c9dca75ef8eafe0bd78766f51610bf11cbb6cc42d74dd53750faf118b9105a3ee5d46a64059a947787fd9ed6c29b266ab8c9fd057d83a3e1c0429105496b25b8136aa1144c403db6d9f27ca599b9eabe3403a9b9cb666476680896e1ea230d14bf96520eafa7adaf5cbd33521949dfd864a313c761e31f8727ebcae67f17c15d02d2734f88f68eb613c0ca82219ef1df9e85acef522df380d85e0372f2a473d4ed26a7e59134d63101152488e906bd59d8167587c37df2e19a3d1eda3bfa4a84052a753cef5e82f316785cf330809dcf22fb8d84307f77037dfebc9bd3cea32fec68e54407e820eac20a27dae4df5f45b26e93c3f321a12f38faa8ffb5a1a0b3ede66043d07680556cc8fa1e71fcef56c164682a8c494e76b467d14145d7da4175e23820e7ebcd316919f5391b743aa8d5cbcdb7de378171e93f9258721e4c20312b30ffdb804658fb9fe0bc482ca21608153970c65b9247206f1fac07b113bcb33fa5d3c52c0680892195c12868c2ae53948b63daa7ba101a2372bb3ae4526627452ff25750013743e31c74b4917aa828d42c871f4234647930d179bf92a9eefd7975c07dc65bfa2ae5806995861457f4ca716da5525e72bc84ba4b19ef1b7c9e2c97d374fe3fe8598c6f140897385a4429625dd58cdd279056e256ef709301d0fd12284e59be193a5716454c85ef65141e8d220dbe5a6135c5470a5a6a133f20e6d79a21d0a6b8433a5487d6796209fd9f96df1b77051f89fb3a9c9fe0de4e93f73c67e3013cf4781cb8d4c5b9daaef44071c96dd23929f02f4f54fde25d5336a883dc994d2c49d52f8b7b6547202d962f8716fd84143e4f161973c85e1a63419041dd25e0b66424714620fe1a714eac983a364f4400954f361234b3bc580b5b38caa1ba524c4cbe8c03ed914c2221d9a9a85066799b111d4f127b5e94d457689506399362f302bb0e40a81ea015f3ec3909639ee5132f55a98a3042d8c79d9f21565ce3cf6f60932441c8120427c8aac99d11be2a2d819764a398854f4e020fc39c09acd7e1b27e56c7c34bc5914048dc68105abcf153a4b8443d86aa800c81d6081f0c8367b79ffae73e99d75c922dae50d727fb5a20a254fd91110dc181073b7db3e45117ebd74e18da62a4db83acf9c652ef4efb2ac98e346668a768bc4c6abdf4db0aade62744b3601e4bdb972c2381a1e9f277dafcf97a7ef4bee8cd38547c87cd0baf9525d9f20e8964aeed5a85f066ab0a0fcf88f9b88dbc69b12af07dd005a485ea8d75b489aa9430b68fdbf6d39049d2b1e877b12835a715e136aa06605ffb1df847578fb7cc3c56765b6ebad5cef5e6cafd1e439c50c730e2261d7f681281e597ffa0cc4562150bc5998ca877a8722e59d3162b248f571b1607a3f1738cbd2053f6bf09cce2834d020e2ad41ed9cf6c3c757f67c690fbb55bc2d3e3a600a89afd26f29341a8cc7e0717a1674f545c3603bc1c3eaaa58ae1f8e3542e33c30b784e60e48c4df5abdbcd6f933a2f6bdd99ef84f080577e4361dc822993e0ae0a5ecf62e682c05c0b9339f76eff347ecfc2b4812ccef9529e15b47c3e3c8b1eac5fe2155157c89c4b56d7f360c4b1b1e24322f9a8f68c5bcd66d4f0b42d0d8ad39ec0de5f442ac5f7672e2b5093280c60177465d12b80e262d23dd4c511dbf9058ff3b0654c527b67012f20e3181c29adb5f63f9ab62343be3546a29309d98d41820a9b556ba6ae714bf127e2907b7a48a6ad916647681ba7454f33a3a9214f71bd0b9b87b227572fd932794f521ef79a91463dc6a76c46ef0d7469d2387c5afeacd31320cb4197d2aa963c20a13e34d9787ee8fcf1bb80a52dc7673ac079c7fcc06abe30bc54eec389b08bb2f41dfd7a8a189a382c92a45ce88e4f19f79df604072ce2278ca5cdaa3ace3ff63801e267b6d6c93524c1c5122ba611d453b2fc90fff2bf39109cb3d2240f8b2988b980959e381dc8392f96906e021bd35f3394e3db9205675a8b4e79be151919819113bb3229bf87734d2cd796dd5f2c039a3c42b4fa42090e295314d423040524996290011ce52f485637a3e44009e767a952901bb3c1fd39acf864e327056d95a6dbfc0514a2a5f426049de3582bebb512df4bb30cdb5645b94c658481e6813e0d4f583c1d808e72913f18da97b96f869a8407acf7047c90a6c34872533313da4de33539689a2c25e25f9171fea4800696a6f35f588c3428a80ade156267c58f8cd5d59ea155ddf1ad3da8235e0694760a9e2375a20e0c19bd89d5fea12dd3cdf2f82e60c96000ed03f5e74d6ac5ef8f29cfeda54ecd3c989598cb440adb7c1bc8a644e59d88842cedaf376200060c4f707155c5e15817dcaeea20503a552ebb25fa1673a639f746dee621a2b83329a3220d301e350bff3b2ebfddb9fa19408b5cf280a417a44cdab55336191c91c8aa489a85dc1c4839e1fda318a487f7c2e5999297f1300b335abaf66b40975bb39befa33631b391e6060d0f1e2a3259e62aa75388d0b7bc64ef3c8c59841092a2d22f27ae69c12794ad1f8b2194d83ac549b47b58eab831a564dc6d19791977bcedb2d19eda8186e57a0f8f151b328106150f1eb0265d1608799e861fd3032c310b08de430fb9f9ff07149648494be3b608a599aba81590020ea0ccdc95e2c3e635e6e6d0dcedf0c4ea35eb7eb08a2d175e6679ed234b42f9e11388ffda76b976fd959ebe6d0fd8727ea231a518fa9c49e0106430eec066ddd7088293cef7ea067af7df9b55145a2803542e0c17422ce06d258471959bcd95c0d3c1dd00f6140e48dfed7b589a6c3dcb242144ae095f7e58ef2efb77b7b3e331c41d9d1fbe2721edb5f66d81e9eb079d424d9e0745b66ffc88c2bd63e609b2827a7f650d3c232da16196caab6bf13c42a5c2e35b90ab0b1a06cc3a5619fb11e9bd4e35083b61f024921b3206659e23c5105bd3eabdeafa8631cdee2f1db9416c0475697188f458b337bf9100c2ea7660aaafac8b366324a5a651a75fac20c730313f1547eac0b74654f2dfaec3ad153c6ae2dad394690064b12825dc458a7f1bcb7a3d92eb97dfb3a46945a53ef495b65fa568c19fa16c95db23fb026e0469855175049bf1ea95788b420c06a5d904790b47afedd6794b4201cef8e1fa2192c917cea07c79713ca576733ee3777c86f82d3007190bd2079104e7917e6641c63d72b9cc96d6cc1ca7edbadc128c1a8d87c515cd5d03d7e6fe17e26f404df411143b4b93298b3e377927dcb8dddca0e01e453b58135bef7c1e830eaf9e31ddcd921110cbc7e0f0f11c08a07a349ecfabf63199000a17782776d62d685f6c6c616b7bd4f240805a01fb730f08f1e02751757198747153c89225cf91186a1bd190140e15b85fbcabcf1cc9da83a15403e3ee6c695ee67029419726de7bf4744b6b5a0cf28dd230d9aab7882c2a63d9fba4d8681bd2a5908009268bff794745c4a4db1414ea26be68609bb08dbf256c665067da0529193cc1378942cb0a2ace11db83004b8835264380cfe8a34172c36c468f7bd203b793b39d698f15b5d59e0f68e107bc98d58ee463c765fa550662b8638bb87d127fc67c0bb72b995fad291bc6d3f6f88e1c31ae2d6b98e1261799bf77085e28ec35afa71b5832d9152a31dafa0777b49c83af127de462bfa72e69480b26c8b2e3b78189515edd1328627bfe619aaf8db1f4a795749622ecfd396f4beed816baa0c2240e3e60cbda6fc6e0292f6d66bd65391d6035409cf7663f74defec6f6f2ef72cece1eb234abe25569dfd32e436859ddb2b4fcd93f1e2776c1eaac4f0d3d549b575ad135a95950d05d09647701439c5874fc56c890712c1a0bdca8451fa3e50dc07c7aa1a78e03609d48986ed3b4e42bb2d5f11f07fdeb37c59b8780acf457f439c75470045dd1a35ae0d0a9532ce5cdc9dd71c2c54cfd904d1e2d588a2be268d7952063780a8c5b169f2b9eb6a1fa73dfc6db623f76b38f8568af767dd052bb430768a01769fad86c7dd6ca7a071ca9ea6511fd4ab580321b4e151798b21f0c7aae69e8719da5384928cafd8296296dde9dbde33694e9b8cbab70154e9d710b923120df4aea176456f35e3f75b1c14be619e5a553917bc50edd1c19df026c04aa3e9fc9a5ba80afe6dd388d62e1fb7198e0e4129d8b22cbe74b3bbd6017734923b8778f8472360ff5e615a9faeddc4a40e6a59bba2f996fc267000625fac06375bbe8dbbe96b1b6b0c44f006bf52be0b5bf91ea48cbefe97198ca4b060e7c9c9ff2e78d23a8aa00f71441650e479c639a15a897cfd302809e3f52148f2a62eee2179791559fa93aa78e1b8f0d80c8cbc5ba80d0036de74e6970afb75accc9a178b2d05ddee355e0006d8ca1bcaff8ee7e871f7a7f33b0a675cbc090d00cd87afd6ad3adc25d56f9ef51210c7924c77d84ba844cc543756267ce9ff20f83126729600ecf27c4238e236a8602432bc3b903defdae31de678852df1d2568570eafe59e5a3769241bc07742835c117724ae05e971be5348219eda59167e21024856af34f17e6f838c435aede045f85458879d570f676d9465ea8a4d5e13e487692f24b88bfb6e1e420dae1f5f2e4582db42e87d084796ef514d0682f8a8fda74b55d42e9d51e2b2147c2c61d5e47842e54dfbf435e55c78dd1acb1647466f057da7728444beaa9af8dff7e5287405b6807f6270a91b2752fe823146347a6eafa9abcf64bcd469eb648e470fb267c31db9bb57a7fb868104fee284c1d3b8116a953a3bad126e699921f6daa8d5a82b74e985d95388f29e1c97f948ede1e4375279f41908cb27e53c620a3239c28e66a045f607427e8d5d8dacd56f26f4af611171568a9591d8d0455609a8bb525aa77533f2d8bd914f94da83ee7e9672f5cb3a7b3bd03eeb34193518ca7178fd3a858a28388eb46a5cece49f72a7bff201cd7f1eac842f50e91086046e6e57710685e2e7e9303a357b1203c9d5baacf4655d76d7327057333944d23a79582ba49f0e41c9e5762c79ff895641f05d752f580ecadaa280fba3d2a760a7a234cc231c3831b43eebcadd3d1c5a3dd423e583c2b1e9bdf9838d734dd17382143e9512ec799311254cd7e7b4ac56570d8903ea67ef18b1fedb4c2f765affdef44ba4745e8f8993ddc70cc8052c3cdc5276c9d48ae9b91561c9fcea2517cfab9160f7848a21edd528604ec3615004ccab23d427b0f1f3904de96fdc52aafd0b214c9880d33bc2bf07e891927b8eddf74f435ee033af30e8c6f8e5ff465e4f8285777d755d00c2288865e06603a3fb6c6f2b3fb001c3ebdf9a0e47866201950da28e689af85784bcdef3da9eeaa637cdacad728f6fbd6f092fe6088b97f92b5e455e590c72c6987c78ea031002fc853e747359eea53aa732db45f22eb2ea2ea697edb78acb526738c669da905df9be9d7b42fc0e41eadd198da352fab03258f8482853751bebbed320b9884060b2f72084179f35c76ad54b7f26da11226be9bdcd6d03cf9e93a3029edcac708ce98f40c0a583d8276ea54820b373040305a81cb82a541af0f3d42963ffae9461ac53332c8e9603940555c933113e1663bfeecb10550f2acb0fc80ee25a919feec2f09460a4bc406e07fed4beb6a03cf5cc5b910843f4322943731c92a7cc04b3a5c3a8b2c383de06a6099b5f02da7ec6d16d0c1d3376b4519b341c2d583d828b45db4fcd4590e58c94b062b6c9ed339cc36a4a7578ca05eaf8b2805d689186545f95377c4ee3253ec91552ae6afb271e4586ad04c489d26bfb4829c8dd51682ecc29239a9a8bbc21ccb72359591e2becb4d24042a670e6bd4477eab89d3ffb5cfbb897b4e41577a342606c8d498666942819dbca49a24e762d74e862660371a00dc8a98a8bd7bdae2e80b27727418782cdf06c1d3f7e6f2187831a2b5419bced255b4f13f8095041fc535c427955e8c529fa967b1b72a6c63f6df045a4cd4fe13aac13b02ffab2d1417e21bf21ebcd178a8c55b9ded8d5a1df7db20db98b6baf2a2d0258458d3585b02bc724e377c1e26bb7e52a7e6b2418e9c392fbaa2d4c655207476f45ac09b65a8f5fe83030f846eea3f2c9d7b8a171b2ea2dc078045315e1f37157823875d319776fd4d22218983c4cbf89a0e2c59a04938e93bed4ef54cb4bf0c2b74f6c1c9f7159bb7463e6c8fe574c8389b0c0a3179fa0e9e015f06e670abe3e2ef5985c8db70fcba7beb9c33e7cff4f55c365aeea0c9bd47b474fb088664da803473919593c619620e35d368c7984a6bbb978de5248d9b4038800e7c824062de14757011a48397e17352ee8992e30989fce307c8657fc977b7cec1a5ae99b01b21705d33ed6d0c80075e40409cba3e7b2324955c7fe6cfeb85a2bdcbc8524e34ca51c0324d9e1029b6af13ee14cf8868f7340c3fa1b87374ec3156024b65b552f78994a4d8aed23fa6e109ba642b12c5e1d902f93a6d40b3f274d1967c8de7e16085c518e41d2ec5de670ef91cf122faf8f035a03e5e6fc75d57cd1ec8980ec4174fc7f69ef95f44d3baa5ba1d52622034600d4dbf94fa25a6527d774ff791991ff5a000c62ca35c8356795c836f14e6c10380093c4de6a9aacc583364352d017ba829477d0b0e064b937ead36e0e2a69085a3fa6e9b34e864dd471847aea54b0278cb13b0cf61af8164fe7aa52c3d998da1d756a67eb6aec059fddd41f3de6d951a441e89136aab1322e1d15c75ca3066e9202c9306ab016b2d7c438ef828e8ef12afd0673bc5db7b913f7d03ba7cec8957a4ef177f743b5461829f9975615e6c7d7e5fcf0145b9253e4a9ee0e1643f6c197560fdf10fe2e621f187055cf6171f69728d05a3e31227c050ce93b2026f57255778ba1e7a98c13f2aabc25f1ba4a28ec622a6788ef4cec3689143577736d242bede7e0317098b5f7467b34489aa83891a1624200b82754655e9279dc8726be76a0212a39a18c6a12404b4734995c81984d4a0e58f2b340067cf276fe8a53a3f35b984246d2d2328edfad48d12cd613a32abc66c3c89aff39bc5a017a8849c127f9e823e9bd6f1cfcc61559ddeeb325c68355327b9c1c56076e190eb4f6fc0105f66bb125edfce58e2e17e607c18636e8259351ede991bb8f111b20e8cbbb9a5c6f04b9833e7fa508da2018a0d409dcfd0dd0a6dec3f0719033b1974648bfcb3c23dc2890023e074532210541fd7ef1dc7325f93c7b5f7008d2736adec4851f63edd553d45124450501c8f92091d0501d684453ca37cc22259bf15fa7b097d66ce6df568aa228b10a734f74508954236c252e0cd96502421fc58b16c7c59a6a07228c0391ee589a3dba49c111af9bc1f858b2e2d12a3d55324a8ad375b810a8919f0f25c05588aae21f374e95b0e024d84b467937657032b796ebd4685090081673a895ca3160e49bd6b51a1024f6fab89a92df42c02c556c1c9742c053cb99a08fe148936d37fd4e6dc60a7b4bdf4b8d93ea866a6ac55a1b7c996b32d8d592e55f8c2fcc4984ca3ccc6041bd7926743b37b072bb7cd1ca2169b88a40070aff8249ed30ba939b2aefa65927c9fd4e04748bbf786f29f752bd932431349ffc3d3210970819ebf511a7368a448ecec8965874b0487d4cf485708c6eaf3184b4731c31ff211a15e96f82ef7b451873f7c8320006048b62b9520efe95cb4541dcf921cf7cfaf516fddb11e9f75cf3738f3354c07715e1ccde866fd2f41db1c26f92d5ecd58205438f7e68cf24882510e7e60e5838a06a179990b5aa1eed12eb6e5fe6f7a16bff5b9326612bbc1f6219e12aefa1d513a8638d45db8a6492bec855459edff961ef6ddf1deeaab9f471a923809c44a4b15e95d75eceb3f4e1513d09375571fd7d25611cdbb6a13784b407540bee5f749a745aa2419158cf453f6b3fee99db5813095cbbcd9899c0fd0d4c6579a7f36dea099fad792277c3480669185e7e7d2d4f44c4991e55947c94094b3b738db53b1b03d5594140789a16d7e9dc49364573016c8a96b47fa54b6763376f2877b3ca6dcd79fc74198ebc61d76a3b68f24d7961272ec0bdbe4c5e42d62b5fe0474aff628d2ed5e22525ceb6911d7b6eee1e8dfaf31f2b71944f44f15af5130342433d905b0e47d2d79fe9b2b526690b944cd6f43af31ea290e7105fff4595aae7ea42b65ad523c909acf2de7e06f6a84d593913d00089f257a7d1c667d41047b52cefec999c4d08ec5851d589014d4ce7ba3420fe1bb88adde3a32dd8a05c92ac582b8abcccb4","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
