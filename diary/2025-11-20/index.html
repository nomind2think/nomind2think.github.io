<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9855565954e7512daf1121bc7479a05b77c04feb5706322565cdb63feec6c298eb9834bdebe22156befafa1ebe371ebcc5b7045ef3c59b353ecd13815403ce0021a4e24e72e86462a1cd1394bec56fd807d9c12dcab83c9c583db2e514abcf03dfa633939f6fb47bc109e91542e6303b196d40b296d51c4043ed8bd7cd025c31e3d791f1008af6a872b88113b491db26c445fa8bc615d6f6f800a2c3ac22bc3d5763e17134691e56075b9b730ed30d57ff7e6a07dac70b2fadf79499791e54ce6c647dc584dde36a5c7123853c3181e5b57e0ece19ce8a3439a4b6f082b4d5dec0ed1dff9b0965aac0ff9a3a120b8b3a085f8c3d8e04aaaa8abf047140aec9c946c894d4bf341aa40baae2fdcdbf99f4c7d38337b43e5a8e96f7a19835e3afa9499f0c37cfbaebee3e280f133089aecbd03fa3f69b5aa6c69cef9be476e30d3f087ffc913ec1f19325b1fbe8ba9087b4ca628b03126ee755447cfbe27dbbd1bfe046beb9fb8c9345feb89a791802c7f6c59e38b2ec6338b04c9ddad107628a3accb5d178adff07bf9d61c78f9e409cc9ab8d909533415553dcb52121d920ba92583430a5d782e2b5dc98f57386984232d9d0508979ce2631ebc08058e7e8b4435829fe5dcbdcdd446bdcb24e87dcf5623562882bdad1506116bd2ae8fd2ac3439db9c66d43a0c67e73ce79fef1972be6a18605643b63a206d3ef2174d902e118099275f5a4c4e8e62f359a77b3b2e54b4b90679284cc500cda3fcafcbcf064faa35af952fb243ac5493af98ecdb06b55e396bc0cc843eef7ca970339335d8ed2ef2cca8e267bddb6981b882cae42f17c5c35b692cfff7e937dead1869b200a05d589c97d8969a7fa19ebb825ba03b82458924ef953539e4253202e6d0ddd0414cfadc083d2e8a1e8664b690da01ab07869b55f235031b80e72a57dd352f22bffe66d22e658562fd781043fb13a9d108d7681f0f9d96020cc109badb449ddde3190a8192b6fe8d0a783dfa363d16f98b407764246f48d807962bc7de62901c34aa809a0ba104618dc7386df7f28fba0f0fb40403df64bc859ee04288580a58ed8999504f5fe67113f027101e67940b191b2935680e3360afa9c67b0ebac52c8e20bf7151caba7325dec85b20f772c7fb81971d29db5c14452b6a18840124eba97b72627e5b5d5cb78acbbee0baaaa5dd2375e0177fb38c34b495e65ec4c4daa26cfe0940fe482801f58940bdd9fab68ccd80daa2e18ee734459e982f74e9ffe6553a99c24308c201ab379e4175466a014576e88744b521ecc996f96ed9a867da57b73844458f05e25d5804a455e7962e89599fb8130aba2c7510412d178d561ed5d1e059fe8b37bd594b9a5130670dbae20d0f6e483b5a966997a4f74eb10477c66b2cd0973f90f069a49a9df9b76b5a3b4eaff6c11f8a94d69a9be9064abcc4a58763ef7c67ea5318226ca2e2fd7514352ca63bf1c9974887eed43dcd1fd3bc7bc14833e4ee6e3bbfd53b3d71133240b2f55e1adb3ab65c8706f9b52b4b6929859378378b74c5403d4d2499673268e45698495117010daf2ccab390bde9d8ecce4baf7c8fbd98a8ef9c29af3cb8058070ebe43389d9bfa14452d31ab773c2fc501e5dd398e8c38630fcbd15db7549dd70d9208e4b8ac14d6cf001232dea735d1294dd1ec20b67b794897bf1c4e25fa540e0573c635553c147d851811a0ca3d3a25ad72e805be9b9df1d313678fea8c355922a2cc17acd7b213ac024b885228e66d6a11869836d96367551be42735014bf174defef78035423fc5027ef2c012885d886caa8f5b479617110507c4a1b64d0c3e181f7cea92febdacb598d1086b96a6e85e1afa8f6a5202c12c77af7c5a9fd50a889a99f7dd5fa37300ef23d57cf89f83e0d7612221dafe30a96a90ec256e47600b14bee5b332a576d62d36d8a0f9fb9553289036f991530988530921d19781fdaa5999ff814b043c191d27e44632805de7878e6a27c1a84a1db7799eca77e39a8c82900fadf6d675cf752c957007a3bbdf9ea5e62d22d1d4718ed80c43124f88522d8f7b5a6d15e64895cc5fb107b680b4b34ef132ae51968bc90c45ac4966e0e93af92feca859af1ba4e411ccccb19a4887ad2ea0650d1f1ce0643a4695dbde32d68bd978156ba7126ca55048bc00bc24727c35f3b42d6075d869f4f0f656cc9f8bf07b4119b9a5cc412485dbb56d05ae90daca4edff809fb28e166c700d09c3ab1ec84771819ac3609da9192b93c68c0b36e533e41da63cdbc33b0b7e26bb38ea3d4161da56072dc16b3d3a59b7d48431b29e64d5a7bd7b954f99b59d10eb7c0c7727ae20b49e887c478a605631f3425977f9630e31ee8f2bd8336267f3e081c98e7318848b72f2e2b168cb5963894270286c51b4507595f23389c6a78afb60314fc4c616047468818e7a2fbea786e06703f0c47ac2e09b75c3ab2c64bfa652a056ac3c76942c9eb8499985c3edfb4070e5a91c8974baf660fec35f4d46ea7a7e95278e0f78ece6a77b8d814f4aef1afa73af6df84f7dc4ac9120cb4e852d66c0a031bd1fbf540620335803f2c50ee080e80567e3033cce5bc01db90a6f21685b8cb4f79dd80a0bce1450bcdc817e7f6e7dd13f90165081a93903dd86b25dcea1cc04c98bd2602894004199960488f97f50a83b975f26f39b881b3b3a98a6a17a7116046298192cf162de1e428052162501adb6dc00f09b668136a35debeb21430650bcb9d85d2b03513d58b6dbfca27ccdebefe51d7f712f511f72ee5df8ffb3e8f3c136c7f3768b7f47d3b8bd807c61f08c5869f34111e05da5cf9b0c6f6ae0a3c657b99212ae24c9377f1be6b1c9d203142ec291817b102a184adf80de248774d3348143298092138c462f7f55e2fcaa93a659b8400cce047858a4fc9d766d139fb0d1ecb8994c9feab2a98d31a9d77e1b0912073cfd756516946741e1aa694a178a25654bcf44b0bb50e0df08f9fb575525e0ce0fd529901bea1b77586fbc1da4fafe2fbbf5aa7a4a92bb56899da6df9d82fce6e581b5556521b4038c47367cfaa533b6790625e135e7253a742ecbc116d92a7e66992b0a42664fbb4ba849d1e660ba8e9833dd8e913a19601b7053d49df5ed206d38ca457c89d6cd60fa4b25ec6479581d23d7cab870809d594f2280fd8e33af5e8ed7a67d4c1ec0129afa8d65a3c8c732af0cc2cebdb501dda438d90aae3b6e8c6e63fbd0464c479b33408b7137ecac54669a9967e9bd02050e82b541b8a3b9c91a8cff7b43b30f8718d9372d195b55929421e10554d38b2b6a1d76456e9b3083c8ba1e858bf87a6b50b05e1fc884493924c88a8a78a04964d58550f2c03f9f52ad26a4dac25de0c8a10abf2f6e74aff7c55f47e53b8dc4e4db8b192c453d68aba015684d8e73ceb7b18ba25561aa5d0a1aa633401692f580658e3370723a1ee33cdf2949eb28437d826238a5fb6aeb31abd8db656a9846e8a0d6ae8a6397149c028dd6cf173d1dbfa79b43fd70d1f0ead1050d485679d9c51e6472c8c857c59aa8f083205db524f7f14378e6cbba3ba0d6a042055772085159f8bc4f1975f72101f49d3c875934025509397fabff05d97ef4bddb2b06a0362638c18c0a330c9d16b85dfc9dc012db38a886e266a848344d15f74e7e6858635d8ab3a167315b6af618c2e47076ae5c31a7bfccb6dae1129e74bc316d17b26d84289e7d85f672b657c0d6968eaff2ee29233c7a1df7fec9c49418c45a9bbcde2eb862234ff4d66c335ac8fef419691063bc76081580a4df97a198b1af324336e91b6b32125dac708c5f10aa9c99205d9398884b305ded5b74ad7598470c2179698346ab2cedd1b333e68825505ae16a1cea5f69734791459c429d7dec214c6f629fa3266f2a05b108b4f169347258d0a61835eef8d2dcd40db379489114507c8f03de79e104b4234e07a0199c64b7f334bd48032e35c4bc8e9ef607c2b73b9ac7e0372aaeb2575c2d15b89b8b35e7194c20f9ab728f1bc329d1593cd4673a59465e38de6e7157ce8f64e469e91d2e7004a18ab47462499bd7902792c367a4ddf4f899fbeb11d6808ed14bc0a995faabe4e7ffa60d840540524dd60e9372d53ff7f36f099afd1a1df6f52b25b01061e70e463a63a4fe721fcbecc673eea1d4c04b28e5c6de5c1f9ebe88379404c8849b55470f6e3b1273c16dd8f31af6a400f1ca7a64cd072d15ddbf1c07ab9a9d5e27887b8c5bd7fb4e63b206582d04148906c42ac544256fe68ba994fa7413532a0b1f7f097459e749e154c6755ff1ef0ffc117f5fd9469e4f7bfa19ee445b4a84afcc162e389d911242d1965fedb355500c0c3eb5ce0c657e691c675feef731741122f718f1c17e216308a062d444dcaceecfbabce917b1caf039cf7def7bfbbe606983e16151a4aa2393428c5825e1f82338d93a66bf703db9e6a9d3dad463f8b27b57e6ed3293e30b2e6ad8e2a577a9a1e4e8e35f6e543a86656faf81fa71b5c653a38f050ebe978070ec89c2c342e336e39d6af03f82a4264f5998d2813912c049acf91af68fe8b8fbfdf81fa07baf72bef4eb097b0ea5c15ff69066aa0a38ab592702c240b40f40f28b669406312307da7aca683e74d988a6b2d9dd8ae7cbbbde56a8acb3d23a363f5f87c5f12aafa35e6cda89a75b9655b3eb1061b6681b3c4f8e52bb6552f52e19ea8caf668a2dbf2f01afb0a40bc463aa95a43e881ec309d0b300814d56252ed5e353d3badf929820bfb1ddd9e050e767e8e25d83c9f28b7238e3e5abe2d78ce11c6214e5f8744f73c245692a11b6306938c24eac2dc678c382be1de502835a9d1cb0c30d08889497cc0f632c382eb094175e14ce48eb5baa547b60e2befc1c3ca836ea2f10550115d41032178c87fc979a33c44985c8d7a34510f93ac2fbd0a5aa301cd37a174ba771f3444e680b34cc31e3b031269f9b12006249f4d1d532505ae12b0e9fb7cf9ebf6b5df43641f035db0d59fe50ee254ec661bc9d76cb9b5f7231f19cab4a9b05695d766a2f39c0ebae1e8b9579d2140b370da57ff96d218a441fafb0b6159d48fa56210a441d6bed5477b8b11578119ee3a719d6c2f3cc663e990e29e8b9d2e3815147a2e35ee5d2dffe2e9f4f79ebfb59a13004e2ec18abed3d6873b3e83965e463097b26f935bf7ea46f253aa9fbb78b0688d7839fc0a703aeb6e41a5aa54efdfd0f8555b8733403133a694db138f74db04582494c1faf8f4f63439ffe565a3bfbd7b9281e69d25a9a6c6bf7db9040e00b7081f10bac4a07f956ca4f34f72038c861d970a68f170b7a3b1384c632c7e38001b65082b1ede317fafb3caedaf33bf20c9bdb3307165833b774e379f8967f5e39279f617530022561b473ed428ab4f6441588b154729c4ddfdd8afc04604b9ef4894a13636b5e6d2f4f00726886751e9d41e3708addea272cb6a17423d9a4789447db7de4a7606bb36ec33aeb68ed8ed1c16d84a5bd98cdc419b2b861e874e0ca01ca022935857cbf3f651a074970508440c630bcd210e3e3d468f53f25e5a9f1c96b5d00ba93c1e8e09e7906f7057e8d4f27b42b5c7d7f4b90fd82577f9370ee3282318635c4f82f5f8ccf1e1df9f7ca88ec84849dc38317ad5fc3b5da4cca5284ee80078813bda7cc32de8688412c425755773910a158cb43883c0d922ad6b4e37905e28e364436714cc5b11bc44633faa730c4b951019fe7879b7d68c2394e3258a9260f66e4e14352097ea6791ce5d828a1aefb41838d735c24a05901c9055d752e4b9f45fb410f6e7891a508c3b45de46fff6a582c85459ed73bd10fa2561bb72dd9b88fcc983eb713bf27ba1aeefd0ac2cc71fbbb741ef646d69951c924c9bf18134c9ada95833f8f5b17f3f4cfc15b6f2ca0037e8429b3bea9f9510cd4e10b207d60203d62d52160365d747100c22f28330188e54146a4fbd0a3a5641988a5abc71d44c911b388f4b4207c73032da9b00344b3aee79c9854e854091912f90027efe53defd82a64dcf658fd590cfd2a72d470e81682c28f14c77f140458fd88854de753fa07dc2391c6fbe54c067595ab0cc46d410be0fa805247e0275d0ad3f279688d124fec50d5e3ca2a18ae69c4996d69e9527e6d22d7b353f44308ead1f99637ed4fa8c0bbfd10ce2f74ecd5f46687e576ce82ef3d45bafad1b1d625766baf27690e48803c811cc63e8d1a6b7ef885e54908ec7fcdea9064997a8f4560748b5b070e83cc6fe7369a8d751f9a54789be5481e0e9f1340f1ac76e277a27fa8391ed68c3ef4ab81bedc9cf5fdab5c8d555e252be2e2d865e90cca50d564fbdd22db67afb7e8fd8c0380dbc2a24458bb5e22eefe13b2b33a74c0651cd4536899dd92c250cffa70665211f88eaa36db719859857e952fa0109e7b5106f005f6ee96f3d1bc000c5fee6288d942fd193880b2bc8351a040a2ba18e54fc2b74556f4dfe46a0018266268664c5413f085638d0d2d2233ee58caaef639e07ab2896283660ee6734b700cdf4b5e0cebff44e7118bcd1606d24d8ffd0bbc8be0cfcfb823544ba4fc8f846ef991f89d33139cade8c2ca0dadb621c381ed0797c83291a4ad5a906f8216615afb6b390f2d4da9eec1e96f046a0972f401714d8fed2bc1fb60ac36056afa63188376732bd90271ddd023a28da1a1eba7953fd565177f6e2c8bcdaac30a68cc4708000ef08661ea384689ad178c46a9d6a581653737fda3d18145b24fc238222b403f15b808d0979c553604363012b888e869c4ad419171e5afe5acd7c57900193daf24b3391ea54028f72f58a4ef9cf26ba08f976bc2882317c3db4258300f50188ef124a26fec5fe7788d29830cfbdb242a50eb5429019a39f6591e9d051d0288f154756961770aefbba172cd3a878b5a73ee520c0fd19c4e1e54cd878b9bc258a66f32956d03492efed2f520a4e03a928991fca8cfcdba5ccd4d0dfe3b61bb8d0cf659d7410b7976f78ba833cc066a95107d02d6e70c4809910fbdd324cf8f1037bb1c24f0655cb3cfe66d458b278a5356afb6b483fa89272078c45cf6e65de1056e947d59e599dce77c4440250dcbe30285c3a63f809b158f27bdae5e32eed0b958446d8f3955b3944db64e33fb716387341121bde923e77125d1ae98e1fd238c97b09d61535937c1ff70a729ec9cd2c01bf0ea18cda62c5ffc6a63030fed42fbbfc347284ab50bc0b390933db63bb6fa8b962ac248743f64e109a8b2f7ad65f74a90663baf8bd0545fb51f2962a35fdcc790a054e3799a175a8187875958f6bb3442e447ecf42998620f00d9997070a148c373abef52326543152a61564b5750d913d22f60be794b42f38e0d0482513a8b1673e8673ea2f51697c888c6f8c186276f42840c8e4ba4b62d8dc7f6614bd4db847e6b69e65b1c640037bfd32730a819237b7aa9e9ed1dd5aed357ee60d908e41dbb1f6d20fc785f57dcfbbf8e5d86d1af859a0e466d33d53acd58cfe76273c1c87bacd56675dda4ec50a9e2bf1a284c68c664dee4b77e5c0ba837a38495a3cd7042635e98aa5185182175fa4950e30a95b245845211aa19ce8fe9c7ffdd56f938b65281b7de91ee1973b7f7c115fe76f78b32651fe4bfeb55044fcbdb605c81ebc119240edd8af7e0c433bb0fd14ac0ce636a8143177c071661f788de271254f32aed34d776932302d048540a717720028f142f7d724b390ced30ca45162cdd38443d490a60f2399fb40c55097e1179023c4d7bd75cfbb12c12a333d375d3c8c463e0ed3a4701c5d048bfc35e24d2281dbe36059063f1e175878ba28caf4377376c6f7acb6137290287f82f02a07c786b058911ee19e2ae1134e7f1860f080f36441008bc90bd2009f700adc6a8e260405ad4a34f0add557164736a3555336fee6315159f830d732ce324dd5299a9c39c8444e1b4d20c25ec8b7ea03a8bcfceef0407f2a43a69c6e23b88331201d7290422455326a0bc116c4082fda2cbf65d4daaaa19bd3330116f621a9fce947e63f572d0d09e3e95660e860f9f5adc80db50127cd92e762244d47fc4f88d65cda3a1b2b3c5999b404c29deafc98ea575534a2d60db529b5df7701f277887665d0957e4ffd150c042f5e673e187a1a4929ad2ca2cf14645bfc0f955138fc2d806fc1e60e1e4794d269069b8903341a59b8d0d393f1548af39a4ca916a3da612193af5dd95b67534ca21a325d588a28417e72ac20f8ab83fcd0033c2702af26be4dc9070502a548230e0272e5741cca2ada6af5d6d4c6b7eccbf0c3d5c8a70820d4b07c20f7a4eecff54b5bc2a2a80c8954d6a455ad66cc246f7ce5d702c579e8110cb5b0b54ac1ce2f182f43581118eca8633466c073002079c554c3bdfda94c796b12490fb34c232e87e1910780bed85b425bdc34fc56b6f0bb160923d31fc4683489a725f9f9376a42b3794443195254a91c6b66a22637285392e147e7ce1fbfed0c184cff860575b9dbe50194e2ff1e9739b4135dfb5b73bbdc99ed030a38df2368ce588ecafb59553bba597b32934e43ae772e13efe3b1d446bb1fd021b184f7a484624b2449b9d842760aaa7d092e691af59942010011c3cd60dd0a601853f2b7d8667c1291fd09aae1f12dc69ff3c30f6c944ad6c07a56a2f633cd035c969dadba1beaa32acb306d21b93f83736dc1e4944efed026376b9b15514d84a15b358a4490af72017d47fc4bf7419aae4afc86f1a7aa8d5a384937144f2535303374bc77ed6722e1e75264532729efc99782a097771cab648954ebb974033d977fcf3c37ad1ee6e842f163eead3e2623132c85d1c357dbb31f686d17790f2dabe054f1f6efe512467ed927820bdff21db9b2cf712e800eb09b3bea69b51e46754c248fea704378ba2e16495d727c9b4734c2fdbe0c8a810e2efa90b8b713bde44688af0d9e60e5886e99c7db2f8bd7319cb9f4fbd98d35a37c001171bb2b87a7b62f7ff16a9df0a17854a6b067855cb2aa7a4855c90d5323d2fc4d453cdfbab362666ee6a8a514122a8688c2103a0f4a0218337a1a865ebef2b591fdecc63da7dc5dccb07df412d652051ae6b02eb170fec47284a265863d8117555cec469f3d7ae525526f8cb4b1d61faaf284b131c7fd03022fce0a3805880f8b5259eea1449a845a9e9593a6519cbfbd0485625f8fb82a8341f63466f1558467bb3dbeeb7c77e8a43c140480ce70207d0b9487ec7d51636e2917fd02a0b92269411dc7d6b74a6a172b32fd192e79612258e43f94cbd577eba2a44e43bec620232f9b2ed3ab5614213cf9c6505faa25233edcfe9a9a2fbb7781a086153660b30ddb773feeebe4fe5bbfec5f7f29dc62aa5f5fa836a1b9a2a980adad0cc2a7610d6118ac62e4bc405e0061963ece4cca7bd9889dd2612be28fb6390ee5d899a28c296f9ddcf5fc1814d8ebfac234a88365377cff26ffa17ad4d7f6bbfe24ee320f84815a23f0ed3a648dcd6470cebf4a13ad60676d25fb6b7d172c078495455b51e27137e80970294f40f8204d69fc6634d7db0d89dbe1c52889a5a3cc3b909af71b641da04ff464497318ba22cfb4b5e10f5daa5a6e89b0fad537153d3906e56bd4a7de226da51e025c97cb368e91e3179b005c1f5cf2e569f6a94db91188b9c3a313f9e17724c276e84a809b03d1b3c3900cac86b74c7ebfaf1f1bd06b1cb212236bc576fc7e98241874290a1c70f8dfbf1618e406f40ba10eca7428b76b21e3ca4c6a0b4f372313897242a238e1cf00f65d63059af80851ea97c62ee1ecaf1cf82332b177db0af51a3951f75d3877abafe266c64ba77ccbfffd0f847fb79a615a2a9c5737f538df12daf40e54bf36c7f057a4f898f2f133abd8132f24db2cebd63542a640c6ee4c6918f8c199f5e148595d58f5354856d15198253ff55d00648a5c662c03ac7ac49a246d3733f54b495f4c3ed34cdc01f618741dd4ff5153269066ce67a10a490f5b122df6a9212184da530b88aa60948a215c61f02211ddb471adc51127210387d49f19a379e1480ee2cb4e452d03c7aaf8f7d2096ae7431f29a3c8808ced74e24eeaa5647b022e205d0cb6b2356e6819a0e5fd6e60cf0c9ec1110d481f085cfc81fbe1720441181482d1853cfed2a592e9c16ec29001970d0204c8b410924f3bc3dc11230410e52711d0e566fdac1cdfe6b13d0be96b0fe303412fbf2d85c16c412df8b7fcc85870729e594be861b834c7cba9f9b1a484af74d6bf10ea5b1ce2231ce19742ab660f5b03a02b36c29ea46e6ad6615c2efc0821f7dc665affe6415ed99b2ec73b95302964c988592306433635891ad2cda9f80c1a319369022c364ca72e8d06dc7557ea15298bad449319033dbd178e7adda7b07be476baf3d7007ae9aff15592235d7db810c120187e5c2f154d925519261a27b568cc4ab85c5a50852fa697126ff977ccdfd31a461d8471568ec7e03ca2e7d40278b747bbb8fe17d28d1923fdf01ac25743e755188dc6bc2af969f2d59e53d882bf68507138e95d16aa24c1bf180476686bd6fd6f0f0d8e1fa4ece33dce9f5b9dc6da91460b5aec8b3caad67a3007e4b55847046c6777d012dd7aef3f3e37220f2103127c369b079b2cc6d0c7a99a6fd0bf648e1e95c505bde841d11b1297c402fec2fc10bee35aaa9fc5a937296e45ba7d19aa75ed2c85d3f17f7d2f9f1b312e7ff0c4d836e3ff8c51791496662486e7d2616ef343c3b2955a563c3ca142e81a9a3460d0256e1f8cdba1d839c7638454326f8c716c48c86d75622b83b79008e3c7eaf6a70576746a755ce934df4ad0fdf11991811f0508b4cd93163a32f51a4ae9f95cd0546a2ff1f77e261ed65cbf625825bfe9b4627d6c9c6757e8ed5cbc3b94e467c3cb0cb36c4719506444c9b182c2331565290765304269f6958cd63c74b2fe5fff5b2c8f48452d0b2a98635aad684dae9f05ffd615ad93dee13f68de7ebf0ef00770b6593651aa6336182cf7093af14b97db94e65456be1a94a54ff3fb6a2cdf23abfba21fa4eea15c8cfbaa6511bf20467d48c4fa33cd5a667ba323cececb20cfe97ecd631d163fca7ec1e566f33fd0c42d1f6e643a629b15207734ff3484d25b23e420e0aa156f789acb193b42ab9119f96acd3a594bd57536b9f4d0a60ae2af56dbcb0ceea4649b25622dc9a8f795fac1c989cf62e29790346de8682a44b250b2ba72c313dda6d0e96f4338c2879fb303a9f703d9caf6a71fd18661b357ddfc77318498d8d920c454c83c949178526182aeee5be0da10ec06a9e549395e2b3a8397e31ef45d62ee09703566247b25ef4b00e3ecaeaf90816466885edda4071c44dfe4cfcaef76bcba2f9d22996337041940608fc8d8f570d6490329679868408e5122de9ea48e0b56e39414df4266380f63817b7fdae6f3968ecc8ecdafdd31b9755de01b53e47e1d8aa0d4427a91205c578059f73a828c6657a127cb3bd9a3aae46df1d8293f8ae46ba097bf06a9f6dc5c09f9d658109a1604b70c00056c879585b306d069bc5c8b23a2b08679aedc05eea2a9381b2ab6b76162e92d14703d5a65156711a75519bc161671931e2943b94183970271107067198d846ab3cc7b21d5682ba2608a71784343fb72f3abe35fc86ac2693a9c9f5b1c674f7656f04815fcad791bbfa4a84bb94570a6d1ac0b5ffc79cf666c58778152e0904a3668cc44023627d9b509c950851e0cee43fa6d7fe9eddff1242c60cf8a2f18f778c61c6975d38146a593624757a1054ea6a3a6f8478d7cf0f029290da4a9c61b606f1e70b4844e71450e3c60018765a7009b3fb4b61ab6bc40ba08f516845f3d72c6832731376da4de08a3be8cc89bd5c655d23f85004afb5dcad04b4839813f42358ea1f6183c6dffc93113f00f2f6cfcc345b7314c4d755b92d8a5bad680b95a04d4f5f77d551bdd5d5214322925c59608e877ba206c34a02f4abb4324686c944d6930edb92ea1968db8d60bf769f3cdb99a7c354c0e44efc3722d05e58f2885adf76f24ef90053a91b881c72cfedd786f44264097ff3dc74cf5b95e661d4b47c548ec11b7396cf3faf70d8822e3ba80d96b5399715dbf7ba5a8955d57970facc7bfeee8bd6746694fe4cc86e9f9c0043cf7f982c6e7d7c116f0b686ed84b09705540846117b46f0966e8b7c7bf1084e3fdd1f0ab15de8c638ba90ad973a69202fdbb010cab566907556115a566e9746b80d71432d170d24c7d783985c130c194a4ebb707fe592710e25009cc0a918e8bbfecb25f82d2d9b76f60109a8abe28363983cd94612165d28a1ec2785e793a94192d49d37c846e3624e4b7b1d5b2f2e2b5dd957ef1716e8c651e30b7faa652ce32f5cafaea30f3822a9ce922ca3179c3df3c62c714807a5e380fae0df6e0e3aae779b65137ebf9a406a641f2b5df1761fd1d55a35f1440e81ac6c483796c18b17ac36a64e05f8a5e79e416a013fe32e932846b534c7e23a7eb290f02c9f75d5670e235ffc66b758280d91452aac2be95873d6becfcae5c38c16ebb9180f5ad921d9ca64941c74ec00781f1fe59db11d3d1e05a6b35f9f85b22d5f6cbe94a45fd78506860e24633390719b25946ccd624eb95cb0b82a6ca1fce08d8f696d7174f4d2aec064cf28f0ffdd40f9c41cfb19327989d07fd52e36822d8e2e3956cf6a99d7fb966844bbdfb3488568ca7ca1d2312fb3907f21bf24cd8a99ba1955f138d1374600ab139cede5f736785a9e0c5884a49b2edf6f361c8eb29071b7971914c00a0b193ff693d772de4ef3f6bd8d8c5cabf423f6cb8417a42263ad29612580184e40f284bd93cd479a7384f735adbfd7fd4bd7ec9d32a9483123699f0ff88292236a81e3eed9b5731fe90c31bb49e225d2da9ac4f2088de6bc31b89cfc7d20e497636944eeb598b285189df7d4469922fee689f039f7f99281c4fcb4edd1ae901f460cc60f3e10f070cd66ca106205a26c76a88df742de476bdb34768436dacafcbc7cb0d3ada36a42c2ef6f8222a58c4bbe54de833928e49d1de78abfbc538891c31989f88d396f6280ed67932e69310a4ae095f6cac159f8994f5842df19e13786b2ae08fd10afe8c6503370208bbb22c401a6c313b4d870e9d7d1929d528a52c3583da6541fe5c36ca6aca3ba69f3b40f343cbef0457fa7abd2239b8dba1eb86621946aa740ac4c52875a56accc87894ea387c892167762e6f1630261b59765aae30e5cf78dc7b4da2318529438e43e7957162e4874417f86b2d8ab62f14b631a1c7c5ee2890f304ed2445b967d027757391261d4561b0d76443e7061c47b2a3ed9e5269764851a91f9232f2723156204b151d85b45cd80591f4f32fcb6468993a1229fff3ee3919a3cb6784352fffe715ce3a9eb7a8892b48e0a7d13b6e77ba42627ea867e8fea02d895354628be4feb1e93956eb49d7805abb7f6de73f7aa4511d41d57f0da457f5638ffd4e087e14d80d4ae4423ee8466afe6a4a9c794df5dc3a1a86867502977dcf482fc564869e0947f0e6a1ea81bd0e03ebe5b7353270f2ed07fbd3b4e867fdf9c624b5fd5a5b95cfc2b6b483fa190d8c56d5a4480a70777cc64cb7ea0deb4a1d3c3aeaca1817d0f9d900cbf9f835ca832256a0f8083119c87dca6776f8047af150bfa0c2f5709166cbb374c629db509aaa0a57d1af5f56b87f91526859cee5a149a7c837f4b606702eec86b2ef7eb46c6e09f6df96525f57574241b27ef685c3571f6aaa0d62224e03880f8c889b7f61fca6a7f5ef3366024b56b4f96e5c31c5409bfc4c7480d80885bd552fe13639934092e6b2e4bdbfb024d174051bb56b291b5807f759cc2e05ebfeec420b6daac42dee8277bfc59b3e00c3b22ec788dd776da0d4a438c7cb05095c789e634b81ed92a34d7236f12b3e345eecfb27b5cabd7ed63f588d3bdad292c6fbb3a10efc2366c5e4f956717870bf8dbcf8cff8daeeeb5bc06b86181730bfbf4490593c41de0b5af072c63e6d1be12d82f060b46eacf96ce0dbab5ae2234308b75237e56054e0bb8b00824cb816b91953c48c90c5e22f7963ddd0455dc9e1e0444a0035e06659d16692dc43bdec7aa861a6af4c1e32c3df033f93c648a0c0170bcc192526376c087df685afde8d6dd28cc565ae2a83993f9030a8fa5492f04a25e5db8955c1f033db7cc81376abbf89a4fb6316e09b406c60d58deb5576055161b6117fa5aee9a7a4293303ec294bddbd47aa706e1e00ca6655b6ebfdc05219f4f6ebda5ec1106c69ac01c4fc12ac4cb688f98103c7be358b48193f2b8acd5f82d0110cafecf1c8da62eb40cbdd0d0e75df76eacf2f54c773b066cb34413a02df746ef92f208fbc239e3858ca1f260afa107e2f4b78f900f50738c53c0ee7c1944b969e0a88a255ae2f476b68d616551ad293fc4aa067f8058ef60a3ea7d640551fa8eee76092f6e4b76988757493ee03d150ae012d232436cba66ba7ae0ee37e6c300980ead3af4a8dfb764dfdf5dbc3f258d0af2d473da5a5e2dddf8a48a5bb75ae5d52919679d2974cd00540845ed091b0d31efc21f82140e68724a27c357ebaba351b198f02e6f3e202ea9b1579dc554efca4c8273234d0bbf9c24ce29bf4b0aa8715b4afb155884129db408c4a35aec0eb56f57ff2ea23ac76e6aba24bdffb245775f8b49370b3b6ad45cdfcb1e2807ff1cd813ee1a7380d8886d655197e9496c680098a0f1a221a773367c176da2f14e2cb2798a86821d6f88ccbbfe929974981860f4d6cecbba06f3730630d642a955a7329a0c4480ab4b8bd6507d55d41fba1cdf0b65d32f44fc8282f3f34c3499880fc404d76a81f9708708c291e2fc6556431d9596fb47c5e14572d50968e97050d96791329ae554d51bbb7905a70af35b721c06b71892d0940b9d7ca03e44e44a93caa64354adcfed5c0811b6ccf12f9e96200af7d4ddba55a8d136404036b7c17bb731c0c040683c24980c89d8dd92081d1367fab45a3d044594ad3543d417c31c601fce8078823fc8746b03c487aa27e713229eb00fc4921b58bc53516fe4abd2bd4665513d4c89e284d7d1d3b95437bcfc14677e31282b65757628b6f83d97f80721f993feffea2fc815d8c4d95e56de2a14158cf434bb772712e0b02c6a98e63864ba14740008de7616760cc6a49403127ae5df31dee80fdae85a6d37236bb78da8a9690bf56a31ea879bf5c5dacfc05ac96bde34340ba2a7bbbd784e48ebade937857fbebbfeda9344a3b0ca47f098476f33a95c315430096cf6698dd89d9f76eb363cec954ecabc52273c4672c8f7aaf8d778df6d35807e2f2ae2815746f84aafce04d192a2f8017536e08c2e8858b783594209fdf05b102e7461ff7f0c5f46bb50009d38ff068fb6a290a6e3df70b25272afc72437045e8079b2e010ae6363852b9fa8b279234ed2cff8ace6eb015e671b0b0685f6fde80c28bc7d3f8e1b366631fba7bdeb64c627088d330f9c593b69077b5108ad8fa288b6773dcae0301e8e3d3140bec9a9a5da105b88870cb4708856014ebd7d9a4c7ee77e747ab1890124902e2b76094ecfeddd289ab8ee133d83c80902a7de26d003fcf23981558397043ea33f18f869ccd4251a1660d03f894f57ccece484bf9336da4c26c0775db1be68da48ef8eade49198d6c89b1b35f0dbf7030915a4067a8fab89f77fa79e64088f7f06f90516444a2a3e208c5922504621f2d9fc5bb04dc1671c4446f2f49ade62971bbfe1b6dd4050c9c93861f2db919e9885d02e54fc958e069dd37a22222642f7bc6fb36e65f6e73bf467fa4b7e4f28ab61a9e73d5c35f4e3805f0f866442e98928643ed8e27f4ab0a250fcc7f3819544316d83dc746a6d0be9bb125fdfb4b9ec370eb0241103fe1ea61d33a31ce372ac6d3982a0294b0d951644d92401a8a6dfdd5242fa6f35e528ef9cc4b01e523ca06e9e4b03286c21aa71489bbf61a1c56c537b7e137ff55ba761ca0c18c722be4f32a6c5eb5315535acd187bcf193d96f4c9cc99f711f3302aaf22a2fe3c7ec9b30a9ce1cc00dadefa5c7422bbea43536703666c1afb6c2e4e0fa636358e0d3891ad54fdd32647f3a2ccd13b98829546d7de0c402e7f168a2b22195f90144e4af81b11819a9ced88410de4a18280b6a11bb9e8d1aa29937cb125b1256d0a8c45be5a76bbf26ecc100a7465e4703be317d667b7d948eb50a20f751eed1ea3805cf131f4eeb6fe23ae2d4b2f73777b637417b0d5a2a3e2b311767392e04d880340990e723549fdb18e50fc76567efc241147427b9650912a93c410b106afda9667252790d478e007e4ce7b052769b2a7e213e026c9937e7511a98a050ba3c09928adfe209f9581dabb76483d89a6cfcb61ba77e385758ca4b0bfde603f9f0f5a966313c6f87f69c90b721a880f2e9018eb80f67667aef48baa6a3dc5e257e4652bb006073f02216d5fa7f03127e8b0ccf592484c0e166bf7a1c9e49e793b14a1fc12232dad62322fa0dd427367ada22e73ce4a75edf31da00674d6d4a7df00571aaa8e2dc232ebf88ed68cdc704646743881c288923821b6e75ead9a55271d6fb952247aaaeb020a7e9f285730e83d1be40da19e7a25455fe74ac12d8a036a451d1b5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
