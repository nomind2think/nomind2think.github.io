<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a587bb42a32c132c0f9a2c8d5365cde0ff474bb68af457b83880a3805e5daafc8b06bbef9f82eb91fbab4d189c7e8fc21c23456aeecc0196c2681efa784749719b78f527dda1623f6ad8207eadf12d491621696acc2419e95bce5d375c02778ef0e6c4d03a3462c377784edbcaab52853e8c64201b2d1712a52f3d3491ae178e18a30ad418fc82312be1e483b10a7bd3bac8f5be85362ed280c380d19195f3c847ce23c2277258d0c91e9203b3eddd6a602fa0aa96a9b6ebd53ccea9d9c6ea00e8d4ab56841c1acc0a250cfe64fb5d6f3580a23317782a31158370325e64f58aa185bc81be2fbfcb798dc61416e0e2405bdc59f10af1c4cd3d2ea7ee5ddf909a5a4616e866834595545a13937099fbfe09b4e365cb354b3cb0d20ee4732fd0bc2ea9546317a8e84f330a20df8144e1edc73e74270726f8a0cbcd7fa36c4658aa950a9beb345e0175af4ece79d639ff37cf0344e309f888f3ffa1277418c4662f2a2a67c1b32c4ea66e3e30be648974d85cbb505e17fe126e3c2e9b612e5a5507844b4f76f3fb73a4041d88e5722b5f5016a355546417e4afff356dea9ba79dd089e025004d4ba468e365dd1d60c821c9a034e6595fd1ffea7550c1f490116f00cbe0a9fbd3a8687ff49c5e28aea2754a6acae3ae6e9688adeb6cd0eeacad51262081a17aca3721b944f0362ab7ff7d371738d13bb9aad7d519c2ca250683d1b9fa19304da9bca5fc28e29b65d12f6f9a89e129cb10f0ba5417e19f7e978e36b5334b0e371761090322c89141e4a0d82e5a3ac85a9cc148b4230889bd0eaec097e9b4298940e57a80ba3366570b1f333e253ddc87e3dd0a952891b29c4bf55722eb697a6af90003dfa9da340e0f52200d56efb82409d8727fc7234033b7fc605da7817c3d0fb60e93a50850d63dc0b91f1d146b256f7f37dc290f5ac38d7c2ffb06aa980324d2136dfb907985b654122a3fb110a3f3473dc14d4ff9066e9f3585bf825946010e990602de986d1810f999565ae5997b5235490129a6dae52a70c5fac590a7ddb0219b1b14db1091c4252a31f38938b2d5028cc7032a921dc8375bb045ed2a471636fa64c1fb7dbbb3635211df5faf3e2899cba2dcecf33d250e8b197452c8da5a2cb437fe989335161190b341f9e25346d926620273dd12cf33ca3a54098030d033513802a80ed8f54b921b539d09f1f88bc490fd6c09438f1ba8f590405fa79f5b9970d309a2ecb14dfb7b8ced8afa8f8bd0d2f8ef5a0d088c66e9bbfde045ed866b5d35d08e57c368f5cc575655ea95787a40bdc4f19a8f0be5e7fcc63682025156ecb0ac213459cca082639de993811a5ccd597e54ee878e2cec884af747e76fa272f93c0fa97ca05ed9194dcacb859934161e55189a882fedf9f387fab5e18329596823ca7b03c8b54109aa768dabbfdd8846610469519ce22d38414ca29716d6c8b920bb5e8b927b9ea832d87a729a41e0e1ba8b0d3879e6d771df4570bf5dfb4f3704c780444baf790ecac31907dab8a052985d1ceb6b77549231a39e6e19561b755ab6e3deade6419644a5faf1616a4da33e529706a58c72e75aa8064be9ef8d69e689c7bd6b219d43dc9996954030420679d498f50734484dd91dbec02a5313092f1a87b5e98ea434023714da6955b671847e88f6b820390cbb0d5cd6c67f552fed018cea5df5d31f7d10c59f1ffe87881c3b74dd435d22498d74d5803b4c011de3b7d41406caec089ef3eec21d81016e2edd02bfd5d5f5b31ddc99dc6943e83ce41cf9c78a9ecfb2cfc96ad8853d500cced1cf44d99661a6a537f5a1a41cbc2fed99a921934bcc5f90727ed5a715e64247d917d72fc76d8e333fe390792ad5394f249385cf35f24816c1651ccd6e184569d477efb72ba46598d15870775905b31fb79f0a903f2151a54ddb26f022d20e747e298e176b223216381e3b5fd2bdcf4a35d4d8e0c91aa6925b2db277572591a9aa47b7a385902b5794122ee206034c2932808fa73caa44058daba23052fae7373964350de8ea182597376862fdaef1920fa1ed6a1296556c577dfd28716f4c9eabba3d880d79f36191586b000511281e5ebc2ce68dfe3665f2a536bfbad53c1bc4861f255f19152ef0ab335177d824ca14816ab0964288a5589fc29df8845cc2355d12b9eb642a3231d24608e5eaab6e5ec0ae2dafb76e0d4e95dfbc5ccaa0661d447fdff1da87284fc7b703914a5c4db47dd6887e140933dafb2744b4ff6a1da99170abe442ed76e56d759f2e71558425ef6f1840b41461c4cabc25ac872679c06a26f54f6810c9133d0eb059b4ce83d6a1575e2fc4c30b17746fa735bf82e8b4ac6d64e555eaec96a3117caafc21d4cf52c8d2a96d7c7051dd212e836e2a962861e3a64fc87e4be3518be18331c2900ca6f9a278d098a04015009a6543901de39c9841b14782cc9ec5b4edea2808eeb7922fb48221bcd2f9cd6686f3ac66f63fa386790073aa2c19e7ea1ef0106d7050c232f02797b869c982ce129c033fbac47ee9ecc5164ef7258df351970a79cee5f083e0000c0c919b0423356b1880e055b28bbc0967a1ea758fbe70f61bf87f1ecc31d23cabdab3f67414de87cfbd9b223d198c112cbd3d49cba1053f3bc162ef51106133641291e05ab3296ee1ea3a84ab58e31521f2b162401792ad2ca5238f32b461daffaba5733be6d136626791de7ab3a38d0954afd37dbc3353414e240afa0f017ced9c86ae50c27982b9dd8ea6062bf6c99e489c354a15862cdbeeaaa0039f54bafe145480e5f91841da213001635078f46b6565b1ea4cd2363968b5f82d5638866abb8e1229ef464ce0b074cce369c906135b604544d45a2379933c55f3255aa791cdab84707d3a09f05057ea716ca9f28f910daef8c148cac688fb6756df680fa654e106e16f0dd34cce2753465283f739638d0adf1615e0b42775ac8ae1c71e9865514e6ba0e5f86bb6af4e7cc7ce888fb00fc57b33e71de2b65d126820a05e33aaf66b6f5368745074c2cd81ced82fc91686373b8de5e373df6811eaecfa9863d5f70042c3abf5823eb76f847b2623dcc62e1161b90e4d1b0c320f602267242f96585df0dc027a6b8419ebb9f47ac725b30b109fbbba4d2e2d6841001a2df5ac15adc01346e41d0ff3b4cc155c1fe6381c1ae590b6a63ee63d107f49a40d8fa02bc22581f64620327ce372475e9675f4160ee5d5bc8e9f21c642848f85ca62f8a0623472a5d2790dec0513989636cf32159b8e20c74d2767566aab72466cd53d6084b78f1f11e552ce209e973b6d3f859a88434ac98c950daafa463bbfc5b37b172c68bb6cbc9b2cfdbc24d45edd47dd07865b06ceaa764c65a67897cfb45c8497e0ed5c463a0b8b55432f7c8e7a13d501844141c4e3dd4924ff0a125c0805d64df0578609d408a0fe37bb36f0089fd4f0c1fca1d3aa76b8c784ae65bbd0b772f92f79dc11b40a60878e939d97a109d132482f9b7eed52aeac14bee3397c248b3e4e250d8275bbd323dcbc8bec76096f0a0322cb908b00d886f982d44d605bc5e1b115d7c67c6dd3125963bc1e2be4e1dcb61c8841e7e37058165bcd8b859cba4fbb1b499714407836d39232dd9304bfb7a92d83105dac37f4bb99826cb13486171d61ad0dcf0937b0257e5d0a73cc00b0b1dcf255eb6e7f162276412c763308fc0b0fb8de18b73a02dae19ea5ca1509e41cf0571614bc6236d643df154e48b66e7ab5b7e19f233761863435c0af0ba78a533224a7657bc90069928894624d12e5725338ef6c183033ac5a0ac7614363a27fd0e9f04c3053098ca37bcff4c43a1f25f0248b55b58902e92eed1c8c50d0e8e8aa7ffa068f711c409b5b5c85932b5888f424bb7d9c1d790f1360411a92b59f68ff882da94caff800de2a12062de017d7eeeed924de2bd6f52c504f77ab25c6f2228f7b8b878c729bdd6b7076f145f7c317c7dccb5dca19438e062becd9fe1c1275fa9258dcde57cf89b7999b1c7bd363087ac89e9f1cda4fff47f1c037fd8bdec76f8970b69187bf2f9b27387ee1111290f3eb4e73b982dcc7e47510d0fb894c4b38429a3c5138a8350cc18fff712c81d9f4c7b5e86f4a56bbdda4035a81d3928687156850bf0567ff6717d5abdf66574e04709b0c563d5c8d6c527c281ad4fd08e34db8bd576e3ce1e26208142f3b817909f3eb5b1825f36604d375213fb863fa70167611a33dbad2aaafd313e6279017d752f05376a1de476c54eeab51a0017b55e7685c4ca83af65dbf0b1ab9d63ca70552e0ddee4a51f0283ebd438bd08c6c4bb0a96c2356eb0012e7ed6dd542fd3239d00fc8ae81617fa99184a87033f33ef3ad128d0a141f11738e1823e975e89f7bddae9eddc445e0afe9af1d10dd3c5aaad12131726ae13a92acc1f4bd83a2e41d0b81756f419987946664360f34c3d7762a4b2162771f38477b15d4afb1fce481b852c52a15f1dc2dcfae0b08f02479948a7f6f2fcafaaf731d3f7a46dec0949ca108a8107c3047aedc608fbe29738edacc1bc22e5f4caa4b173fece25abf1b388766f2741913b6bceb834251009312e63ed31301a955e4d29f0e21ce6d9198e71c277010158dbee98ae40282a55bbb0a39ddb4c974cb58c706b8d92cd1da81b5711cf1a21ac96d4ab7850319e705ae84ec6690bdc6066fb8f8b9481328faecd916f92d94e80486826616d2721e099b089d8e06e891a4a1d058ece0ad5c2e09eabf393315ab892e3484adb5856eb083a07b9e693309023ac0823f523bbf2508699137296e8e90ca030094165e2717dbb5980b34b0ddfe75ff070d565ed4d5815b18bbbc26112f20a5c4cf4f216d94eec774e597ff8135e403496aaf48d8ecd9569d75ae2c5a5f66ed9f16f72c1eec42e9ce7430e065fdcb9d405dc469539650417851a5993f817c0cebb59542c9ea1592e9d7a0fbe7e431a84f6ede6686614c538852881f9aa324ebe53d223a6a818b0735e99ae38c2ed57e317ace2521000ccb1489195c8da776f4f1a94385be85b9dc40ed35ea7dda94a86c917cd5de50e80ec5735153b63f1bbf506fccd3ba91d60ebb12b57775549c351bd0646261c78580428ba15efe96b526c260e35ad4bc7f62deaa6369b9be71ee106c11de29391a21bff7cf9de5f85effc1f23966de04f2b24ecf2beb736e377ecbb5d465b8d97693a5f8a1b542c22ad8ced9172d745e23aa87cd4bd127e5b4885abb35343d687e37bd0d51c0893ccecbf2a6f6f1f935af53928432b1c45d1494eabc1798ae882ae9dcd0ce1c1a2efab1eb1e0f60709a95fdaa9f6e3a742766d9d20c30daeac48b6c7dfbc33d22b1576211628283c945c9600d361d27a68e7332861b26647ec2fb2872a53872a85d0e820dd03f4ae9a349aa767c751c33181983e4e171263376b845433280caf0a6ea5bc89036f48e3e94ea84b8c819702363c4842ffe5d8bd0dec4db5eb11b69a0c956d2d121b0824d6600b103314442b3fff0a94de9ac6d03ebab4b2586b9e08146911b276537faad46b9c66812d5e17bfeda8c6f2f1874470889ef44fef73af05756eefb9ca3527d38f0dac5e862e84bba21a40ee889722ab165a5c2e42473399a4686901ee6b2cb3cbe64f0b8ee8ad90c466d163f906447afe600293a9aa5646009c6f8ccc05c88cf1b8269b86745f694082dc6aa62f5b945ecf1f32a4dd281ed0e24ee6d105c584f45991c4425264e3d90e2aec4f2707a8e9cfcd815896650b6a589892d604ad84a1a8425e10a7fe7046d523bb98083ea9fea9c31714f5daec37de133a4f0440d4f3c5406257641c9a91aa64b22a1eccebbc1726d17c835389ef6963b21d8ffa428c8f02e6c5baef6b46fa72a479128d9448e0776fab5717a8b8d7d6c4511996879c22f2e09739b2c0eb9a045f7be8506cba94fc7c1297e79c228d543839364290e53050792c45986b09b377dcacc44ad7c95cd15d33ca45ad092ea314d58d9bab76963d72d1da83732da74bbd6b0104e19a192e229dfb59c1379426019420f3d7aaa88b038806bf4d24a3071c634e9258fc95bf00247c55046747ca25202efed59ddc3f77097085f94f8aa04928d31eff5d4fa5bb77bd9ee617cca49c67cdb8c2b2b84a5c53b41038c11fb8d27d2c0ac1e25218c96a3fcb3902973edb3aed7de4e67579e0afd2dd57ad6c8aa3b825b63aeb080049b7c32d1a79424ca2e3374b67df60020432fcdcd591023fe022910c74b47764eebde34d4fdc746f2dcb02e0dd572190cf2273d11a844231718e96012f80a5473a8c5158af1ad1e47410990a46b6260d8aecd1a039fa8ee02726391b3204391de9183ab415836cfd70b679741db09c051f2e87fe30971a95c8f284a04aeb01499036e03216817c640eea46014ace0d7b9b3ce280a81c00b7afbc4170427239e486aee9ddd53bc441afdc3281f68a4a63cf60ae8d4839289a77975500d9824f9d501133102be45c6ff55c55ff74615c04c84cbd335839dc8fbfbc12dcef6156f5a87131d65fb3a1f4edf12743c779ac88df9e455aa0b4df2bd5a8ca35f37977324d614d1bce3bd2e96436b9f70fb822969105fdee78f17127af5a165529c6326d21eee462614d6e25cc99362c9da86e07ee870a9f9dd0d87d9b13025023a74a5496e697da6fce6329e98b702081e04b6f150a077cd088bae3a8f4dccad5806c77f288ccc0ff0e5ca1e2a4499dce2c5092a67c7a691c3f6c832d547c8bf8aa70d5b05abf843e3dcb74dfa037a8e87c8bfed7f394d85223ca0124c692767bcfe9fc25b5f972c9cb1caffe4aa8bfcca9189e310c64fab17102b8a3db4869428cffb07213c5c6b84dbf97ee28b43dab2749823c58b1b050cc73cd2f7f2b258d199a8a57f06b9f0333abaaad62cfe65bd3b995623ebfe8fc1699d7505b2aac85b7607433e8a498b0b7ab29ddbacecfe20bddc18074de43f51baa26896cf2453e05a2b291cdcedbebfb16df3977b17d526ab8be4e6cc25661765b894b140008363e5374d8a1ec238a52f3c2cf16671aed0027dba4fe2253d8d9b1b23cec938408f8bb1e5ebe7dde696e1922ff3b7e6cfea9cddcbcb9265c50d762941511a61641083be70e04b9f1dfe8f8e44bbd14be85edbdf3d71bc7cb6e26a331a3999bdbadf8be7b10d6b52b139786f2b2475d56a2b06ab9d46db600f83a9d51ffef9f5d9cbcc652a0b2387aae50c9403203e5d9c8b5834f65c6406fde1319a920987d09d291f7ceac0744bd3d9be4f008d0ba44fdc0d1c369607d8b2fdaf281879805e523d4e31d92058d326ddc6ed15c437938094fced46f343fbe98404a4208fd3670a87c6008e9d9eefbd2900aa0fe93dd0ec7030cd5c257b0182581c3088b50ba75b69f2c39ab332784b6fc67954c4e66b9cba9809f30b03b1b072902df6364d09c34a7d6c54ea32c56eed19e36d6ab8ba5a64cbd6f9a3c72b9a831431c273eef351bdd8e8d3590dffed366b6ad140c3103874560786a1ad57e94ccc8ce670fb3d568085ae625fe2020dd8afb6fa76a1614dc64373addd512b975cdba2fd3333c1dcded75f15afed9eca3c85f63f23c37279a1e2c9473979fbaf0506b788eff68d9c264b377c62be12b12be8095b4c4b7934601fa3fa8308e415cabb8b38487367e0aedff3a927b966af2977fa9ed7a92f8056085e11960f7b38210a500ae818bdbb3f51c1dd3acabc086875f56ac76df458418679f1b918bff49594612f7c42edacd8340d24763c5fb699a812a23cf15717f9e8b6bb35db82cf229270910a0823f83a78ab2b39b537ac2853761eba8351ad98372641e8317b49180f0e64ce75e958887d077432a342c19b85016b48cb10994db03bcf26a7d45b57291a339416afc86cf1a7544d41fd784c26f1aaae8fcf6adbeede783ee349e9f6863090049d5007bb6081c07b4c54ca894ec3d38696cca55efea5aa84b8b73aaa68a48d5ce2022059de66de6bd88a4055c8be264443550f9e68d3da5e765103d656ed0bd3b66db00ab791468ec5ba1b3251aea555e9b33c67b4eb63e4a070fbd26fc4b15d9fab1b61ced3e5f8ceae972890a6393e0e047f6a255347cca4a09bc2777b045becfa6bb3894a9ca67638ffc653a12defdf6ef60c881d3efb594924f00f43ad39ca00208d50cbcb44438cde4a1597b7076235d293cc39274eb21a98f5b879d914c6d56259ba71fc0a63a5b23a37c435d41766a0e671af781db7c72cbf968c904ab7f53b8ad4c2de616f9d3880643ac2f35943d329c3d018d74a00ff78a42988627a1b1ba365531209a2876d4eb24d0c3422537e2aa3cdcd02063cdda6bb5bdcc7aa66701f072fda6c56dabc1bee0caee625a2491f74b881f6a20bee509307ea5a25d9adf284903d58f4d345d153165309456b7cb00fe409bad9b93a75e30dc06916f01efc04dae078f316e0c9465a9374141a5a64a4310cb02931fb9c57a3d350af41362209fbd1e705a6a766b8c4f7cbc4d12094ff6bdf9ed6351d8e2dc1a335c3c7861364bc7535ba7c2f3171d7d85a82f83e9956fdaea66b72c61f1599982c3f0a651518943ab2c114a8794d5ffe62605987ebc3481fa9556fe5313b1fa1b6a847bd2938c2fd4323dbdea84e6ed1f4c20c734a285bb07499265d7bf805012d57ec2e0a4de98f871595d7f5bfa8a34e587eb772b426c03e94bd172ebb70e1bdf48b2bef996dff831fa26d6a96591914755885ac019967ff67194b887b7aaaeca603becf576c76ffcfde986c38e3cfc38492a4b610a968fecaf7dc34996c3fe79d3d8f6f21bcb574476cf7cb25ecd05b560bfeab7b7b86204c1f9bae1f7782200916cf3e50d09e0f62df8459d4727e777d4eb0785ec21c47e7cfb34ac40f7be12baefb536dabdcb53d182a94bf0da0e1811be686460984b7bbb394144939a823294e5a7ddd74ededfc82ef9fca80ef6f0cb7b8f14e85bddf02c812b24c647ff5670ba0aa69dead18a261f6881e3a9e9bd98498abef2ecc300985d92584a400a1387a83132e2fd9110354fdb9f847f63aa9712b38cddcfb94066bfb79b2bb4beb49a9523274e3289d78d862345b786851b8ba16822089c55c2f9cc1ea4629cae5a425b42b438a3adb43a59df6afe49efddab7ebc6e8896bbd461dd981c45e7038d385f1782150ec4f91600c18714cd9531d51fc5ce98c010ea18eae94420dcae2dc0c40f43db3bc3d7634fd68dcd0a8396e0b161b587620d9c62f251bed18b9548d23858100d1417419b3208214b028100c7241365eeb1d92b7460ff18a062ffc861529b23575e98afcbc2a10af0a1f6e38fe081e8b93d59530b68e7be937a44f923a7e8dc3e8823fd2c2ef081dc37faf77270c12b1f9fe6024b7f5de9f5d1da430fa1206f0a9044ea61be41ee74732f107ccc96f761c1fcd500dd00349df68d3c182c5750a8cc40860f0e793258e03d0f8e31234762a2b4d05b1571f5618d077aea0d7156724c7b4f3ab5ffe8234a7f4141da0e950da82490db3d360933135ce6b96fee1d18c30a8570748ef5d5100119b4efae713a5bcf6e2435992c3ee671e204f19f43049f43f2312d5e1248084d332f630028b4fcab6ae56369847bcdaefd1dd6739274cd31e9938ad3e0e11d59ec18ad6bf2592744b963b8e55880a7e96a89fcdfe0164163c0a53e433112ddca2d496f751800528012eb7e6ab250bb1a05b6d17377b96152942c1ce8803cdb01e2cabc0c1d4b482fe73d2ad770091365168f465a1d1195f316925a41b76b3ecb5564f79a246ca2806c3b8a8f3a4abe1000a5bac2233685c637a5ee039509aca3f3fe6ee546442699c3747233d0eb895583156bfe388b20a4cf98c27821e1276f3bd10aa1032d78580e0f1e866bfdecc5c13f25c8b9b88e4b41eaf037c1e9a285e7c4444d46b5f54d52711075b3cc0f06f5ff063be3c3452366155ccb2f93682dc1761d102b3486ebeacb2d47d0825f15aa5feca5b55a39c787bc18cc47aa2cf95a460e6e4a9201684888d5770bb8ffff16c4815b2a372ebb5a6c662de33ecbe5565a78b22ef2f1cb5447d6f3b0b3c53691adf4e57af33dfbc3a14f20826e0e4ff720d8bdbb4c05600d739d034cb50c956fa651cdfc08d4ce9f6eda55c37457def917dfeb71bea81f790a5a227581ac493cc20208449b772a186010853b733fff5ef713bf7d98a5184e43bbdb2aadd24b234293a143492936e75b98cba8fd5430914408b6e9ffe4a12c5af1b226a216ecc2f74e70516d094333303af2ed6b5517561157adead15db42afa6dfa9bfa21835291eabd954a86061f3877070729f2ec57542649b3c192275289150aacb5b401b1fab71f238ed6a584251b952ee30ad33e75ac885e82df04f3e1a742fa9baf7d9ce1fb75eb86fa5d1480533ab40d5d568f407689f3a3722cbe17cf5fc776304b5b9a1bd82cc09eb67c8910b92337d56273962ec44194d74b01a79edb8dee0c0c438f2e67e181fee98bd5ada306bb3d2ada7f85c17010640068e8d3b9c5633b9e39c7bd1c20594d32cf728ec055f70adc5fb229901b4a414f0522d8f5c4a77bd2d9b1b4fba81007ae84b933a0802246e4060c0c003fad17c23c63ffd02d0cc3994d58c1d13cbabc66521811722a72afabf85b4cf68f6bf9b2b26898c6d6a693a7d869776bc8a1c1c662d1cd95f9f51f78a8c426ba2338ec6333990f4c3e70d2e03f2f317528aaf1062fdccb1826c17b0b5558c94755ab341296a1593ebe58934324b776e85b437900270cce7e6edf3c6a01bdcebb69a86f612c6b2414467481aceabdc10295420026acc1da20ffe83b77c82d593aec779e3ea4801c41be501a6d2d2b265af6fe64d5544e33fad4e2c8e53e60dbaa168d2bcbeaad2d8514dd920f67be74c0174fad494a9f6a62894e79a95cef509c11251973067bebfea6ae8990337c935b697c5e40cdb5f670037a4d1f1256dd9d06463e55b8919504095d482f8e43541010812d62507736afdce7d4ccbfec392c3be0bc77e2aa85833b2b11ebdb768ac3fd09db74b81ac01be2a72b22a71dca14b8a2712c64634ad6f40847f68786fce4bbe6097e3bb5420922bf328096b3f45fbc1ea980ec45a931e6cc56e5561f830d11212a39526a4262a0c9f3b350afda2601bfe5236d8492161685683035fc9a0ac37ffb26995ac400408280206c7510bc4ca7acfee0b0990a131a5b95a3ffb4c0839a3b23f785d7571efe2463a8803a6117bbd216f7826646e296f7cfe5eadadf57e3367af3932c83f3d2e22235b9fee9a4928e74875fb5bc1e159714e91f191810dfc5d13ed3a6a0155c576d860e7204f63185d88d50b5a65bc5cf8e50ab986aac01188beb16d96a6bfb463d9a5d035c5b30a3d3db440b571acbea4fde21ef5a94a804fcd72ba9bcb8d8c5a0d8598d9f669bf51f3cf631b13bea9305e660308db86a663df440cb8b1c9f4874c1d5720ad5747e358eddb0da1861cabc56543fd2c3c305445dbf97e1e4523af81434574485e0827573df1f5931a5d10db7d12cb5ddf4d67d5c294140fa291d91ae5959d632da4067a59e800be931f127767e213a1066322953c7eec9cb8908d31f8e37a5475ed930d5348f7d56591f6bcfcd2aa9079741160d12ddf92a12e82c9d9d808040644c9158b26902c850ac647232ac834ee3317c55a72644ba3c1f3db1b876f925e84fbd66b0727cd450a9a63ebcdbb93dff7be7644bad603e74e0c20d78e89543310a02b7442941da1e794a34d06fa9f5e212b41ea1e3325887840dd7393b8dda36ca51fe7c02ff12cda88618bc9f0b978ac369aaba0090fc037ce2529b70494ce15442fde508b546999b0f8b95cfeb92fdf4810fc2f7851848a71f45e3b1e9b0e4f18d1ddecad280c2ad2bec575e598a77b6c2ea43187d0179c66aa6bfc3c769fdc344c65692e8e1967dcc5ffb466a1d5626cc1741e9a07b33c2e73aa0bd1cecdb90da0d9a0b4997c86fe443ce05d314e9822b6791c888b7cdb9b7c2f60c1982522188d35eb7f4a4c2100e257ea07406756711c1463bdf9e87e6f4b064911ac18567673b6e3dfb5360d79fd1af43f671246fa0df690b1577bee270699cdee7dc58c41f76db22d0902b2c35b7493fd0e61c0539853d02c04732f2de8b8fe813046eeb3f4855167e0ac285ecfe9d90d36fbb41b0025c850b9cfd63f9216198e1dd0da363d8694f3b0437672e26320396d09c57fa89e3cc1a5d0f9c0df4061e6a4df85a5e257776e35c1ed37d08f4b9ee53a9e8ee0e8fc826a8889dbdacb0e0e2662f8431130105def04698c86945ed041f48af021cc62a0e366eb5305405d42c040e29f581510d32be981d617eff8f8a6e3529f65602bd7c7aa7a8ef5d50f78ed33a7cdfe7ce2ec9b57886e8186471edb96dc097af75e8057fc020d848308237110812ce9f48b2129e3f2cf15601b2b130f52f4d37a66ef5a88344abe8fd9d8c80cbe53314c8d19f63d984b29f57a5f5ee6e828859e24092511cb9233d43a314774b513f1232fd57e71f5631a53563ffbc73ca21a1fa59c454f494f99184d01e945ee5b48b1e4da8e8527b6b165b50d819c29a2dc274a842d06112c4ef7742d6f4c3bd4a430a1e0b0cd995384c9b6c7b514c1858f5dc3f2c341d64f947c8369c490362eda8dc0ddf617dac2507faa800dd98a3d185d0c133623800b2fd87cf09b798a76904dd953ee4f48f5b78a42f771e657db98359d6808ccdc1e12b50475dd9785a8b598de2526ffa66503352ad1ceb5cb965ffe66603ed91d25d48260f824689fe1f46fa85951377a32f436c2f3a07c5a66a454d69da134252bfb0482be9818d6a65dd49e2a4f769733a13d32569ee35dfeb53cb478d21bdaad4ef5a60bc91c0ca2ea376222d9c13cd9ec43e542c558cd1192d0f36bfb2bd344fe003abe09e85394422c6680d871a2efd23bb320d35c6fdaad5145239fffdf27b53de2c1be5599880abe643271a0a286ba9a4d893dc6af95d4c514deedd350dfa8b1d1625dd50f67c77d78581ff3631e884c74dab680c7534fcb712c0f6484e5bff4d73d16b6f1b29550adffaa13552ae042ff5fdc10206a900453c4e8a29acfe713d07406fa80f02f14a1e091c80647e977bc3c800d192f5c653940e1d182c181bf46637f0c966cf4da956d92a1d5d8967b8de83be29bd99fa3be2d0830a9de25e6e4b87158c607be25ccd1091aa861277cb9420510e53024dbf196097e95d8c951436d22e52e9301e8bf19cdf7fecc34117faf4b3b880f35ae883055794d624b2abac566135115e9164832c7ee4be9435a35cd2a794e68d654d6a58f475e6e17fd5c82c56992a0581c00c4f697bf30217a2740fef24775b3cbcbff49eb49c2a485cdd35df0c7da817bb6904aa52092c11ba260faa97b5ed5413d6d80cba9ccce3085273be545dfe26036d35c9437c097abb371bdb5c368f6671ac434371c1767a9c8fca40e18e38a468b03667bc1dc116bf1b6dd5ab75d97520409d43c3373d31c49d01054fa881dadbcbb506656fbce7ce1f0f13ad32bbf8efd2e0c9d3b20a2912a589a3d5703a9a0735cf2e6aefc3ce91f22751f899c32616cb7756132e620618ef9c3b4542b7ccd5d33e1fad678388f72b9542855f2509f249df20645a5e4e3802d407ef4af9a48ad94f42a142f13f83c43d9119dd36ac8364857e1d48430634e6641081a017efd84be788a96263355b6987d81e698b56af9cf23c0d04761627e5a6fe7a335b5d04cabec2da551a25d6dd76e73438a8ddd9507b320cf23e13d7789107510c7ebb1994641a953935bcad0219d5b664115bfa4a5e15300933644962102983a1685eeb7777e6894cf55001103fa4a0edc7c401e024eeda971cc8ef099a028a38392542b5ca4e110b24d9db219377a5f016c0e51115ef6ae53bd1e665f88fcac58f2186dc1f89d96480dba99f83ce839ad393c311c735cd2629092e5d7bf2e0c5faf312e8e4c40f396d3378730f8892aef80e0a2495f1e07f6e66384dcb6661b78de12e462485b74ec85e5134f780c00b6648c5670212aa3f1ae43959737bc0b4c22c9a78598e9169d56687205ab643412d8cf086acb43b6c7a2d4e9a38180b1ff9ff4e029985f44eea7bfdff6abdb621e96fdf5c1e954718ba118f401fd9a9f29664843643def1b690310b8b149c779ba52c67ec3f61be339f535b13b178030fbf36945fcebdd22a5056e230b4171c6455b34fcfa915a4f4806d06130603bc8e29582b9b60d04ccac3b391c8b94f147e02b123c670782d7acae376f98fefe41b6386e434b6129cbabfae68e75b2a01e7636598b01b33fa139359acbf61b7a591f44f8b6ae5768d96673b51efc0f9d096815ef99cfc5a122467a6fa7be63a87f664fbd1a6f8a50d63b53d682ab991e7d8f304d45deca3fef1cd93c8ae1b6f220e39764a0d1761f4e176a51c5ea84812ba7e4f3c809df57eae618a7325e92fd49cf029559d39540c039b2480f2aa5d541e83c634def09fb9daa678d69255d9ac5404824ac218d970cdab84a3ab907f74e11fe58aa3d4935633e7578d4dd627d3bdf69bac4628a67bdb6d5b4e749338726538cf2fc4b0f06913525c009e02b7d1c60abd1b1be9ff562378df9d61defd319cfa31b1326cf150427fd076975be40df19280d88f7935ec50233b2428c94c51b255b2bb99aa0231553276aab23c64634b5d633ddf5fb13c9f3044daf6b7bdc5c76572ce2cde322ed11d3115473277f0254911b09d5ccf2e929cb50d9306409a201181e6bb60f0a770c840ed00fb5e6a28dbcc42495827bdec437c1f6ff21cf816173cb81081950e75768fd4392e5c3d4cc4e7945a5518e7f8c34ef50819e917fc561c8ea4d32004dc449ab605c07a300b177974eb749afb46398265c83a75b4275a5c162fecafc467257405f520f47ecbb8902f89f488dbe9cb713ee7ea88887514e7f854740072d83da3422a00afaed943fa0dad5e2f2b05cd4a2287b19d0c17b54966717f3b718fa4be30f0c766ea72fc90f69de71a3c8445a96d769cadf9453abd4dc3bbe0ce65f93135faaf38dc0192db4fdd45aded6fa2a73ec141b541713d7df545dcf02bcd0c9796c3bd276b749b658a1183a64506d738dd0f216a31a3143bb23a9755848291800721ec081c9fa3a66fc7b4997475c8e560a9ca823e65a1a6ed4ace3ccd940846d25c78aec7cfd560388d9715e0dfb254fd042f763775e4c4e31996cd6ac602ed8675384959ab65fd9d1fdc279ab450bd829907efd3c1e9ce8486c58fb75e076647d1c14cb8078c9fc7847f72b2c7870e0decc1264dca9fa39cd45b2d81e8b662919e39efd3714db26550a466f5c8233f7cc44e6bb9aa63f16248418046e2665e8a6f72c60a8571c4b67c750a180ef4b6895dec1cf2b8c3d5791e94937edcd8d76be91eaa1f1c8e21e56e4f3aa7c0dcd02334be8a9e5bd92785d5b8ff1b37d5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
