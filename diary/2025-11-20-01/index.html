<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06016c92c84e9d287b22de87832a18b6c9fc8d97c5770d44728e3696fe17d67cec1ea08e6fbea7e26104ea7bc60cb28519dde2c165db6765f6e7e775e1a1e82371eb8b119a35e92a359355a53b4991edfe2186c7db5e1278946ed8f5353869d77afc39a43243993ba819a08c08ef1c9e912de1e085b2dbaebebd2f00b22c6467e490d76e880c95edb3fca54a21a48e6127598eb539d28272ee6eef2c3036d98e6e47fd2e08068681f18c4493b66b6586e084014d2a9c8a6d78d209a032a661b26697d1a9f5767ce7d617002b4fdfec611da30ddb96e61103b787f843456be5c9c75a5a5355d0d711e120fb9cf7fcdbeac811cf4fd66821b8fb3525d6a98414fdf79516ba09458be146fc9ec32bc8476d7411251dbc1137cd6cea5f19737ecc1c587171d297fe8dd3b79fba234824c8024e9693d066326bd2e2b7fd3b2de5db4d3f8b0159c3804fc91a09342ddfcf63f4692ae347b2e5019b59b69714eaa6a5380ac5e2b7a69d372ceeaaa9bcf359f01455624f81e95d4b7acefaa65a170eaa73f682cfdb5c57fe084a31e714c18f8933abdddb339ddb94ad0b14a296516a41ca3097e91f63edd35c23952778eecebb9794b348e1eb2f04be1b557e70b7dc023eb901b81ee2eca47d147b201502636c280f25d6abe12b550f8aead6c94ac807de6b832c6e6a39532fa1f4e12819a84f4b798798f1859d1f0b6007cd29df07e8982e95cac2206fa896d0f2b44aab60c181a06963f54b8740e9f32c7be4caa93f2a24961636bfc9ca84a72bb020380dbc53ffe6d2d9ee52c3a23b717d76319a07d1907aa011c69e6b2216165bb0829bff62cce93a8d50d40f43ba76f7ac0a582685fa21118f186a11dca8e01b2094c760d89857641808decc1f003791d8a207f3503270383fef0239c92046885a0bd2fc24a58696579e96b54d5832da24618648bc4a5b742dcdad9db7efae977bd5574587488671e5e5a27cda16e273e86dc58d1de26bda420f5bf2636963cd6b16620334d8b156cf80ce7e37bcae3618ee0568a7abf5672cd2648fb4fb88352cccdf3ef1222eae39ea7db7ace807623d98ea757bf00d5517d63db3b5d210dbd3bf5a4b8dedbe7ab2fee3f84db5ec16b01e9a4dd31e5e3cf05cf2dc71821a316ac63b4b06ea0a862c6025951caf9b02abceff9848e50735fb252655a1f67ddc8f35b3f57bdbf6e55391abf3377e7a00b94e781fd1ee1a665d69c3393da55a760e8f4b4dd0e71bb87da65072df841331e83d3926376b9941b2076ad37aa2f75597051c3e324a386e8b6ab095282043001fbfbbd4b5d566a7e28510a9747561c3f426de51eebed74dacbc0819e5f5fbc38b0287c109d0d4087781f2fdb57d4e24c06004a4b2146a834207cf898c52c109600a47e1711a4cba5d596681ff63486f498364b9f157d802296943b854d648909976f2515a28a981cc7c455e16810636706db310f099309133e2692f316aa629df604095f030e20e3d776c9acc8c474eb921d799287aa768cea93abcb0d31a6cc2c5d388077f4a42a54a5154a81527dfb642fe7d56c48ad63b4e6bd30f9a53a0e4861374ef6ae84a85dc3a383798f705a26c26d010abf99cb633c48d160ecca28a6e18d8dbb0944fc2df4df38df8515544aeccd70c28d9beb9fc121288025d0bbd54bf095938fe0f0cd7ff817ff7ca48df8a716ad514a80f6eb138a8feb0494c06f72fb36a165e623430e30671ba90cb993c43916fbf3b7cf4f74dd0385c9deb0b06ba35c32b1957eb494dbff8e7800ae2a44481ed74921847753375f50b86c81060c9d361b6dfa8611339b217dce4459a47a5059ca9befa567526c94755f0ae594efef4f0edd86b3108960a9cf93d723d4d0ae93b561156a78b26ff4f7f1151a35bb1efdc66ce1e943696418effb93f4fc1cb43e578e22383a0456ea60e75425cb2e2daa5ec7646122b59bb9e95cd63fcc1e858711e0d59a4d5547d8d08461c846f593c84f7c661b9a0a25650515da22d319e24cca04792371dd61576b837314876d240b04bad6d887c186365573deca2a4980e392efb22e3f6ac1bb0cdd9a48526e293f8ad7f6d81c293ecf4fbbfc6920de0807ca3cebdf8fe7b50a68446a6065971c9c961701c8953a909a27a7054206ea92f98666f2a9805c2ef12b3a50c07b502409ef565b2f0e15f1ca8d37938f6be8886fbd23b19b34a5a6ab0f99afc30d48509732ecdb0ca21fbfe29f8815ebf53cbdd49cfa9e449b5fb978735574a427453e5010ac51be14f07702a78e6da8b8f969a8a884249bd12bc35b39b590eac7bfdf0e73da3128687bc4524481cb67f676aee5be133054f8c94da23a0f0523dd67a80249795c3de3a45d9b934f926d13c15cfb996a3b917c58c9732de08b3b1b291f5724253304bfaff406a272c3bc7af38bbc7da4f2a4bb2f5ab2391c57821cc87a636303e2798d62d7a931c65ca78961d4b380305665b4e24e355208d48f1528cfdd64ebf4623a08236c1ac16647663e336d14ee70ac16867df08f6fb8c81e4fd4f82f300e52b70fcb5e729137194a1303aac32cbd1645ec60ae91feced8c688f91188403dd6ee3610ec9aae26c37153e7a4cdaa29ba402ac3df0b848e7965a820d50dc99fbffab01a9a346d5a845b5f75b9b6263031a6c6d33afe6466601f5ea89e38b2480131f66fdf86a4b6bf1c42db56fdb16d1d4d397721e4b427c9bc28cff4f20b730ffa4d702de1722bf892a744e482dffc4b1c0c7d59001869533844a3f5985ed17018691715a5e5fd241c3d592113082e89c2a7f21ec11187bba20176bf8427cce68ef9a0ba527f0400fa54bb935f0bfacd8926de767370fc4d89e29e8bd4d91020594dcdf9e59e5c3859479858dd586772bdd4e1ca0ff4dba51e0ab696d3beae50ec701214ad2537ab4c520d169f8f62cffb1a8b0dc7a537400aa7252ae1c8ac26f6232df15665aef7006cf5e605764285a5ff6f129edac9a9539a36d347f10bd285e679e9e53bbdb531fa1e1e660e6b2de0a1c4e4f2dc2b6f6e7803f77890c8246df63e1b28fdd5c135729a3e1f944ec8cb135193732998f35abac0c7e0dc3fbf90f88395152133e483685daa04f8ffebf75159b3cf70ce4b99947fa50cb18502cdddc6f903f2973344b58250aa254b50084dde48b0198f1f6b711eae84d1131849696671bf22486c82b7df5b0802eef19a74ad7ae41b6435c082bd6529bd23d564846790678a4cf82c4306a252224f6d177d76569562fe790b0b62a8f903bca698d54bcab966414af77280b3640734155b276976a64ae13bc4d7549ab5bcb99d36dd306e313d35781e74eef67f7c173bf28b98b538da80e105d3be86d57742a239f9bcf1ea8155b6552df970d269dab9cb9d7ef0ccc5df12a566c15484eca82c49dd31ff05944fb6e40872c385d090c1be8c6928c2de5bb284725f42798b6ed75838fadfa4218de86e6a22d876a383371571fd6c57790ee1f82d6c629b89699caa259041990be89b0e402b2ad2e992c848bce833d8f7dbccd27b5f67a0d76baaab46a50011f49f00ee172451d361d74067cfd7e0b22b1f19dd67c1fc96877de1f752170c24136dc0a98bc9ce49aea065889698e05a45833397d19cbfeae0efc9bb93abcd1e35d453d81aced93e151adb9ca350f62dda673428e319956ec01f56ad78b97bda26aba47e69196392ffcc1e8f95e487ae4f28a594d227bbd3ce94de5bfd73ce7cafe42e0eb5667edda492d87358799cc7f46dcd1ac58f1cc69b367a8ea8e19c5a5b9358df3de61cf126698ae081d0f905823a3b9bf62bbfd04bd07425d6b816a2468fb887f68218a58acf3fed6015b5269b87550110dd14448e6bff151020c4143e3b1ed2ed400589e409dd6ebac6264878cc0647d4f448b7b37a2d1aa1f6d478b8fdcd982a90507ad0ca7de54b2b0a828a0b55c0b9b1749c8dae36314b177d008f1cd378150d1401e35a8bc6095a93be0994b5b129b8211e951451db84b4945879e62b254eed732b84823bf9fc4c05224430729f94f942c976233bd8d349829ec3b91b87b56394d6c7ef84daa53a989ba1abe87b6c3301b34df7b7c44ea9e4171b20679614e551106d9051fae0c368088723099475d8dab4a45a870c156669f28ec30a2a50e5a915315ed9c39e62b03b5255531a9ac74037ef576f943b54bd6c17a58015dd432e5a7c46348181291e52f11d7cbd45563329302a8de9c2cffbfb6ec66edd7e6cdb364ad3faa9519cb23894372f47fdb14351e49b9be162b6c5a1a431bff952cd1bacbe644668c845c4f47adfe45d91661e447754705e02bb5ede0f85ec843ce009b87a4fe7833e2b450688737987ee57f35545d2e499838269522ce0b2c8587627d2c5472a26cd9be866784b5d2aae391744e131071297348f8624350c2f55d203872eab25e5bcfe0e2201d94d49ad75b3a9aee3eedcfa71e8600af34a1e1c346d078723d2ea6327cb375ea28af3512fd339de4c9076dab6d3be8ebe287f672004050cc1a3d5d87ddbff841ca4b048842cc53fa3d92aad4fec1a0b7236f829dec0c2be0c15520bbc4c65b8ff324a55db1195cb4d77ac2d826d6ba87869af19a23ca4db2a93bb4694623dfd3d2f10b81467d4fccfa51b511a2f7fb3cc2c15cde1cbc443b064261413bcba9c0cf61bdd2736e4e2791f5465c923e75a7eb7d5acba9ce7d49fa8359fb5f0a7d1d626bfd0d3a3aa5d3842f8040816c4e0bccff9c836d262ba6c5bea39bcc696e9672654d602b3dca123747ae847020cc8860a6b4f6dee247e874e05b2f55042fc88264a744771271c9f438761860714b1e0e637e6dd00369779daae968ddb7a21dd4d3dbabf674ca2076b8607683f7c0664cc808b39f5793f3e9fddc2674162c7445b7d37283a83a2e6167d5d99da847bdb9df333a0c609b64a99fdf94e7a973de88e03b25ea9ee4f70c2070f4b67d97eb2d0eb51413ce743b620c4c55a9232b483dabcb6374d8b17390cab572ad8ebbe48f92e52318c1184c92d5a31fd0f7c5fa456c98b4735d081f9d31f9756f289a88581b4d1781120c4908887d9b50c435f5a4d6b099d6cdf473179ecdb2158810518263372a46002d29c085a146954bed97500f4ff07141221dcad31545776975d87e53073dcdac856ef57a56847e27a75783863e6351a36e023d226bf7127cbcb7800cdbbb88116112e67bacc0a5dd411d5ad9a220c7b980c6aa4ec542faf0d2f03134dd625ce44c17ce6299862a3749be0ca745a94475320175ea28b50d373094e4f5cf744f6753f499dcc9f9ec69c2bd253e51ddadcbcda7d59c6573fdd88e42bf9dcf10e24dd252c6f537a41c90f5b3572a6efaf80226d9df847af81999aed11b090527fb88b347da44d329ad3a5491437a1cfeb507e8faf8e7c911b4276b070d1a129c5b914a594a15267e54a0c8991c8b591a9a74c5bd2cf6f7dd9fec7b46445c3a7c2c225f0b71e7caed20eda7bbe32925ea0482a3a2b0eb201384d11619a4a559fea2b4efb813a87cdddd4dc5726a4829538aea759c69bec6aaacf7ac154056058c3bcf9d7d51e784ed075079e0bded4f72334f34ec9d801f7ad6ded6a3999eb14ecf81c8b4e5202df933f1fd130f65542074623183a48ec368f65208321f54ee881bf0fefa7fb84bb3d48d961640889d44e2dd7441e1ad74700394afcd8783d719b0e95514983442ea18d3bbf49815a1753f399b1b0c1eeb4ad541c2c76d88f3d6ae0dce46fe4f8c7b9f957df3663ecb7fe7b4ffe7a15409af5ce27921c9bf1d7f2b4aa60217d30e789489e87ef9493424e8c559afeb68085857a0eabf9bace9dede89b0cb33cf6328998d4fb016fe8f026481a8596ac0deaa5be6eac2052ae1d75e032433e95d7e472e8493e8f6b8f86c4f9fcd32d2e19dab417b9cfb64d05782fc347af1d39d3dd5b93c73c001546b047e4768ee24f81afe8e731797934cfb315e639c0934ed864d5cf5c2c774e00876662296dabec54ed8070979bc0ef372a56bcaa59f7da2fa74e1d0f67527297a844097ebf3e1a85c4790f12930b62d95bede7b31634f15e87b48b6a718870e0892f3147e68e988dd497f26f73b057da10656e12dbbf434215fa894621063d601a993ab668aedbafe1d0c193623d35a544a116e61e36522344e7dce52e4e30f4641b610eadd6e87de933548c314c1373698c4391dcebc56e0905fccf812a9a4d00e107e4b3306372cf0a163fb3918608f8ea2a592360acbe6740613f1bcf169dfc117c5d5cbc6884ec1967796e71ea0d814a8839056bc8520ab58405bd2e40e0a71e63c4e093004ee1c07dc071a1b90085fc5bf6bb2016f5eb5428bb3c1b00ca65f0c77e707abad1ed1d8a807bdb7140ab69ed46d1c7362b28466735464d85946fb6fd3b094677ee75daea18af2f9a4b1e58835338349f0aa41ce1a2205bb210617ebef27386c68bf93ca0e4f8071cf66d5ba509d41ed1c0869c1d6c03576ebc85883bee996214fe83e5d457faf004b9d1ee93fbe594115d4793938bcce680da0132d3fb05a6413025c12c3c8675bf3ced43258e2142497bad46220c4028fc9ef9bcdf14092805d1af91fc0606f24d21a7c8bd465e69e43f9e1513f1bf8636147cdda89b9f90b20241dcae054894216a8cabcd86a439a330efce0a7602c775fc776a9e98b15799a829170342d3786cc0bb98181a892de052d79fcc5989b67f5ac6600d3a63be85cadf54d2cbc7c85ec0e21a7f8f9b27508034696f57d440c3e44cb7ee995270044ab3d1ce477ff014499e3398b0206ae00737a7c749e4ab4dfbf43b8b17a36b2557866661bf8cd0167df509acff9aef89c8a213e77facf378963b4d1ed0781806c7519028436fa3a401a4e2fd725a77491c06e89c99afa9778341a9b9c42ce4823c3bc3ed8e5d6bbc422a0a4b4a920ca714830a6bbe5091f07757ff078d8a37d5ecd7443bddf8d197d06c60613fa90e99da98a4defc5906d1c7cb23658c5deb66d472e59bdb73ba6c4ff5cabc6081dd7af606138df7ab66ead10a39256b39cfdb793f2a8e5f71741e4b439685288ef5a97f9c9f46e36b56e62be9a917755b5c53ed6ef818215e4c9151ff60c60df7a10076e6837b850e3b1b761b52f0d134afce5bb5cf337b7c5203e6cd5726ecbde46fbd990cc8850452f6455c4657f808a43fc7bab880d5334a991ff100c602368546fc33b3ede22bd486e956a3fe7745433483a30b744ad55a746f9c6483efe1419e5dd32889dc392fa388b6117c49217e10197d726e3e8c382f360854b56788a4335b6b593b6adf945cda2068cd58223db96888599eaabbe6ec468921bb810625232faa21c0f443001a82e0fbbed16c386db1d7d5fc31cc17549caef16f5c7aa58d5442aafe4824b2c9f4b6b851021d03f1043c5cfad3d66db065821cf4d928e3ba5176702e0addc89c23e8c8f65ed9c068eec2fd80f23738a8dcf3941ff48a70eff501b1090037fe06e650a8384e8bd6317508f6697c678f0dc0d9053b1fcb8d42a8d059bc8febb1e655c9b01a2f92154a19c66cc11a0c2a9d9e2215b0e17100f0ad024c064e9a23331a507eed0b4ed621cca5cd0e19ed7be335ce77c3abfe5e4f0e9585c22fc226821ccc3e30bf3c6efc3b46ef075b3cf9ffbf74a5040ab2ac89d6f3786321fd91714651d8b17f4a03932abde87e71334759c2b4d16f8fb784353e237c298ea3f718457a655c802acbc49b7d2728f8821ee70edd6a95b7cbeda37ad93170fad21a9df7c2f9453f22a856778f6d371c6340a1dd80f836a2786cb3efc364d117f3d86044858d9a61f34cb82b51ae48363aa73ae13006a1ee5c228ce5df24928ada2536288f7e4a6dd7632eae22fc0897c1c4381efe271d0422b605113580a2f8b861a98c807fdd53a32d46b8cc0eff95a791c025db9db86a38d43e7d26b3878c8bc410455b53def183cffc6a0b2c6522e9cf71ec96706e6a6bbbc2de57a8ac46957827eca50eb0dc187ff7b12bf25a6a3d1b8d8950e7006b7aa4528eedfede9fb49bd65bd6d4bf98cbe179c443f6272fed6cfaebc191cf3960e4948566197fe745854e2605913b4217216d04d562110d61f617a704cde442f40eec3967ebad377bc8e73bbab909241856edace1b468ac06736ab95e6199f2eae4b647c8b23d07a47b6a5b9a7be1297f2bfd43701273fb1a5819b973fc1180aab1de04cd211c357cb2ea3119fafd81817d303b14318a1cb3a1300fe31d79a06c3102d6083469cd07a80800da6e57db4f418afd77b5f7f1da25faa93c53aacc5d59e80c2fe6179c800ed114fd147e33f20326aeada7b95cad5d2ba8cedfe4bd7908979043cf98753fa71beeefb26f10364b818ce9020ba0af75d9f5a3c1775ed86ccd7c71670ae9f356dac0b5c4e9d2d3c090f1fe5e249da1c50b20acea2f2511fca931729e1732fc6f173b5ee38562ed10627c415dddef807f877f9350843c1b36e8381ea22e65b9b77304d625530add7cd802bf65a789fdd1c1b5f305246e375bdc5382da700ce9c9c022e9ea64ce024b1e079ff992e6605a2323136ec3265a9b76e738fbb58f76b8abe77d304afecae41a74eb4ee73bf5c2ef872f8ee00d78734098ff14a2448d7db24ee517236a5eb79aa07b6f0f3735c2b91d73b564f8cd54b5fad971eb23ec2651ded36166a35659ef31621d816d73d8e435b9a177db26c496961af2c86ab391232ec05dbb72cfe1221c4035b75244e7c9d9475a6a845dfb84d08f1ceb63435de66cfa246fa0f1c7589e38660862e591c4a116df2b5900b5102bf4f0be45865c5a40340176525f3407bd02e8d89a31117c557e2486d409a57bc7329361096d0fb3b045f194c1401e8f1588805e96343f4cf8194502ecd5076fb316e1fb32835f4c13cc36ab733d2f6ea7cf7ecee5dadcfefd8ebdef61d0ce6727692b5d4969a9811dcaae0eb7686741875aebe7d1d44b116c9530578d66d859ea325bfd6d5fe565ae3b7040d0eb6efe445ef2b88af5c77197d0642c168f2f18bf8f09c559a855a40a5a5508baea0c5bc26a2c6eeb712c275bc34db7d7ae277029e12a9ab412e964de579d7ada4449a035c20bd8cbb2a09ee3dda34a57a3100607a053b9b4f38abc35a9f2e14beda01c1e0921168b9e6db5230c0b75068982f5876a494b7db9800d894e11c7b10bbc4b5782aa751c8ed7f02ad2ac4ba2a1f72d554284e118434a50115e6f64018d1cb2ce49e9fcb8d7645ef8691a86c693d43b8024424e4b7b2d93552e1a9f00f7eef7a0590aafe4c2d269357a42009a4024fdf9e4c0da95de36a0096eb6d176d48e2aee0c89381802e5487740c5de39db6178ecd2ba2a07c28cd6a45aea33b07fd98970bf8761ec29cbddbd474f4e160574eabc6c73a9f47bebf62d3809c5ba23543abd5123f3330e7398cf3e4f098630256f7778ccf53a0441411b1eee4c6bc784439a2de06ece8bb87960189748d148c619bacba993ad75bbb217103979268ed8b7fc31d8b31952c6094818df29005161dd45f1ebf075ee4cdb13510bb30440120a7ebaadf5716a76d2ee17db22e6c2fbf187c0988f6594554fd6bd2a53d95a59f1b3255773334a2da38dae3a5ea0b1ac2860e046a47daaf8ad9fd1791bd785367a761f446e4c9eeef6228924b8b0df779c9c69d22f07a8a45d801526bfdf0ba9bb234685ad837bbdd9e6f010ebfa33f171698ea978deb3b2d8b42deb896fdcd59eb728ad465033e8f1ca2a5772acb04393fd4af55f4d2fb033633ef11afddd0c784496f5020c12e73d446e4c267677f2572a486eb87036f3ca65bb8039d7b5ec6478372147ba6e2f24b666e26a2c10c2dfb7623eda48603bae608ab478a8ff046a91341508fbf92614851559fb7adb385ff2713c9e24a4522418eca9ae1ec035fc17ca57e48283c4d6322aea54484bb963d1bd0762d94967e474aea7c2fcdfa2e2b4a23418ba5c15d9dc8238da7b81dec3496bb5a341475b61390ad5524a3230c79e2cca2cf80341488211e5b14daf652d8c67a374b5d54ac1efa4cda9fb072eeba34f91c86f31817516cf53851ae453207aa3e85c54a7e5fa83372ea8ca48e835c3b6044b95a6cea467df77677847e8785528ff5629133cf52fd58b71de59e7eef126c50c1d5eccaa005e59f80cb376f2eb06fb5885901b1ed4647cf2810b89e6cc6aa20af9f9dc5245089662d781b48813621770a058af90ef3557d7df37d2e75591c38a4106f40bf520b407d4aa34289845633e164ba5501eea6ada8e9300b7d04bed45a6978374b9a23bbecd5412608be988c268f188cc9d10405c2a392b403034f3f07d7576f5a179be5ac19d20288746bbbb3cbbb11b7db58cd8fd36f4698a2ab4e7ce7609115a9a7b502f32727f2d59df4fdaa2c957e5b59b2181980ec6c0ffd93613b3e64ca6d7e20e3eea13d90d31d7bcf1fe116551f891859ba43cc03d7ef8966f4820ae5c60fd971ce713aaa6790ca01695d658386732885d0f625ecc51ef8f5421d9e70faf8f50e9d111c29fe3258e4a959888a77cb5bf74b1cdfbcb0894069d24d6f8adb01881d7974cf927132e9a94ad1c7a7647d8e087a3009e8bb785f1667c4548e42eb932763a89197fe9e11c8d8902fec368a88b4d9c5530d4b0604a95429b6df191e6d8d3484187bce56176cffe35db841ad17472d98c8c2545120ba5425ffed64cfadfa000811db549f093af968bcba46a13ec363cb50cb406c14b513bdc6e8a097d208eee2e0319f141b9fd3e4a7b94be586fb5973ad89d9bfdbefd58f3fc2f3e137d9fddcaa8e8a09d4ad75e1967202f8c24bece16c2cfefb26d569164fe293e471322134b9ce12fb3296cf984936cfe460969db98d3ca96ef7d992958e329aeabddc5bffd8e691539bb41cfc95a3c0fce053bcb6ab12f9cf099d162ac86a68fc5bcc3b37b97fe0b65afa5208e5e860fc2febe76c0abae3395f811ebf49986bbea150ab18cfb37686f1a1ecb9b5e7f188d6d101d4593be873e7995ad32a54aa2542ad190d02298181f6248da6da7b9331c03a42c6ba7e7ac51f2105c8435e530662803112d8be04231b4169cd413185ed94b568905a822925bc78989e49798bccba6de15b577fa5f2b94fab486495fe0bb62e3c46cb13a18f4e11dcfd7c80c9b7a14edfb00df26a8a83af84fd384d112749aab43fe4d7af79fbc388c2ba65731e7e2e08aadf701958e7b449a09794f521b2f4567db6a9c3d590567c5e6b2e536e222e52f1179c3ec92012d9a5e3246ddb5963615780506158195f2fb156416860cfcf4eb31b10c955a6672cc4ae24f5ee37d2d85dd3bdc2c37458ede0ef0f0855dcdc49fa15e490b163865e99f317fb064b8ac838528f097efa892697869fbfaeb0c7edc8c702ea2baf1eee3a2c6d1d57bd1eb2089c079148308b726f9c9efb71481bf0f742ba6fd4e0939707152a9a4cd8f88b2ca0a95bc94f5b6bde627281a9b31019bf3ea35e8ae9168cc6e4871b06535319505eeece1d22f4bdb7de676d40c4bb5c989560e2d6a060a3095a0db38d31af4f128b71ab3daff4eae33b7ba65bebc3fab8c34f1a5deef7b0d2f62940dcab4a5e551634ef1947641720f57e955f5dbe7497ed914721d356201b7156b60d1e8144f801f73621be30635b912249a39b66c549c4eeadc8091875b703e4852541aacc3561c17349a55fbeb39da04fcde348cc19fa2fca97664d6690c09b798d46d3cfd4130dcf65562a586adab153f9b6bd5c978161af493ac4eda530c3f71514d3ca6c741014382b62073e87fc4d68a736760664c6867e0e1166f2b1e4e30924cbcdc392f6f477bfc3bb4fa7a07ecd8fddd63a9523340c82e5beac80b6eda5e3dafb2f010291451840bb1d5148daf5c4a90d39b4d6b2e1200f57565ee8024200f2e7f5dd5f7bfe0552b72b2a4943b427da9d2aa9fd4274f65c0b2403624d714205b31e2d763d5c20719054e63d44121cbebb964375b9949c780c9365ece64a60d6f40d0dfad157fbbcb0336c5b4792e5e093e141e3df685beee834dbb75d1df51544d519ec38a6e0026c23d71f4d733da1f4b18311e8527c08de8da04a15d05577c3fa632b1443c88ccca5a5a3e5ccd21aa5ef2278c2fe79e033ca574488bba9c4e2877b890c13acff46bb3623a8450a45ab6f7770910abf6677da5236976fa224c8eb0175c098ae027c2ab4baa275065bfbe368ac0aa34e30f9a5f2e8654208ae39553abf56bdf756a13332fa2b2fabae92311d1b83791b1b9fabdbf0aca579914967b41ebf79c223d383775b55a595ffb67731317f7e46aae698ab42bfb739461aeabd49d6768ba29f86422df2dd99c7450d3a67d14a8801fce0ac341528d9973c0a5d40dfa952d849c8b4935833c698dda61b674da20901739a6103d7f1eed4592359781b18a179359dc8befb4192ecc24dd95e1b7fd521bafe4a7b3493df990206ddfe197434e292056fb2ec89f41caa989aeb56ce817743641d0f16bf6d814118baa2f3de659787a2e835da688e0c9927e273a456e3a579aae4dc4b175cfde3796429f1e741250ba96ddb206753c2aaf2d7e4d6d34e3a42fcba68bdc21b0e9a763f591fab82b15d2953ac9422b27ead03a19e430a9fdb12e632d8095b7e4070b7398d50074d58fd4bbce5a99a2b2ce24183bcfafbe7a5db6efe8d92a02a983adbcc2c15c900808dc272c7a1002b77a508846646eab9417614e65bf284024b5668a1ed8ff31d0a72eb8e6aee6b697619b6a297d6cd3fe3cb6cb13c7139c670e651910aac7953612d9f21b34a09632618d88d815e9d3594e12f88d275ea4363b0f0058804bb7df9352c1d88db3ae0cd520bb26ccf820d5be8a6c08a883e369371afb7091d50cfe54bf2bcf217175ff145ced44c64337e6d933ecfe463915edd16d29dfaa826609ab19c5e595d95644c14fab04cd7bb1510f042ecb179fedf1810df6209639cfde40c6d2e3491d35454b58012d22f1ca0f26f048c5f171f9fe5154449c7eae6f54da1dfa17bed76fec98c7a67ed4601ed065c7340c716abce1152b5520b5333bc5656f8c08533fa2440502dd904ec0ad2e627434976f66a9d93182d650174ec4c7493853ffa73dd4582443e4d6724ea280f5e4f582e87a749603018cdea17271980710e94868d3fd294b3cdc5c31c59356414d2166ba08b40cd20b889d45a56a8ef8dbdd91d81d705fb44606ab4d7949d58f665f06144821cd6b8a9b5e366cd938bdfa1ae43e870bc8b21bc91881c640c6d7ccd441f02255990e9bf2bdc50a9f59f4e952bebabe3d4927acb3bf8724c4482024d27f33215d75fc66e697fdfb6695d2e4ff2677d32c6c597b714cd8dc6a59d3666c718761fec8fba2bf19a351946d2926dbca40c9e290d58591e1e40b9a87dc692ed7724c0bf224cad000f2f161c80b9e84e6f8f6379a9679f334fb48b310be811dfed494a6c832d249ca41b2a0c09f3bb6b04b69bcd597a2ec5a6d7f763a23efb312c551abd483304b8a6f26f7507c3075dfec956fe74335265e5b35da69335ea3e474abc1f2e789533e24d63d07b2d3fcba6827cbb9147605de14497c351cb21115e72cbf6bbe6fe9b0b9813837bddd3c26ac2f72888106c9f4e9bfc7092c4a36214068e486254a91d5a606f8ce4acf019569738bcdbfd69bb3ea29a8e176002419f8a262170ce9e940d78139d6cfebf67b86950e8de6fcc611edf2b283a2bd392b6a606a2e74040e6e62bd11536208d9051c9366b505af561c131f294162ce1f0fb2363e6977337668984bff9595a718c110d17468eabb8298044e4fdacf40750e2a9d35980d2f796b42aa2572518d9890882a900751788844d7d0dbdfdd0ae44b62ab645eb257e7446f4e840254b71e4989299290300cb71b3eef62a8bd0d3f60114a08878836dd4b07ce525a55cf9cb54c70d904c42ba22459857e67a31ea14628b21ebf052c445b5742a9205f5fc708f18f27407b9efa066327b5ea0f2ab039c686275211814feebce7747cb6b7d4d0c55a767480b71d2207064632905fcae3244589a061f490632859b60903424146cf3e567b5d77e468903f88114a55ac923fc58917e92c3006b0b8f61fdb259d76b1099a2ef9ce22db8018386ca19fe4b8c6d6742d4bf0cbc398519ee8e7412971350d5cd926cc1e57db6e1e2aa6f5a25cb74a912a9839860ff3e92c55e3153a433bb98629f4b9a899ca3e7fc621ce21c4745d46e1acd8e1132cffa5f6e41d8083c96c4d2b852f2fd236551712e12ff4de42f5cdc02df9f7e6c30ead950de33ccc527523d6171489d9f3b34d435187a1062de8f1a01a4c636d1cf5ea91f03142c0b218f752387500cabf4ddc8bfb3e0a1bd9729f555bfea7f94a89df2eea41443f2c790495c8c091efa08df069ecaad0c30bbb122b029512a850dff9e0e57825cd90b369dd4b2e1ddb947ed4f31ce8b793829f146e8cedae0c17d50d570502e219ef77581eba348c021e01eb8313712daab16d60dffeff6a594bb809d433de6fe29d2a1de6dc62cc7690f7d724d3f9c11c1b9adf4ea01693abe3ff3034d866d28fc9229085fd64ed86a087cf123b9014c3a29377c0b29bccbb801c4a6460b754662602a6b00ab38fdd85c2aef98dc2e944fc32a68aafea0fe98299a943fc4b2712fd54ea1b9617e2a4a6ab8fa9b317fa55516730016cd936812ee6f2a07fd70a8458c67d8fb46667275d0a197677dbf2afa6943ab5052d09a554027b2f7f580fa4bd3535fe3e969688d50aa08f95ab6aac13e367bb65e2b0a1a5b04aeaeb675f7e2ce4f92eebd191554234e4ccda1b3363c2efc18862a974f9615e89b1e5a7d18d51cc25f019ec263caa13d3d0a8b90261e118ff9ccb3ffad644a04a78043c6282a90e58be4561284b5ed0a176d9effc8e35ef80693dc9c00190c38e33110829d9d1d8c4cacd0b3a5394ed9028893c3410a5d26acc10722b719c223b7b6caeb290b67406c8eda9d0df7569e41a863f3b9de18c80a5df5b89c08126df81db8443270d7ab11491b1a547c64ea036552fc5bf718ee1473174c96fe2098e5dfeb1bcbff1fe1096560c46d6a348b88c35acd8b117f37aad743e3307d2dbc31a4d14b1bce01037e93ce7437bf60cb3e3df3cf51877d24887fb5ecbffc2c014c661fd19ec63546dbb6acdd63311c9045d818c33f3f39977910aaebd61f7ad96b7b7a955206d707002980bf66b3520af278d14f2bd9e9a4d0e1f9eba8effadf7b87c26a94af59cb2e5db4bb18ad15c4d5238f8f49d00f7447b6ea7ef10203675cd5e13d91fae8555222f4ff01044efb4ae67817bca1373d30a93e648a4704607535b1461de24bff6f248d192540806ab874813e62827cdfccbc2a7fb28fe15edcf6903e0cc0509452a600caaed73274fae4f49e9b94b0d0ab5d0a7cf5eee3b2ae1ff70f0719e9d3fa6accd2083481c7cffee8efafa4b1061b9e973bf023924849059a152c2cf3b0f4745e8615c21f8793e07644e24e5133955e06c4ed135691387e2383fc2fe65952425448f7fe078bf78c6ad115c5c90d59cec7afc4522f29f1c0a4b2e88cd66516bd9aa66c414cb11bff02c6a13bf45175791961fd726988f430e05c3ec694c0c9145ff158629fb98f047beec6ea411ab1cb78726a811e3c1e483141b793a3a10e15cdf0dd52d708f38aa2ad0a6bbadc56b24440a0167a23022e48fc4af2eb927fc48eb825aa91b864bf5ad3e11f58fa0d475b55463f37517013134775618de7705bc226e2960216d7d3dcd073025f251b52e87328cd54e784a1f3611d035f57a5c5b30ece7e32bdfcf8533f66847d6d830c30094f9345a9cb3edaa51a2ef8a18302283de0b2db9c690fbf628d6e1fa50dd40801d0d08623cf71be14a1f199b5e6bee057472f79b72573228f8d3849e4e260d2ea2a2d2fc545b673c49b05d534e0da4644ac30073cfa3c3018a0913b81a6d5ae6885c9af94705b17a3e9c826d0921e95a294362055f9cf67b071c6a9ef46a1908de98cab74e924966ba6e179269e3bd069ab02c000bb0c85729566547c218be1856b2ba9d15d3cb6964e22e656d743ddba2a5789ff7a5d145b1e2d846f36cf86402a716054cc859e841e9f78592d22ee41ef9cad4d168ed58ed6d477b3b0da0ad700a1b283d3297ed25d61e4dcdfcd4188a6fc60518e25bb2011d8cbb68bb94ef46d5ee41e9843f3dafa90ef3dae7eb91ede77a46fb60d6df3a5e5f23c9666a05105ceeb97700b99e8c27f76364829c03dd74a2703b9656ad7b643dbb1f60df5b19b45c4eeb1183383f662c5ec5f372aa9aa8feaff68ca5ba263f3e2489fdd40c437bcf9f41e1dec0facec1bc67a7c386fd1632fc256cbc6777238b884c55a7cfb1bd8cc51ca26eadb2657ce68bcd8604bc0a9c4e1635fa4ff4bed5084a174788b0fbd80526da39a047697e68aa4abce5b51ddef2dbda9dbdcdad357b6ea2f43023e8dbad70445d4dcf29f2d8018662cc9dfcd05296f9be2df0bb4d623cf1d61c6cbb5247081ff03d1478aa2a48d66b33c283c3dd5a54dc98e3268ab3e623c8b50730e1bded1503d52be55bcc808125b81e95ed26397ae793926d527eb405165577a0060b15b96358cacb36595e04c278ff278edb032987196d4d91dfac4ccb1693bc53965adfeb8c6d55d21f74724c3837b7a6418a08501eb2a03f09a0895b95e00298869b6c7bbfe808689f1a7c8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
