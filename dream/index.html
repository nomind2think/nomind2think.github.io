<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6812005a197e670d8e49cdcec8b68ec7c68efb3832ad11d9960e9bf57dacdb06ce3a857e3cb643f3c7637811e48efd59d0c4821aa9f95ae569c47108fe313e51c6845281052f7456e9114a7a2bdec5206c569a8230ebac820fca73ecce306ba994ec6c36354d978d6f61fac3a8d0e6cb0ad26ffbf155890b715c401e84d7449a1e918fde46ee46d28e05898d49e511d0d2700e5d20e1015fe7f2558cb8fb909a8df5d3c21094bd3b27abd914774c2c727e18a8ffa34e86c67a71075d127e8151598994f966758683be9e799361426fcacef14125eb444c5570409f938d030fb4483ba8d117e1623449330a9e8a5a6c1f86b88e1fe108e9028ca5cf2a3175d3861037e30a6e9401fe1c5ca4049a61d47a0be944e429813c1ab10e7e54de0f4ae2ab7704992a3aa4aec853686be23cf5b56aa351b50e5f92c4f283c03717ddfa3e12c6457efe6ad426fc9fe1ae913166400bb896f1c42b88c1dcf167ec3c14e97814db88ef2b7ed7629654ffdd662f0b6c037453270c71b84fa87ff1feb93f6296af9282fbdf2e75fa9c11d65048145704b6b329c634eb3dcc4defb1256099b3916f37a459e5875d4be8fc12ddb610e448af236f4a57e65c1c6c9cc4e1c860329fc10aab5773d88becea8b601cc3d3535be2e36cc94a3cab5399e4762c5ff5117b8ca9fda490e1e3dfd32baa299391f2be45f0d4e4fcbc7f366bad460c61f2956649dd912c353fb4562c30a7dd141b2c16ce89c859657a161183334bcb2f753ab4cd4169b9c01b4db5f83b8232921174827e5c2d4985eb26a5685b39efb0a06b160e74b0b8243e747abcd37ae43cf74d7b457791f5c8c5f12b83a568b5389b6677208df76427e66e8da42a2a10b8d26748ad876c42736247a758231f8aa6b83a907fe7ebcdb3a1d8b6b8c3c604891cb82611f8bd494da135202dc4f1277d637ba0a01bd5e22a5da0ae95747a1318921699ce32837933f9d3bde0935da25a3a28d68e07ef85316234fca6bdc279ffa8ec9629b399a14254112e02a66df7d1fa72005576c3cf33966e00c78a7999f1a84ea3288bdf9a8f76b80c3bfc34d647bbfd6ed0c123b0c353452faf714dc05d1acdfb1f9f7a343f40edfd59bfc4908b0a8c0113faa7a27e9da224e8f3de5c68eda49c33a1e9393630ccff4f090f196b4786282a20f81132bad357f8223b6f3adda15cefc5cc0ea84efd324cf6d5bc068cf798a8c25b91bb9a61d134c530e372453344df6afe35bd97a6d0393182bf6c3d9ed9f83df430c0bc4c46f787398a16dce2d810e87ae3165bd2f95e6179db268f956b5607cc7d918d1c15b6548a3259ea6b221db72c45019eba3298e3463c9cc04b24d8cc5f72f0a9288cc80c532ce7d69441953e60460b9e050e44325acecff96eea2ff20e87b8106a5244ea6a5484150c0a9dd7352e1e30995a8d60f753de08d5b8a186924cf22e30dc61f76827441db6d016c9f599dba4835fcc90319c7bd9763ba9e9907bdd5bf27c76eecddea5b0fd1c02d8d3dc78773907d5e74fdd6d82b39cf636c7beab5d8c2dc33a48e4e4d38eab206b640b29a1c2a3e88249d8558ccde5b6cd1f23333f3e1be284a474cc704400a22532f2b8b87aeebc518e20380d72c54fb2b37d37a0556b6e026041ddbbb113677dfd6aeedf3f0aea511272565f28d10a4d4a9d82738d390841bcc71d9bbdec391f7eca518f9b8c3494df9cab48edc67bdcae7551e9f3483ac53492ae5a239b39cc02800f58a795af24bd22cd9b778518427001ec99421ee94c3f50d9729f2653c50358d5cf6dfec1273e916f07615b328fa28d7d8e91fbcb58db54c7755705aa5997121a5e881de65529afbba8de5e5943c428e704f7642a9de3ecb6bac1cd082dc7a68e893d17862e7c3f45d429ad39d2323481a9ed26dfa0a3edd62caae54b036ffc382ab3f5d71d5e5851153726c8196cf0378453a709fd21a3499a8b419e1ac07ae4655ce31c3613690bfaa534ae5d951b34d415425f7f161455dedd2da5dcea3ab61e02c1e900f98d3e9d727fe6c46e9f99b3d476bfe69186c9ac3f696e1f11598951f049292fd055d36293e221ec61e301e6a1a122fd90ff81983814d3e4861a90c36780ee72a121611e073dbc1df0c1fb4bef3c12765da675aeeef23e09b65a58336abb29d9353159adc519766eb9eb16d62b137a7f3c6f62ad1d63b78cac6a62b90076d36cc262f0a8b8bc12c1fca4c97af218d783f0ea3793e6fc9cd1be63e8c1295f6d1d721a72568a843b74339b5c8c50297cf4ededc955f1f207a0bfbb1de6c5cf3d61418ab81b76c78b2835c4675a840f842cf55d7d838ae424a1bcba36779a98232ff6c6fc41e1c73273116dd80c88e487b12d792f13cc4fd5426d62af054dad4f18475fe4d1e96ace2e102bf20582f1d487f06b436d03792f90e01c6c550cc6ccc4c3c4d524cd26ae826d855e48665f480adf806765b66b1fc6160fdff51005e5d4bfc7e598b6b11e25b866a9903e72930cd37c46f159e2cfa348054c3aa8faca4ae260ab4235866b4a6db50f14bbf19d13dd3b6fb69d95bdc948de84f03ebedc20c9fc58cf999b0a2b4e8d0171fe4f6efd447f255b6f77ddfc367660bd3398341f1b14e85b8e7b6813f0a30bb82d5b695ca0419d077a26f8f338d8699aa41489e5466231aecce766c4e5137ba9c316fc15dc8255022b6c9304141914258b37474573208ea2dbc06bfb69333dcea83c51d44cbfe71658d51a94c5b3bdc585508dc3721a5dc5c0c2eaa73c36f50638fc0294599897a23abefa04e7791fa299b12cd55ce67db10b57338cf40f52108d523691dd443a71ba364aed830520aa4f71030b34aec03cfbf2f4a3f33d2a87dc8581d3c2efd215910ff7fef3c6e4e687adfb9626f87aa6f7dbd4a24343b6926192b26de5b4d5c7553c37bbf9fea353643017156ec914e25bc474487cfb8f4eebffeaa130f3ff363174a9783c334511b9d6da5e84810e7c44f3c1270465addd6cb300ebd2cee3b43a08d2413a01b5c541f57f948a89a3822e92d19392692b3179b6e383f9121d9c37a211f96e736faf72964a93bf4a4dfc21936c34e787dd10635fc133b6a0412250c5536a5f27f8f259ba27d52dfed12316208827579a65d67c7447902e3c41f5a67264044e236ed3171fe4a2f9145ccc9aea76fa0c16f30e78aa2071d5e776debb8b4c95936d2e5f1876be75212233d82a9b9f080654536b4a30b2d5ab84ea24c60718e523fd270afeeb8b6617b8afd5640ea5e0f652009a53433581f2cf770e0440833f66095cccc357b50bed42cd8bbfac684b7f329aed88e4b024e60378e885a5ed36c1cfa12a5ebf69e1acb98393ce32a81dd386995bf91cd4ed13cbd58e161570229e50ca69f2e49ca17dda341bf7bc3647720b2c94beb4462f23ec00ee6bb6fba87f1ccb4c6800dd669df0fcb54c092c625e07f0867f91cfc69efd76e9a6225b2258fad1c5068320fc2cc59f5003fab53e62fada068470740486b098580567931fd76aedac0820c37a61ad45638af952fda0e648966ed3df349c324c0d2d6ba9944cbbaa9df372338394e983b7937e0f7ab1eac1ec41d97ed18864279d3dd0089467329e3347cdf6c480645fd05938532b544cda1dd632ec3e2be85d7dd30f30113feb9d805ba3a90fdeda8b9087bec44a23580d0c72923548f0d68bf42f4d032aa3179bd21c7abf1b1b5679f528a15ea813ccdadb775775ca81a0e21f270274a8fa87882181df2c2a5377cb079dee83aa89018641771950c34af3833c4049220706b9a37a5560b0aa983c4cfd57054aa85ef6a109124c5ccd00257843687293b105da313b35166395ca8a91be26921a23dc2bc56c53847a60b4df068d474a1bf7b2c635fff40f2c5d3217adfb286436f8c6800299d2cdeb82e8413cda1846590ab24d93e32e44ec683f440ab1cacbde228d0fbdf197535587f4f11745dd5963a2297c4be336d15633e1cadce24b6aefa3b49846a0e0fe62b28f489ae6f2dbbfcf431b8a5706c19c10215d592a267bbcf4e4c0071ae364dd18b25c026392dd4dcfa4a266d38274e292023dd6c7ea1f763151f75c8fe517ceabfb0b2376cd081b7babd6417c2ea9fd575608324d436600b871862aca227d0d869c8f3e7e1be4ebb33c42be1dfea990f1aaed59f5e4fe5ef8594105691d998c5e99d79c9fd5a35d14e634a0c380c8a7cd0dcb91e80032ef656774543ebf20f5913ec38ff677b85f54ef3aa39360af0f70cd49fb3d6115f09f988ac38a29080b0f8f900c9efc95dcc214bdd2d81a68ca30c8c470a624794b7f373dfbec6cfdd0bfbd9088184b91f6b637697030ae5ce81a6079e2e19e7213a9e4fae40eef2a3fb493dfe013dc513e7dd189bd76d51279c5d88030efbdb5f72695ff1e87fd055b3b6c04cf0cd7686df60f624939f397cab439f8a78dd325d566680eddfb4140c80ca3abc7adc5775eef9cb88c3392d18baf68e6663f1ae597435b4da020fb1d1c602907e20c85d6e0bc69a62cb4f0455f3b1d0137299e11ba0da1f9ac864814922040fc867e8c91cdba60da9a4492a63e068a4952d8e51a3fe8b1b3c09580223b619cc1c0f9f374182c5a1b07107a939077cd3ae02304489fb123d6a0d69880c3c169bb796e4b898a55cca37961a77bfec3d21bc7ffe0160ba365957ae38eb0b9f1479fb0740960b38d851471f63f2ea4a220c1251c48207007900e41c3183fbcd11338644645b1fdb34c0f28bd287b93efacf60d89bb1640eea6279e64aa7ea1d0497d6a9fcd02de9d50531bf7d734aec63aac0a61400554ed4d39fc852956fb1ff1755604702c57dbba80988848dbc253504ddc9cfd656d531e404bd8c42733c17522cd8c16a0561f99f57bc9fde6fdc7e42ed8a8342a242a8ebc614117458c3864cc51864f68a5366374681f4f7c1e4a2fba15fb5b96633fc7e9cca2af503c30d291c4c7007fd505e2267a26c0801e5c2ea385b5b01dfff06645cb34475831e4925921171efb88a41e3709f062149fd3c58bb95f84824a60488e589236b69c21555f55b3c55888cb874ec4b7cdbe9714f82328887029bd2348684d39a2e59ce8738b16312d9763ea8dae39edcaa4219b9c183fb2fede374ec24863a0579043d53207545bda2249413789f1798c343508593d4048abdc48ffb5775b9cb9c0e470f889e9d31411f14feedde370e645b14e8c6c45b3a902b733868d992851ef1d37e0010f4686d6d5391ee3bec3acc62600ab163490d671dbd1160d910707a0e20785b22f437dd017d6fb503115cefa4035bad6234c35e6062ddde534a2b0a7bee9ff14bbbf5c8e9f3b8107d45181d6b8f7a9c7dd77185e612d4be2f0ce693246fc25231a7c9b9da2a338bb917477ac4cac4741a11b238d3aa9b9cb95338613c3b07e95469d43a16c52bcc6f8700017d79d9d91679877960a479ba8a71cb8d47dfc07f5a183a26707cc09ba00ecb2a59d1e5be78966448713a2a88838502ea085bee26bf2436294f244b6a24eb4ba59bf36b127460dedcdaf7b7cf951b9d4ab0108520563be23f865b62c7280a7e5be5ce5a70a7fedd6824554dc10b7c094db766c696aa6170f1e2b386f00567729529763a74c34e5197cd40f2f6235fc840620cb1a9554855259e2a85cd82ee9e54e7ea2fcdb430e770e53b48b8f12b4a9b192f25b5f6f94641784c077fa94fde9005f3da0b693b35c083a5b2e78b81344e1d79245f76d2f3921044c9b1a7e210950831e0d18a8277c3cdf9f944bc6031dac6b7375823ae2e16fbd51188ff71ea2c8ff4553cc6273053e531c198650feecc763eafd9cf22cf3c2e3b8df3452b70c4caab814987972e952f38e09825474a6e5e1e5be2af3a619050f54a74c5e6ab2035a76bcac2e1709c2182c86fc2fc1483b9e18c920d37840e631b0482a3ccd940595f9179da0fa17f54b7392b76663efa4f33c07a2eb0c6a566f0d4ba298c9f5321798b9eb251f2b77180aa28afcca36079f0e88e52e4ab0ed1f799c2d3b16632d7007a09369eb9f1123d2ac13d74e9e469a235ae4a148cb5e7ba7654ddf092cd72697b598a5e7af521164c29a4b951a9fd6d7ecc387a1d39677810627c0b5ba1e97bf3738fa5a066e35e0b1f66e954619dff47c03693757549c408937b6d3004a5376eefd96044475a6ee390cbef5295e0aa83a383f6fed3dcc561b422bc6bdad4343b65176bb6e6b1314f9d7a71f4979ffe385f699e0a0fafc80ac3817f01fe3449101b92563b111e05adb1496e62d0a0074c1fa72517860013d8cab4b553222d51a912ae15516a26db68333b38b0d2f9cc3ec8ee0f8005030c5b234bfb81182a0ee67e272291a0b2c0b0f5533cc7f0e6c5b5e0e391d9c72736008fbd9350f13d451c6e22d3febd02f21707266ec31a043fdbaa6ae65e0b2ade023243598cdc3b3aa577af2a0c4240247dd8061d512df543745c8f5d9bdba80c1acfa48851c39ede17c665fb9db2c4b96f5ad14953abc2ad928dfcec4e72d824d81dd2a5f6b1a4998cd984a4cf5af204aaa00196199414eb51e6099bccbdf46a2518ca8341b93ab143bd482617047cfd7c41e1d48212fe5574d09763cc5cb7b152d06b6e808921cce894739ef735727aa435e07acbb8f6451be71e9b0bfad49acf6da8d61b682fa22d7a2efc02a6752ad037912f1750e4e95bc560764d014597465a7e5224f562e58fe0b22cbd00133485db1802ef678647d15bf1d0aad629d47d69a379a858519b8ab5679bff6a26382c7354878d79401545559c5e838213fa7d1bf346b7920803864e28eb1f0fe50498f509ad4ec46fcf10c0e4da362b9d7028d35dd9a2a693d4d4bb778f58888f74aacc1dfaecd25f0d162691ffaf9d4a5baa289f76a0fe96fcf68ace0bba2c05cc1a17b552c97e56e7bce1679472596c68eae0b117a6c9b533c2fa8448a1e554fe8c568d93d4f50c7152156337058973b02b4538e5bd0dd9d33f96a9c6969187755391961df4e641f4ceef9342b11183b2da828b215d3b5d056bf2a69a71a4afb183f4a18c6fe32f99b030032f9c926f38991e4f9aae425640817fe681b6acc0babd08951371bfdafdeba98ca90fa5a412f0e09c0e367b778422b8a5e6f116de30d0f394a01f562a2dd69d03c82afe46735e1187f0b075e7e44bcf5127f73c57765b04be5cfbe507ce6228d349284cdbdc31f55b3534886e8feda60bcad252958eff3df1e918735495ef7f148b2f106dab8fabc89b0223a3c4b4c52ffcea3a31295ab30d8e8a92cce5fe5b9c6350f9b95243cec3a39adf6005a9a168832dc7cb3c49a3928ab18e10ab69d07452c582d313fccfc312e06171673c7033148283d520caab4ae940d0e5262ad5570296ecdf8792d876cffc117bdb038a24b4fe18c9a7ed611c064aa01993b0c418b56dcb8ab75e6b540f5ff578436bf12dcecb42e5e22feb6af5402f8a7b1e0bd2a7dc665b02e6e7770403e7d4054553e0138dd668b82a18f3d0df23db38e4c074f8df63b4e15fa243b81caf39e4acd701d56590e6fc13d8992591294ae0cacc629bd9b72ec24b0f3a8aa6d88b7ca72ef31e9d22c8b3031ab7c3f9c7c9496ad184cdfc069be53eabe5636d0bbcb7e0d1ac99a5a41314e0fa9a61a264fd54369288ed7785eb777cc3c15a6e76ebdaf1a7b835553305db1536cc15ece97c74d8dcfec3a10b998aec1aac2a63912e69a467082249a592e9055eacb86832166e1c230890d5d39d550dde9c6874745d91cb65f2be4bb4fd4b4cb09eab1229556fc66a8552483760d4c741e7376841247857eb24db289956e004c985b60285d17a4a4219c41091be23a7b44518979927dd21a9a77df85127aaa60ac645e4442f37259c817facebe4d5a3f843d19a1b4451041effe8323f16426fe36e885d91b56e483ab8bfd5444f3f7ef9fa99ac2fc912f58f14dec1b88ccbee70331bcad0ab1f5f868fa699e2b3f786fa26576651ccf32ca6d0bcb93d66933924a2774de316a19cc5a2b9c3f7929c9a0f504a2a20d20c5ef8d05a90189bb500fd9d3f4a30cb044c9c25f821d3f14a583f0613643bfb550d78f87ea24ffbe4dbe6b441671bc260a119bed3ab193b41c41c11a8fcb9fdcd5069e55407a8f9b2598729db5ac24fbb3342c7857f35496af99499f126e307888b1a4684609fd2e5d4be2c915d699f265f9cd3a6e95636259f42a52994e5ce744cd85cf103fda9beb9eac4ea6fb76c9e7172bc1bea8e2eb49e4f123cc6ab1a71235bfa6c30b12a4f0858b9e688489f95610eee31df8abfeab2cb71e27c40e76b041433dc660cdfa9c594f64490c933269714c3b459323f397296194ed9f8b4693b6978b072d681030a6f9efb9b825e8f4d23b5c065f8b7744601cefa3ef237a158ae395c6838c90c2093a5b684d9bfc571e2fe7593bb9e6dcebe4b8adc89b6b7ef04a5cbf5dca9307c3c09678d7f22c82ca93597f9b49e3eab738e3278d86642f524514c2e0c3476fc6f9223c6119d250ff0210d0bc0ccf5a2bc8c42cec1d4fd0930e356ec74190562e3dccbc7defdc261f26a1f6decf446148c6f8b80e27db0c1b829ebaaca120566023d3b68e45d29a5351c1fd202d13b10643a01ad79f2ca5aaaf5d93b7cd18f5a1d2a9f6eab57ccdf01bacb6e8077ad0435f9e2b54d247c01d52c7934e4c733e7f9e865de0ac5b8ed2c7e59daa7375ec72424575707eccc53d89b545c6db6446ff166f6ee4f2973e834607eda56e009ad71bad281e5f9a9f747ff0084baa6d944692b78fbdecb1be01544ef63c19886c7da412f1e78513cc8c3211fb6b204d6f0fb113ae8eba8796e860faefa5627d053dac1da56f7eb23aa5b94bf07e9dc9df015ef48eb44316b26dbfccba54ccd3502bee89dfeb0e7577c92b0b3afb226243d9a9573477285fb377faaddb3878f136933a21d8cb27ce74f58bb7663819aed41d2cb119d5d835537df9212b57feca820ea3a7a509373f966e0038ebe1aa49826e2ea892feaa4068824646843ab8d81130c2845ed3d5b789307cf35dd103376fa6a0ed975865d7395b03f521d96f49c0323e781d182f2c750afb1e81ebef0ef851007ddf946e9b94fae7b6201ed4cc83fa7c752600b07336cd344a25dc0f9810b0808c487cc42e8c822aac462d2cfff10305727e482bfb2d8c8f62d94630db420ed2b63768c08acc2c921736027c50501ec876f9c9232757eb4725ad34fa80df0cd702c9ca6dc66618e8508434a0767c1fff3edca00780f9e65f0f90c2e407e400eb157b5232c47e40fe242da5494ffedf70751212788842bb453258c084b8816a3d759470b13c20ce7fb2cae4fea7ea80c476335b4544d64f697ee3dce751d05f071ff98a36fb91f1c089febcead3ce07d7a44f4c32a9ead6b294306490d9ba54f9ebe2fa5f0a8c312e6faa3d9facb3638de1a4febe3046aca6b6157ec4e625b2fca19f4db837fc43e26bad046dcc6b06f3be3ced889379947c709dc6ccb8603ca6a89b7dc2c4caee97bca35ccf914b62ff1f852efa4af126e2283e2d08201700a7f61d293e563d932c5dc55161ac635ec83af2264a56a991583c74f7387f583db9b33a551bcd7036da0b9e7cd1f7677c839e5e09611343a38012d1566d48bcef7b9a047f78c8454df5c1ef3ad7e7cb615f2215c3dab2592f141b5adba31cef12e782536e4786ebdefb06be2f616cbbcc979107dcfd2ac82508a8fe37567105e4b921626575d2ec420075e38721a9e8d665f6b15ff7325906912ee6a25ed76cd1fe6a9f12f20b22cc9ee3fad17aacc10d05f05062b1fd117893e5578c3169901a03254d51e3356e0ea87cfcac6f3df2510e134bf78636d3cc02cf47fba91e97c7511ba76730e5f0107c7344059cd3287db57dee30504a918548a058a1744a6e9a4f1ea65ebfc409fae7c78539ae13d4a484bbcf5820c4871df2da10feadd27719fcfe502db03e869f677335f8c8e90ec0bc1649c5666973ea9407c61a119978b1484d56743d8e4c15d6fdb877468f26405a0782106e62695c930190e4bc55c0cf4a2a560a8a70037687d37f2095f3631fede521eaf415d964bf931c5a77ea6fc4b7ce06b54bca1f7f2935e1af3b42a2031423c076dc8ca837459f0ced11e35862a8ee95ef9d8aa8e11a5975ddf5df56b0961a1ef4f749b44b14d3806cd782e3af70fae338ef1ed8d535278a09bfd106055369ed7d2b04a27daf6ffde2d756f4cff612fd90266feb36b956493b4544d0a38eb8c64a25b9558e6736efe96bea778a6b171364e6860cdda3549d4c8e7ade4c2fce1d1e095f92f3b14939c998ad0fecd853f2bbd4c82d0769bb12b657f2bbca01883c2356695e807eb06c0354051964e4be6b5d0d608170e539adf48346201cf78beb80c9a06d14b0fd48e9524eb80fe90248bc65558283be58fb943cf083e44d96de1e02dd6d4d92da876ade02f166b463e55dc28f7e4ac93b997268f5a1d50f05f56de90dabaa65c8ff656dd5e17072e2ebfa71fe1479989d797c75616d52879fd54d2bb9f4d0cb64f10d4d2a1abae38206b9452c18bbab0acc7836125205fa242fa0daa60915b8ca8e8e27a9cef765af3c8fb1b447a2600824f40078f14d409a492a5e5930f3c8c676829ee269a05310cfc8b50bdceb8da731e16e38ca6b944da30d89e1a85c8a98be08274fe3a059d9b113e7baee0bc66ee58e3a2d45f5df902a24bd54fea0d70b22322be6e46051baa4ce82a07694d1553dc2ed8fd05849e3a41b71e5ca670411a2e887eeb16e4b5129cbaafb322240676417141be8ec2f2b3dece96b6e85c902b6f1cc62265856a452d306e0641f17efe2354ef7882d41356cf00c873f229e5e4e9f823abd0acc2528c50dbbb33b7b4bacc0741753d6215af09cbf72502a7c3e64d9ea33134f589d0da17e358ce4c296232eca5ca5e6ff91b6c7914037a9a593504f0366c008fbeec1ddc69131640aabc2f921bff1a6bc5e73ed30040e14437b0bcd10400b7ab0266a14310b10157a2d2b4edb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
