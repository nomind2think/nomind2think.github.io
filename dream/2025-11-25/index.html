<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"106b05b55fd56d19b6c84f6db2ab233a71f3091e85c580dd06d25f60e29f8126c95642c494a6b68a6645f99abe378f535b54ef71eb9070c6a752086c6a494f27f1ab17a7636b4d2a1c6504474aeddfb2b972f8aed11e6caf8b783dce3dd32d3e7814fabc334d271623483acc26795d9e195af23340010ed317dd32bb8b8d396e1a13eac66de39862a1bda728f93cf2f62e27662e86df9f03a325b8f826de0a8321b5d360e09b4c7aa54fd0849e6a8f3fab973146d4da1ae60bd03ce93bf8642d04ecd2c89d34c16b4bc942ebc0d28371ba7b20b2eae49080c04ec72af063c0c528879e8ca76ee2217454478621b422c93ea641963a041547c11b445836caa8de5ef752b87e447a65408e9737d84034e53464612af89506fedf822e906da4754c56c4407502042be22dbd08e97eb39343ab92889cd38e827cf75393e5b2dfc96d53ebc43cd5472e0603d4f71f974ab9065f400066144e2463ed94447d45ff48c84f078a80170967a9d487d890b1879b815c5f2f6290a3429a7b7006441b04021490c8caecbbcd9ef23503bad172536abdafc5cfdc05c6226480ec78fce5b6e354cde48a9bc91804702518be7353aa291e2b74004bc3195ec6225004d7b14be582ce20b3863c61e24de6ba1437232573a46ba957f557525c81708bfa7483cdc0ae458d275a6d3b7d9662a8c41e4d94b69c850bf0e56733fb5331033ade7cd606a870b57087dd595ed0a40c3a96bc53e343f93278a9596c5310dadb307fd692e8b4935f1ec7d5bcabb99c87e35bf8e8522eb553b57a2c38050f18b7c630e9ecea2e2d9a25ca0c581686fec5277c6002a4be9552d4907c936d080325d5604bfaee7a8f7d81a0c19dc28fd03dc05680a7f05a2048cf9bed336eef1f41836cde5fbbbdfd9ba1827ce86c25dbdf758914aec20af0cf9250390447eba4bd7104e3fc6e45e82aa8cda3eaf49e8ea1ed5bb350255e246603a6d79c57d7cf3070c3eb111a4aeea134cf44883ec618a63fa831be2fa9e86930cf37822c03e7939e39110d3608debf65e6fe65e8ccdb8d9339b06c40e3225bd97c0be34110c11f0e2bc6c7d631081f0574a58a35685cdbd813ffdd44d5b07e7187712ffe27e78d94c22bc1ad9c49f414eb01a58b12dd3036221519696a37e025687b986324e272d77c421950eace1a9254ec77a568104324959221aefddbe93218890c038b2a355814bf6c17918ce7cca685dee99ea528ec8f203e6776a918b36ebba2ce8afe6bb37ad8120670b83f50a80464870f43c5c31263991e0022a62fa0e25e620f46fd70353af526cd96e76fb006e93f534d94edcbac79f425cd73d2bcb991f29a4aea25906dedc2152de640bfe2aa05aff1295f6f2d847fef7832b71d24266470c3c248ca34bc37bd436414adb89a9c5060467991a4fb2fe67f969db5b559283ef918a3473ae439ba9d9258a58b78bd3975646fcd7b1512a842cc54858d323c09d684279aea0bb1a99e6a9f9c36e3ff9c0224e8df0fc3b8ecf26594e292a8a697e454bee8742ea119acb1ea5372181baf66855e3d66983fc2ea2bc3e985944a6abc43992f9134496005cf45eccfa713d23dcc46af3a443b739b4780931feefeed1e2e0b67ddde28d03dca225f9cac7e8d2efcbbae5c0103c4c341996a01ee16b7cc50974e8bf8e45bb01526f47b5039db537caa9365808037d36cbef4565f5d82e631a4a0f05c8e20d102239d0d239f34657efe22cafc2fbb92d2f3e204d92f1987583e68b7f74c7b2dfab8bf2f07aa5605f4d70d83f391e8092cf9a4c64ce5d55e338fb269b30c1fb79dfc599da999ab25ec59ae16ffe35e94430653db06d27963890a92a3f4c539e8fa7965c25beaa145339d153710cfb7e64b31324cb5b56bf568a59206485bae5ce9c3cbb6102501ff23eaa1ddb1dfce656a5b05913c4852aa0b64d0f72b8c83f7053d80a926b6a53b54265d17b0dc14ac295687e90694be30da76463967a488c132a21af0004db3c63d5fa2a55f4f0eac9dc93321e6c22c9f85cf8cf6640fc9385d106345320f38a0342f808e7b1d755a2e7b7378cdfc868fdfd0f68cae01f81a024232733adeb19723e4e7b2adc58b34e61cc946c61a5ce5415ff67e56fe7ede1b5c89d80a21df850783b70d3a834f12f58c3a240bec89a62e998a2a1a21bfc7fd1365760909718835998455d7f3d7cce1b5873e1376618755d60be0ef1cc71051a288145ffe0e270e8acc33688e703cb4123c89a11ad9807bf933cc9c36d856fec2f296ee0e3feea35a46a50abdd96a67955c4838739d22c4dc456508899a2a62b9b3b5e3900e163b6267b1f01dccd48e47ce01fd3cb6bd428660f51f84f67f155a30823ff806b8fefc75cec18328082d083340e2b4c6ed96387d88f4898456b41afc35b4fa6782b6817bed02ae63c3cc853d611736e8bdaed0e0329120fa49baecc5d2ad204efab82c8d5f73f99c0da19c0dbc69a86b36a7b398357eedcdc115af3a26e25cbb4272d7afd18001e3dfa245100c603e516a914d51e5ff42514f88a3b7588c875b7a378211abd5ebf3c9dbd93a2d411e24939d69b8f8eac85b6482f9b3e955c934eb0b485990035d37e9581597fc44dba7460b6499e176901938ae0d87f0c0df64b718f0ce8996790af6853260c8c16df78401c1059503efedf56b97bf213ff0eb60fa629fb2308e695194d31591cacdce6650061456e6823295faace87df1ecaf942766670a9186ebcf6cf057486cd65da377db8e0cede7754fb47b5ca85a0671a33bf706ee1fb686f8c566bb5a2f59f481ad43e9a0736b89cb07e692b0002e163e7f3584ffb67d7382f2bbe6e12ba23be7e4b11269c29c8f0daaab623fcd6a115ddd6b3b80a573c168152eb7a325199e703837e84985a8b2b2b9d6fa99f08bec955d64057681d287009f4e37e207723ae77ff2c0fdec1036f2c0b34a54232ab1fcc0a3b9bb85fc1f9c50fe7b84ccfcb06f033ef1a67d0285bc7ca71d88ecbf7c298d1cc0e2f28df501ddcac3c41ec9906df31e3b827ad57f908efab4d216d5c2e8811b705f2fd33aa4b84c9d867f2d1dbab1b1cb3d069e0eecc03e9ae714bf2d0d242457af3ff6528e5d26d0bfec5de331a84c255b3c2ca946fb7a1d25732e9c28d0b3c911ab9ff1532a32978fb400a75125c5c3a33917242bf3494c40ffe9bc327b96df8ae0f551799499fe1df7f7cbfc2fdcf363d937f14bedcbda605726fbb0bf63e9421e664775e25346c248a46bb251b60add6a73920e5a1055f54347c1badcc930f41cf3bcaff9ef116978e08502ba899772c2ace974e3b55e16f6d3d9a18faa1f4e3304719b231589525f56bf0b637928785ed6b57258f4cc97f5000049e01e033ba0524f6430fbf7f0b13d3695254b3f94a61b87aa741657f1d17f07b3a82c8cb13d25824f12b10c2d8eb92d9dbcd11d7915cd4b50449edb0da5db497b7a48c8ca93fc322e52f5e76c4878b4f63b8793b68613f158c401f54fea6db60dea7132b49833005c2792f75e4f8db1bdac992e1202e67dd58416a4862bf7634adbf60b49706206d8d46832360182a6be2d5c4771bc5678ec45b41e841a3c66b0efeade7739838971f79877d5da1ae73a7b5713ee7547e7b70d092a9b16b7b937569a527f85a577d32140d4c0abc4d4a80a98f0925f7c19c9ac9c144a6f9164edce423d712063db81e0bd1baa268b0cc2a0aa09c09ec18e2b804be2f6f6127b1116d1f4d1afb5c5ad76486071684c4c306a813c5592a8cebcd1f332d329de26b8370fc679c66bbee44ca92060dc5730010ec85c140a1629cd5bb841c06a9a5fc3e47019e736d2557668318634e9ef916bd9357e50a9b48a4d751cba623af506cf34ae6f72a57ef67d918d7e80993b847192deb028629725f0249fbe14dab9df39aa1c9d1258cd1d018f30331fea490a7da4ed5fc7bacf8517340cf319115b55b7171c6b8737689709ddac8e5714e77253422d3f8e10291280937e693eabbef45d3482da11361f129bc2e3f3200732bfd8f56681bb70729e6e8379caafe74bbe9b55ea2fd51a9a0acb8d0d6fe78a9c2220a0f5d7dd5a43c915c4927202e724eceefffafeec8ab4a28e51e8895da8598bb0d3cd05f5f08bb1465e25a6d770da73babb60b3087c4dbd1dffd26d1be77090f1fa77d53d94c171f6aa3185ea86935bc826afbe313334a1835b32183a632dcc7d0e1b8e0b4d2649ffe087ed05ba366a28b7c584659f65931ed412559d48a2a7a64abef572fd662c45910f8d8b3f3ba1b18ea31c7a654be5d9d2aeb2e7da6007e675ffde4f5bdd0c24ceb0a436feca058f0fc84a8bccdbdc4e019cbafac8db0cc11c061db71cdd045ed3cf1f30b393229254e466d8723d5620a24e531a2900778878f3f8f35012685d762e4fddce2935f90849226639c0ecc348354bf29ef9db471aaebed6a6c188e276178802aeca6c11e6f54c4be63d6f21aaa5183df569225a2e7968a8e2d929c03032e215b61a6265fa14bf3cb1b220d6af33be882530002f7d3cb5bb9907d184786ffb16859740a18bf876de170d43b2c2deb477d60161e94b1e354fa7c1cc7d1216d7e19d6fbbde083fe0e780dcbdb9d4b67d8b2e93f7a21e974df3ec2d6f9d6dbd966db1b18c671b9b4a18445adc68ce4d297d5cee85e4b17b7072e493fa002d379b0fd5755608ea2f361c8cf1a88511bf5596b16ddce90f6b21546127eefedb700d989142e65af75643ea823a98055d705d77039a79d1673c2f0930ccd01a17c413e1824d5583490af47f713fe05c7ae22342353fee777ec888a1ed959a50ba7b52ac90fec1637573501c298c960479bccbbce88ed51034cba356650d673c187aa90c4e66d704474dbd08f957513cbbd58f6d9e3eb765f13f2cab60c227de98428d0489cba9e99e42215eb6b5097372608cc4eaf4b43e156086a41b25c490ca2d253d80caac0b6d471856628239d09f7807fe1845015e8f4028a60c6acaa4b7505638cabafa5b0bf6228c7e47de11192e2c50416aae736fedbf743175bd3b94481c39eaf72ee7517a5337e8749bdfa66ef1acbe02f4c3f49563d9f3a661c533f0052144b92a285ba5465b4aa1e2f6af709fcc957a046446dced4b595d1d4eb8d3b967551feb91d82d013ba35af21282db4fc11ad9e0d4bd5cf42540c7c8b36a206c0c60712953eb5ae697f3b1c0ff02f5154d241425d0240cf42a18066e38fcbf59d45c79eaa72f37ca29e029e81cd3a5ebb78b98bab6e646e1aa6a8dfb89aa1b825b88614ec42d584f62d3b6ad9eceaac6d3843ea89b5f0116b06bba7e0f9f626d89f1605fce7f0a4c4e173dc8bfc258014861f5b57f29335c3b1c54326d7fb57e9d7e8ca7ccec2c153e6cf118a7afcba9bd97d88a1865c38de9723ee99b9ff414eff6dcf71df69b05a4e25f98f2d63e9ebb941cb498efacd9da1f261671d382034a50d16076bd4b03993f566f0ea7b8b1eebea31cfff2ad4f5d71ab0b38fd6b87647345fed80182d89b6d2d75ddee8ce65cd68ffe75cfb42f5be490a28821a1a852ccdfbef7d40ad061ccb3f5370ee8b7165c20532d4499205ee1b39a761edd99311695cc971894d79cccbc72e508b1038c56b0a887470071ef8a83d43df633346596d68b1684a84d1d147ca2224bfedfd5d74a877664af113fe958f0d34752b1e24c6b9bd3b2e94d7d25455fd821f6f1647cbe11611dc1561b54c81c251c2698856596ecfe7600c9931e312b84c8e89ccd8a72470a64381e588df25104f49f06a2311619f6844fd83c8f06776c90287c9e49571b9b6d1b1e7966070c97b9c58da6a44079d327595860be909851bd1ada90cdb9562cc9dea2059713b4ae24a1de556f057d00d2ebad65ed37b7b6681b67ee856b29da859f0b46a86ea4a5b03232845c97e7fac5631c19c735f33f746402a182e71865546085ffe19695d6eef96afd665bbeaa18cb75c54051bb8b07fcddc091d4ff21dd4aca1005c7ffbb7366a90806c397983fd5afa479940af6ca119b4b8f5fd9d8ba34421383d064145c53b1480c9e3dfbb2112404094ff7da9fd23a4490d2231d8dee62c1a326ea3099af077771d0084857965eaca1b25e2250530cfa4f3f8dc9e765c4af8e3b964b36c30fa611695998572d405bb1200979f1f58facff186acadede9922251986c31d1c1aa7b5ef1605e99f55b0e28b011b10823ff333af8d9b7571ae7e62ea592cfe2e44f3de9aca22b128ff5813a69d0a2fe20dbd5ee200caab604dcbafaa0f48cd64d427b4dc7f332b6c929e1844ce30e61fc5c4f62c9113106fbac0b2f6723278e0c5e7d9251e6f5557c2a361a18470b0456f1c1291d4e3f81acefa7da130692a6166b17e20ce2cb59547d0be949b31a045d4b0cdc47e5d5ce504c937937427d76f661948f2abce14404f6363492047ffc121f9268351f4967147795e6c9539c3b33663037d13208f0442d4540170bf18dd1f736424d7b3d133ea535e82700e2268d3ed132703c524d3c5403d5440c8ed0ac8299cd3b0eb1b69405be0cb292a62b24c1cc636ba1489f9fbe65b28de90ace426b86c890a14c619c743fab0659b456bd627dc8892ce2dba832310c34ac80d1e1052de2c102c6fd0f39c8ba8ba95b1ecd6c497921b151eac94f76b60cf8ad42f9426e0a3e3d1484a201f1bc4acafc43f2cac4d741ffa7a396cf0d8fa3e8dc9dc93cdab1110a54f851a2e34d941fc347056dce8b5d1a18440c175c93381fcf393c57a4c03ecba1c5be8c0584a91117354d533535095da9bea2d70eed40e5cc9461ff113873998e9e965bfad67b89d3987cf70a180dfd1e5a11dcc707b4e3e675112af4b17214c06f657711b79de36e418fb757d1097892941e181581094bdbea446fadad1c9cceb37a4da56a406c70171e2168a266b4fe83a6905e2108feccb5d8be7aafd5f8a4ae6b02a146677bdd01d6e9f0014f40c8e326c0e58efb13cc23f6a66b4e8897d4b3b44cff97250961cf853875fec499da432ca04b937b4d31c0fff20c5b6b4c619b4115c746d943d069b34d7385edbc35cf4fb34a07b63fb54ce9d3978e802d95ca8a342c39fc614fdd82d71327f0f7b0353435077567e61e1cb8e7787c839e1cbe18a08d21ff107393e33e523942028a6afa8d90dc53f972a17bbc3f01339875e2b143cfc770c53df1c9dec79ae62301ebbe6d5e12e7a89a9325bd53e8a28abeea2c2bc943c1409a74441220eb7b044f6427bb3da1d17e7afac8c37c886adeda8e62aa8da8cf7de2796e3b7d284b2e390d4c70ca890a97ca705c070970b703e3efa1f1f4be149dc03c4ff9d81b6958d2824c2204e81b6ba2442c7ee9e8924d9af032ef75319a8edbfcf4ae0d2f16936c322eb8eeb2abbe0f1baa920f877ff6b6dff2f38a237df32dddfe2cf44e8afdb0a7b24f3cc05a234233630018f5526d99b3e33fcb37e893fc85f0ba374e848b87fcfa6db37d6092eabbca833c9f5770b3bb766531d33f1c5ad6d365d45837bee5da351f056ba39ca172be737808e676bcd513334a4d85a3524fc9566f63fb175b184d1e82677184f03180846033a9a6e5417b9aceb13c46d0c9e2f3db99182f8d24223095c3550131d484291a30e57d35de31edd60e1a662d914020c29407bfa3be05da07769db8a483a2afd96bcb215f80baa938c76513f606fbb03df38d9a5cd8744eeadc8f317d100605897a7e077b06d4feb86d77f0ff24755dcac5ade37ed8fede02a9d283792fb9bfd9204253fa55eaacc7b6eadc52de456e07492ca88a3e46e6d77905913ac96314ca82160785f19ea1666827aa1b1a0282f18f818817dde949038e1a22d7a8a68815e57b9acb18b3dbde813a11c91e8acf02d26be2a3a997c2b3a1cc8d1671b744252ba21958e04e4823ac88c616943ed3ead51832550a08d0d71200b07fa6b5c0f37724c30fe2e3aee96bb553c9155cce5908d464a469e2b67d9eb60f777a817d1f89912e92b9ae559d4d9b7b6a7063bdacf31fc0f4f47c70ef9a25d618381349986223b24cf76dbbe5ddab986f5b9e61f2f483e81b8a1a483e57cf5c989bf32c005bd0c526590dd117b713f1f9e01b1c18d070d20b3039eb20b502667ed26a2162e26c0b870171b5301669f0e4622bbb8e452cac627499e0174f5d543beeee8dc2d218177aa4be46aec8defb85edadf305eba3f31e096184ee49d6428bc551c74940d0b4b04f2c67b7a581ba84eb90259ae12741842d5af446bd258e4460042458ac3f34530db6fcbc766613840b175496d756b593ed2112c40f44ce508ab113de806b29575911c83a68eef30d3bedb6500a153a424aa60c6b358ef36d964e6e8e9b7496710f3b8237bfd9613379cf8116436d3da9fa1e5c30b06ead790674e4bfa927193e2c50fa3644efd4877e29db80198637fecb663724fd2afe6c07f4b6d98f5d4c240c16ab1f4363920fd70e1bfc3bdf086b537b31fee922d10b3d0fb21232e4be48ad1c34c2cc635194f62cb3f01ff8c6c012015f351f200025d9fdf0d3e8894a0b890c0a5609a67ad14a600a196649b6d525d4c7ef4dd2132cb115f3cab46a912061d21ae26a5fb30fafe13c208c7f8a01234f9900673c54cb5ed5a9bdd54e8a056a8d8212eb20e14116eb4ece12235695b80836684e54f45434952d3b5f9706c3781a660a8c06e16cf4d950d2e8f7f6b13a8a07ea44ffc661cd3084bd79c188c0da4bd815f797d3089fdc61f55bd1469681216584c2253d0ec9fa09cd58f618ddae66a54f9be8461a46f933d45e2c1e6e9c536cb30df5aa885dc2214e370c2cc14bd44e27d4847124db553dd883f2f7c6d4cbd76e7afa3036ce4e2f3d0e769d99a133f771e1e914ee4930b5af9a2407274bfd0f153f604e31fdff33b5dff5d57a3c7cacee745cf837c1b444a169845fedf9dedf299ae22d3dc06210667b064c59d29595760304ff326f18628d94c1cc24a5b95c796cf9dccc35d7b6d099174dd88d57f9e218a406228b5b4ef8b343fb7db1324e459693f9ac2d03b49b8bacacdfeb8dae691d181e880fdedc53b1fe163ef6dbb145d599a8d3bf10909c9965230363611caedda2043bd457f98068396c1206efc50526773970718fffd6b75b3e91e4f1c6ba0024f68e425248e059b3e43352cd014847190373c84e6a60c3a9d185080dff3c8b6b6c2355b668fbe3b563161b420f1dd85b0a9e59390a3dc41dab86c5ac2f2fd2f0347bfe90ceb261be13f7e830362fe6b7dfa0ebf81075e4e1ff242ad4efb184e9098ec6508979e59b8b4116eeb7334a8ac8ca9ef7b55ba1b0e886b9ee4356a623b5a27eb0f92375946cb4068b487775ff65d93e4afaeadcf78a0e6fb6dff563d6fd9c06751cf637f6a604f02f094334b1b1c122c6784d5205311cc5fce9086f0bc50ebbd05a3259102313de2f8ac4e9906751949936e559dc9ce4b3c3f9d3a00eb0ec2a87bdd1eca7515b79bb9ef8dc8574d416a640c95db7dd0f06b0aada5167d1c353e1f728999035094eb03074622192029ca4b03ebf03d73ab3c59db9cbe5166af3214c42906f40b9e5062df6687445455ccd10fb34deec5d4228cec4657526490cf57e5acf732f0b5c21097da1046cee53eb01b7ef58300faae22f3c7223ca414a325537ce33e0c54ae1fb15621a78cf6e8954ffba48903952d99755d3212adca9fd13a874cfe32107217629b392fdf4b5a1f348b141e16240bac92ceb88b5f628a8b8ca5965e65c56a124a5f3fdc12a8e8adea1652bc4b2c26f7d45e989c5bbd2f41b0ee9e0cdf27d6c3d87954ad056a144fa29d21eaf0e07a0e53068f9de5a052557d87d8931b34fd4f2c6d05a170ed6065760f40b713be3338988453257b77136b6bf2e7dba9dd4d78e8e163871bc448789c13ad7c9574e0378a3cdf36ba97702b8ff9c557865c86ba067346c8965429786a1bf0db3dce30c8f24f3f1042f029bfc356a713d7bb054821abf2c4b89b36bc991818007ac126a0722635be404a13007a9b32430173d79c9a6d2aafea356a8a79d01df395f319cc39949c0d54c628cae99f0dd0392a39de60a3ca9ebbb30502fd5bd3cb02b1d31b829538073014b1cccf5300056a810ab176e0de00e34950140ec6dc93362248b8f83a5f0a16340ee3b986e663fb1477a538f950ab6529321e8dee9441b344581a806bd42a8fffa4ac988fc799d1742d51d3542a93177ac4daf5cda9e5ec1ffae0967636031f20258aee6b147ce617fd1bd2959606457d0be318e7fcd88d096761bb23b988f2e624ef5a0a1d9b2cdc67c28b948b72fe5832ea85acff75531ed61b96b601427fcd0e65d953a8e6d381298cb62d1fa5d7023334118cff92531104db33a814eeb402ea2faf22c94ddba503123b5e6551527a71605f90781f9c7f29852b3d99170cf2d6fba5b96bc2ff03f92b52b6228d4aa96dbe11358e0bff39d16bac1e1b40a7268850f93b902a7afec3fa178e18cd93a62c692d89de08f030df6e431a89472ae92de9fe5dfb8af64ccb0b43fea092614723bdcbf3a53ca6cd347857b5c1a99ddbab02e6619ebb22a796d74bbc21cb7165d57f9142a837f5293368d9d99aac6605109eaaf54253336f303f90755910c80e0a4a65eba5a8ebd6992495f30cd304aa76d58fde955dc3bf430e3ae2e44bd9d392449a64607a49dd65d49106d17007b9e4c87545f64a339a3bdb42bffa39c688fafce69bfdf92b0a138065f632cf307ed45f98bdf343378a4359c0ba6b6781ad18d47c84ce5deb1f058c0ae5fcb59f481b29bda0fa93ca3a21ba3123ada5af04eda454484eb05a9f81297ce4a82599d4a4c9ea0a6fa500a804d8ddb6b3b589f2ba21364dca4be01285ca3c58af62bb901ab7c3c1b08260da1986e2c99aaeee8698dfdd01a932cd9a555ac9f5a604c1da6e0276e1c6ad206b426092ef9a878a82703809523bb1995ee0e2dfa58e7de9ca6b1a076796038258822b9d72ba76e7abec254da38bf9ee7f2fa31b84367f95e29ae5c543df2566e9925ab6a9e2f09301f24e0957da7e01cecc3bec256bd38ee775ee5e02db2437b0403d6e00a620ec6d249bba6647e83c574f4a48bc6be04c7c92981d23968eac20394ee55917ada22dd03b2ac683c5aed0ebd78169865a4dbd8b50657d7878b272083a644ddfea89f7fb4d64a4bcd6d755a28c22562a136f481cdc14196c1018f957ba4a3f9f421d3a09e7a1812d639969d1cfc0be745b226a4bebc7cd132ca5c4397c59959d78bee93c90fed3606ea486cb3d9132974a495ecb676bc9d306b87bef39e8c2b754982f2228d9b4d14fce3ce25875a2ec33aea7af3611b9ffcc6387aa29c1d11fe879aa1fd74a27305e95a53f977fa3df5c8947b201b1eebfcdf583344ef9c7ffe0b14fdaa306ea365f24eaf1ccd177f7b41ded041c4ca0bcc1b63c2ee2c62bb32a5a42c6ac9216905931106386f2732ddcb03aba8a16ade98152b8c7dec0c9f33d3f7c4a7e4602b06827dfbb0a48656f276c900fa00cec48a094510414a8bb3558f429c8e88b00f4cff08a0e4e98286e8ed1893054c209f02a228a6388dc73428ddda9f5d6e62d88083a174801cfd6e05079831c716904972db70794f1f3d8a387f794497dd0f32a41edc1b287fdaf83671f4c53f2c5be9345040c6d1e108fd8afe17abb3446646e473060de2cd401c4be6af39c37e41072a00e8a62d103d576b9dbdabbcc85e5cbb6db3ee3aa2781e28fffd8ebe03dd3dd65d14665ceb0a72b766b7e095ca2497071bceb7051d0dab83ce2ba5a91f85efccfa540bce067ac29d7dd0f6b43ed1135f88854c9dbc796c34b18432b5830c6abed5d456b0feb3baef1dc190c24e532437853a6d44bc26e4c8b7253c80d5377eae36203c9d097d5cf4ea4cdd940a455bc605e5cb83bf64af79c26ac1723976e0c511207b628e8338fa8e6f25169adf52a4a070d6f35f7736834774a7af12ec031de20d3030854befa0ec460ddb1604d665166b899dfb76ba7f527680fb2f0b72e507033219de9fdbf00761df86004252331d99c8e93d185c5d18db1a7cf384631dbb6ac1256756fb1beafa22bbc469ad914b461969ba3dc2bed227990a4b1366444a5c1cb11af9a28d00b88a164315b362803b8ba0c85b8152e5fefbdd60761cda0f3a4c9c22f8d4cb6773a1425ad49759e2c5f80b5d1214504276370cd273c4fd80a076e1bebe954a4651449d84c73451115801d7a62f06de9dc77e0e746fd9e8aa176c5e3fedf25747220d49fa0fbc379cc465bcb02f31f21301b4440b131872441da65b337ea7ce19bc9c5897b9e1a68c4a5724d41442ea2357c0f79fb610e3adb338b642d17cff11733bf9d59d4082606ea8b99bbf71c906a0337b82dd5d7c4ce43fa9c9a65262da1991a80f5f5d75579b303eb1099a2b6496c6e49c81b66957eeac68c5710726bc7ffcdafbaaf76b3e9cc6de97cd5926fd16494f8ecb974a6e258ebc003f4c2a5d0ca8272725875fc60836bf43b4fe253b7bae83808372ec0b472ae94174fcb6b1efa6d424fe304d1ba2839118bacdb8e18207f363fae7b41b539625d394210a6d7a1b0da9850dea17b26bf5af58741f804e419a41723d60a067a23847be95825513959cef0bbb6df2bcce1e5ba0cfa99b6a4807f309f9d0bed3f44a198d12419c1ae79de4d4f16c17fd3c5c1d1982107166cb5523e42f431ea154d995455eb176727202a49c8ad2798ddac18ed27b6538ec1138ea657e4929822fb8ef7edd8ab9a20b757cef00218434ba5c3249fd9859809238863709ff4a7f763ac6fccb5e614bf5ba230d0138ee765e072225a7c27cb6c282f4bcdc4e5a39e722cccebd29a533efaea25119a681bf911df6c9af2fda1e05ad7b2cd4e1f52914eeddc53ed1b1c1f3c156361010591c0f29f32890afb74908574dd65bf1ef78e00953f42325607afa7b1abe3a7e67baa47f6fc8c790a2eef153fd09fbe09ccca5effd911ec6cf730c90d517837dd6e4497c6f63a840574f168073dedd347eb49e74c15731975c2b8373e87210e227af3718d1cc597fe593ae4811dc6db22b0360523aa64943117c66c7a1a24fa24168210cd64b70fdded056571feb26d5f15fa6ea1897c40d760f7c5d4ccf16ef3d10ee4c8924e37af190529dd302f438c532885c7c8b4c9b259edc83b7bac672f1353361899b1ab059d49399d7d1b66fb5d53ba71fc59c6c4140007611869e9e10ef45bb26b76f7fc22f1ec4c7e8026a9aae1d09b52ebf352ff317a5a86a4ce7302ff8a87fb6806b69b092800b7ed0158b9377f4dd3057be0feb146f933c92c3ba865934b9abef1fcd84b9472fd9700b7c306272cd1516ec5ce71cf3ec1a3c0bd51f17d8850b22c9edcc85f172fbb0b523273815ee5c2e478ac24072ee9f4bb7d549436aee68d75821c8bef79f2c38e6ca73b023605ccfd0b6a598450ccdd9c5d9f2253636f2729f3508a391e7b670fc9f25b358d7952a7d6e4265bc98d91464390ce00c139891c1f462d2c9695b9094083f4e3cd9ee55dd1304fe84e65f1b5c995279992f819d443a8b2aa70ad5dba05df95a604883046e50ad5df92a98d99309b1d82e1d0d206f1bab034a668a49915ed25642e4764a70e49e1114bc915008598fb1bfe534ab83bf332e8940e12df5964f42d85f2c002b69b07851d24ee96b11f3a98ac74a35b0d6e7d5c56c29f2a6de3527a5a951f354ce32d7c8a6a520946cd681bee675ce7208ac27019d68c4d6135ecf69ea0010f162e612e044bf1fed164058be14026725d57f13afa165147164d4099d7e8b2fe8141669b35072f84774e6d060cdceb201b7298c6daa54826255e71660e858417dc3aedbd5cdce21c1fc118edc993053591e78bdf3bd72cf1d97074e29c1cef82f4b1fd473ea865a079363700c29d464cf066403c92d170bb0de65293389769cc2b623e0cc0cbaf0b849626d392560b472064e082344a9f0146acc77426e74faf6390f9b4a05bb3181499feb285af55588111e39d59cfc01a17995138e5872b35cd71254b6deafd6f05b26812d84675b8302f0d42b6acf46457c1b4fc327af88ff82cc4e4d4d1035aeb46f55fa48699ec133c9c78fbec1d234d4481fb71f293bd05d378cd8946c6cca38fc910225a123b0aaaa78049f6743fff28d66abbb138415a54034ba02059b89150df11eb2366ae254b9bd8ed7a47212dcaa9f34a89952bdd6f22866c7fa4078c69babdb12d11c1a52c7e8f7f79d505ea232e6e55f53f34a6c0a72b141fd8a11cc2b788b20089ff92f736a0278bb1c3328c79a1f43e7c5c5b6c9610ce7c008e54b0f109921b12bfb8b5aeef2a580a2ac54135c01ad4566f998350118aa798746d40eb3aa0242dd43eda4b577956526235a2c90609fbf42a9ea009f80ac86782c0a867977851e768be8f7e649ecb9036f67e9707f99ef34e98cef031434dd2fe99b3df06a8d54ee9ba62a3df2508346e652b82217e9530893a77c72e1f1cfa7351d61fcce955db1642d5f52550efcd6d71aac84b1d517f10b2b816cb825ebd59faa3199a1e96535731b47cb05f042ef5ed09eb764a9955f8271c3c073f33f8bacde44bb92858df08ce35a47216adc0d05e4a5111bb10d94abcb357c0d2c4a3fc37797eb9e530bfbe24eef8b1a7dcb56ba4f55f185697129196b9158629d2829b8e54e0ff9cd63fc3a49d513716876493540fd16ccc089c815d9c3ac72eade67e25f2dd22e91c412b49b9f02e3f54bf29c0a59560195db7bc6228bba050c79c4425fff01c1c105dea3986d3ec4e8a803c16deaf62ee6440b5e485f316f7106e1a6a3d2b8786b356e6a771a14fdec7f86d960fdf781d92488f165d1b66d6704b66b43ed3071453c342cb300e69b9b301aa644f555bd82c9c71fa3a16b2468272d5ae06b1901ee3d2cecc1098f8b38f2ffcc79d0eece9cfe3a342fc1a29032ae0e0391303a3c62932d939fabf3fe6695d45631358f793fa5dfcbf2042dfdb71a97dda04d85cf3add66abeb57b26322aaeaa6b40bb335a3de9c0c5fe7996f4defdbf86e23cf1ac2c019346027474029b499d6f6b6412da68fa4097c5f5d9a8dec681c194d0825219786b3cf54b729bfc2fa8591794e4e48d27001f92ca065ba036a3ba0410af1354a46a38be7502660cf3f441b893f83ef8fff820b69202e45295b4af2c7ede03cec831709bef0529ef3a33a5778bfeb7c80b2315dd31a2fb2413789e3a1029de1c80d315fd5f178d8dc1b1e003a3b3b0dd04bbd11c964e04ab761feb0a7574172be572fa002603be8b6ceb0f993789b4bc3fe8724cc2d9de3ff8754fb3e51c34d1e6bee14ab433eefb016142041296c0e49af328b6b759cd5e419ce4249faacd8fbf7dab73e4069d40f235a8fbc41cea8eeb47f8f089eedc0d9224d38b9c66a7acb6f61b967836ed82e774ccafc4a09fa67eaf444c698c9338578ec12165d3858a7ff353c92b6657bdbcbec5a71b5c1a8d7a8a105bdf478e20fa850ec66f8debd309df4a4f676d6f7643b9a27bcd659d458b8ab0f84f7d78885a66bd5b4fad004b7e9c9b13af5a2152693266e4462b9e9c584080f8fa4bf2e58c856ac66f3cbd2951a9f12a4154aa403cc29f16f627c5e2e303e18b90a8bfb16fa00208cd5f3e8cc44ec270c04753ff1afe80b121167c5e548f4aa2c6456eea644a03ca6baadf90ce3e0a5def69930617ce54f2dc78cfd6208b7a2c002475c032eb5ad2402ec2f96a63a78d851f24ef9244cb79f08ff0325f201a1b09bec3fef9879e757f20ba68c7475ec2e25850d91391fc93801425781340ff2625c6230d86e5b309223c2ada8d4da119ae944521a76c3f7e24ae8a9c06c59d2202a412f0a4e154eb97dfff0c23b96ec36ca28d0c4ed909e41dcf61b3b3a0c2ba7efdffa464ebf7336b6aa7555ac97cf80a9066b73288cec38ba9d484863720f35a1330821548a5095f0d730108e2aebf5593089df6903dda71915c9041063ab62f38ea5f9ba4b5f2045c70ab0be4ea0798a5c3a711617c6c9d0e0c73ae3cf7acdc0ed87b81bcf6f73431f1be07d6711c1dfa29297bf9d840318d5efe612c41589292ef37fffa70a3d42b299b44c9eb2b55e9414c66d6c0279277c0f22d79ce3b70f132b47573d521e491793df1990c206d344f04b1c12349c4599f3795b4f75bb4697182e713be29db47f68a5dc0075d745586f77f5f755a35cbc1f8d28d6ad0e616fd8e835d6e9aeb16b0303a41caebc04dd0337de1ab44d3e4e80a9c2d75789a920d23c2720f1d5e08953f5db97836b72359b0c226fa54a9ee176ca0c8b3901f988ef12e9ede17d6bd3ec4eb3b764943ac629238d76ff0f86ba199e259840a4af0a9b3001848c8a2d2c3b77a6b65db865966b58d1dd96652d786108faccf0ce1a5db27a074edd346ea5c10b40b557532a92f9bb3e5049079b2296d354e701b710a17d1c9e7fcbfab2b3c0e92a245be6e2c8d3a414e25c63cfc843a159f4ddfa629afbb7ae6fcb6c41ca712179366a5ee14ea02484d30f4a785bb70a571671f9bf890bcfc38e71b0f486c00afafd21992292495091ed20e6f1248feb09778ceeb593458ea6d5b96386674afd98c04efd6a5cdd93c32885bdf1ee0ad3c80894729c3bef5e7fa266d86f9e03b0ee1aaa656b7eeeb2b067c2b139092a3a0afce03c05331a37b13efac3bef4d722f7ee57811f26287bd174bad7bcfb99ed870989696c75d0545c89374d7cd36782fd43323c5ec36e010ca9efd81396c06be4fb56472cdbe6a08c39c65a0f10d0ed5d072b8d56363c3fd4438102f683176b80d3c02563178b306123bb77ee68910dccfc26b2955d7e9b3aec216959caf114f5541e91bfd36d45a48f421f7ca6e5180ad40178d9959406fc0a7ccbd94ab2bd79952be4b414d4088f6a0ff1b0e38a3c3ef227fd3e6e3389e7895fa328c10123283a8e3a6fdf264ffdd03b31f5231014fb32b894a7b7b79b4659265800f85892629a1b59475264342fe2e74499bf44b5b260a7d6321fb2c73067293311e24fdeb1501a12a4b0e35593ef6e38d5b2e3551e695f2e4219dfd148061f250a006880a0b291e2b82a5b030653d2084e5fe181228e8dcf83aa8f2b563701e744eea97db290afb0ab2dcd461602735a4f308a372a7dd64495be00e1a3b94a593705760896e1fe6dc881cdbc57950feb16831e8f7dc5238089e003ba8ecdc642585b2439b06901d5cc51952703f12dc7c9f67ab99890a9ca578dd96edca42db9a8c2b5f4ef62391f55545ace7fca9d515b93e3c611e47f62d55ce0fee9318f0afd9fe44b7faae3bf1ac7a97a42d4f6b1683c8f8af49aefe8cf5611227654a160dc10532260b8ad1622167c55d95aff696ee38cb02e188a6666b7126b4ddb8e486b376fcae826139ee52e605fbde4071ba2e69262f64a18fff4163e4718f7400eadf7965b748d95c8bf25c1051af271be284a158647c7666df3fa34dc24317a03e8a67d01e4f888d3533fbb726de8c12d6cd87c23474527d8e8cb6bb4006e034535a49d66bc5f74811494c9baa3528a929b2b0964fe48e140bb20ce89ddfde62dd150d33b608e2729ef55b59e7e6fbfb6d53aac33bc176d74b8fdcefacbb0769c1a3adf492596bc295346b44c391b4e8aadfe72ac334fea663e8db82a835f114fa45d7d505f0cafa8698ddae2f38dced7847b931102dc3da122b88b6acfc84dad0d2c541a80814cbfe85fd4ea515d899366ee5a8ffcd222a19fb2952b8f701e198a6afb9017eeaea984bf3d3fb75424de0bff99c115d868ddad322b11e922e49d8382a003f27e09febcadee053e4173c40e813f98e6cedbbd864bbf6eb1bd17781acf248b5b353f249dea2b533f565186cb421caa66d71","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
