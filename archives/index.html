<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a57a15a7cc29ecd99a403a7de2d3d1c2d875531ccbffefbb979c5a40f107c1d560f05bf8f5313be9e7c5844fa500395c253b697be3c005cbdb3f45e78c56cb46a155e9d77b7129df5ef3189fc9593156263938d79639613b3fff44b4a3b3e5f44ab304a02995e56e8a5b72ccbc3ab647981676294ac7562b8197a86a6ffc5064d1f625d57812b19d42e928cf5f91999261c41fb764f41b837879296db76a7788e89c3884a2a3d5d1f257af597ff1fda12611f0a730bf6109c0a5bccb1af6771e1e67c1020bfe95d3255d4cfaf17222330efff9547875ea77ef561b4c8371d3eb71881a25f2b853165cf4454a875dc3498a7a06a6fc1950566df62e1249f86f80dd527b324c2acad251bce71d2e9fd8e55071e515eaca44807744784def7bc4d136bf6997bd3aacc2ce4a2790a3745183071c1b5c1f465b003404d63b06963595a2227fca6af5b297411f4e64129c1e3490c815441614d656609df24c3fb74c3bf831dc80d967bac1368169630e5aa850d7a9f412858aba858aedd1151d6ab4ca95540476b9677c906a55e79746d2416f91ffb9f3e0f4061f8b0bea9cec949d29be752e7365594356a3c461dbf3571d70a5f680f3068c7c9c14dc54e78490053f967dcd5104b07e8b2f6e10616310b8318464dc2ded1fe55a15de16e0ee52611e0740424b4115e7913fa1782eac5e874b473d7251479f4d44fb471cc0ee07f0b05cadc81f626fc65dc729d762fce6993976101772d395e5f81be6da350c0a2226fa6aaa0f0280f5ed9245146a63c2b323dc326b61b007f8b0f7d0aec865a4a48fec52e3365e105a4388d11ea29156a6e2fca395f4e9241907ee39ecfe35e4ff99bc97b7796e5c7401b4839ee0d7a56c6f3d463b51e900a280cfd46625945881288f7d87a9ff5109210e78c168e15b480335ac90327b9cc00812c232e64e07f40866c5ebb1616fed38b05a8d23c5b33218ea18d71d86abae727dc8fccf8ac6b7e8f6885b255a73f8cdd7a2363cbd130dbcfca9925aef38b4e4aab5ba01f6da84eace50b8ad6ee371387ca7de82b967cbb86ac28e06995dc1b4f3656301b8193b1d0596133ac57bcf5598f189b7e404ee2ac759ae52dc1572942affd6e7abdc18bbc6839f37d09e7b468bc25d14c29c904c009f1e8e2e9969b9005182d69efbfcb197b88f00d04cc726b0c795676ff983c86764d3050ebcc7a4b9d5300ceb4ba596ce229cb197207ea44a7dca891b15a24e3879e900ac9a3393db5f3f91ef816762b59a705c43ba876260e01af6d96f34fb0cd353afdcb5ff7e3d0186a1b455ae918bc2cfe871a3a77f35660148b9a02af0f2feb1729a61bdf2d95a412dbe9785badb4dd68fe2ce78d3bc4737d7dbee89e986879ba063ee02f100ba87b1d9348691336b1aa030309f32c602b6340df4a6a59153830d91c2778bdb79bef2f12888d43440adf7baff1ec75c426309f4974120bc23ca5abdf38dc21637784e672a02324f387fdb5b94c1ab0315d2d9c7a8359208d66164152c5619a5dfc5cd82b1e5bc79288a961d73508323bc1c5dc2b5ae1874455212ae3cab0687277aaf62c7235dc900cec22a20a245aee0bf3dfc97e09fdba7b63b7efaad6d35805e03cec6634be08f5b981aead33be44f1e580e37a9e60c22217015cceec10c4d449fa7ce008307f286e59f4bb2272fce8d90e4c7899be82ad5bc101d8bf363f384e027aec547ebfee67ace8cb8644d3139468d16016d1328884eab2e2d56a540f52de9e3b21fecbe156a8dcbfa630e000dcf9b2927bc53aeda44eb09f3176d24dfd2b6f285feb3abe07ba4fe47e26fb40115f8f50ff30c2b73d835f93247d10947f861c5bb7e4ee9f2fb0ea70cf3e3512a298b3d3ddf7d2e6e7e1b3e17c9da327afd7d6b44436bbef0acf56fcdc4abdfa366203cd36a48cfc183a59b338cae8081e92cce983ca144abb8c4fa09ba3afdbb9728241cbd99f39c9761288f4b358a9e860e0e990827eb8c08161c700d006263b64a15863b1c90d68b695c28a4527b5f8d7ad9d7b2990a9f61aabe5756909c28e032e2604ed1f89bfe764e109492485e3ae43a5b3be88693f4909048b33bf804f2acb1538b9f902b2d88b5df0188c51e3a84db5424fa8575f8de1884de96d2a44cb2f5e58b24d46ecd79c3eb5c331e8350b3a0652b4cc1a02e79bcc76507c0b8d1b2c8aeea38cf20bd302a4ed13546800e1279c4e678ee8ffb12c51ccb818adfb8d1f075d78f6f0ddc1bd0259c7539ca6d7ecdef0ffed71e88d351e63afc67cf97e4dbc92ddba2eace8ed96a103437b7db8df0580fa55eedf6236920315d84f8a928b042a7655a7ccd5c5540fa6e8ec0916d87f56d97161df897ec1b0cdf1d3d56cd0f5405ea24dea5ddf3f0668fb8af224e9726e9d57139d20f061910f346286b83c59bea89778a14b0d57d340a20d1039a2e3137a0f4db8402c2567c58840076de484775da1730d4a51bb6f9ea7a09ff2f5f381ec6ee5af37081c010ea4f8286e69dbcdf107a51546c645b561db9fcf5a95d23add24a003430a3b42bdc7655a37140c7086d8e1cf3e53d9251a0ec7dec9ecf0f7aaec16b24ff4d87d91e194d30459fc76fe731ef37f833ac455bd224637198428b68190bddfb70d35810e7a611c8c64faca9539010889d989edfa96f49565c40e2534c092a720fd5760f6a69cc38ade7036dcc405663663c13d830865b6c8993ad9bc25cc28631b0de7c6fe0b3637b5f7791b95ee6b143cc22c05f336d07b84a65d0c72ed574cc6b8ca78d2b93251cf9d3d1636146216b87785f57c65be4b0bdfbac358780f3302ece4c0d8217a4a2f5e2ab486fd8678cb0e0b885d39da28189be3718a7284987235bb5d8b9b6c22e7d76703d173ab82e6610ab10d3b57307908ebdacec0d47068b2868b3cf97158ca234d8e3ce159a6cde63fdd11427080f50c4fdb12ba1bda865eb33e3dbff7a4ab5fdc42b9791e0d6531f47e82d4160ab8e78df1062bdd44ca277d5a7ac409c67888ce0653c7b597deda2e3946a6977bdc69267f914c81a7b0c52f0e6dbc01dfd9854be7cb6ff969aec99ed4c7ea722da98eeb0aac3ca6247acbad917af33beb0ea10893b82bee3c597cfd1a90b97fb36f528f5e984034fd0afe3ecfdf73b2ebf7bfbec0e8a1edd0522edea7d663f9f3eb5610960791e40dd4c1b02cf7a9fc11d4a7e5ec005915fa23e13b6142f8f104675cdd21c9c29f1a2eab80b0d74016b2f426b399c5fefe95be60acd67d54d90eca080dd1f003306192ad69abc65ded8952f73c1fe94b7a8e21bfbb53dba804505db34ae84729a90db1d26c6e62e81922313c693a4c5dc956bd83aee3ecb9df081900b054a7f8e8d95ce8845bc14d0cf10cfa76e70ed0350dfb8200925bbd178b8336976bc4bfbe4a181d016ab20599cab066abd8b3099ea92bdd9b036cc3c44204ef245e0dfa9e25003c0f9912ffefe23ae5773a47a3575f7c48b45b0bdce69387573697489fdc1e847f1d6f25043e2e6f567151b9cb9fe81f31fcb4e8de81119a0314c6b48eab3c8252e64269288a9955a80978176cdb81400aed5a19564e31e853e434e230a7c793519cb5105677f098fd00ee7c39dc52b28489bd700a27148bd8b1001a1d131e5dc0c5490b7c83b1efd4e2bef1fc3401c1d60b59878236839a6727fdb962bf6fe0d1c0ebc71936223b0c1d3f19f0e787a89f984514cfb47f3f4e2bae846c295141ec16ef4b88d403475f7cec9f8bfc162a4c8d84319af449a225fe0523bd6c60f934b2d28177ac4db44af7b24da038e0ea9a8bb9df9e9fbeeba743c4d20b66ec0d0b43f12e18ebda8f43d05be916285f377f59bcb9f7bb5d004e25cfcdd9b38f0601eb6f6008af8e5dda60e87cefeedfb801a3728a46daf6712a5c00e135f539fc50ac5353449850aeca4932834f16b402f9e9144ad6b3ae25559afd872ffaf9d9015edbfaa991946994f2d449905c3439e17bfef457dac0a130d0ec3c6b927edc080b88fd64621b7c7298a6441cd641ec0b607bb272a6780b6bb856d36b18879aa6b99297ee08781cefc5ac33b72baee686153c34db382c4afe8cde8f5b0782c3e50f83272347cc927120f3fa39b525a7b5443920164353dd5867d1c4e718996c75a5266f01c399daff8df9ac067f292df622d4014f80780944124dcf0a36b3d650b93d7ec0f1395ed81c2982fe7d7ad7c9ab2bee12aac1ff4f0d650cd797418d7f968dd7c983e9cd0b2f54f15e6e5c4d1451c893af3ca956127155d4b22c90e5cdc789ed940c8dd3d9d99cc9b75c7d9ab2b82693022c1d800d406f1245de23d9f97496e38e788c58430875f26213fa4b02797ba124f0b6015159e7db8f93019b7ee712ebbbff7d3b7d368006db7932adaf9db946d9b607039c9602223d085ca1e6d76c1ac5a3d5770a4856fe967891b52e70d22254b09c0c678e1c8937bba716bcf209248411f68df13d37cb9756876538f0bff6d319b1e494c926d786f5b243e18ba5fcb87ab3c7305860700ead8e1130c81f0607aa31b98d191e3e167dfaaab9e3fc28ae40c96a56d9cd5e0f2aef49a004048fb257e07d8b395728223e618c63790a94cff03c005d2436c7185986588770339f493c4a877189fa7cb583a454e3944e6e2543236a7b2d62c46b04d5c02c886db98774658da1eb084fe9fd8061b6e466832c542ed8b452fb080adbdace10dc88a6318b2c4d149903fb4897d83587ee509a60be73cea2a624e318ae72f4365abd24f84d80fc7819451b2d2a340e70e167562a73e52b103e5f52d19a0f1c5fda595f0703d6ab6503b8e824eb040f41c4b9d08569093ac13b45536a16e4bfdf36b9d6a287452b4d841b55aa2050b4b10f1d663119965be66c82b2819d18335e2faec12981bd8604f9fe14424067256e163e3e6ef7e7e508baeeb1ac89dcf05699554457d4724b1198e6231c95050a9879ad06561682b2b5e82a904b0c7246d46db7266a0dc5efaec50a1ed4e4fb79f93c40baf6f49120d4b73f3278f9b18d3245dd38746d66880cfce7244711ac6f227ed964a619dae356365543962ed94180259e97cce68f9de4fe8446f7034dca87e7f16d51ae93f6a350d2d56889b8bce377340b771cb6815be46ee964fbf4eb429eecee7da13c5458ad8ee37496a5eab39b8e7fb77d98e00dd2903829741db28b4d17b1a0a4bd665737ddb09838ce363efd0ba74662ae6093792a2e30d2f2f2da9cfcd37a153d246f7d366ec6f4b6663c981754167d42a3a7e22fcd35a8aab864f6709ea9d27734f2b963eb19c68998c93ffb4f1e8dde8d349c99ede85ace62747c1a81df9e41a3ec6adf3316a270f75267c0cfdbc3a48bf87fac36a6e96a0fb2c05a5c6983c7f42f5c41aa0f25ae0d691d7ddb5c83b060f7ae9f075adaf7b18a0770932353c2162674e6673376a3423f87aae7a5174003a3b39d3e3f97e50e3bf439a82c58720b2dce6b61d44ffa3ae91f9fd915fd86c6866298771d3905814f636c142ba2e2988f963cc7ac2861026b28f3db1b604879469324bfd53df241c3e61aa4432427e40880f02f3f0ea8fbbb19db7ea1bc37a6d6f24a2736a8bf90116d7d37d830e25d735e2637c29b9d4ed07490df662621ba49a86b636fd7fbb2e1d8e3504970423f7047050cdc096f0f43f59fa9c5fe2a9a9c490933cf2fed3181fd796c215fcada70118f78d6fb51c74c478b5f50bfe2c55e4a186abfd984d30bb0168177de1f9e611ebe1b70e26a1c52060c6e5ec430077f97bae7abb25ec1efb74e4625271b338062af9fefdabdfc8e06ffccb726f9041cdc96139a136a3bf01c8f80476adcd01b2bcc3f19bfcc1cfe3900522cc3e8c2b5cb05e7b7121d8eab656f92a2326b15f7a846b4cbe71f6f15150d46651584440686b570b7d64290e920a25b224e4f7ee2ca83eaebb204f7539ffb284f7a69683d69eab558650fc5c77048a212123eadf84d75b71b3163f07a9673f9d4a25b10902109e8a96128318ae64f09b99e937a03b8854610cd995bbc7cdc377a86e65dd06a52bd95ee83c6dd4c2a7fe9758d6196ca6ff0692eb6400abfb0026fa87ea15e1ec784b0ec6deb57e5b004c4942379a9f4a9798eaf50991ca725c91dd0235016dbee6a7a8195904354241b01c5bcc3c758d3f0bc6844cf0e4fe4843968fe55ee39fa19364fab9458c7519041ebcb37021a085e0766e0cd6d460b55065421242f98dff5f4e0feaee7e7e8bb8d186c1c867ee9e92e0f9f8cf92c7d71264919fdf1bcb773197052036750f5c817ed4dbedee55e56d36744f6285452ba5072704207011fddd95811cd0739248fcb5ad194fcdf163e2fbb9da1c93868b0a6771db8f5e1bffb1b9dd09aaa861d59acce26390f85a5d32f1049515e34bf3f1d4138b31c457afa24d2d630bbd35d2ac55a0904673aaded44d781b6093da3fceed713ff03d564f8e319a42524efeb73e914eefb4ea5115c25a0acca0cecf11e787e376c0aa670e5e68542354481e066d1eb301d47f762a891fd632d2f95e94ee2f6ef54cc2f75e7ee09091305770cde5fce72fd6a9f962fc31c925397f9f8c2f5800ffd7128e13d403156c791e0b962defab80d664fbe0e845d6f743b725efa18fce9aa0afe5102bc4d7aed3382cdff2d3abe4d029430046e0ff115be99b844d72ef6271031437b7caaadd8e180713f983afce7e3f6d4c5e32a7d83b41aacef86fb8ba5b665141fb9ab8a288930c72bedebd3a65bf259438c50997de93bbb7925369e944a53c7e37737af1b1d3efb10007acc6a88da50cb7bcc33b1d49666df354fbc3977aede0a39dc4a06efcb6935bca278928d9d951d2062e53c62864c57275a9bffcf0ab900b49d7960c10c9a9ab61a81d2c19b069d0c85a86a51e24f3003de567907b18b8b7a06efb2427bb31e23b01823d9ce7fe80e4aa36886f27cdf9cff363e3e17f757c9dab953119151ba3b2b63f5b44cfb2320eaec3c601cefe4fc441bc5d4123c8e2b9626539508c00c945b8425b97ba54c0818be1b1806a4a54b155382cbe888157a1d344028078c8cfe3bafd83cda3c539a113ab4735053fbca496f8aa68dd59b5e513c4bc6f0eec5a4f1baa7c1344c4b467073d5738ca4bd3dcd13ee2b0d4ed9f2c7f056d68e4fe96354fef1ba1b56f65d56e74dd8204a38b58bbcaadfcb1d43b5fd5014bee9c8cdf2d2a859acebdae94af342bcc887cbed529a1abf1f31249f7a557773b3a34b46c492ded5cae04012dee313d5bd6e77156fd7c4b075cbe251f3672e7f3560fcc5ecb84f6aa0655a74f5d10297a5b6389b7d06cdda8cb52846cf82c690bd6d12d6d794d312a05b35e23ea15c8ba3179de960ef9bebaa5a9b874226092f29e341311a91e7dee9392c9cf6cc0f54455247845a4bec176fed3611fbb792998332c3af397e2b546324df9a80bcda0da5c71e40a9f57b74f0c5f67d723ab9430f26e24015fee847a52c931c00dcbb0ec9b4c2b32e39f69fee104b5010dd6d0e53e5c0c671daaca23531a1ff8f9ba6359b4b89feaaecb354b32b87115d80326712de7dc23f1e06e4376a175702c1b6ccc03983c25bc1def30e114cf36f119bf097255df9fabb425fc67759f473933b25a3ed64c911140f1935c2e13247095e7a2aa29f54bed3859c7e7065a9285ae8ba4f9e5c12040aadde7a439508a227ebe97593095f31b0dfd72f4680a16c00a72db338064a6eeda046958b68e62af7112a22aff892f1a208d8a4713508e984b48b9e12644bc92593af9ecb288c74b04fcbe1226860eb658e1604c4dd5e12c6eb94f44610a00678f4a5f6c9ef57f07aa459e533350d3139b77c12b6524ca7e8cf718b3154e2a639d499407a559bd5797d23114b8864e7cc6ee5d9d36b35edf9b85da669098a118ddf3a0e7d57e618f22bc9cff787d4a456d0208a93d8ff5e5ac1c427531babe6adec063d3b3e7ad5c6324823da7f3a8e617028ce1c9bff208f8311a18f9eee7562918ea09f330a9b2d6c1a116d9bcfaac8542b55cd233bf4b8a9b0fd1401d7881e89e54a9dde1f5fcbf24b819e911360521a04788c876ab16d63d004d9acfd21d8333a4e8af94ab19b8b211ba2a90da142627fba570ff59c09f7833560985b8824ecb1b9723f70e2618c5acf7d7899d7ed79ca6a4e48108d5065329bc576f294e36a1d01cda08a23ae8f30fea96667ee5744ca5e72b4042d14962c5392718bd6dfa3871944fe6c46a5e8af8981ef3f49f78f868ce71e834a18852ef11432688d5cd9a7698b06f3460f861b668d788da604bff5f8519e04aeb20d78329756e6432ac0e32ffbd86c70074ccc827df30b415b89d28570f91c3a648fa9e22228291e6885ac6b90588a3b1a3b9b298dcee0924bd36aff71b74bbdc923589f980b765eb4eee194a87e58abf8b736bf57279cded782eedef19505c11d8a7a399c8a037e5fc738ee2f25a957fb240dbddc5df9848890d628eb79d6ddc4a2eae7381479142b9e466c965ecd4a45a3e31ddbd8554b0c05e130d5493bd085c9c04d400f952ccc374f0f4dc1b15875fd734ffbbed6e4c5ef48f4cf921e8924c26d052eedd65107d5c98dc69b7418bdea063681c4392c74555cb5becf8328d7dcfe602de72bc14f89cdf61334949b7c9c396f398d69a2468e3b6d67c091498b73f34c688c9ab9d15abf49f0e8c853958a126337bcd8338202fb4127b63005c39d61801163114ef843c6cc0337e598c16b61757f3012a0f683c8c1a6a491aaa4916151a7ee9a7a12fa5d0173a742130ffba2fd44e489c48828e6f04011b523ab46ac63a95954a39fe72ee49b3ac89fdd7b28f7ae584b096fc788481cb14f9d07b544e1c3c4220f49a89d76bd975e43cb5e29b95592acafa1272f8ca924d95014f597f76babaf0e0d2b1ee87f2ff8aa848102178e685b89d9c0ef4db58c269b6601c4faff0c9bc3e33c73960ce4ae286575131b2a3e464233062e42754a7d6812ec7748081a0c83b4752fd13383fecc1b8ea8b6c572cc4db4f88ffa8c7ff057f3a1bf926a7fdd092bee8589212d80e24b11b509d8fbb4f0c9c37d35a046ecda4a556bb21431300b3714575fb5bf1798de54dc6012c77639f38c06a52f30b5538c7dfa5a394e03aaec6ff0a1e94329755d0935519abefff8b4226714cf6f2420b0d509a9110e96e6068210836787c486c896026c3f3dadbfc048e783ddd5a911257f21e32fc148c626f2af3d7a2ed7d85c26ab74621f15316a244ce2f27ffcbc4ab30cbe98cb32c8eb050514d4bddefc95fa3177b0a85940de17a8cf25afbf6e191bca01a9d2bba8e0cab2f6f355c7d895ee6c0d7bdde7e8cb818a07669fe0dfa8a8edadeed6b1215e732e20a6a33182253d97c793aed438c63dd9760fd603f2efc9028327e4a91838a619d54cb84ab5d98ac0d804fb3d36c2c935f6d723f58b375531ea54468d68c33ccbafb057bab96fc7cb1555688d0658a44488d2819edc5f42988f31ebf4b2d778f2b5268f3242a4b4437018c197f2814c64468e6647954222d0a92f9bb98287daf77fab868be4bd432f569a1397c2f3b3f458757b705283f7e891cc17402318998c830bfcf0a2633012d2b5febf6e96b080d35d16a0defe68a52c98737d7935f16dd74c75b62886c2dd8f16845cee32a050e875263b5bc9229e4fa7449d3c2b5b4a9979770e6b63015ab02a464ecf783fde8a523fe1fdf95ef2b2c9ea6d6d7e0f94c120ea434238df4bdcf85c805d2b0e16a7d4393ed3b2bf836e4db24c25844577039037fe3bdacd2622f5351e70f1f698df8008b347dabb1a04e4806ad5cfdeddd318e135af93083856945a650756cb93e558299c5d2eb827c69c69555bfef5e5ab770ee6a924f14de0c1f13d549410f7c7527333cdba60255653a49396c1c0e205d6b7a765529ee13d4fe6d584a594ad31888e4e04863df09a5fa99c9a165ade6bffdc01b3c17ded54061dac2f2030ea0bbe3f76a216c5844fb06981255a4e1a0f50afd002404fd8557bdeec90ae43b8ab5292fd7976b0f330ba23408987807d28f94c9e709ccda2b00429e9531e5a6dc1de5d8c2511f7bbd8c914360eaacf0599580c9fb7fdfc5517a6db170d3255c45191ccd10b434e08e44a29b686f1308ceb389612e8c8c2f7e17da160faa99bef9a9a8c5812e1a3ac4a21ceb216b8b86d45bcc96e274a60aa4be5f774b6e7e8849121bf130fec9a0b27192976dc78692f3a11d18ed7d6796e466108e31386ee2398a559caeac08f377c541fc423e01dadbd6065ccd35709dcedfbf9ced1a6be5f479c888869608d6d35b990b8b868c8c4ff60a395eca013c4da1d0a85c89fc0292d7b7e1e55fc1b8a23eb2d4ff8f3a4ab2f90c68978c60db884780274613d19b2b74266f57a6ec7824eca33ac9fa2b9ab3f3090c595262ab870c5d6e373091232d07d680366aaba6261bc546ed30a207749e6f4423666da4010188ac937fc6468a06a4ceaf7f119eb56c994725a33d038fe9ca6b15d16323eb26d17c9708bd4e5e6cf30e5403b8439ca94d41f9348a6274e77e26d0e7ff22dc32fb3993b8d47a3518da6d5f8d22e4707f3877955fedea1ad8088f84f1f00775a73ed8d9ae2250e34cc9bca64205d2766dfc8be9e717277071e699720e122e53b6804571952eb789f3588d38282eeabe3953d56aaa00f28a84a491e3de445f9b9af8b0f683f9b14fb35e295528fb9e4bc7124135b0fa6a0040ad69a1f490a4348486af7b2f0a4ca477f476aba16bc6027aaed278c8cf9adfc558279a1b0b45d81cf2df971dd3f0406baa2012b1401ad2f7e13d661958beb933a2d53dd01e97c43b7f5d9dd55e6a9d9d0d56d1aa9facce6edb48dcea14860f4c796e9fc2c676ab71ac544db72cbafc97e58ef69a2176b714bfccfe0638ec32369aa9c65c593a46260c9f44a2a7e7a3cfb0065e922acdba6bee0594196c2cd9ef99c6b7f16c1c5cd55f6f56ea465b01b7b6dcbb0ba1dd296a8340dc6fec9b65985de4464dd91ee538fc16091783570d6e711e2932ac80cc0d6c38e2078c7f5b3365638e3959dc33245a96a899bccda45c12a7f3bf6d40e5af3f858e51cf30a40593e7953f0811278609ff64433ad648eace0340ec4fcbc8abf5473d46a1f134678cbc711d12b87efa2f916aa97adb87d157e73558ac82a57cbed65722b6379df1c2e15823bd1e94c6b5022729af46d3b7ff3e91dae6eda1bfdb0279c9d911deca938ce74856ea6e2ada5325cd1130877eab58aa253919502d73a1e01814a32ba2be32d95ac6164511ab95b0c899fe17a5f00c204cbd4074d151aa2ae69e585ac0df1ae66950d9fa03fe4d13182ecce9937ede0baf06ca31c2f6c54866d770c99aa6dab0c146fb32048e168cceb5cd7347802c0d4e135bf51ae49416f64bfc8f2785669fc73e5be19d9a5a72912b3e9323ea6dcd31cefe814f859b16a2b86676d3adeb26bde8f0a4ee1be03a33165d8f6805e41c32992e25c26065316320830a338820b24c6dc17a13a1f17d60999718460a8eb99a5a277ce8a024b5e8df967708c0a9c0fda68f208959e0edeb26f9e77705a0b9c2dfb0c61c2b79d0e7d642404173992b6ae17b8f777f210565bc5da373cbe3c6cea7a2f9159a756d1afdb14c5d8dc40d2039701f4a860850700d97e478b8d6b06e458bf2f2cb407aa816019e028849635cb0282783dcc18f019b102c5623b5090b640ef328a1677bf9997b3166a97635438f50a75558df3199a8b977df7a99700f3bf541b32bf59a0065860b1c4138bbeff596517dd32458bd980bf1208d55eb7960ed41e2cc4282d17e2cdacc8ae3e192417744436ae2579c0ff4d379c8d0435d2cac8c547080f9fe1f5c341430e407010b77e327ffbbd526bb4bf4093a6d8a350601de1f2bb49fba97397e912165bd0fc5bf004ef3e1acac6733cd2d0d3896b722ad52846b8ff31d3d8f801f67a3df752248b6965bb84e7241aea76fb8f408de6ad56633fe7491694d163902d427edce04a2c75e84484f2f1156cc7ea7aadaee1812af710e41e260a359837d73eb57c194066a040e294d78acd95404fddb127b74a7e21bec3989d31eb039e77cc77e99870c394859157047ca42e1fe80992a2d5d66ba767c508ab4aedee2d2cd448839396bab7e0d788afd68174bcbe11a6b11ca2d2fd23064aa598f7ce97bf06a3ff135db017d955a94e3304844f3dfe8531070b4954265b7a1e1a457366d912aba318501d016a74b3091885b05a245606e2dcf25ced36b1bb85f1afc0b5be231e9d2e0626343d86643d16d13c574b870be6e255d4fd7b2df32ef60f511de07b07e8ddccd4f3acacefd3aaf056ea270e69d34d6d36ed9559602ab62c45e4ce02e67fa2e09eb763b915da3727ffb47315f12141bfbc58b9f51478f92cf979b2a057ceac3fb95ef3180d7eb6fb367d4f25660cb4899e8f537c525504a6e115d4ef8b69c6ff6528a53055603fcd360e91834fee3295af617b87d98e9ffd0b0e131d40c30eae2573be1596892f97953517064dfe1821597e8500e37dfac0faaf6bc80a7cf922db0f03bc3244ff221bb796c92feb5cebc44130747cb940d05ab9ec7cf0bbc6befead0e4ababdf5aef347be8ccc4af90b1c1735b44573e8ffd0319c9c5dc486a749d27dba77e090969a1fece011386503e9659cc445bd31fb299ac9300addc11bade668ca5e01a0972b326b1da9bbcdeeaeec67d40ac038a10d64a9e0b52f007ae2420c3f0b65c4443b66af3e6935f810dadc2ac6f7f104e02f1b7713b5e1e0c7dc6325e6db42754eac161b52fccd159283fbdc1e0b2843caaa5e7c870a32fa1afc9ed33d95127373befd8e13296ae1121acd367ed0aacc6163cbc95daaa4a85c62d5e2e974d20b80ef77fcfb1a4ea6d3bb2483a73bccea5230b3f6cdaec92048dcd81db66aab08bf38f2fa307707a3e731e8f4da391067c929741b780b5dc0e9c3177b93f20598f9c50a8a23470618b84fcb68958dde3b871b6d645a352f1fec729d6132526f39039515a597924f5eae590d1ccd075491fa2f9882457c0bc56568a76b82a55172738372c3c303e42b98f94e4f3c531105d7a2ecd81b9f55521bd679f0102de67643dcf41f7af63fe38025f68318aa75cf2c1d45d24ac28892709986593576d78d13886f124f12c07140ff1e18ecb33821b3c9cde369a8696f2535f04aad3fbf4f660585c48eec22ee1aa5ced0fceca4edf94a37719e60dcba005b6383a3e4ca0da9973ab1ac6f9478dac995183b834b1bf723906905d788891b88d9e6b9ee5d5b69458bf49ce3246b99157925688fa95b8b9cd5bc0e3dbcd957d973ff170d5e6d76c1135837438f187e98ed99d56654a9c4787fe0b1e15c2325ce9cf52da36743f74642f17c1008c0a1dd883643ea2345be8bc551a3cb8d1d186936ab2089894b4f7aa53165744fa700335fe328c562e7e58ca0df7969862c6c0451b26bc18c96e60ca2075804cff5e7de7c222c6dd90c931a99b7eaa76bca28923764ea6d462b88c8cbb659ffccf1b0f7ade3837fbc317e03359ce7a56da1ef8ac22354f617818efc0be0306b4b5b8c5ec4260beb7528fb0b6321d25a3b61112ee1885d4eb08cca00f374f642b0c303d8f01eb8205f11cfa245049158ae2edc4ce4ef2338ec074168787d21a30668f8849bfbb6cbb79a8fc8f532edc14cc3fab407a7af21c832c26def04a86801a39ddaeb7f84a44e0a991815f0485cce1c90b10d0343ee60bd104e9c7bcd2e698ae2620ba9c50db73d8769baf7fc0e448443bf75444ecbd5e255ef04fc73b961b6ede73c31524316605081f355bf6f7138831f91b3b30eac1a44066d3ff310521671daad861bab6c8a3d1e9d444e860e6ef5edbf45b4c7e01e52d2efbb6e0c6e21ae989c80b1932557950fcdbffd20a14b68c10807a23d39dcb66ac3d597fe104894a708c66dadc25640dd7b4fa5dac2eb2c55b5726d968ca2d63679ac4c1326c276798d04f6cd54fd82fcef9ac8a4e02b3f3aa17a5c96094fd063da23f4f90adf2f85e52bcfe3ed9fefc0948c2196970626e0d1b6103f79320762cf18849251953157ab9a51f480c40ab81197f0e8eb7898400a576a13bc00bce01c2ee2df711886b8a152212d00bc7d2c6543f05b63c7bb3f85efefe829529e5454947e6571c4b73355c0c69fb21e797e3e6f3f46efe2a900596c48ebf4e093dba6e2cfe1ad45c2229519da1adad3c5ad57fd0d2ffb197b211089a32407dd48fb500e18a178a40c7379444365372481dd5752b9c8226db7c039167e810cc493dfe885e3a0ba249de7cbef8929e2ccd10e36077cd25ba5c9ed01d4ab29c7c529ed35858fca5434237e77ed29a31acd207508a6b17b4f0e239b324b8c3df6cfaacebda47ab5293b9c88319222b94154bd03bb77e22da5687c99bd7c30f7177266eaf07f97ed5db7ab0b4c45feca47720e8112652057b1131a824b9172b1033bca2f0a7883481641dbb4ba444689b2d5a934cdacc5b859872d67a925bef107cfa6ca846502ca27e0326c1863b1aa3448972249bfafda65875a925ee53d60a32115cf94f2e973fdce34132581646133df7f4954796ab3e9f4de9a560bd8c7b20caea58a820544ef11bff5a1ec0b58044b6ef7b674967c1ecd3968bdca17590f5f3db9927d1d48eae919e6105add061c2e5991de8bb3cac07ffa2e4d1f4cc8ed25093d786bb934ba0d9e6b5e923ece9226c35983befea80eb17cc34ce44ce445800c43341979cc5b9923ea3aea426e9840b7aa80e576b9294ac40bb022f187a96fafe3943e6a4dea32f90dae70125600cb53d4b9717923131b4b2fb1ebc665268b7fb96e5725a2f0b53135e6caccd04b084ba48054d98c9dd852d7cea69f0200d991f7ed96c56034bdfebdef29526d565a7d86558c4a682f3a8eb095196525443cbd19f58edee48021f77fe69875c1949d171041aa89ad24e7b6cfa5d99fa385065625bf23b12877a9decea77910fc724ed613a8b6160aae80ec81c454dd2a1987de50907fb24589dec864f01237a15907bc43332ab2930587a22789cc1fdbb25bab263aa5d70afd81fdf33dae653495e3c72c734ad927c7538c7a490a170af4b2147d09cabdfa005e26ec0b6441a7102d9ee9c60f72ed7cac6ca8d116e864619be97ae4e592b9c3db2b03e26325bb58fc4c051f9403a5ac269f0f7a276b4b292c6be8c32cdbd43c5a2c7639b1a2d5dc535213af8b37f78251e0172ae5136f3d7e17206ac16e3df1f7b92155e47d0722afd5cc3927925f193c54cb90690c62b0c263cc736026de7e5c909c6a4e85889a25570960ac6ff92eed09e3177aeaf09e919cdf3898e97d2e4203c433a6961d1fb9eb2d6c8f48ad6a36437def99e342126672ce3100d4160379394a440fd0ecaefaf1137f3ac0776536037ee0f5a88a441c6ebb3c24404459ac87bb0fb1b86f3cd91304e2b5076976832d54951b46e09af3f99beeebfed5c7b0db26706f8b2cd0a776e6e16aa16abcc0e562a497f6b5fd9ff733994661376076fca795cce8584b45fa154bbff39a67c487e2a894eec617af0c6dd237131dc1e134a529c009c8cfc55fa79b323194549c134b6cae95c23e92fb9de5bca2637c14a7fc37cb31e0e42da4f499c3b10c8fe2cb9991b943fe55984c26fb93a2616c99c72d9f4b530f45eb3ab1ca748cffbce59589e07089876a4efc911a58528e797a4853e6fca32cf871f303daa2047526a7eea322ce85494a6c5ba535e4e564926022c1a32e8665f5786a09191c64a56a971755cc224b98c82a7910b5a248f677aa8232ef572dd654b18fa41f4f8dec56586523c0d8f346ee2e81a619ba2588ab0b7e3b8fe9a30e11efa938993e4acc1be3e5f4c38b8b8d42287605d8f7903d545e9bf482d101e713ffd1f15b827ee59627d115a19bb7e65bef2a7d027d2a1b1fbb811bba0ed1e194ffeee7faa693a896dc43e05bb30fc2a1342c5597d9794f3b691ba036d3714b0ba35de561b6d81f4966f3aed0c6e1cfafd6a9cadfcd1a526840f623f154f65c708f37d3d082fd0001d16e58898a87d418d65aaf9881657d7a528923ea619a04020e6f099b8cc8987ecad7b04b50d0500145b3de89ffc25d611f6d05a6e8cf8d4087c165390f4a82e9c7712f3c8e12c74eb43bb3da9bbb7a98276a97e7bb65dba88fdf65c7c470d9ffcde71467725fd386fc35ab178e624f720c8b557c7497a7d0c0575ef6b43bbf9115e4693abc8a803116c8eec0eedb2d6481861f9bcda0dc7a1174a8c96c959803c4de2365b8b2fb8ec6f99700e5020bd2d6fe788c3dabccf9b74a4bb44f15e47eff3cb721ba3b7cf905710a220512c178e5f35daeb3df7b8932f0a71a1996cd9794e50f6ee20c8b4c9719204fa092ac3e3d305ba8e89a25ceb156a62de97c9d7e24e0a0c50eb079dcd3bcd9ec242a84a5441597072561c1bf803016aca0c0b7375baaf35535ed53737784ea0673749e56c08ac0a974bb71da93cb4caf99b61ef50f3b44a11c2685e4efb092b4a2b0f2041d47786259d4e18d80b4973565a505c7e9dadcd366d03b325625b11dc56753f98b5362c6f100a339b5e27a13ef0ce1ab84931df6b6c4aaefe0276498f5e989b7bf4b38c6f4f98af7794ec2e087e8d04b57cbb32fd40b14ca550f41298ae81769ac90b9159aff39f4fac73a2580cee73b626900831f682196c8b69629a25d22479c8617a958d428996f7c094c97685b32ea851b34229b8ae7ebcb92366ca67f3db4a296a2c77210644b33b83c6b64cea72471012ec3436f16210fd8a4ba7bb32949bcbdddbc377004422f702e78d25f66b667f3d0f6d5940fe2d8241cc93934acaf29e3f1fe51308d13ebf82338cd10d21a77a632d389b2e91badd81a7e48bfb18197e2cbc90bae66a00915b66076d098ac22a71def9c9d382807f6c9ceb5509eb9487e8b7fb6dce9618f97227fd1282a98e27b4572ecb319d027c24b0c7b21fb1097b33d7f745cb88ead154829401e34054fdff898fe54da5dda2ae3ae9af52158aee70d41cd3f0b85fbc562b5dd34b97ac845fa6389067056a0aaea521895669c04143f52e7f14749f7fa0cace8a8b9ff2108c5e41080b4f9c754b39c9ab05d9edb66ffb1d2e84c77149ca918b866d0897806f77bb2b63ee843a1315363741c02813840a86753a00e031345366bc5bb55eeda1299ccae7a1a4073be50eb2eb3491d7778ac9660e1c019689fdb5931395b1ee7a2bf59ace7bc09b24f92625826f010713a8fee6cc9a05911405afa49a40ca11bcdd69453ac68b9c98d207cb910b2e2b39a22a119c692eadd33ac318bec1be100bbdddaca3fffabc0fbb8f2d0c3a062b2d89527c65dcca7cd231fb3602a51c5b978777bd971c00fe20db1cfd8d1e6f6aeaa1b5a79db8503a323fa27de86fea74fdb84e4ae8b8ea3cbc467eabd4ec09982a37891a03f5f65df23be1e1b1c9a6dd28512a74cca313733381933b6e54ff66ba89657cac546730eaaa68ac74f25cfd4a75ea9af840e730b1118b489e33c242b979e87c76d0d61e130cee71a48d98632789b568f7bd4b8c58d2f6d94dc2d9060530893aa93c814ef44acbe35dcbaef9bcfc54ac7a640f744869f13840d1d6b5a6c2a0784bf755a7270a4a32b1452a43cd97f241595c5dd27b1a4dd640a647030b4f8774b9ab49a73e3cb64ed6a7630a88f10bdd1c06aa6ed8a412bb2b59003878e714ecf721236412c9f2dbb8c67d350f7f5a4bad03742da744f4d6ec308aca0db665046fa411a547aa3a691fb87c6a32e6e84f711ce0fd7181b166a12f76f063382c710eef5f3c7daaeed43a77d941b521d689db78eb7486bbaf1048f54001c327fe3d240cdce7925367d7f4c722b41d881975611e9c1ba6de153717f0ede6ec7a543888411ad085f29545b90b70faf05648437f2b2f5bd5a1bd788b03f598fb6388e670bee05a3278c6b94e7d263898402c3c75190b1c27b108c21dbd909672a3a7fe37938c64aeb9c1edec3621c045ab1a6b8e6e10aaa92da7a2c346728cc5dab31b819cee90d8c2b60aebc20920b633ad7e947d539241bc35f55ed41b1e2347ba5523628dc62525427cfbb954775986d2d963792541c45b304031b41f47fade4298e8cfecb4863201b087f44fa7cee22c4df1a313d84e420c4ffc3254bc5e6abaf1e5414f367c0620a8d8628883f7a1254955fb3fbd9270a2acf51a1e79a4a709d5919d7c099c3f226bf916b9f62542e4f501086ea5ba1963dec9c390221d23820ee8e5ba6d877f59275e9f6198e71c8dbc04128bfb295c584a735ad5146fbf7ebc625cb583ebaa9b2b8eafcb4450f6a1370182603031f5c098178eee8596d43a9378b4f4bf8e5f0d78dfb27cc3c9a9bf38b6fd3e570476d2376066f167ec61f929bd1bb7fb1ce538324f53a06e4976b44edc111af2c36a2b5e59e9d70523862228b154275cef24714e6aa140b8e99feac02b1b50ab98f78b2d050ef6544f9346b0e9869ed957956ad1c61e9dc8e62ebf55115ddd11fc7cb2882e92dd3470c4bd7e880181a576abcea1a52997f66d175b8c64e458ce8bfc964992fca7355702dd9eba5e411ccda24484534ab882739173d43fff7aef1edcd5f1ed0e844cd857301921cec31aa36cc5b15cc3edd9ffe365adfc0a974ab8c80aeaef953bad02a5c1250b3e3de0faf2e28ca8deba3305fb913d7cd1107b87a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
