<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a78286e06d26907778bc7fcf5ab611fa637197055a8f5fad010ef0ae013299ecbb5e22e3d62a2fe5e961ba26c34df45548ef21a03c730b16d0ab0dc66f846a54ad71861cfc817bd00a7042936b8ce2b109cabd2e4f26dcc66824f410a4d14b2d02c1d9281e970d825a7fcd6f13c3d6e9a09fa040755e2c0cbb8fddd3d8daaa4454aa99bef0a79c256230a86505c745b8b5c9f2d2ee055594afa38a98536080705877075f9bed44bc0269e341df7efb31701582e5a2e42780467259842f3908d4418dcb3ac646b9d778ecc574dda177346d93da353b089b67de16ad5e54742d4993de0bade13fc2f06cbc9fdf10e5f0dfec46feb81e66dc44a9cf7fad31ec015766880fe934da4c10a2e25cf3f99e64d87f51fcb698e6360f61ae5f8b9ee4453bd88da444db5e9bc90d5158742fe7124d329fd34e63c65e6d888c08c9d99efc957d22d812e4246437b74a9a968b2cccd15859084697003400346481940c8d514ee4bff9f5b637ec3a11578b0cad6975fed9057d95ad0d429e416813074898d6195eb4d5ffec73103efec50c05533398cc55c0e28cf438ef5f54c7c931f48f9a94db21cae86eb8ddcd23208389af88e55c3dfe05a5c29eeafbe42ab09c64e596d60b85494816ded3b78baad7c12defff1f865ecafb51391f6a5c143eb1d49117d8749a998da82bf4108127bd4e4db452ee4c09c30cb883f028ee379a69560e84b578c0ba8e720bcba9b18d20ad8f6da1bf9ce2cd0ae73c54e95c525238fbccf69eff4c1826451b8208a86d6a14f0f365edac2db4c9be97e08bd1a2eeaea13fdfc79890e0f93505137fe8a71d358f4277ad6f48aea80be17d0e4bab3ee2137ff220695396778529e4880e294c4bf83bbde881d9754313ddd0dc8a240490ee9939b0ca35b029903c3c5277cebac0c546f2c1c0a1e4a8d58d79afa9b59ab6c7fd66efa4f756802d3d39556b660300a47af82225ebb3809d4c97aee925e3967233a718daa6aec0d168e649529fed5a2de05bbf2d3c95da43ee06a601efc5775fe005e1f9ba93f6b5941d38d28a5e1c7d0762d375a06a4f5cb2922b976572fb4f214dc4ef0decb4a9ad0f71b0dbfd1b0498fb9ab3db0b18848e11aee413821ea0bf3c171e07fd3d84495b45ccc269be0b66b7acba9868ef042868a6a6904ea79badbfbdac8d9ccb516a0b3f3e56f12f09c0b8da173b7776d2a50c9fc049439a6db16e116005c5d4234eb485fed525632d9e4f33ec4eab70497dd202972cac8dac7e253bd18c7770efca66680618ae53b3f2ec8ad3c6a2ff8ba404cf7dc10d615ba3f0b70421e7bdb9966724e5386bd453e045a35c53b0c461a8b1b67086bfbd69001047b06835f1f4266dd450f01bb247bc3bafc30e9424d5340813dceb553e24335eb7c5a7718d461ffc1c013902f7e113274f59923a6d436f82f065451bd0ba5bc81277acec157ffffb0582d19f29ac82289c6f681880f10466473708dffd55b6790f1bf58220916fbfbacfba262a0540a2ec477743352f4b065b20eae99cadbbf04e383a5b877fa877bc78b4d1dba866e8b5c6ab2cb2e91f72c80f04d9a2e1eaa2f61fd90afc0aac5495816847b99952cfc32121c19b1bbc0a83519a689ab86983dda12514c4f93d3083ddf7b79db3d9975a48add786fbdc97948dd0804fb56b5d10e0257a803cd1478283f05b1bac10151764e7a05956327b97436962f81791af1067f0384686f4b7905fc44e18b41fcc0d977d4fe12eccea15718096372a7852c083e09decd3713ae34817bd0c9df04b706bd7e1ed899139d92f444347897ebeb4c1d575776876be6bbbf1c29d710af1d31f18a07a66e433b81bcf78bb92aee76023b32a1d2f3de57d8b8821ad4f18de45b794e36bbeabb2bbbfa0aef39f10d4c1d115b1aa651c46f7375bd74050134bf3f3719ca1a737436decf2789d11d833794942b06f284443f30d2a85ae051911f868eec75f35bdc736c7c624ffe6a5cdd537f073e6081d17f66efdadfc0c50921c729038f625f3d0989f53fea8fe70da36b7479954be7b9e09b55665fc0eded752a2ae780a397bdd2f8bbbac640842ad1694625a079f2b9cc0a2d5ec99c3d52c76807ab21c7fc5a53bca22edf0168ae8fc30b0e71315fbf1f97fa78ca2a38498df778d18342f086bd9e964462d5ace4b3e7200774671da3a7547d1d828f369d9f37f64151acbce70ff5399cc983591fb462e8aeeb026edbf6805ee4fc8209e1d3302f013d5ef41bfe531662e075b07bb26230f4b8ecbb548ec0daa5dee736a2870277231a60522916aef8f996135c8a16d6e8cf4735d8bb50f092c2f3e63d64898e08afdadb6572ee9898090e709139c0382a256aac035526b0ece4d264ae4144b0dcfdc30cb75a693d79994cd3915409f9d3fd94580c5e9e25c3bc40900bc9d1e47e5d54dc748de79b8c1874548061d862aee0c10d9d34882ce76854465d787b68276b3e75492d6228c0a537b073f97772b8a2525ac0ee0329d0e19786eb0147c199645dbe6a9fce51617fea69a1bd7f4ffc3ce7d6b026310b78047168e1005f0d68cf85ad37d987962887e4ad8914b3df35103dac75a54ceffa4a269d87c06257e648d0fa4dd98eb4dc04d908910bb2b8265e197b75234edaa096d53929ba819fde4ff56af9a2dacbb2ccca3bf07b8f3f841b0828ce5a2ffbefefb0fccf28e1c09d4b2d6a87ab25eb901fd7ef8ec5f0e8426ff32424410a7ae35ef91f76f2bd2df2fcff190c943b58965c36df335e52b321a4df3621fcbdfea0a2642e91d0df146a5735809a7feeb5de3dff5651485bb3aacb84bc784b4c3e872edc2461630c7e4b8b25de1e89a7bf57249b34c10ce12a38a2927d854cc9fa0cc55269c8be1635b44f73bd752a354ed57356197fd421391038f181e95829232b7ea7474d3553461cd7005a37b233fe6d26e503dcb5bf5b4f759127e4c27af4f41c4781a2f8cd7051f63f8e6d2c47d41ebaa47bb87a5a9e24876fd7384d009f8508c5ba61d4bdcbf9e32d8b9d6f046c9d53cf30301f4b2a4e3b8e4077acda7aa7a8d16722f172db03dff79a24c619dca06f80b6522ab871861236c3ce7effb39c0c302963e8b374ac4a41b3f01ffdd98534df0735785d3612a093e2ca6471775be2c605cf1258f56ead58e1e5ca91b9c9066d53f436eef581ccc84c3945f5e975c3a103f7d832b48f9b4ec6e1c49e381c24405011f2ac80bdd4a88ae5182b634c9b94ae1911cb931369a88bcdd3b6b9a0324279e6e4d283a9dd382e49277c34f5cac32a9dfc831c8d094eb98ab7e2e6c92b739bac3cdefc572a162bdefd72a21ee8a3f3c9038062b4ad2f5af64a86d09df9ac3d80b7e6762ac42b171cb81354d4cb87264c54aa79d9030637bd0667ef4c6cb879682b0974ee37e091ced4c7ab36d23244a004bc0df546926329dc1e282bcfebcb340261bbbc82977d0ea3c2d27024a8cae5372e7f16e87ab3920fb8d88b308b901d88a3e7c913b9eb24ff876513a1affd2fb835f90ec1359c674676bb6ede4c3ae90eeda8ba54ab024241f98db4a78caac2e2ac9085c4b4723fed3d74d260daab83b64c0421fd87616829fb659f7b32c23a0bfe644a10fab25a4b78fba126bcefd86aee6cfb93ac7c47d5b55a964ee174f1a7496e9a3c94cb9c3f8e7350df6a863bee05cac96d275ca8d75c5ea376379f29bc3811790575c739b614e4c410cefe19e9a2e52079f154d42ff2cd0552b22ce8fbe46ee83640cda04ddcf4bb26009120dcdca0425c8b217452ff79f91ec6bd0f6521ca4f338088be170dfdb06a066d9e1fd192d954ae242a794a11e308354a89c1a3ec32ab4d602253082b3e105649fb3bc5c8e8058e27fa5383b87d3d9c11688709c07a5d2af8042fa6eee5471901a7d5823edfffc2ff01e924593f8e63166144350781f422857a0d4779e4e0ba367fe410bfedacc34d296c6ac9d20070bf7f2fef02f04235d271d5c651385a458983614576717f1326e3fe7b5f5367178fa9d8835844ffc8e829ef609031ffd38e836e0dca7c54e63d50780c9e9dc89fef782fabc8768984b3bf8f736354374379a6ad90edfb63f2d64366996fffdfaa9983cc1f90937611bae1a2f4f60bcc50f3f4f00dd06f608b0cd12a9cf93f526bc1dc009117abfd23543949cc521df76aa97032052abbff896739dbf03191d03b47a5f127c8d6ea36f382a4e83389c0c7ad4093f700f10134553b93244fea97712e0dfcae647673a094be7724a880ca59a81e0ec03a85998ffdd69c7cd60fd09c88e62dedf149e7e5866cdd53ffef295d8cfe6314a7df100b296130c8b17017d59c49b13290a4a2b163d405c93f65df77ff8b9a79f5efb72a524b6a0b268102d90dfa0ebb4e717d944f98addba234121dcd93bc3c880f810354fa84570bf34e3f085849a20f1525ce5464626c26c485947f3fb6435b2b5d64797b0458d56a6991dc8cef4de42c6e576135fe1d6d17bc6b3f392d63114325dd4f6ea5eb6fa7cb2a2767887592f3c18e6aa9b974b64255dc5deaea7a1728c7a5a6e6380ff9fecf760c7798169db97d938f880735c83387d491e6cf52fc2ef50f9d16aa7819d3dc07d54f94b66939f28d4f8356c2eddba197c7080d7d796b976e4315bbba88316dc0381b69ee2b9a9bc8485dc3a8202e526082d6848a9698348f1dd49877400aae67501ba1c737c776ee16f1b55130da5cf808297a9c02df3fe1e6f8cd0ffd80209bad4255f2c869e9c2c32720e9658af95d1c7bfd7bcd8488affb5d85ec5a9c39e277fb268091b7ae583f6a6224da21bc73dfae6a8140a975968a381c054b73ad512350356684a89e271166cb131cecd34177dd571529bb9507c994c688ec47225ca61e94f1429ccbaa5b3f943244f18b83d9f526ce5a77b4921bd101fbcd7cc9a409ef73c7f8c934f87e566a314a351e7f9e5829daf6078ffb905b62b422dbdce59a336ef7b526a047b309b1c308e5333adcbe81cc02f8568c4360810d6e5d4eb01b05dd42154ed7127d7c18e76363b399828f8b61016d976d8f06a2e4609fedbbea529cb27552aa5700f8694c17a2ba076cea560d7eff4b716b1f481e4473b74eb0db9356d9143de3974bd6a437c56cc7214aa39e139db1fce76fce453a0823a76262831e91ae7acb75945463dcf0aed057333decb5e299c5150d54ecf3e1e964596b85533229e6054c3abff10582613346a3ec8923e6d1fa3acdaed9aca14935d11ac5b21408451d2624c26fd063297a512996232291d8311a8448792b78532cc0abb19416f33f0e91e7f852a5952f9b531919ce2f220297f473376b41fcba3fc57688aa0a4274e7afbcb0193b8b43e8a2b0e987fd39b0a1b6919fb069c74fbdc5d41fa05538799f935fa4af691c6b221b2d1761beab143daca43a5345d5dc0067c76ecc5aae63b87d76c130039b4af12af7fffdf3db5e2ad6718cfd1212e33d838d29cda0a3c5cad644b99e826a9ffdd3c3422f3bf06323f434c86704feec42d67b3c5f5a3885c64e648a1a7132c11ec01608f91484675356d057ec8ed4c2d0d6d54033a3311fec04294b7b4a3aee425c0c722584c7d9aa6c481eb52f01238e1fe421727dfc9ca7e73e293977407b228d306acef45f304eaeaeadb2eff16e8450a66e27e6cbb631886245d22b05bb37f2dddc68d9461f6167a90d2db1b703eccc790856718c7649734dc1555c9d3305b89797988fb3896e947e1e9546a0d52b834005e001e350e82c3d63c0444c39020f5a066bf2462541d411eaa48208b66fb5e7c0f92d71d6b50045fc812e9e93fd44dfbf36d036ceace6bc56c4943c282199e19c620230d042103680acdfda6469fd47516a240c167719ad42f68ba5ab5a0ddc33702f4c6587f390779236f64b49f3f4058c97c642f4f7885487465a3edde72e88924038d9e08203fab11da89eb32f026006b5c88d372c2db253e004ac666175b46a9833b9eb7574aaf8651e45f51e1a4d65444e45b4a34a1652d465ae10c009268bdb93b5ca68e8d4561d4b983bd473d55d261c31336038b1349a48fe15ef4ffb8189aaa67ef984257701be96a1cd106da9cc26f9ada867473dc03e5e86159aa825d7c1ba247b2392f78c5f58e3bc96a840477d46eac24f73f1e75fa8ea81b2f17ab8ee138216cc0caf8193ea54cb76af40fdfd048d3aefb5c664b5b016be020db7140695472b193cdd041f627a589f8d0ff5036a367fd09d396c84efccac374c1fa375aa95fdcdd04fdc0d5e5d759d6ecffaa6465ccf0bc9e65201d35bf0187927f7bd9333e39991e3abb0a4af13b639bc40eb84a0707d5b059d209f805157309f3256edbfdc820c115793e6bc5597917b2fbce8084f164c87fe782520307872c106438adebfad71602030a6ee35b75109a2b3ee31af5774c94ad17bcbc81e249a442461fc05f372651288f1befaf1132d5c9500b4d29b3ebc7a58475e324fafa7ab1041d89d9eda2ae0662ac99df12b7b6129349a09a80696dcf25de7505a34ca58c20c6e121ee5f97cea9f107c54276d871a086b3ff9de4595181bf52488ba478fc2fde03ead442e80c7450d49e229170ad589e738699540400728e0d76d01ec20601efb18689c3bcf7c88ad84f9b4d4318f2a580083b42f4f1b89ccb808ecf8e76a046fba5927c445e7bb744f43f383793bd896dd33d1d980abdc0b1438fd0dfeae46e2ace4a694d57b786d83ff172e45ff6baa323e96c6aa6e88be8f2f3485f6eb3e74593b7ca12e475b7aeb5d68ead5fe6d493a4c466b17cdd9b6f072b4c7365a44671b6b25aef652fd03cb1071e2088f8c1cf9311a8a395fb67da42aa497cc99f7f9d7906ea19bd7d79dc8b8d2bf52becc8ca676a0c52be41a125160d813a75e3abe18ee9b4dc2e8af4d7768ca6a40776602bd19d9960b0d3de9c977fe2fc3263d492231e043d00f0e206cac1da49670ae3e6ef9f7c2458c65a25a3a9f4fa0a28b8148bb3641358d4e654a62811118e2ea6a839d88d6e6c66f92ea3cff5913e1f8a3b7635f180671bb1a451717c3c7f02ca54cdda8176906cff038bca4afcf1c27161c8600d93c97d47b05d4448d98c327399820c94758c6cb9b9fdeb2ad907456f75cf22dc623e6be48b174a2060ffd222f9f072809c5c75fe96e17baffac4b868ec0b62baab88ac57ff5c91eec69df695b508faa983cc0f1f062fac660905fc73ede67e757f5ee30d10ba2a4f965e9a7fc71b1a01ec21cf8f0f1dea61d8fa38270b7e834c93816ac56b420fb5e1bd53b12bf9231d7e4d1728234a687bda5910576e81e889e55015af4cbf4a64f861e3e9dc4e2f4df7357bd5ce9066346c43efa5ae6a304cd8bcb61653972ca191035d31955975c138286d1a6836ba2c1f4f44c63003107d4da6f9d0a3cdee176ca107c98ebd11043f94264eae5016061be99bbc045273b0ec1b8532e65a6e5904b71bb903ee4c1e1eebd3f2011bb072bae8aa25175787f3769d1e5e1e4b12c2db2b8081efac506ff0daf90d1ddb64dfce36a91f0588dad99bc01cb08d7e61f9f2cf4aafe728cf5ec36c892deb23d486d5961e9ae57bb710fbf77d2a88a4ddc7726b0f94d0f85df0618d65f03b411cf8f13a218d67153a5ff3b1ffcacb0aad335237a2fed511d271da4463db30884020ce7dc305702ec9b1254596f882a3b1d8751da3aa01b718c6b4250ed7f1408576961de13fc43922a290876950c35471c8b3da1f52228ceb700d093a25ab7388d299c47fa61efb949d34825673f8da70ece13fe408afcae6cb293e9f25ef011323540cdf4af3094de655b8f250e9c36f6e361d0a59e94f9369e1676b1593614ea0fc9d0ff60b945f192102ea5234bd438cf6701620d8b137de8a65ed2d20c2673f43b9cf2baecc83887d284b5353adb0043ed3216f8e65fdac702eb02f87e1a385c2632ee50fd3736c8397698fd7ecfa26a269f5e2e8d3be152e2856eda034e41fb164a6a044f47382f1c6a674e024906ddeb9f4bd50b0572f9ab0617ddb05cc74794591878b3b8fe9f15dc52a518bcaba0eada6df1d815a1c8f7dbcb886c3a41fcc0e7c9eeda5cc57502295742dce8241d3ff29ba5efdaa9efdd28c25fed3abc837b67205dc484a9d958eb706daffecae546c1d285a88be10c1f8dda1fb13f9b6c15605df0ac8809c40119ea43d7633e1a47cb097133e05f19fc1e7b9bb7fdfe370dc5f3cf195341388047f497d042ee78becb133bd11714bceae2f4e657877dcecf09412391bc0f6cc7f14b07f2e9a271ee369ea84dd5fc278df7a7542f76b3ee4d426abaea97752004d4cc3361081bb6ac7c15c0014380d8140b504ded4f6e350b488d8ce6ebb3bbf5d1ff1776c85d11f24a125ff4652ed14d03e7880b0b4ef85c647cbf2ed4db588c4596c8a005263600e42e306094964f532de5a57e25776833c0d10d01b9bbff9f3e8d90fc785dbb6d7e86708d0dd816adbbd56ab6f05f865e7233e1263ff1d5892d39de4419083a6dc9b35b810a9caf1c626af6059d51c747cd77041de2b72957dfb1c04a78883524912c55d41063752ce5dbe17d012b4d17ae794ded92dbd74b845f9c7a4d54fda39e5b8fabd37be0729f2419e6a18229a49402937ec8e9d814f06e5ee5efea6b8f1657e5c12bdf552792778724870e125023939083bc37c3f56c1260c58a3ff40fc99770107273784e51ea1e7ce258e19458107773d4aec71c0808d13ee8552794e217553a45f56a3894d3c2e7cd93696707807a235f9afb4ee223ffa4e6bb09699d3da3d4d906b8656b313818a2bc7e5af27930541ff49eedb9c9d819e3f2986396895cadda6a8569f85ce7b155b79383e09f1d035b79d1f7d2aa0cbb9a39952f04c0671a0aca91665c871646b6a29a12e335da7dab3c5c66bee3dbcb0c4995526d7db1d002644f84e561ba8f614ba71438f80c54011d3a230545615dec83ad9e6ae041ffb0f33fe1a1b768464468a7d32a8814174f3da33fcc7f0368e828d3da0bf44ba6aa4ed632c42a636d6b506145a98fa285fc4466c4ec3fc942c40d78e3fca3e44428bfccab0461926c30fafd3cd1c85d43d73b4dd3c2ddeb6b257ea73956e07304f82094a8332c2bbac7d8334bd1c777ab7c7eff4f8d9f3b52115fd3f5283a30cbc191827eed32c1695f8374616a6383f937fb57b763ff6188b30a6367004f6328e842f57bb6e56520cc1de3c28622d87d91161a3fd4dad559a11295a87553fb6bc2859d1997376298b6d96ed24528ca48d2358cc766fa2fcc6616ebff1e53e6bd1234cadf31b1905599e973bd8407dd6915d138aa6f9f6b132618b3188aa0ebed62608339c3af77c3351d0811f2e7db41599c583f907a2b1afd430328a6dc2fafffba97627635252880825dffdeb680bc1905f9ea00b6bdfef01aaf2233d6faa4bc3aac1f6523394ab6fd4b9bb7425628fa0114bd6390e6c109222d34df225ddd13ac70e5e5dce9a441df5244f9731a88dc0e467bec44c001d50203ad57ba04edc1c86ea7a3a4b22eb0c345876572ed052b095febc8a816e04305b34e995e165b5153141d41a6df2520a89cbece25256df450831f59d18a7aa4002f049b1dbf3be49fe73df2097dd35718b04ffd508bacf5fb9eec85a7bbd77988ff9ff81f78d628c0e0ca62240d292bb22ee913d4299fcc1ae35ffe1313c611301f49ee6607df4bbbb069396b0e8fa0fe973a5755ce4117f0c91cf9c30e18067358965764f7048d3a15a55e5fcb41b35f491541dee2f388bf84c2b611819c6e452281107eac1072a100be5e79f999a60d9a3ba186735c41b91b9331d82d0793fbba1da2a34cbe15d62634470585bbedf964b246ad9d5c17e844af63c9a964900f4c6d40450f03ded7fdffa29bd175ea2875599fa5e1d0b6c80aeda34e8c0d9783a1fda2de5a0645125db8a9522c0091100ffcb633792838fac210ba74fed9454021d8e6caada9bb0e40288c1eab630b74afa0e5267f40016ae8b9d3c62f7d3153744fc84d0a444942a90e10f4d252ef7bcd65acaefff96fe4bda98f657ce00da016e5109249b68bcbcbb6d98c776cd806bcd72a925759d0e1a1d712b27f2fceecbae5e38d8828bb1299f03d777c6384542de04e75d1e6aabc06149a1d67971efd41c60ca0196dbe8546220b67834bb02a68b77ae93b88872c61de48c5f2d232ab3c4dd470dabfb67348f5597254f54d8183e911c302ea27cd1fda522d0c7b3b9680172f5bcfcd09ae71f4b175699cb6ea8f385818a57f453b1008176bed678b2dcfddbb2bc95bb1da06b5396ffbf4ed28418d31e4b49ffadb12ef6737a32bd41da1a040864b56946cab52da3a1ebf1c0cc3fb1200b823e063e143802b3916f1f895c5964e2a495399107105aa11f2047d0c35f79de6f76b673472235dcd093783d851fc0335cd1e77d0f6dda5bdcf62518027b45f8d2015bc6d43d0776e5fd412826fd9850225eb4c40b8abe6d938d430f3981c8d640ac4438445ba68512a4447a475a429e04e87eda7c57c9f79c6bea244c40fdd16ce5cd8a2a64a0844835affa069d093c3046eb9a0162601a24383bc72f0db41462b0a9f6b515593eec7a2ddf783edae77fbce88a51365e19297ce8f73a87e7cf6c3b8d4482566df7bcb482d20e5a502f9ca1132130be20057ea62da8f0078fa95e8895a6b2485f15aeffa966584db4f4545331dc93dad180c0e9d35ac28c1e992bd45dc8e73ee4ecf5a925b2624c4db8d30dd893c99eaf760023d1ef7bf6acbe3ab77a55c6a678073598c886cf43c03854147e1fa727c45fac31fc2825155f69dea7b423445efc781659350da2089b31e9dc916d653d54a762640bc38fa6a5bf35878e7c18fe6db9f67067624","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
