<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e62cb9186e1ec27b1e65ef9af0ce8d6cda19c5c5c61545593972c4293e3f994c967a0a6b7c820b4ff9bcb833d4ab04caacd6a2e721b65a2bf139e576bbd3d5bc4c0e76d9d0e54b26d464029f62cd80678004201294b83567c1a9e018fb52f78b174b199d98182190be742b7e4e53957676d798e9ab0521b8fc1f384faac70d67ddc2238e78bd2e54c412dbaf79c0de523e69ea2564c27cb32fc74df838ee4cfb68de6def0408f8afc55bc9d8c46f97278f847d84a883a863630116d4f705eafd60beb2f0ce0f368a23f7b4ce29fecb652e69c45f76788ca4a7ba504ee18f2a01f29dc73f6281845b65b834055f520047f2d7961a946115a92872566a43c05769fa157e18cf5574673373de3b53ca2642382d6da417ca332e8a49d2669742f9dec57f7f3b245dbe049e141c912a61414e6bdd7e5f014b648919f5839ad4663ba74c44f7390f22e103825ec32f157bf7edc1fe9cc83887a64a78262bd9a4b22a1d1bfc6d8a80934030aa571a8b4c36f7069c4529f1fc72c335190294e8d5f6c33490888caf49baa35c28f6452b63e414157ab0d8c8d996433e2497f9a87fa9c0243588d4fa8f24e3331925eb997e7de0b8f4da891c3fbc6e24d69afd4a7ed43db9564b03b7990bb142d3411af462b7ef98f863c2e88ab1a85d8b77692f9fdca39559dc85e447ac581c06e45dc776228715750b690acea7f5243439b8277e46e52ac035bcc2c32a66ef02f3b1647667265c9f9e784f9f4348b90788941c69aef31de1aae051b5d077f1a8d6dad622e11ea1d0551c21adbe27e9c3d2caeca862136f534dd92675fe1e49f3752950791a7b1656c566d9514d91891b1663af1d96f70536924b811e8c93879e94da471a4fa6300bf035890fc2cf81e5a4a836aa120fd9de0b1ae49eac7363400120d4668e169849ff15964fb05172bf9482dd31abd12886a2cc6cc542fadc514d2a6ede746f2ce00e39ae8c6b2b7af3014e14a70d95e1a29fac3130e5d6379040cdbb1d7b5521b4a20b488851297e5f08fe97cacead0f89345b886b8c24e35c862dbb844d735e52652ea1801b03f00d9820e76302a9a613638df46235049ee41dc3df3d1d89980a74c9ea5cc312c6266cd8c42962d1ba93b4f281467553b0a7c3de69234a856e16e6f113dd95925a0d5782916f4a73209e303ae0b97df9edb6eaa33d89ee362936484e1ae07864e6d06742ccd103904faffe86d75a38bbefd7cf6e88b261bfbfcfce403647d003e6559a0ac552c6e6c256e557c72a0518842fe26bff223b3a321b416e92f1f95bd5a524962ef17e6640ca52683dc8cbbdbc251eeebadd907bab7aed16454c5237f89e093ea94b23b7bf6de7cdfabc27d36012d418aa5c1ad164f149c1fe8c0a00221b4e29da8dd4429cbc71afc5b9ad30ba73a8fe2131f58512b336316b8e629c30070607b3ca3cf1270cb7283a0e12a373de619fe60145fde65b61c4d391af41c426a55c0b9ba49e47f3b9d29891f7828e798547a6a887957e1e66bec6b76d210bbcaf00af2b361c6aeb418ced909a18f5f3b78c8afd475edb3dacfb3ca6ba39a202f434674262bc5cd68be6e7024e775094c3cd86bbb47a29ff51f8fed7e997944effdcc0f26f2c5735a177a2615352cb57f33c449e475b2cb0124522baf8cf7a8f275a895f4bc3980047c6e42535a968dd288ca4b5599f61595403fa6f5ee7ff924eb66c06faf0723a39a4e0170136b6f928a86dea786ff366831f6afcea819ae5553a02631d6a64603fe63a49c9e90a27ebabdd4403819a478dc69ca20faf254eccc09d59576b4c357ba79f3e71a5b15cba23068d09c437cb9c93df654f658d8f04519f9a9c65b658d5faeed4910eae26a17a2de6b797d9e448ab309ff9a85a2c3ea59942e6fe8d434266c73779112d5eddc147a064a0c94738463dc78307ea03879161b070d73e1faec8c4c2ea89ebf2f801fadfa26e7004045a6e5487d8ba84889dac3964042fb22ab5a8e1c2796ad2defdbd89a50d88f9482a6a7cd95da5e57c5f44edac5bf19257aab6bdf03601ac03bb5a676e0f86ff55424599a4100a3eb67048411bd40ae084efe0500081af728da9d87efe74a8743b5f7dca2b20a937accb6f09dc32ae4891961cabffa8ed0164177b7baa9e688c7364b43639f6586db6e432501030852581a95901e7b54280f4a6228eb357ccc9ed87adb14c67c507bd194f20986ba181654fc2501c05900d4df6aa5f97fae6ef4f255892456292f10e0ab839f80586d77c2e52fc11fbeabfedb7cd513c42ae78e14f1719d06a52aea9d33de353df3820c204b6286a86a2646836b0a1af3df11ad123716543d770726098730a3f7191c5550bb2bc581046ed3efab382c4dd8e9e0130eb3ed44c6e84a128473bf05f348ae68eb866109fe387cf176fce97f2d8f35313739c16cb4a139740019ab2cb93fcfae37a62af7e3659b3f9011da30796233abd2b75bad012aae978c37bb7a7e2f7cf88c20fd9f232cd0444463410b4b0add945ab487783074e2460a861fba7cd00235b5f5de52303d1be1a8791988539f730495e86857095523c5b27d5681a19491b940647c06a06e9dc778970838f7bc2ef34acf6314a773fe23feb5b03e22a87207054799d65e7909adcdcd01c585c2cafe70997a058c8a5c53cd63d18b215fe1382dd7e84309849636c46610f7c4d55ecf97d7a37ba5a260d045b2ad1b2f2fbd6c02563e3df430b7cf4a07f709d4081cb2ee42765857ea8732d9e9c9505872479f7a7fc0da0b761c039dfb9f27f082afae049abd7899efd3c223cb9599247875c7a3c5d3918258cb3ffb25270d8412a2b716b85501b2abc47c268d9bc2ccbf96c902808e946041942cc8b91d3dacf21f235c97367cf21daab9fc136617426663b2d926c285fb5ead34594afa6d81cb23b78c2be91d413b4336cf163065e4e2f51eb0f83a881e0db7e9c49656eb422e50dab83cacbb5990cc75988bff11a665497a91d6519bde274802ed07bf83f6e14c96f12accd797b76666abbce488eb89f4bc73e7ce95da45f52ac53ec584568c4d4b310a22530de4d5c67dac6f25ee5094096432f8e7c15abb366110b74709bfa9ca8999fa81f14868f14bac55f51cf87713d2cea1c61589806dad7dee60073d2a03491fff045039bfee6a718b75527652c02789013c7da67313de607c0a7665bef5ea03a875b424bf672985e79391d9fba2648c427bb53c95a9d9b61bb2547dcf52fde1a72f49781d7c5d1aa06ca2893ca371d2f80d73f6b24134a93f7c67f392855445f4623f2fdfe98c6fccb2d9c83e5216910e53ebf7e819555cde1c43bca8cf27bc7c932eec1830a22a71a9ef581eb749953dd920c41bec6be64e862c5397ff073ec125cef38f05982bf751a34a6681719d13eddc983de7858b8100e853e5c2a4f200fb415d4286528aa832af244cfb404106c90a573f86075d294a163a7d0212f8967c5023abf55be86707dc974d6fc12341046d35c10e2beada26f309aa0a660982ed245efe8aa133c60c4fb7a924a0683e611a87f4df4c7354a752fdd3402865ca636f39fed754644f26e2b21bb0669c0fc1291d6ca7e2b2eaa6476279bbddaa135e815c00a41e5a2d16f51401624675963e09aa3db225a4491f4e5e4cea3ee204b064902371abee4b8836d6f4765ecb6ee039dab716adb036860172cf49aa832a315ee8246c264eb11712391666615800a46b77af9fc1a15b1f8837101f38cafa552733f7603d82c7b4c783f45d67b2b28ab4538b8e81c48935e5273da7c354d4bba5d9bccc322239179bd949004f93cbf8fcc7c35b4695258781f056aa27b68c9334a8cd0a29edaba08ae951b6af53677798f433bdecab016f3d84ada945826a197c1ee79130d206ba69a8e4b084629f1cde657609aaf8ec4d1afa835303eb571eb7a2e51ab36e230f4c6f6dffbec18caed5ce2160ad0460320df57bc28fdffb46436d9502940a0b1b42d2789357d16ebc3bd30be8fccef3ee5b981d0ab2ed7ba784c087a46901af5810cdf51b98348f18fe35faad4b6b7630f7e57fec0de7c923ef62d62319abce07ea7d894cc92b9838c285e3d43d93fd6421a3ab228fce120dec0dab57cf2ade3cc1963c5011b3b2f69b47edd56c3e20df14d4684accaa7349b5866e64ce2960189a5614e11e6700010c86477758196f6d89608d009df9f4487f9d3489a6d92ef9d6afb4be73a2818a9cbe6355a02bf7533e33b256c7c9fcc0bb08ffd4a7d26aa6b2102df3ddd68c8ff22afb29caed15e74aa1efe9c4149f63a180d872d8463cdbc3fa5b6d244af6d597af0878688a232b9f871e145e3505bf7bbfd571010a721307d830b3742abe23373bb0e6ac6cddfcb7e9a7a940a0e2c1fa5e60f46be1e527b674074b504c52a13d69e1ebeb2522d337a3d50fcb25e7bae249da1400193f9d862242b28b29a9b9b154013cb0e4e815c6a871785f7fdc4d31873e8b2b562f6961cd814426cae28520f08d0ba0bf107590e9ad058beb90685f130fe5bb04e5ae890ad38c4e6268931dd24ec2d4ccfa3ba7abe66681f04cdf4d72062b189b225709eef16aedf531c338a126376ca54b0e7fe334bf5b8ffbfc97b0ba0abfac8f1817a32f31bf60970e90f084620dbbeaf7c1f58a5a8a06f566b43e4e7b85df3632c2c93d2ac713fe3c1ea5d5dd29a257255acdc79066adebd5fecdc320fe6779284a46fe5c1caf76ca823eb0341dd3adad37a93ee9a0af7d449dd6fcee2970fdf9903f176c18cfd31ffe8e5d5ed36d10a087855ddc546a84df8cafd9736039b913efff3070e20230f8b69b4e6a7c524cc832677ede1367f53a001007ad321d431ecf1c098afda3a8697edbadcdc9ae751c197224992575e748f2c5a3238984ca64c7506c4b95f39ebe890b665474ec5701cc3a57450e6fde445f4c144510a11a2c4649b0bf03ae8b79c93db49ce47fb39ae6f19e1624c418b87a86bed13ec618500a0ec3944778aa3b7d518c16597fbc5f33cf681922d0d7657983a2e25c1a9cc5e983f29347a567b23e54740d24993170593a11bf078aeb124143a7fd74b96022a71c28f9f115fafb53c232b6d389b44631ef530bab72ea0eaccce3d01378efaa1e468e01353ae4873040727c586482321989169566418a8ebe5d5827c68b99800d303aea0703f19c3f9fb816c274682e2b6847fa6e6ea3ff50dbce241f6cfba26804c556211bb9c4b554a2e24395de0435a7071b74080ef78847dfc90c4ad898b02d30306ffb0ff71cee7d86bd1513f8bf6af41d6e949592d392db00795982608fc6895dbc9a79b2c00ab2d19cb7f2133eadffc26dc6edf287a2b691495d41686da1c97c6b2c3457b2f69f050e26e40228124209253dd2af82995886e36d5ad09e827b33ee2be118be4e60ff7b6eeb94b1fa5f0cb799f11b683f3ae0dd8d992ea22bf3dbc4c9d5c3c871c0c46f9f3438e37451ec46be5627ab83623713a934d344fe9c8149a0de92b652c220d88328772ff0af4f18adda6402aff391a774f30d340872977c7c4a322624c6c58448516a8e9b4bc3e0dea627e97a6fde41bdae6cdd2ad15bb980d2a3974b78acb7dfc94a7cf1d8b8fb5e6c9f0c472b1eda64ea8fb111013612d52662eb2103e37399725621fc4c29a844a893dd49a4009a7cf8c5cd1dfca92be4b97f4c026c054d230fca765c25d8ac735ba6d0d77232c5cf660ef09b93911f04affdc230ec04813e7037099dfe4c19dfaad400c604eda52a93449c4d59b2a6a03d4b84b6b31f6b2d618587c41eb4dfb6d2a7b6f0245b8d5c532ccd3509401dad11c33a3ad082048ce963a57921a0a6549beed3c5a4ad94ec3e3b816aa95bb00eba16d4c64f9f3c2b9bc38693da7fddcea80547a63f305ab936e4e1cd9b74de5bf6e886574a2256a177744144a5da613a90fc98d463b43d4c98f7c908ee173159dab314f9ce63bf4725263ef0a17873d14db513c0dba3323a7a825974a9bb23952949a8b05b76a5c79257fb6c441b4b5e290561cadbd67aec1342bd4bc8bb605f0c93d566310b4b837aab0c0e63bf1bef86ee74966bbd1c83f1343489627f9faa0559cbcfe2af23e0a1060dc5faff37fd293f340403bed2ca5e50f6bf7f5cdec3e6765908e7f90d7698013390eab03b9ed97edb4d542a68df5551229c560c5871ca886973b54f4a0901774556116a8368c1bfd3ccf8044c74aa74e23c81599c907f746fccdab71c4a5c60565e97d1bdd5dd3500a2855a4901b9a1fa789cbb0db6456f7d54b6f36793ad02d5f0f52a49bc120bf37f104d5908181241e0d1559ae12abd7957eb3785bcde716989423add1e4ab6498ddcc6020221e4426b8b06f8ad7a50affc0599bcf1456611a1eca240c35673c4eeab49df04baaa5b626dc270cc0c8e1bb92cd368a1079987c796d7842dae2d128a90cb9ea8681018fb1337f362fcb2ecdcb3415cc43d33d5b11d015776751d05d5c9f18a06856a875b626a17555422704ad981ae9619654f29919e1ba770247a4818acea92bbea8b854eaa178e61a49f85c7bd71cba97d323bf9f721c02aae00ff9d8d1fbebb4e39e758c874f188ccbbcbc3575e705a5ea5e66b3ef1c71156bffc7ba8eac636e2f98ce93dbfe898ec78866772a21aeb99b15e9eeee2daf11898c39d7a35d00edb6145038dd22acfe7ad797ca9bb09ffaba35958a1a1efa71ac17038a8c633e26e467c6ab1c22c694eb4fd358f04199225bea75a241a0bbaeadef43724acb7b6f254b4d7b06c5e36f9539fe62c43ccf3b687378f636c7acad422e301052cfefd42e6729d01fde4f252a05f2ca28239e55648e61c8d785c8cbacfeb4bc0695ee3b1d3273fa14f009be46d807f3ce48995a2052ac1811badbef2b67aaa4be3dfa8fe4836263e5d1c26e95898753e1b97c385ddc1152829fe96c84c7d7183cf48d732e9227a07cd40b868d9066e75bdf7eaf45711416e1b69adedcda3864c049b37b5c455aea6091167a2c8a375ff0314694d6da9b04400b02230d4d48b69d1f7f9351e8bb5c49a3b89353558f4bcc383a200182c1b1963011afbbbe98074e7889db29a8a4a3feffa0fbe5f563682aa4d7cdd30ae0ef86b607c8b980e6f56bfd8337a74ffbff4bdf4d578bdd6d908c357f6f7c51fb085e9e2322be61b201e0b4357e3c78d692888f6bc0d2f13167f9692977be48595dafbcaab820be85ade8023a8fecd23c25e8b7befbcf906c68daabbf8c90bf586b491a6446c55f3cb28f56d79efd2edd65dcff8604ddc80da09a77519dd03bf6239b9cc863833caf702abecef995d129a044d001dc315963636731a240911700035ad6ed8eb49b21e0a2e8cdd6a2fff81437a5383395921ed17bce9ed92706d46042ed3b4bc929245c6dfcf52bca96f40db62177ec43a7fcc2c311e4f830ca2976a5060cb07bdbff2a7deeea9b0e6951be5129e693d6b7151abc644b214639cd69a8d690e61d73e2d1249f064dc87b7f40406e00af8930b1bf12da31a70aedcd346df56ae61ffb3866f9449a675acf860c524ae408fe64e5cdb945fb2a5030ee811e0544fbeb2f9464b7c7230a1ad9daeb0c15571ee25bdbf8ce2dedff549afb25889a935e9275c4ea3c876142dbd96213ded96c41b9aefed7aea39f747da86576e7d8935a5f7a9843c700bb0a3d1553edb82f1dfbb16bb604354c350828696fcc8230a3ae49ab309c7387c32fd288197c4fa99e23f0844b4faec2481c0095cfe5f63ed763f3b8ffcfa9534c44c017fd76c94864fd1bd2c3b9b8af01abb9ed63a9b5b1140c2fb72d4e3e87eb07f17e2f473d3ebcaf46dfba326aa0136d60fe739fd7daf8a2fe2e96b0a1a835cbefa7f0efe94fdb5e638a439baa3b2d6feaf062e1afbdaec2351fe4508c0ef3b31168163f0f2a5345fe17de3c176e07ce88ec13fe355f95cf5eca65c3ade143e9da12f7fec2a669dc469218749a9e4bcddee5d26ebf38f928da7b6c1e62174788492e28d074c971d121a5b5d2a68816cc7d127e61f0eabb9898eaefb66241d9459ae6356d930f54201c0148042e9d57c57261d09310a244d22993644809e10bc2ab9dc9e0951b59020ae50661cfbad749637119b28c43c4e41c2c9d2c003c4e3ac2a16ae14bee3869ff487df35059f705ed30281ef495b0d867ce509fbf9364892f5354c81adcfbe5d22e8469cbc3968f060bc5a8e5aa519930bcc35f64706bb9951226f8c12ae6317705051e3508ca323a2e49bd57b5b955647c7c9487f28daf28d2608ff92515064be904f354e6165237d8df0ef9f88632c13c7fb6d285299ec1ffb92638dc721c1de43c18bfcff0c98e0df12f97162ed80e58af762c01b6056403470ee9f5456b40b7064baedf9998455c8f2779da10a825b02570a5a4a909eec35b71fbb2fad24871f291b0f47706c257e9cbafb3d1277d984af0fe891901531dd6fa5458462f24eea0a365f92742707431b37ac00b5bdea829211432f560e8708d5a864141a413909f8917bd2bed75b5ecab6b24ecd7eba263defd9a84b9f779dc88f8ccbffb3a99bb025283e7379560aa19c9c9ce089db2fc0a9728ffa3725f74fcfdc2d8f046aa82be36d1360b2b969da407365019d2e788d24696c0ac6447f7b85f95b6166379496da9894f2c040c159dd9b13e6df9b67b238b496341b0258021c03995a95e3928e25173e2febc6f9cf33a1ff3a34b399ee7d785eb9b8f60e1a653b8ed5cde2edb3e6d8f34694f80904062a6407a5eb6b18ca01e94121f18c90f58efc421762a9cfcfa3e807bf3c70bd8b003a5445976d322f40510e5810b852e41b1ba1df60cad71877c17df2d0d315281030e37115d44bab40a823d3ff34d399dec8f52a295ab49f08a7192761c4f5bfb46161921073234804b86586842257328e2a974349f1817cf50d23aa09c1188e6d276893c59e75f6aa512cb4ed70a8715c6c922555aaf69e7937b436131bafe44ca77b8a8a8db623f1afa2ee799179b3f511abb5b461a3f8b2b437ede854d7a395f840b6ee8d20be9b41f0b6af458d9d06af8b1c8e99901e21c8737c1a5fd529ec590788346e92728f4cc3f1ca5ec6238658cb1208e7ad082867e701f178843e0f92bc53db40fb32c31466be7f09e1e30a98a895c423138a79de310270f523558fd0e5afe12de217e763c5041c22da7d23dbd55982022edf0a01f28489d238b2fbb5fdd925d3b8b416fa9c9b3d89ef3e4c65d55c6a75b7ec5e4466651ad8685f3e12f34b905035379dcb8d93644cf83fb62c134387bec78601ae1b4c29f51e7e066da66bafe6926ef66d9f527c76b0d44175fcffe446ec9daad656a9b6e85574a10db5df7f922d9ef37c8165bc6fba3590e4c37bb7c92efa829e54775f7b321efc894156e2ae71889f2942a4b40a1f5fa0adb2a6bf6eb8a99e4b1a5cd1c5c55eb418c8f7bf8d724dcf204e8a224255919f9cda095ca0aabbce4d8ed7274a75c662015e938d17b26820bf0439b6a18eb3985bd9df8ec9f8163e0f64c458976931d23dc6290f309c23a0f4aeb1b235277e59f7ca3d09fbb5eda99bd6d71212090b21081017ce23b2fedda11191d58381e2a48ad2564cc4951073a6e4698ad7f3fcc5728786164d0eacc1355f6a32adaa0a0ae4c16b4a562130eb333d6ab019775d954f99bc31072667e44f708aa6fcc18ea185c08304207a69b997c7bf312cfaea14de94e5d49cb364da9fcfec18bbadc71c7b5e31205c5449df312fd3a19f8ea9386e130c43987bbed1c545a0a0fde923b5e49693820e0431652fc3989a5d6d7159158ddfbd14b2166759be501a4e346b7e90a65034b23c843396118dd772892e11f44b9db36ef3331fc8092d06697a01473523fe0afcb2f4b58f56514e5242eb7a958ad9289dd50276536341871ffbc08fa6690886189089303d926e4f57c7f1b820497b0e926452f9b1f16cf210d239048d8f55e38b6df3a83a02cce56d2f55636925a1674c0b492293f0f6f1b2e916b617e0d7ad8451b4775e76ac3a8aba4c2ea21cc2f349858c0cb5c417d65ccee7bdf057e87cf6c8a6dcbde164b0ffc587929a9e65a989e5a0d6545e88b4478fc3ee6030ace062807e6de7fbfbbf6e829a266515b1f17beebcfd620e287648376ee0f732f78fc52865d6449bb7827fb463a556945315a263aaac34e0d33ffed759ee0bcc19a397d8113dc007c0c27cc0bbca2375ea408f5931dde17a2c5bd590ba7f6bd4fe7e82dce0dd95a3170cb4c67cea86c6e0962dfb29c1203b17bf352f5794b94ba5c097f1c56ac3a54f1b8683ea1a79ab2aa9bd60ce3e1f6e7125738799f5dd59539ff2ddaafbfb7925e93f513fda1a964e76b8019ac2053a0c70de0e07fd6a2cfff39af243ca6c210c1f55d96709448dbd1a6c289d434987e6a7efcde860d66f951bc4455cd816bf671ec52268e50c2527a0e33040154112cacda24b6505633e70bebe806f715ce2d5da7fead77f91a98a774035c3337efff0d5a38b91115e3bf98484170969d1c599c9b3e64ccb4fb8d026fbf2ca194ea3607eb8ef9de690d323f787106b918e4053508412206a6ec48f9be6f903b9676211ada0914b7369a219e5a1ebe7c77552acd767fe3a4a24c0328e543d9004c20de7c0bfd1b92714915c5a54563bd4a92da0e00c8fdfda3fd746cedc27129e49f0254817f978e302b9326bc83b00f6bc82c768415753091caf6dafa42c6933de4d9ca81ce476491de7a93d681d902f398721abc936a319c7ab55d506d6aea9963907a95","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
