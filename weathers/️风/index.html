<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4098b45bc2a78ad02f2b83da1c310c38459c0492bad16faff28fce8ec8ed47f8d923197eed05a3a82e7bfe7ab0b4d0de927c4681e815736e6553933b70af307d49ad523d511b7d45bd4e21af633528c37b2bd9a36ab29f2d4bfdad8af46ff2edf25e573ca6eafaec63e66c7f94a477917f62ea26d5ca2b2d9448050a588118c4026cf825e556eecd272116448fa8dd2ed85937f384976506f69a27cfc0f9b5a6d7107d319b7f1788c660d7b3eac57667fc57fe05a8f6f38b3d9baa830b031f11e9cd87afabcf73b184430a2dadff3e2d6185c5632393ca492ddd7e4620619f48bc8c505f5916519f3ee79fbe2014290c8b1c8529795aa0e94c17c2d3f7ad35177bc72010f33fecf23d9b329f34d5e15d9750a3ff35888a354f82ce7a3380822d08a25648846ea54f53c120626d870dcd6cb1b7b05ae439f8db2e7356c0f5f31ca66e93a442ac9fae49d9095640aac7eba328d97adc70ea6c2a707e6e727baff7f3f623655b35664eb1ceb7dc8a635c8b168f12c204eae5701b28b1b68f1c3aa268f5729776df33c173beb30d56232fa2e3ee7d5693f60793a64e93fd08c10f8d3831e37ea21641bac11a757058e61b4350a345aa536eb7bec455d2c02652a61e62015501f13a67cb2584295c02ce7b856c1f7453a7410e7e32da867a6b2bade9cfa562224220f70b1866d7308281a0357a9d0c71fc07f88bfb330491eee9d2a9f7030ba9d8dba49693fa5721fa9fed2704675266065a3d6bc9edb0a493c81fe4f7d1adc78cbf53242df0878fef1e62aa8d35945076a162214023456420296c9f33691bcbfaf90cbcabfdcc1be53720606fe090b2e2c4c349130a4fec21b73bb8b94e2958bcf5c756eef628fb67501a138f09d8390880a4ee232562dc7695ea6041bb6a9d1e8ba0a104d827e447c9d0679dd625b44544c4d6270e1b7300211be539662224c4c57597564e8d448c6b4dd1034008be3e57daff07e12d516eb8bbdd8e6cb26a423e0499592747039d295570bda7e30dd38c97f66c544c3da8283b2b5794327bc2b7573256cbef5def1547dc470314d28ad90c2798a95a01c5934e8df484393572edaf9a85be08b713942fa803cd274668b8549ed64fa1079e8133b78eaf176a22354d5bebe5864ea04f90515e1137199a6d9b0bf73d308b6b46d4841c66935b9eabce658ac9d0db168066bbda3e89bcf4fb3c0037a2e39219fdefeb75c16832ac3a1a867a20b23801e87ed09ba68918cb680495e82119dce459ff02d086568fbc142ada1ec1577425e5597dbb6bef1805ce99578cc4ec394ba72dea668ad51258a147a7caaa881bb81de970302472a0ff78ff5740a1a03ff9dc11ae1b714c93c34d61505d20bc9251089fe6875965203394e2197ca695187e72b0f123260cdfaa65fee557706417b1979fb292d8e31c526a29ef89ab32b316748e4eddf30fbd799e3ffd34455a43ad2b85a54cf0a5fc8e08220f8b3bf932153c748fd177cf1b62748f353d63f02ddf93243edc14697d04a758b960777321c476c921452cc8e5c2459af49a03a23abb2a0b660f591402e27dc3b1ca0fe14684cc8f267c116394548aa3fc3892e64e8c53960e9f1d35b3f5a950c380a40a4c90597f65558d87204aeeebabf53fdb6c38b2e865ab46efa5cb14ea230adaf50bfbf0acf7e90f9f276644a6b9c689678ac6bae4fde57e207e2fa01a3e2ed5edc39e4f337b59ce2bcdd04296ea26a254832a15436bb0721c5f729692f71012746defcb95a56b30599649c5dcc265104b5b8de94b391db5ace2d0957bf5a9d63b27a4768e58e8c8eb0de9af068d2fe280936a68f74afa028bd26f156cb03661d1ca3b4eaaa65203d70769ccd40164044e4894b3af83071d9da66184c1f20c90ede721339ba01f5d5c7702c1884454a41006b7f875e315e0b8765d1faba885a36e8f542a11771836159eb934a83a33d8561f4cfb60138de8e2198087f078ec5c22649a3a056e2be4d005e2a9d406692018d4813cd6e1e06a8d16b90b460f86952981b3151a8c086c0696af251cdc55407d12e1d093cfe02fc692dd0a7e7a6f0ee916595c6bc81dd283de210ddb8d29469e3a5e958c682d1da85991cd9027a7cd62c5fc9d83e47edec8d314a76edaaec00da159e8129479c9f274eac3f3258d93b183122665ea961607ddbb3598518444af3e0fbefacc93b723d8fc77ac5b9a0b63e247b525987b7c727fdb2906fcafbaf4a7ed2a73722e7b06ecf242fbbcb220e2fce25684989531a99b486398e064e70e98e8627497e3b507d271742b651625a4b5f5c405bb923e6c9a93d66d26918750a931a0efe3250e462b7ba2cc0335620e44016f50ce830159de698f24f77f683fbad98b1d7100c06d27cf727f26bc0597bf15840cee145c6d98aa49a3f7557b1142849b3cd25143fcadd08f3c9a3412e4a822f3735a1b96a982fc6ebc62192f3a8ab446e95d87e1a4afeaf7f8b9020bd905f8f5cc3618fc599c8d61502a506ddd19dd35b2cab2a9324197fbcf0ed2d1c944ad192200e2d37bc4c8baf15eda292df00ea061947861e5c33b9d78b89eee679b0d3eb313fba4ee8ad094388e78302aeee0eceafb95e5383bf0505b688603d8c4cdda319d3fdcaba39a37c452113bae93f1bcbb27d8819acd0748cdbc488f2f2a706d38456233a51930441a964cef088d3feaee8e9c29e05a09d042425f1b503ffcfb6de29ba2d18198d627904224682ecf1353c56383642e26ea41351fb54d488a57557c0691a2a50ed175efa6ed8d81691f6b29e88c179a338899c0b29deb6fd81a6c7cd3da2e7b9304473a255604a42503247d5c4cd45fabae7fd3eb576d71abfc791754afa5870c9817d9c8dab26315e671edd29ec9ef8be9d35ae7626da26fc902fab75ca94c0fc7f69bdac9dbf2e03d5d13eff3a2f6909b72e62ad132593380f3e27e87ed25024a10fe8d11bfd7513f8fd14f8bd4387feb74230f7d12c79c9ba8113fc18e6d320b286b5d1dcd11918c4e8ec907725635d1afcce8333116dd6efb338223bac50ddee58f450686e4127ae7a3812b66ff8a7a966a1a98a277196361c592e1f47f2755313123e283a5fcef18aea70116ec2b150a565b555efc6f8aca2f1e2bdabfad09ce8684b6051a3c138374e82a467e1b6c55919a9e15531a26b632b0abe3611c2499d4a81b5921c991bdd8155c0cd70afd9e9e220a2db2fa0716c92d6b23a4e0b11d559f6ac26af3c7c3bd175b47846940e4ba08f2514f1b063619dfc12094495489b14fc16b3c5b8059b2a55aa8631fa2e5db67574835464cc639ddb3be8423db15c92e30e4786ec1e06bd078b8286174c0d362a7506a29eda9bc924b661af152ae8ed10cd86961d999bd5ead9dc49acbf3a17d0138ad5f622c48f6cdbfac84ab689d68d578ca363dc1f7fc1ece92b3cbda4fc56b41880b6460da69cee525f732424325c958d05b6a2a1a6da98f327260fa9de5cc1eaa7555dd07c5fe57d3e5b4c68f989380ed5ea0d34f7d33e515a78990b6e34a951b81b4a6814ab2de95bd4098aaaf175d1558ce59f352b93e0de3e45c93171120b8d7d9c30d9f0ea28ab162cb6c9dc75c1cda26bc7b12d8ffe70a99b677cabea96ff64327c7f555735e7e043298270cfc94d716de9bbecee483209e1cee7c3bf43ef6f0e744b89b1b1187522b6074be37d26cbe626fea9dd7db09dd327718b8a46f992cb24777549f9d6c1de2701700c16b8960dc9a554d931f3d552e5ee55660ffebbe7aced54110fd25aff90ded75d517aee45297820493ecf41f35696b616c77fbf3458356445aed11ec7c239515d312388f45189fcbd4de2d722fb584dcbab8daecb4234c8292129e5ccd8781540cc72981427f9a25d255204ddb96ea707d20a57db349b65022643e6be28633182c55433e16701da882dc5b67f7b3fc64b1786f4bec7c6a66327013833baf6703fd6995a5306f9c06eaac461bdc73542ea3518fc87b852aac25ce69047d3d7445d305cb3ac520855ff1d76a8449584b02b4fb436c02cc30868dddd156ae4194e4791be44bb82ac1a3cb32618f6cf37042331b00cfbe84f89c59bbef5c6ad115159c7d34b36a8d4493ba118561af69a4c215ac020d63ee70fe5f0198c3fe3892eb4092a5d7325e0ba735616b683b34ec621f17af851646610b4b481f14242bd9fdbb553cb9ca75a835e639324a5aabd65bcaaaaf906cd31da07d0b92c178b6bba5451fcd5b83c95a5c52432ec4c67b86a6e8c40fc79edc1415285216052af1bfbfd539a4791359ea15a1fe651df1f814236f928e93e6ca29f0f5a9e2621e3581dc16feb5142d4785e0c28a595e8625fbfbe9a5c6cd44454b51e5723e8ac1ef9b1df7ba4ce80dafd2af9902a1646046e48958a2d90e5dca261476efde6539f432095839ed42f61a93bd348e93090e6525835fe8477ab06fe067af68eafe6e6819cf4cc4f25305f8f2925afe4c63f3be5edf6a6ba191624d7aa5fde9a9b0976c8de50b0bb9e56d4b2e6fda5c36997fc6eeb54b9eb8fa2b72ce0bd8543f00c9912845aec4ad1be4a19b6581a44adbe5a7bb017eea81b6e250ac517e7925fe84d103b445517600b76e21f3924beee5cf9a27516859f9e3ac1078f5d5b23a3e2baac212c47c034c6e60233559a55c9e9af445ff1980037bd10e9ff9b07c29cf6a438053023156cfa2b36d46fbe448b7eed2d805b7513370b46f4ec6aa5c880eb43c8a7f86b46c3c45889b010576c8a27828b876937191f45ddadf203e636f48cfb2f0753fc2b59c3bd6152ded5dcc1dd1acbd8dc38597ebff42950a302dc61de013c37d7058959a25dc301527149c5842636794e5cd087cd1ab9c02b313a1782efee73b9f6c4e14a0552df82c8b5a620194ac992a9271ee8373864a07f49cb0bd561c6d833f5a04957138208fd61072b609dceacb96bc0ff4d3c3eb4d3e11a150374e80a547189b96575f564f8dbd1d3a21d682bb49367f13f6d727f2c6e36516f35f603b7522aebc919c196f2d02c3c2ccb129e644ccce68b9510a1a2abf765e747286b1092ea757cd1813c7bfb41900d30580bb1beeacdab9fa41d22d534aec3043e6ec6a4cf423f122004fcebf9aab86f81c27f0983e3a4809d272a111883720d18d681dca7d44cdc3bf45362e3b81b32681db03abbf4e9469c5d55d3b5e6732e3d0ae6a07e8095af5b54cec16e7914b9d0d2b38569c0d66281fbb7eda38c16598727f22a2a3b730ce5848f9b5795c29dacaac22685d30f786566f25f1d1310efb14fcadf19194a5e19ea07ada967575416ffa969937f1131f6faf3044282eb0d0b82858d13b6bcec5b1aae2ff4d6bd9c3b21795a7d01c55f60941db64040dca5fda0919553b3c8c16ae178b4717dbcf8aea4f22ad575077961f01c709ca811068d34ebbc90ac3666d22a86e043fe4f1c25af9c6fb0bdd90dcfd3a2fd6a8321c706b45e0daeaaf293c5bd36b69c3cc3428b258a52aba5e94109fd92d490994dec56a6682d3dc88306bdf085f8352bd02cb356d82f578875d78b216967f4ef4068fb48e27fffc7eb827ada7ffb2344fe53f04a6ec136950d940ae2cdec089260e14d47cfbce9a31c6a08171ae0278233fdf91998044fca3a1bc9e9e159e0c43aed1a50bb556b68c7fef0bc3bbe0d433bd6c0da49e4923a6d3c2dd8d678e69c6c73984313c74c83a078b57fa9b28c309e2a6bc5a1705cf2b27d9e0dd6d5ac5473c3645c8cf1012baaa2e8c4b6f672bff1db22db4d13b9bc7a8bbffaa3051ca022e9cc7f51255f0cf0485bee9fa93bf94d8be0ff6d5440c7a722faed50cc5ad8b6102a3c4035b490a64ab71ccf2c91b10fe27e0b8e5af46fce4f11205e49196fed25d7e7ad2e9477196397428d6fc94c52e68ae2b59c7fd1d3839dc541634bb13424b8f317a7a49ecaf15daf0b1a95dfa09893fa506830e71e496ff3f20f77b2bd54ac15e16d55c2614e3c1eaf8774f5dedf3c19ab073e38bbae03fe0df5e9fef94a082d6ba74c98554fa380264e0c75812e01f219e2d67dba424d62eb23a180d28037bb4f6e7ba49f00fa97d52526aa9cc99adcb2e850373afee287bdf9ccf737e968dab49aebb4ee065ea23628ed65a7926a27e619265ed10849d7471c1a093f26284906e5b0d8164e221e535875874cf6cc3967a66c36580425564871f03bad5ea6472b12f08ef3c689d39fb507e792486d38f85d99cff3ed6b1985e487866a97ea6cceecb9100d79a10a0f44c7277ef1f6f8d880584c9a6fd449d6f52c4848ef75430fbb3205b063186c4ffa42a6d338af779719d2e9df366144c926767ae25ccb9773a90abc35b84b6a6b2c974c4d30218c2678022f44e773906d7dfd6c257345e971454bc8bed0c3ad816e0bc42ff3a9770db49785d4704086abe3448318e5513684210a9e3243d5d1c7df6421845a95054b77f405d634f993912b40d9eca7cfeecb740c6a409a9f5ca446b765ef4e314d154715493ce14a238d0c0135e0699bb41b477bd7bd9e224d399bde9685648cc5c9fccd853c27db6e9be7642a3331778ba1b78eed8d6c56909b8177717f5ddc538522a7deb9290627d5465a776392635fe3aa780805b7d8a1d9d1afcd438cec7db144084e109bc17c333c32bafba5764029622d6d1c7e433b9552ce4cab2d61198f709e64f6fdb7320db5e5cbd09db9737c6bcd9118466f1c8d6335bf0b07b20361ddac5e65557929def1abb6a7efbf9480675708925068f738e20ffa4203830523382f8580aeb10504c34087db3ce3da5d77e97d06a0f1fcf6078ef2b6e6be940af1e6c63b95d1697dd5a5287082a470961032f8ab93c172d57c5690e354a7a268581812f9f390e97dd45667286d92ec48a2a41c42b863ae0cd412648835487f296e0ae05a5c1ee4188e6d3d65486e7fc379a719e6a409bf8ec3a5df9b2555e3da5303c1b54989f6f148cf3550a4ebeca9e20bf667b0a7e62fe697ee99cc2f1a52e26d77d8a5bf1b340e20cc4f3138d859dcdf64c8994b678ebdadb0319522c352475887adf26612b4bfb6e3c796fabdd6d2e4f5159a6e0c60dfb47fc1b30ddfc347c4b40fb1b37eac0c511b27928fc106ee1621a140185e2fc1db755ed81a58a540cbf669f1c6461631a145dc30aa11b73fdd30e3cc337dd5e443f1df9f6435a5597e88817de5b220027b9533eadf9d0a73f1621e12d2bfe7381c0f47690c617a03fa208a6269c259e8d8f2d4b324e6cc0ae9a973873b48f387dc10cf792cf53c0feec3f4f0ebc23f1008b6b6908b0da6f1d87a9ef77a1ad3119dfba189ab4a2d33e35361185033f8757964758d2aa78dfd8da5b45d6ca5292d5ac018c93d1127553f4733505c7071c4a6ed558a93f1ca9355a4659d51ae04ab7cbd03f22f1c83f6af3ccebfd52ddf60fa1381cb7e6f3a20693fa4518113e870f5030cd45a47b11e624aedc20150c63da6b32984e2a8c945d849c4594330b13bf660fe013499409c99a01312a053aaed2c9ee58dfd1e30316f672a4aa47e3ad43b2ab728cc1a07762e5a17efa667e2d533eb865c878c9a75a9b9bff883a80a785be98075f2aa018bc893494e7497d1dce3f443b012fc65effd6a7f5295edf5bc6a5a2d52e021bc039529725df494fcf22d2b45d484cd315a4b467e47254f67afd9822c37dbc93a10281d72b67dd674f9188e9b61c6dfaa93342b45c9e5d1a24cee1d78990106a46c374e85a50e8e9266f81a3749d7314d9188af4a832c9d18996c275c95341313b34fbd0bb0f9e2c0afa326899ddebe1a226d7c05e392f9609b10d0dd254ce12c929bc24247562744559e17d2755a59bb1dd7e0ed56d486f310bf17370a72d9d1ac46b01fa2a35b1a3079d8a8450df8ac50908cc0b20549574ece981c020b5082f5c3f05912435f51ef5de3d1fcdc8f4826133328f3576fb07e7043aa9d8fc2865b18eea414246d819caf2710daa4724c4686950346b655c2d34171f825907916fca6d3804e01b6fb690225e00beb3d32f50fbb7b2db28bea4c29a5fcc370662a79d2a0cb058c741a2408c3703b686bb130308724d42f205f749934b3ec9715bc78c5759461e83b1171cd3065ba718ebccff66b532f8f8c07e5a445b3def9a09dfb83425934aabbddf10a9ab6da7adf83c7155042bce17576b904a952238973995f2e3d340d2a7fffd77fb7f480874fbd8ca142b8edddac5bef472856f691c7a299f595229367a0b70b9a08f36472fa0b7d90a296e894a9865d56a61187a05bee63dad6c3c5cfd367a60995f5a12499ea1f313a6d0443ee0bc33ff27e5fe63dd55b21f9d529418b511df2e6bdeb1aa6275cd1483fa96146c15fe0077e349e851b5331edda4e8ecd859640143c198d7b241217debaf3b83e0bc05fec0d01b1b0cb13a8dda29236d6838c686ea9833dbdc445e704315c40cdf80053d9b9d9b5d23a262d90ba26386fb922fd5262ca0f53a7c1b5e01de3fa2770f16f460d71b2c12c939c6a9d053800a17b40779673be950ebfa3a61695c8cc2d48a829f86696eb50130672cc6a7f3d8f75049db11cd8f1b75eb56bb5f3f9d75cbcdaf906d0b8081be0c3c85fbdfc976b8391d889405681a4c5b188082d81aa95852d35ce81401ccaed68eee73711c9d06c6e28c0f2b644b6d5fb6332b98ff51036f2152444451d2e96879226171bb2423dc0e51ca1e9f9294d44e8afdbed60610927753568f1108be7eb3b544d7ab68251a18cab21371fc12426b085e993663a66c1ea38fedcab61a38be19279dfea2e1290dfb9a7862169f741c5116c19bde4d06a4871306f04047885a62a74783f4904d4f05441dbf317f117a9e2e9745f9f4ba59ebf0d4f7911216d7851fb3919224aa3fc53739470dfa8a962f55cd46a6d1d13c10bec53dd9172278cb79057e20fb6c2957fd64256a0ed7cd8392065bc82385cf32ef223479ca511d9fcd373cc598f840da93078c99ae90ef8e8c28b6d9f33ec4c071dd52b432532cea666870e15a47d88f9a77f6186702565b42c7d31860c725f1911e9b544512000f5767dcd53adfa4195568528d6eebde941accf744649905883a9c7467db25df22df7333bafc17238d35b2ce1ff320b8ce2e6b09c45472b1580a56e4bed3d9043b34d07f4963230ebcbc77bac829a83f16198698cba170f8a0dd5e75e1161dd509f67f57ab6590170fcd4b48a0c0b71d0dda19eda6035d06c22b7a15b661a0e5833212c6a5e929b90eb3324c67ab17f4570b988c8bd80fd81f8597d92bfe16e5017eeb7e0bc5e2c1421d86887cec20bda1fbc669e4ebb573cebd9c6e2524415d42ad29c51d9c1b76d9623b80662e2484625832a1521a661cf1ef275920de16a66ebd46a775d54b37b1d19c35407f6f9bba7491789269723763a12bb56627c3771144d2c5cadf75e6a069041ca255e25ff3ef86d12eafdeac9710fafed19e00496ebfd17b25887734108e884384ac85228c8936715bb375152c2233e1ee2ca0af516b0b6770122e40abc605f7abf823c02359e6738d6b17ca81189803f04368a5e04920aabd5ac70b4769dbbac65ba93e9e0a81cc07d26035a83aff6d449cc45345a4956dccc3a6bd9e0358189b7acef19142f3dc948dd31f4f54814d2b66b6f9dd3535f9ebe2d561a8631123f7a67fa279f62507049dc0aeaa21cd47d870d583ff74e921027a5c7bf984395cb3ab74dd2026d2ed4a5bcbcf9a0890f026532413457d75a6064c6b0710224fc1bb82dbbe11478d2478926e52302b62eafc75abe831d11489a6756169d856ae4df1b41c212342081a22bed9ac8adb92639a5d6dc17a2e149996799e35607d7efaf812f2a577accba34e5843d458fb39f50a3fae5c6d8454d1cce227e54f30ca014016f05b79561c5e3b4069c5339dbfefc5295e68c901a6e7b5de4a79620cc4fa1f756ef2d666b7c798aa6d3bec84d55a58cd69546aa69cfdb7cc4f93926f8f1ee2ac83d9a1afa9fbf96c1164346a077184425890b766a4b513fa8bc214f91a1f964f30225ecbccd59eed1092d91e704c7f7894728b6c4ba9e7e70fa38f65ebae442986eb4ce2e20e981455a57c6dc69be8804fd90fdd1f17e2fb3b05e69c746ca899e0fa08ad5a19d7ee5caa27c185430dd6aebcc833d5c73be6254270bc84352f9f9e5140b5330301862ac04d61699526f4194c7dd2f05416faabb010ec8c705e1550bde091eed1858be9b23cb4dec97b29515fac990abe70d72835dfbee4e39ce2bd3ba8fcdacc0c2efcccbfb8eb5128c3b422dfaf2ba92261a3bfec828f7cd60f219ade8cd87010c9743cfba5fdfa12c740fab51ab8531455e550397434386d27740a6d367e954bf2e03772f01321e0a99ef3fbc3d8444b8e5847ff423f9272bfd49154a67d480d685d3a523185a841d10813f7c33822cd1b8e8ac23806de977741599505d5ecd3d836b676dc10fcb1f1f81db3a1acfaa9c1337d07ea95b29d73b043bed60f0b5ad91bed73c8e9d2d2ae3aa54213510495cc8762f40f67c6d1f18ed230862c81d4830b292d0835e0c617188e90fd90f19513647a43ad97f10eb6e61b6796eb196052472a3763a83bc557890d51fa5d5f3dfac9d4d67d43f038af9d3f4b97272fc66ef43fbe932e9b7ceada9247463278ca446d880443d886d85150e0c37865d6799a73c21b7cae895d2481bc259aa5b3f414a2269a8ecaecdb5b6198f17464283cbe4a99de4814aba217f1eaa0d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
