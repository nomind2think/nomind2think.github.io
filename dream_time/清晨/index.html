<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c513c1aba4624ac65db9cfadf4cf09be73f88d3d12c8b816966c6c7bd49507ec28c083ea95dbf01edd104baea2d14edce9ba41b1a05dc376ab78c026af72e4d30a6ed4054ebf0fa74de09e99f609130340fbd0e6bca5d2b664ae7a785cdda4f99b8b0c036cec0f638381055dfc7c9390b93436d79ddd92d38bfa880b4ff8ca38ad2208a53368cf4dd76096c2e73b4886ed95113eff8b05a7ac13ac348d777073e5122d31e4b24311b47aff82f96cf126149f94178fdd8c258e1fe7e822f5cf7ed46ad5523fdd5fb76da19496c36a639afb372aad4abc078df1135d77aeade9a4745ccc77fd709c0b6209d3c1682dde71b888a83bc579afe66629559ba50a1d347d07a9499320fdc28864323e0611cb3ff7579ca8f3b1c7af5443f2037ec4f084bfceccda0b8f573d75b3462b3f6997e13f5defb868d3b7c1c6084b972803014f7116211bae32db46e55c79a1218e27211bf1ff4188fbb533488dbb775f7d46e6e32abd49ec94b0b97a634f523cf468f5028fa6b9744158319473d30aaa84b4292cdce1939f99d9ba41204b878726a0090cf33d5e30cb6430a8b22ff7635782b9cb49b9643ffe695899c977d46135c0e08755ed8470eaef799712d98d77a9a64eb87f4f08894bf348234f3ba703bff39fe619e2a0cb14f454c1bfdd66d033b421ab28ba56f333b11006d9d0efc573170755c41b9780eca957fe33134e985ab2a7e42f874a216e219674b46c251e5dab989ab50bf532c641873ec8b373c816179ede362d7c2910cb2482a96f65e9b82732ee5cc6a0c135d0590dfb9e714219e03b03658f82597d37fc170fdf9744f788f6f310e0537e9afea5f28840de1ce3e85631d0be6377313138c18142a3b6ac77d4eb0415e3f456670a2f867385f2f76c37a17376a1fd242f8d9afd05c6dd9b4a7c9ce02db11b0c11d50c5d8a4c953def3cd0d8ecfb8d2a89d66e26c330bef098e50e17591ee373833e09841c98cffebb146ce7e75c52a3cb321fc694b1b7ef44bb5f5bf4ac08a32349993e54fabeebddaac2d57da413d7212468f67f28cb3ce3a8f09bd660516ed79e346e969ee194566c65fb64ae2263b682832d834f10f4ec21e67be78cffb48977e93214c6123d1b89b71eee306f57437e46ed5c7f40400e3c6793160895a630385e81d07993d5e92b13ea1117fe849c7db32bc84c3ec0cfc7c254f317a0d0f32ba0fcd428653e1e35b9edb95a44260b4aa1e1d20c34aa3ba75baf8c85d8e6eb02b89863b5a24099d2754374a2a9a80ac1de9982df5f04f55afc5e9b84b9022969835ec705c5235af1775621742d590ee72e3eb6689a5bd61c3f93ff53b39b79296cf8df03029f9cba20232328b8e9dbbc3178d76aed4f2b7de869869ccd4e811007b23026b01ab16915692f878886097b5ce3c1b27c3f1392eabed40516a9468ceb470d5625740602c42711a14f0c08c4b2d121f2c4fa90d617ba77a2cba6acee4cc4b7918350c9dfd4e2c8a76c9c50211847707c66a94bd9834f34485fa6a3f76055c1f9c219bbe9334260a3ad1fd8964b34d1a8187281f6fce67e88d3de891f9f59499486cb0b7b20434b1b3d958e60195af54af85f60b05908909268b9afb773cae122675d3fb57ff3f2930a12a774cf2bbdaf2cbc06bcc5da42b900d5532737205a7af72f523b37071bc2d84bc426b6edc95117fbb282163496cdb6984f8ece12813b93faa4a0bf5b111414ac5d3c06f1c66c226d8fa5c0893a66e2c337940b223c73cfe17fc1456e7b4c77b37d5457fcbb7177615909adff4e65de864f0e5e5f9b87b447e277e389133b9c6014d28408efaad89edddb27ae022cebd7a165220221ed40a112d82aaae17abda10ff8fca3b59406c2b53a54983a78df3569b13d455a979794d8c3d790a07eccdf20fdb3dca857956c3c82ee4111d2c4050a92813edfd3af50e0a99672c0034ad87d68178f433bef0fc50fac851ca624bbd0f7dd90eac7dde2eede724ec7ee9cd18efaad4576a4fa84ee3b2ccedceaa7e800cdcaf585293c2960aa3283248996633d47ecf5398bcaf716e26b764eb7288b3c2fbc83b02e9eb861e4a526a1f00e7d339ed2fa5ca3af1756e21ada89373a418cd838ee922a776b7e40ca38b7643aa5499a24ec095bbe8be02a2dbf49a9eedbb81433205f948e78d87e461ff9ab58e54c06ba1c1e60c90fa6ddd45ff51c8772283a527671c342722513131d45d726141906c28205dd7974bf4f828e2005a35f6c2cd6e2ba2bd6be6aa9b59b6827f93cc7fd5e93ae53ac6ddc2e4e0a30ccf9a2c0ef74be38de1ed58459874dfb19f142f8acfb71517c149364653c01e47ab5a547b2fc122b6a509a7ed9551e0c6c32306ca03adae844c310a70ee5c79622eecc82c897ba0fc0533f2fc21473b8b9f52babfab9d41c6d80ddc01ea6b3dada0d0e6a43060fc24f4d663aa48b2bd8f0442c753fc947e436972568c1252156c709b24d669718e4b5670f6043e940af874b04495d1d142129398c81aa671935512d222f41a67e865b99fa9039f21a3b7479bdcfaa3f043a1f3d6d9a3c1ba916bcce4d5d35d71a9630613dcfdf27e13176e4a7459b03aa0199398700331eecb05cfd3335921e0e8e6895d230a2a7d610459504f25a1aa6aa43b792c16dac83918cdad0581289e7102a9bf68ee84113add167cc78b2fb03fac8193c6a598b61e4eef3116781c74b8932081156bc3c1eb04e5029c36464d2e8ad8ae0ea5c12823cab1c6c3484590da6a3867f9ca1c365d898f9f297cdbc8750fe2b37f0fa7caaf1dc1039dd7fd795510134a9ab0b0bd6e38df8712da9857ab431466d6c35a1eca0a6373dd08b1429ee7fa1322d935fcb192d6b332f91e18cd63be047458e3d6b80bade3c5ada55f3bdf3f5d05829294aa6038491d2b0f50f224b60e8c92b1a21a16a01bca1d81d9652920732faeb608a666453c51b824c5dfe72f9730188b5b81e23510778d07e6fa7948e6124426217a7bd05de5df1231f04e7a5b184955589b84a247b9c323128cf9b256fca7b0a06c886a18f3d912a5c8474eb8c84ddaf1ae4273156a080b96b4af60b2cde45b46b9346aaa7b1a2ce612a21bf3571317e5b818b5d1355336d1b66c21160f48a5ee29e62ca61e535d9e8cac1d5442fcead53646065a62ba710dbc114afb6a50f5da32f090ae09c848c9338368227979b5dfd47c77c07d7298aa660b079cb56317ef736bed564f323e72f68c908be8ad2d39edb2b5f96b2fc507ca21f6358438f7d5b1d7aacd3a92404b649cbe00116e97fc34885fdbc460ca25a3dc75b0b5b1539093dcb75530d0d1aab7259c7e0730a0ba4ddcacbf6b412a34c7f19d8af561670258fdd3d6b5cb061e128bbd29bd0f737bc4f4ea47c823eac949d81e7af8311320d6985c8b08913ef4552f15a0e1cb6c2df107b70990011a861627df359e80066784c9b708468501443e50af971dba2bf0e681dc435f2d07d279404ffab818d431924b4d84c0d8f3a39db9a03f32294fade9d8ea60414ed5bbd2299e263dbd620af93a0eb30db1061f380020b63c104e488e172aab7d80c09648a6821d15ca52796bb9949ecb973e9fb8727ccbd9d91795c5ce7a1052347b8d66075c2c4e7c98ef6f6cc6331f5ef033e8b7bb7e61b930877536010331784adee4406bbd7a0f486860aeb81972cfcd51e0106912fffb6e94015efe36ba91c43cfa961e1a17f38a3e8a1a7a636ab790570b3e197c5536e00b1bf279152ae9609db2db6c7ca58ca00f7798a990e159d38b06bcc6c7186c651a4529b2a6f2827a6a49a997b89d216a437c96432459e9ccd6745b05563e05403771a7d3890e7dbe233d6b061bf539d7faade6925c007ba507914edee64df65f5acf7903e775aa1022dee606fc1438e9f2b21054bf26f91724a23c366092839339316ca9d8b7695447419c6711347320f9b3e8e741fd8eae2d56cef0888e568782bbe8da3898bb518bc95bfd6936554786cfc9e6ea69e4943483daa1918d284e168cb439452576ffb4d1702610bbbd564703059133676635a9890a387be15a164ed109fb4107b5d730db290ec4a0b5666cbc1cc6dc6b6813965abd2276ab0e6068eec25c73706ad22732ca0e28d499c4db36c20f319f2ab7936a4a87bd3448854f362492e5022d11678235726e04e3dc2926d0f5ad8d82a4bb9d2d657f9077b9d9c7cf09d0c525fccc42a0348599db27228bef97e58793423577532147fe649d0fd3cd0e2b5e41b906c9009a3a24b89e056947fb56302b9f2325f3e78be3290e96950bd8ac4f68119a97d04d9ff1e652ed73f6ea09d5700ffae10ea0b4091149fd04b9a4f48d1ce04dc4033b1b27d52a088bb0fc71260f2337c203fe4fe0f3b9ac59482d4352482e8c189879c740ce2326887a9c0e5e4366026306a2dd72d3ee0683fc30e1f221b60f7725461267b42e5c080cbb2247e0189a30c889839c18e6f3fbf87acff3e14a566003c978850873c98077b1d988776148f8f44499d4ddd91113f754239c094f2e5857ac61b21127e617c6b5d263942e4544a0e84a1cef2fe302f6c1a323a08e68156c6e7287a814875254c27a44bf4d5b47d59ef4d45c49374e808cd4fb04fb2b559c0ef5ca9a663c5ca304919ab931b19b900219d47250ff8672f93848e380714fa487ebb9791c833fb2bd50fc65da74988cdaa0bc27729b578f6d4e3bdfbaad8d80cac3a19c91b34506c8aaf3de7bc80dbf71f27b4e9c64eee9be5ead5eb69cf9b4c3a27daa0b3547303e7fe9f4f2b51de62621e86d1f06f8d59ffef250b8e1a819d1ecc85b26deac87f370ac3e1178ab9fac9f0466aae50e6b5ad2e9b9d9595d0c88c9593156c1aba4615dab2993045f7742f533d8968d0f714d2da337511d90f5c64208e2e66b1fb44f421f6028d410e5c2ec561273b038fdedb26029f0ec95d4df649c77391043cdbd3493e039c824e7cd802170044a304e9da4fd99119b7fef49a0fe76a4ca62b820e2065d6b41ed8e033f02a32bf077b2fb598ff40b258d68b2c78a2b4cccdde4c55d699e5cfb39401baff2f82909de649b48e122dc958b94fddf910f51355c6fb0018605eda58f24a09fde18d99e3b6c8e97a71723bdbd406733b090c4f7f43a45107d4c47b156d5b52bed9d8d252cbdf7e27c90216d6b9642a058cb62e0e0fbafaf072abe692e8abb96029d4e12e3f961423da24fa4f768304d0f0060cb1d48a1a73a3e0964cc8b1a44a21be48191c495b997154e7eb7b4883e21c88e655d331b4d96aa58423a6d0cab59ba520aec5c711298bdc509f35dc2ccd2698308a77b7e36581c259e986ec655e53cbee1f4c010ddc5e4c00bc2faba3c84ef901c4b9f1caab85fdc1df41a1780b0a6e14d8da446a77e8f57921b57dce91f8d27bdadbbbf23be515953f49d284acdf397ebfa012d7354cfaf99d4c4011253e697db090bf5b1f161e322078cfd77f51b03f30bc4214b3f5bb5c9551cc16919e9b46ff517cf1ef5e65e56eb8470e73cfe92447f46d1478991fcac2c60d651ad4173e59b5a1842bcea20712b309355ce8a0f4785efb573764e68857db9de0b5f71f39ac544310e780579cb51661fe4c2ab4e7eadff7bce003d41fb2a3696b18a328cbd472128e486005ab213b0c2022b778c4bafc30bc1f7974c3b0c852a0f73fb85c9d7db8142b05fddebb31f294fa9eed96d9d8b89d740ab9850ab29a1492324f1132a808e141808ee7f1bbe1f544011ba1702cb910de63d97009331e1fb9fde813a6e0d4d9ecdc2a0cfdddffff499c148482d2e8e05bd32f3274bdf5c986eed80cda0c7acb71358f4756d5a77e80f676a2bfe2941143c284ead1306b64e6b938469eb865f0996afc1992bca8faa06f5eca7336b028a341800c6d230cd2076722461862be4678a3c639af0aafae11fb85ba13f386c26a1945aef151bbb772ec14039dad89c7b357780ef5221a731967c900fc1c179ade043dcbe4b41f6776495cf25b5d18a45aea3c92cb0575444ad658edcc54dc298b68b7b6b59493ad09240870338f4c5ab0ea802632b7ce6a2ff4a9f25817d916e2867ee6c8510fa5573424f869febcf8d75d89dd24805a6e72f357c242e9f043c95233b533ceb18d8b62a04166fc60f119aa4f4dcb8c1bc52611d4593cbcb884ef33b74ce553e6543fe719b4573b591ad162b031bf53774ad9655249d32f24ded873f02902ebd4508c1f31c8c6aa53562db783b0cf88a0b1c0be414a0e371f48aadd0db226b6270ea826731f7544610a466e1c64c0dbe9c1525813e942231ae3d54b0fd8120211c9d14ff3cedbeb57ec0e52a5766a87f0ad926a39ace6b0700a7d74640c5191951a706b952656aa11501acb257acc8da4f58bf56f3db58790e2e334a2e8ee2f5d71f33f0e83b7d244bd79ff19916eb638f5a06ad0250d0c1cb278f4c9d607e15582cfaa220ab2eafe575f40ddf136d5eb4ad1ac3efbc8f07c2fb2e60569d63ddb774033389731e4464906cbf6350fb54cefee6583c52ed8514cc6e69600171482ce20dcf485e054124f7bccd93c98ccb02e305b0298725b20aa0b0666590db9e940ede3022d2cd2ea003d10635a391d7affdc4c984b3f2abff1ee0b62374bd7457fc4e20ff208dd5defc26d8a82fe1f759d051e673dd90d538e33dec11086c579ff4644e9b51f775a88acea84d1f618bf50e9fcc250bb3079145032be56de1b9ef8107ef0275d5f2fabc2f62801d97e5ee0c0976113f38ec2ce0a19da3cb44ab871017ee2da74d6761b1b76c4cd1b2da1c230b4ed827dc5453e82abffb5f251df8a16f3b6c7010dcc86cd40360ac3af1eb4401db9863a906ca4f9706fd62ed9ddbc6cbd937a33a18f19374d140611d56cdb1b3b67518d5aeb4413fbd44a3b6be739b0b5f736ebd163d794e2c325e285edadc1d71acc15ff54dba85b31411fd44314715ee8529858076ff2a4b9b71630b4a6556902a3278cbd2e63fd861aac40e36c49a13a86ebb9ac2b2ed453ee601074a2f60b6b6a6664e6b46232d4b203f98dfba22d65919b3a04d831fcc54fbc6a4a80a543e12ac31203a1fd8e6886b89b768a35ca58276226a505bca4e4c576b8b875857b0a4b51c4f0d2882969d016ae4026330ac086da93044265b95b0f9eae23c6bdaf89984df10c850fb5931a39bd920df348df8f3940e46b6c929211efb6d6efb453efd95a471e5d51447be85dc6fe14a5813dd0e064f087ef30313e96db54850b9e3fae0330f0358d2bac06a7ac78893e6b4cbabf13141a798b6b3fbe2d44989b6f303f880aed16301aeec5ea9666a7c327c80b72d597f4b9b782e9de7f9ccc70e9970fea2f22ca8e85b4e959011cf26d3fcd1283c5541eca8a0b05a31d7eb494f67f1139eea8e151dad494ebea3c637ac3b891440cfbd3ce6ad0102050020b94a0da0c8195d9c0d2bbbb5b529348a3f0f05c0159fdecde6eb73feb2db78c03fe0a65aaabde9a212a871c3cf5243ae1e925b9bf9c63fa12b9a9b364fc02f42804edc68a74b8da0f2ffe892524a916c583ce9d8c53ff1f730e5989039f2bd1afebfc80ca1491ffbbc6f78f38df5fd68cb623728ef198bc9bf8f589e3a2ed289f32140970f268c6112aae2ba1fa8752fd5aabe352717fff2fba49479badf5cd8991e8285071e818b90d0c2dd993fc59dc00c1fd2b7a5635f36ce34acfc3fc6e5abf9fa99a45f5a9cc0acf3792b97c6fc6a4b88dca211652708476c7d0015f7c5d0195044c67e01852446d7e31d0afb23898a0d093758c81d622ade82972bd034a5028e303294461b440f1ff8402fd67dcc83d8704a8cde149a66cb6c4319d93467fba1b1e28bb6dd649890d228853a99760ed8cfd7d6e1c9aa8081dbada75fa20aaeb8ef6523b1f493caf70b50b6b54fdf10492ccdb46b0c1ed9aad91b1848b30cebd92ef361a9ff9b44db585d0a206e7f33c939ead2bee9f6624f1591c5207ef39e4b96db72d48e3ee354a2e2d9ca6cfd619f7f7fcc550162887afe5e7f52f24a6e7ed89fac350a0295b7da1bdeb94319db9dbf36ae661ab6932d1b3b835e448d270d0dd6045b9dac643afd3ae0cb3d04e6e61a8cd6c41249dec883bfb1bdaff46bfc5f3dc5478d8217f023914e036151f3f0242161c28410ea27d824ea515fb42f8386ecb783a5f4b7a1d2efbde4a6e9faf9e6ca11532443acc9686e0fa38711c2c879ab6934791517821b3aacc765d25a8ff8faa986acbf4375ac6b04b6349245c3cbfdb7524726069b5903bb2c4e53bfe481fda56b88e00671afdf06e0be7376103e6bc97d771b6d6e61fe3d598b0b25b088a3a085a0b1a2b84dc7eec134ab46b23a3f9aae2d00ab2779cdb1718c5890d69a9a22397307f30ae53eba67824a4c19108ed2f7b124d65940849b8cd539ffc7ca5d3772e937cfc7e1067e4e9abfa0f736d7590eaedc488b703d7f6d6c91d4e178525552ce2d44481ae27c090dd787e6dc4f4ea636ffcafbb45870b356ffc9b58791f9a5f6194ae820c734bf40335a8cf45d9709d86563468203013764a9db612657c77649c65a36300488da8e5fe7161db75502cf098c7a64674e8702943ba43b96978a15eca5d103ad4c872dc15856ae87ceeb75735cab90f14cdda7e51b6716b03da070ab80fec182d52f6b17f178a856a0547628c39daf0868cbf636b4206a14089fa8f8cff9f2f8161202df2194376dd62dbbba605b7a28faa8af496250d9134cd75b5d17f9eb1b2de018525246a378ea5f6a5dcd02afad6f93e22e6f6fa145757791e6c30cbab6edeca99ca6ecbf4570500a3d14d6f577b3cd76a2169ca1c388558500dc6881195df2ac2b12c3f2d746a15e5d3bd186fd4908d74e08b2483d82a68111fe3bc4469b07dc727403b24db1f3dbb19f98ece31577e519540765106a7f995d6124b653cadb5b200cde96b2f0a1dc213c10d18d9d605f48a22adfbadc5a9d74e510b53a30a50348c7f0b6666d601df69567b0a430734593d236480af0ba3a7a0ba7bcf748080c14fda620c226a071d95505eaab73f472c8497f75a16d8c8fb2bbf5be0adc00dcd34b95612c6963679f08f94de0bf5871ca166931e475329d08df840e532661e6e96c821cb25f6c7fe2f887acf7cbefdc8f241cef683a371eb79878835927ce46d385ca1bf72295ce731d3c1b2c6d86f13a8644d8c11110e68e6c4590eb6b89d0261ca5753cfa83c443aa0f38a2e41ce3568c50f95c2806f05d05cf08886b768b5e174105d9f2a266028acec14b7f0f0d8f1845370a2486a467482974cf525147477b22a165e16e614f04c90c6370246df2f9f1982da8d379a30c9df7f407ecd3d9392e5e28e7f463a92290fe2eb8ddb8ad1092a26c2b7477493cdfebdb1e99252fbedda4cf47038ba89808b4abf240bff57198952049db15df0db6792f0c4ce8890d03498ca865b14cf4c9440acddc6eee92ad430970b2bb8099186f17261e763523753d98933ace29c7262af40344c5176fcda3d84268915ef0b601a5419f12ca669c7fc6e3666dc2da6793b811c56ff379283a945560e671746862eceab5024064d6b584ed27b28312908c8b73dbce9af6836e593cf1f9ca33a3dd2ad817604493ee9cb0217748d38f834cce3a05ca181a18fc850b77d7773a970f00f3f2436c64e733e1b50a9a0ba03b141739f893d58d32bc5e0425b896e68aacca9d5a070b2b3d1ad1c0ca01b3957c40520b421262060f869759739cff9b7e000cbbe3d472c9eda285ea44daaa717ec77069e4802da76ecea2f025e614e93f7d027addce185d474daff38dafb0068816a1c8fc63c8e99160ddad4cf2e2fe2a15002ecc81da62678b6c2cf3405be429d97c9482ebd69054265322b81d491e1e97e718d703cb49301091b3c5d836cc97e8284b3bf63a1bfa463f95865f341a0c156eb0d812065e385a463d9f474b1738863631782c53f8a3092435e9fe41c23b71376a2451c70cd10c2868e81402a51ce673d2e44661aaaca7b59b8fe91e66707fb0897bf8c436100b537e3df9c225bc9549469c6e595e6ec73d2f2cc36baa191dce19bfa66e4b329aafa15dadeb37f21351fc7263c5bffbec685b94b13da24515572297f5610648197e2a39e17bf93be41504f307bfa3f294376215b49cafa51ab56ed818ae17636a46b8c39b47b03c4268afb9a380d89f410b2dc3e430be681e6f96852407e42d29577273c714a38afcd89c822611a457ffa9cac9f4e5a84ec6dec5992d4a1427906bf66581e49c6eab45316f3ccb21c2be86d16cdfb1f1a9e4a1d4691dde1c8ca5d7a674bffdbc08a9a424ece5b25aa7de51a97ac911fc45e0b15021b373eb27fb6167d7c2913b8b045728200bd01d96ad4d4f218ee9a4e823dae7de66ef9051fddef792d4bf6814be69e02a2a6af8a1de7ccbb78c6f37864215318f388869d65b52dec646e0a51f80162c06d4ed7f8607e2837bd5c50fd4e1773a7fcf3b287f713f51c913eafba684821796151d0230ef542210b328e7918ed52e5b7370c1892322c4c874f9bd2d381766a826fddf68b03ee6e8d406e1126ed54f50cabad640beb96fb960338934a9c09bdfb164fe797ffd565c92d91bac85bb3d91afb4d626621b6936ea020fc5bdfd1482297f787d1402d47374b730f934dab54b342c330cd201fab098138ca3f3e32604c0ea35995cbe4c7a4ae514940b5c3ed5fcf1b2a5c85c661bc4f632e98ef9b0af03c3cd7b38244c7a6f63778307709b1dfe7628334a2d9b2e79b10586ac14c9eab0966c68268aae1cab7a51145a0871812572aef72b77518e051055389b6e06d883296761","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
