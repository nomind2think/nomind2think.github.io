<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5e830edc0665b4bbfe3aab68f4f8e5f755b1be9c0be97fc004a21b19938045e0b9363d85fac4509c96bd3d5ef7fb77b3e01872131673514f0459b55c4f47f578113d8bbb93185b752f329f2118bfafee6d9c0182167ae3429abb3cb9127d6e87a8a61bd7b2ebd0d69ce09b5c531110e5ec38e5d567acc3582c042a67f0e3337cfd1c66ca8760448b7350deaa82b01632969b1d20e668eff2f6ccce2cd4ebe46b35e80f66aa150f6b803b2f63a3fd069380caef0a18148f57dc708d3992937a06889a2a0885d4b4ce3c6649e5447ea72bfb1f37ba3427503d6e99a91764eff85f166fdf9ff13c36dbbf77117899f8645c9a0f1ea441642311a3d36a456e7f1b7f795d180bc47bf5b6303cfe56864d5319eb0d14021b6487d4b70269c0fda12fec0ddaacf099ec4ce63bcd4f4e56fd433833756db6427ceaf980f96f51dc6d1a350ab576cf98f7f65d62e650066531abcd8307c6851d481441a36aaec20353ae1b00af9f1e2ddd65d3723e928300e66849f9f99e77a1ee1fb4f9b587165a46199bbdcfbb7e3af3dac34fc370340007971e9ee8a874cd351605333bcdce24a7b0045a36d09620ada3c5ae0358f36fbe99317eb39e671e112ac60c427d27e86b7b59b87f0e2732953c2fcea4b5609b3782c7f1bfd78a865edae02e9473734bf2b093c233bcbb73df6d477b8e5ea1b993cab2cadc07a379f6aad3424a9047092f3114db77b3089343484e85eeedbc2a0d22edf7d02b00af3c33bdefbe1fcb0d9144a800f4a04d697c4124506d90070b83cfdf6840a1dd513347c9d082be8428261ef0cad87e65cd5b22a04f14944a1d6041711740b17c6ed91309c837ca7ec2f3805178c85c655758d7e34758eaa74754a5d5d88db0e2d9a2fabebb1fe75bf5a89b50aab1d0e00bba5f1f9f54a5cd0d25e94a3f38655c5ca7973d6e2a943b99e083f04ae4e5c070dbaea6fd739ae4fdf890b84c169f9b07887d9f75a0e115ac469a557a0bd47a2e3020c4c36a84913df5725137ddac8cfef979f78fdfa5e3a3a251d8adfe6e5ecbf87a1230d6f6f3ad11e1d8cacd7876c4b5496f4369599cb1762248a3231f0423b06d77d31333240af4c25700ad4d6b341d7b88ec15b29bdc96ef35072a8a973e6d65dd4b617745d1f66eabaf3b525cf65dc37439b403e1f8d9938bfd201c9c2d6ff6dec8ec60e84c99a09b06fea959c9fcc1978dd8ebe96bb4df824fecb073cabd2c12e8e52f15dd3a54c223981cc68a26b2749723bb9462401b0854f2de0437be72f76c255030815a09a881f540cd18113af2b4665356cb338b9567ef343d7e2e6654b49bfc0c578322e5fb40909943b440c64aaf78debe0d19e4b4582ae74ff99ca238a5999e22be9a8991079c1eaa37192903fc029039e5005f6b10a3ddec6e82cfbc0b15ffb206d2d5aecbf01a9bc55a7e8265560d82fdd518c21c5ee0e417f3b7439bb1e07932c7cefbbfe3ded7084195c2859f59511c1c415de79e6cb2dd6396ff537b568da5656f780e2d868600be191d44415f42b60322d4786d484d0e04cd595fa15ef54071506e753f836d0cc5b530f07ce7fe24cca4796a21cce9b714257d7d1704735fdb6340415ecd5df6dea45df48f6bd10aa958b36e38a737b5ad0a81920076395798328e9e4a02ae6e42aca5493ed9c0ecb4684d441c20959541a1b654e17f3d9e3e33b30d4c37ef163cd09c48ece779c57e7bbe4ff2634d817af5482be7e450e4230055f7667bbeb559e0d9023c0d60cac3ba486504e3e5df8c901ac800263a6099103f8e7c6f9732e21a9da5504eab9ba81a048389dbbd8e6c9fba7eaca2160a2a068e6c396267790c34a41d1b194947db2208186b13a6581b7dd63ee7307acd204d3075352dbaf80c6924bc3099b71b098710633c9c76e6e8eb4087ef0151b5cd4f25f0430dd08f19c32df1df8ec8448af998f410359923595bad269471623382a860ad8fe60a6ecab542f149987ce10217d12bec46ce7d011e2df2563db096f9df1c438806c37f6ed29428e1081b50749659b1222e58eced546feb40092d32733f2e1eb60f5a8b6a6bf8459a679b467e62ba3aacccc8c3c08a318923645cac632b642ed98a9c66ea7f27bb8a82e9d2a714621077082b62b2b1c522e32a2a18a99ce743bae8b9e9be198422b0bd729132fae1993eb3f5ea8285f20d01161406c658082583bf62d18679e490dddf7cbd5946e6b3a3a670c5b0b572120c7aae9df009782ef7cbd6bd182c6627aec43750310dc86b120654a818d972a877fd069814e966719d4193b77ac1c62d98a5e04583438e7759ff1fb5ee0a4d53d24b9da7122232b6e1ffae3d6f6365f1ff3fc8bfbb5ae6b110355d253c039bb48670386d302537925f8ff860dbd06cabd383f41bdfd96fc9e60118fdcfe2d7a70d9e44d145fbbfbadceb2726a11759320fc001aa6b93314aeb11f3833da7f1034946dcb265ad2a321bce858795e9491573d6cbc09b5d51f6426fa7f1493b42296025f7d9240974c7b089131490660bdd49ab9ccaf82aef4946edd1ab9709f00ee2151019e973500356187bfecd02cae367026b2b2555e7285f7b21ebd8619bf56cd044a1d0b8ded31850b18f030319d88223944bbc31e73f85819dc835cb3fc5e9e235ecc14962e937de7e936b252d8d65336109145b70584167e09c7c966249c3fdb0b354b3df7d1aa4237a1e3a255f2f8e177c750ac8ef9c01746381472ab3706830864473f7892d54e7ba8b5dc402317ca463a6838fb6b2966508ac29a693dd613edfa23c439074bb90d59eec52560fb62c832a0b5d6fd07701aa2718c897b3f1c2d1a5a52b23279c2a8148a48d3e21ae7bb7da77206955e11406d72132767fc43e8ad1b30df8030573778bc934dfc90bb6f45758a514aaf1fd3eaf05ec301054c0f33d8ec23a2b6da6cb5f668313c565f5ee5afe487748f889c5a91801beccbb928f7ca704cd74e7ec17c5ff12501eb9b297b883faafcb30bbf810c320e3ea043abce057531ca563ab9c63a932533d6899d5a47dd18d0232e50ee4157d11dcaa58991011e9a0892dd2073d74d2bca69e461b6c32242c9ef4e8a564d80e051e26b239e9c683a83efe86422f9bbfb7275780bbe636baf7e13277ef19e7384e08c8c2bd3157ab7b9fbb03375b87e4a98a66bbb771a4e21d073180649603dcd76f94bf7154861e3f218627c42c1c9e0085b3f3caf96e798f2d319e7cd58cf84df4486a6f315660986f2d488cd42c8c6802a530a814008e2a3f3ccc81f52d3685c238d0f908471500e99bb52d3e5d549004e4e6f4c80a6bee8bae0b1c29834b68d2b21ab4bac3b0c28b131f974c052bd7dd7c879722b301a6c3b1388e2cb73c414681a5b8ec36c836d1879c1c8949ef425464eb006f0093044cc51542cb0e8a68219b372224463e1473e7743ffdc1ef300f81517ab54390a77059d00af9da440a2dc5085c0e7fc5f822beb2d52280bfa013ea0bbfcfa5dee4ba6d2d033ca936b0cd47f1eeaa92b48beab4bab0272164fddbf281286472031b0030dd9f5386230727c32dc5bf3ae13748d253ec3a6e216852c3808a2b1987668541fc7b5c362be34373835029329cbd8cec21ec3a90e225f16f6b170b82b98180e17a05e1dc048db048facf8f56a0454df0e664d1a698531a99712a0ce019486f3e84ea954cbca291eebe87e441c21f1eb9a5a7c78aeb023a992d06684bcd2a30cb93a3cb95d746c034ab39016461554d81cba16f131ebd190ad70f20bceb4907bed2f42d0870dbbdb96332d189229dfd95deb9fb6b56c4d27054070788ee77cb5334a90f1aca024827af246273e87b832640df32a6526d6876915f8ee7ef4ddc36af48d456cf8d87b9676db310230820c37e6d4d332774db44bf6b669c412c7f052d6c4ac3b6316ccdbb3ba5a1de5333f01c081a24abbca25330cdda2bf4bafbdb92caeb06769b6e8b12cfbb8d956b4640315ee7661da8caa7b34f5f1a73b9b783ad5c3a00f831e32c3c9e8bb6899b5b998d0dce460df7442b179b54a73b1b21523ce2cc77740df3d6946ad07cc02c3c24d048099d92e46649f30fa2b8a2e4af26fc4c3974a0a39778cf89b1d9c04d103abaa961ffa4a6f0eba6261baca20e22c2421ad0f64268421ec0fd65d0b70fef8516ec7b9ec89de83d722097fff61977370d7272b8067ea49d1a75a05cd793c61b6dcae6b1ff73930ed1afa2f3d297450e8d765d30b084f3a9d398cdca152d8c939b137858c9f79c9bd1b0384d1574717f953d1584fbeb5601f1d18e56b117149da64fbad978cb57da32d13ac4b5e3a9d70ceb32baf789865a97a8cfb17181ca7f38a3c301b52aeb6492b25ddc8c33a228a9ec9a78605236d73cfeeaef2fa4908c82b91b7430177439ca96918c5c91a44984bc4ca249a509d65e8b181869b740a4d5aa49c5117c89ed84b9afa6efe547bf1bb6c8653c3e4e58718510b1a8a84211aec37564b4074c1708e2a18823a688018e74281f89ed2a2e16adf79b2d8a55961a188a66fb7ec3433ae6ee1260f8054bb008048037e7149fd740f413465334a2ab4ea4c96f1e4a63571cba952cc6b12de951dcd34efe23a22f672be8fd2e3bdbf4ae1ad53915a0acdaca58d18cadbed09ca3e16a4e157bd04931d4823dc05eb615d2c5239a0896ca9be698cd9eac6c301b0adef7e9f45a59f47852a4ba32288eaa95680e1c0c46387fa493c2327651a54a40baa0d66a6726a2aa95dfe355875c5fd79180ec5413c5455ec84411ec7eff6d6e0255298daf1ad4f2f6ce7841d7488e6ef6a2c42bc33c81c9c8510cc6959ca32b4a7cf34e75b2bb6ec603f6286f52e626795ced54d644e9db1f22f165ace59a877f41f03d8d1cdeb551f4880896a395044217883a0a4192ce3c7d65b0230a9e3416dad5f8552cb68568ec6df00504bc798734cf0b70f2484f6e0d893c718b23be923c720856280a72110721305a66cc64f7e2652cccf49842d7bc9617af2c2ee7cd948c5add02f4ea55ba99ff11e4aa0f1f77d084faf282cd774ec9630608217ffb71b66efb70db612bbcf3364306cfd051e5f203f73fbc10eea500f4df6ac9559dbc5eeadb030391a0fba8771aa8f58bea03fec26ff92147c5de902822bb0632bc1966862869a654dbad1dcb19509f9e8feada5e08352ac332e04014028819cd9125bde6d52f0a477c5ebee88927092eb44863d65ab836f611996089bcfe29e0cada26c9e3b5ef40cb07b81db9333c7d226f30dd50bee34d1f93df2f64cc49122c1377bc20ff5025da12ee7d36c0653f61cd6b735531f0cfbfc4858247f68e6b3425cae23f3775b1f36e6fad466f0228452ab1add6e7b30dd9a19d64b5c223c6bbf8dad9fff227afd604021b5a9a5b3b436881d35e18ca946ff56943a3dec6b83057146664a62cace43dd0a43c560015ef9bc2b1701a6d51dae447bd9bbe8d8f5ea531f54ef7e1d7301affd5a38889794cc3f4c58a9c4cc6b451b2585d88e839ef2c7776fda5bc67ccee44394174886dcaa3c954f05ab8e8f19a0866fb2300735992889ba2938ab557ebcc4bea4c412986703ab0807550ac77bc508fe020fb77789a0dec932186dce1acbe66b5c094e0736acfd999de64a9089aebb079e7d13f624aabf5f770e739507073a792c591cf16a5b9a6fd3bd4dae99afebb2a93cfb2e753843d5b98fc7ecc33744a78b8b6add7f8fb55a2341f3c437e38dd47031a454d36828490fddc2fbf38250b48e351b723392ceaea3b11faea59323a801916f242594fac348301d8341f3dd223a053dd2bd066b4c9d364e00e5b8b21c0244be7ee276194c9defc854663f175560eb37338d31929d440a8ed793e7d3fc28cc44786a86dd19a7daa1ce8a9e9ee4bcc05036b1ec936d3c7fa12cfbd89b0135d1acf5ad33dd82ff47d95af5dc11efca1b01b3fadf03745a22dd91f2d0a8257598b484444e949e6a34903daa6513c769e21baef5c40b732a216a6e265994899925492aac3f9403b0b2a006a6c2d44361d31a069ca8330bf0a8d1cc60ec36bc6fac8d83a13b024c58f6912aacf95d1eb5b141bb5c52e537907438bd48015db073a674d32098169bf6257695b88dff96dca105fe52e99481f1c30c0ed67763cefb47b1b47d00b2b3ef441dea9e8adb5b2dfe84dffe826fd9b1cda9308f8a06e7d90d21e909a90d2989dee8bb9edd32bc17eb888779f4ba6a266bde6e29cf9b1ded1e96fa9a493011481561ed4c3151f6b94b6f8a26cb132ffc96aeb2223bc41dbd6be95c8554011445baf3352b6d202edac80db42fe39f0e07c0972ac815bf0c9811a36cbb8ae07fa074861a74d0438c108885d88b01f4ec47a6dd5ed5c6bb8cbc6ef3fb2ec7ab484d3bb7f822b1bd70a2c3ea4d18b37e3e8b37311eaf516c88a1256275c4fe8ef090b5cadbf0e379e7a717ca2e49e6a77e1c7b4e09ceb8eea8b495983f7e470907101f0e81e0c23f54c6eb66d18de7d0bcf4eccbc326dd946293b13fd2c98b26cd4f97ef91529af5634d348a56c6f4e972fdb2a0eff14a7b0758a0b6fb2c6f97c0bb69089e75f999a9fce0b1590ca008a7004046c1a2d660537943534e0bf9154653446cf9070abc1d5808cd685c9386828e0536cd8c91b23e35d34c3e30876e050ab02de1bcbca57b5874767740813c324071faa83bfa6eaaae9a9bc93a087bc4bcdace1c0fc1a3f184e3d08336294a1d03fad375abcf05008322b0fd33a4a34b490fd26f1408c744a2e17606deed74ebbd6889ff34b97543f42a984e78d61cf25b7278890eec8c326d0ca71301b7e3d38c013b62bbc6729ec414e2d57a2c6d5ad6ea66d25a9d793aa6a8dce59b4e3c6391b9fd2f4393a2defa2c5c7f094af2db87a0856f7ecd41992eb6f2d6fd4a839bf17a486d78d52e5bd2e0a655818c24e0e20cc8cd4f0e103d0d5051cdc3a7a403607cb54ad99043916b42935a25ad1b251f807ab0f457dfb937cf29fd3a72926186f84e66e555d34c6599c5595b847d77958a86a2f67498a088f67ff8eb9de7ea0f58ac846595ef991d1459c616962b2e92f194ef169a32f170127f80c8637676151536cd0a66fa6d48687324be7871c16028d4deb32fc74ae61cec6a95fb50dc3138cad42b004cfe02211c5b34f93e3d77af2378c97747532c8819f7ebab796dbbbe6d0d5556df4a69598757aca06be2dc5c407be295ea88a4ef5d2cb896de4e3491229237f2a09a472fafb7c92bb7329237ef9d6c890a32b7ff43a604542f4b8195958ef6e5159e759ce4b223a182157d08aacce36bb2713d218dcc0d41b03b9252297489ce50792e8521244a8ab55f65a55ee123e8fa9aee1bd2450f4322df0437890b962983b709e94a3fa4fa4d910d82cceac8438b46db8204cf5d2a4b6b22e669aa5a5c89142c79c2ac09460809c8e4f67bb23983802e1bff298ab3ce68bcd9108c322123d26e960a183080fd33a0fa58e6c9c7a4ad5a3772df48a04ba6e86493c3d1fd7de10c36e1140c504d6097b17aed6dfc08d143c109a69249a4ade4fdc2c77d7a6729f10902ac4d1fbaf3e696c88072d637636a02c10df9ded3c76c7a0dd5c3d5aefbd80bcd1903841f8c4b371b43afc20246d6d50d6b11656bca560ed42a1a94f966066b6167d78bc2e0b54254af7f323427bb84851c46ee23be1ffe48755361c20d333efe19269d9099c0ede1a32a5e8f8ca19673ad17f67b3ea062b3d23b2570cd570b674f7b533e0a65f103773fc86c780ed574609dc0621fcb38c2e509c5e98a86ce6a8194f401f612fd63ff59a75e88e99804d953dfda0c5276bb414a24b8c7176d11d241d2cdbfe47c7f3b580bae04c68ec92aeb54429c1902b836290e8cc22ce1ea4a3b12497de282aee521a00e7c5fd8a40921d42d9dc2b4e1d772aacf27c0b9925602fb0caf366731c8449a7daab22de1e80ef1b22233b6094e1b8ef0bf0da0b74a87947af2c325ccec41794e959029308478e5f12ef7dacf41a4822402a58b4993f792e505605fd60f19217487c429e67f2441efddf864cd772cd5327db777cc9d5a6ffacdc9f706ef7ca4b0c94d016e0e32e5205746982b6a2b4da65242567568c21e4ca25aafaa505c348185901328ade66e31018fb454ca8a48030720a2a2968490925ee4257fcff02799d6d96133f3f90b641c692e8d33c97f0f9d85418925b6334328582713dcd6a29ecfdae52f25644c556c142a7e792776ab62b01f1009ad9046b8d1e761cdf99f25f4b36b40e001ace144060d5ffd8771d7b2759770732bc3072553d8a04a7fc9fb2f811f76933c62b047a250a33489df75ea0bc8e154bcf6a6bf378654b71501059ab16cd46fcfee022932354b4fe3bccbf8884dc544199d191b2f49d236863b32e4da62cc9f3426b03ccf4b6c181850a794c136a7eab40376ec4108130833802f8ce567ca2c4dbfe66a60db3b385fd6e142b314296f9469da30e41cbf1b1b43be7f10884943335c27c0b56dc28e07388442768a5c1ae7bdd8b8468a122e6abc0a0659c4e424e819b9335f24dc7e8c066778a354f24929040b2e21b4f5c054111d3563b7a330f1d5579cb56d5a317b9a5e3ccefb02af406ecb75562f427f69ad24722a6c9ba8552516828d2a6070678b72499848bc247c1edea5ebd015f2848c8da7d18ecbf197da1507457243bef82e75c40ae31f0db85d1d47d22b64bf1e0413e0986d7d8f7677b32e0652a6320f890780e3f054dcc5ba42f9c3da034312ea7bc6b83c18dbbec763da454fcca514bb9b7114a5af71ac6a81f911b397aca9f3de1d22e873392be4e17d56c5d84f8e813064e22e115d6b765333f8b68e169d06908a18a6d0f5787b33f766af357afe1f5d841cfb9a35e6ec64088b7b9a06c2eaf653d7cef518e1dd6bfc5010ea400c252d517f15e30eddd0318bd9d6f3041716fc0110f6161df9a61ee6185309a0598f722d4022fd1c55b732a7cee836a14a3da7b9a3de541239c53c07dc5b36c174110adb8f6a2371b1e5eda35a320dc9796844e3378250f29aac49f2269a457f661a6fd41d2123d0db31d8d4dc6fbb55810fd692e2adfb16a0416a0fbb0bfb866cd7ba7b4577aad24fcba6a23615f5c83607d26831c0304cf39daa314b0a7fcbee599ee2afa800258a09983a2cee7216152d5e227564772a0873cd485513897543597b02e808ebce0515bf3c96379f91850d8f609322f5ebfb510166b387802e4d3ad41fe83f4cbdeb4a213ff524ea5117293ebb2cd679a09a67b9132f231b49c50377174fa865520dc363fceb923a42dbc31439713f0eccae763d84f30f09e3a1589cd7ad2b79d16b6eab9260d0daf99bfd8f0b16f847a34906a5dae7f0b053193a8ed8d708fe3c29e3c1e80a94e4a9647122d097f3c52684a7fbacb736a2aa5da54943a858851953f39c039de734de8c473bbddf167cd7feb4ee57286c22e05ee8ee9eb14eb110fdb7318f55352918c7253cc28c43de2d78aa61bb79d509a7d71f0e2e41e20f4d43e4545db327ae3aacb5e7067dfcac51f7484d0f17c9c191581a771be782fc7dba01ab97fec6a42ba6a0225cd915a69484b0dc6a48772bf15bcae2512255f5dde6841e04f38fa1f18986ff3cd32b86425b936a5f851d33ba109687af25c4c4d33cd4228df2d87f6f359c8254b7a7b295aa843ca1ff17b854be65c007b9353d6ec6b32422694910ae5dd965de166e2ff6d670a816cdc6d603522cfb8e0aa68f81583de1eb09b9572893e4f6d46f8915669be9c537b39dcab531ae7c9e1916c7829955f4f51d4fed49baab770e4fd1870513b21d5aede9d0c5d1ff02f88a82fe6e8a98d2ed49953bf1172998be33745c14db10d28fe295ddb1d126a2d44faf6a5bef47d22c790d4581a632146d43d9275684d572a92e46a2a5a0e36f17b288f002af6f40a90c524a01070b3cfff1dcd8d06f6aa6148a80cf7d778c7654d663542456d7638046bf61ccb8bae1be5d4ec1c7f049f7b60aeca3bb868c72bb77af7fdf35e311145ec880892da1a55cc939583814f589bc9a2382b5c07cbde3ad58cf556a83bc096a7b7d929956e4a42a5c7954095c9a61ce5c3b4fd4b22375a863987ec3fbeaec42f147d3b665a5919168c6b7860456d77481a02c969d7abfc3134098d8df64565e2717720469f628078c2a0425a60bf75e5f7816dd9a2e58960e6db6ca207aec8bd15a696a9288a15f843d11ec8ef92fcd16cd290553d652c1771977b827e623828f4026b7c113d97dfc86ea0ac2af6286d09ab3c75000333dcf375b05c2e1076b1e01769a0d55052f5592c47c20a5ac44ccd0a4bff851bdd174bf018d4c4fbda5fb3909616c5efda1fa7040231ca091fccb4b7a012a2374d7ae4c877f750b13ca8de2e2425d8e4ffa4ab0ffcc5f569434b0cd6155a8ad62eae32add13fa1cd5736b877b0798cd1b5d8af3aaed4c0eb1628e57f902d5c93f67194fc78a95b531c3607a22bdc98adb7a1544ab7ea94bb3f382c4932d2510b705e7846f87509b7b8a8ec35a3b5fb4e3afedc63def7d41009a4c957e7dbcec656ae525eb478553f00e5dcbdac0f32857b6d0ecaefbbf048fd921a50b71be16f0b4f3662b5efa5f8fe20ba9e3999ad690a3e2493b2249cd65d053f80b97f6607bf013274c870950aad1cd0c081c80e6b6ccb0da5706685387d3124283837050be0c168887b3d55b7535d949ecabb4b5edc72361adf53da6755640e4bccb1c1eeb4453e6c07de51fbdc2fe03e67c6626d4a04de0c86dfb3844ccc5a910ed25f543aff79814a1ff6cc56996c69b0d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
