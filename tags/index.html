<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5715fe8ea620405472d64e17d93dbcb95ae10027ebd909451b504285b1fe8f1ebee064afafad2ae726f1378dbe0f4554309afbcfc8c07b1ba20045e17a52fa4d3d25fd22709afb963a556026185b7d0eee4a2a0fb9572ada543348e950b620394fd7eb1f7a595756243e34fd65a8796b73d9825b0f753d55cc2bbf89a242b69d4b60f28356c2a2bf6440f8d3d617078fc96b99d14e2f6b7e521cf7dbef1c1ddbbaa3f43b4665eb683b9fd1be86712aaf1d8ebaaccf3cbab43b861e66765e772f8cd53f0e7af0e656f3116c5c5f6a3c460c55abb218b42588d4f2bbed3014b98ff329aaba4809009e54e41a0edcc752134bd0ba6a40089f4d1446b8c7f60abec0869c5f8efb9026d77dfc0e1c91ec3e84fb944bbe8f3da04375c22fabf8684c2820e38e9bf6c52a3a1cc40049dc51edace4a5abcd49826db2e1346d3d66bca5fad705235b1e0011f46b9eb7eeae94645bdb67e2fbec2aa6852f83e8f34b14aa6fda008904d5f3935820b8e6efbba3ffc139ba3f80b38e7a048e011608084e51e6b2e3c9262e685e8844985ed823071cd4008a96814eaa007cd286cf2d23f04c73e267296f173e66e4121f23131db113f177b4ed01c921abc95d901d7bd5d622be42e718a5bf57b9c72d1a7a4c10b98e5c445fb9d463e0cf4e7ae8292c78607489f4b895bb111bcbb59f8085a40c0f0ffe68e5bd38478a70754fe642f79586544a8037c7e72284827aecd6ea685e2c09588c2cf659a8ceafd1768475228594ab383ede973dbaad8e0d8bdbb8571acb0d8914753846bf61b471d7d3052f36c38c598aef86f6a30dd3a033fb76c61ebd4cd50396a92af711fa9f05a52dee0a06668e943871acd198d8d6ae9483d1033d90fb21ea2464f1c6c353727e7f7f4db95265cf021fa1a6e7addaf3bb08b18570e2ef44b28f2444691ad01e2ee44c2c7096f7105ea7ee0f8512dd159302ba5c908be35fae3cdee84da17b136c19674507097ee1e3f716651acdfe01491717861a17f1a255d1ac1d5c0488a277e291fa3320d8241ac703f7a3c69c07d41f5b6726fd1c444d1d54169da32fdc6ab13c2c8fb14dd9a8644c0300e06565cd51a1b2aa2e6b91d00663a69bd4e698d23529a58016e8c1de9061ba2b5706a80ab0ca2e177edd84401f132a02836b94155a73fee2629ee26c51d2ff0aa46d741bee9a8fdc62920318cdfbb5ab02aae5ae8b73fba82c763f761b791534756ca678236ff8f2468cbf1113c409fc7b8c5b426c527033e600c2f33332d3d52dea2ed9c43003bc304dedc6ed1a19a05a0f21b5cc72e9dd241603b86cf42873a42586f5e4fd50de0f642478bfd3ed2acc8928a2dc6657c2a496fd12f093af6621cf19fd86f835f9123e091aacb59b84adce27c17573ff7b2327d225e7979032739c874fcfe0c7d85b9b47a357a459fc55e013a3573aba797ffc298382252c7d12ef46f63e5252bb96cb0660ac98bcda517d08b407c61eece2ffb297affe5a2bf8f21d3cc1e2aa87763a786ade75a07d98587558231b79cb16adf7244593cbe79cb586ea8747fd0a2e64750bbc889afb8990ae2d4dce88d2188da6fceed76b2d860c4e15d03647005f82f075d4294fa1198c59bc9e441eceae1ba748a647effd15951aa671d080d50727bfdd36a04d91683509ca881f611d2ce5db7ae6c3dedfba87b436e76bca88da41864825a951e6508b115cf217e534b72382a0ae98e9a695e179b3a6d6682c80c3e888a5edb666b34579f8ab5728c3b063e490d33af2fb3a5e4e6991534ad5342711fea52a4e820dc195f77250a7aaa6a5a21ba81aba18de54377fad4403850fce861714b4809a47e1ac58ca318f8229607a5d2e85ba6ecb8b50f7be150a008b307758930f13541556032ca1611ee1a99977dea298f7df127b78154b3919a2ef291a583c6b7414429d0b491f6ca85eed13346e5b8b7a1228abd36df7c2d554307bdbd420a2dadc86ee6e72aff95d52f6e15d5b0da6d9858d8ffcd66068a668f7298eb257dd3122fe41fee367c114a87371d19e51c7aae20f31e4fe306af56b698e5e37d1a25ef74a88aea2b007889ecafa585483dfb5b8129c6a4e05d1d0886b921a52d053cdc3c7ef076faa74c4e3b2a701216276dff0379b326f9ff2a091090901226a344feea907d32eefec3cf0e96376e71a8d1acf810bb5fc062c6c5797d32cbac79575305a6e30b2944256ae1c9a29279c5118fdb1c9806441247a51edfb9d77e923f0ef599366fb5fea59b02aa5b6ed786de12b7cff1c531467f23a44e5e3fa392388cf28e6199f9b056170145e0b28f1834a863a9dbf2d65ff1436245accd476616ba4208035812167a74d6eb459b9f0371d48f4ce5455a6f5af2dbf2320d012ec28a5c946bac54aee4694a700f10c49674f612582099ab5c828296e136ccc0eb0bda3d8ffcfd464f2aac432c86b579b2449d8b054f74b6f50ce0603212ccf27b0af957a50dd46e01ce87a8d37f79aada60c17948cc683aea15c6aaa132808f1d9070de4e2e3d6911adec0de70027feebd2a029a90708f77443dd1624413bf5f6c484135fa5f66ecd002f44b3e4ed91619f5406ab85416a2b3920acb925d9324e1fbb9ed009672d50cf18fba4aebc3d543acd4d42eb819983b7bf00afdfd9523ca99ac670a3a2d5f63e290b0bee5d4f732970a78c0d32070432f0bb0bf66fbeab19b63b7f7296f4799fd7fa1229f46d5f77518ecbdef9f99d2ac968767ab2e690f4282c6b083ff8d41b924f1af535c7cc8a5f7ba2f96b0a61dc7628a6b31bdfdad428244bc28a9060976700513828731e1035a980643b78c18c632ec324060f6601d23e163374a76fe8a04cae7db2b3887abf8091df4abe4080d3668d55db82c409aeb8e109c9c9e2694e3d2bffbb964ba08b83efac97832bdef14c3010230f2414e5595e3a5bab3c1c2397014395280ce3ad8b6e77efaa7fd9190255b6dffbfbdc90ef1381a20b20f147baba986e6a3a1f3ea46733a6698e9955ad50807073cd1406a89db9f2d1c82e4ea4aa8078517b34199f9f9a2db4674bc9f15f579fca848783c6a49627aa46aa919f995c3ac3103db53ac728d85c9ced8a328f5e216514cb0d18a7fcec0d94977826dfc4d89b53bf932191548d6bcc66fddf7deb9bc2a405a61a640c6825b493800bd233d24e7a6d8b6e15b3420adf7ec0f32222b259308c2e2e0ca92be98975e08ff229d26e5c3a32a03d804a0d71d6a783a56c69d32905361e0e399ec8933852a0b0af270be359a57b0974fd33b6d8ad95194b2ccc059dcadb3abd5fab328395779acd433c458c45b402f4cd292fae7cb3771bb3a2b09a19440427626805fd6b05c5fe0663ea0d7c71f07450d2e45f90574be494e1cba35e91e42c255709dbfa6f6e366fe156e6de456c8062e8df90bc0ee628e16281c14fa12e7c834c5525a8a62cc03e5f84bd878ed9949500db250356b411526e99ceb975c701a12233c74bb4795c966085e7effedf496376c98e8156305ca4e7baec2b0e1b37e8782f1f95b4bf481c062c543e27fe0d331d8d1473aa05a9ce9fe824f3488a1a9a0c2ca5ee236cc691db674bde7d5e7ca731a98b34c673d3d10956a29f0555657c7c3a08ca0a6fd5bd59f854adffeceaba32a6fddd5a420c98199714b961e9d740b5cf699e2054257277f778bff40b1af6f37b233fbff32dbb1b680faa475a9074ee396f1ad014b33459172cdd8c4d5b2528868001749180c9f0a8a0497d11aec7b36f34b6338554860a1386a9be08d1308a6230dc620fef4d9e4dd4179df5e3a3a733252f902c024855f6abdb68f86a0bab58678913c3e0b9a0df13a30c767cce5d492b9b1b36ba07a9609584fd3091388899258f6f5a0201e346d770356621aba276ae4a1a19862c6c5cd37831debf655c5af91e589b01d7709e19d44270a8637dcf5a7581b0f607f384c548f67af0d283ed368cd359ec3e2f7a6d053ad49976d143190f3231b672e581a450e7704669b457041ab1873f3a3faf89e38cd46b5b79363c1c1c523845706f80f1497f02a6a5b0089b543b377ba47c95960a57b1af049ec80b4c4571823c800cac89a4ae953e8f0f87392d90178b0c7a2b297956a0803db92e3deaa1936a6e9252f723d7c5c7cb3ff6f9c309aab633cda3acb0f4609bed2e079462093d03c99d7213c29fb520b6517bc80291783e98497ae3c24113fc032c2593972ad82ee9e05b953c165eec5585a3e366e5af8eeff025d5a00b1204f65c90be140036c070d1d9fe125e8217922c857c5334f43cb6f13b5ca9532d3bf40f71ddbb5d449b6be72ab4333b267603e98b7faa4397fccfb6ae67b3c8cc01f6ad3e644e3b704dc1ba64f96ade0b7138bc7d40bbe61ae106514626523bd27c4c64dd23747d7337ed542bc5db2700b5a6b170182a50a3795bc5bf7c5c20af7921c5e1a4fd1494b5cce207af7e1d7eab7895e944f24180cd4aab97dc229807a8bd262575b5c6e87e0f5739035ddbeb52827b5fdb5a4bd10dd70e982bc9cfe9ac277515f6fb2167c57878e60d3dd96b45cc030187b7f0e2defc03a7ba83ca4133b5c6b7a130b57eb5701ccdef1cc2f642fbef657da16a66bcca6cdfd6f233ff41b042e5d8117a5468ce2863cf07878edaf038cfa0e5c88b1a2fb2c889fe97b717343af9ce8a0b79ec6c0a683fbe167002694ff6cd8fbc45948e9a02c92b49d1b222842984a6563f85a3d77a1f02cf5383f82b600c6d63a8cea5bb392684f43c5b93399823ebcb2cbf618cd6a12e206de65487603b77e4b6b58f76b600b36ba9c7e75d3db99058fd7dae56d6f99c5d26791ad689dd67ebba6910ce0256175748790111f33084c7782bbd7f7fe03c05e1836b08107e24b6637a2322069360d20152ce472cd60710e41964ca2926b1d984bfb4f4c71e7b81dae6cbf04cfe2f9d5ac569003e39bd8273e041941b908da167ea146ed1ce9b5432e4e87b9dcf9503830f5d9958ebd91b9b9782bfb9be5bd8dc3aca195b058aff13c6ec4da824162d7a898b6e1c47cacc78b36907d9c0d86fcbc7833343a1bddc5bfef9d71ea548fd9bff2b97d9d1885803c3b7d2b88b6bdbd37f5a257bb7398b5730cb4a49fe4f0a9974dc93737ff3d0b542d489e9f7d9b544f62fbc52037964b95fb507aa6f2816a832ac8d9707591b0f996cf2934e039aa7f9e103b1132bf4540c289e565e6c5671d3edbaed4b9f3d6a620a70f088a252d127b00273ec06ee00df74e39b93f1b0eefb862d78e8024cb9b8fb51e77f11f8a140d305a28ae7536e8e57fd9eafa14a75bd5e8861a583fcffc4e4a8df4d236694794fce6d4a29dccf5c799ae77b71606c31e3eb4cf5c4d8af4b420ec640e0dc23d3976394245b08f96ac92fc7c228f530a0e148ce5bb33efd8fcdd7ac3a0fdd6261297a313066fbb1ae44d5c880c61588552391a20568928ba298485742524b513241ef3a471ad4e6434ca6557e9e842571c68414351e9f7655f51fec4e062efa6a622593a202fc164d98454c57332af8976e4c862c653f126bfac96f0876af4bfda0de51036735882c1c6ebcbb7ae1fd4f5437f3486e011690d41c3f56d3777020346103444dc87b97c0dcd7f14dac150ecb884cffe98cc63736d3d0d41e0042374387b57bb81b980ab3bf7ff31b36eaeb326888df033e9a1a108c21cb34886ab23b9c4b685a360acc1c2b56ddbd184c63766bbb367ac3caffaf83e94ff0514505fa83b41468feaeb707a217277abbb01225720674334b8d30f0a0e12bc0777f35663fdeac76bc52adb5949d2520d02c3de8db490cad368a35656dfab7728bab3b27419135575436c9786a0d06b1e700c17014ad50c9d3ebfb0828c71e9f1a45fe1070471157ec99f24d82595219c76a3fe2ad3002e0cb053f8324b28a6a1dd60320a27b41c3a2e680c58b53d5cdcfac6decdeb2578d353e64eee646bf691f641e1636b0e7598eb6b0229f1a423644e54342ba46b8b4dbd8bb35ac1ef4823a80f9873057bcc8d43fe3348ebb12c09f47e0f7ad21b15d3f734d5627c1505f8429b61d4abce2fba41d3287686ad196c919f60ca4c71bc0330092e1c774d6d062dec99b1f524c4a575f4133e4624cddb49ac6fb39364beb83e2a10064ae37ea27b791858cecdd8aedc4fa5e532e80c9a5271a9d832190fbb3071fb8573938be7e655c5e5e84700c9b14b0d9a5274cb39e6e2682a89f6687d2882500eac55fca75573c7f593bed92e15230ec56bcceb18d5c93bbc1bfd575ed3610ef8691260df33e881e94fe78c094f9bf74831671ed1788a9e06872249fba7f3f1d6fcf6f5ad479195eb05cf4298aef3ded84033fe45f32488251b24751da41133cc64b7162ebc5a125cf8d1db25edd0d8a02aa0d4c359c2ad03c661bfc38952df068b7330c96eeb863dea5bcc53a98d56919bb4f9ed590b0918d3ea5ec5deea0f46e2437ea536a39b8c51df3f05f03c3fa11cb9eada4a70cea89aaf0549ee7d0f463a3f97aa49828d616a018ecf05f91d67e19dd28c78be1cbc40a4003a57ddc333f2ea022e2a91d7a82ae6e5bc971ee8e5f9c1ed29d8cb38c09b0c71f91477711d970acc28c93b02e3e04a883dbcb72b7cb02eb34920e4ecdfd66f3ca9865c71e3a70a0405f523e1f9e93cc8e9de6e0d0be30f6154f96991af90fff36ad12a5f92c87ed89d9eb9845e1bd1b292a479cdc1750d5526aad8c58e2b660d5776f220ad3f4f8b4ebe9b53d5759d014d716808bf8c334f7371388fb8377aee6d29cf812dda2432a0515b0419c92282aaa8f667d83fce69d16d4790970f20c9b1815db33d361f058aab24745d485423f43eae8c41d86a968c7ca0b2acb6b1abebb48065eef245ce9f3ff715a64e5776a113d71904c87585ecef0590de85f7daea330445b76ea0bf934eb14b4e55bcfc5f1ad8ea619921f2317962d398b9362ebbf3ef3b56aad8c63d56235bcb1f550cbd6e330a82326fb52f12e277bc31df0c995e9be7bb22f129f9bb10412bd3a06bf54acb087ecfb21989ba8e8ba86a3109a8f37f42e977997dc96639290e260056e785cc11815911d2abdad8bfd7743e11195fbe34aaa9991b85335a76b742feeefe66c0a9f45be8fe7bde7827161e535d522dc415dccf028887faac15bb95467cc5d781e3f1e5ea5452bf510528003b2ea42f56eaa8208fa2b91dc8c9395a184a64f73f07e410d5f10a22280fba47e17d01695b4197f8aaf78e6113048b14888cefaa1ef5495cdae57d8dc022f011e5a7c00add1b16222708059ec4bf8e032516e949e0008305fd1713f92f841c2faa98c9c8503af7aaacf37854bf5ef76cc289cffb1ff1216a633de9e1f8277c5019187d45ada211e841a264c2de3dc90045e732bee15c7480582b654d8d28830ac657c82a6f612ee5121a223f83fe2a191da284dda410704d1bc750d041007ed8d4370d556e641469b11a345f741482229a76a089dd4a290db2903ef46f11222b5f21ec6bba015b2fe6ef0ccdd9731dca8f8c5a39ad9d1df79ab8db570b1aae9ae5e5916b5bb70c2dea8a9b90b2235ce67ee588bd4dab74cb8cc4b5e0387796b9773950964b61bc988cf6b938544024d21700b8267f92f534a799909e0a9d1c15e10da4619b0d6c9ace5247a651ff509b2f371a8a7ebc21844e3993757336d139184396ec3f8c5f69b6cd6bf52389b106f206f4eb0952b773a338c00c60aaf4368158a603386fd46eca14ea951938897b083596d49b8101b69110f13bfdc28155c444e564c9edc7ecd4fc9f4283c29a4a2ca79cdd3fd50a7faadfd89d48378e7cee3520ac3cd2b1037b08c31ece96b82dc717c54b7edfc713d5eefd8daea1b3705775ac483189d6bf570c2aa0e138530316a05a3febd358696165cd8bb84309853b4a203c4428760b4d78db4f974b678c739d7216e5efa497821b92e09be927902b81af10cb6b71beb12e7036746d09f80e76470437be20ed6c6c1e95c9d73b9b49036f8041f42cfcb5ba26f7dd4f71c475bc41cef59380fd1fa2be3f5127374748672edd9ae04475d1734c5a957482f962f5e865ec58e7d74e8a1a5885a4013b57b3b511efe6e34d72748e75776bde6c83bf7ae193f74f29cdbc3e0bc75a7bd7e3ef08062a38b5cccdd77cac759a8574f19cd19ad2ca0310e375fcbe78231fece5517971dcf8dacc1122ad5af631ac05b93ef91e84e303fd99b116ebb5f5ae26d2c9ae4400eeb58b13e110a7f509daebea0b933567cd5edbd6177b42d83d8c5c11f942658e3e22cd5795431d85210ee5c681507b37af35cf2ed5c83b1c82b643966be932c644958045a3fe4e440b7aab2ee666e185993dc30003b24d7de1726679838848b045156f4c9f024b511dcf4dadeea621c7eb1a03aea56c86b1170ffa9a23318904890a8e32778c493d721a5d797da874043cfea526211bd98936764101e2d18b36d0d9c66d3864c466d3046756fd1cf046fe29d05daf5e9c91461b132a6d0f60c52e58857e510c0537d7a9ec50fec43d94b949ac24245204a9f71381684d831ab7cfc5bc9cf420aef8d885a06e64fcf58945ff11a22d03c62aa22304f419736b377b9a146f493a78857cee3ddee1ec42e416cdc006dcde43865dfe4e1294c08e2f96786dba754efb09dadef54824e02833db5eb0b4f955339ca3ffb29dba8ae31a38fc05b113063e949d3e38797719948085acaf0fa8644f2d351484dba05d951137efe6038f8b7e60d1bf62b2210c6acfdf92eaf51a7b330f4d7fdfd401e2e0df6e1038c30f1d5a614978f95cac48249ce563ff8203a13d9e7d1cc75140e966d7b2c449c78b2b0d56b1ccdf49c24685ad339e31bd51b10788b21c0b3716c70fc70d1af5ac546553ccd137f21524aff4ceb86dff8bea57f148e36939a6c600faed8d9e1795989b620433c2f4d89d9b6c0ab92a892d7b0485c07a24c53bc1b58638770b962671e3bb4d6cc59cd442b3395edf39c061ac024f5e58861d5715da1b2d345fd170bd4f6f5a962f2d39224a57a7ee08bc6e9bad2f8be57ea420623f35670631a6ed0eaed3c54c41dc2c772315c1d81201d05836efb99a5fd5a7189922fb60f8733a33f90415befedc99113ce6cc28e405db5c50c60dd9d0886ce9a08ff4c101de27b86733c5b5e9761294bbcacceef214327ac4e9837b8d6576135b282587b7b03e2bf97f546a9f0f3c6fe015dbc5c6cb5e504015018d12e8339d3d54f440a868ae14278bcd3cb6b97815666fc67396b812b59524468f99353b39e3102fe8373d90308f8d4d80592d5b669b149c701872dd9257b381c2f5fe42c341f2a3c1ef0468048930b8abcc43a46bc687d4d0e85f6c086a567b0af6c37f050f37141b9dd377fc6ce448b170468a2efa335906856fd6bcb4fdde131c74c128ec9511db44b236536f0539a89f517af96841f0d9ce4c72f9b329a934b018611d01f614378ade270524296780a91be4ab3af6d676f37c3d5a5fa0b523a1f3a77c1e512546539edef092843732c8f2a21309be50345547f76ed9a3bc720706a858b3827a2c09cc5d2478dbfee737413f0703c3192cdaebb43c839d9b3fb5427543ecdce719366ccae98f68acdfdd70c1c1c20c50fa75a8575cbb7dd4d068a201c4dec4043fda618a7f9f20514b3c9ae3e0270f79f74d8e5fb4af204a4ebdfd80741d2975c6b90f844b650c11896395824d91c49cf2db53fb34ed5e4fecfe6f9a12204ad26123be2cb01f5e36fc7a6957e2ae7e4a8603b617639251ff725c539da4a8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
