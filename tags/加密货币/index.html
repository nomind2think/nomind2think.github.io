<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b30d2078e9c6db4637357c27a94aafb713ee83d86ef9d5a25c3881e57cb50e8055ca06180fb15d927e0a973cb1810f8b859d503fc880b335d4d212ea76e9368b7445d11da2f20e73cc84ab4658d68cb2c4bc5a02aa66fa6230eccc0e6a7dbe1098d6712b86f9b564142c442c69cea4b086ddb1bbe8eddd79e44f9e44dbba1b6a5e1bdb2f08295f8c197cb1e0eb0687684758b003b74717ae6df773f51011dbb4becaa977aa708bde74eb616cfdd3e3ee83b4eb875d5e1ff22033ecf69db9a945c1167f8b06ef0ce7502e461960791a962ac53ff8366194db02bc08b7e76a166f8b788c4cb11d445376a38e00fd9dcfdcdeb780f5e278d699b19f986b0f51531cc79f09a6f4a8f61e8e713feabf120c8ed6f8977a9ea1154b4c493bb369c42f1e5dab0edd1509b077021a867c1ff0181b06a63030705b6465b4b1b5a6231641245201a4216838536d394ea038bd8fe3d6c4c2521939f47335488c7f6c36a16e543468656dd1b3a095eedf900e86cb4e0cfa9fd86f0ede5fa52eefd12f92073263c77fb0440287571840ef8156d31489e03eed6276ba0b193d10046f0cb5541311c9aa1a2e13b6667c520b0c2f9bae6f33aa76d2cecd57bdd37362ab52101d9c4df2e864ef713d3f80004e0588b3c39dc10e4c5c1e15db6234114d4ca40e8a65fc969abc60282b9ea5684d79c13f6f1eeb9d105c2e61bf0a24d1b28270c9451a6d93bc1909814cac51517d16cc7e7a900fe26878ce4c8a1d00653356450be48b19e2216df8e422fc0969f3b7b2a416f7a101ad104f847f744732470335bc2d79ba0b6c7bcf8f5ccbee591c4c44347b4a0e4d5dae924253d482c59aa473907eb1f85680fd1efbeaab81b4f54601c688f09ad2e4b9e7ce64cdd4bf82c2937d167e542e41137d20ac63de696b15a8e58e2b6d2b0c619e49945253f64570f4a5363375aab4a52199fc84c3d6d1820827ad965310b28546b70cf8c1c36dc214faa4e7e2be9add17bd930f1b54451d4ed188b82b434035fe37832f78940c5f2adf9c3831afeed019fd49cc907aab0ac80d4139cce1778d7f621d03c1649620d441dfb78be6a4340fe45719139eef0a6409c150714c356ed4063363258ab1a8d65d98cbf34bf62a0ac69e776184f3799706202cb7a2976538ef4f9dcaef6c3f424c28a40fbbef061be377219a7939eebaf327821a48e015395109106fde7063bc2437cd2fcbf183edd4dc59cf38edd050aaaaac8a666f9c0156f2ac2382f59d8e99220dcc4d74199d0f3b44bc593bd091ddf3cf02e4a8ff7e68625bd056dec79b7cca57825175084f968f7db02290a5c107484cbbf849d42f5eab736f0ef328377e7d65d69a69bdd7994e9dff6744a0a5ad7d53fac469fddf6e6f191b902b1748f3cf66aa7ae6d15f5a647177aa10b50f1f3a2224fbeffe039974c6d1ee12ec4fb503b2f5611d73003210a1bc8ae8fb38ed72d5c12f0960cbc3a938559f9ad8f046f7acbf95a5c44b324e357dc0f8763d1ba8713696b4b3d85df5a672750769eb50437a15d9db42b3c2cadb2e9abd615c266910715339be7281cb4d1dcf93afe56d85503ab152a5b3e126f69a746c9a87fadb004055b52d192fb42861a01d4fdcf9274f5cc47f4810b1325fbd91ebde52f084399963b4508b15bf97beae72aced584e196c2d67de8b2ef7705119c31887f8267e1c546abfd984b7721da5d2a892f38edaba7c7cb9268eedf2801518bdd1a678a7c8819a9098ec4f4df98c46f46a4452c0e8b6cbe926abb56b5e1ff98848a1092c1346db9f3058f72b55b746e8de327595792fa86a6547996f5f78ce5068783ebf315127e30d961b272d67d9551f728dd1cda034528a73075e0b661518e3f96c49621a7b0da546e10f692c34ced673cfbad027f925db5fcc134fad08f84795401e2f0adf8de45ba76edcef29ca03d1e71e55a50ba224b96a9266912f0d0c0cae37159a0c52d2999f544e16d74398b6b3daafda66add50b3c8752d62ac26057fa3c793d802dfb75b5cdecfb93cef6edc1e5d1cd1a4ddb9c105439877056386cd6c5b259877c1e10bcba5641afd813799a6670a99335bd4d7028c809726e9abea76f6d777f4c1a871b101197b0c2a56c0d1ee4063d59889e4c93677bfdcb9e1931b048fa853da9af0bf3045ae479d56d94f4ab88565cf41aeae0777dda10093f830488a09811c8244712e9e5601a69811ede4117c6f529aab5401665c1e62591b949735d9c59a2f41f6e6fc21130bbe6bed7752cdbdf3021f37a62d10d167fbfff76b15151ac07b9cc3ee451f372b094d4430033de85f69d2a7540b8e1734b939af2ab5046b9fb1124d25f2c9e17f8a96dc076521353240e7011bd9dd8ddd3fc5d99c4fc571161f0264c0eb485fbdd4d7b34fcd8628410ae265461518ed5ff3ba600bec5be1731d66ceb9da52db67f87214656fdcafd8a1ff016ef2d95610cf0821aff43648d8db5e7258cfeb05dd285a9f30f2ba0ce7180a2fc7abec14ba5d2996675da57cdaba52eba94083f5cb7b7d29eba2549b0d9dd48f397a84281998a662737762261c84c992f45ef9670dfedfcd8da691ed5777ed079bd14c701c54e6097a8e63d8dc5eaba4043016342f2fd666dd71ded6a3c1a155e5dfd6c887f52b59d04b3d2327c191fa68b91e7b723faeb193eed67a0e8093fca8f65b9290a4ef0a48c692aaee3dade4cf80bff481b263ba257714a4eb7c5ab2d476ac25a71b049e39d37e62a5e0c114daaf093393b4dfc06618cd8eb7a64cf8352d84caf9b3a1513ee61d6e980a1b083fdf11da16942c003c8ee20bab4cea45f482bffc28f88e432496f4ae0fcde0526670a0dc839f2186a983d8002d10d48832fe6e80f86f18f2745958f66554dd817e665616624e7c41b85839ac067ae6038f60d9d04fa6a7b6aede4810d9a0e7769c754df2f8113baf3aa85289f639370add89535c2f1e3bc52f2d3d1f2855dbe0f769ef93c333b42d54d6656fcd8cd7ed3ecb6503d30883a305c0ec67d28d1448c3f190eacaec1e1b0ba2ec3a6c614358e993c64e03f8c7e372516fa34bc4c4a789a3dda8c621adb3d89b50b8d5a6f78d442ee23443495358c26ff7c472d6fc6431728d18ef53f0c26b4e6317fffd10329ac62ac6d872de65ec3c8553426e1dc99833c7aa84abc7f5f94603a24b552a9a88ab588e5b07094f31dbbca1b91ddf4f8a1c5b1933b240f50e297240d79e1a37d48176af076c45f547d5615941ec94a1d12028b2054f9251d71b9336dfc1e3c82972e10126fedf82f29ccbd060cc5d9a8afae04258f887631412786c32c16d12f92b79844e99443596f7ad54c60c6736d6d4882f7ef0fe1a1f29b64e82c501c4c5231525edceb13b494ef8f17cdf17b7b1ef1ce23144c6d53fcb23219b8926fa1d4ede0736da9a35b8b5804f023b159b12b379fe5226a56de593976f950b1083fac3f84e0a5f0f8663b7cec5f35d71b4a4f0459235cc2f7a5de94ec6273c0190e14201250a154be31588b9a8540a1def7d9f34a2d7a4f61711246e5ab984c9a7266692b491b0e5375ca442c7eebb8143310887d0721cd3a96dcae4c0902254ca6448ff1f90b032fcd48ab639a4199f8eb6d30ee70363261ad7ce77bd4f61822e81f5e8a434f5bcf9b0d50f20e3899334d4b39e439780c02a44cbc183778dfb391853f20936af73c2c5ed9e1134072c04edb50e8c7a5daec8f617058e5263b91d9d6cb9ce38503150f34da819b765468580961bf7b11245fcc26eda32beda6fd0945f3fdfaa35123376206017068af8f3cd18fd87f6f7e01dddfb337c7e00bd0c5f9e47360358bc6a9126b44b82e94ca040417068c3f9a64a0d01920efceeb30d59353c53ced274d8d413e570b05f23339656f1e84746925564ec91ffb58d72b445304c154f610882d39da235f977e47b8a333226f6e1d9fcb85d88c2d996307f0950ba40d74bec872100992b77ab5cba761f6a79bd9fe352d65c9dcb3fd5fd8fd5166d609023fced7c993220255e93d4068b63730b2c33cb20427c7310689ea8b38d345d28f06b48747db83e14deec240e46d201f63a929adff8090563ded49e24534a9508a5825d97d01653d6ffbd3e27e94ec04af40d92acddd33f550bb02a59d3d013ca5a0ba3dfd44326c1fbe7e37901cb3556acf097b20ecb6fa2fd1ad734107f9946b9a797d46c4cb0785b28d00f419e16a399c84a4f87f23c864d3ba52e7e00010bbcd2274f5af691c95021c7adc1a7928cf4b674cad81da8173684af6662f82ddac889c74e3e03861151615f9c80ede71232b7d337f0830ad9109cfaec85c3e0be8841e7b370a5429aad90039610a9a9156c7408f580da7f52db3a38a334d0429c1590f2c19d08634640f3b29d61c6912eaf251bb12f4002b4bc1c2c0b2814a3848c523bf95acaee912637fad78271ee6b9ed0cc1b7ed6fdd2d2dd6b996aff2bfc2cd2c4edf4d71b7464f96ce2784005672b2ef2df4ba066c056de224ed07d1b9c852cc5a8518b85a87a52d71f86ed1e25d8e3b85d7d411c7d1eaedceb12d75d1c527dcee107576d44b9078a0ae7b66470ec18153c2930874436c37243ecc296cc4b760496e76d7f35f3329a975bb626c9b35ac6b70eb1a22b2923e9f23e5694eab62e704d2490d4d1927d0ebd156faef4ed51e32852e199a01872e68c57a1d7cca29dbc26dfe9ed3c9f1c29b49ca99676eb8aa12a55bae43e97956e83bec8eeedbf46d20f230af449734ab9c84f102d34d623f0eaa80aab27b969e1b2456f7bfc13668efd01b7fcf5cad6f06f764ed9a06dd233399610afa8351fc66f3b7de4178b29afb75a38da37ee38bb56305c6d6d2612d05eefa68c08fc5041d247a5e734b99ca7915ae359e6a1fdeadd62447d232f30e70ab511ac97e9833f9fe04eabf4fb0aa9a4da8410e3f52431bb23bd28b6ddb0b8666e322806dd58774f8ffa3cf6af67eaccc219e1177e4452a645e5c4a02171621dccfa3652832ae97023e052e2463c284373e84418cc932891dab453b420e78cb73bd707dcd0b429942f03bb33432ea583ead2ada7f2aa0924097babfa46fe1317f91a0d7c670b034453604b64bda599fe425288960f8bf88a7f42bd94365f76ff05ea933693bec20cfbc9556f143227d9c3954d8f1723e5e5c6161ef47ab61597adbcb988795fad6ab5fccfe0b95452e542ede614ddb12ece15cd4710a76e19bba4ce1a489313bef8e9a1fbc58891459166df19eb1930ad17254de68332b52bb5e398acf5d8f3874068ba50bbe64833f9eb02316ecc30b9332ef5d1b1e4344654ee983ef5bd4a425fd309d63069f60a8caa877c20d604ca633490ac4fb0eabee6159e53e01742d426ebf58c8d5237a6cff6316b603e732a5dda465a2a864c4e2749232a4d6366d314244c2717523d33f6e9bd9e44b0e11a33207a0f5864fc743e3999b1e93dade8e6a70b790100ffd3aacf75725b51162a8bfd2f0237ca30e4c64f56f3b8b707cd59a051b0685c387bea3edca249713ae6a1528d4ff6c58a8a05bdf2a8c88ad0352320f9722bf66cd88b560af8d3b4116e3e9ba6cb406ff4d5427f5e145a153a64f619ad029ab58b3133cc225116b89efd8fc27dbf60e03ca9cac62434f5ea7c62bbf2958eba6298ce5f96d527af68a0b61d93173ee229ffd7a047994ed5fca401c62912ac41951ca0a350a8f57baf7f6b07ba00866e758258237230708ec39fb3be2c31a1ae55167e9748cc83069e49607a4cc722b61b25696ce6f0531d6985e29f2c9e97fe6ba3682c5d51a5ee40651126a8f7eca34e17c7a858d67867ab31085dd9d426278efd74de7bffe20adcdebd5f34b1eee11ecb77ac78f830a646b96fe630e73ee64b31d69484d9fb5a1d154a0cc84caa85a9a9365805771087aff352877c83c6ce9027b275abc82f5da5dd4f4ddd258ee5151406e212a9cde0ce26995ce800c0d5e299e6d044617808c7818cd32257c24622e78962bffff749ffa4db55e8d6884e020764ab5cdbd0999569ffc668d56c36b62a63c5732023b3649ee4d945ed94d726f7401a0b8bd21c6cf55d3ff5cdfc0aeefd7cf741860b1b0c7d00251fe0e8f68b9df860f337e896c014d54a0a1092db080b3652d8dc119db085dc4b76fe15bf345a7f9f8f124d5f92edea39abe6ef014b76772c049715c0c8b48a58ca14a3670d5597b252cedd2d5f7d665b049406ee02f367d3c4fda47ec1f21ee5428a232dacf035c6d5fdd58888d5c8f479e4132572877450e01a98274cedf0c76b049e9da910344b3f9eeb1f1d85953035e4029633db47815373a37b30fe02295b26e6ed7db645727f555cd7624f8c4040a8a3e9ec7d0eef6899cfd3d8c7c1645b5e70001d78db109e7b8353f6eeac392a7e35086548ee782e46446bc849c3a4b5bee0a77d216ea1d8ec0bd732081fa866ae46a4aa3fea5c2e3e96624ef54d5477242474fcf11878f8b1dc341e9a0ce6ba5fc3733746e3272ea8d810d980045b317bf249110be642a0167f98da8eb31303c6c762b7b7b1bcbdb924545f58a707d9ac28b5d60e5b0b8490e549d2d1edeca2b9a0e0af2e1b0d7a552d7e37893d8918bad32b95ddc6208a57a2aee9b20ca65be003ad2cd746834939445677bfe2d24972327cf6f0b1620034b63d7d79c2be62fa2e8744cfb997de545483cfbd0ea9b1b7f43e12d0584656e3d8e50038c75e825d455c16ae4311003495603edac6eba16874498e4b65e4491da0269a85bd443f487f665a312c5be9bce7156c67d8385ce2c17586094e30310d1ac0e6e8b1244a606a3ab86795e5b1afce8620e34e9f6a25aa6773e286c316038e19a8446ddaaa1ac1f4e9722db569fa80a4dfc0b0eb159512698509e0469bd8f73f8fd213e48989d2cfae5cc17f0e771466d7535f8e2eb8baf622037f42e246c65ceb0ea078b2c64b6028efeea3be10228bcce0e633466666924ce5174f9fc7f8d6c6e86d42ca9f864f9e2273f933b0af640948c6145cb67ae9dd16b5b3bd13ec9b5343bf593373136a5fdef71a7c104a9da1a75dfbe7414291bfdf7ab40aeb28eed7235c23789cb4d7faf21d82ff86e8536d71062bc580e97092f07b8817664d8bd0ea6f27d2f474aacbf5e58e440785353ca18d8b169a7380ae344241ab3aabe06fffce8952af386683ecf75204e22604ab98b52303b8bae56a135810ea8ea1ee436c66c03f4c4be2fb0add0db68670ef5d4b7f58298142d921a6435f88bb1a31a90d54bbbf87b399f1115f0e27b51fd442bc17074d1d3ebf882e8d0ae766ae73b9643e2955f1eb24dd8c1feda42a86a111fa4156e7898cf6d116c7ab917442a3c615e58eefe73f0729210b4af125c476fe3b0bc4e05ac685097a4f7e0d9036fd17a5cc8fead96016f2d3e33018e46e8c73016e2772d567c78bcaf55ba8add4903b0084ea6c081b7af9f049b809579c09982966df969e973b2e97eea3c27ef77604065a0b02e7763da57094b231960c82f0d3ed1616bf342a2947b87d4fe7ffaa02f40ff6676d7e50d52c0cc275ae345bf95d4056953ee0b3d014695eb3101084898985da111658ec1e31133f3b1700f7fa5aafcaad9d83f295212a92f3ef4d92f4e692ac0f7f0091667d3d45f0d64376d77773df415d0e660a8ae2ccef457fafa2ebec2b2e17ebc8602be3653fc841e0b08f6539a9eade8af57f2dc6d8f3ec55dfca30b00e65f80199581565ef9ec76c2237276274e2aa5cf5e9a707a231e210822edacba916b850218f537ab45d3672afa4bb6f07d02916aaff5c21177e00e26203cecfe389b7ea471730123afc6591dc5a5dbb56f18e3ccac03fda071f91e61e80da75e44eb8ead4c39099b7b2b8c72870d3b791a3d6add7756c875198924e1407027700ceb2fa449d29b342fc9dca1d2682755b3f5f4ccd9fda53fbc6b493e30e4e219f6b7b45a35ff544db89a811683cef22e00bc99758b335dc74a22ea1b1b6e391e8066edf81355f3de68aa6dbad084d5ab79003783f16d503cc85051e9a1f7521653d2ec2007c3225a9959c9bcf9cd4d94d69b0d1b9b9d08800034d11b407e06b86560de8cad098e2d5ac04e9b947282b838fceddc0563a0da174dd6528a83d68eaae3342e17266cbf21e8949214e421bd4a140aad9c98b631a8c551721d7ef9210a4e1c63ff60fc84325eb3965890b3a8dcd47e028af63c394183515898ba32062c652ab8c10a0b56fe59664d865ccdfba0818d5c9151a29327e44dbedc28b5f4fd25179803859842ed1d765d65945677cbd529dd25bb8a8b5e062ede2add7c9a2e6d716b58438602596289243bf07b884a99eae0b2854fa4cd454576c83795469c659787a2d146b64be962f5f09d639baee6d408c683c6c44e96cccff5fedbfde0d810ede32e3ec235e56cdf00bcd5e5968fc496e0d0da82aa950ee847b4e311516c7db682c0a5cc203786717ad7757e0a50a8efcadecbcc3edafe1f207697d105003bd002c2a846d9326689c981ba196c1a16debb53925af9aa008cbe6a497ea26daef323a3df5d90f2ac09447436689fbef335edfac507a59e19ed6aa46ab8df95c4f496f173c1c4e5d4d67624e3808bc71db32824711ab681fbca817e6fd2b06de6392ec9a4b3a9f5a981c84195d7abe8d436879e1fe89f2defb602f5e084bc0b6e6e08a754f2483877978ce2e9e3022c7c80f8edf93ef964c9669a13ded0b6d1125ba6425b128cd73f78ceff9886b65c69e3bd9d40b2cbbe794af6144f9c544305ea902153de59a688149a69a2e77192c2526a76da4d96d88b52363b7963d00891319038c804ee3d2a9ef5fc05992759428420fedf64e110b7aa07cea925d9ba101236bfb38d4e6890e63f9ab0648d09741ca6f1faa14e0e920108fe8c839bd4f2b44eb51523304f4ceeb85717346bceaf9a29376fd729b36bf3aab2209f6cf586bc7b1c88516c3b3008b9770f7d166a4c3be1c5670518f57798d8dadfce37ea024fdebfa329552c129823813e56329a31b88981f6997ec43a60db51cf8e9d84c2dd3410a6f8b60f4f0dd033b81ec40dec01814698a21482fcc822a5a2996ea354acd2e01707382d64189aa8ff2f205bf08496b720903f1b2a8693eb32e551e11e4556b3f37aa29ac22c17ca29df6f107da0a91b9c4717c35ce8758a23b09e9f640b860676b8df1aa624c1a3f76b4d7c41ff4b956be1440f83296221b25689c547af05999a9ee0c0fe0995cdc32547426f61635f213d95cdc12be1e4aa6c0204e04ad3a8d1ddb933325cbab43ee39b545b4601c79ded2c04a053daa7f4ae9193e3ecdd9a72ab21d8584f9ed5111f86e27dd599a3a9078835cc4bbc5ad243252bc70e4b9ef09ef34eb0cf36495133579bdbc6b5376b51357b6c7571c24f6e8b329b2e9a792f4be301aa089ffa1b8ffa0c6cfd5634b584521705101ab3793dbf0572a085de86ac852bcecdd6d22b308b9d720b6e1e39117f323d79f77d618ede5c634bd96f45a0f81e0c1e537c71ccd55afb400840f91452475ca0dc9b5808cbc82d3bc0818dc265fedafed9ee6afbc05f5bac2a9b2e891285aa263e7d14d5ea207c0f99e7fb0b59ea1d52503731f74379c57a40fa3dac6c14f558ba2881b78956dbabaec2f356f1acd9e63ed60ca7ff68b3acdcdff085c2b2088d858a04411a0c3e625ae82322ac18cadbb5db6633bb5380a60d49860721c41ee0a4df7f559ada2f0a89439656e4e9f2ccc5d2c878cd72dcb5fcdfa3420b837e8be457325c0bb381d122e5693ececd4d16bf3c901267ea226279af864f7db15beb8d8948d2f1ba35020eb7344ea0f2124ee491221417b5acc0d475fe8e18deb68cda830ef0ae8701cb53ab80206692f66c3d5abee0b82ddb323f57d6b820f78e20da3e4e8f0d1ed8e710c8fc963141431707866918666ac182e58d13078e9b33b8107dc642bfeb947a86aa39d08b41e2361f5cb7b170efe461af957d4345a5098e66aa6cb1f0c128f6c94551184116187bcd0c21b4042f3bc91959290206e051ba5664f953fb6396eb7e7f27cdd690f8b5735caca10f05f56a8ed50de1ff3ad7665a44632644fa8f6e786ab52ff6fd540d14585a74bcf7072c77e1b37a32d92227a6be99fbd9e425805e81aa60447569164f9f8b23b1216dd1a6d6937a9c3f6ca0a881c3a72a20f427933fe476a602f477219b0d0daef3541908d101de97d5a0e124ab16ec488d78330108ff8eac8029a0b65fddaca2aa4adfe8df5129399d88df901cb6d77e60bbef6521472f1d946dbf37ddc2a60ffb951e8fe9c1f1bfe69492be78d6266286214c889e3ad5bfdb49ce69baf24874f4994e0213b355e9e69e2d873437f2f389566385e8d6c6849e3f809e4e5d57b7e11e867061f3a2983edcb3eda926c5fed9e40ae6bf681650f029c5e48fd194fdacab33122c605e5f901ddef1be5b57cdda85ecfd31068a756b8cc46c03ba9cdaa7568a46ca2a792bafb02a72f140527554a54ebdb1d593425c1b3d6293f57f85fbe40c751a8068668b3d10501e5442683f533fb198ff3d6fc822ad1246e290974da0c7f0b7d20c3f489ec1f5aa6ec684db0c034848362e54b35753f83547bf2c89de3afe82804f4858cc001b2b1176eda0d3d93e823ee5adf7a6f0ef2a4a868a096a2679b37459874989247123f92742ce7952ef7b3041b763e89763c8deae9ccfc6dcd19539265b82ae5af284cf831d47b74ed96e96617e9bf45e6af2118994019731980e2f4b140e7a0796b6c9a75cac6b549b85a40ae1f764da68f6f521ff4ad37ed99430edc4241e174b7d51031f8db6270b929feb36df5b3fc044e5d19bc4111ddbe79b8ee79b5e03a2ddce7f8882a24b0293a89f33151bde06d2e0112b8e93ca171f3f1f0b32294b019415747de0a0d6c5ea80c8bf76ec6f6d35790fc6e9774cbf6fc039ec1d527be7407033f72f8304dfdcea8f4ba0be57b6a2ae1d7569a21cc82226400b0e7b9acd53e66461de877ef38ec0ab7bebef8d2286ba5a15e6062b3e7b50552d78b60dbd186144cd684b0a9efc74c54ca3d8b82801920b590fd05d65dbd18b54491593987c49d0870f9f793daa57ff7c02ed1f7ee5ab99cb0bc236f9997d8f8476cc5ec59a9dcdebc2ca143eda802b7f7d4a688dab90193499fac1410ea7385246da8afa9d72f8a7d1bca51072aa985342df621b4980208b215aecd002d26de602543696333800d3fe6094cd903f52bd0492b178230c6be35bdcab050d525c537efade2f9a50c9490ddd079e2b2123707e50980fd7b1876af0bafb52762ac4331946c1ad234cb75baa3b378307c6830d6105543cde5ed52a9ea3f6f0bae8cd46ce4c4854dcf8880a8f55a99d91124e01532caa5173d8a66cd309c93bd17eb7e906030395f05be452694e342eb0fa3d461d67aaa4d567e4ab8c781c78be913dfb53b65f395ad6b82bcd162d90811594762cba28f5379ababf74322daac5089d17b9881eeded02ca5ea56bd1ab7a576e996f57e5e819d250aa2b8b0a39e4f68d0e77c6d25947aee428aa7fed38b1547acdba9646ef202cc0b692bfef3b0c876236ddd5e282f20333c05bbc4722fc0ce89f859c3cb370907e7e535a7dc0c320427f28f31a0359a85d00d0e8c8217aab5e8f26c81a0a96d5fc9e2df653b5765d136a07a25f28078574c009b09e83055f75fab59e376ecbae73c77e4fb278be7a1859257aabf7eee193388e41c7a30dc4221cbfa0b6099982a733708e378037ac892a704dc127520be7e818e7f4665a27a2bc289a850621361fd64d4eed0806b22cbde3dfa1e226bfd1ee5e1c6e7a4df4531f3486f705b6b371b824ee28eb0f277614317aa7303fc7e67f8c2ff5c1974b190056c524ee852d8799e58f25cef626a200681ff1aea47a0414d60693bf98d1ae97970fc363c7d7a98a17fc30e26d331ddf7e63d07efe05666a03e9e30fb2f27cd00dc14524f5b7baa577b6e4ea3ad8ad908fcacb765c41fedd22b3ee4d9df42c20960152ff4ffb9b0721a260b7826031a6e61301c5a21d773c38fcdd3cbb8108045969997651bbc5f3d0d7ee3333a173f304e15d7660332ec7ac7abb8db02cb619762878d7d841946c2bb2a6e8d5a619d96ec6710d62649b02bda980b02494b51bd6ad35f81675f1752daf3bd58a38cc733a3ee20e14c12d250d3525c4a2ce9bd67fb37a3c137f02eaea0cecee616336a48a7ce9ba2812e90cb56227fe0cd42db6561413e76cd7a6800a1b1aadb2ea5d31f70534fb0e7c640510f39bdcdecf6b1cc00d3cacd332a48f6b2a07ab2838107e6c7a8a4d40bbb25394b4c96091d9bf76dcee424a10157b8f86f0921c53798cfe632d4908a55d10045c8959713ce650fec167f562e1177700714236877ed9142d5ccecd6370624b45772a8ef803bcb0e973a4d0501897bfd024fca4f39dfd4e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
