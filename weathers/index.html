<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5feabc2472134bcc5f149e490f40c39560ca6b7dffca5611410518c23b62c1a4c7296586b057489eb5e58986160e7d538f136fe854a8b76126865a5cd89737616914575a5136b6f442053cf2862d56ac9b2fa6718ce955cf71389b6ba31e23a1fd130cb42389c649a4369c2ca4c60dabbd8c3628182adcddcbeb62aba606804c54f2f98152ecf4a9d88bf1059615de68f7de7ba96799fdca13870d2470576eef3c39dd6f691e446c74a1aab5e605337a026876af0ecfa57334a39b9799756be913b63d81d70711785ed8b25e1f694542e9a54689aa8888de081724cc3eee7830da797565b34612566946565904c32e054e84ad7a3fb248721b27856c7645d3c97c32910bff818b286d3959ea9623aaece2efd5f253298d624ce0851498a3b33dbba1d8e3512ecb41fa3f9f898116c783635cfce6051ed222c4f8d9b96fa578fba08472eebe21f637abff6192b4069fc5bb489722982c5606b3adbcf352b7590c828747527267ccb97a979810bced4e5b2982852095e76b0672a5d3196e5338a5570d05e9b0ebf676d410385fcf80571b387a478b599d04dd86b97541704ff7d433c79de50bfb14f62f6a5b4db45713a0f117001127cbf52148975fc6c1cb9fb9401f85139714b7a7b2572634db1912e30b900e6ca8e238a06579630a3d0bfa2421e9f7e6d9503af045bec74f040515bab29c97aec7ba3bbc7cb9fec1ce8ab9966ef0b07d2dd35c9b0aafb598f8ad8f9cee34a6259eabdf9e9a6dcc0f4c311d57ee33ae5ac76c52c51834dcb625c51d04c5a691dcdb3c266dd1544ab8a76b167faf7d609dbec60ca4320fac324bfd4a796410b2027fb53c0eb89b90a3fad78fb7ccd683c0fe427bbd41a71dadf236dfddadf33ac1e81eb6a8520f19a19e2407f5a6f979c317b5434ae11fadaa2ab715fb405f803c39e8d2d64a19f6c1fb965a31ee85cb56db3b77aa2638bee9c35733a7f834180c7a00a7e4208b5d08a5f499283ef1297b7fa121ab8cfcff920b458c813a95a27e7ed17519c9bb38cef4b27520f10666f72dee4eb00f767fc3841cdaae76989015ff9c55956433a2bbda4adba11cb178c41bdcf2dcde8a1598d3e4bf11f652ebad87f8856e3268003bbb13f21c071668def0454949c8dd3bee8d485fe263e48d9ddfc6755a4cbcbd833b9432e2aca839b7dbc9a7dcfb78d78e0392283844838cd29bbbd18708d251e9525e920a2194072949465bbffd8bb0e85967ca188551ceafe30a7df830f215732126de1e7333d1250dede5836c81c256aedb7f331a1c9d5e05a62f61835b615f2d6e6fac01ef4eda280796f017d9bd210d90fce81c0ac50b0d38ce6acc9886c1dab4faf769a7c4f433366b715a5427ebe02e77ec1f401fe3ae22b8eb8d7d45ae60315c9ac522631353c5ae64fdf4cf7bab49fd1a08871f96cffc00f666f829c036f131f90af166f7368a1dd21225ad30bd09e8b7af841205c2b0be6323904a7981e9c2e39b081a1d4b4347bf7f8b123999bce80da728e92587f3576d9bd528b46e0c271fe5a81377a54ed831bed4a12167dc61b88b4d9fda253fdaf1e9cc508cc250fd775e106afdd95b79a0b6367e0a142275ecc49231e0ba898d7101d6aa8e9bd98836b93c2c423363f9f29233924352e4756c20b0f3f659e761bb3a29ed996521a185ed9521aa1c31eb61dbf5ecbe956dac93dc2abead5359313125dc2b5e777b0d206976c6a2221070b86ed3e1aef537225acff3f7357b66139350e321e3136fcf82bf55760e76f0a033f6ea1c5cdeffc9c1004afef07cb4f8b5992286dc387d6a70a7029b740a73f8fcbdd155053975ad4ce587abb83a125dbf31bd6a55051a5b8e9405aec635f6ffb5e60c5a4a97353db32b2c91bc3c8af4107645f360460196a0c790157d8d0319825e934d3919f2dc858c00fd1c1ecae50273c2e2e3331a62ff2c6bcc09edd039ef59121972085e74c0c0d7563420837827ababcecbc0a63c1a5713835b115778fa42174a3eab328db23fa97270968ad03d155c4c1b68375467b30b242e4612d6394a5654b23fa4c6a90af415645404981d06aecfd4c051cd000c00f7133023ef25ea3a483c2a34f789bf2f1992f701427598a61264cb247619884555b7a2fa49e0d0e78f3500bc4dd71e1dc8c3bef9e433da93bf0feac900026895450b770967c5493f4eb95321a65bef12f050132f231008d845bffc339db47193d030c19a150c34a8fa962faa15fcef0d19dbc8a0c3cce1b38f7787a39ae4f8e0c4333c3e0a5795ce3cb9079080fca8a72c0ce65839c39c2e9e549d6c126e6614556d5149cee212daaf97f93d21d307dba904a1e578074538565d52df48bce2d7b346e8b64ea7c9cfed9f3237eeb2a4519763fde3c9c28d4be36fb5bef97c2f3bb703518e459a9a2bfec87514820336cfa9559cf968ede39bc96fcb92282808e936b9786ce22a8ebba1d8f9053ae41f67319d67faa7a9703516b3bb6f6569ea4c02605b9c9d4bb3957e5b197001649701fbf00b9fde45da286a53fe7d73eb891b6b40b3b19ed5e684c04492bcb0d91384de0d7c74fa1b0767b1b8f2fb172720194dd5b2b6100f593e5cbfd18c6faf353fd8c5c2a8652c6d636d2a4b5b9ac91beae93dae063933298ae3afac4e9d7bf1e72b79d6fcd89ae029edcf62cad8e7f33fdfa49a63356171f8dc4cb1693cbf148bd08b35fc5f7a7508b137ae87f666bc6cfd8435be7db0df2c44362991551b7c593261eb43c54877ea0719e4428cbe35b16692b67bfe9f5a2102fe9f29f31b68e7ca04e204d59420da1bffb12ce6e765992b3d20f49df5306c451deb3abe614cd4155b6b161952bf4e782abbe0efc92b7f0a2f902b3de1a364420113921cfab597c0248df49b34ee7ba7457f6cd0fd78d887df32a816492d1b482c87a6938d076333be946235940c93e3d5ea91d505fd031804a8abcd628de579e59eb8af225c1dbae178d11f828866c4db6c42bde35e534620c84c4d7686c77ecb99ec8825eee96452d810c38a79972e7f5d6a0ab4e67d00a6fede6cc8b35d1dd1c75f706102f337cafe88f7864e7c8b8ccab21f99874f0975ac7bfb2240cb266a0cabfdefb38bedf43613b598cfa598e07fdc43bb7650e395c6103e37afbfbd43d29dfc220dd64aabda65137b31a11114a7f176fca11e9809f9d9a7a5db335d92a3b65443618e0f0d0885be1778d261580cc23bb6d0fe4fafc75c79d2a9d233b4ad674b365b954bd02fd673baa6c1a0590053c2478ae7639eac519ec76692bf0b3c0999c676c36667b77e63c51d0c92bbd94e932137328670384c2ffcef3ea9c885fc2698e0b331d6a97adfa96c51e6d6eeeb16b420fd5869826e43711031fee1271b97f992de4845d34dd2cda3f078198981d1f6676b78e771bd2e8153e6db01d3532b4c047477c158d4ee6b28fe61855e3c8c7b798ef5579c0a2977bb2b82bf08d61ab8b7912448fa503719377983f91e8827754de7b18103e5103571283239e21ab96c040b7d8b3ad70d48f25c08fcc89d26f059576c2b6b64945b8237e62d77f944ff0789fd97fe80ba3e32f62453b4b65baec49de18a4f6e22f723debb3a01cbda3a10d33b82803e017452b91ba808ef544cdb41c7d1cd6d55766b45dcdce9ad4257aa141751ecb6227aeae4f8ace7072b1a3535526a9e8505fda296987e8a6e590d9d9d4e98ebda654ceb47d3de188332b9ac7a5a4b2c90424a5dedc942675d5e8226a0bd68271c480073ed6c2dad9d998b02b93d2e2837945e46171b6fd4173ddaf76b529a1ad37b50c20e8702284d5cd7eca468d484fa770d945756cab26e648f9448899396842db615f944f317d48d3f115f628b9f12d10576518ee7d1eed1c3a02973befe0b97c02850d2f59749bd866b8d4c8c6dd4cbc92f070c15b719f9610e19dce91f5d022b1aeeb10a63b9c023be870a84677e6957ea58e26fc97e6cc4b5b956fa1f1c543aecb6576a25ba417c2be49322479be8fc9d194ff6dbcbaf9d6fb80a7887271d47aa08a7dc0037c87f3c0713564add4a9f05fad9975e884df5029afa71a3b4edb010213bdd844558dffecddde9259eaee2334129ee6900376ab32d0af51735a08bb31d226119c070c2d0f54ad7647f4acf8e7aac53fed785e73c3bbfdd3b553a50cbff6a1108d545b20030a29f0b1994ffab855ad19196a205858a791f05efa908f0134c5811a4be829168739109827103b6d51baf2e473f7d455e14b4f0814d23a97799fb11d538c9cb37c85461601e7ce37d6a46118165da5013842af1af6ece89cbd12e7c1519fb1450f87dac8a667fd3a4a15aed3b807618f2605e2fbf83fc96b93d221b42daf79d3dfd625eee7004b3127468f1b7fe872b9628e013b89c4b9df2b5e0428fdbfbb7fa9cf27033ec9f1c744e4008f032a3f24fec574950f12148bb74ac2921733904cd1b84cefa116e975ba31f68b2b2a26652c20f800e039e08c74fc029c439d682cfd46357a884333ed5d5193a36093ca4023915f575baba71f497a19d3c7ebee78abc58e177eb8ce5c45ce877d21029b1a2c0860697443eba40f88c2ea25a8b81dc8680fa7222d4c8ce6f9453cc7c51fec5cbdcbbab335961611ec13b8d012b286a6caf3bcb6655d4545f8b01259d9dbff3344797beea1b6598da3c78460e0563d731e96bc07a392d5f15774fcc6942289a229155bc523b87c3165ec1abe5022d63b330b913d3d91bf8e773cc4dda6e905014ec112e2355ec7110cdaee03abd06732aea98928c8c074d9baf9de588b6609f60920b06b0b9d98dceba62e84940871b139aec326db8584bbeed7dfd39e98b3d91da22562d6780febb04ab427cc9eef033eeb29b5dad7d49d758308a927fcafb8e82482059c8820e510ab4ef58543d785e6f23231b82256c593bee702f4edbd4b57370675ac3ef82bda7ed955a3b41b008cfd8a81511a593839c822b7ce8b0cb4e668b0ea98cbcb3106171039938e7b9f740c294ce07549327706f91a70274ae22f86582204d904db3c47b8d4c010ac11c5a5bf8d0021c3cd4a1b2b869191255232cc76a951f44141378e70ae388cc74c9b630d15a5bb44e518b96cc2ed3adba8d0d28d1bccab70a9191803a0714040d915aacdbd2f507269d4437c00d2efda60c68663407dd4c888c5680b299c53a97b3d537beff37d24113188c2e142a683aeb4e26d023f618ce3d3de5a775db1db24c0e50ffe274b5671a0761f305a66a911ae265066b29684a7beb672b88e5af9891b5f42ac2723dceb41c5071405388bac189729039c8f8b31ae78f222add41142027043d02831f11015766defdd9a8f9232a63fa4e21addbc669cc95793e3421bc2aa70aa5b5f042f76ef90bdd6db365f562d4508fd2228939fe2e9fb7cf6a4fb840a5f65e39b732259490c5395560e9a15e583d5ce24b91ac597dfd96f672320a835a2910b4b014afeca0841b83ec0b10a188b602406140aa5916f4095aaf70e367278cc8c7bc49ecc9cf978a59bad5cda3ee204fac8c2ff15bcddc29d775435cf866c7860d39fd0a9a5ec6dca91b1392857188392683be09ff52d855f8e87b644e19e86e050c40800f5b377600ba11412050e7c792a323fb3977325880fdb52d481c282601c003e8f2e9752c8e400752766c09d3dfe82e7ccba08a90669cf461a086cfa248f0d8d4b726da3037e95ce3f92aea2ad1d6448ec6c505431fca49b30318615939c1c338d7dbe4074b9519334ecd00e1f969145ccb619561bf21a0e7014a4c5e46a2901c01c4eaa5b24399088291fcf08a06f216e6db97b9eee4ff2ee4cdd8a6e78d6150cc71d219fedcf69bd1215675f4e0cfc831bedd51669d7b3745d7ef3297cfb5d54e3dd7894297c3e75acee20892d9f6394726a9f8b53d0691cd5f7a69600de8ecd34e535656b3ed30039b4255dcf4370ce59b07a143b5ad3bb8e479b8100abcf6be625868658935032b8dd6d0a4ed86c803491b4c1a74a48fcb2d728e5b4db98249a88f53935c006636153aaf9ad763fd7e2756d21b49509be2a3e6ac27e46f92f4b2ec1b396cf48667fa885bf3e4eb8d6788bf4c22d4b9ed45e3e25513e5dbec262f1c8c2a140a540e2e51fb1a08190af57c0d27bb7e74d7cbd514b2a724379590e699df26f1a021ece41380488fdfc3ee541796fe7db5d3a9c31162a6e9f0081281659b2163650a7ebab05b03754f41b51cdf7660ba7cae74ebfaa3bfe7d329af85f308eac3a2eeaebaaec11c9782d212a2115c162b97f3680380d5454b3087e3525871e08b2f3b03dc806057e610644df8ae37e428edd9c1d21121a2183b2af8f9993cd115bd6b174f663435f73018a1c785307e239a5886b84c7ba7e5e55a7752358a8f41dc60e3fc228cc41b119376616893935cc3d97a567959f4e3d3397a57d0b7a91c207eb16c757a270dba296a2765d7604e2c7ca5dbc96e81a1a3a4ecb00ace54fe740a8bbd25308fc39ebd17549090bb46525947dc63a5979c904dbd5aa1aee7c1279673083d7515fcc3289ab1f7ae4c7ef4e2f341850c40369197e6e0ac3d8fa6823be65eb986ec1ecee96578b3c7365e49dd3717035b338bfbde7d4e1cc605e97fe3daad50a4621517103689af335fd79543a10a98c88913915382370abde53255c64cc0d934a42a843d73298a4d260fa6611c58fee9b1e38c3c89c9b28b03d0d183f40c27586ee0fd4ea217f7ef4919bd837ec96a513bc9f973be06f4de68aeeae46af8811b2dd06a6e7eff2bf5dcd30f5f92d282ab193f6d513b0034bdc8de43d44bf17ad6549e84ad70b7409e41cbb63e5b0b63a026cdad1489fc1de360b3660ca47e5e6d2d1c7b961f0210c91be619c2f2f005d6b22aec8456fcebd7163d163aafc57e895bf527fe32f4cf523bc2ebf15d2a08c99d3ef7e271605f65e796598f599d876c415e7e3958367266fd26cfc0fde66c93f748c714dbe6fa6b1fb56737af06062b9d83ad6f9cb28d565f20bf422b0272deecf2fade77dff0ab699710a06a4d5d343eb5086b99166f6f675d29d4fd07e53d00c572298d186a34bec358b4564917a65681d447266998980beaf31a27d5caea2c7bcc037a5573a85ac7a3141b5ef898ad5fb24d5e90bee1a6bbf073fb786803b34cb447a0f84929460d8ccd77abdd3479c3cac76f24a9ba699f484db2d6832109d967d54d903b7c468fd6eefbfaabe3a9febf7d7ce3d067c04aa3928739e54348435a8e0981a635afdafb1399389e2b1c56a489afe1ccf399145e09a6737a2854b7d13fcb9656ad04c7e839a4e02c653bc6c08fe9b88af5745e2cf22dce04be05a6515232a10c5a86be0d38db46f33959b960cb61fa5eab08fdb54fb7d46bee690f2e271ab4802cf7750e96d3bc1e02400b29b81aed1b1460576626f9ee4d829ec9e88cd54066d2b18d9a60dd553ae442458accaf1a4560eae247ac148124baff1f383f9b75540df9c597c88c0535bf76f3003c7c35e2b2a9d10dcdc498fee52ad5a8b429b762eb75e9c57a0e0210f310f2bb1711d80c7d057d71d9d9e7b949742a2c6b368648c746e6edff619b02bf8f167e4d0227cd48f250d0f2814d1136979b4fab944b0e225bbf74fbb332c3ccc553c0835c0c075add889da5c7f365784a749a992e1d07646cd37b9038b196040ac326d268ef602b96c718bd9554b35079facfbbb01dbdf278789d0c0d1899a44e51558eec802a6a7fa56cdd6f1a8592d8045947a9ee1a54210510ef0f0aedc9c88adae3e6d568e558cb03583353ac64dd0b69af1512862de2c1864174f91b31d3d15fc61cae08836ba60080a963eb1367d6bc7252050e35d6ed12d435bda3c3fa088cc870e929be1cd0f4e499b14871f4c055705c94cb66b817144b57fc94b9fbc54aa89f7c10a67e389e240c115ee41212284ccd06a3da21aa3d1069fcde16b6e76db16f3de7ab5c43cf27ee0d5b8461e47a526a187144480e328d274f9ecc48cb7c60ae091ba1e7dbc3a54d7a8c17414769f4f24c72eada043fe11f4d69fd9331722adff64269724fbe3a34f0676c5b4a067e960576bf3e15355202289f03df9a8134c8b9faa9ce10699ee275060d6089b853fc1b1e4706d15a9f42de0776da77d8f8cc06a63d1d69694282ea46bd9d3e0747a3c35af520ff3ead1b4ce3ac0f30321ca54d450a7351433e3c6633366a0cc0032367abc5b8944f986e4c669578c149f789a1045f61b46f77657a0e03046262d03d470bcd1976554209bf6a2aad92cb1f407557a7f7c4c45a6a588e25277dfc3ceaec07c4a083d47350af774615ca5ac33a4cc240a74af159ac79342994def662acc56d41776deca9aec07eadaa5518e89d88c6c9a6d11a72cd0d2356c0d68e907388f9c72d4baf9a5d319fd48432f4c77ea7b5bcc765f7169218798697315c12a2fad15314bc16680a002bd1f669aeccad6ce73f7a428fe1bd3f4317b4b429f4d81b9dec7f1ba034abc3e555ba4e36c00e7622fbd0546b031173d1e97626f8c6fb2592fcc6951072d0c2de5f1c79280c2f395ac4cdbdacebc0930e5bf488a48510b127730b81893d24dfc2aa1c4263a1fe3d54a0c41983a3f2bb39c4aba3591ac7738732abd5ee10c039627b900551f8f914212f862205d0b42af64b88dd636685eea3dae677a43e5042e5ca1ce9b57adda4bd038cbc3120f26aec2718e4513128c4e89da5ad99c3a4b688e8a8866ea3b0bff819d5b0b253c65ffd5bdd67f6eca3e8901e2b8f68dc83c04878b3e0bc0e6db821a56bb287ef08aa97305fbd610c97c007da7a4d82d7035fea6cca6b3be5315534bc4200aee3b46b0df916b9eed406e58b9ef2655a336d10eaf10f5fc8228beb00ab19cb1e9c6518ae93cc97de983d737ede7ebe8006feb437e3dc41235470bad89bf32dab71fa138be77ce338883301de82720433a5e6f0c94cae6331c139e6c1bf2fc35f2e8644957186f164dc9cf1fc2bdf528fbfd8b4cbb529a3d409347f6357ea2f60a5a8c26473ad13f3da9911b8349db1f31e10158788cbcb068652fa9574eefb47a958ad0b5315450b1b9558fd9cc90732cae348147de96b335e79fb8a89a038b14d4f90f7677e7f97ff4f0889a1fdff149f0148c9d598d55f59b23f24e7bda55f0cba9501fbaf75bfefee5b2df2c1ea8cc239f8c81f7e491e3bd6ea0ea973faa5ee13bd046e6700fd0ae52d20f77b012c3d425b2f205968d59527f584562002cf404631fba4f6a263f2404456d820ba8e09b68dfc32b0246e5bb02d913818aba8d7b4aef81814548a50f37237430012bb7232d1078c9b4690091c5099490b96bf568215d61141bd09fdafae88388cb597fb0536cc48e3ddd04298f2ab7ba134df64670d2504173f0caa138f6d0d4c3a869e705bde41bf8540cb511c51f55f3a6621563e762e5caf9af80c2e5d29e36b67c58864d5ea1713682844d178b0f492c62f3e29e75c693285e27868f78da29420210e5d87e6ec277db9f20897b81bc8083120ceb77291e9711feecb02347911a929be63a94f7f4d2b5cba0bff5d6aad80a50638f213da8400916900acd614bc3c52fa72741f8052a431564ad02e84937811833222358bdab4b38f93bc83be68dafa0f9eb4fe309818ab4749ee92930d41ce015f8168f470cdb136b8d3e7196c8729f0f7c2fd4e3b97bd74e18fb9a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
