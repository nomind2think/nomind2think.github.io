<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7d68745224cb449545a32c045a7031c7664348ddb421666e1482ea8a7e014eb02c306e786f39a959ae8127468cca0e05be6f761222f604901848999b9fd7e88a2c8c1c32e5550a4e37acee4184165a5236c60eed46c17b9e679dd590a67f5eb61c6ff45f0865ad06d519313d0ebbbbcff74fecad1f0e5beb915288f21698b39e85855a5ee235b43a013ae2df6b39cc7f14578d3e337e27afa89169ca2972c8a0f0cf73a0a3533d3a2861718ad071de9dab6038f865b2f3b604dcbd3ef96267236726f64f451f16a10dbc01329cb80f733d6c4531e713f3a2b220ea7b886b7da817456f11ce6b1ca3c0b2005b41254bde897deb3f99de7a2a8ee401c34cf3829d540a6a66a993f7bee072b9d54eac77f0c9d8ffed1b9f37808e4240b9926cce63e9e5b440a6fe5a8767363a635101843ca8cbc10730b28be0530be3706dc9fb83373f74d208ad73299efb71c5f11758019a13c4dfcee34f60481cbb3c34aa3978033e55516080105006339b99eb64ef8d39c1dbd7d8aca930243b6203846cafd6ac42866f164d827da2f46d40dfa9abd36a42f97042778ffda6d946eb2928d4cb756e4e62bc2dd1b8e53991ba55d56fdeee27c1d5d95a317e60cbbcdc95ba276299d7d5259b6b01a10d875ad1c9a92e40705e5b6064894ed67c16768605a95612f21fd8fac590ebc61c06724660ec034ab1fa8f5c69af7b83c4e7ea4c1a458d4a772ab93b301706f1bffad87cad5f44f32ac139416016e4644cfc2dc4fdad351bd099773afeb8862c7dda70277caa20fd879bd4deaf4d47de94b337eca9b09dcb4ee8b772cd975f9557227cdbb2fdb4ee38a9c7a7770760100488ba288b12063e5b91d9748cd1e56b3b8a9583f69b876eb33ad01430d32162f9fe6c2bb2332164810388c7371e4e66d9d50af9878b403d7298056b6c788fe4c661c092245d91ceb48b8344aefd3ed59bab8a71cbe2ff0c1eea68ba5210b9a2f807065b5edb630cbb0df9b7abfab7472aa62a34f3d49c5b626cb67015247f3ed155af47b7ec98723dbf5f122a1448de2aa16f3cb81c26c67caa6543506356bf96cd3c775529139eed460f426ef384a2197c71801d15743b1d3bf93eaaceaf8c7a17e0c397873dae7145ec41c68d70cb5da0486975532464a28c62180dd6ba342976b86b613155f52b6915601834aa597151b57a0494f3e2c577bf7ff01bf731eb0998248bbea84e61a02361353adde4b8508b0967bbebb74bf0af5d6b467dbdd2af16a54904aff128212dc65fc416434066860285c49236c6a5da251ff0a2666d15ce6cc5633070f4441bfdd9f23fad570e35dcd8439f77fc876c4433f7b56174027ebd7ae32e2b258247d0ca760dd692f2d00b27529631263dedd0de01a7e7d9b85a1007c3d44bebcd00b1dbcb358047b007c3a42e9fb6dfc09f4c0db0a4ff7c7503d7ea0d5cb8f0c796f661b98c80e83ae66d6c3a26acad1009ee6841c211eb60bbb09687097d50301ed1a98cb126b56d64b7f3b0bb4ff0f79709a65318a2e7708afbe2ace038c64b7e94789315be2d06cf37fccbb64e9d6ad4e02c3f07d8df55e79da39373a30edb9041d54eac56e45ee93de5a95b5b6bc5655e046df327ed125aae58a0e141a059758284d640a6aaa350941d9fc1e9ad1ff19d9755a63a3a3814d8a253e38a3bbdcd51be5b38ae3480777218adfcd2dae8e458f4d750029d7d943f0e4d27489f604ebb50736831d387e8467b15727353fe9787af55326f696335c559b56ed51090ed326ca4073464c654548ef4d402f976ad54a737300644342bc352a2e2175858bda0d72fd434dd1625704b2bda52eab90fa59b3102405de0d070f4413f2d9e03088c75e266cd7efaf89a5bc4eed728a4586dd914c0e6a05dc5441d7641087f4d894d966cf6127dfd39b3befe1f74bf742e4c08583501573b1af9e544e3e28e5ba658b63ffc35a3c089b8d0720736fb1b0ea7ae25611e7b3e18d16791a9838abf6bf5a4e635757a3a0ffa4b128ff09d2e8725e7d8cc356cb270c1389487a87c33d63ecd499862ecd5e261c09ac8450b2e933cd69bd176031133ba13cfaf5656ed3c975f88d1152db353830405b53cf0767a36bd9f1451a7246c481768d12856122a6ca382988cad280ea589de0f88a1a931204c0e9cd4cf8e2871ce66f9cc52f9298aa417d2c384147a60a13710b29034915551ce2ccea8c54d2ab340ab7f5c82f8772f1cec2197d9c882ad10bec4c1e62912f656fa30f5a512057b31ddf93876ceef37ef9f41a3d3c3bb352c30b093e9fd334193bd58606e752c3ab145a6a1d154a81fec85bb172872e101f8995833632a534ad505405204417c0eed12ae43073bb18f75325e219f0fc57e784624f21dabdc38ca590a407379c603c2d263a8c3c2eaaad14c5927406da7a3ec55984a7221ad6dcca4b56b969e3e3ef8ba7ce2c52402bc91963629d7fad65315b56a9968f5311d34325176d07bb2b827a716fcddd8a484f69bba97221e3187a86d1bd71ccf23fea3802e5d22391c5aa68458550aa62f78424ab4fd1fe301ddda0c3fb517746f8f1cd44cb10517e5dae3c81aa7e5f22defa6d73b7cd0013c37c41c254059fef61b9246f5edbd00c3d297e541d148c920a174b94152250a03c22d0270c5c0d2c25c5446ed9d28b59f163b323598d349b0944b45af73fcefbc551d869de92c3422c11c331deed6138edfd18ed69d7e1176240de5005998c16e714fd093182e2c643443427c657c7390a0f1d94da79b05dd73f44400e07095272f1c979ec7119b73ab3bd6050ec2a403cfe4bb0891579c5746db6baf69aca77f03299647bea1a891aefdb27a6d7e0eb53dd782153a3d73f8b726d9017bef37cf352f17082865d83b9f26c9c9221ed3afe10cc861e67edc3a95b9849c1676cdfbbdf16a2e2078ad06388b34d2fbc39098720c39a1d8da81125d471803a0cb9efb0aebd8ed73a58705d696b99203a529d38eada1d9602b486fa96dd70914d2a8b67e3a857f38fab1348a91e63b5d3a9117040b8186f2daab895e6105b2bc9de21be31b49a99480b5435a758483d470fcd226db6179e6054aba812a03e555dfd8fca87363f6c450bea6edfed70ce2276c7c7d11b095f67bc1c948ce1bf3b9157a35e2f272563887e62bd2c8b38c1603bbfdfa2419534252ad3e4a9e6a6d6a48d2b4979d0f6c5b1bda94c4ba427899a890bb6a25caf162a2411cb96b33c8c1d5d6cd8285d9a389e18f976967739e04fd0f601174e5e52450fea891e13b984eee645e7e871aaee9fe3ae4e7171386835e3dd3f3587f591f414e8a2d73bcb4b20fe4e76f089803c874f9b8093771520a3d17952549817edabf9c840282eb189d9ed4acab0fcd784dce64ba096f1820feb7f7cd0ac1c74b8aeefdeaa4c406f1b84b6ccb10dd4f2f1cfc93a29b14dd021d7d12b8aa519e9965cba34203eb4c24f4f57123da811ecbc90474a5989ab33aacec10e5bad159551ea75616e6a1ed173243513ec3ad9ee0d5e0a740070c001680eaebcd704e90bb93ff926fd371e7a74c2ca817322b7f4f9f585abe370d19601146bb650177b496d96453355d7801969f00c27b23a6c9e40f3d844a68965bf9f22bcb250c92c751ff418679f6aa87835584e845ed77686a492ba665d432d063894b1617a844da7ab60f5d96696aa3eb8383643cc67b51e170cd6aa13bc06ff215868b47b9a0010b89524a90194be2075399bdd59d12efe54b364a8713d606edc5872613b9e6eaabd7f8a36b9c9ba408a1b3b522bc3d3d569b08fc9df061965f3cc594d109cf1c97a757a9f74b3f0cf6c4b727a8a2394a19240fa3ceb4fbe8dc2f35df6e14670a1708822817ad074c0f1ed5ddfd3c00a370098ac7b54ab91cb8a20a3ad5357b035bf1c082c5c2fe89a65888ca0250afe0d8b09296b54b21663dba548e1756a3bc096e661b3e77b2798f91ac776f4d3f3bdf69c0bcfbd87565413d084b4bccf4c783c4aec62e39b191c66a26ae0d6308c29c37709ba5fa5eddc223aaf5829aff722ece6ca4e02e40b7c3e60617fa5b1be72f8c4ba064b9e1aa4e23a001c7b941f2536da66e4fd83d4f62a48257c34cf0611c3e16b7754a55b458a1ee919c3b62132d39d080e8b6b70cfcc5f14d1df16ccdf6f38f347a17abd61d78fbfeead2320688895f874fefc99b579332b19d7923d803d34c9ef55167ab91cfbaf19598ba6dff19e568e906f2d531fba8d7c0b71b0d1b38ccf207df6be227abd0491ac70801d40abe0a9fc8e657368f05005d3e3919596363a63066c074be86d8a63c3c636148989b5aa82d0b215ea7857c39b615a45ac42a32c1f18b37f30aa3d3b5b86ef3c49f795d972ee75d40f15b57341cf52950b64ff421a962c1b6c95dcc508f33867fba0ada66653ee13251ae7479fb14e5677473a74dbc8a33aa39bbd688663114a8960018d2df60300697aaf69ad4bba0775cb3d8d2339166e3e4299779c687dd7c37e658092ce3943416935c671e2a5b6b0ea541f07641cdfb121c3aeb6769d1edd872cbd93c00afb574c36bea1c33ac6765709775d3b8a8c621ece34dbf3cf0a6f64ae877d3ad38a63975ee04e568b62cca20ec1d030708b503908f684d3d7a622d346542e969a10810ed2bf68ab334ef6f2bf0b8f0b435a5d67dc39e1118b56f9b417b58da9779c8a50cdfb469d44b4752957ecb811c1ce5701e553373ded6cdb1f8278e8f5d991019a3acae3d9aa26f511f3fe62ac4d5d1e626b170690b5009e6fdc59bd337429d61c1380a6f4d25f77f846ab26e1365038f0ea7c777ffe471429c7f658a3f69cd66f67067e33f9f8cb608b15471efe7e232bf6decf00015944381408582c67d6e5b47b4e65712a81f1852d86dbf86cc963d2f848f2e6ca7360d7d8ebafc007ef0bcf940a01d889bc76d4f1ceb23fd61f175337a938fb7da3db3579d9c456138cfd4d945db35d3b1e3843cd608535e097f3f6d195e6d0902ca7123868aab20089b1ca05722f36a91dbaa53f51217551d2eb8600d20aa58bff3b68bdf0de5b9a1b52b7d56366d83fd6c8d1430266eba208f8bd8269b6b1ae45968faa96b5c1fd59ba78ddb4078df612c935792cc66110524dbf1f55fa3249e8cee68bf2f0d9628113ea9d14a69a36cdbeb916daac43b44a15dbedfcad25b5d5945124b1aa9ffb85fe7b06ab349fe9edcf244d657bc24595ff50ddb0ce43a4810f85b8f0cbeac1a39113a5195a823c10006a5d2f2116d378f7a6a3d1ffe40dd723491b0f131b978f0d3d628805ed0a2f7187d1167b19c1ad35ac1bef4b84ce000f084bb24d5dbe041ac4f13df340b88f25dfa6e96d4551c84902a6895596272dea83f6e75e9bb2f320361ab6f38510f84c6c080db962a128107ca1353b439ced79a06cc632ec58a12fbd17581e95e692ee9c78b20947f560d428be0dbc5fa4c3212cfd347d8edf89276a36df9ad6b460cf5e542dd8c97f0623959a4c6d5aff4393645347df8eaa3cc9f3c4c9967cf4d020dec89c57eac92610d275e878a350f1dcd7dc630096a45c7052a73e89911bfd96401207bd3f6dbf1e1379dda2899fdf79cc1681a267ff06cfb29325071592a7c71ff52a545820a5a2291934c84ab9faf3946f22a9d0c63aef0fa446fba14216bd45f0358b3d3c4377058a7d3facd70f283bf3d491ad60960c50f9e911e8ffeb7f9014396f38fe8788d76065aa7cef7a69ad196ffa38e6e8aa586e9396ba3d49b2b4075e737a041ccbec89ba0ef7f78ecfadcd9ae1642c5119ee0b661d44173fb59e9c22f1e00f523cdf78114d8972471b309668caf9425f9823731a23747ffae7c41756f7269a3826afa775bdb5916e634485b2d2dc8472b8d903ca135e90402f8ab1c8becfb64481b5ca52c654d9acb7d9a5875cbbb22fb8af2e4d3e5cdc9b29c12e315ad658f80bec5b6a72ef9ec134afa3aebb2116ecdc45e6ef4ff037d49cdd346bbca2199a4b87da3943f7e348cebeeeaf55e80ef737ddec5340cc505690db7a85c62ae74f2642470b00d24b9f05d86092ecacb454beafd2b5b40b9b630c1eba3813f7b396c812f63e17eadc2fcb1bfcd2c570455a639774f6d9e83b42b3bf7345f591186e823c1965a5211ec3dfc239d345bf95e1260a065c173503add3384791d8a6be1faf7036b4e54d838b920c9353d3ed1592dae4aed87204b2f983fa6703159a3130374c3e0d6f973f99e34874009872eef4eabaa5faf658737e6dbba1f7148c39594ddd70fc323071f7c6fe9512c5637630a9da69ba7f9f8c3650b7d08e57d1b854f357607f20345f0af6cf71de30aeae41fceb838c48d2702ec32c364aa718254edb9db4c63732bd8bb2b4753cb68d1851a8868d3080b5458a73e0f96dd6476cd69d3de07fe75ada7776d50612e9f4e4f88fae905fb2bc117a53b852c3d8cfa9e13e137b630a1577f249fffa49630d52456becb6f926a3e8d2fcefa49c0c092e6b466764284864c21123c4c213a10bc72479cee13456f3a0c26addc766faa3e920c64cf94599727752882e526874ca526b53e50d68c314049d1ad97ad353b2ae74b725d458fefdca8cfce70e0097f6bd424fa2ee9d56ecaac8e8d08a346cb314558994af0121efba5c1f861e9ff1df37269e14cd12188d7e49b5802dfacae1e9c89c23b731b1a0c441d5e9f93d7c3d92cd3b1cb6d4422215181e5db04a0f44dd5b3ae5a93a4bf34902bcd1cc2d732e36342d8fe858b36bed75982a7eb00d60123f722e779af0159a325391c725bae8d9d0cacbd5cb9bb4886619ea8da03d81cdfc88f75d2e3ba335e4949c7133c6b533fe70b60bca77d5332ad76eb98eb0fe5cb38a6f97eb145ce305fb57be00e874bcec3d6cdfc06860f6a848e578fd0eb9ff346a7e3f9925e114cc330719713f5024707918b8effc517e4f9b06315ff0519f1927d0fafd09c1e7c4833c2b141e7671bc25bc572c42ba183eae9efcde4b029f1c51211d8dc882a269e89d62b4057a727f42069097ae6c7e686edc0b9bb574e497b472e86b96d5ec359dccd1f3069b97cb11744b84146af9d01e944ef6fa6bf68c93cc1c5c8063083dc6076a321e4ec54229a2c7e8f71773d876953e8e99ddb2338c0e9a0c3ea0e9981d0f8469e03a121a0e078730ca84fb9101e91e54e88ead962d064ec5ba9bef169d96855b1137f2d0d17b66c095653e04457f4d79684bd40a81134f98e246bfed220906f8164e6790fc0c8f08c8b3037a5bb59afc06353cbac7e766f857e3d52ca07437702d2121443f73b16fab8997f00406093048df51b063bc8a167b8592411a1a1355ab1eee012c1f15bb9ec7f006139f746ec1bb6d0ba1417f4aba7fd74289fe4440f0345034e47980e11d7c00ea9f49aaeb89f76f2aa7ae92354be2fda24e0f9652af8fed028a6dbedc3a6da70a344adec32dd3d8f939378860a7c4fb2f5378ecf64f275dc931c85bb7306e6d1d7b23585bf8d43998d1e2162e2d5030c82f40d90bdff3da5cc0e32ce506347c387ab042afcf26833d5d9d7f568787c8fb03483f122fac10c44076f6b92e0dbc180150b7e45887a3ee7d12ed33af291416cf993d2c901611649939e2b7c65696163e861c3cf3ae8f15e5b987a4cc8892345e64b1fd43cef04597c59cbb562074e648094b80c20f3be5d734ef12c5dfb8652c4539029f4b4d907dfddc617025c9cbb342b6478911af7febef283c1a711337c65ed90ca50874e8b133940b744edc3e44322088c70f2ee876f0e2fd20e03d54d29405df0ecdf926947c463f7dc4e0b3061ca302857561115ebfe48f0196aae63417b2f22ccb4e822565d81521cd0e064b915fd65c30e7f23b0e0e4e5a9fa928185e6d3b532334c7efec9d375590c973a93eba9b2510f1bb890127f5a0350fbeeae5765d8fc6342c50b47640843f43d2c758a2b01339e7ab4335dc833a7e16684e3fbf3d3be4fd5fe7be36846a1cffc9b267f8b3d01766357873548a7fea19d8bf04b1fde434dd23feb5cecbd95e9e00bffcc8ab74e647a20e27c461278c04cd7b1436b08961ce43542d44d3000460f99c62c0a5e534ee393ccc54632e7e9ea91a72cf0e907a3d1b8738e01f1d1262efab6b018f18c051a09d0f94c34bfb6fe0c31008fbf3067097d02931d9c96ceb7be815735b74a1beadc9bc037e1ede57bf7987727ad2eafcb77d155b97f2c106c2681ec61d71ed07f49a407c9a38d1287b9c83976af3c859d0ba04f69dc0968823549a439127ef5c105819489c86cc2e3fdba842053ca3c51f552171cb0db7d9395958f5be6134e359d804a2de9084eee58c86b6d1b50718ef9eef942d44a467af78e21ca98807ce65461c447991018cc14930ded66c691914590bcd4f33984a636da2fb641da82880b7746006b71f4166c1ec0c5edc0840f765ae5a4ceec44954401d1af42f8c3d7584363d07fd4b49bf20472fb092061294013061dea648d8f42b16f61f299baf71953f6d150cb7c576d29fce55a35d23a4e70a07db2f8432295bf92d59136836528c6706e32ee9e008d58489d2e8e45a7b19af3348cb191b2d318e7fc62f9b56a42a3ada189ebdc764239b699fd442602d23c518886f5c2a7774860aaea5509e1e2bb5a12b3a334cbaea21a6e6ea36e3d4d2ed08166623d5c55b5c8daea282109e04342a993c0c3b1d7e21294b9d8eebd16a17c085ea8b5a0d392af54e5cf0248d47ca86a91b8d918b3f7ca88094d8ad2fe30476e8d9033129a7db91d6f4f1c6a08bf3f0cc0f9e83a94242a5b23216f0d69c594c3b678a72835a935b3db8680e9e4213063f6314ed937fed9a6c511d1deaaa03ba1f7539847cf99dc17d7ca8a4d66b1f98029abff4589a389a9a18db90c80051f524be8d20248f59d893d766e713bd6a286a902edf81d01710a71427343a3656e3c211613fc564ef07fa3123bf4a2c90630546aa9e148e00fd91a2a7985dc5558f2a74b2a53b95afa64db4ea6ea2e96feaeb4c661bd49eaa92f2fe90525e4b1fd03281e7bc8f8bd949ed11a76a4577245d6f8f9e574c1f4ea7bf91caf40556b2af98dcadbda98645f02c9d97a61a7ea3d6942409dd0986a56955898d0167f991cedf5afc90f62f6a7aa5885c397b286bf7ba3f0552fd574e7e0a360cff0e2fd100eb9ac0ef3cc0b76ef6caafc9348614b20589e6050532c94eb82db260cb4c7f7950f5ed282ba3a0ec052d0c9858766b9b9a6522b039c45531de994d70606995e9ed4c8440acea4b8d6135592448e8a376e8f3d26851a2929d9b6ae1898ffb60c8652442c01668c72e07f5a8403f75b830d1d9556f4953fd40ff9b7aaa9f34885fb51932a82120cf0378d52623390791e10d2f988419762e94c9327bfb96d41adad81e2079cf658d5871ee73dfe4f9c96406c46e127983f88d82cb22fa9ee99ff0768cd10de2d940c7d6441ea185399312819da73bac1e45c640a95f40095cf5bb72837abd908bb08eb99e813567974c6df0c732236e2cbbc7dbdfe89f80590995e8c7a4f7b8da04d067b5712701f07e07838a013677692ec2e0a7d9514b1cddb173d915c30ed56833100e1cd371768530e12fc404e661f0471d786b08e3067e7f5ec6f707049600fef286ba072c3825050860f505d4cf62e3fc7cd1009fd98aefa7a07f15f06ed40b847df5792c43c60a93f7fdb577291e8d7ff4a0184b0148ce299fff1e684df7e9aa1ab6fab2cc4f2f7282af50b0dd8f309f3fb7ceeaab55181a3d709f48113c5fa65f98f11a416f7ffd273a35f516f69745daeacd19991b81f5139688da03f14b33fd6e8750a50bc57687138201b41bbda906dbb24543d9333d55627eb0d387da4cb0c9b035c0b4d3f9f8cbca878b78010653deea3e780f91436dee9d7b1d17c57b1a23aa9a9c2ca74d234c40d14c727e5293ae2e26257016bb0e49d91b9331033b36e0494e8588a4b45f042aca4084ab7fc409fdf8e08b6ee60ef0903867afcbbfa55419b826fbdabc8c64b96fd79730de455e5bf7f76bcedaac324c8489d6ebd70b49336fa77a84ba11a33fca4dfc8ee021e438a10610846895459d499035edeea353ec5870553a7a572da37be115206de70e5d0b4c6e9bfce2456434fb3192fe1147c6ef7ba0d2727376041b7d697e5f5cf7ce6b454d7843c4ab1f179ab818e828bd7729581a63118708c068651f3fd9ed568a26e4f1415ef41a1a4287125fe0261a184323492f88fe359bcfb89a3f9c72e79d79d8ceb027d401399a8820605b8e126a3f502069799966af096bb836b47de0a644d5e44c0f11c3d710050550b74c8c2d2e09e9881bd0e1349176e044dbdd0d6e80dcdbb9dd06aa8d755f7ffff19e073f11b364189503ff179e407bf362a8a33f49babbe35638a2ed703c888c352cbc4c817f5d755149424d4a26433a75b2fb1f5de1e649f1b095b8defaf4edb84d132d126eed53d00945ea967f69a5b707146236b14861cb3e1a1b46ff395e59975a876512316b6d5ae8ef5ff7b70c50cf33e305ba2457125020cbd2e25eeb953f257dba035a2d85cbd09d2e25ffae24ff960f91e003f6e7b4907acb1c7318bd89b1395aef04b6994beff20c1e042ada27474e11d094c44bff29a7a9d8a6eb3ab575c2985d0c1aa0dd626ae634391cb416392f7ca31f113ee26076245db69d9f8143bfd2caa2a181f000b31937640b216e44d234b0c50c8104d89d975e78c36b07721cf11f4c48adfc688fce57f3d9942fb14ec7c663e38ad43c4189861bb3f19da017e22ff0fb1745bfd576088780f04f327e3b6e24fd3c35668ea6dc74b695313f6a9d89760fc57d3334848713306bb27e7558daac6b210abe663c3f69cdb2be17629c11611b9be97571959b855e0bede1d6ab1126b9de6112edcc4c2899f7f76d93aad3dff400af8db41acee2b3aa2595d6ffa08b3cd908109309f7e4b187c4de6e070c57e6e44f0083daa0ad957ce80d5fb7e5bf8665bcf75653178174d41afdf1d9935278dc9d2f7b389177b132f05c7dfedc56812f1850b8180f7f11bd856b9ccb314cffa486b0d0a482399e7a6050deb0d0e853c3527558519c97468b2e68de23347ab4d8937c18e2fd8a2ed1b4cb242847d6d720d9e2dcd2db8c8c596bb7d972b8460ff304a6347aef216b4befd00390ddcd96ca5633117e0f5f1b94aa9987905df38a126d63394de1ca993ba32e4da114035b60d3b8d76cebe5b473f65f8931477050c7ec469975abb27321aa11ae78829c655c608d435f4fcb3e68ec762f9d496df18f2590833d8f0ea2372ca879b47672cd65d4bba94589eeff108be20f658d4b1910e2f01fde18e3cc5cd1bcc25e565b5e4fc2209c96fd061ea4d556458a308719f2b1ba34c3bb89e3f200a79348ee94ef8186a0e12b8b32a803fec0e3bf5b6b2696acb2591d8e7c72983bb681507dd3e75b3dbf468638d9d7afae08d737d0bbb9c0ad09aac9428825cbb67a91675e871649520ef79d9e78295ad95ebd9688e907d8239b32f14ef6f36e1be49d0eeae9ec7df73e5e41ba9f1194b34c052cf9fda4ad2226e5da88dbcf32c123073fe23e026e1e63ece9ca8eef29e775406d1d18646ef1006265f16d507afcafe0cd2345c6ee0c323713f43d95cc6fa4e5f830c79d51fc69971bccfc720a244f12bd3318bfb3d20279d3091ddcc5b762a0dad7d16a239f0a2e815058993e5507b3e081fa0ce9bee305ff379eaf20f1010a8b89d2fafedda42342c59ffb15f41d566f0b4699004825f33a99e2315d0a8e14712ddefe048bd32007ac371c0c3f5af79f4b25bf98e934d79469f221a2a11c4ba7e701180a58472d7c3209de81a59119b94ee313e165ad4be8cff86a67b71d15c502784daf3ba3fe9432a5edd2c9daafecac552053dd762c94cc98432b4f2ac9aeb53539e6c63e88c0e5cefd0729778ec05bfc6ee2f7723ed3047799e23e7ffe640c311a4971393bb13479f93b9e739e31c432b99d903ac22056987640d5aa5ce708ddae8a194200feea7c3802278ded8c8c7f0cb04facf83fa5831f44981bb5653f715188222e09dce0be28af5bdf239737315832e06ad79d571434a9c622284935aa996f6ce38aadce1fc622e1205c704b767614ee7f1addeadd22bc8c871aacb528c325ae60d4f49db77b12180cfe7723f49109bd4b275a5b8c07aa00291e0e6456863237be4948f46660bc5c7ee6a90e018b0dd7b72fe1bc39a6422f73b38f14461a7779317a9bcd154e4ea30434043a468f80807e4f76b3275364a00a96c4b5a7096347bdaa07070ce5a32825a30a3ae845ba1b4fa8864c2efae579f9fab35510d45cdc8e405c717420ec8a7b03e13bc350940584a9324db9d6d15229097a7235eea566d10563ead370bf05b9ccac7245dcc50a499ea66dc6f8497551370b68d74189f76b03002f10198933fcb4c621b7c3f1cb12836b1c8dbb1211d2eb00e6330c6d292c2c79ac77f260e14501fac82c2286867944c171b7b0bbf4c90439cbcdf43c87aa960ca3675cfaf8e89ffefcafee58c3ae0735b979054499eb27dab635293ab9450173cd75238b922a384de3faca225c6b35247030c0dbaac88ddd479e4b905ad2dab4a92acc1a83fe3a0178be0f926774bd7dd4c03c815e4e92871bec820458809aea9ca47f29a63b9ab3cecbe5d83d5cfa412618c6fa58494bcca79fd18c78c7231b564e1db6ac5c4b0d3b90e09ac1b9892ebcc2e6de5872bf88f17ef4b01800b7d3f823c593d0cd51ab89b426b084a384f54f1d1f0958015813a031542138f02ad87614c9e264c4e8f50fe9144f92078cb5f0ccd46f0be4e5f37d9c03b14a8cf7835f4e7157256b38fe446f90b27bdeddd5a820fe5c5eafabba28bd84d3615cf992275696f1c7e623b7dfdcc2c1d64fb93568315e26bc8ad2ffb29223ceb3624048a19a15d4fd2639443f9f560faba5109df79f54eae56df797e4afcd173d5257eda8d885a3d32b362491e29965a05a1a9f1d0e96313ce7e8c00d44103bdc8a0f49111841e6e31c17dfaf1373b4e1401c77f3b947e8afc178cf440c230a79b03e13f0496c61364df7cc05adaa5e56f1fb0e8329951390b3ee26fe3fcc2d2efd17dc04ca90ee78166fefa3059185c5a95a4a792b1afcf8277d015e1e4f23887511d6e8655f75d937a33d9d871628b78791b5a3058804b0b26841c80915366395638518e6011ba1f8f6d8a636df4cde0b52c1ae798592cd3826e4254d251c9ad65a675ef87693f8567f01546c8d2a0d7ce0f9cf637c6bfe7ce5c03e33fd78ea60a9af54fdcb8ccd347ff9ee0c156fdb13d34a32a80f95063ce0cd0fe84f41dba03d17a73e2aba6878ee9a29f1b1a051d08ec3a66595ab83e0af30d18a14276a0921f5f448e43919c610c50997f0f5fb38c6119d1ba94a48e6801a4482c0c22a316fd7b67e21d17938b108b7e7c8a0b735482a4e22e1d2ec5af9ec2d33ccdd656759e875c16c262a2000662b4a8e6d8f1173214ff9a24ebead5514b7d593124967e8ce5d732376028fd0952fa113fb561a9db268d66d42d7f3f544bfca8a569f58f71d30917446a5d4bb433df0ccaddf4267a114e7d2c58d368988c155691f7d74396a9f07c56fc342ba132e64494e98eb30889e2c1e9654c842b95f44d207ae95df3680e2e4cf4a31be8323610e2eee7f01e9dcd768e13dec909ade89f79f9dc830be766eb72b717450af5b1edd2df7bf5fd0bf66ee198eef3ef2d2d3b59a274c437377ebaa7dfa2981c38f6fb12e44f94e649f790366ce9e8da4dea0b3d47ab011d500d60ac9e4e55b19887d5f8a40b77956d94e42b48c75b701210b7fd10188ac7d9d2ac8708c6b505f19932c3f3f3382d85ae6195c18c769c99c2d4f14ed168364ff86bbbf87f16b23c7e18d1d36b65173a32bc1a1946428793a3810819533c5e667616aa419f0b6374f339933f91c4924663570fdbd30dfa8f1ecb95d6f472d0d215e3c8326cb2d73f14c54a19940ba472d0968f166dce3907ec3034991c418fcabf8dc27c2cfe4d316c21af2fffd30ef74e195458e2d2c25032706d27fd1e887923e83751aa6325c5886b5eb6b035a5faef12ff31dfe1e3a6a13265c65b765b9f90fe3729199b5db04ef93d574917f145874db4395940946fff20493cd5b8cbc1931df9d6183e3ecc9576f8a5c791d7e66d43e24ac7a363cb8367bead80e594cfa472801ac241e80a4ed10795042917e7e44ce86a5dd617caeb6f326c7f94ba1305794a4105aff7f2cf210c6f3738125eaca84b9f786bcc6f274dfac1c62c0658dfe7f8a4ea7af7fde22a6ac02282582c3f0f53c9e473b189506e7a29c3919bc95e7722fa25369b074ad0c085fd91dcf76d83418e08901ad48de17386df6e08c470690b599a736101e6bf432f7f2271200c0cb1ccf1cca313aff595f521e366a488f029fed67a641b75977ab34ad9e460bc803307c029a87f4a981ab7e51722cfa2436e0360e1f5596b965cae670038f3b7aa5c335bc2abb3cbdd0267125b539ab6e4855973dcf6052de3c8754ddf77b52cf0d84b8dec3a52dd3a1e98daca2de132ba665624af768b02b46592d4b42887fe4ecc9a7d4930dde7c1b7e78f0030aa2df795ac6343031b8dcf6af6e6b1588cfd9dbd4f3a6215a483305fa8a6b9e8ebb05390cf2d09dc4e0c8c7a374bba2eccbd356cd2893cc299d84bfb84f2d781f8aa8744bedd08b43b2a8e44b86bd89e47ba172cfc123327eaffe98863778fa85ca264d21672c5221675c05e46d23b66c7eabd70ba78aa992c52d8ce5c713231ecc7419c3c8a4ca712b4c4806b07d1acc5bd80ce07a2de9849944640fc4280dee350ff0ff741d26818f982c0372cdb6e1051b666b7b9d338e037e4b76dbaf293f113fcfa88de33d9132974cd7bd05bc226e3dd5659e129fea257105d0c830fbbffd78da5b95c48c07e4490c1880a1cfc952e42f364ea1b5d96996305b635b9653508a243e263e19ef943253d990ebfcf9e93bf1b729906c167b36160512b18443c037c602a73b3c7b050f7a45f908a9c9b0d22ad57a237f033e9e969a3eaba6be2d085ec40ee5077a56f1eff7758587c55dd666435ee7b42a317c6962e2bab2aa397c52fff3b13d93227a60111ece0d948ee5365d2384d4aea4b3e841652ad5def11535805c84359c4bf7334e160bb01a2e20b7a133430e55b0ef838640ef68abca4fbb741ef506cf1fa6a9c6e7ca5234e4fa0b75e5e3305da257b31500921cd259d992906c20970bc290727ed05e66cb4657de6fb5eb743cd1f0381ceef6ee7ae7a4f99a02df3fdb87d53aef8eaa3f554ef254e7d281f7813fb294614f69d08c850914e38e57f18aebc8e605b78a292da4a2c82a67891d7c70f41d0e10b2549b94869a9d04bc23fe2fb24bfc0e1b45c7c9ba7af871554277ee7679fb505ba4007dd89cd3d3dcd451b77fcf42d09a3c79b878458466cc7d430aa187aeb077e68486ffa5283fb1dbb26c64b9680c7ff699f25bd56402507611a547396d4361358b4159db4bcbd844ae9f7ce8193f10dc9f99145dc68ff67d7547eb314a13f3c5570eb96fb0f72186bc6fbab0d3929338560844329dee81492f647679389d2201ab71d2278b1b743041cedb5ebed0f21ddd6f4aebe5b4e9c180fcb93faaca83ff4534fddd28a0b84bc1f2725b13158e9caaea1d155919819bca59a4b81b9d52fad2133ff2ef9713dfbc99bf43a71831f5c28ff91159fae6a07dea3dd918472f286896d1d27d144a9259248d5cfa78e68113b43cc1a4e26cc6aec3597e330184f720021e3d8ad0583b46d7940bcf550f66c76fea0e5d536b8cf182b4c7d3a03092510788dd20002ebae88db7de8ea46b22d9b856f889ff8ec1b7e9e482a26ee8ecde27a9d72e3ffa9f62a5ca5db272c4ad9c5742d6cb9c3ef8283604811904d2c03ced540eeb5ea9cf9816637f89f75303cb05bf906afe441772cffae8867f687a2674da3dc1e09d6dde33bc7322bc3a998b8752512ede6fd443624e0ac84274bf89c1988d89413484d3e4d5fd772fcd8d800dbb2a018e3210424f874ea33775dc9fa34d707403819867d915988c5a2a85d3de4b50aee4cd963ac7ea90a5eb2a330eac6518c6fe0de48f2eafea637538816dd7d450eb9bacb14a6488be89c13565d1194047efd3df1ba776a1cfa56d96fc74ce68213016ffa061838d272d811aac7d56eb5c3150455ea5b1be7bf845682d9dbfb23f400a0b70192c394c3edbe7eade76311c16658dac305a1b5034f17e6e5f9ba588d12521ff912004765b7c1d82921b280479385f51ea1845796c61f2c2f79483fa2ab8f97c8b9a50f9f2b3592d656ded418b72bd830be3619c2363ebf675159e17891414cbf9a7cc2f64ecc269f1d2f67474bb3eab9e31e722a99fb682945f8e41de4a1be05c7784a7ca4df3b5a6c24ca756404dff68064c7a2192a9989b7f494bbf74911a3a8fee459750d4a8bb7848508e6ea4c709eea05de682486773260752607aeeb92e6ae0a6d153ea08ba2e5253cc5cbc9586704ec93dff070a973133bb6146f3c5ab71b4e097df6590b083511828c5cf5aea2005dad9fd82407f0c9683474c5748e1074b098b7499d402a30094a35e8b2be8c25ce6ea1093df2ee5f7178b40fd2abbe91484556e701eb324565dc848f672bf8b94bc30221ca1cc2c316237bc6eaa245968d71ca4cc72ecd18e86d73211ea58c88c0193b27eaf4c0cb6c576d7e378def1eaa5392fd2b768b7ccf0b235297d202a39c944f07aba6043b79ddece7c56862f3969699617d81b03a342b9d47cd1b51ecfca4505be865ef6d067d2ad4864b46232f518cdd2018872cdc6051410a214a03d6d1efad733850cc09a0b43db1a7c078ab30aaece84a28052dce23b700df4a9761ec994eb29d118beb9f48f2d36c590b2585f7fcf3a8ebe7d3a90f8bf5b3e7cdac22089d294b79084a3ca326f20d3663cad54b771e3a34b29a33ae4b3a79b1bce25fb2e23ff7bcf4e365e5749ca169fbd7a6f3cc124d8b5ce5c87cc482a5f3cc09d9b3ad62a1d5105b7ef54c9170036603bc808001bf9a6c4094f033a3b0e25648f961aeb104803aa9e3564d7eed8b71c8ec21d1dbddc31417fac57d82e5f7a5f5ba08359c7d0de7a6aa57254e410290fbfe264633b1374a7f0af7d9679f9a02a693000db5496a9b65b10b4d364964dc7b6a2df3b22cf6e299d8cec341dece406cf4d4fcebe31b251bf23655c1472468086cfd32a39d86ec97a07c967e377d30eddfcea1fb6a366cf7f85cb4d80d4c3f31ae4c8fcc8ba1c6f829195ba57472a88a3077cb23e40df12e168694ddf19872997a517d74aae153ad31458f81c87d4a6011831037f840dd546315aa4dd8df6f113c3c87895fd7b607f8ef139ea72d483e32a760218d5927f2888f789236621200335794508213a22a72b3a09c7c05cde5d0cd2ff5dcd46375c1c2d5a8221a7d6ab5a6114e2173f3521dca1db94bbb1801a052fee568a7ada56fd65277953855c87fe96de64a30d446471de782e9f68645f27eec3ac62e45a897cd8a0633e3375409cd98a38dfd78bc6d8827aef0f60b450faccd3f19eccfc22dbd0e42a6c111a125ebef13e718f038397dbd05b144238c8e85df88399c36c7ac2c22a5063157eaf07d101649054ced6108d64749a2d2867a7441235cdbcf4a3b0c560ba2e7bd1903abc85a3e4bc63e392cf90f2d9063f752d661c23f5d37a2e401e9a96f2ecdc5bb420f4d6ca8fd64d131664824d9371a6e97410e614bcc522f0f048308d2f91c4f5d4b1ccb9b30b0d57b7c3cb403e0db095ad44d9a5029c5058dea2e2a854f369eaeb50f8c518c4e3e30ac66946f2711badb5a5969c75aee66fae235194fe3b974de481850431dcafab8350502ad9f77c1f245457e3ed4b34c4a54f7b7b74f100aa3ae646d9c9cd7b472ed5644a3d1b48fb81f0002636348b3752c5f8b904137d0e90d90141c23e7d2ba22cc3f11b36fbeb2360f56a762eb05b039bf39f0262461a12e9b446af0d2830cf629d2cb74195b9809dfac45e8b47f90221befde840542502346ccd8e5068c2bd913f5947c882759a23bb6b7189eb0dc65a39b802292870cbdd959c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
