<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05dd05f7a780743f5b640565440724f86d7920846fb83a1aa24bee42b560369a44f363d3dfc88f3678c3f375e6ee3f9d69463d366e287210b3f0ebe81eb60828649538ad97d99b9de7183054ca8e7e7731abfe69b759d2562adbd5dcef971a9a26ce4e981e3dec6c692f8ed186f487594313854383fdd7e5d6ea5dfd28197cba597b4a39a0a947a528a436b4dc01c9efb26f7e8a4e1d374ce4756cd64db34b34e5e1e260e7f1983151caf36b01ae72387dbe7743f6b81f9135ee7a13fa3365eb5b1f714e0d5b1b6be874dd20d2e65a84024af03803ba8e0815e2aed511950dfbb83a388f9934e9929bfb684626e4db04d5a5499bb753d7ecb8ee458b3dcd44d479b051460dacec2f2e74a3cba36a202274f45f41963b06a7adaf38ef319aa7c58afee9fd63d8b36bf4e493714e2fe499a5b933a017d926b6ba10aa3813fe04b4dae7d8aa084a77eedf2c13a6e8601e1a42b0ba8137650d0bc3cfc4df01c5447e3dc40d6bfd746db441237a4a079029108fa1c1f22d0aab7252ff7c67388a586aef4dc438bfd16a0da4683ecd4ab42d195384f2fa6a6162c0e6aad38383c0b87525da767dff8f3731964d01cb2ecc826eadac7ef913827f5b092c0e4361297c3d9e4087202fb3f610470e8474a710754abab9b1490e0f15d74bd58995dbbd766f8c7c945132b7365848b4acdb1d4c3a6b8ab825cb9d3181056748bdbc51363394e7a4de78f66b66e28818ef92f1ce33a3758a58ee5f5e757dbbbcdfa093df0578666d07152c546dbde547391f436f4f76ced10c6235c2c8b17a61573a30ac67a5546a1312d5f7724c65cf76c61dbc1d951f842b8664e2b43b3558682d887235ecaf7e11f19fb3561e51200af3e409feb29e710c477e0a3bc1de7a997539d62ee85a66de184d47b4af5b9d5628a33eec59e487d8d301e68e3d4846b10d41893b75d1d9966d2d8911233cb588de585d69cae8760518744dd59c2e883390f652d66a9a8577d0a0887780a6220c207bfd731bacb2d18aa9d94c700f524d8d9c83fc7320dd0a03d60afe051ff257c825359b8c4a476274f61cc8f95f382fdf979e20746f7ae2403b5108db46e924cd2185a4a8700ee78c70f55fab5df633a7cd672b1a669544555e6f5f1f626ea4530000a5c7b7531d34d5059e6f657c5e6352be2fe681f7af8e1cc7b126e778036bd7cd0886dfe3cd9171a4e5c06f24f42caf826bf77c7d37952be5d20ccb27eac6d31e7869d42316b753751cbca229ea166c0c22d88d8dd00c56cdd568a90d121e8eaf80a25c60ac628302454b7c7d93478498cd219e57b86f8912953f96404e7ea25f97428735daa2c59dca5cc2ce9bbfb6e93a7f212bd21ef0188efd9c154a1ce19986cef44db30bf4076e192017dcf8c2e7011e6881dd7964571bb1e6bb8835bfd08c02a4e8d790c66764f12565a5a9a2bdf77f74242d3613ad08e05763163cc4430329f8e8efc3635a3cef2ba1f11fc320806f6ba24c7d1b7f5531ee30b1243ed0cf52dbc0f506528def6b81853d0175bbce21f6708fd5e8053ab9bb15d92fdc8373e20c8703503524ded92db44cb08a2be539828df44e3db9de4b60a0470cc9a98adb75be880b191f145236bce26d0d2327a3f2be8213e0d6462c0f7bb6421c5f0413692591a0f0f818435f05ff68b38b97a9116dcb2b1c5b26c220e06d875bf3c33d2bdc0904e14c46bcd8ba91f7a183541419d6ba8f3703505b1ae950ca2621e0e9ff2bcf5ba93022f0e4bee97619dcbefa94d3df37c41fdd1957e7076fad08c2beba745edca624e6ea9c135fe953649e8e354ec268864b560145ee101abf983f464c1c56c2ed76fb8faa22559aa4c0081b450e1ba2869d563001bbd72191895fcac1fc70f6f9a88e7b02f8403100df87dc93d7747349ccb77f36a7c0a67e186f1eddb9c409df193dc41b8708a1a81683a9f8c3de143ed9b3df6aa8a7e42aa20c5f880905227e7587716da288cd83497be1fb08e725ff6ef45d7fe657d7c3b5ff35a55560d843879712abd4165d857c854016bb916239fbfee3fb5e297224b5440d324ddaa52f79123963937d66cfe12a7a2acd6fe7788b258c9e58d491a7d8f56b25b9a51fe891373c72323cee03defba1c81e9726edf008ae42b3fc257c38365534c8108654b1eda151c67286378b98c6087f3de91509ed253ee930e84d9fc9095f439fc1d815c1c72b66408f78860a366538e2cb4bbf01b373331947f073e91c2596c0fca38ebeacb7727941898766bf9c739ca3af920246526117113b1664ca98676b64e5a5331ab07445ccd26cc2b0764a4ee1d9f75c1d8580f776e5322b6189cf4399cc284cd8d88d2dd0057169949b68229138113854ba8e6d6dd3588ca56c1d8da66f7874e0018644a4ea9d4bd03650456a0af52e755b1c925b991da631040873d47baafdf3a82298c6bf6eebc06a1a9e0209eaece3b8e9381b1753e765d4ec593be7cd670b454e416423e3f6fe116db28c775dfe25fe803e2fe53e45cdb8ace024f8065de68511edca122d213f02175a89b812b072553fba29a936d18a750f225f3206aa200d6b4f5b3c0c09a1c814e8819f0daea651c1c1877083bc600d71b696912f611bcee173b98c625809f1a02f26eb446e34f21c20113c07e60906897346130b56b307f32201660cec89d6c237d92c781fdb3053866cea6599f2be7530062463eaac2c131bd6d2e64d568f13091390ef26533d3d55f345989906c039aee4d2613d81351fb04cb120e3bca1904873bb3af643a07760cb22ae625545ecf00d9c16abe043125a55cc6d84ac2d237590bb7da2e9ce324911d75b93a78ccc0735008a0b335f20bf87bb2627e8a7ac6dd3274b5238bfb99ca43b6f49062a2207d7b56041091e668b1e2d65e8791357bd9778e5792dd6943956066e69b6925c2ad151a8952d047e6c88c6f6f97860c89405f676a7d7bd84ccf96236cb1f210be4795a39e8415c7b2422764e4a2cbd79d11a9c944be0b2fab333c8a17237c30898ded384eb2eef57c20ff194845b2c55d5fe58ac1dc9f9b89c699711003f0ce8f9ae0ae9fe468ff6e86dea17a9ab1ec81eae48d621a8c693014c202835753224f6074506923237e28580737c3e4f6b2fecfe364a450841a3d940c4c8ce1ba3e2c4f85c3d1f11ccc4b906ff980b0e2290a20628b1770ec1f18982120254ca562af672a3cb85b620c4b9e26fd28ddebd6fc10d599d3f0ab86e9be7046478e9094beb8098c47a6e925c28e9e5b68d1e7f75463a77248233beaccf87b03eeb7cd6ba5d67292f6ac5397895dfcf6862edb3a01439d9aa887a26b8e4a27914d6b9f4ee1ad1b7f41f86598aa3cf86012a4ba63ec7ea74564fa4c7da6a089d5c4816fe32b2c242b742e3abb06e75cc72adbd94b10f6a10583b4d893f3b1f846e309516bc2345aab768027b0b95da1d1ca2870aad7cf85e3b428903831781a07a0da256d61e8be06a6778b551cb68cba61b22dbc45fb28e7651bd39345d47cc601eebf9e9fa6fef5f731d3cab2e977b9d43680925bb53449f6159c22ff64dd28bbf013e95344d7a178f46c38f4a6861669feb9cff1be652b62ba85612f78cf5f05d989904d877fd3f77f0adef905596437119bcc55c069add11ecc5abdafaf07e25f8057dbd78bd8d5788b6afc83ca57196a247adca4d2db41e9937f85928c49586d35b1306bf5b669d0e45e91c364f54d1a6aa102d64b47352777e39a338d2319bb09669cb03aaf2923d83e38229e785bade538e0c7fa37570ce90a05dc48b6ad1726a7d202b248b920f7a177b2eb69ed6b84efa6f8a68aa0e1f50b7389735aac636fa86959ad8b30d8e60be1753356d961c0eb10ae9284a5ecbe73be33ecf4d811a211eafbc29a40ec9be9fb8c867f3780c402c43fa494ab389358646af972f5f87ee691f31bc79a84f1015ef01b8ac1a511c9490c1969bc91b891b520cbadeefc144c5f588038c24d7941db8aa012d537bc8435dc8b5bec09b0fcfa152a9764e2defe61a71133a80acbc2f1dcd5cf9a610519474a9128d123b9778932a7aac6821a4770a6b59f7d0280cf5516af0d0e501fcd97ac8f253bf32732e4c0904ee1bc64888d37d37f17c04ab42984ebcc448931f377a5047a3b0016b28fdc99b4bb03318baf70706849f11df0ef60ebcf170100e1af6e8826378da4b3a3c3f6a100be47731b2ab9d9ade27124357463fbcd4b4a7c0e109db21d37a2390ec4c1db469a00008af999410552757ad00f4f02d7bd91c5bff7202b978503b8145d627cc9cd51f79fea8709c0e4c8490fc1e519f89e060edb7e3490976f4ce0a61b92a806bf49a78d1a2592db609642e29d790053e1c2026ba348bf635caa3118d2d693b7710bc623aae45c5bfafe729da37310e0422a50e721005c37823b13a048dfb0ae65d64b860be123ee03459697ad1d42fcb359f16abf8dd2aeb1e7f4c560a88612859aa052e235d9fc194b2a3a3911f320ecf0db121f9b45498d88495db5606a6dfa04163491352d40969bc6ac0f68863fdd13da2dcf545f4def4194b5863918a7b9f87ca8042d848e13b0d51f2ec7f30dbb586bd0da9b9ec7f6c48ffb589194df72b34334023a1bc26a2dc822193531087bf3af0fe6ff774432490c94755ac10e27a2e906fea34d1350d2d3e31d914907c0bd1a39a49dc3e74752e0edabb10445fca57f75c9f0d03378ec690c8ed884e399bace45c038fd1eeb6d84756891c9a5a7d54d0772bd0ef9fc99b2b5a163ba0749eb281f398b3e3db5590e5d5c362de0285c4e1522a3a1971b13aa05a963e1af4dcf229ac8a3f640c27cb12c11e71c33bdfac786d0cee36124b969296869fb77915c46c0aabf5cbf05e0d24c48965b98956a0cf02c36e9462609541460e1253777bc20e06625d88ae64dcdebd39ce296bf499d533f3bb3ae781c67ff69cfb8088aeaddf61824d958b9df153bea0a765d65fb2536d0567f04f33b332b8ae92a585c952fa1315fab8b4f2b079ca3f44c752ac88782b5a050653858fcdaad2fe327faf4ec8feaccff326ad76c50a06e87bcaec8abc482867102ff8382ab13bee9186150b85f60cade31ea14464bb6cc54aa86f5256d863dbaa507a377d3748ab9fc0018f7a99bff0d952eb6c79a381e170a69c5bf747052cf34ebc1c4cb132d3d2fa0b28eb26225d20ea1d785600e71c3a3740bf688fdd1e9498f15d44673b16929732dfb82e70cf142d696b50499b7b897c035ed3d324a18bf88e1b46b5c438fc11dd05e2db4ee95c0f6d28f5b22aad4f1bf5feeffc516f8e6d6633d0103f2ecbfc5d3fe11ae884d5cc112446dda8d1ed820cf80e4630f8a68523108def3269669f05a3226c7dd1a2d0731f54685df7557d9302471b61b9529bb6c58e58cedfcfea1267b16383bfc8d031be1026d4af72ba76da338879e7b81ea1699f52c363199e699d33e40a5dc9e7cb750b89b46af23a4ac75cf11a9a849459296a4b543d3c56ee750ce008e9933095c88d3c883702802616ea7d498d8cffb8befff3ddc643a07563e86cbd7868cba73fe0468c81e569ed0d62d50b128a02da355a296833bcac46430176aea681f39035d0133b883b7aea03b4ad88436dbef458753c75fe317aeb6d04e349e4a29eaa36ee85212b969fad35ac0e14e4c84d9496621e603f743e8700bd99967ecb22bac930de4899bd6a72d03534149b1d4a970bc5a36cb12e791d1b668b8bee6b179de1a0db835cfc1ce4d0b78a68d48d17ae37011efe3f98e42aa8cae39019e9c2f3c894cfe01534571cc5e12272fc741082935ef34cf96eaf703b1b999c9da00a5f26ad565e8db3994f48a71fec7b3ea4315cb5a35f69f39c75590cdb2fc3129352c85a624f50c4775df076a3118bbc7352f50fc0f0abbd60c0778521768317a617c74d7fb0cbbc83dada45681973682893318650b507a14ebfa13953a741a3d52bf8641cddfd542908a3a8d780f9b07364c5ab2db33563edebf4552b945cefec1f26f4436c1d1487aecefefe1044660e211f7e8686789a7d1f0a35c44ba266b464ef6c3b54da154aa1c569d31427d0974be31700a8949168fddc771c50f26397729818fbbc9f31527cdcb17bea926141d445e7773968524f3801e0dc05de74bc20081feaf9dd46561448d282dc3ac477b8a75f05c027f315f4c1d9193415ed6d6cb4002e2226ba07156f7bd6a0e4e01eee5232abf21f16a19ff0e8fe8e6fae56752b762c2ae0082f8537b489b1e8ef7370d3129ed35f1265dc50266b1c7b8c1a391dc4cb69d5628cf8ca5da43682b23f0a569d2c03ebe9a59f914441eeface1811fe0e405da68bad9f44fadce12dcdc880c12b0d15e3338705fd3a2203940343288f4cc91c20f6d0ee4b44c6c75d6520a1d9e08a973e458103bb726db76ae1142ec7935b2accc7c5a024b53e009c6351aa4294c0305f45f1b4ed63f086c90b4e566fe89c2fe1d2006145341ba14fcdf2f7dabb56bd4223499455cd123acd23bd7011722050905d558c557201e0f8c7639511c0fb29df35449663fbcdf31f72182e45d2920ceb5548e0a10c8a8f09cde04005273fb451a30e8fefbd1943d4bd47f07bd0e809b7f00c2894dc1c39f1744a1249a69c58a7ec113b6911a014a4c769d4bed42f3d50c119e99cd024f87603bea07a90e6d328a8b3d452e2c8ce393b123397ed47da0b05015a568efe71b7b1528e7dd61ed1d57a35ec697df03f4bc42706a816fd4715c4514673a5d40d86fbb5e67322d6f0447514981d587baa6d165d30e25a3b5b6aaa5861c149cf74b63f300e033edef4f539fe24e8b2edbf38aa9183db42f655d1bee349be6382000d2dbfafda03d7662e648ea79853debb2734df17371a5b9b6ca1a47d8c70bcc4ae9a8aa1db3cb1f23827e2d63eb36523bc827b8aefabf92879b6b8ef2e42b7663d8c7d19ed0d535b2926d1358900cefd66a9b9aa93b454df69dc426365114328063b0fd9eddc377cb43980296d52561563c6d7b996949130b1c8ea7d68305fbb4eea1e60da3bf6b21f0e93dc09eed941d74472ee4a21617af190e095376e9de1737f6624e416b192f4af245a6c42d3164d5c7e9dc7887410b927f1e68aa35e89ad21e272c0b8b9d7d9dd0047f26486933cab9eaca84ca95cca2afd3641972ab4f5228f6c347eb5c00bd51d4e8d75ce2a3e83aed305cc1824656303e65ea0b91824ece5a53ce8ba3315dd1026018b196c4ac3af88611a85419ab1ef9cca1d1ac8c39d9fa731dd18fd2aea5b4d386b033d473e1092c324a23c23ea3fb9fb44db6107d23ff0d20d5eeef7d119078a114d92679636d05b932f48100c54d881051d69e05c046bf8e68f46b1ce43a2828bfe2e2b2ba56786b641136c0e012caef535b0c2f4d194c6fbd78243b61a6b1750d5d6087dd7219361cdc0b9b474edeee74327c0ca8f9a35fae0e3e0e1dc040a79ad00a757d06ee1833840305604980193872b9f5994d1655d9bba8550ac3a8464d41d0bd3d4207a780bb9d82b899940709865581bc8ff82f474c44cf613f2a4fe3648b1a061095dcc6d3e98aa601baca45e5f84702010e5c5c9a3af58ae295c5897e7cb55e474d422ff487f36cfd9ee698b7b9d2bc03b8cf1433a9a92236b8f00e6972a2bc3e65c982a0c2a6fa370f2b059d8c3bbab544debec723c85533c12876a7c698aa53cb9b0ff6d3d1d30410ce2d83eb8bca7f26b4c3b8f4059bfd546965374547ac13bc95d557c7427762b1c936299891a986298cbf733a490c0adf619cee07aa26fd040cf5b623000bce17c055f063cdeeab2a63e51991634ff37b4123981c5753b147d458bc4e17b16b4122eb41cf999d38bc6b377600263b8c252d1b221ca7ad4f6b5bff02b84cb2daf00b1dc4005f4402997a60cf943050df123a6e05416222b6671a33009c687018019ce148a74d14709dde6260ecd0e4a4d6a29f18017d75de465b8d219ee805a7cbcae8b706648d1425d6e892fd24e289040742615b594028c16c6635bcca53ae294c7a8fce8ac024bb9bec485e62f64a4d11bac27207f39ac366b69f776f927f1874be393e5c8a97522e357497ed394a7f29f281d5548b6c51ec02820afd46ae226416c6d2ceb1b56ca6ea1bffcff3df2876fc719dbd1f7ccdc35ba4e9352ce509f06d24a5806e3ae685b74bd7014124573ef3f56d3983c5471bbceef4ebef5a8d091673dbf5861de48ba6427d2aa435878b6054d5f15468b663fd5a86459aeb20df7ffe200c3b18995fcd4e8ef69e0d01cf5a93c522c3237258399dcc674c08387597c8b9a4f3ef61b38ad29c63cd2c4e08eabba696adf44e6ceec643123eb0c81550b065b8dcd2443cfaa7d8d1bec54a63de7816c54f8258bc66ec4cfc714dfe49fd68dbb698fb73b2f2d3ddaf4d568501ea64deda312680c5afb778ac2b9616bf030b91097deb3525f78a5254f0d86d3ff1650be2023486b349c973538c285e75bdbf47623ead2c8c60b2576eb4cc5aa65b90c30c05aa61b5c7529a18e42140effcec8d54c174b92cb73b79b89242253314b3cdb33e7ffa9f4ba1717a5152e1df3305e6304e71ac93f84b952e87de858aa803b4a03468265c99bccd115e6f9cfec909518e9c620d5fde745ad2bf9a8b8e8543eef9964aae9c16f6f9dd8f1b772cfcc4433ccd3389e7a7962c39b0ca14dc8a0134e96abd7d44f78de3e2c0e087cfcbb57d159947dcd6e033de72a05e8808bc674e09eae7c22391be23b00c0324dcbcd3f27a339933e78ba3dae39422f9d649024266df8619010ecf3161ff78d15fbf4e020fb0129840a61649acf5e0d285b988cf91aea58a87e579e294f33dfe4b5841c7ba5f9c46d034a586564f1a59ff2e77508e3fba915a388249666e0f79cf2f73e1c163bc0b8942e1f91d8802f7584393da4a298eac2a4e7511a0fd87e9c1c41b4960a4baecf25a269b41f70abb49ccb6cf334d32a6f60e8ce384176a62f2680ebbcf632ecde2bbb69a0d3fe64641c4d83181e389dd9074e09b8fe1e1e995d58615e4fbaaff9b13c8bfd202fa8e63b989bb461a52a850d656c076aa094448aff85922dcd69b752c5b387f9c0f885770d674bb102f4d58ae2b64299a171b31f660e5bed4bd87baa6fb9b59f90c4bd5ad1416b5a3845e14a484108318445a07ee02fc6cf1c974365455a7fa0d5376dff20080260793bffef8d6e37e86ef1063bd2208f11e2377e2a3550063223a0ba022f27ec9240a6a0cd4ec6fab17fdcc9816eefdb51e7a69e4725cc8071269c1bdcc91bc1266c7849c53ffd7bdf3201158fdaaa735a03e9e961a2eff0fa836685d614cf526081d1b21795457982cc4e66cc908e59d1b5eb56fcb55ef47782aca3273760de017893f0ca076890de634e41832cfb0dc453c753fc6e5ade3919b8045044dce87f3aec5a2c6b44e8aabb8a4b5965fb337ff31d86328dc146bfc924e52f5f49f4b2138e2e71b5fab6c80d1ed584dbebc0d299ef3211995e21f28d725d740f0a602eeea32901ae55340aa82a5ee41f452d4b3dfa6f4b3e6c4d60b12b5752810e44a51fba0ba8d4bf273dd81ee6c4154a59ae8020bf69f41dba6c4ced97560c64f41f5f4a5ab6c1503dc64d6b367673033ade840eebe2864217c77f8688e96f51f1267ef1188cd37755f8d8f7aacdb5143b5fddee8cade0f3fe2984fe","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
