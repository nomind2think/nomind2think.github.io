<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df6e2d7fa7f60bf6951f961634e4da2905f1152623fbe3c4e6b8665e8b1d6c84870541946712cd6fcddb0d55a38ca19882790c9beddbc61bdba7bc8c662147a56767aa3fef6512cf40a861cee3aaf8722a89afe51682df8f14df3c69c735de881648fe6842c502c4c0320fc844bd7bf03bff405cdaca72bea121533c5690e0ed7c3e9d2bb41d0e094bde1f99a31c47827f20d0ed334e976ddc6ae8d5a23fac2b8bbf86807ed682c5a4db4b2c03e7cd3dab16efefd70d0c5e180de15588ff56b9307f5536e2150ff7477d58b6616ee14dacd1e078f06c60d4b587752e7ada72127c8de78275635a6f6f7a0c8371d776298c298aa811d204557f08012b0db7845984dac384dd4c8047413713aacdae0c16575cf3f0ad5938950a0eb894a6c5232a2d15f9e8c87b8e1e12dac4322c82c3179eaa3f3970ce3b4a4a8f8cfcfa2690b7d8a230455ed24bcf533c427794674f4a7ec6407b71cae98b100c56e7dcbeb44a43015382cf2895f1ffdc6d480f54f245ca973bcdc6c57f6e54ba2292f89717ac4f89c2175e44470fbfccbb0002e6b6a17a6dd8e9418904fd5f0aa0de8030aceb5e2a10518605c7dd1674fa3c126fe5fb1d777dd292939066b67a5af183bc341f8dd8b034aa3193166b5a69378f750a02a29c6a5f21da63609e34aa9e2cb9901bded22191a5decedaaaaed92a8409fbe59cf57962ce1186210966a58463d5f7e89ff882efec3fbc2aa2a549100da8ec64cfaf24fff5b614789e4ecaf0e93c8c4aabaf5ab5a7205bf6a762511a359a00c5f0ea045704bd14f16d3d503a329fc412c9b0872156de33468e2043ff1e65aa34d3dc542fdd015437a6683496b5db3acd7877963cd45e9f32d76e0d04db719ec164a04c6441122c62d6a83cf8b3ffd5666f15c4b42b8c43bbb45c39db08dc1a5b53ef845555a333681cf6febf46b87337728b883dd6ffb935724602c0e983b764498dc837cc513d343ce77354b2f42259d65abf50028679d9830422f67a1ed7ed75d777abe7902cd358f9e1a0f0035a5147329abf3c387333791d647c8e271da333fadb81f5246fcda4812eb678561c990df940a25ee02913ab9f38781ab1cee419350547173d998465f070196eead47fba422f377d49c3909fe1e1743f3c3f3a613eddcb2332fd90b3883cc6b942d8d723bf48e861761fb0409d563de59682185798a984ea622015f8f6988a6a7bbb02a27496702e7f8ef2ec8c6e59a49144264faf62b5ffe6bc5ac9a11b9e0841946a7f5c70a3f06be9dd19f3e8deef5c58b5f8b50161c6ba11fc387634206fda6bf15f8271ca5b58434cd91a57f86d980f95dbdab5a65075758914a3f58e10ac5499f7716e5c645bc97e3501ef2b40656ad3d7571aa61acc39c7a094dda1e030f562e74f92830c0f87d880ab1ec2b549eaa54f578c31031cbe0a4c9c0065b61c2afb328cad2492d34a2a253a897bbb5e5a0b8d469de92cd008eda025cf583c3556e1e80dc9ec6a730f94319c01b39cc60cb5306f44adf5227e4a10da9900a3360249f86c8564c2f475f1b36054b6f8cb0af4181a0e90595eb0195eb351f9a504ea9a76f2e426751d019e764d9e0b9843403aff479f903c0c60e4cfff6506cfeef190081bed2bd86e05fe789480ef88d7f8897beaaceb56a43c94aa16016469c4578a5f93d8ea881de6f1cd9677aedaa93068826d2d27564c955da6a40f703c127dc4df4724bf647662c198bf828b69ab5f9469b64597fccc2d2641d0fdcd9206582f53365ef70cd3cc0b82766eab6d0f40131e631bd2d100409d4f78f1348edaa11c91ff6eac679d4b2dcf3aedce16b41e547bb221e1bb607463b9dbdc52cbe5213e1d525ab83f44e51437cf892a700cb012d3a2d87a24114770640ebb4451b8ff191bac2a87abaeb4e37cfbc4bd2d854bfab483befb2d7ed3b5140289f8d8360a39d370226b24bc2ab1cf2f7ebfca2f776935b20962a4277f4ab1801c3dcc680472d039bba207da85351ae7818e4c1ac4d4ef0221ba006b060230a6c16a24536938e88b1c959d51166bce28ad47b250ef595eede9fd64d99b3aba45c11c26cbcd5404123b1cbd5155cfa75e130352205895a676c4f536f758f9bb8e7aee4da7f1079f7fdc448f0e1f0ad3e70e369cecb12d07c0d7e3842299f8e112901e07698e429b12e1fe4a10441086f59a7b4f646fa7ec47f1cfe21b92ac58110aa81004f1a7898910645abf24e6f4749c03391084c0c3fa1141bdaa2c9985df56991c2d1026a5cc7ee0d4e0889645f026bee7426e21e70c00f90d6ff7996245b0095d242668f55b305c21e4780fc5ec611ac6cd1e5979ae70fd8a7ebbdb197fd201f36b2993fe2f87beab1a8ba467201de67a8e42dd4e1898f356568b2b9521824697a9b3964158a932ec291e2d4668b530b1dd7fbe0036287c94bc92f56a21c46e18e54c4b2a129cd4398a20980eb193073b0f23451f261c5d0c471b320ae1f6ea12ac59c2700747c5c69b5c9774a58fca8dbf0e5d475d72ee113a834711cce66ef6a2edb069688fb5ba6942fa852a00b3bdbcf46f88154395c603167b2965f72eefe209086898a760e5ebca8409bfce4788057d92805bd3de28e9034180c1ab7170cc56ed5b5ca65d05cc0c048bd262991bea7f04ee92f7e86bed8485f2aaa44eef483000be2933d5ce93c5f8422bb33b43db967b7f82f96a494797fccbe0a35c821f507e7064aaedc644d68b3e7f5bb007af7227787c87631f1674f2046aa559e0b3d945b1042072cd3108291f55d08d2dc061fc4cc4a637de5c5e0161ee4c201d956a0336aa99362976d82f8a0f87faa8895a1db7a2d6dd531534bc592efd4389782919f7afd7f3cf944b13d5d80cf395cb5eb693b08ca9b2f2575e006d52f4a1d8a73272362af08f1bef9b283db78920d7d0d2ad6def240bcd48d230fa9e3951bd541ea49f5821998a616625953c08328c8e125cd259426688f736e321019bf41b1377e254a284c4396d65282b5438b804859374ef4c734b30d077fb64e4c917c6bd1c514a81d15d89e7ba305c8e9cb50f4705211a1351f618ff871b0d543d3dae7f2a5d864cc3b648412c449361cebca116a2572172dcb9decb0b74892bd1a8ca8665612efbf0dfffb4473318c7bc26f05398645b516a7c1390b0750168946c06f25dd7530742b59fa719c0407c6eed6576540362e048b25d490d222d00a3ae74334e172d3f9ce7ddd686283e9232d324aa27ffd185f1642421eaacbb854367de58a2f08ccef33160b2631a6fa931f4d246aedd5f7a4022f3cb60785c1d73102e1317e240e7736422f318acb1ecb9e4b8ea82beaf8bfcfda45f01b69010f4083db65a9edf79ba6e5c5095512c2cba54e96e477f41fb1fb6174bc297a84e4293ebf5b95cd0c1558f35c7f7bb2d1702bee6ede518d66a57c9071f66bb1f157e809015e81f393178fa698cf13bf04290ad0825975c90372ddfb0387719dec956bf728e4893a3f0c80f2233db881454ba8a9eb4df6f95346e02d2067de954bfd48b14c27f6bc48007694c201a71ca857092c857a88664ad5490edebba3402ff1a828de8ad8299f130df1f520bc940df4682664034c06c9d2a6467caf43e5867e3ecdb05c09498c5bfafefdeefa7cf4ff4194f4298ede60f61d34c9c0dc4302f30d5c60f16ddfd7997ee8e0274c9fcf3ed61ec63ef4223c77d96deaf8ede24663372409005c0bdaf257b061223c240462f00b4f81705c72aa66003295b771adbbdfc8fcd7462555589b3f31047510e275b2aa0db5d56314a460dc5b280596d017354e4d157eae96dd201d62492e4c0a71ee01e1ba084c5c04f0e1e05f84fafb3b71b8876c70c8266e5d0e0763fc6d60c33a3a90a473c026e03b7dc437c5346233786ca5563a2d98da2c3031f7811adc8a0091ee62e046622491db476e6484742ec6261c3fd71641677d7ebb9fee5442f7657f8c68763a8d89661d5c9b3e8fcd881fed6565df0fd6d4f106dd42875e88bb096cc6117e080083afdd3ad8759b0b04cd17e841c119a306a107cae5193a7c799fe70981eb1dd18f10f05072c4c75e180eadce871036e07631ab0c27d68959abc3479114993d9058e3957f6d0c1ce3ee58a538e76a6c06477285648228d2280b718fe4305d005349e332ea22d1355d70659f0c3352d5ac6f4f639a728066dde130f5b99c8389ed05b16a7131eae7eb42bc0389a456020799f9672f7be4fbb7e284efb11ec009802af63ecee14e093ad4fef780dc8651a710e4874bf53ac76066fb590358b7b2e60bcac2813aca674a683863e1180c5114b8972bd069f60e728dd0c70d36df2d1e9d2cb64b4e81764c6a1d40943279a0d09c832d08915cc49114936146a75cb1935351544af2faa42e277d1b31461f0a3cb981eb7a5794f0a1d783dde4c2e1e2444d13060bb90c643377918a4dee2862eee404e90f509fc502484a089b31bc5074025303525889c1326d7c72303d3b995c47007ef99880fc7f297c8b0be3edcd31e168c2123d0b0f248989f24f0ef0f01a2e791046949e028335621993a9487a0e73826f0c5a5fe350db4cf30e8c6b835ae1a8041d9cb1bf24605c07dbefbe7ddaccad6573247aa4cbeba38b27f13a8d0eb5a770a9606b9f1e3da56c824cb4be6ba5362dd7e0dbe36ff58b530b9c9390bae5c8d562cbb30e617be1db9f82add53dd8d53ec15a8d937a0b8452a37160071ff597e17e164ea1ec2e245172d26432d97b445cf8f50f5f89ce4f4026b7a84df8a8222b8ffff1ba1d98e1790d56677dc6179d6f87ce08d0103c5d70afb088723f1b0c9e66f95b7ed8778d00a9c04f3e092cc8c2cd9996cd500450ca559b58da2abafc746916d26d6e534461b0fdfe3660e3523dd670559e8a7456327a8b3132d6c7f5b991905790ba47aa1ac14320fe7dc8aaf9907c458cd215b3118eee2c77695e5ef3d5930be0872df2c19b8f83d5d80047bc9c157391793d8d9e06383fd5c16bd7f21e3d150c60bf499ee81a336be847e0c649b87d61d156c180a593b162ed2c31e2c610cc4acbb58a1065289677a4ae7bc3bdcefd8f0ad2e778a7f4d591fc6c3b961f55d5acca68d751219063022a4bcc02cee5bf2e57dde496e8c6a19df18fac7b51d21e021ffa81df5334df6a378367b14a5c00c8f71900d4fd96bff90ced8aafa428c669edba797294cc24344cb444fe10a608e91dc58a3895075880044ecf7d64da2f294ccd946a8aedfaa78f7c6c520ebc616d37f55ed7c560ab3d17ea48a828f4a1882bd3e6287417afe5dfa68fe834b08a3a49c068284d1e0b8acdad189cead6557c1f6b7d26ec607537789f96f58bc8e649a504f46f42abe0193aee797aff61896b15f5470979ed4f803ec8d4c744e8fa60014472fe3b50c5026302f63971a4cb62e3c5809e4316f174c30880c01793e63a0db5223a97036a12d61663e086d7e9f616c9cc1cb4918143bf7bdb04d47beea42adb46f6f4736d82e0ed36c3b6bf96dc4233b1dbb091a203a3575061b827ae6ba9e9778a912b5f60c77320884d22e1513b64a4145ec3fea5c16f0e29b1ab222d018fff4bfb5a0a78689e3f5f1aceb41bf4e467f25f4f711d163d1eb2af6028d10d5597cd02bfc109d2bf18ecc464433ac350f9e904a79347b7cb00d43104edf83f9f41e15b21ecaa3fb880773334eef1fd1c0121e2045778718afd9656b3b0c557a8669e8e1a76287b2a0aaabd9c5aab908cfd276cc670fe397dc08c32148b6b1ebc2eb7878e233a730726d3ac348269eaea6e1da484ce7b5852ac9ec7974cb064de69976853eee6b0f28fec07ebbdf012e49d1d72f57010c0b881b1d2f941f832f2aea9c01e3be657f4f3ba8ffddbc853abe9e836d90cffb0dc94e37fb300a42661a2f438942598b8be4aa24e47177b4b5978e65edd3b65cd078356b54f63417cf3a733ecc4f9b0ca4c77a439fecf49c74c00fd60a1e72cb1e281c2dc3254705ebba86f8e4a1ffb15f1bac1851ae38b92c89b50fe46b339b1ff2437adaccb5fe644d652271211359424aaa181e83619f8959d784a2725c8eaa58de2d1a55f064b93e3925b1eaceaac508610371bbb99fba4bd8df688e6cf860fcba9c638b5292bc3c5e80ee03308ac78b5dc27606cb25ca9e354284afcd84c27e3bca014d8b7d6ee402986527d5fbdaa4652cc7c267d2ef59a36ce73e900e37245561c262c9534335a80e248506916a73a1caa827801f9acfc0df7c27f3ab97e230666e4079b2c7717b84cf268530abfc6d6d5d0786784d9c42a6f49748435375841d1e57289334d881f41ea1b869d009d9b9b7d940dd33f143a8e1bc9007454c448ae237f9677e42024ce8a5054f4eed6542627d5e6977298e04d6a469b7cf01b0a8d229c443618764accc62a93fd92bc7fe727020578ef2bcc181c9c3884b4041001961753127caa2c1b0ee011688ab9ad7f0fb6448612cce59e1cb6528a652364e18b9633608f0ef3dcdd7f611e24d2717d261dbf674bed3c3acd4267b2b965ec57c2a8d1338f54d92325e732c5eebfc78341e8bc070b95a5837b7138ce39ecfb98c9634dfe873df328cf0f7c8919596f51cf19b2e15c4b4a82ace750529f0dd36b973e10c11c0f335ee29cb19e0cf33fca1fbf9ee2d831b3a8f70e9f48cca722c811e3a09ad58a8c2b75256eeb49ef4ef4f39bf235d921b00867aed32c0b6fcd91a2824cf13eb0463e749ccc6dda7f84bd77c645ec5b874d395e1d7f4cf97875920b26ecda044111ce070d5ad6049578b8c2000b974870046d989dc702000c691174f56f5e9e26bb36cf1c772e295133e3194535c83f851225e98c8f6962fa71f012544aaa0d0164b7f0c346052e01f6d8da9118f84b80dd9abfe48df1f161a2d261555e43016e0f7af8a7ac935629b7e17965b6b64b2654123f3aafa97fb266447ed234c8a6f929fe88b92a3f3afc3a6f8c05de924dcb11c1e174e6864cbe5ba5eb1cb05d45c193201c9a53a8460a533f4503cd8b02b3a393cd8dba2a665f4e1e5d280ed6f6f8864f39f6cf539da2f5774d0c3640bf556966ed2dd08d5b91f81799cace48eae0936cda12a99ab6e55e15a0dbd8b26863f90c5770296f2b09cb67d2147385dc2f35f73b49a0f60af3f8cc1c644f8cb438c98728e0f6c31dade6c14265a1946deeaa58d6eaed8f7adac3f0d36f2f70dcd1c3e60bbd478b10bfca8a8be76214b1452ed31c2f336727ea0e31f024390bc811cb85b7dc0e48b3ea90afc4462d529548a5d14a5156ec98f98dca91089986901e6ee0040f437baecd5b951ba417f6997a47649d75b4772fb08b92ff6eb6f9f11620b9f9982d07bc885f812b7cadddb2a67b81222e06589cd34fda1309b6faff25e4f209d601250dbc53c11873b74f1b2d7e6d4a6dcb67a17823755346e23835bf173670433e417fd3eb282066a9b18793a928df3208e19fc0f700e48c3ad31893b365beb11e0b4287d33c240d33976d188f71f625740f2c52fc602b7af11281486255da773fcf32afd4a11a1298ab10b56a70f84b170dae210592c82eaf427c67e828cf7eeca807c1c199dce30cc136a495dd255a36a32dae3f99dd87d49f996a68ef3e29f595411a875964100575374b39d3f213bc4cb270c813cac91c67298602b7e9450fe7086f2620a854a391f7ed47b21a5a35bda0969c02848d5fc9d9fcd7cff4ae02d506d1b87fddabf2ebb386943dab01b3208fcfb3f09eea4fd003e270e21ed340cdfb9b08a89e88180bfd9504d4bf50de4e2445b29210905006dc64f5b15a80848387d042926a5d9905c2e84d9e36cbeb632d33562ba3120559ee228f0b249cae1d243439c187507591b237187874fa2b8164bd1f8ff013e8e094795173743bc17990ac25e8d280bd76a7847e20dd836945d489d897f47fada06507d5cfdf59c2d6e8c31e470dd48734af863b15195106aa21a606a55949316eaf75664b14cbe5aa95433ddaf047a16f55736e70c887a8bb064809e998fb4ebca1069a2f1a64724d5c30e60b3ebca4b0febc398fababbd63d9e7dde2d950f900d0dff384d44510a6049dc46eb4f420f7247839bb56902fd5e806f922719de38386342a2c4ce60244d374232972a04f813401a1a06cab51af76de4eae6e5983c76c7695054f7f8c0cbac7f7aac983f0cd951fe2fe21b51b1a11fc4645ab5b5bdd3a3c4db657106ec6cdb9bbf4faf0b005491225f18f8d956c9c40af27d0cbff2ed538b90b3d1e2c3b3975eacd0ac0c3817aa6ea09555f191cfe9f4a7df02996fd4a2a021555aec8b0715105ff4b2e1059ccddd0378a758d49f9c291ab61d8572b225aa7df84d06cea643347a8973c787f118be9d8886e3cfcff6e9e44d2d6552a0cf22c1b63901d219e7cde659814b2d9b473d1bd30b51ae2bb7f7398cfb1550f27166eb6991101cce9126edd35359b251be98c4c6e68ccd845b28f4793e32fd60c1e3ab7bd7431f42beeb7fa51e22c47ee2e8ce86971ec2769299b4223007861857c3c9bf8f55d33e0810a16b829de6fb64e1264b80de9471819ef616ded1a0c2a59b3882fab49fda25b75d2f3d766489f2841217dbd4f3bc50c68233161c075b65c9bb8c96da184bb8025d64622450ac02f7e46aad15372ede2a824ad471c15a7edf07cb0550eb935b5e2184a9c7360aee99e83290f29e7d8d79deca0b5da4821847d7c763f047838020971982612656a8e70c5cbfa41ef36b97321b8edee72ee6708c99bda25a750cec206f1083d4f914fce059e5099f7dca690c82dd623842aeab656ee65315bb42c8d6006d07be2cc4cd6fa7191bcde571ad8c695ec191740cea33a72331d3e714130bcd17e77c665088dd1a8a768ebd362bb531339099b177ab81101c8da0b7b11d4846d6def4c51668ca995f0ead583da71480d80f03bc3a0738e65ce0d2fd0c4a91c10ba84bd7383ba8c6cb4e180ea856aed6f49369ebe533a929c3d2885989d5297a841639315c94e99ad871e652b614617afd6208ca043a1ce756c6d1d2d843fd33d03eb597b7d700938c81b23eb20e5ba86c0cf9c6d6215a8b170b560dc1cbd77b734f686026a91cdbb7fd7af34c824e6fc7b77b5198262bd302cbcdcbc276ef70ab4566f571ed965d7775288c874950a0f821638c045e4b939d95584c10d852ac0432f64f637d5302a30e2c38377df55ac99d16932e8af7d2a0e2897a538dd2db15e19d80c8836b805ccc4001ffc7f1bb1377b5728abc00000777470768f5664069d1c6286166e8f9483497761afb552f598f92bf8822f841c97662abd9e18d5c35e3a1b357e17569a583df9e09aff955aa939a35234b1e66eed15f136f666d4f6e2e6067efc75729a799ba9a93daa5af2dfd0582e84e8f97018a36b3f14183af671b79ed5d673fa0540f995cda5c5dbe196111adb431dbb5ae9af0b810cc37d5dd9ecfea46ce435ead381a76db46047df88e9a0c91d40d8af572689600f77f4953621bb1757b26a1d44ebba25e968ed376c383280a601894b60d2cfb7cf99e27894b3af66ef18a49d38ff60a63fd59591eead0b2dd5cfe69441c0145395a15b07b5879b813eae21d933e7df87849e05a5772d51005f057669f92dc17061540ee302c5c4e69ec793eae808a1f75dc8c7098be08eb24dc2eabcba293ca9802445217acd25713a184fe93aea4f7b1f5fa7b256fbd744ae972c21432478981e8b4380d93603e655f54cddf364ff24a3b51c2ac792fe19895b0004fde450c4e5785504a2bb4d69504786cf8ff9584c4949f6069d1661e0074d742ef283d7effefae67871a1d3a0e97ca324fa43ff92a0d5890f02dc5f8e3ad0b14e64dcba9f878d15a7bc8b178c2ab29246393748e7a754ffa031332a269ab8f4bb48e0514b5271d7abbeb8cfa53d303d4902b11bd8ef58287a96ca6f0788bd66ef4a1ef38359204ef39100e3d68f27a4bb1ca8f889041c2332462fff17ded68721f2bc27a4fce75b142f5ac2ceb23dac1782d8953bcf9208853a84adfd9cd7c091406ee2c5385a62489b40ca5e7e114f9e084827304f6cb840a29f8cc7335418774e7935a506e488b40d1a855b3f0f574c1187273077e0eefe07b4df2e895a3c58eea27186fbcf0fcab242f7b034a11234e3723e79589c515efc53cbdb1f4ca7881d4f49925bad124dcda2db0b94669190b4a0a81e1a0a1c1df25e8636e5b02395624a2cb483ff5eae4b391f891ed1a0cde8457dbe7273e51d0d1a1ee55fecc094edce895a13e55aac54bfeec303142955493ec9ed8bdd1165787132288ed1941935b748e3f1a1df4e5c9b34335d480581789b2493097bf027d21c727e1fa352b3d4a508c063ef445b62ee5d45eb5eeeeb8e29c8c1dcae262adb571111528806bca60c7f63975b4b3c79e8ffd2762d95942c9b0053ff34b29743b677f3879d3a0aca746b3c137be4acc8ded707a737892f6db7c99e74437ab83dd1334b9a4f043d741420278c66cf83760ca0b40039a2288409a01aef1004f1aa0e24c8e1f4464312c53170dd34126a083b3d10bf12b3bda456453c6c11df4bc1638852e80ac37083557b51b21a59ceb784bd2f526dd6326e1c4db0d901965ddeefd126d26e47900e0980349ab885993fe424ab563249d742e8a737a1f80416990d7c5221f1c3e9cad8034f12325e0ea29c2e3fbf0cacd859e6baeee9f9a99dc710bc02cd2b4de58b94748de86467af407392ff73407d0881abe71562deaef91880d95b7b5ab61781c6474c4c19e32e80fd5f7d3e4aab5d84447ff6a01aa1b89c1c42eb1180e6c9e78c4ce57d4975f159d4ed3ccaeabb9311b451ad13d9ce8c686488b25cce2ede1183531cd6eed33f7d6ba44e53b4529231c2f4636bb7e446453a6f9e0e8631cc8d481d33843f6bbc423c87a5ecabeb47ac6f607ea82dc4c40dfcf34e424b02d0fb6d221160b29c6133f5f9cce6e4bda89f874c4b8c3220191194df5da6d369a28b43d43470a43a83d54f8ed96c90dcc0d8bb92ce90cd5aed0b98cf84014af8230895ef211b8b9569f8cd885414890e35e0aceeedfa29664fba9c68ba449bff61b11d8ce5e82921756510bdb49eae55fa75f4d6e7f8f6bfb29b85b329694e8876fa5b7f207df37f70e0b0750f56058491679be737cb654a42c2ee2015de008a52081c35463a04f4e786b9e3c838ce0fabd8557aced113e6d849c4e2d2fc5aa59395cfdc019ec467a421063b59bd7f1b45c35811fa3d5f24a6b2fa1522bc976e7f4ef890d9cbddef2587440cf9f0905a63c97a2944281278b498833861686180ec46da04746b050c1a033e989bf5adbc37962ed37f30ad4467f7e8a820821bd31de32a6e792080ea2d791538a8a39fb51d5603bffc0aaeebc7431f929dc061d5e6eaeb03eead515009f15080e30b544acf8d17d8281e0d1d9701adcdd9ec326539557cd19688128752fb79b59b5d985ad158b16aeeac261078365a7ec31a0caa999e928946869042f75bb360827f36fdccc816c380a13bf5a6a7d06c1be10ef2a65f844016932545c561c2ecfa16dbd15926a310513e1f28bc33cc0ce1db3ccb76b758c805d159a29289b36f68962300bff9daad190314225aa51ed04c9d198e3ca02f652db795e0cf5533148b531fb805e49498d22a1419f164fee8067c5b4dafce8ffc491d7f5a14db381ab5272d95ff88c6bb4c1964b24d393e35a2d348455f80a0a7e15575992e17042b79f3032863cbfc9e5ea2ba37900d7a98d36baa03d36ea4e804ae9ca51adadf5a3743b21e24f21f76558bb98762903f072d12e5ef51e932825b3d2546f75293cba279301c0577f59d4a6bee427f5ec0bddfeac9d4643e8da6d9a26653e2da77f27a8080fc1f3198d27e486b4b3cece76459c5efae001c1abc110643d67933af48ad50d0ec9e395dac16dfd3e5c40b13730938f556007a6ee21a71c6d3beb2d7dfbfb624b0f03c000a6bf7762e9f58b706345f6e267019094f95c1fd8a01f0263a8d97ac65f15bcade7593854d7e2fe8b5381129768588e0b88765d47481c141c77726746671a5522efe815aeb6cdd13a0eb8c5f89f04ec0eccb2992bb17aed216d9ccf9376d743f2070f4e3de69a0f363638bdf3aa728bebdcc59fc3c5d8a150c0ed3d572cb839dc6cee1b34115981cd543f471a399f762c55a7a51c9f4c70169dccc7b5365b100d2e84dbf4590991560a53f86794f7f2b7efc865d0a14a508959d60bf72dbbedcf02abad95a9dc74261945949832122f4de88c1c7a497325393c4847b035d9231493da2c07276e141fb98f97cd9e57fc841d21ab308a4a67d08f73e1619b16f4cb8ea2cf4b7304075c0dc3f4e38f63bba7a662dec435cb6064484a9947d451a1451f070097c85ba206b96993f41401992f8d61fd2e7dbe119838a6090a914197593ef8bdc4f58b6d825dcd167423aef2906a900f2bcf5c4885889a62889de8bb1b538b370d1e9e86c313053beddc5b3f775ad899c4e709ee9bc677f4195d6c231bb964f6cd042559d8c138093667729c2e98976d24b7abbda12eef72cae8af438669b24e4246b29a209a0ddc310da57115ac47108c6305caa4955c11baa2adc7adbe9cfeb64b10bf4ca100704da960ab1794809f862df7fe45067aabcc56a9047a11b4f8e7f702358ea0487b06072b1cecdd8c1059c5f9fe417fd97a059776e3e295ea9297b94c365f80c112621f9ce2159b7be28f0473f4d3bc2033f214c5aab0b83919d3e4840bedf5b392229e4cfde776deebabfc6bf25d157c535d4a8fcf98a5de8e7b78846205985f694cb86d259fdd5a0dbbbbc62c3b9a3785b6857047c870619fb59f3159041fa8a4b14451d47ab7782669637a333d13c0c8d16856ccf38d992fd96612ffc390c087997e9fbde16b0d27078af791bc81cc268b0a26c0b7533ee3c60225e551268ab2ff05ae2634a35fdb49edaeea13dcf3373ae86db91a325e38dd7176b35d4ca110ea31e5979cd16705aa17220b13c9fd64c0c840430c418cf1d0843bdfc421333ff5da622d0c638f300600625cf245c6f87a602d6d8fe154e52f66ef1968671033496c0a5d175e32b91b7183b59064239564ff7a0a828ee5747b8d028d2c7a9704aefd1a22bc5e551251d0920b5962d71d8d1f7b49779e66aab53709eb15bfa587a0b60332115ec5898ace930ac6e566638d019c71586c25b2b625aff49b206fa7ee49db18e5a611d0b7326c57cc44cb39d014928b20caf0b38398adc02f327d56db770de04b7d5cc74190beba6c3fca7a91e58b5b8145907ddc1c06e368caa5a4c63e1ea4df82557802150fc8f2fcf82696cb1aceb02fcea742bb93f0c174b5a9e0713aa90c4737c81d6dabb7e1c36115f307da9bb8bf68c6a03b1b53430a525a304a2e836a556366432680ac5665182811866caf21e8b7acf44b952efd8a97f008911101b713849229240abb2acc46a93960ee3f5d4c56c521c66f6beba8b15c5126e2f4f7c75495cfdce1df97535b82cab58bdd73657ff3a5081cb6f9669c9b779af3ca15e86b6c3e45fb66bf5ea172999953640cb11391776ebd7008345b0b20ef3494d40d6c39c29acba878145eba3ff40c03327e47ca91c95a9578843d5f7b47802e3b08984a2044e66ed8e4da2386a84df451b2c5936893398e79310ca80ad4655b3e4efaf988173b34b919883a4dd5537ef2b8fdfa1b3edbd2425fc2b1a72fb1d1f45f6742a30a66e1846b250f998b941175d37f940af70d196fb1f05f3c36b5bed75c67839f643e56baf6043b81492edac0b615116951a6dfb448eccf210bbcb39d6639a6cc2fedd8251db8c109a898ada4ad38777b6fd9046a7a7a18da4cd8487b7571f7a68d898462f9f799593aa62de003e06292d1425ec00cfd0238eed7679f690d19eaff0607bd5e394b84225d903c795ee9574511bea11bfe2955643e98a33587c1b66928997f64b85271dd528bbc5f3513d63a22728278c8a12ec128b43ff4f9c116d3c14c128de79eb72cbb0e28db7a426b5d08f89ceb7e4acb0482ab1ac545740deb25a2abb705b3cf43ac7ac862834622e4d1f4b862a5d5d52b41c69c395f278b1e29db34e19e83e44ee74c79dbc8f4321f7f9722c38287d8c97c58a200f8350c2c2de9d9776b8aabccab515f262a89a3f1387a8e2ebd4ede3a47381055de07c2105f29cdca07bfca630091374f382fa1b0e4c9aa8b21ecb1ad995f680e18ec3bf9be413da9ee69b73d9da1b8e4c6ede86892791f41baa5b42ffe6f40927af8bf7ffebdc1306ec2220c386e157b8c0aff84e87687bb88d5df8b427c1173b3c95779b27dc4a6348a6d4df4620cf80c382907efad17e2190b87db7de18802769f0dbae718f9c0b333c1b8c040f93750c64be03c44d6fe05a8ba62f11dc0855fe87d1d8ce43751473a70efac81c1f6bbd6053b47db2ddf0c3f71ba7d766f5e97707578ef3184cc6279b9ec87eb5624a57dca2957d7a27a7fa2876777dc42fbafcad4ca23d4d30535d17c25e10eecae13e0c53efb2a618c80eaa3e17867e68104bacb7c56e83f76a11e2bbc5962a677a45b9b4dd5195c8a62ead6c63febb34fd2f0e3520e5e4af5ac3a81beb43a649dc856aebbcd13bd3b581bca25f9cb1b6c17e23ff8dd27311d063754b8d1ecc738a388319195ba05d2f2d3d3cc1d6f2b49554ea4253b413981cc9c62c89059b6a45409a000576549965d575e8e4cf0da6a3c0426675b4b1586e7d9c4c47d15e04131976f5f1ac0829117649d101e3224c08f09e8fec5b957ead07bec0636a1384a7ee227908e4649d7496ee22cc4c823fcd41c3657dcf8067349f4301194545173a021a2662f55efdf209fa22176e6e0841dc4aa6b78ceb169d87d177441682d4542e4265cf8dcc44b843a91c30739a0bf8f4ea2600711407cf5164e92e014911e6feb1dbaaae3fbd2bbd11a8b3a1fae38d29453ed510b08066d07c875e4be376c182f0caf9604a1ce322619af697c65ca21c21a51f2a1e4a0e6d3fd2a75ea144a8f7f572769ef64eaff7e4bdb340a1051e8b15040aac2dfd7f5d90459ad8181d076d341be5cbe70853c3ac1ded7bfe518bfde48c79e7b0ea6db6fa09e2727bdfe9ab412e97832a2b29bee277056067215349d7b3f2803a56c094248b476406d6f9f67303f0d36f5b3da0438404b7c5801633ce7ea540fcebf295a9a8fa750e9c651c6410c1e208599728dcead1c37ea70a9868a45df232bef88cb82b25a4181c31ad3e94d0c6cf4b297b3309cadb48abeaf3b1ba7c95109d0244b2d1106983845d2363f09b581e6b96d4fb3d21276443590c00c5d2d0bedb99d9f74aac146e2a64527aff9c7f63d08b29a834969debcdce380cbf4715fb1025f2551f8da6bc3897ca657b10949b8f1b5a276b712f20c400698008df8eec77fde50c630c7d390a3422d3e76f18a847757df1e5d3ded0f68db4c78304643b8fcad3fbef5bcbe05c9f4722b2c98ed172b013a4432da48f9db76d8fb4be6bd5862cdaab3e15521b60d43f5db34035ed8d7818f155dd159870b30ffc367a99692730dcda4677103e5f75ffb229294acbea2191a22b0f6a73ecdabb4c5b423fa3221912656a5b5740f1ac5e9659b6a7270787331aa7228e98760862c6c8fb16942d587891ff58781c0921ebc079ead5632f4badb54698c7a4b75c4f6107f937bb0f3a5a23758c76196f53bdbf6a5ac4e900ad9561a1e92e24c7106dae31d093a305d6f2482ca0028bf99c44b04b1f9ba7d24f9635d243fb0a22881c23e228e3856b112f805a43bb6a7a54d982ba61bbb12fa81f79ec86216f9ce4f9e5c51e4d9093d3cb0374d857511162fe6346eb97c3c01c8bf9e2151c340328b5117f5410387f936e8dc722e1c6343c58bd0333ca7b2399257782ac22a5dd12dd456ebdeefdcc6bf78b46072758fe0f6a34370e32a509ac8169b70e77ed18e63df2659b571cc267d8e53797440476e94816601d42265e4ef3af61747af4cf647ac4997e2171b0d713de75b349016236fe3ecb9dea9a1418494a76107a8a5343aed39ebb5e1e9cb3c64b4bcef855a6e8a311ecd35c076835c70d08b7190964387730664029478a848feb5305e516d13a8776488d3f927dd9d1685711cd70ceec71c02cebefb1056edca8dad99e15a178ef978a86500a9eb8144d9e0c5c64b029e1905a4ee129476d5f1004cb4e00f93650aae9c10ab6531a7ea9425a5be077524d0d5bd3a5072cdb547e36253003260dafe2dfe4b3a282004644d735a88ad56bf9416b9100a56720cf1c657468912a95bc68b3f5a42f7a8573d8761037de0bcdebc90a8b70dd2333b840f64f542b0c286f8d0827c4d3f4d87ad857ce0061ec864f422014924736691d10d01d452b8abda0984258e68edc705ca9af04629f2b24e79bc2428e1e88712cc61733ad5b7a650741cb95b8e16e2061988905c3e6716a70c2b2ad4c7b208f2f1c52b57915626202fb7f56dbdda74d035116abbb004852175bc49642bf30ec7e9f9f063e8abd41628c62ae5c42e74886f3c74e7b690039c8a244ad569fa8767d674c985b73dcd05eac5aea2cc70f17137e8efb726fb67c25ed32a8c805b4d4e019e8166ee97b8f83d859498059f8823416db5bb4d6b1557ba4121754f51f41a158698b5551a1288a36033a3fa619a972b655f86dc27040b8850b1c1c3c1db2dac71af580e787af5ce030237fba32981b277ff37bf663fca0c2accd8c234b155889a397f143517a05df7da1ac4def2842779e58d1178850a9dc70a48b4d738999de89757cb37477803000f3645ad587e3b69226c32ffeed9ca9562bd44d910bfe5a591ec2442e5dd493be272b259345c7b2fd7105e5bdeb33aca6253f5ef609be27542328d7ac04640f7b424514de572da5db7569098482ab37ab9adb3598475f26a53fcaf3979d9649421a1b87f1f9ca41e88d6b793425977a2eb68178e28a0a92839adc5c28fbee7aa63057660a0139c28df9de5154c5660fe63b3713d78503e45791ea5eb12a73ecf8544d6ad7c4ab01025cc8a7a7d431a39b21a75d1d86f7f966acc10bb0c3aa7e1ee941dcf2aff5e033c1a96da348736ed1acc6b6997022292d2ac385b78fab4b87d403476f4e334903dc355967695f0d71ce47f4176be6331b685b0a074c90295d11c860fa587eb0f9c8578d5f11ba591adc494b74556e88608de81b03125e5070a3c67a10cdb16d26d6bc5e31be096ef26c9f54d5ef070b25a631bb237e8261c546a7c095ceb65f3da64f7c3f15d90c6ac58f7dc0941073ffb5447734e99f06e88577eb67f1f20172b4b6526e448551f67120a886437dab6ac02a75232462232bb4af313f941e5efd9541e08d8557b76126d16389891c4f0770eedc5cdeb3d02c6b53feabdac4ca340f3dc29fe31f31ce79f58df217223f3a55f2e4a60411db87adc3fb65d912b20e286cf1cf2aba6ae7934328f58105e5e12cbe7a82e6867388d5910d0e2a55418c480037e764f7856ffff56ac0ed92b33b02936c0e0d5a19a191d8abeee6ea8821e1f1d12cae2b6aa52ba148c908247823397b07e07d897a1d2632cfdf5cb65a1a9067c29dd9abe8131d08f2baf05bfeb5f41f705131f52ff449c07a3acad4fc289bae8af84f3eaa030809ac7cf9e02731231f4bc99683d9c17bd186788f6c41d8e4b799591715ec89cef308896323ff1502abdf8a66f9cfe83ad940452a7defdd2a2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
