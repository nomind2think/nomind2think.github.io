<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc36e944bc261ba93156d9cb1957aa9c241d1b4902f71419336d27f6a0fa83e8b9631d783cb5b13777e9f131f992160f5f06d4723911d6124916aeb39601582f04382258d8b971e541f5d4f9488c39b6d36219d5fabbe9ba6e77998645b3599cbd6b1f405e78196b718884843172b2e15c7ed30d8c9b2e9d435351a98739e1d4632b0a60e106b31adc09db246b9b95ea1e46427e30209db6b7726d6157d95c058647e9d6a87f86768721c9db91fa2fdb08f56ae7898015428424d54123b158d83383d7e417f445668c88fb2a524489f1007949d78f585164e228044ae9e4de6824cd37d065156fd6304cd51072359a9b1cde52ae8d37e2aba329a1e69ca16a8e41ee86b9754c0e3be69bc8c203271f3a9b54988bdd578a4dd32211e1a17a4d911954ae327d2a500e8bcd80c0f2a97c990afc4af8407efaf98527947207b71249c17756edcb6a53e54f658f4e0a446ee6e5b290e63621da8707de202a1b26873968125f689f0fbbd986d469bd8a4e84acfae2e0484e76fc380a676893a8ce3884b8b78b0d87b3fb376ea5f6c99b02cf9aa3cacb50f6dd241465920fe349452249073c4ac1fe5863b53b1938a09719d00db88c6588c2718c67d784136b8e16726df451a4995f697bb1feb68d73e9a633fccfb4db287571a8b6f1d7cc856c18459712a1fbb69c001909c2272449b778103c1394d6b013dd8f5827172c72ebe87f8dd012b0255028071e2fa359db24a9322f3d7405ebd5097d4a48550cdc4187d5d8e27f3662a73f603eecb9099afc4094ea74c622211ee65727ba2e26fc54688b67c6dcc0431f5d8c84a259acd32e2fee8cc4488c5593d4139efb170dab4725e37437823971a9777e11a1fe188032afa025830060708d50f452bbc55802c35bda03e0f47814d3872d4293b99359a16ccb3e9001d2bbea7ce9a8d3614a1f76059ea599c15febb982dfbd65c7858933663e8f398921aa790d7dabb475735c56d926abce41f85b9fe431d0aea09b9064bc171d212749fca6b94004a6238fafe65e662b4fe88ed4b931780c8c01b46f7eda9c694596c338095a0d33c65f26503eacbfb207ab795f0e199643f1eb53c2cfa35884e3e3aa4c463de64c94a4074cf6c90518d1dad9177996db93d25e40e4eb43540e5dc98a8858e115ee0f1d8e3424fb6e023cd34f11ae6157f4928a987c202256f67ad76f90e4fc7e66972cf430fbb782a2e206db4f8a86799f4c06853e76fda55cac8c08351a4938c0159c21494bad9a58b71cf7075e87b202da3facf6120a543e141db5c580dd908fa62ee86ade8b128e5d029ac701a9eca44297c67e44a63e3313b453c5ee58a594af50fff1fe9d9dd37ecabf438da6dcfbd33de94206a6d57cb45e6a544d4c518ebbd7ab5a705de32853e578492ef6f729acd2c317b5fd2ed5c373e8314cc123ca13a7586732546646394d4962f9ff66f65639b3fd5fe003d1846d30bb8675f227caee8b4afbaf9fa79f2e8aedff65a67792b5e2df950053a01e7878b21bfce7978efe3ff7a9d6dc618c6e1f0de0255d8a71a8c5ed8529b3572a728323e76a37b96d34f1ea48b2e912524c71f5aa1326286225e0f762eae097444089c8e78a85a431f622eceb9b5a28b44859c3b78a1abef36677c86d37b379be2762dabf7a6121651b76e30e74f96befc291a68797a6945b566a908a429402fae204f90896752e2b21cdfee746717071cdc1ad0c4cf73ddb2638515bb28459d822de57951f8f9c9949190d563ea1b629a53faf8bc2c6043e5e8bd3cd29db9536e09cb286d003415a6e51323763ad3e37829a8e9987a511a999134a425b57c652bdf87b581008e5c73c97506d9366f1c7bbfc589d44f4d194b4a215b25bb5ebb77ff5aa89c09087ffeb9ef6499a3fb367892262388563a10f21ded84ef14a5bdc1d22c80a1f22956dacaf86dc5e3861c5e766f64e986f86f6f2232365b4c10774b1eddf40169b251776b4425347437855015a54f0c49bd70fc12188e6d3401f8bc915de78a9bfc5bb2c3721d177ff73411feb993745c8a646319aa93b2bdaad6608d864250457b63a0de22e55b9d06f1a57fbfe83ea39d65e3feda1142e9832703a25e4a93e29c6f7d7c1dccb4bb8e13dc2a7a567346193150f95095c0e088f472463197150f6439d885da664b2cedee88360d8eb582982d1bee135a06e4a23f55465af10a2a0896dfb560556f80aaaf0d30aebb31483ceaf2307addf5192469c7babcc2afa97d085108dafeb7f6387ca860ba907bb392228bf10f2d09e5767b8dfd8b7b14d2f2895346da311621157f6c7bf9587be354e60c0518c5dc996e03b133a5e4cf9bff2b4208a5b40be430de196d181d7940e097f11d775e4fc0e74619e81af2661b0a5d3ce2b21dfcede91b226778ce238205027b91e38ec9e6d6e97bd353a19e279446bc1fbd31b82e83d7450c5198f0ea83610e8d4be1939047fa5498ff0c90970bdd086532728312b73b135f4b6784c4ac25cf38069f9343db026ac77cbdd811c52d762fbdcf27e69ba0da6392773ef74e2f75c5457a685fb3a60b403450fb3a40f55c41d3762556dc15d48a7d7e880eea216479c4fb8ecbdb1d7da445d2b3b998034aca0f3342ecf3782c7f797bd814b85cfeffc2f64f816e188da53d50087a368caceb9af835f5906758d0bbb4e751f7e24a4982b4cdd8add243f96eedde11adb6f23480da5a5b689f7f57bd7ce4eb9f1177f397a83eb93000c02df96a7ea64c8abd594a529323724321683f6454d8039383dd0bc6e480b452c8effec7ad23d3b69b72bc52cce189101f7c8e99f079525b21f91d7c9686b8bda1e18f170ed92e9bc7df3d6eb41d4ba7e28c449ffa4486f430c4539be4e4574af62774652d8f9136bebd174287504bd847170923d575428a166730783b2c732e44cb45268c6d948724ca0006112669befc72cad5fc723f263d420c4e3e85ea3ca8213076cd93e7fffc2d36340696b92cad4ccd8a9380fdc179c8ccf90f2b73fda77f816de70fdc430ba88e04ca6883f095afc2fb6b5faf006bc89d5c8c7d6fe8688eeb57c6d1f6ba8f38dfff090c41ed58bde0926ea4213e13bfcfc2a89539911fed1cf4d29ee540b385fdb92fa4ed4a7c59d758a9d08d5ae675a055e44307a609f65651347b16f9c27280d6dd29b825b5c25ec44a4aef20d2f6214e3bc2c52c3cf76c02eacc991568302950322d8cdd283fc24d3d7832bd4914749e214f8fe0b14bb3af00c278a1523e22e7993b642a4b3f203424edb2a044e6288124f2d14c6bf3c9013acca22c4d8f7e8cc0b46ed033d359f9c08ae8b701040fa6966e01a04a93f18ee22dbdce887118549997ac2f6a6f1239d823fef1dd4fc0daea850c31454b8542db1adc10bab92d18d0c4369f92c0237de9d0a147547da4efbd7e27c6c348304d43e45137121bcd629959c7d2dcaa3118a0fa96927bd5165626f145b0a73af71cbdc2c7a4a75cf111b4d2609ca4dd91d7a6d34440c0346223573d4becc34ff12126e148f49906c95d1db3faeb19bce29d073f6cea0b3bc5df21b59b99ab911d765ac0e952c861ee89e2feda27b035aa5742fd49cf47c4b9dcb64406d2b6849a3e87cb7cd14fcd30062e9a1250968394a5782f88915171662c209f66d65a3c67e16f7ebd95872e99ac674504391ec65871a7727e626c3f094dc205f37fdda230a627ac5f4f256e07978b11391c3080c4e06c9f86956bb1fd9b3f82f3e837953b28b4266cffb79a82f5976ab888a7be0e90a71c4006bfb0cbedc9b48469e41cfa7230343fbfe96ff92eead083c69dc936278177f8babeb69daede19065d93af9c1bb5fee93ab10ba8354600371c9a9fde94c8c0dbfb46bd90c113060ff4f31d4a5ce810c8521c9a01cb06d7cc0f69d1f80fc0e0db1fc61dd5de14230e4b106184afadeac59ff5afbf6c0e76d310138dc3e7326098a350853cabd14d05728f1f51458252184840929746982e807cefeb4889415b1cb2b2b836f9eb8565e7c49429ba2feba5574299939f3294445910450a0874fa1d6ef43196e0eb4b2ae1242721d152d21d508f1499754e6803d236d9b27de46e8fcc0a3187a0a533dc1b5bb655e6d71a2a6f417a35e24a6a83239ae3b281eff7d98648e9cf45478c4dc4fac0cc98e1a5386103a27e716351b27b6c13e7c3a12a793090d4ff8d25ea80e3e6677cdb138d667a5d0920745fd1dc908f62ddd5db282aae5eea7fe38591fe1c4bed4fc5e2dbc9a040f41c0b49440edd4b0640fbf951c31b80860aa0a2fdf519a6a076e249285ac98ff01680a1acf0658fd3045272055ec77dde09a59399158b20733000c1fec940401b301668b3a1450292e7bcf42303dc4530d93e7bbdd5d93273b551439cd9239a1674f63c983c7020412defbd63443a88e8a5ba34b64665b0d6590556e49daea625ab299dce3724f90c9cb2d72f353d0782be4d8f8a97e679ab4bf475f1772859f5c46c91d8a66ccf1d4ec228d2a0f8b44b42df71ddc37ef3dba381fa0e73d03f607a43f9ac0bb04008a382b4d6145c9548a91d7958dda479ccf0d4d235c69f1861cd712374e18ca6be9ece6c70b0edb9e65b83540b63920ad21d7c153042d9b4c0dccafb5354fc1be32313afdb85c63e6cd6d86ee9b63d2c6ce473f820b78be21affcf93f452be97be4a702362214463185c6adadc5b8ef85499ef04012662243660c571c7cf6310c16ea5a9c209ba9e25c679fe0c0d8e7848fff277e4443d9f695f7c21eacae39c92d7747c91f8b3f53a4c99493ecd2e54f8a7d953d476cbfb6da5be1733ac6d6cb87caea554303869da7011718b4e6dad5e1003942f8cd8baede606804ac45ffa12c30fab4acfc50d2c22086e2f19a484e68b974c1957af6aa7432b45a90232567cb21db8f2cf19970de1a521c9d6072e5a4bed5f2183a29f6b0fd49e36e77a6c7cc04d72c96fd399f06283aebec2a3b4f92b47c40c4648dfeca1e903d184e31d15f9e046a9fc7fa4cf38ea31855bb5713359e90b968e9b27f8920edd844c1f257953d5298f5a0695d0027bd2711d5db0b21a82c31a1e00e87e3de217ee0b3c789781e176a11a97d2c3d0a060ab32feaef8078eeabdea63b8ab7609b33360a86e6509cd1b504caf4318a3147ba05d76b81e117e9cabee329941f0edc3876ae6ffc9b4a58ca4a671b86b39ea2c9d0678c65e4742e61e683e1701dea303d45ef0a20c2d360cd230f2a1e07080b2533bb9b9b13b2cfc09df67fee591e83bd02afd9b3a973f6ff690cd80790ef9219ac06bc04aa916d4d0b3d9c3b484a4a58d3f15e61545e9993bc784a9c0772d373fb7b6efc5c413fce9d212b420cda43c54ddc5900e32f6e5bc5521604c4d8fa7c025170f93d51372a1dc736ecd55230a950020c15b058e5a55feac2efc32c494f65d2947eb17c9e886e2ef7178b90978148115d31d8ed45a8601846a5dc1271602db3241c42e50a67a9899d5d3b88d670973c3d2897e8eff1231dd8b5d2b8a50d1faf7abf7af4ee71e499b4e933d7c2199283adbbbd336c05c37e22e8ef21ff08eedb73243567e9883cc2349e221380e623aa4116747a84d68b85d26567e0254d311a5d659dc660a2a1276ef40b98b1cccbf3cc19c47fd9bc724132ee6dc5449ed127dd139c89d6724fc6316cc3ad826bcaf132dba8452685a49555afabf793920511d174df31001bced0e04efbcea55b1b73843b5c5a14a0d2fbe79583f79f3b26dd20f91588850fef6a700cd25d23d06c04dbee165c068439bd9fe9e72e31f8130dd7b175bf7034bb5a7c30824d9a0a53aaede0b157f13cc51ace78079bd6f0764aa6a8ccb473c582fdc9dfa687d4a1a1632d8178128f36d2975b2914e588c8626e348438bb0af9ce24e015ba0911ad09ee61cf81c434436b8ab49dcb152ff74c4c494408d9866247a71479c73a89e84f9f02013b747f673ef3f03e1c9a542dc89f00581608d8656c3ab2f4b38228a4af9133577a65b63605fd5f00884dfeb9b3321ad464be1baac17252fabea502445365aa609adc458d6a9677b87db8ad928110897478f05841cc24d551390dc5a4938d6ca209621daa6b72f970cfe88ae2c323dada43cc196cf594a8cf621aaeeac08d3e9412300c768c69ead2cc85b5a46bb5ce9100723ebc75fd337042dcbbcfeb4ccc7f2cd956d470fc3441b76e4155b619cfc94a04027f8d12e0c9a6f3d6e122ca15ace121b203efe891d01e3060b8478feab21953c4c56b95a8788e52058cb76251cd91db5804c2f0fa1d1b92135c53919645668379155f6d0c5ea2ee3ca23e9607625e3f8e61c19d894aea23e90630bf2ad124aa53f6baaf7bbe009e748fcc31be8b821e0be7bc3c04410e6ae2d3b9c18f43ddb5b8cb91738293e6effa9f2553348018730e72cbdfb22c9f53e1ba10c01d173acfb0edd2ab1aabeb1aec5425d6704db67ed419e377b2b7b9249366d8515d63dc10d6b9c3c23c87e30a18b1829da899ce731644c9d57c9ba28891ba18baba02c72deda67c9499982ea4f18c03884fc7ffe012ce1243039df2f740ed475c037c40440ebb2957c2c63b8c3eef96b2f6569187fed026a80ddc8ada73526d3028009b198c403b63aaeba8c0f80036c41a979c51cf7c3fba09a02195a4863d79764037c14f4b837aa5dfda73d4e2dff3a4b450957f6e5bf72024cc760640e047aa20eedccafe2a07975901a32ec25e76cd4807796ebfab39d6bb6bbfcb18a682ae91eb8dac3056e631478ec9d07e278d2a42d3961ad81aa258425c49f996f34730c2d3f32ad98e56b62bd47c7fe1bc8e14e1bc5363fc183b231fb1f95fad0cf986f6e9484c076f81849ca5b8deea64d57ec8a20d789173f8fc25054c67a611ea83490a11da46bde0f4f115e3161eae11d39f6c8151ce5fe64f78ecf00a3bb6492e381718f97d650a84fd807e78e9ef29f3a6df33c825a83f6b6021b6ac1887e7931af69aeb372a9eb7647a436d1e6daa7233a26a967de963fb7dab08aa0c7e82706a3cf7afce81191ae10062b5da7b0136b17979d49634da28008fb2cc8bfe05b781a50e8af8e3d3951f81b35be7bb15fe6fde811f8961ab47110db9ee6eaff763ee629162299791db766f1b30bbac73429d201978eb13f2f705c512739bd43ca63f9aca058e95330433b0ebf6285d370e37787fd04f486c6050b9618efc38f10cfb0a92a18bc38d0257ee5783e5ff0aa8aac7a263a0db8bf2b8755e1fc55b1c591aa92aaa5c91cf466fc408795e81d3a438b8e5070ccd1885207fe6ea47f37bc3d5c92aea53d4d2d30dd45e6c0a9126f1e040fb33740aa1514f205df05e4cefd8ec00ed4c1ccc075dfa96607f87745bc0534efc8f661f8891dd6c8018f73dcdc81dfa81a0c55bbf37635b5d20b6ce172baf23c16e8bb0aa4c128244597591a5a8856ed062a60191d2264017c8a60d3cc5f89168e664916692c00b583f630de22a048aaa74ee6fc397187571baceea6d7df9610e3bfe464dd6bb9917d84fafd5698a66c4470ebb82e1b6a31c0d1abe1aed2ce7264078aeaab77f277b97760b77c0342fdad4ee7a05d472b48b6f3d627421c16198e113842be9a321c2353e543a098a94c700463564d6b44cb4255f98eafb6596ea4651cad9b219cecef803674715f923bc9c117c8fc086adef803762315a14abf0d5bb95fe7ad6470112434c26ee4f0b46ae9cdeee80471e3856c7bd350cb3690ff17f0fa714b1fde029cff7dc01e93cfd9882c841373109767d30edbbb4351189a0187ead991d84696066ffa87c74d78bf5999fa2436f324d4f09c8306d8674d643bade22b4994d259a417a194fa1f9ffb85a5dc4934db7f3f2133af63c60deab1c1b0c0ad36576d889816c83fa875c583589a6bc6c36a419ed7608dfa9492325620c25cf5791ea12828c84b55cc2ffc65144580af066960f61cf592fca979c2d461432353154785f7a6831ab815a7016fda3eb0d8ba4cbec2f9622998d5c85c237cbdfeb979d9f065fb69de205ebfa02a2c341aaf82943d75dd461302d8deedaa1f68b1eeb86635397af7c3dd93751d3dc085915cbb590b1222c007d9ff413b443502442fde36285f25e65ea64e918697f439104b5d645d14d683345448e4a24b7595b1593550e4c69b10242b4e9c04a192a07e78cb10894bedd77e5bbd746e7f9b8c05983d40cd16eb5f57c6da3c8c5929eab07d9880f851db55aee69bbbb1bebd2e06d83de821746a2f4baea81d4a052fc0a62ed3da8cf2f51dec61cde9396b8738ccdb613c9b2a16ad991c796d22ef1cb6b7ec23536842bb83a9782ac0ee2b4bf15895c21bc26323ba395ea65f5395cbf5bf640b77fcef4c61c7e2c32a31f2c584b8b0b2b4f4933bf3fda1714eb4f1129b69a968ff5f4c8ab696ff71aab315d3a53e740a9ead429b58762fdedcde203c71d76d42d2796e0872506a2dbc906fd562254f77287164e9a9883dd9d3d0b78ec114248177c93ddb6ccfe6ccfb5adbe0112f7e23cd4afbf80db3e2e8f4cd02c07e1c543c6fd55c084171456052c3204181a0c3ab852da0359be92ba35c81d864d06a64e7cc08341d2792d1a281cc702b927ba74cae7712533e3fad9f1c764ff600fdadac6089e0d5d72f9347fb830c9ecef139b9300383bae1c38211ed2f67cf10a4831297dc610083d81953e985b47c5388b59cdef55bd6dc3b2a27433ee076b0bcb83ab896a8dcb0313706346ac984ddcf144f60298f5c79f4bb5485cc98f8069a53c07326b7a3377f820c85558b5ad8bb4ef1fb059c76d9471689f83faeed0d9cac39136f0328f2573264192d17aae2dccfb8e365f140be39214a543fedfd498bb67b50a64a534927f74740564fda5fa06aaf5e1ec636aad016ffbf029cd2a52cb765a2e0deaa0f05cf7ba45d5d015990a3741794bdf3fc23b0c51f676c062ab90605d72c685f2d59525333ad23227d48db3cf8cb61c7b806e29455c2985b7af4d7be96b02e3a500a06b9408b4aa28d6a41019ea44ee664ff9a8a4f93708e7f7367dc533ae77330f419f079b9c550dd90dca5dc4d309f2370331d2ad064d7c37a97187e10ab848f9eca935d492d49b387a7fd0d845a326c01f8cfa7da0b9d7b562fa63165ed5f61b4ff4b45d58335c3f3b343fe086fcbe012eeeac97a6c7e1b108c2bf66579c2aa74b7456a441b09b6b3a23f33349b4aab390a56cdf71b3bd6d053e944cb58b31475587fb6b877237f6e7c76f43383f5e945aaf0d00d634acbc7c75edbe9d7021900321474959c836dc3efc39b3c93776b16ec1fe7f4091cb66b55837c6de781b410627e80b995677df9700acc7f3ae7c2a68ecab53e14c64b8f55a484e2fb9728f19fab26962929bedd02ada701bc5c4415c464685a0be528c9dbf416f86ed3f71d2117f7c3268c8e2e6b3f4d47233fb17a0795dd0f8474bae061a1e665e89b04659ffc2c387459adcfd6416b574055f2f154c273ead6932da2f07638129c2d8fe2a041f2dc8e3e6313469038469dd72e493b7cc30de0e4150a6d82867da56fcf8ac7bbc29be945f80b9a19988acf6703b122b4926622a4fe3e012cf8ca74407e600a793d993318915c746ef5608846f0f9d3c994e7ff8ae45ede4e84301cd3ab58d56e908c9360943ff364410208725ba0e9ab54224a691c6fec91f41fbde8a1e75e67bb830f3a9e3687e77b4bb2cdf45e7bb648fa01f60bcb6c3a817cbaa6a0487f522962b27d637a2c333546c2959ee666646638bf7c4e3f5bcb8e9ce92ba032392a1289cb3ca06919e350892469da87cf4633e3d152be5e7ebe4471e84b327c00155e946f5c07bd6ee1feb188a59a13d6bda29590f14e7d18f5787766d25ba57d08f3703c5a2dd411ffcc5b735ac3f98cae2dce206fdd8cbdaca3df9b824a10344199469d91f14f20ea77bc73e9ac36ceb6e6b93d3ab8e904349e469373bcf563d5ded2455c7cc0bfcf4b39b93bfeb55341da89a7d1d981e9c0c07c48d3292daf02ef5651f39e32b6723cf0ac4f5e4cd50a0d3984e81243a9d137d93a349da123611b22cfb6b909655da8d6f69eadd74b54afa89f3a025020aa1d457b1c9b4e9f27b9b7971e69b6fe80781ce7ace665c25d4f193843734369ef8db4156ca86fe3720e90bfe4771175a8dbb112e4c2efbbd9f9ec8fb7924bf619f80f8ffa6fa63b047a8c3db4564a6390a4b71028e9146595393a5e6a3a0195753f3b54e9dcafdc945f1a3b9d798aee154cd018bde5488df1eb00ea28c3fe0f1fb6037575f3b6448eb9dd6a443bed28662237eee3a24dd9ab7078131cd13d527a8a79d134a5e996129b6590bfa758e28a7937464a1d6aebc3d95ad1cf70be23a7e3b07e07909c27b4a987386272a1449b0e089c71a478d77fd58c9cdcc4da59be96df7ca14ceebbc4c41756aa9555be161ac5721fb75b8d70459faed0ea5f425d898b076912eef5aae9d8cdc402c006b168221dba667ea2711d68a12451e274a609d554b84895aab789883a1e86938903272dfe5060bdc515cf39e32b5d002669b46cd4d92b516972e97eee30e37ea3de50d29c44cf8b6c6d47384a55b95594508168dbd6979c19cd2ff1ff0302a3abc5db48aca316dec23eb0488d834343adab39437148afd605f6d0ea4c5f5e77c95c71b0204936e1ff9cd2b3122b52c7282c17dcf5cdccb5d827825d08cc15f24371b9ff2e0998c94127e5a675b59b0ad1f71aef9b3a27e438300abd8789da889c969e6b571f70e38ad7ad925e85e401b1e5b8b50a2c0d8dbffe382b7c30502800b96c2bc462ad7c2127202bad5a9c4166ccbd9ddee37b745c9997293648ab1344a9fac21be4c524953ada6b47e52f516c744ca8d342c86b9","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
