<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba6a2dd60971af70450d4138c9b12e0652f8906d55b519a80403fd666a4bf6f6cf2481e03182b8342be57e8be8ec70f1933e50b80757df6f9c8b201038a4f30d84f56c51db2432af8997bbf2182df061616db5d4f139829c0f6bbc72194b6cf668358537e78353e0095a9f6bc097b7b64d1c698b7fcc59b973fc5928107f85eb4d02b6b988441518c928c4f04d9f512acc840bacd4800f60e1461e8cfcdafe88c96fbd2707365f9f19cbf516441fc8b2e091d161864d1abab9769bdd10edc56b3c04c783f2b0862551e1d3b27c6261ad4fe6653903f2655780c6aa0e974f5b21cb55a82f8a776bc978d125f0a550729458c4ff6fd4c03760723bd69186d623dc75a885eb19aab38a8b840d3c7bae0293f0ecb1b7edaccf21156ec8fa60d27b92f63b67baddc43e53d303b9ce28cc8b6995f0465d288b550f741aabbad314d5b509e89117b2e442fe30539736e3e7d3fde4ffdd595308326b0026313db3e9baf81d4a39b5df4ab01adb705b5b7a362df5f252c4d3d44531e66399d18d13877023f6f021ed8673b7b8f709a33884f1ff1694e8dbbb687f9237e435cb167068c0dd8d6ec6a5546e13048195149fd0994eb021da2e5940926e83e288979be39b5707b91fdd6d674d9c7d48514a2e7e82b876fcd72094c3e9eb1711a08426cbd53cf6e9331b2b0089477e21b3ecf242c2418ae9640ecc2aaebc01695f8c70422ecfe36049a63d99dd65b92c46239e1f99549b137a0ea8aeaefd21f5c15e8f4f98eaf6966b851b3be6c009e81b2e5f7ac0cbab6cc5619dc05db84395cc0f955a2d81e4a691c77daa942517a2ca7fc9d4bbb55a1770ad1ae61a5591213f83e595dc107e2feaaa92bedeeb99fe626174d90606e51db445c127de06c294fd6ee94acc2b339081113ca30e3fd6e78987f2813138a79cff328423b6875f56a5464bcd47224a3555d8cd414e46523fb076cb64420d817baecb41b8d7a139d4af1faa9e4830716b2d68b48e9c0daa3406687dbc1eb0a0ae246d71206fe69ecb985c24299a42b6074a4d810cc804df608facaa3260068952d9af9df4d4f8d48b83e100255cc77a459f248e0f7070c6cbb189d6dec9015b2cd7b32f6a4e160efee71f28c1c64dd66b1a67f3586b7c7b1f660bc3863d2dded6fa741ead495de30900be569c69a838e2a9b056441f7857b1662b68bdf5d0be651c037f711c30ac4de1d91025f0222a8e7fe7dda8cf381ba755099fa60c16f43561f1a7a967cf39d175b4082ad6f1f686c4836674034dfb201655a37be7d2f42b86bc5941989396438e708d550c859171fdc66afebc607b47098d96fdbd9e7944ffa7e1b360b245c2a2264dc03aad92aff1ce429087bb17cb13ea88290c2a7484d47acf49e19ec28c54eca8590a3cc2bdbfb2d9c02567f3bbbb16b63e259985ff47aa62e69be8bf363393a8aaed3b51e93424cce92a14a3010b159eabe7f26befa909d0b7fc0a55adebcaadf1754ccd382c6c62fb4e2a38d8287a4f41bdb376f66ad3a71d8c8ab5269d30bc8781c518e6f8973a5533f237a85e0882236b7b65d8bf76887e148c2b8f4d40de6c99385b5e38603bc856ab7bcfd9ac45853f20d99440c5bbeb89136d527a3569ae648e688effc0685a94f69644883699254e03b330cff6763088aeca24904a09980220b2d9f525cf9275df6a5b0d1e5d7eef1ad93b750740636ff1b019045cbda2e250b6aef7d0fb3bba56a96244869abcfbba19ca04e086ad9c6b560e04ffcdad1cd5cfb056d1014e2c9b3f811443a083fa98409cdd789c0800fd1ff97826307f5a3f9239a8ebf1f11821891df799e896c41eacfe434e1e4ab6c24754ead999109e46801e84da61de32f7acd38a1afac9e0601c14805cb49ea26ffafb6ff3b0c56265190dd25623d9d77483e7de5633b0bf9fac0510be1c665c7cae4c4d1f00b6aeff6d7b43cf694b5a181f7cc953a91c7db3b09aba51d4ec62475b5e69ae811a7b2084549ffed4b44cf39720bdb883053d38f55ec48b2751e31d8346f3bd436bf10298e17c436c153d317713d4b6993e0eb68fcaee9cd1f45e5c5fa1e5f4159c2dbb18f69b9e54bbc81159abb7b33260583d7501ac7cc89b91f42d564a51663f0b3e0e055321c00fb996a16abe0aed6a82fce92a2dd455b6df31688dcf8cd04447790c599aebe9aa67a08f3e318bf854b7dce97281c7a1a1d75a97e43e0a889cc841f89ffc742a1d67e133773983340d706d3671511b51af7c9c8af211eb6d86212c8d248ed27cfc264be78804afb2aa9bab98d6cb0b32179edbd234cce759efc07034e86b652e2dcc1ba3c1fa567a76a3b3cc74ecbaf39427af679e5a7f105d22a739324e78ea4a1ef74fb6e5577910e3d7bef735a2a5aef4e3d63671201a3112e28950d1168c08b9f76a7bae990079c94e332187b8e547158d8af84abfe6d41883238f3fc7966812bec0fc45afabff42c296dedc1a6037267b5d963ddf3476fe17a391aa9e72167c7a167138b6e6c0dd67b68f52ee9b213ba63b7ab39db620a931d6e45aeca69a6833639111c6312e6dbad61a2c473097d2b794871609cba475f8dec1249f83bee3a70f2a2e423f44cfda8e0b66bb659c79ac2c6fe84b63a3f93266c3714ce3fa027a4b7fcc18a132c2b1e6269c921b2e88dc8f2dc287f2388d22914ff6ab41a626324cbfa02ac6a95a3d01d20b5790bf09392dd628ee698f661dd07a7deba6f6b27b01f0201be7685ff3ed5d82d6e76728cc397d42406fb82d51acec0e9029de9f433a4d99d4d4b2ecc9fbd1cd89350c5c2baab4a516dac6d677ad1b3d13d625762b1db8ca86ed3e0cdcc5dacd9a100dea6064dfe36c0c06420622bc24bfd619b468c4204a05c1f053ca9f8e4bda92d767597117d6c97573d9dca9e37f3cc6521de3629828cafe250c335254ad81b9f8d2b7310bf2c6c933102f5c40ddc5d92922c82b9237300224792c45afae9386e230330f143ceafca46c6311029d14c21e2b48e27c792badccfb0c38e2eff8913c1f058083d656a01de48f373519e42e1cff2eba6c42cab3033428e6eccad46ade2c195210744d681fc0eff8c4cd822413fb2e9f725cb93afd120fda92ce8a17d06262705d6cc3dd5a6f0d63c643f2b9ef52c3fa4864bf1aad2fab193596d39ab6eb32a67837418832ff4ce88bf54727d6c125a45195c667be21725bf70f8b5e0d6d148e21d7b6d1a87ad457b598cccc2f0a36790434381838cb47bf8273d405339e5e9dfc83dbf8f9e0f7de678b7defd0549b6408c0f86a3f4642af1c9de5cd6c405226c465de3d2607020c52d0e977fec99a443529722b00c82ea2c146cadbfa62254f39cedd9fdf0e1a67bc48ee796fcf58213ff6189c67ab428b4e2c3c6fef681f71fd7ca7cd28b6501e0e00c1b01d90a83bc58315d9fe7beb0a1854af0bac0837640d4d1e03febf9cb40e01a4cb7f7d62b85e27f4c6e4b300d60a299d3b7b6be3d75f7b6d5f7bf211dbe124f292cf518c4ee12c8940991140a6b09f8323e80cb668224a83e53b6b5f8c484d9d95dfabbaa28eb3ba1ba0752d8fca02ee53bcec2e2960e91bbefa23229466ebd7e7fea9c8be2fa5c8540392973d13b26d6691ce72cbb34b67ff3f7d6adce83efff227b09b2da8729e7b449a2d5e9520c08fbe1fd499fdaf63c0450ade78fb882e3a4840944208053799e8f4c6027ae4575e304d8494ccd4b80d9e4101860539af25ef9bac4360c8cae191788f7de59b06d0f47aa10e6d6bfcf3fbe00729e8e77b01d6b46a0b846764b47be91b56f7a1b9a03c30ebdb3473805e7bc49f333e9dc92e2ff57be9f125edcb09db5baea6fa62241a1822283440868a72383199ea6ebf0f24cd525c295eb2eddd61ee71ae794a7c552cc693e65a8080c604fec81f0d8e7a59e0b1579825e7719f174afa5dcebb5bf84f94c863ff64c0329717875ce5019355c84350612b446c85c262f0596fa0066b111305facbf041be4cb152655ce9a8f17ec7f0fe334ab6a8741f3d8d1c5f455f45b5b5a3a98b682c6ec7c94f00c6b3332a52a23b3486f6ca962cd05c23a360b95a2ed7edd173328bc642ce5036e3f51590100c3fec14987a15e4a4ec55718888d16486854dc68adb1b0cb25705ce69409d11bf34d6b3b8ebd9386d998ad233c1cf0c81e469145c0e84c849204630ff1f952e9455edd245c14b897ddc98c98f21cec8d316bbcaa48aeb77db1e5cbb7fd6406e637627b5be2b7b8a306ea2ffaae20a208d78f7a77df98db8e90d3c266fa0cd5f26d8c1988728b530ffa840023cbc4440e8d3a6f7a97742c8a878a6c9903195392361ade21db0e24f3eb8225b8ef996a793b5d9a51d475e9a753f22b1556dfcaec9c01bb5a553d22198213e718420f290632b135c88360f809132e9709c50d9df8ef4d6da76a80a7dcffe44174ad44a3e38b7622b69c9231ead0524893eed2f7b18d62bee27fa672b087cad95f3c9cf73ba42edaba40387a9799aa64442b60ca6b333f268183a66911280a91038fb528d7171a6c47856eeda97ab33edb0420d940a8e9ca49c33c5d20e1fbfa35d1276aa510375bf2da82d3bca76d7fa557901ab0f3942899dec625ad2c9c55bc86a64b676773d1cb6735f8c6ad8007f31e475d20d9c61b2ddd742eb467dfab168347e72b47bb999bf470f7717a0c7ab552e32c8c9835efb191db100bf7037953df6aaaaa0fb3e8b22c9c9123eb48e37679d5bcd597fbfb6aca7ffc9cf08c6f1cc5667615b4f3c13128b88652b97af6e8f43bb318fddf75cb49463528f61c5b82fd44471197cf3caa115e0ff60445358f38fdc26a7aebecb328387890f2bdc4cc1560b64a5ee55923b41aa0a6a03fc630b24197eda765c17e0cf9aefade2896384f3452a7b6b5bcb499ec970acc1cae887f4736b0ae0b5790c9793d89bddb586e6161669dec435c95ea38df4614e757c6fa1a51f553e528696ca8210b94fa598c18a53b22d0707a1bb876ecdca8b5a4e2ca8cf09e6548d32345cafcb3afa7efd8273242b0b59f015d1229395f073c824ee4e89d2d0e7b25e60509ab764c02b83d733b088f0ef91addad139bd8816fa01d721e6b3a5f9e0d07359f79c04156f06a1a806c2e2f5358be938c3ea436fa6a53d1e1a6cd3bda7e564accd90221bb2c6f30071af55d0932431203ea19fe370d9b0a7d9d31ea65c81950ba177e5c76381cf32de80a290c223b07b5ebe3dacabda82785f983355148a7f56aa21edee324727ab417d90b0cfc6df4b891a847a5f6ff99fc3d603b6cd22c0902a302bc906dee17b8d2b3921279193fa581824438595a99ee7d39894fdf6449e615d3e94330181b057ef064e505cfa2df53061400e1b96718d81ee3bbe19a8e649e9a0b11879d39d3c9fea0170053827f2fd7c0668e66bfdb40e98968dd902c5ee6dddcff822c9801a56f457490116f9baab7fe720da2fee465ccf36b33c058f1488edea4c949f144263ad911b2b0c9f484032f235021377d597b582a8ceda63c4742a39cc907120f90050647d99f49023b6fb4afe3704fd473c6f1dfd0a00882d5808a2c30aeab1eeb5855f9d14c7963ac15c52bb76016309329ef5b58d3ec76a90d0bef35594e7e62d839b47d53d09331844bac4f5114d07a3e26132d152306702fe740c61af53090c751cdc7a8b12207326101a85be61f60c8651174387c0359e2f63852bb69f75a08dcd40df7f73c957ad3542f0472f07eb7864c84ca112c6ed765abea19f9bace6568b9651f6b0888ecc3b22b266dab931f1b220c9414749a553510cb6338ef06e3634fa76c71d6159f6ea2bf8b1972b794fe08c22623ccd5d98622ad137c28b4f62103f4f51dfc6b3f97504ec0ee41daa883fe058ad72d8f486c8732b0cc6d374e10645fc8231d30dc1bb68fafb7cf10c7619dd7fd96c5d9279f940aacc2c1ba060ffaec17971857965c974f722e6293b971c0499087501077d76cfa4a970fa34d0e2d8d3af65de8105e1c09cfbdbc9b55f9670a45ea51806af12de70345174b45b992a4417682de7bb517531dca7e83aa6e93b05a29a86c3e9344aadb8436dd6b337791d1e19173d9a8be4a8f0ed73ffd0788f4b57c532cbcb2c11265a53e0da5de0fc241f9064fa042685fa617c52c26b53676f1c95da3227eaf5eb1eedad84fce4f78a85d8185ddc0d437bf03ad574434ddf63692b1219d953198b7c7a4f6430997442dfb7a2585d1d8babd12cc0351ebaeed9cb8b43a8faa72c4bdebd084334ae3e9bbc0ec288c5cf1fbb56a08278654df2878963b0a66ffa264142946d18495ce37a2e2d2c029b2da0e30745d00bfdb210f539df142eedbd08a3bd348fb23391101b497ec8169c90ef9731507e386b3ff68b1b6f0e635c572cccea07a99f1d9e353636c9b4d0b84f58d4f9190b61c77e48bea22077917095168716a537cdf9ccc53e170e1897e969c99f054a14eca5cfcf97944ff969aac842d91bee78cf3c0fd9a03683338b70c03d5760d79666600478a1f14d2ac671c3138e6d090e5b432c78ea83af36adb1270a04162fb69ad30a7bf04afd8405bdf351d7fd059859d34d2a145ad21a33aeeb731289b1679eb9c2731f6fc30a3e87553a29fca43481bc83a6fa9ee5d960bef0287e74a092cabec59037f7fd58e822eaca72454e55b0a0c48d44b1b4f79cd5b5e39f048191ce70220e44fff787a1a776f1d723face0a180ff1d21b359b7086e13283199c4c345bfb3f21b4dabb367796c9ec91a15f7f978fc4a946f0ba0122db6d08c372a5e772a59b223e3a69bcca97bc89c567437f86d5aba6278ffbadff961258908bed6df1c9cfdbf6f86c4bb8bf3623b65de4ee6620e28aab28544c1d2e80b42b785b2a4ad31fb20cc72eefd37a1b3e55351aba564109616f51c502bf00a0b72316e52345c734a81b2597b160290c8bcee32bf2feb158d80f927a16e714d47cef637468d7df07963c2348b6bbe09ffa6e7b515a378738227b69e8f2aaa529d847d767a07fdbcb987f6169976c7a91864c5d9e79a646a1d655d360e21c88a391b4d76015662005f6ffa1d6372ce32ae5b4d05b0162c848687530a7a9244cc2c88d31e1b614311a062713c4153eed3178f9ce27847313a04a3b301701eb8c0895caa9b6f815c42feebb2d1428d660948ddb2e6a873e508820cb414a156f2b795a6dee3ab6dff4f39e2c49d0b1f0fa1875dfca12a7791cab010e2ce2dabdbfcf4cd1a5f47776cb6b259b44d4686bdaf96ecfaec7e0d0903a8c0f214f9cf7da478b2b14b3c2abb59b620a3993797373204c8b12e411d22a59b7a40db101f062b3eddaa82fc6fe332f8f57d049c36829eeb07123ead64593b067bc2ee8666d97125fcf051507fdfcdd4756b5d041db5c63c451eba634e6dca7b5246632c5223d53a7ff74d08560a81a1be03a7f57de7ac651a3b1bd55a4e02bfad65daf5a5f87d0b7633a7010e45de17e2c930aa97f141d05ac80ec8e3eb01d5da778a89372747509a5f06b5d290934eb3a25f7c0bbcf0a75f384466f0d80d2f407202062cece110c943e224db4a06daf351637e5b2a35ac5c3bf2f17bb06731e4fa0b5b899df998e522915dc57060838f4898625824497e0b3c249429fc3a462154415cd723907249438cf19d9a1453e999ad2743fe75c706b37ef6219d654dcb8ece921e6106b76e9e92b0ad2e4971184616930a8782088db33a1f0cc45688d5c58cb500f240d44d271995c2a46f7b9585016d8f6a888d882e58d7a65b57b5d784319d142bdc219f80339cb142c2e71577defa31b89daf450109bc0c884ab6ce89bfed9cb5f62796fe2b8b8188d552f3587a322888f91d26883a2e0a5c4e8207d51c1fb873c844d57db5bd45e3f9b6726773bc60d2c852549c2ac53598170c1378846b36a19d27c426404855e2e74ab7bfe60d9da37be371d74b072c342604c042a56918347a6881c049d03b55bc053eff2d53f2a5b8b05f95fd138fae8c5bbc2335332cd497d7e978bac67fc88cec3639519a8b5977c99e2d26edc454288338bb292f9dbd587be0aabff43f50b7a461370c43acbd4e6814316f4ea14de5e10d8b377e57444c886bec97e186af7cc5fe601ed19e0f52a83939679e3b1af86da96f1d02c48e70eb915e73c516d3c5f18c855b712f3e9ba624b3115bfb3bc1639d97223182571b8b5e37c5bd98d349f36aaf76296790c8950faf882dc70c0f20d34409791d49b8e46f7147471868f971174ab006d6eacd97d65cc179146de4d98cbfb0d2a3ad76f43835fd613a7fbd6d00b486e1396e9199badcc5d2cc523ba343ca8dbbaabce89efb5c2f32762e198777852668c39c676c7afa30993a4a7208e80bc352756128f06a9b887e33732720face9355a35a2dcfd7d90c9e758748069401b32ac2c5d4183745a5d3e36563824d1441c7e37f2e4972390017dda65addffa40757ca9056360fedf899f4ef8e94e4bda050dfbb2b779676b5ca8ae23e740caf852e66345db832c09b5f016724a6e733f5dc17e914ae64d8575979e1544d687e8e208b9cd40b6f362e31b557ee49d052cf55c5c59eb85a2d7b9546618c61c2594499c7577ea475795ceae8630f7491ae6f8a4c283d467b1c153d21953fc411cd4a2e95dd5e1e09f0f361b265c15beb590bed6054f3d686fc1ae58ea73c4f000fa04c54e347757d476a9274121dfd219924738eb806ef49488b38fb499b57c9950cd1d281886e6776abd6bbbf87202e7b1465acac8b7e23a8405e84a91ae2488926d8e4aed3b2947a0130888ac32af238b5d0dda0d1be947d1ac1ac570d6169982da51782239c2f05e9166af62c0a5515922f80265b67700f851d98898a7917310e9e0a2a1fed785ba3e805ec3dc62bdacc84387c411beb329091802848656b0e2b3caea34c67bcf953e7496bd19be77ff04eaa07ffd34c8732863e92fa179a1c3f3a4d68dd26cb681e801a4172485c25646cfae0e671901efaf7831f7f85310d7d440e9ff779014509e29a6f3ffef206a4301d9252872ddf8b2d34b38042f5e96074e0094266b6ca9904d547960e33585192cb8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
