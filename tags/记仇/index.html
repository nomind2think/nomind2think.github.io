<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a269dcc1e00f0c9537dd018ef7db0ef510d352223e5901c510ce2ac95a7676bbd9c70fd988c7d59304621328f1c27580f659b75c0788c62f4d9da289461cb168fe69537db89b9b6375a97fe337ac7bc627c2b3f412dc940bc61724f6e1a3a1cc20d87d0bdb791703c9baf64933e4eaf5c6f900669518a8553ffae6e6c0194351e9b574292261c64f2c41707b027f0d8cb3f2c382b39c25f79a811728b842b6b219ea5fe1be8b69b480c8f91ec7ae1924347c3809a35db028a0177c411f8277b10d9e992b42eae4ada40bd76f434f2611e4cfb6357ce3537f7465521e05d57c039a737a3db4d1fc0f56de53e3e085adf6c5f29c7b0ff22dbecd1cfe6bedfeff202c0b95f4e3e6f908e08cb9b0df4c5a9cad237c8a0afbadd1f9ebcca56d3ae3e7e903cd84c9593426114be8962bd24a311df8a794b6ad02c105ce5e13033a62a9729e75e4bbba88dd088ae4d48c6d98d918817cf5c8627d61ba3d568ca5524092c0288ac4367b2e78b7fa06697442de957e374622743e0e0a845e972de0ed52689a1d2425801ddfc5941d8e15da01f33ebc0ecb8689ecccc0c67e8866ddc40a6c46b18ef6e895d2173f38c73e421c679f5bf560338595842e48b4ad1ade9d0f0108c0cb1e228214ddf0a71223548f9381e3b638b3a4cf4e3d81290e1eb1810792ee504d5358820225db3de6a842f9a89ddec92c1e249c44e3fd619e5bdafc6611795f8584beb864a130aab17db673b4d5a7cad9b3b7fa0761bf1046a07f3d66844748dfaedf30c863b496e2d58d1e47b79f0f11282b41297f76ec6bd4ddc999dc47663da2735ac16dd3deed20242b3ef270b7c7f9897a44b1a30afa03912c39d32a92a2057321adc464f4120f3b2c3dd0f3524df36a16ee7fb0584ca8cc0fb50785f8e5c8f2d709d68a0aa366f9021def46683f1f407d5e24841f1d369c1705cd9f7647afe9ee48a3712a1fe11a7cc9136cf40c3a0d80249a85f1bd07d5881b51c0ca35cbc7601b2aa1770469f8ed05f0a04c79392b9b6f683fdadaddfc8753032e3e311c5cd45229a828adedeeb48febc2136a0d441ca44f55e86ad8a4cdd6a485eeb3ef1e65720b753507fee7f09bf0758f59bfb91899e70dc6a025861fef7433d9a059bc9554561a316f72d062b5a2c396e58237a28db9af0cb7173e447bd51bc339863372cb1eaa0de80b5c1e549b5cc0d7fda8e1b40a62ad66a5e93b7776f594d2aca98189685d799becef70c759d55ca63f765cdfd1b5f317317f5ffbf8d9bf134cb1a4d2d2bc453b8cf5cc1959c5c3eedd1a33baa5f168793b796b9d00ff18a3ff4867431a6ad1b389360eeccff0d3dda6f4c45ee886dfa6ddc5269e833569dcabed2f00c2cdf83e9d9d27ff2b4ac83e55712b73e12c4de0dbd92891971339db4ad6b3a0b6b4cb78b419dbf9c058f0ede98fc227e90274d4428c5c9c0dc53ec64b342cd85ed4bca0ab2c864cf295f486e854e71b9b296a43cab1e55d4023865af67732e95e0007e406c86e2925eb25f14fd7a9703d613acff779564adf2ba4667401473697551977be09e70dade97174675515ba9fa3eb334c133596629576e5c044682c3a76b8d7379b3b57e07f85fc427c1d214d89faab81d3a7bccf64443ea1163347d45ccede2fda8cee1d6c78f583f0f3f1e09ba8e1723260b70918050de6abe5f141e281f0797925c10e757e76ba4df8f82f155ab8ee340ef295ca4856c901f78193eb14df484a82e649230f9c38c498daa2dd345dc04afd6fec61506a9903073d0798d0ab4af8699c1ab427f13dfbc51fca284d1e68d60a6a6fcad6cc484c73223d55e32f01ab45b27515ea558ef0fc94bf4624bae6d59742854c9b08cc14777c28245f997c61fa00153734d93216966cfc5e18d6b6074e06bd747dc0497bb16050d4ce4cd8b90e3ce5f021153fcde8b5a5a10c87f016a8b138f30716ee59e6cc9d4ae737e7cd94afb1fbb4eca00fd553226266fd440ebd80e263311213e40d615119b5da838694c6976616ba7b55baa8550b40f430f647aa12c9a57ad7326be68027e625cc0aee11b93df7ef91860a2047ecd4de2c5e513d8858547151c43e28ac7ee2e4d9b451f30486998333ff5e234c23718d6138d8fca46b976ca9b13f0ab510529b758e8381e02f48f0a945247c333217c02077c93d0b1e959d8cfa13fb290aecedf77a9d696264b05e826ee56d4d1b828474f5b1ce88f6d82c3e521f468eba27e9ce64b189a556561fb735a5cc23f34352457f5ed53f25f4837e190c54429f8ff43e83e9587b802111341a8a7c98810b42f55342e247c338ad1867f6c964964851d59603839283d4704bc05f0662b8dca85c14c80dd8a3542832b8a289dbc8ed712508f75652ed9c218200433e423cb0982c1aa06882f0aad335b612573e822e0e2ea2dcb55e500153142ebf4f47c371ff31e08668732a8b57029aa9d0f4c38d64691b24395ecde2ddcf1fd1e16cb2a86139e837f4dfe5c2402ac4a776af363a9c5153697ec1ae6f1edb2d754daef4558dc192250c3c8cb21bae5a9c7926b8d3fe64579b8943fa55b55f9b490bd738ced91cb84ae67a8bd4e4aa2fc4a2d6603a24d2cafe9df4616300669e963534241ef10f9c6b9868dbec06394217bacbde7b0a74ebf62d35195613f2d8cc560ed951603ce2fc16baf8574e4a95c7a306bd7e087184159165b10980b604cf87b8d5024f1814ac236edee8de5c11f31e4b91e510b441d7a37cf80ccfe57e2a6ee5b4be272d817055ec32ce23b9bb1ca890d38ebabd8ca6c54938c76eb9692d06a6d3765bd26c0b4d5a75fd71fa8675c582d04509fc3d9d5598134434391c6f7ebb75a747fd7e74a4b31125aa3500904005916b67982876a2c96a59f7250d6d5c4bf551749d7448f61d40c171a31aa77e30765bf1ef5b97332f26c8c5b726293807503d43034f483ebe6981c53e4aba0843d324fdc7c893db2f4b73b94ba4192afa8a0a2f5d7989beacb4a15b575bc919fac74db8c057e3bc310ac2324d810f5ce9e6c89febd359508b4903f1c49fda27ad74a147d92499de5218d6cd49117e68aa268622c64bf2b7e4e02882601a9da9d8bbb69b2c044a2a0d3f9579bdd926807abf7e991f72af5ffbca69aa591222d4fa24677f58eb40c2310061ea60c0df6352a15959c79f7090ce28c35db64c67da6d4342bec2926d466473f68f8628a66919cfabbfb04f93618d20fd8af436ca582a90b89c566e0abce84460549446daa60b02003b118bd13837af3b44f354ccdf0fb891031ad5c2cc35bb485ed1e35b363e668cb35792e83061990b3dd0417a379b8d22f21a7caa5e8b3db9191848e3cfcadc0e629141afd270d054f713b2561b813cd06fcbff8ae25089d43f7c93ffd5c6221681d77bb5e934019fd8b239a8f758d083c7b4597fdf2b00fcc1d0a5f10dee6464e4029a9c592be9ea6b17c41595901aebf1870a914d390be556c819cd77c88cf6ca21d06290ae2b430697e4e78e0ae9b39a6597d8642f21448aac4adddcfb0b20d8e81af579c852b1229a18f509ca056241c3375229dad64f69d1822a6045c05580e0221c879fb6d2ba440b904d355734dbfb2a1ec49aa8cf553d1710dd603cb158e6a7a69c4c6ed13b1b13b471c90016040c88956f246b434cbe8aef3e78a5455be72775a5f0dcdc157688ebb1697fe5c923d930bd70ecf82489929d47566d7e743c32e2ab5dbb700591c64d900ddab188619109a2da43b31090637605429697eb7da4baa125acddf93c68594669b573ca80a83394fc64874742ab49c83d8431b7cf6acc83bd4a92123beb71c3868628d83fb3f38b238b748c9c6f93c1e098e28d7b67bcd93c2fa5afcff640b34b96145ff42deaeba2886547fb496f1d71edd817a66139fa19c0c96b2a52c2ddc7e295a3ed16ffd9319eab046c729fc4ecd3518629d4ab246f34a7b7b9a85dc5746a325c6e5dd916557ad01e6046384f649995616368d55fece528c8591114721cf035fc683c150aec636cc22745390fc6862bf29fe1cc3400a97b7b2d65410f19ac383ac3acd5c9fd15f30a75c6931211548b1772e87489ef698b3903417d88516f6f7a2867fecb3b230668f199b71236b4b1b30dc83f7acd485e6091d681aa07607986b4c68b438daada3bf9182d37dd3233fd0e08a452ef71aed71f51d9aed9ea5c604149a3844bd2852286a13d3f89923a30fd86117a37cb352b177317bed3edb2e3063eeb0e58afc935cd59ca8bced14bc472675349413c5a9ab59c7a8e21b15f505fb8625ff97e64008c8487c84471279894b0ad677c4df1831b60c59a4f8dad2302b835505856022cd0d96f086493909697dfb8917c83467c2f5d907e7c00e3b4f602f3702e8afa3d84669a911854ffaa9549d5f767aa57ccf94c1ac66450a62fc09e12a55efa9047f7bf24103e8edbd42cdeede2311aaec910cec9e1c547f5f61ec22cbe9e5506ead6151f2549805e880c608079633805172cfc0634ba2202a45cf8604da0592d3ec305e79fd209d773228fdbe7c589b6d5a4a052c110404151071b1422ca85484c145b6729c37bc0e54c76d1a2a5a99f9ff84b3fcf8fe339e5cc5d9066fafb74a1e2829603ec6233d72a347685616de968f6835f393a2ab8f46dcd362099baa2456a1a7a70f70247388018383fffc89df19cea4fd6830f31e42416c5efa32c0ce32fd3ef030bf7a185f368b7c87f1f9e0fe25e89529a92f403de809f9de78562f5fae8080e6759b900c06bcee53ec8098e08409636842373f195b30cede39353685da63b6dd77b63bfd312223d528f3d3dff9f1bcf32f5edff37cf5072acda4eb2b23f4ac44481d5aa9386653c1d6b8719398c869cd814334ef01b4372cb2660b9cdcb0a97215d674c31bf011aad4f52dad13a275a7d46fafe8bbcb8a3ba071b9dce66e55fe1823aac0fc5278d3265857d77428bdad1ff95472470f1770a74f95297941f4d6eea8d412de0e51addfe7dcab1a25b356ee5b7f973e8210200b4a60f4aaed0ddd6e1e5837c20e5257097f3451901663f15fc95183db7c072b06d9664d9d1e51fb99a13a967963440ea0d89a2b24ee0413284ff90de48eea23b5664f42c55aef0f5ccd707189482429f28e4e09dd05f5bb6531860476d0503939f19239af45112018f083224d908edefdf8e82cd3b7654b98e56a83a0a7da3975be2b93e31171e301b76eab005c38ae04f9270250b5f47bc7ba8297ba6ec98b4c0fa23d4862a724d4a9820d5808e046e147df54ee54bcc5d246e963481389600fc2d10069c4b25711908ec1b85731fe3a824a337e3c972aca3681eb70b5dbfc8a75aa8f184f97e4f2af12b61d4f6d313a0d3d3c87278172e870b0203ede65b3e85f01a39fa8f5c961f7326a25bfea73726cfcddc7c3ce932ed7ec731e40e50d1cddd844529b44c74bea323aebfdde0e2385749945b4bf4120edc9febd170e315a672cf8f3e5e2bdd0548f8e59637cd13ae40b4e9fcefc26ec1612b3082ae3839766f31b2df0d2394943752e23d923488b2fd304ce618a24ffc58e4630a6e37c45bc5987fad25f222e85c714d5271de20dc5af7cd11f8d239b217bdd923c8f606c472ab23faa0d1999e0c30eba0c3e6a42d6b1dc7b6711c342e8f396b327fcd1ef5b9e57465383f0e865526858cfd328fbdf7bacaff66047bb9ee4b60545f222839a7a9b3fb8291c69f92c3f01875b5209d5fb3a051d96cb2598f47110f5d1f5758cd45184b96fbc5e19de1f0fe37d0b7873e3e117139b8354cc26517ff2d73db843ec895a99c270ba1a0f2d2443756c05cf810439db9c74306eef8e294ada95c63549a6208db1e14d7a6523bd5b991105bb089e6f956b49a29842d6e1b5861d10f3551cda1b51119b1f73529da03cbfd39cdfb4fec1791cef00e77c588f442ed8b548b89099f4c82cc10a164652a43d205ab1364e9c3f5bbe7894d02d2d6766e813335af97100d6d844a87a32138a888907fcd1956e4389feab6e150f5f3194e36dc20d6bc9b20742fefaec40e1afcb10ebe48a720470736dbdd82a1511d83a512a4bbda2b15cf24d98c2c28c15347d2fd01d0526c8bcc11a9320dd0551d4ed520386ab43f3846aff7bc9130962207cbc0429bea89a9b2c0d7774a5f8944fd5af3775c1cd9a065a9175965c1cbefd3219465db58eda40b576321befabf18f7996396d0b8c02dfd7eae054adfc4bfdfc9791da6d41a414d9999f195ac08347e28cc8820413425df96acf50c435f98762e8f3c83c2d1da96999e2f37fcd1c6a300b1bdb220e85ff951080e9a932e5217068297bb7d6c2b911bba5f60314aa121d74d29e7b890714c9306ba408c38a301def428522c2d2cfa5fcddcf6026b964b0bfbc75ab42fcbfd6948a60c8113a875ff8e88bae8767970db3acb17b7f37d0bb084a02ea4e225c9516a9f11de1235b5160de644265d43c5477069c88ff10874839a11564ecad723ebfef1a3830ea905b697638b13fc6a2d711d79917e302124110e7a20a5bbf8a23c754c8c347c5a1f70b9bf80026fc43f7697e62777421d3050d5b7072801316534c9fe5d603a9886022399423058818072aaa018894b11469c1bdcbaa1f486571812a78d3db1e888ec636db291fe5e8491d7f86a0ca9d7fcb01d3a304d39e4de27322fc676ef6aaad554b219c59c5c364badd11f861155c861ff44594bc3dd0bd3fa658c7ea6109767a1d727a19c7ebe1f987a070154eb1ca581d57bb32bf78788e18dce3516cd124fa3726fd322af3e516ed240572ae49132b266490e4f7e7ce2d00db5e5f9cdc2efe85706426f6e09fb69585f53537cb00158c1c7e5ce364ab41b55a74c89d468262f7dd3ffdfbaeb106a91af87c41fa33f8f3a35ca49cb3180915e988a7b8b0bf849bb2a9cecbeea7d6241238604a45d2a8436fb213d5281cfe7398c0bbb8044548f9aa36c3631adcb69f96086c27c77614ae1f6d2fdbe3a6911f618a662d99463a4e6b2795495cc98c57e9842f86138f7d45987bd51a763d765670ca52075f677e0f76a6980f9f822593e2d75801c483ca17867812cd9d9423b4b588ebe3109ee5d0e9aa8794a5e3b90314bded720fa7841acb72d92bc42a2c3bc7ba3982b7f1c8245e8815324b345639a324a54aed746e0961c14b67a052c01f87dde0d6813de627b5e5488960bfaf4192d4f025be2032c56def784186f3e04f2efe6df748bd8522f6cb098b33d6cb2b4a0ab2e3474a18a58ed93b0c444ae42f3389e0ce060b3dcc330481723254509838dae5b21a22ca2bf88e6556232f99ce1b730eb4ddddd7fb2bf24f86dc67048e77c714c87436f950310a2c8547601d27edfa01f6b90c353a9c2f446b6c1e283d557209380e96cbf7877c0f6ed1466e81e9fbf0c6086ebae1fd4faaedeb17f5e3eb1e9b322721ef48156283fd7b9e029e28a0ab97fda295596da95069e55a2717dc67e5dabe786d98ec78e6247d2bb0aa4f1acc74cbc5066e4e9299c42885ca82af37ff2d5bc448e592c59335ee30a17baeff451004c13bc6688566fd246c899d78975bd03d3220a2d1aae92070d6d0cef916ad2bf08ee4d3e50a713aeada03dd06d4f36576dca049b6de726e5fe5ae08b8c8f41f7a936ac04fa97ddaa0f8f6e6f7c431f019568a1ee7ea3a4f6ca3b997bda3db69da1e9cf6c39a2d31d5c7ebb24697fc4ec3733d0409ef2687b1d15b5cf27792f8e3073f73b10e9a73fa4be6abaed292dbf10d2a5c783d90aed324ece9e1775a1fcb465bfa2eaf93a2ed7ce3dceeb5ebe916f208b822da112f0a493fdd80a13ff81a8d31beb96f68d00f963ba647b2223381e82cdcbe8ee9f585f42ff43993632fd995c9f2c430a2598237ac380d3dd50494d5bdbfe70cd97962f195fc8fe44e6107de2298fd30e1c981393f85d6b0d1ac5c89d3e1ba6fbef96e664626789265a201a56da7d52886da9bc8d32bf34e59adb223ce8aabdc1d37d03fb5162bb25ebc65787fee9a47da577094761a94b7c59a94bac17608449cc10cc5f34503f72c0a1106030495b8bb7d3c4648fc7c44b781805d5fc6f79c4728283c33f34f685b45bad48af031e9bed353354ec8c73c0082eb5d8553ed5bff1f90d79d03286436e95058257c667ffd126d8035ec47315b4e106949770df36f5cc99e0ade737d975f6c1347e116ec57d17de7c6b5c2bdec691cb3ca6f4ba1111a93bb20d6a996393873df807955d85e356c02832234be59524baf0848926b8829645bec594e274b2359aa511e0d56dda4d537a497f8c3ec853ffe854204b3365ca10338a4931815b06dbd2bd174857d07a36fb4df93b2b9c9dcfe1de43414334ca907aa0fe823177be059ae6d8151a9ad2b6866eab81af0c721e61c02bc5ec95c18e30f92194369f84955cf82f77af42b78d7db1b026180ae799c8cc8fd3f78db708e5e8e233085c5b5d798601f6edaa2e7b42f00d8e3b9018f6e8b36cbc860caedc95a1f6d687f99e121d3ef243089b6b534a7806a977bfa42196d381e2258a0e276555a0c2aae74207fceb476784f6181602fb7f89f17212ae6597bca269d8261a8d5dfe56e556a31830f66652c5c8ddd375b7826d33f3b41f0d1d0b0689ca4829a9e875db0ca788445d1bcf58b82f560d0db7a61645affee620354573e1484e364d665bc491984a3e04626c598a8d903f7d8518ecd1457343620c2be3eebce6badbcabdfc0f0144650e9f9f7f73e487ca77acf221e0ccfa03053b4c2e8c42db478f4ece71dccb116ea3699eaa97d1863794928940cb34e55d597064b6b1734706fddc4a284763894e00af4d12440ceaf4145cd39269f9c1f8600056540a1e5bc5ce940f76f4ec60e55920cc29e522466941814dd79c5474cb6305723d0ddb210f81cbac8f0d98dfacaa45fa083cee7fa09991ff69ad4e3c6ae31731c00b1d8f9349b7d399d3fb548c4d384804312efa04e00b340b3e46fd7a3b1d3ad459fa1829aaed0cc574489a4e580f7cc2db1c6fef73bba4e44d0853d713a1726f95dedafe384d07697ebda7154cf9c7a98c3ce8522bbd51e45129a9b5b68516a91ce4db94b1938947ced54b53a598c9e308270245043f144cc9ef4ef9dea433d9152345ba4d332e20581bb31306371563151e56dcbccb12956ed149fbee351057c9f7bd75c6567fa8fd151c21f0b32b5eb84374d8451bdc1694d1eb68e4b74c2ed9051d904d90c875e753269051448ad889282f7b227b22232ce0d774a6589bce84c9fede7869c8f3c02d2fd8294e3955359bb847f529e374f64a933042ed57bb59c10a3c24c7cb2a48ff2e10315dab8815d4d3e7c3c3bcf3677519be55ff21379cd279069fadca2dd3387600d903d8d34e5fce9675574b3211d68656f49bce6eeb0d236afc5c399f37163f3ea4028318a743267b8fcf0d842cb02f00063abdd3d058f5f737dd001f0485a658d814178cac73a08f22d6085bc641e60768e81fc461127d7fb73fdc1b23a8a0654c3b8abb02aa5237d4d3af1237752f585e3cff9416e953cb03242ba9fcbf6f7b65e4ec4ff57246d24f04ab3d768960a1f19c809eec0e97f90f140444a16edde011972073927d54e6b1d4a00611ac4d763a021d9ad79acebde33b5089641fef6df1d41aefd15639fbade7f8ab0b1a1140ed37ae39d8df3f19f625f1597629a488a967d22b82c2b73c1debddf81f6ebb060ff800bb5f1a77c1babd6e2ce07ee2545f37f8d3e35a6a975965f56335c642cfc0ab0da1c9e9ae52b1324b47b5d38793f5f68dd25c0bce218d4e858fc98fa5bad9f3a143cc9eeedfcc2198c850281b0720ac8b9f172b07deb1ea19d4b11a66f37759f69f4dd5ed36dd96e21514abf58062f15ca0af537048093ce830970356081bd14c072bc30731360d94aa74234b5b2a05a3f0e01f2fad4dc0ab13f3cc088d911da2e802b72f96dd1a3af5ef90f1f254c6a5ce14149e0390712ac7bdb8148ccfda9b2b0a9e601855e37ba1383d928f024200a6de48db535e0fb0b7fd4543ffe2dab4dcf07c444d64f4a851548a251f78351f2d1159dbc659b5e72d1796da3aeffe74b5c51d09494baa7bf2b2972013d5102eeeabbb0f5d18a4ff1127b143e5b4ebccf7497999c1b3af8e67b24fa44a9d17589aca5300aae7a1923dc7be6deebf2088f2b9a43fcda810f6d54aa48d7bf0bf9259fc65841f5bb3191504eaed206231a7d650ca2369985048c8a8ce9cdf8e8e49ce577c792398c26d995679573409ac7d7e6c7665aa16241769cf250ad753e7ffd14c8853cc6ea4fb772c3fb5e4ba058ecfc0351de09cab81f6b06225bcf64dc65243cf7e1a488edab58e268ba0867246fa4323b3009bf88fd48b3f174f97c550454c05b629a81b386bc0620a914473b176ec037e7616d9bf40f2c2aabd8977fa9cb7fe8f03cf8d8059d70dc4aa20cf960149c9b69331e4be544c2513f8eb7bb7e200553f64084d194209c679781bffd9a80a3476963d70140d98eeb6215c1fc9c0ddc975a9903287b15d9dc486cd03cb9db6e195ba13c7dc90cbf1236714d8d0bb2ceee7ac022a1c139f78ba57241e7f3ceff95836c4c32976cf2efcec4bab33c18564791b03400b7cfd1ac602d1cdfd7391a94b1b001f34a334359bf2a279f46fdd8cca8b868a88e34724b8ea69a9cba5f6c4695253be4c4f145d8964d7bcbf3f3fe2598426084395191ecbb7f4cf4fb546c6a5c1a9f072af3a0d144445155d3764bf582311b48b17407cff946678a22f16bf99c9cc38074724ea2a59e0673f565d7cd511fe68096173d4e6c59dd33ca8d5f9d70623b5bec1d07f4fc388066458f206b409b7ab2c72041d4ffeab42390f5f2abceec79e3a5a06ea320bfd8cc01794a29c71020d85e23ffa00261fc1a0bd4cca8e941b430168e47c25fd43f94805830f6b9fd9d6baf4de06843f328a1387d565125d0c9a2404a60308d1d5a26553e7020afc24d47203e4a3c704055c80d0e83dca53e20fcf29ad99be958d189df336b07a21288a7e7dbd21f1aa85ff480672b0b13fd3b8fee3350cc323dcdeb0b87ab7c0ce069377bcd441c27dddef22840dd80253231186e649aac669c250a6ca138dd5f515f95b2425ecc71d8273c75aca90c4ef52455e3da6a0cf1b370310c9e4b2b70eeaa7cfa6882299a7eeba143bccee8f1d06500c88234ebd9d9bebc0f07eb532168da4837460a530051c10d7c8c39aa85396c9a117e3ee7d64ca3c2ee62c796d7e770d57fa26352a225fcb54b670410eff466ea11e7a5f72ab9d15f386ac357f52d132f5e4da330246ba31efc87791be6042963e7d89efecc213e14c09a7370b984be83ddde11fcfa37dfe601d56c3892f17a6908a69ee0062ba8348f4aed394d4d53857d9a531ed81692a918e8aee84ad2ad8f20957c8347eceb9e134ed019c472b4b111d369626da71c1efaa217e736b3353398a0982189aa7ae254b29049a372bbfad2b1b28f483e7759efc4efee45a452c3f53bd4cfd05ad2ec5132ad0eff9f92b379d888486ed86f8cf10863074dea7131ad55719fdce43aead87173ca065e234a754afed23616d2f2755915551b45ca758534e4ca0abb63cb1c4a8f53708e978c61fbb67fa29596ef32e61a1bf91a705e3109f861d4061be898847e53c0944e8b47664680a3d9c856e46bc5f82ccbf03d3ba68f588b9dea498b835a9ae3fbfd56b83dc12c43306999108f3dc27dbd2f4b18e34b6bcd58eba9c5c6b7401874a41efcbca9a5353dc44913eaf2827d832e726a38baffe21de8435d81b7d64f841d3e828bc6b87923d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
