<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7a52346d3125f41223f65076e1d9ebdf636fde7f36bc1214e4250c2b6bf852726fc36c2ac8f5d0a2b8a5e57b700f04d774286cd92abb7e42507bad849bbb2f14f919cc0005c3ec43b6e88d22e8bfd5e169af5fef5ea10adc9496cc391b9e8a99415249e0e0ef9a415ddcdfb0d7720ecd5aea0521fb331b29957ad81db8d7379fa7f5f593aca97ef77304d118e334dd24cd5450a5dd84312156de9dd43f0baf6e99de195123b3380a48241a573cbed7d77d6c41b3bc757186133e3f90bc7efd2156dc25bb74b73efa1b5e7f35b543917bb8779bb88817c72384f89f29b7ab6ad272d85d95567d8723d03ff6e5ec0f373d5a29524b5d0555d768a8c74d935c3415d491147fe44a724aa776284b1345c3907a6fdef6f199211acd7c59e5286ddf1e248a094fd121287cb75abb21879f23efefb4b3d2c3b5a06226c51bdfdc33cdb6fb34fa6da5e8f1c36bd0ad503c2298d9b2745effde364f260ca7e0af7b3ef5b0a970bcb6137696e8fa8e4cd8737accc9d9173280505f0f9851cd1933e2d91d9c8874501a73a6b3fdd1ea5c4dbe7ff76553072fff765c944610dffacb3ec4bcb1493ea6ab2d979f3d58df80766d423dbd804ee577937ebd075e4cb9f64a26c3fe5848dca8433e11b93cf1e1828f9e3027fcd32dc7a3ed960dfa6967ecd3c7b98765c36685c59aab6173f1810b57b7cc83b4f40b18a594977a3ca3351632c8d34e57994f7bb6e304748e1736451e41b9ffc18009b04703b1326d094a05292887286f0740149f002d93951ca15263e3409f72ea028b78af471c864b417f1ab6625ff4b5c7152178b7c97c66a1f3cef1a46a08e46e39ea2e117ffe85697755424e9e6ed368183c65fbd7af581c4c90e007d5e41ddd55be17a97dacfcc6ba595f50313018173be3204b541310058ee9b1a8887d69ded204966a0ae54ef122b8d27aa102b86969368a0ae3dd78e1a4cbd8a841187aa60e7d19c57a137db6acda3972f8d651a5ddabc8b6fcdbd7f322c5e3d2482a41f44b49f5dcce7a15829478b460811e84fba9ed759b88797bfebcabe5ab8ecac857198e1e4d5233aa783ac79b4fc05d051b9a97276c5060412ec5d19252f1d9de5885766f06be5608f5ab783a13635ece2ed1b020bd8033f8a59f6326dcb2c47e32fff3691e37e69ade1597308a70dc5a076b98335f3a23724969ce1cb133f06cfb7f1f033c9ce268e7c15cc5cbb3625fe34eb7224a5021d1051878144110755df3d1003149d25e60311e3d7ebf98776893d0cff7b225f60fe95402a6452ad80cd8523fe0b948ca157c39953cafeec6bee167ac8aacf0acc860cbbbb4f46a5519180f8737c07a0c776746de145701ec955d5b85a83aced21c8c5fd38f07c01ec4c49d4bff484ee3b6baebf0d274069ec80568b705f333bdf527602355812b371c4ba08b91bcb0c198d08589e6d1515a420d16dd9d11a3f5343f90a98c05070ba02439ef5b6767e77b11879eed4ffac49faedcf7382938932bb97fade92f8874cddc80043356b7ca889bb4ccfbe7f903939578b79d7e454d71392c0efcb1f33a92ebdcf9979f55bc7f2fad284b2afd8ebe69de3409300b73f101e8626e730833abb89aa7bacc3dea4f2e500b091029cd835d4d10dbbc971212a5c76357169de26fcb43b64ad4b829b0b0c29a5f063fcc91631eebad2049b824d861a7e00e8b7b05c75d08cfc317b0e75ade87daccbe5352dc40bac5b0b9d29054db0f47b5cd23c1e4f4f9195c6b8a1664066707766786972cad3e4d4b4657ae5c8dc70c946236c2ecb16328dadb5cee90ab4bf81218d4ae8694f94586be7f399bd6191002e3daa64fbeb79553e004ab4892e779ccc3688c0b18ab73f342c72c965a2c64fd4bda7c88d5fe40d559bed3afd1765d47225b87cd32b400194518ba09e25fb8b7c5ad56d2d413ad2f58fd9109eaf07a66f642325488572eff03c7b70058b8a669386207b37497f235b87efc2cfcc68f825f6147108f9324bfb08805d1acd914ad02793bdeff2716a24dc732706f66e491aaff1e5ab7a9fdaa5fc7b32a9e574f377ad1e03a948fa128de694f9f95d722ed9b46178cef462a4c39737a5e39c10d6b4a4ff05b95e22378616073f39b87448085decbc85a4a38343d1c0155eef729250ac5390d8b60ad9b1dce2890328ecaf1454f9077fe1bfd0caa4bdab39ec969dd639bc18fd1632e4d90b43ee9d7ac68cbe84a5b4caf2034f6dc151a56669abb2bc3c8bcafeba6caaaf8e9e18f066943bb95e7569fec8ea4e64e0341d877df57b90e6e74e76e7531bf4514a1ed1e352726f5ea96d9aefdf31033df9445e81618add996243a87e531c324184becc748ec7d305e49a7d20d9533d42f750ecb2280d10e7584782185794afa92c1800d7385059f85834652af229adf50990798c2ace669696eab5cdb9bf995d4b828f1b014c666e5a174357bfd41f8b6bc7c0e37803206309e218629c37906a25729b326a5491d1c18a3103f76304b51630e31d3078601165bfbdeb29544a0cc8fbb99ec67fe8e13bd45a9ec6894d1f079ecf3f7df641ab7f4f76c8562bb4951e634b01c1354b8594e75aef5d48d26512361de258c566f3a819188ee481a6abe849ac5f31219272f3741ee5e3f21dcaa2e92e8bcdc89e0f3c62e1602682f1a7c07e9ea329fbf046107dd6e8d39545e6b677420bd64d0ec6b0202c4417189f511d233ca1a4abc51c4f7b3466e073b82d7a86915023b9518da653770080f26dc9eec6b916c9adde4907bfae8d2ed667ab23ec393bff96d68ee0c5465a7f38f2671647a31ca52051df9a58e0acd5c0995eb3f447a3d1b83967c09d8ca61a200e3509db7fc660db27b12506f36e540463a69debabe81b4573312b7f5923b3508463629c9a933c0bbba0788617c4c97dc6efe7ed146cb31d51263738e681b20c6c1381bd6c8a936ad317977cc0d26eba1e84544f86344b8138bb037e3fe93a2caf697dba1ba18c29ed935b9d9ec53ed937b7032e7ec437a4c32a0e8aff656034d09655a98554f4227c5dca28494138d69b49f2d1aafcf0297932e244e51c87fb9c6d5e0e044bf67863f948c9ae091eab41ae10059e992e0e8935c62fedee4d5ed4712b06796a6adeeac04b204fc14d65b4793accf33b7cbeb95ee22edfc978000d74b2e6c63c328b107446ee996e20fe2f4309df4fe370573fa4db52727c8aef02afefc75ba5ec72ba87ecc64ed457c319f6c2d0632aea096c8fbc4b0da0397272fc106a38edc8a86e61f05361d1c69964e94e0d3d496fba3ab577801fbced721b83fbb4352acd81dee7c9b804be445ae642d6f9bdcc3fcfa8b1025dbb623117cb0982f66d920226c3eda2f1bf4487822ea46828df8a8cf130e0e4e06612f26554b43777c363f5db9caaa32710ab42ea0da21d32de2157b148b5f66473f950bb53dfb19470f42d170c0fb916684121b61298da48165f51ef848dd3eb388e4e2b9d5389984e76ed2bc9adc162482f90b3f82ff832442a658f00225d45463cf8ef3061a7bc1088e7d9404076bc35c8f9c52341c6e78e12f7f5bb96f3fa8c02d8bc11513d0a6c5d48351d46fce53802b38d0ebba96c7024bb3582e8b16956e139830fcec3bd63edb175886278682deac6be5844d58891042c148f3f932d9128c8b67328aef7bd9c234f42026a8a7e9837c89f7c212f19f695a685e2759e3baf1c65f9a74ffa989fd0e057639d9d32e84eaf58fa64d2be9aa688210550c30072e86e9e1174d915ebf4e071d16df1bb8b06feab0cf308d54b4782489f9f91cc2cf810350248d1379d19c0df232b5d10ac4a95cc7acfa02c1371b981a2b67a5eea0a409058829edf0ec2a8848f7246c0f082cb3a5e53b58b519c2d22b16ccb964177c3afcd94f6abc5dc5a4a38c70f5269e2fd66bd08a00717c36d1b0b8798bd085fd858eb0aa5396c64d815f4910dcddac0c7ecca18dbb40c9f1bf36014786427e485874e846a8dd6a5a850489ed818c059d2ee9b32ecb24f1aaba17b363515402940f03c52abeb39b89714f4fb6d6b01bab77debf387f5c561b5f5475174960cf23e09b75fbb09593b24a46f15dec2d6ed6805a5e903bccebbfba483180e7b043917c1750016b129bb1b8377db8e84503d05432613ef62611b60e4ddb4cd3e8b1cba41190bfc59a5b12d53b3bc5ac354bd36922f4dfbe67aa6ebc54c85270d01afe2774bb51282f3690fbf2e7c419b3fbf716ad4ae7def480731dbda4eb7a0682523ab25ca6c5ded43a98a82be02934824fd0076bf0ce78d99bfc9ca44c2d694ee8bb4423e727732c3bb1f3f3555cdcbedc71e8f3b25a245a3ecd6cfdb3e2c4d696aa5c3b85bc76879b71ba183e4c3fb26b99d89640fb476408151ab096a8dbbdfcdfeb5cdf93bf9cc39ed1e7f60d39c127851b6ab32eb40cb4f42202ec96c2c8a5346a399432614ff94b0934a355b979a95b9324bd8198792e61516eb437fae0cdc008aac5e93eb9742c9965d0b875d2c24eefc490152037c53b53554386b569c02eb500f8c9d5e7fb4686ab7c722a8b76bd67359722f858fc8581552fef54d305c9f05d830178c9b0a9b87934ac4d02cd9d3462daac5fe96594dc90771e9a541458308cfd7dfc6c942dbe6a341fbc6a343b0625a37674f6f63be082d13c47e9022abb01b13b45ff2f044a161a83880e2da61322b433e113d6f275b31b9ace795cc629befb7f0a96b2636d9543e9191cc5d18dfb8f7741b1e697fe124425ba2b1bc4dd4429a8f800f88bc5ac97edac2c45dfbbaf08ec6da48eab86f936aa91d1100721287b43651f008978277649aeda50ac7847b3aad89743a7e9ae21f897434c4af57b1bb4087b91a93740cbc48fd36d047c6c7c334b9aecbce78ef22d2df1a0814e504aeef6dee9fabc65a60ec6b68516272b48584f25e4d2c087d116f40e010a0fe3855e4916fee7187842560ec567f050a874b83f1601e7a5a8a03be66e2baee33f404dfec619af7fc613790edc88b9bcb1165ca4f3941339fe2d70af752c53b88b727aa62e9a63f61e4acf49bb76a4a0b24c97a41d8d6d9589bd4e031276de5a0b8fb2e66a123b3a9f2520642565c04bdae79a9788e6082d511939220d38bd7d2ccd020b4ca2fdbea17b88a40aef1a84654b7f3bac8bab10b68e570d7c29564900dc536c3c4e57b0eacfbf00892f7b1686c6001dfb9338ced86dace2a81ab788d974581f85a8c0a06e1bcb28846f65895a2e5b7e2b67819ff44fd5a0d5774dca6af0c1f987f1617f5dd8445ec8bf717f5dea79b68ad0afb2789da7fbe888a76bf42cd79bdc60f5087408df7ca84aaf731f6ac760135f8e0634d4a9fbcdffad41fa6a833b0291536ae0be64bba505613da0a0bd0398b49097de1b5a60b382d5843573bcbf467009b835717a09fe3c959f697f7d588c285707f28ddaf94c43c4a9ae4e71a9196833de66120a45d5952eb18f0e0859abcd8644ef56d4f2d5b7c9c678f82c4cee18582ff8bee2e138a35dac2d50d22cd8a34f4d9a03a839a49bdd24388d7c6a474d4c801dfe23e8e1caa26b37abaf100357dd529271928d140b0a857c16840710ed9e8775ddebfb2136540558c9a260670f01b7d03dd97eda84879d90e734060fa89106379a2f2e5a84dfc1f07518fc2d9133616001a5b53357f4615caee4aa7a54ff408fd478f6c0aac408ae094e49c32c928d8795ed32fc76dba6b6de26eefe79e1029c7954e27c2c5a2a0678f792e1942591cd67d9dff5754e7599be41461b07ab7b626d9af7bd20b743561ae45f76b1a34296ee0347255b03225462a8aed677a0396f986dd933b9f25345cfa94c9de363b6e7636afe41d150b00c80b52d19d2e77c87cf981114a307708f3230dc5e344d789196bfce6e2aca7a27118629d1bda0374707a862c4719e295401cbf69897b343cd3068b1128f4c46cea43225465cf70820ef91e09a6511b3a378ff961be054e9fd306579da3610c0198108ef5276661859e32914485d4a30fbf0c6cdc927dccea44f4cc797fad2eae6ea3112135367280c133ae8a2439a695fdbd62b6d852ff5360724286febcacaa9502bf6f38dfa112058eb01ca23197b60562729003956917a3b4445bb4203ab8046ea4c3037bd071b798989ad845c0c663063ab27d16ce45e4a7f6737d8e7a0b07219ac66991b49f099309f47916f97cf989d0e65b97aedbdb411fb27446e06a1083266d0fffa6022ce5a39289bcd3c77ab455e54ff8fd471be397704f7dbbb878c534e39ad21dc30ed4cf0a336e98c9a70c56e1e22be5fe6e5fab5f89348178613bbc8e8087b6da12bd1c10c99f8f65888f4d56ad6857666655317d50c755e536724900ead580d3a06b2672ae360126919f7463e82c2c91488f12c78f5d4b591b37614bb8202f1780b061ff3f9e0dad54389d6f3f2be521c086a809fee80e0663de6aa32c08a1bfe5eb93bdf6ce5d06795b44b471a7f68ee813b47990a313df38883f6bfcd48935fa2b65eb80610ee490a0519c399389a0811bc551452a6ca5c2911c51c2c3104c5aa477f5a9bd0f0db749e9861f5b30d5a9f3037eeec093c7eb232858095e34d181f26670a936524cc3e973078f1a7254aecdff2d665b4e77a655e6dfa5fe190b246671335c0982ad9f201561a5a975b37ebb3d7aa8aa47dd61f04168d3d831fe586d4ff429a200572b5dfcc3323acfa7abcfac5a2f2723dc3da9ae7eeae1d1e7c3e720488f054abcf66d5670448e61aab333edd6cb834895c5413b97fc0cdb6fa060f506496eb4e12ff670c5c1438054f0bb525211d32878c48ce7a27f5a9dd6027053e5a902352ccca2f556233ef2b6e7c5c23122820bd7ad40c30be3d59ccc3af3b798cdcc812936e64a66481a51cce09b86f48bdc3614fc944f13669d015c902b5e2be0e102f69fb9b1ea934ac1f8a7052dd3ebc4e3fd61a3148c68061088903ad4615b6fc6ce755afec20293438eaa48831cbf065fae185651d07564cba3a0d5b803e525b75fac8df93723f59ca2a1cae399e019f63b14b2de015017a89a0785d0db1a519202898436658f8c85610239434ddf449b7bcf163ca924225c94854f54ab5fab274818893be3868dd21bddb5bf6128d36eef22d47ef276e836300679bde77948dc9387f60db8fd7eb09c3106aa67648f62c64c463b714646122851acbd11e97cf614a9508cd6d7d18d8be0e5d12bb5b490b506cfdcce3696b08cbc14962c9c71df66496ed1f80838af820744fdf2663ca8973cace9dfadc4225193dc3b48a3c7fb211767210c9d0c3f20cd9205fd14f0c3c8f3705c7a157d18e0d0a6eae5523e972c11dfd684808d516be81c668d7b24b397abe4fe38230c1b524b339d323b591eb773f10fe87449d8c9cd482bc2b1a48a86607ef09395eff1cfa5945648c7a26e726d9a416de9eee760ed843b5a2b138941dfb9e89f717e7e39d250970a34f86e7891df80124e76828c021c24aaad50074ca782b59b5253c21027ceb88fe254b176c3a16c8223477e3a61b453f6ec1586686d541054fdb14b9f5fda7f2d9fceb858f9c4d9c963eb1e6809828905988e1be980a3bb68ab273cb2dfe31ee1865cc4cd7b18f463b8ca485dcd4a699105b4fa45511ebc33c09e54b1579fa2cc57d28f74fe080b4d9af1ebb8a736d0d62c3027203c3fc64de07c6646cddb04c2f9d3251b33af44e8f83d7c38283537ad5c074da640e5760320fd52a5491a9f9eb91fbfc464ddcfc0d18d01933ecffc6e14885477d11ac8fa1cd33d0f6cb6f18bd53919a4ec533520a85255b95ab60579ed7b9c16a18f203e13ea40fe4aeca0f8a6e229912163e988e9b902744891582951600789ba898a3ed47d196e70f1684c31cbf2c593dfbdd6d948468a0e4d85e49b010f74285b03ec99b42dbf8627f16bc81ac06999f12f02324518a37d7b0a01feb10dfebbb32c19af4455eec6c854391b0c0775a8e53234cea965335a77fcc04a92b41459ae11cd9d9a48cef4f1bc8a5e2ac7f1bb30654c8f4200f00fd14f0620545b07f0aad00cf48bec571f23308938359dce745b8b05a6ef9969d714710a711850fd9129a8e9a61b20ce755ee5f2995eb1f966ef01534c332c60cbdf50a2e091d89f9dade5d450939e6f9345f01b6d2d33ff3c8e82c32324459529474f35d700f69bfcf9956445b5d4ac2966ce2bc8befc52ce6c31deaf83fbfd1589e7236fb85f106d0cd7708bfd54f4455ebb59b8908bf095373b297764b2f7cfafe783a4ea1999363d70ad3b6d3b78b76a09d4d3978cb2c7157e36ee9c0cc7156614f99d02b784ba6de8cded60faee741d26522a961290d8708123ac6c4272560e80ec1caf7ad672cc44613034227824a43c2b964b25e11f85c7fb6b5681f2911075b8e2752d5140ca3c0a7b9a97a3dc1a4b138d9a4ad277fb5c14465033d356e0d89911f922f8a6841a6c45ac82141c327fb156d283ab0cb6679489aa8729c7fbdfaca76a9528bf83c1661f16cab1eddb3662cf4347640c4e58a2ac545017397e39b5c91240336ced8824a5f019fe6a9e036cb6471fabede2db63d6a95633c385a57d693ccd9479ee67b38d4af834711353ecdcb808ee456ff8c7f00ae08ccdc30541c7ddeee7249cadb35eed1cc3a5efeee37d0fd049971b10ea64f389ea1a59c1e612b8cea71f06be97ef321287d156a14bfcc3f948e64d534820123ee30de57294cfd94d8146990531be36819590b027067e795f4365dab69f3c3cba9ae00d782044feb21b7b84606fc280ea2ff470099920faf4cd14a59425d63eec0203eb13f5e4bdf8f5c70bd6a07cbda9c2de373294be8e9be30217e3d0058af8bcea990aec0dc5e4daf6e6ea0953417041b1db483ee8f201a3f656568dab99c7203553310e8409e9aa6837f63dd6f0cc10b392f7e26ab910a71594d70cb3f4093c59ceaa05f9d26963c15f6eabc578ecfa411535a1f1770880982defba7a35e5ab010a2aa72d7808f566111820b7d6901d9f3af839cac0b8f0bb072751a00258c8aaf50ad9569b4758a89acb306e2724ad10cae240c1984c0b88c7e96ee3be664131ee43c74fea9ef344e3b332de27115691c6c889fe22aba03764ec0457ebdb94545dcbef6ed03fecc0a41d1140405182c76714ba43abdb8e01c381600c251f57e1e5fb0cf7d2a39639bb3fbeb98698fbf654f7f201e25e26e0bf91e37edc62fc7a4d5da092070a03f533c2dbf3328bb90a2f35aebaf2105ccc2a078d7a90dadf8157687a7f240a6ff79db6f34f5beefd79613852259fddfb0afc1896c6899dfa7773ad1433c8db3017c7535f7d31587594c4beed5d6a71da08f474f5d23b93b8456791d54a46d1f75201a0402030004c645603f308e02ec0dd53c78068b46efd1184c065952436e427443b0db066df375310ee21c54f553b9a2ddbffcf4de41a6dc952d624fca3354686de8a1624ef5f7d56cb42be823820f252c9d8199d256392af8b32dadd197bca89248ce5fe5df814ac5253fd5b4554c064fcd6910216f21564f2c5b80217d271cb298a1c4cea28c3f4d5d67545b5cc250a82f336f457a7a55463cf53e93349ee92c8cfbe7c94c61a3652a761ab1ddbd3a092e7a3f5b049c54b48730352fb51f8bebb3ac4ec7a1d40e3a03397bb4a8c2ae56096ec2fa5280e8a2d8cc4c7824bcbd4919edf13b80b4545757c424a17c9ccb20941d271027fa8fe9423ce95bae3a7ac74a659a2452a62d1f0ed827a9c45f3d2e0cce0f8176dbb6b0d8fe1092464d7713a4ad18678640aecc2852a9fae43415318642fc137fb6c61747c297c574b2b98f119b80aebf9d9566d0fec6046fd303a23b99655dc84d59adaf5bef5b25db2ce92b0172916de36e50b38a1ecef7c8a3703f233b5d977a3752d66025cdf8f06e16c085f236e181b111a140d535851d7daac1b9a8b811780485d7ebcd7d599416044229c83a112d6569c20d19462602d352eb1756402237faeaff701f19d2a235a5a23e0447ad32f833ed5f72a1b4cf0de7d0c882d406d0af5a967884ecf32e0cd6dd596ccbf18f3ebc942c69493caa111e247eaec433dcc7138363104d95979967319de6d8fbfc30dfc6be47e96aa4703145ce4673960b1652214132c547244d84d8272c3aadd03f30b79d64970997319e9f0bf4643f432987c3296b4a6bee0712d83e89fe9331fcb49c8156c26a4f9410b69df25c468e0b097ba676e9151e68571ca79d918c7c256d638b9067967be615ed581e13865dde5e896ec5a8e67c3978050bd1e2e4806e063d69b3f5013283dd5584c6c7904e93eba83dbe1d6d050553a955c3176fd9fb87542173f95ce7aa168e380d8140803f5dcbb5b05c33b5e68fac48ebca2ecf47c366d6ea8e0068c848699edc68b5eaea277a7bb87159b38893a06ea32d1e3efec709669e307b382c7c5581bf4e8a9ce35141ba8998030a454f81b6f03d6b82f332723793601aff94fd96b7c54e79ff156f912306c63aa80a03570766dd9b5a69fbde9b0e96efb98b8ae3119dc631135593a95758baf2db6932e2f3231f12c21ce986e14b38369abc5c92f28c0fc57a0681518f8cc42883334785fdf978bcef38e5b3a7bdfb6abaae1721531423cb84352f2215838bbbdc7e7a53271224e506581b8f2e77c7b021a2ed10ee86af1fcd5a0af6d5b274e25bf20489bcbeec17688438f8187a3327a1a5ab2b69376ab5db0f5d306d42a26c72e2aa72264e4e77ea883acaa0b555981edfbe7e37a2b37e52b8d44508ae8849c0845b479ec1d91380affe735bd16af838d9ff51a19b9aeaa93b77f276adc43c95314bf512e821152c7ded6756aca29dbf561a81abb38d1c8b0a2e940bc93fbfb37cc0f57cc5cdf2d4893b0149c48c31a40278a8917d8f681ce950ecd3e34b74beab8a4d497c0a606755b98440ec959fc88c7ffcf2ec27ffe532fbb6f2e614e5edbfc618cbbe49508def02e3ae7437ff6b2f851e58f79d0bc15ade2d0ab1f5b3ee0aa282aca6a50713177bb1ad654c1536928c0a3dd1d9e32e498bbc3cdc787e576bbd51a1515f8465cdd248fa58826b35cdaa928b67527292c6da7ae3786b7a9c118dabe90113026c67b45da043cd7053850c0704921327bc4bf2c050e527897e9efc107b8422820bacee9a209c3672435c25b5f69ab9923a8990d2ba2b5362fa9c2129b717ed56b5c104d338adfdce1c7c491808ee849f27f0ddb996b293724ea7590632722805547af6f849d4dbe85169c6705f8a19a563799e4f83ed64a758f3c081bc2b588a4845b428310929a847552fcb614ab646b2b4a45bfdd6b67e6386cedf1b8687ca5bd3dbe1debd70bd5bf24bf38dfafd8a64900011499d58eb7fe28e12498e2bd24b1cc6b8f6b778cf3eec063cb877cde169b55c64524d7e90ec4f96e0e47293ced8fff6dcb8f62958a2f92db884c016ba929f15c438308bbc2a3b1b48569b4da8885ce7ef132395522f60f1c0e3e5b44a719739e6a105204c9dafd4514af155560852dd414730e98e66937b5145b09dfdcf82105256f87f2526f8ded6d9e3ec7bad69d7dd61d366112df04a2b39e2031e6fad4b97f157fb5e7cbe57b0ef795bd26ec9a56e06abed8883fffe12d17470951de1cc6dcc9c9b822f2a4f15383a6c941ba282a211da0f44b158b65986761e29638c49c9562269ca501cb383cfd23d10e564d524f57cee0bb4c0329330b2788a2a94abfd30ccb486250e8ea3f455b1bef2b502926f1a90e76299d44c8987483d008647d6e6beff8e94c5e67bef370981bf350ea677c04307074ddc778915e1fd3540577aad96b65cee5a954e80be2c7bc95cc53ee44f1a94eae5df8cbe399f5d10ecffb719a120e7d386212bc4eb0ce22ad9b53910f8083c8ae4174f6e654e12e981531765a93d2bedbc5fe7e0a010cd3a10b6cf4fe1dc4de6d2dc9ffb63edf0ddf7781fdb02ba543a2a6017c16e9532795a335de910bc019db69322ab5d44ad30b570b2015c4d6775962be22aeab9275d8af28da1e61b954d5922a4617f0dafd7180399ad2e455fedae99d5593e6ca53cc94366594e42e88bb28f51b5fbd86fc2e96c6124d34333c38aa5d7f6be862e46a7ef1f5f38754de3a1556af6ee8a0bac4cfe11b6e56970238d68d5c2b003b2c91014f4088f2015eeb8c20a0a87f68bc21cd31b1f1d3a9e6208fccdb8e31bd96f0ed74db7aa17d6a46a0e7a6869fd1530a91029073df1dcade80884318db09b5f136618925e00100141779eedc78185b3d7aecdb4338fcc7e29e3a442578033a322b0f6e4f5f46d52f8463eaa4a48f6a8c73c7916952b43eced331071f2c4ad2f3f2dc5f767ea203fdbc3c9046c6c3db24cce639b5cb25598b6957655845fe728c7e07db07dd1d02426b668bfb7b950dbc96e796637b64cfe184fe0f89cbac9017ea1fe0e504d7a4077c529acc3dcc5d9bdc2e49c93d49b38ca97523462cb1cb72648de973dc8955db5ce68b163e9848c94499d973ce8654e477d00ee0acbc26e9277f170182c2d148b4e9ed1c0ec9ec382f01027b2bf9f5bdd81a72156de4a3bfe4e25601cded2bb6791f7ba821070698b8cc112da9a43bb115d0f7ca765f0987efbabc24f59039e451bd5e6be216ef8b07b431d82354b9b84c9f9c2c4180b27d3dc7bb7630034c1b0752de69de2538bd76518b4dd685aecf77534b8ff71d076aa0bdf2bf34bba9732f3709c035095322c5227e90591684018d57bbd011726f965ebfab917caf405221c9e6668aa385d428d7e9a92b3e81e1638bf184168a85b3550e4b7bfa5515474528b3c8f587148d7d3a10f87f01db7cc8d0c2c27a1e808d84a521d1cc5861d4da5b28ce5f0684189da716bb2f64f6c1c59a587bc3c184834f493c0c217d5d1603d93263d030f86ef7a4115a7ab9057caae1b26883abe85d5601db9fb9d0a146a059fafebaae3793795802b47a9352d24d4498aedda56f7e96dc42253ae88e54f97927a6704a56d7406ff485482e6c62019702a1c8736c0cdb51c5ee10d6f0a43f03a4ccdb60ec5de9ad7c618b03c9fa17f7369f76def4de129ea21667358d7b4acda586a9c961b8d472af3b06097fb5ca75dd896e8c7f10c15df5d03e06433fb7b27655aa7e9111ba52f6e09b9d0c86aab958638f2ad4823ad1dca620901e7627b6f58f6e7f1c523d6a2a0b631d1a58539af8009675889cc0ea98288721512041833736d8b9d01135840e97c37145b548631c30a719e991a8a730d906ffdc15f5558d378e8cd9a7660c9866c7e5eb957d252be069428ec771e262538cf7607a0cb19912378ea48c5221fcaa5fce5dca24a166c1d4b5d02f14b91bd17532a07dce60399459cf0626bb25f53ce26bdc95243d4550f4c7c33fd086530405dab05b0fd737d2799fc26b29bb55bd6b3f3a6b94248dfbafdf36b26b49eb6b3d5a21ad5ee3c8f247c19552816b4a86adb7bd22c0c770d5842295153a537bebaa97102916da88ef3e18fb909931653e9160e988043e71ecfca4ec8fd619f0d63e4cf077fd5dba377074a5babb157411219e0d636257f662d8ee4215647b769d63e0291dc594b6b0bc9069c6f961d7d4674892620def5cdbf8fd3d81cd81c094dde79de65079ff32e3ca17ac502da48a98f14810a1f84b06daaea83b19079998c16417ec1b2f3d028acba6234a845f15b0f8f925fbe612ce9000c866db8d6883a09f14018802bad3c1c7c6a648c8db392463bce3683342c715f4bf3ebb3f8cfae24f5ba25fbb7900fe725e9b0e23842dbed0dbccbed870dbbebc09d914343ed73845d2a24d706b84dce6fd79c9940b2b97c8c060c8b4923c7bfa1c18d5787bd39babfab105a35d1cfa4f05bf8e0132fdcda4853e19ba5fcb27e025702aae30359e4d57567b42db26781e542d9114ed87881843fbde189f74dd6dea915ca08930c3a65f3a20f8880114be49feea04393fd3ba0979f991c382cc58ea7f0390da71ba7cc8f5e868651fd9fa23b6afb88189c07b414eecfbfff2905524f5edd4389508a62dbc6c3a1014eb48f9df72757f1918948e6ec5dd3220b654a2562048d6995d3d828ce05044f37ccef077ffdd3ba8dccd7c18d3a8c92ebf971b7874bb4da2b8de9f16710defbff4822ed86a338d6a17071064c641f154135d209a860961eae7bf225cd926115365181102d2b8561a3a8920a9fc6e5a918c9727e0b44dc2216745f679b92b1ac0713f4ee6dee37b35efa08c93935bb86d18c81724f30050a131d25d071437b5310a65f088fa85f4a520c1e80eb9aaa5f319a2f5010f10de5b8153cdcbd3ffb7e55186e986a7b810bfaa84dc889b7ff3218c0475b09077ce1314bc0db8c64f720062b8c5ab8530613d5cfa4d8dc55ae521121c1a181642146444d251bbb26419a1f510b2dd636c8a11de8cc1b327e7cb1a9da40e96693b7929e125a2d8bfe07f1553ec6f5acf687d4ba8f496d6f712942352824a3d641205a2b9eda74e6f6d032a362753d2dabaeb6a8692f8dca2673ed2d279adeb9c6669214f487646c6e611ca181cb178b2990defc6842da28d2766d6f96ec60b1f4bbbfcf58efa0a1b7a7ce22c0892132f8d37c2a7e8da14abb9b02b6866bf0d4dcd7ac6f99caa14b20d7fbebef5ed2cc4982ddb137227dd93ab5055cb18d9875d7986209291c193d94ba49b370094a778168437f981b10fd2c0fe5250d86ca887f80b9cad072e1e3fd286c4867789f56c6b7019b1826e56561c20ba65d9cbebb3bc83b9349393dc18cf01ca76734299c6844b786eac74fd368bfe9ead7c41658e73a499f786acea1437a0ad0d8456186210fcd8b8bb43a127eafe68e329d87790890ed897bdb0bd05e0ac4d88e1023e82dab9f848e7d1f9f8f79d39e143dccdcaf0959ee1de264685a2533f114fa50cf9b232655325ce0ab2b58efb6af264fab6638c76bb60facc02bbc75f0e0d4a4e97b63502778daeac243c4d010ba9fe627b09cc8a852a62fa48efdbdc8b48b2ad5c6af50630ea93cdc09c750491b59b5204b1bb82864d1270f6e1eae48d719b47e3e0a5793c301f202da495c2efbfbe5851f400b30c9e383ab01c84c719ddc8856699f8dc7f36f2cd9ca65aeed5ec33559206745320e6915a61ffb63252c8d02de5e296e2b766f48392545aed308fef1b781fccfba3cf0c0e157082dbe6ca15581c79f496555e461d46f0fb5e5bfedd7267630306498739151a8e763af446a4f5adf4ae96dc6cb385ebecf4e9b425892b3168d593e4e91ac5fe5be32e2580c42c3e083e32a2a5e9d575ab2917f5e70617206976171c98cb7266b424ff4cafc71a842ea5e20e7cb8dacea0c710414b505a5b27193ae7c1a27a3480529adf41e9c782e0012e2df7ff3f32de874b0e5fe0878b38bca1efb4cd297a01ea2d4217affad9091a815bd98939ebf427d08fb4169a4714245748c3190a868ede01410b866077da973b7c627cbc32d962dee03b1794e98263040d7217b5440407410e2de8aa1f9ff0a17d33b89a386d895c269f7dae80781b156b67eaa91cc193bb1b1d388952586b5ea3b7614eef796640029e044308deff6d3bb3c49924d7db3fe2a6e9a7bcc8c8a0d766adcef31a372ac47904eb6d5ee0fb31303ed8c85989ad3611450185b5e26019ae9b9f183a662b28ff0f11a2ef9e58eecbefb063343608ae963120fc0c3f950fcbe4020c7f8bf9b580ffbd99b355c65e8cc7d40df5705777f37ef28a4793c96c911aa8ee37daafd4b1ce63d90ed1f4f4a644feca269d365605f687fa587862009ff79b03ee0158942c195708a14d5c948a2ad71c340468265437503122b8a57b9079a292c6c6666483d8ec1709ebe7c103f6ce72877e368293e34e423cc2b232b4a7a469f3d714eeb24bbaf4164854cc24274b2959ee13162bacff83af5d2bb46cd76f80acc6fa8361fb9b52300f79df840c3401f15d07cb6b0066a79c8b8ae794c8e65c740848f61d74dd10582e455e9f2e4847f3d74f2ad47468c92c96f9d702a67dfdde2f1445d5b2372fc3faf200256e3445a68b9a701d0d6aba5d91c8fe6f9bbbe3712563b1dd644fee22115ab1328c12cf49cdfaadad9a83d0668668a28d7e8974fba4d94189a356248ec3c939f7cd05ffc9fb6db1d758e92bb57d53aa11d9ac94313e3e6c8410d3a5eb9b1f4181fc69380d766f69fb5d9321d8ca2184b07594084709e48806c2107ee86cc2a73eb007febdc643bb33a34853f352f7b2c18057072423d1355ce39f83de9c18d761f69cdf405a5abfe5649dbc6c317c108e80e480bdc244c97a0456c51b8dd01a2bb517d67f4bbdb146aa0f7260b6d74cfab2f64e887ba6b717970a0b933aff35ca50b9664004e773e87a27b2964cc439494fb3217fb812e34359d38ac4a0adbe65f160f3717a672d5d9dc5e4f02efc650cd67ddd9a6450e58b71df7af437929004df66f0be05dbbc64e6f019d649f228f7c1b6e64345efb9de914117b09ecbdfa5e863d269032c319e1a67501d9d0881d9288b3b7ad14e7c9d2e97ba200d74182a3ab94afb538272d972d5bf1b43f051123223e8937cb621f61508cf3ae6b14efea00135e2b0b1ebbbe115c053c76b590f57105edd761a3d9ba44097e0753618cacbbbc65b2dfcc51fd433997b0f8a58ff544b90f7d6ec36faa3c93adfabc3449243fcd6cbbabf60d9a03b8d12bf947aa51c1ceaecb23ce682d7ac019eb3dbb7f87b398d5738c49b60f5e34a413ba74dd9cc2d2f1945b1f47a4936c12078d21a7fda0c84a537fa922adba1160cb3f074f7787f20c9ab6ec24094143cbd1308beb47c60a749fb867f815a123790da41489ba27e06cab8e147f37b997c10ac07faf898ec0073ce9a0399390efb8843dfcddb2857877aad1dc4cdaf1b0d8e75c9612a3749eb0497581c28b814d35aa5b9c91ce8ebb3248c07bd46513634507b81e8f330bf98b5ed2f0c14579ecab847f38e877a61118a293a9b752fb060a3dfdbb88f18135f97e62a77026c3ce8e61b466ad6e92af067254dcc1905f1c37b0c266dfb0fc9e95eba84fb2a6db49771a50b4f5a0917bca5c7acb89c3ceb84327d83c833e3c91ef9ce46f2850fef6274d72a60c50ac6e261f815b1108f3b854838767ad71eb035bb5e461d6059385f1ec8d16999a88e4a3002fadcab7a56ef50f4f116364cddfeda058e585c88b895f0b3c32bdd3b33e2c830a2dbefd1f048b94daa647f35b4fd1fcb5d824a42083d258795d498d8f1d05c96bbfa9cf85617188fa14c4b18e22fc87af5a322c5725b502e789f7ed949f526fe827c689aca7e16be4bff41a2e2177ccb3770851c476bd9a576da29a7465791abbe09d826af0983d778900fa4693aac8e446669712c507aabde41cd4ae05c964fd2dc1f57ed741cbf2c3a2d1bd0b5e5f057a00dc1c4d98868584a3d0afa66586e2172a6c4499fdb29648e23cee6da545b0cd466cf5e7d6b0177b30e1390699378efaf40f2edf9ae3605ff796da19099bfa6bd8046070a2fd8a00455acd55e19bbd872a3f20e26b96a7b686bc734ec1188bf2e81947a28670fc56051a6c73f23e181d252c17b6cd275d5287d90db734a1536d138a7623ef285f8d95fc3f4f943f7af7ba2378f1a85726cccc22ef1ecdbfea7b0ad2895f2ff19fcb3a675ea949df4f618270a3e653b98f9b05f37f69187cca107ece06014321fbbb6417f337ba8df51c12b53c33cb42127fb3426778e127a27f81fdfca07447874c76770074f07c7170ecffb28646508db63be8ce63d356eaa0549eac1b09457f2170f583bd503992f9f5e7f4b4a00587bd6a02e0672cdad86d5f3898ad3093837ed1d08c5fd1571ade5b8030bfb1a4407405d9bafdfd46019f79e7543a3a53e758497ebee13ea537d3de4d5750cbd1d4a1e920d57caa7802c3e1de3835eb272c9cdb1bba54e276be29cbb152537e6e851173ead7d94bca24775b5a34bcfdf5902071a5dc0a7eb69d3195ebee14b0106e5b2145e073f46818bfceecab1c9cebb5a96e8e15f8566c85e3a4c63a2cc9675166ee4790a7c61b38b56183023f098e75a83162671e73945d883066ed3f7426f7feadfb037d5e7f2d42e33fa5c0d77ed1fb53a529b67e3d73301a3947de83b39d5d205f2bc633631c489bf1b64ed1c6c9ef9701b273d1793685d09089742b4dcbeaf6af22ba4f75ee4426ff5cc518633a9dd1d5b23a6872f76cc6c4767961646cf8424ac4e00bacb12549e9f2509acd5649dc630938fd9f8fd69917a3bec433b420cf268af2272f5b25279dc074aafbb1fd8bbe6a5b99e0c3c93f19ce664542011b356d85667bdf7838c2cc3fb83b961bc049ef46176a89067954abbe7572a0e7a6ee54b122aff1c3b1b287fd19026e5a436656821bc4a7ac061e7e064db9a1948ee24663839ce850de41b1a63494a544611e35193af1d69d1d66c79c85f96b2d1a247c9ae8919bcada769f9a9b4c1d3f7d4d4719bb4322ce19beebf0b374ba1ccd312bf1f48f99181dfd735a26b9bad1e906d3281d1fe6ba191500da2a685e3eb7ebf95dd9e1cbf69d947ce7430f469c693bb0e08b38078982b3be397afc1e512adf839aa40fbcbf9c019b364bcc27d9c09e25aef408c118a97aaad385c465456f953cdd892f9b222b45b2cc4655cebdf3731e9db0c74ae13ed32823f5b945aecd2935e03c86bf3e1db21ff3ec327af526481fa0014da987da08f7e493b69647495da1bf2877f33dcc04cbb7dedae5fc415e4c483d12e14cf47cb2ec7eef55ca95b3e8368cbf2263465c88d7411d6cae746aa16efd698b7366d46853b8d141a90c8ad270de7543e9ff48009c327cf3d36377de5391fea6610d5dfc1334a5684e578606ccbb1a62b8f4c0a40ffcd7f47802dc93130c9f018129fc085b7eba4d69fc6c808805ccec93432cb3a5a493bfb69bfc963b41e7625b07b50f919c87ea4f2e33a80a595c9958cb3f595485ee258525268392f42c78bcad0f1a91a980e65f5d9c3344ec112a7bbfe1f85a95a2531e7d2b6506f890d90378d12a2aa34c0383d6d8da139c22663844bb4dd2719dbf4a15c9c93411e23dcf2dc7c1d929e7e7365beef0d5cc9eff8e43791d57d63f0563d80e9793021d916bdb5e6e43d24ce2cfe244177f43589adb2cd58dd6034e42c025121a9737b13db619cdee7062a0c7b1f4a5d0c36f93acf18d4a6c8155b69df2969397b8321bf3fe605f75f050b7db2a6b0ef88129502036325af8beb7a41acd8c7b9e07567b96ad1f5041842d025f58d10ab0036ec75a2fa9dbede9db0fb0105a982b0ef4631dd122f4fdb40e8b7e88e766881b4c519ac4adfb910931091f7dc748e7099806d3772b853a2f068f32aa8ea61bfa995540cafc094f3afe1b5ea2da551b55c6c327371d1c84361d5d45a83cee20a45e764ca8084449094bfd94cd6db553ff10757dffbba08a1439de950b40548e95d647d4f9b538d0dbcb257932e7491dbeacb2613e957dae8564252c1f11f22041bbd12dd0f74c841402e257f4850e3f5a2e6f6fc6cc0208dd2050f2b96cf487b4c7f9631650a17176cc6aa487fbb8f0dab838ff7d7b3112081b927e61efb191cfe956ab0bb1db8ac5a0506e7d11d714d345545c645f5b946584f8a448aaeecfc10e6c9691b28432f1ea2484221fc6c149b4845be04dd44bbb6907d7bd3f99b84a484006545391c14b68e0476c4e246ec0eef0dbcf6c99606174e1025761414fb4852be407761cee1954a9bb64fc4bd9d7d01dc2b3f9d96f9d6b7c01708e0c3a20b9d0f0e7a5c5da431c3bfc1fd3bcda1b47cd1648c363b9281dd0dd2c061890606950a001483802ced19faaae74051e8411c99f7cfc28e87cbc9d96b2c26dc4564908673c4dc3026020ca890f669b79ab0b27aa63dbe6ffcba603ef22e6b987156ec025939d063ae3b7dcda6bb8e713e07e33c23177a28d7c3ef70d67b08ecd881e529de39c3030716d91ed08980ed95590e8172379b9ac7a6bd86d2b99b36869f2d92031aa4c30a92a1995c71f18a27663a6b6171803e3fa56e5a4833a3940c5af2c0530e7e7fa364a9a52e235747d645b640ece4504198a8b97a55b44a825ff1c75148e6de3fcb6885e5ffdd02b8a75ae468262720b7ba719d366e4cb7aa505767b53a497b4ac7eb361bf7cd0abf83d1271caf8379c159b0ff35ffa1bb9e6551dee1e862bef71002d25bdc08decc6732c24d6db4aff3b1429eda26141637499e6a9077478202e5b6972cc4129c077c087ee1ecfbee9da22fd987c4eff2a6995c5d221c3b4c3b2c490531105ffcb9314a1e7b680ac8666ffa92bd998609cddc8f88401aa3546d716637dc5c707fe0cfceb3f96e5de1a58ea4b66867be623476ba1525956d79665fda731c608f8c23d3fb4432b377ec078c4a610e84bd6674e694256f9e121a8a185ae3bec6e59b90380c2806b0a55a9d71f2d6d9adf3b7213ff5725f874bf92ea511c1a5c41113d18d62a294e1f37cd987d10afec2317a90fa78c694e4f2487a3fd46b7b7985e2136fe5fe6a32d722b4c0a424fc2cc2732ff487cae49e14f796e63e389fff99e099886bc11254341b187292cf41d0881d8ae5124a6a0f008d4f28b1a84b7153b27b55de654881f69fb77b2047bd72b3b7c4fbac3e692f2dd1ea936f0839ff218e07c9c0f45f3ad0c747dce1c5bbb1ec226dba2830c346ce6b01908c8fb853b5c6d5fd37607369c3b7be4a4a206e65a41e15d718d05c7b5c89999789b4e073ac26f1b31a5734c08e7a49db18f0e1b29c88c81038839423506226dbe4f293f3d83fac8b146efdcfb127e215ec5a83dcca5639ab01950c10664b0c6348e4d5af960a1d4b30cc31d5770a496fc85d8b2e24bebe6444b56fdeb29615","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
