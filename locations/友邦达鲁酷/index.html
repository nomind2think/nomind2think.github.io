<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4171889394f8ac0b84059bd1f75eba67cca3c6b8bd88c15537163985b47b57ab6227db9972ce66e85aac494568df24234089980ec9f5978e05729247f000ac7b9dc912200ed1ef04591ef5652e38b34e94eda66eaff8d08e8c6212c711875097516312e2c9c70b81c8564a3ef471ad0c799ea3dc021124008b63b8479d19cbb0c740f0ff4fbe5d1da12753088eec256b1352b53d053e6188b9bbdf951b9a01519779878e5e548cf8736fc7bc38c8bdd3efe4b8af41078104d420318856fffce8966365bbddb7853a65134abf6a912c3202aa13ee71d5454d486be2dad4ebf6ef2642356fe3d5123eaf0978e2089158c32647e2c7f4afc49b5198532d7fa970a7f7dbb31cee3c160b63b87b90526f431f756894fcc0b6217d24550e938f45e21319ff56cbdf33de416cf20187fdb01e225951c21bbf5b7a0c25fb40621cfd358c04a1dd150e9adf7c8f9057d90db0f463045c490bf94b18e6a6a7288375d6e9738c3b721021326e2b945e551d85de0948036d70b11c5a72b19f2d2d58bfef965dfc12380ab3faf11a99d46b538068ffbccfad43516d4e0bb6ada5158d89532999f839f552c1991d62708b5c7b77af35eaa46999e81143c0513f0e01255d1c15d0c69dbe4256d62747bbb11388debbb513e134aa729e806e46152f0a58a871b489ad0b9a288f670ea706d9853cc786fb5842223b9a6663305e265493e5453c4779182167e918ef4b08d1b0c1578df299588be2fe20cb53a3c5081756a9eea8ae60aeeb1422a3fbbdb01ef198b412b13750f311f14e87d62920d9d18e10ddcf3d309668df07edbd4751f766e61c3aa8421cf1ab206592e4a849b3a5a0ed9b7ab5bbc0f8766eac78195bcb6330dcd0e767261ef3aa4261f4a5a9d7db1da0c216d0ffb73b90071a5c374d780bb94e44d44e4f35ec7b6f5c02bec6ec7e278a147573b2dc5d3eb0f0de324bfa6af10a047a18a7710317173d2bd98658e37fcf303dff8afcf7334883567e6ea464bcb000bbd921dd8010bb2c68aaedbe1744c49792156803935a7f9a233d39e1e3cf125062149d92ad38aef95e682a01cd46f860501cbcb5e3d321e675ee1972b713637d8c2e3cb0460f5c5f569137f1530b2febd776f6edceb412bf14e5546ee9a81e39b4dfba26c8af54b5660c1a02465a9fb69753604ee89076f28935160565af1f7d2d9548d4a667827e4778d21b7e7032fda8b76cdc9d7bda4d6e10e480087b070c7c7234d895606406f8040edc26633661f914e07f28ff7d7bb64351fb762ec1b2613afc87bd848b439274ef2808666d3b341728a157711390d6b4f135c504871a8ddfb5ce649439c2e10644b4c23cef71aa0d98f2898440f5f4733182641849b58a07d6810980c4b2afbc29412d50884dce9154e655d0bcf65c74087645f69191aa90282e39c55389560d1c6f3880507d47bd53ed86c80e0d26dfb4569cdc85b4433a124e1f22802ec7a22a36d70d3a81313ffb6547c03fdcc71de5dc73ab699398afa196fa099952317bb4c501c4acf9b28304a7e91d2d7fd23c51b62898afe022d4a9876baf97b0c3a92be2275df54ef3aa51d86ab510686c594bc8a2b57eee95aa8190c824092837b05fdc6a71197fcba4d8fe48d9158e45257ae05c9d85808aebaa445ea2dd70cc4637648c1d1c454888e9618785224a4152f70f3dd4c07aad28ec08bd842591355e2899dfa95bbf7b1452663630ca231da2efb06153cb3be35663f41c8b620ce00e4a22505a6f37fcf9bfcbd12bedd316f046c80b41a465d56cd8ed09b6f6b9574d4664a4d0e4c5cf8cfa1bfb97db50bb50728024c9b6ce0c260603ad33d9abf11ef61821c1e80648d3c9bddec39e300d8eb85bee7cc477d595075044c22d288f02e1b32b22906534e4ea498c5e6a6c56da73a13739fd50f87d242d94745441bc3ac892e4884e8c5c2499a8f27b8a658aa8249f9464ea8b601f39bdba13b554d0fad65c09d82b17630f7e913a00546111b9c37bcad20228f3a9d804d8a939725512843b3a549c29f796a654f81fa3c4c0f17dc08860d9f4f2f27f191c402d7ff5850ef8454b245b43d5dd9d509f8c9954bf5e82e9708d645f06c16ea87ab58c85c6e06838efdd9d4e697cc0c9c74cf7974562998665add389692ec2107442579ce49605df89a9fd01a872d16f449a60b60e27ea665a53e4db058df3280e33045b95c506470228da3b3acb82e204bc84e5d51465ad309bcffe3dc20a7285cd64c657310803848e955f7d08e599c909d565e010c35464101eac87f79ddd31c4851eb8188c5c759b7f941442f0b07b2c61f65e42b2af6841b76dc91d078d7020484132b961ec0769937ca7f6dd410655436154488ba98862ace7958ffe59457ebceb48baccd13e81b7c6e27f2beb8da92217e0cfbb7e8e1252ce4bd45751b7414c2869f0a8cb9d0f008dbbcb01e0a22502511d7e02e7b60ea9c4856124d9922034a672a3ee1bdf4f1116f9eaaa8775915c09e5024f4529b2aca112f8c6ff3d5a43fcb7ec81848e25fb69afc523d1543e95ec38761221df6db5c7433c4bc1b307d855ff74eafd0b7ce0eca8003bbce4007c7f25625843c9a0f5e6db81015d9f72c58a8e62ac6c92cc96a63e41afe6e81c119df60331948010ab59825783ce1c53633fe1dda8b01c5bb2d1877284f732dd1c0e24f253183a51ce97acec1d49296ea258fbc7fb05039e98792e0098fb8646e134835d6c284da359f61f2b42dec3e3ca948b9651e9a30ce35e410d7e5694ddb4ef790ae5d2a39d7fdf1a9bd7d025495ee98770c1fd97b2087e9562f0c43c34f62c045aafeed12b7578f8198160ba1b5676f1c702a24462ad3da9520a78c468bf6c099de4b6ae798d0b66e700f00da4fa9e808f7338da8a222c6be6c3f280e4248c2dbce5ea4ea61723c24538c8438a13c175604a1361124e856ca0a22d8e3082c2528310a8529738b7690f562e8046f41c648211645b3d70a0b03de4c4ef8f587ecb6a58a4b026f7d4a004cb765ce4fdc4d45e553d82a86cd72b56634f358bf4294ce3f7fa978bb4e2da1e814ba9e2408d25f62f70dc7b32cc02e586195e487b61125b6068a5f9d65b6184db9935fa3a3401aa07cd1f515b27f2d0540c094f65fbbf66dfad70fc895e5aabde9c41701bb81ba711105a2e27837206de6aad441757ec737acbe417956433b2f7dffad06aa25bd3183425a6444974cfec4ae4787d1ee15ab2aaaeb3811e744ededa6eee2cad7493751bcf0091f4d8b41fd0b5e9222551cce4baaae14614c31832eb5fa44010f65403add61e335e0aac7e3d7e1f1fe963caab1849a203cc681e1245647c1f6054d242865b8a109a72c2834160db4b18d0aaf395ef04cefc5f932d87b7a816efa32bf7430c186d90c300fac2cc97bdb01563cf1acfe41ee68148ce28d022fd74432ce9efcccc34da98c3d27c72682b8e74db7ab38ef5618e73ecc77ea876de353907e99ace963becfcbfdd2176cabd13b1657ebac76d16aecbe1b59b3aafa68bc33ba078aefce2d5c1cebb5dce3c5c3d463886842e67020c274d26d25a1be6e8e82302b2bd7d72e36cbf3e8bc7d0bf2a41deb44a4c7c1a3858c09b922af6cec3e1676a973afacec0f265e7af710e8d4fe26464d84cc282700eae754a148a9c433766fa5cab79a8aee8bb72b4308bc04955c2b852098c9155a0aeb57f784258c2d625ae652516d0bfcaf86fb119638f5bfa0f3d121bf9dbb3203c74728ef5aa49335b28a7ce05e76d5e1b5dc6e033750156339ad38e3a427fbcbe7f5d4a5b79a1889139ff598ecb3d1565437a9c6923bea24452182ddb0df72023d0a466b708c2d8a417ea95979798e8746f7bbcac650e66f816406dff091eb60a072946f93e02562cd470beb5fd93d4c8f7aeea4c24ffc467d7fad9345d753f56efd8cd68e64b6d9c9cef8970604c5f9b461277436c2dcb3751d47037994bfd47cd1b1d875a609a276941764799e0a9c0f2736417ed25ee81e939a431eec86591c90e1fcd14166efbd7b9769c217da0b61a07d3bccf59afaa2149867a7443888291dcb46355a4c75519c2b38958e601b392642e08661d4952bc345f0b0e623198b5ff73eaa24df9af54df265772f306b31077f4e9025c65b22397b0bf177f45dbf48462391bc65c6c82dcfc9a880204d672305f53347f54ea99f84a56096e49bdbf0c58480424b75a365f64c783657e8d03b2d2e1d6f89e678a73b028d2dc200c934bec32b7da118b0f2cd9a2287957fddbb14c32c670e478d5c75ead491a82071709e08355fa5ab4516242990e2b3e5b21a4dd8b5110319fa4f5941dc05b36136d2e0c42fd7dd85e33fc37fa06847631dc830239d595e0fd93147712fe2535671be97a028db37aa04a128e26ae264a6f03a3682a59ff1fbb30e482f1f9e74dbb2b6138defb8616248dc88cab6bf38fe84b931dae19fece709c4e56a89a19aa4e617805ec0092d4d2ce47d31994ce55b2d777889f648f5d06ded83c895fc1cf4b1cb1b82f8315c90ac7575b8142ca50fc71c7a0cf4d2f19a8893092dde2eef8e30456d1d77cbb7e4080da2f79ff59badd52ecde79903a274aea21d2de5d47baba26ab909fbac85249c5acecd19df1e27b943d80c7762d31d9f2f0198ae6ffdb5d809e34a3cf26893c8c7bec827f05d04b1d1abbc45fd70bd2053baa6b9c938dc630412fba9090572205bab788f936015d37a7b8a380b6b62aa2292d43a629c118c59f2f4b3a982573fbd059b5ca26b4ec478d78e981a26f290783e8dde829d12972bb20d5ea90eaaeec96eb70ecfd443aefea2f92126011174e5950602a3f539d8ddb4d8cbd2888746fa4470b209df07a91b7a5843230698511ccc5ffe7375a6608904396bae77c6f2f1e1128b42329afd74c2d2e2229f575d05a06f5e360b7e0b41b217e37d3dab7551deb562d814c70c88a17bc54ad38c121dd388c54d89bf263d56c2a7c367a9cb59b4cf8ebf84cf930627c78a37dc3bf42a5524ccd5d6dff098a977804b3b48680f1c3338cdf7ba5463eb25d86411d23057d7b988d7fec7888b7b1cec1debbf9edb1042912b977738550beff26d4d365ad1ead2fd48bf3277ad0bbf88403c5ba7a790fa818d363ad8cff15f0afdc054f32df9c776671a57ccb041ec9c943072ee4ce1d09762b1d288b16a64cca4e987b02590ad99c9482c8e0ac2b58cfa5e5de15950c665c545f181ce618db7154d257fca3110c00ddcd590984048033f3d36183f2890a38a0f460d1cad380060dfd552dc3e8e82885b4b3de493113ce5b349b6943f46c2a1e596881af4c98c202b0905b6327399f2fe551c5d19b2249140f51d584daeb0244354e4471aa8d300723b798c2c0e1a60a8c1f3eb0af3c5b9caa2b12b7ad265e13c5980f816da0ef0938567af475a4c5339db4a09b6efbfcdc0b8f5415641962e5efe217f5ce3735f03a5d37982904bd1daa1d71330ef1e1d7d7093c7e12d5f66b25473665d28c486b078f7f41f34d4adee9ff7e27a9c1a556853ecbe9a2af5af574a15401f0e3b1540895c29b9c9adc73c23bbf72f6ac1f03c4c2269c0b09a3ced884e633dc4b01d6b4e9c03bf45b2575ac8c5f619c11e851ab744de866e480724c019149f94ecbba13a08548d0ef0878b697a7d7700e9df9cdf312823dd40ed404226047ec4ff8b8cf0fc3b7057a572c7a0876634be42d21f1c992d59ec39d09e45391eda33e56a5f40edf11252d56fd8314ffb9bb24c76c68f5dcd6fa4f92158c2e38abedc43c37704b6c44c99a2e82a1bc9efead570b054e2828428879dd3259f2c00705ffcac21cc20fc6a0f47106506f504dfde9a9eea8512a8a12d9aaf2b807c103c3714bfcc718c3a2854a2cdf3dcddfe01d7588cc312e4d81b6c64b2b8a1915d2a7d768bd6ccbcdb54679dfbbfb892a89f491ecc92445a1df734105aa8542518699c2ad2baa81d3ce98b8d607ec6704d5e967e82a2cc3f78f67e1c6e8961afaaf13888973b9ebb1a298d0670dcbf7c5afdc80cb6850df6149f60b07297a5467ebca0f327f59b72b99fd32b9c854c32bfdc42d6de94a15f97c9e6c05edfee376f160274cf21e0dbb43f36e12948b1c6b398a2073864348de879c4b1f39a077f4c16ca27228817b906dae52e42c524e0f39e1888309830477dfd3c4e1e5b68dc945777ebc271765339c0cc3871cfc3346076aa4099435cee7874e3d0bebb10ba728fb5cc883d5d7e762f4d7d274f602ec39a674893539fbd92fa6a18898fa20b1c6bbd39e512ad7c02212d7fa5bafc501a3bc955b2fd6499e8fdcc0af88e4955872fded2400d5b5f540c97cae745ff50011ef11e8bd70cf74f393ea8d6ee7d863bbfc480a4b2473db4573f5858f402cbde8c07eeba85bb22e6e1a6b31737760e0d28f9c16a0f70bade725317c8e23186789397502511b4d133e54cbf1b7e50ac080522e3c93641d8273abd5a4a8a05c4f074f2ccb7a61853a55a6f9429da9d2dc435cd35f9a863e4f955535b328982d8c7328d9a81133d9f4a2e3d079cca4ddbb41458d65a1d31d27cfa0cba713165cbf137bbe427621a500ef00673dd696cf65a7f7c177ad46e015f8feb010b4afb1ad15626ef947a6bb21c4dbe87723d16b33c3b6f9aaabb854abb64e20e286986a527e6470613a5651e095d0bd6f88d5bb7199dfe87c474b7367aaeee1184e28defd3d29ebd8c357a471184887852ce3c59e7c55147a1e1ac4fcb0820766f23535198fa228507a6d417cc71d185e8d68d8c28c692f641ae2d737208d66a9351206448cf5a4da26996d76d8f733d4afb5807f7c60e96a8d95081da4ebf152543fc9607e205ae4078dcc627284f575ae00caa7502199c69a2252ca8895588031055aeecfdbb9b34e5db5451b1ea91fba5c8287c3740a363dd9d50d50e50856f7bf270a0f3cb6a3a5b79ff55fd7c947e8f61355bd89e38d500cc3117c582b1506643b1a9abce6bbd692f6493e2eb342f8ccb123c3762d68476c089619a8dccc7370a93a115f2afe7f468c95d4155509153d7c4dc3bf298320eb04f9317571a49f29602e91b5fb06031ff094524686228c0802a4a7c5656cd2dbf5e99a530531f9b1f9f7c6b5b5fc134d39cac357985fbd52ba4b3b9be6de444a909c94043a8163a35786f6012fb23aaca8cc555efab1a15843a1b02a49e7c96d8b4d920b4ef64422fe59b647b5d6a21c5a7e559d4bb4a6bdd025113373a91762b6d34a7252cd2d243828b5cfbf19f6a12ae7e2bfa47bc53e680d433d6db2aa9e5557bc38a02e1946371ced0ccbb552f6ed88377e12ad0b67caba8a0faa9c2fc154855054d47ae98f60cfc59c8c7daa8afb51055130d1e0c4aa2a3636f4cd2b0bfa4738d7c97b760ac2a9d809a7939e6d0d0b61941078277206ca9d3951a35ce9a3c1eab36498d29ee7d2250992fd74e4238d32d51f7f86ea7723bd03b6f6a8ebdd36d845f66d31e64e3346b603833c92110117403c7b05ebcc1fcf84098a8a6bf8fc9a5bd95a945b5cbe87edb298e26658fb7cb3fa60feda6b53fcbd7b508ab4cf560eff6a1edcded3799a0faaf06d97fea9751d14de50d22a6ba818726843d8ac1d1f2cf14b0ca011522c5c468e83a9064e82f3add095b67d5f2e792e14ef75f960ec2b1d311485bcec8788b44614b0c171c61ed4fe3020c888be5ba87abc6613e0d687304a7acfa0f0dfd10313225c15f9b0e7c309e7737faac630ba20f1affb399ba268f7c0419143409e4ff817230ad72e3bfbca06c3e5e3a90df63fca04a8a02f7a55b03ad088f76b3aaa0f87c8fd6b09809ce855ed261ccccb4a80f3e634229aa672e62ef44465f346c60cc34f0bbd2dc397e77e8c695caa731fb50ade524c153b6b5fef7a5bd88424c1c0e355bd92427e469e91eac0108d527219f2a6baaca696f98a5c554a6da0bc02672edfbb6cafa10e835dd2bf348c752e297156a6284831ebf0eb95ed4e171f5e0f3fd6936e558d4dc69b6bc1b67529bf2a8519bb3a99752f245a8812ee657a338e53024ceedc5e4a84e43354fc374584a68b1e636c4878edc230c47b04da6d03dc5dec15343f5a6ab1cd538f3e791acb255c6b5e138682a15097945d8431c68018f704c3ed73e9fe8071cf1c5854b34956b7aa198cdd823596ab971e2fa9205fc1801862ea778db349064160781f0e2e5ef2fd59a3c236b179fd78bf7883558c3bb4f3ed8ece6d4b1f9215d0b8d9cd9f452e762cfea0f7dc5d24413c5ae42484c52efc32e6853ebd2f117241a935b331eda7e249f56a1964dcc731e55c4b80ec41b6232561ded0bea8d063f22db935af7d9a9e738a9b71792d0d0f2f30093226d17a6f7e7daf0fc142d23829b656a3247e37e6eb9621abf7b807677adb7b0222a76ac8b31593cf277034176e6f8ea53ff9b3814e2d1aeaae0e4d80041348ac831d1b6baa0139abd58a41fd6ea1667e850faaa02abc679a7e31d2ca58e26aaf969ae6e468b6b8f0ced5997938e4b3be4dd5b22577c7d492d190b16c95c63ffe37e1d04c6a5522c434802c8b1fad0d35f480204297518253ef29dff750372bf8669874e225315db43c7ad18fed93555711b8b8b642eab9c9d9cc9982d8f9150d10640009cd00e00801f75b59b6e5933c56e5d1f53386675dde47cdef1a4643b00f100645bc85cd2ba36fad22d3687b454d56f8dec63dc302bf916eb989f0c9a2b8bad0b21d225ae3bc6bc3f73d99ffb9daf78d0b1ace9f462ad2eea69b8682818aba8e63150a50859a47ca13e9b81c9e39c28006a368a1a4fc1e1438e4b232922fd8a48b46311dbe280fb9d31c17f9a8c1a383145ae9f553fb41fabaf470bb1cd9fa5e7d58ce006d9e0c626c7da946e5566c5d98575b294a4ce2baf106c4f37115515eda1f324e62175608404f43058d7ba712ff4abe19b70b433972e81456d0b6ba14b5103f901e1b2471b34a805fbaf615c2ccb9eb031cf68bcd4e22aead722da4640f47480920c87839296255b412f6692b5459625f5cca101b329e3976e33698479c46b1d42cb1b27dd5730127f7337b2d818ce819bc600544c1ed02afcfb0425952a8283232d900dcdf130b0ff585e32f7e010839e62a7049386abf2dd8b99bc94794945e8496ffa6ec638a95ee8d66be16119b0ef630ea8a8cf78c613ee5980be523094b300886511df1d02283329906d1bde7245e42819400f9a7395ce620e3b13bcf5523d2b1dbb7e91ad8d72555015ccfb52df7b714a40d791f6e13d10947b780b4ae1775037cc27b63ded1e49124f17b23c554259dc7de0246a7c8125208e74a4fbefeacdde57e279c17c462365faeac063ddb304f56936e0cde218193c8dd9d6e6566c6bc5d5447c16128cd7d5907d2de59eb3bed962ee3967ddc557a3029098a6f22ad371e21f21795c200d75de9f9e25a46296d4f0345aca2a0150b5a26d0d1e7445584f563fc2eb4645b9bbe595a78b0d6affa01fa887959b556fe6ef9e8f4fe92380462d334006bbc84a2749ec799dc0cd38c51fc3dc784530e651913dfd33c100715fd1828405e0be653cd32d55b8afa2551efe7dd0c34b5280019202b15c2d1439182ceaa66a9ea382006fbe61d83feedc54edbe869b1623dc2683d4d72e7870b28fc52dcc7f7686a0d3e68e13c9284f6721be3239d2f4b2fbadc388cad4aad98099cbbbf3f34b7ab20b44ec1b87abbadeb96f696282301cb78f6480ba1564f4aa9ecc766492980d1d53578aad95c4cef8f5a9cd9a693fc5e797af5dbd2048d23034fc740ef77c095008ac3f7d63663260f54a49f91e759071c1ba1b462bec9cdbba15621ae942628ad3467f53922dfd6c8842e20f94a6d2bba400d1e818e5249df9040664eb779aac7c083c4e632e5707ba1eae3fb3d53415d9fd3693d125a5a07654674278513c929066d18cf57854447f834d1b13d4786c842392f459c283fb424592d434f68d34940e900d91c3b41c9263c09a046d0c868f1006e6840629afbda781122be1d357cbe5cdd245223ef7629f1fc7db24a5c533d5d2ff26dc7451adcdfd3c23c8ac099fedc6e9d7f4e9f045c13a61ab653917d2ccd720ccc2a79ffb7b61c62d1e4a88231b5ab1c3e61874431383fb7cd591a5e85a0042dea6a028ddb1afe3e3908d30b36db31be248e688b412aae26e5d3ac373133257008989c965e3575fce0565139daa9cd19b5e1fb38d0c4b8ba7a1d2a736eb82acf2d2b668034722dc35391eca87fa115837cd37057868d7c2fbdedb840c3376788c7d7ad9addf0f2d340b851ea14f0d3f30a496449083a10192f7b3bd8e84be361e5979cd875ee207ce06876369836cfb42e9b09e13b6a69c2b84b6c99a45b94541d353adc04f7d643f001b6b28a0a5b4a73f3b905056ab6205f9dc1b41de0e4f10196467ec364f91a4c8b43a0e4ec396229e7b99b4460026a74bccb83ff6645ff51aad272e621a663c29feada6df848332bf541ad8d481f879a125bc4907334064843190a2823dd278f60b067c09a053c661124b8b9059339b096736b14c9432ff7f2b208f44bbe611668eea2d7b349ba1a2d05bf60c7a1e414be2eb84a29acff871b1de39260d4eefb02311e6941b6e6abaf70b2782092bd756e0800b6fb33745409e6d887628b4a6f5069515f7f3eec15b16b2e12c60f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
