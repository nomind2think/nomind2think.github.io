<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76b8d02fffacae68d12f39322a537c6ba03cea1f870694c4908e190abb6c2b1e954553a44acac147c4754dce7aa8b38310d64fd169f19c44c3dbd311bb28dcca7cc610150b19d277f1786a6a1033743a361944b3a33cab7982dad3a5847c7ea3a1d2e478adec3e3ce239550444cb1268530e694cc114b708d193d8c0c4f0fbe9ba33879a44676f1d9bd02278d5b1429b511046ee0ca6a92ab36a655b509c258b764d625a96055a83b7ef5851b7084e6bad03e37272d4c70ee454e0a473ac2ba98d5d8c5d3020ba26698e40d6a27f5a0f348ec74fab313b08c2f44dc25f5b304c97279c214827a195eca1a3b563963e6b8e784593818608d702c86454b4daf0477e025e9e7083a526087cddce8451f496f922b65b951aea0c33786d8c2b383f30371a44bf5ef622cd9f071c3d9c6ccd60168774c2e4d4e1242c96cfc1c0f22987244100383f94f1ec1f766540a64d83c4764100595e82e6524eea1042011fa8b9c08441dfa3f8b36501a85fefcf0307e66ef9cf7888f310f7246c7dce3d264781c9cf985ea29ae8a9f4562f263ec9e0a2b56737f8b37fdfbfe57d5dd59dd81e5ac655e1d9012d96d4c58f5ad729b8ec4c2186904c0a5841347789cb415ad56e21bc99d853d9d4840bbe25e20a219108501edfb26e29ad5db903832e1c9f3dea37d68a9a0ad40f13926f3671dc10449ce879dabe98fb64d24961635bcb7355e8c0d46c70a02cea5386de74386cc6aa4aff8f4cec8829c8665d3766152d2a0f111cd66fc517ddab39e791a997ed568f8d967d63a55f00c25b75c9fe742eb893ab3156bcab9625c1bd2d7380178852782827e89398287957b3fe7c7472673c79335a4ff2947549c3c21e6f88994ace15c49ed3d6399ecbc3a7ac2d6bc0055866e45a5ae360dac0a95d96fabae263fb6d66d7ced467c29761baed366396b8e327e93966ae57a38057529fc2ac7d32f214a47e4521e3d267c30fb51361a277ad820cbd53fd25fa4ca565a80921b19a20de164fe47f3869c59dd43ddbf76617999531248feb69a4bfd4abb701962ad346232c99eaa2d9e0103e0509cb8be10dfb853f1985092865e22b589bed11a4f8c8b611d141ab2ebf80fc98d7bf4efdfab4cf2b00037a97e74658e3ced8c121d3a94df9915d6076f761f5b9579264c4b8ed0ad86cf96b18865cd044d10bde67c9127c413c22b8a4208f83b37100cacb152d044273fd3887c91715cb57b71d08ec81ae8b4a1676774f949385bae5305a33ba47d30b8ed555b58175afbc7c3e8a0c8bce02e7702568f484224370afa423775fe33e2c9c132fc8478f3ba10386d52cfc505f0b3c9814371421af8967cf88bc24d3f668cc02c5054477c38ccb5ba6ad56bc8f78e23f7ff2c97050a48d0689a0ab2b6e30be0cccd7c4f37f17650df0cf93bee93c82294d5838ddda78058e01c8988f76c50c8d13c17062dbfed9969c975da57848126d906d6fa7c9736b73305f3ba5dd209d491a603e3003e890d75ffba1835449cc93f40dfd4bc7e4992ff8e80eec3bfbf6378c5106165d059a83018b1395962df0a4a9b91af46fa91be371b601e5b09684a56c76a051daad15225e7ef5075d019cd5d453a4e15bff06056461b2a624749da22ee5792c5935a010316a478381ca26c6932785f345808353eb67c185428224542d1c38aacb0390433f43ac05c2d6bc4b7dd0ad917cd5ab9b91338ec6e04bab872a5da750a9e627c47066f3307cbe21413ebf8de8e88eff65e20380c0df63497235a105f70174d4f0a2a10371070c5dc7a05abc264986337ebb1c2b4226746525f862e3a887509a1c3c9228cf9c06d797eb333fbe9895f6101efac13d6d8c85f940450ad84946ad91aae7fe1f00fd9d88419c7052bf687d864eb148e7b769d1089f193c6fc50f1e7f9a608ea26a8f4ac747b13ce92052c1457126d8388b80313a072e705eb6b5b6047103c280c9901c40ce6a560b4fad23c6f82e6c9f621a04da4807c492898214fa32bb8127ece490ff11a09c6424321fa419dc85907f33621f25f0265efc59f7594b12b65f5efd153673e73de398c1f3daf99d4a7c9804362c75d5e082613c68432c38969ce0d3130ead861e51f09e40c0e5404405c46a48e9da973c0ed47a75f51ce647148429edb5bba646a15d67fc4bbdc7bfda83657d044639cebc24b3be4dee4f26de615621bc116039f8a949527a5dc16ca62f305c0024d2568b8f40fec7eed5997dddc955e7eeb8c257692eea57e3cf3a1f82c85c0dae837e544436fa631dd36cf49c1ea2272df773f3b7a5d22ba246e69e5efd6db8ed05c1433411f4c885cb01be6881dc35f27a2d5e47c458ce4d8d4f129b4e403dd2de7c6462f672d8395f1fb917708db6650654673619c684a925487a7193644700befe3e9329bb90d71763f859bf46e9540f1b741d596dc4bd6cc85afc65ff5efdd5f36bad600c5533455a77c7745ca9481f452fe5725f6314804344b2d628940d06da4e64fcd9a5d895f10709429e81ffbf1c4db229bacd637d99aa7c4edefce6d43618d10f7eb4ac8995af98453e11e3fdfdd57baea27ea2400141f1f3c7c6c40313f679f129106a6e369141d4b31c6e6b4d85c8e552af9b6531b183d596580f06e1e244d312828254a82de0cd311e8fb44c72658c9b6fb51efed5c56d7d6ef1adb2824bf58315fbc59460e721ea55bf063418024784c7535fdd303bca43e7edca3f7c4e34b490e923dc8a2059ba8adcb5acec0e8f9f7ff230deecfb70f85cbd92c3b16338cc04294344c7243934765d9bb4fbdbce170e9cd5079605973375c6c0c3f5bf209d22d2f5923240607d9f0e92816d72393f1ac5c3de8a79337b16649a54eb646af56a707eb733a84e686f88003d510a0f690e059a90c89260f57a6949ce9cf9b9dda0d05ecd27274bd9fc0ac9e5b837a8db67ae5aba708cdd634b1e56d299b222c816a46cf233d38c07f5019a22801adbb50eb4d59a79a75c2a43d8d8454c77e960fd6c169b91abaf00e90c45f809096551d9fdbba2efdb15d4a149bd1f3c536b4aa285e4316fff09f2779e2173ef2aa527388851258b9295fdbe8382bb166e7e22375c3340059298a313d2b341e42d48d9265c5de8c4f59192de30f551d80642567a5b09ffc58f74ecffc3e33a81822ff4affb08132840650e81599c5325dde7cbc7e086022f294fec51d9d915252359b53145ae4e8ca3548f59151636f38317662dfb67ab243d82db30b4c0c0090fac1491bfa7e4c899f22a782d6cad690afe55ae69e07821418dba23afdabe12fdf13ad1b654d17bdddbbad81e1f7734babd2c1aa82a457d8db3a845dfb63cf1adc0de70f23d2296bf0bb9bd2c070bcd000f65b4a15eddff209b10243c2ae39c1914ed71011b9a02eef31b6d33285869792600100d08f1d1af2ffb0a57e97930ee204c1f560c6b820ec4e5409113a0e793f2ad88ed31d75464d7e45b8df1b649fb40c9d4e13d57964459856f20f12a7511dfb0c21dab733928d549cc6c87415474221555c39f283e81754be313bb6f36893ca91ce07ced43565ff021e9a258dbb0df4ed9539b04171abe69695d87a6f788875961d468c96300e32c194d5fff8d7ab34dd78436c08263e0dd033a032a1e576065b232f33e25f3e9b76469f8c9484dba47f41a15c66d2722c9c6247bc0e3017bccb1800a5b661f59e022fcf774bee3636efa94b13c81eda5330b2fa9efff7d1df68b44f10858086e15dbe26426fcfb5227c318fb5b649fcb7c2f84c5ff84feac58b882aae23045ee2b095d20312f36aa20cde87130fecca8b6d4bcebfc92d2eac23711e292cd4c35d2ecf7163da496f57580d3effc07ea3465de36b51d72c55fca6599dd758f2eb8b57784cef6ee8be4d8035116891e93760a3903551edc0b61534fb50cc7d91341a0a2a0f597b98f950447854a11fca91e03a296a1c5460fb92e0c0b0b5f26582bab8a1730d1cbd66f364588b9e3bd01d35965caf30e0185c1c58b408c1d49d3b6474d93bc49841b6d3cfc2b0d8a49f72532aaf59b115455f1780509e5ad08371e1206b7463b37f7ea5e606702936b6f9b58625fdb60867c9039a57b9292a85f1f90ab026ce82cd4c48ecb2cf32af80fd00f98de37920b655550a14780213896a738a4abb4c725e351cb03701560f656f28ce28e7d1cc04d23a0896380d1fe5f9d3f0879cee9d6fa0068b4b476da0669be77e0edac258f27c6384137eeb7e4e31fcb50879803005545c32f5bf67d4471bcc73f946a06221f88c4c8d31de46bef4964257841689687a8b71a7e8fcfa8c8e25f3ca9a4bccc07bdc6402c206d76e6c92c5fa2bfbfa48e9c449b0d16569102b22951abbb0ab1d097311e161f66b05ca98e511da222d8b9986b6033edb52d154269b1e5de3c6bde7cea3058ec2715246e14cbfebc08be72448c346c27931cf811e1d1247c3e7e8de0c92ee25283744e880df4470c248c6a660174e90149a8fdffb3b4f8d8e9e9cc5eb8c40a44e12b87735f2918b940fbbea750a1df4dfda79f1331e3bda3c104a44cf5562b4cacb1406078828ec43c879e7fd4874e6e1582fbdd53d07c5e3f9fe7a36ff5744eb825deb8d37ea0b84cc2181f7d8146b64b0760e80e1148711765ae79790724ad771fb39f0b0287a757d8eb2f394d7ae45c0e727aca33df08054323a9a8adbcd64bf51341cd3772bdd69a4b07a68767cd106f6766cbca0c2da66d8b234136b288c8821e4a9275c458e937aeec5721c6af65a1dabf6bbe21c9e52f9e819908b184cf7d494418b0fe2f4cd3d0bb56d6ed09d113031aefe9f9b0f348337ad46cc2f218355f6928e0f571caa8588bc1d4e90c88896e6d6688dfc27c1c94a3966a46cb101d40542ea39d8b2c7b156c40c5c120f36d842afc160daeca3a622f32424a7abb4e48091529eaa6c1c00df2b0c6b29fec9e9f2e7b0f8bd57665fa164c12b06f3cc08ca574293e54fdd63eed3fdd6aa9b886179488bb520e21e169848764a006d680bcf042bf5d917e2ac0cf60c2fbe935685c0988e51f85a70609ae442929b54140b50f9866afb851289b967f54c2d382ee90f1d1e831a8815a591081eff4d59d3fd0fd979985497424ba70add46b639dadb2f1b8a1b54c89e9927729da44a83ee791f23ff17a29be256cf21c13828b600afebb0a1857523075a01e0d6ab003427a077e7ae4d140ba2dd754c02008304039a91d9ab1cbefd8bfc72a93299fb40f0b7443400c64f776165069e7a5b0398388d1639b65b8683f1b38ee78f93d63e88d10b601ecd050443591c861e6f3a257e53ee71b0fad92a422debf3e70118140ef4828420f9bc4fdd82fdb1d78f5b9429f04f2f6a5ad76999d9cf79d4c6892bffcb0f04e65f875e8e395630a589991c87ed64b8c3d23814cec99e1706131506a666cad714b46836124746e1c07179c8030872aa621c53402e88516fc37625aaba02723cef7a5aea45f769861440865e7c7b4a6591689efe13bc2aa1fb9d54fa6747ad8a8c579f70706183672b59f6e6d85f2fc1cc68f0f28e2ac44a4e66a0ace50d35206e30dffe639a716710f9e0c83b649740cb8bfaa9aede5afd1820b481d6b160549e04c9e60f06344a1d14a21d8c55c2ea474c28b290a13763c7ed04527c9a1bd7423a4a0e43d8760eb8621fea947720d1b1ceb121bcdb156cf95595e72b95032bd08dee593b6729672a14231cd091b4c16210bab8d4b44bfc7394e69243e67c5d6dbd665b494018ac4cfccf0a13762ed683d9322d3e4d0d60a8c6125642167a4bf355cc9d3060a065aa4610f4aed9013b48dbcb6a5e73d70ef0e9078f7cabc4697b5c7479b1f79f0eaf763d40375d04d38e5bb689a6ddc05e69c16ca62833c226d4c1735c0f7d7eb4d990f1b9814fbb5d657d37abe3e52d22d537aab8afa134a65d799c24464f13335660543c9db2d0b8125ad5cfa3755d8893a28ecf1c02e4b5d193d9241fd9da956f4e79c445c651825e75dd73ad04b74f22ace6ad1d8beee5a0a71a8f72b9a7363fabee9f2e22591501182da88c21ac3bbb912c05e6f2886422b935d3551f27f043bf87fff43ae6db1a1c05c7d83da5b7e263162597b6673a7b4e0628612bedbc0ff2c939768cd8367c218495c4757009ba7e31eed3eb6cf17df508881f175ae7cdea1113fa7e1935e627051fbb61b9b0ca3555e7b4bf69734ee0c18e0b45b6229eb346b9194b9a2c6bd103faaa47aab78b8b4ab43b7be35b253e114d34fd071246659a52fee1e0057c9b84f948ab003f091edc39537d9689cfd366f05becd365c0128507ac06bdf7aa41d46a5d0f441c64c927da204711c5874c711d8955cf11209de938bd210f437921d327972c79154db5e29c9fd537651017d63f006218ff55751da3517762858d2fd44e75b5fb5dab6cad280b5d7a672d984f339c896ffd66c99cb6638d042b7f42970ab281d9ba92b87a0cf5479de58d524d09f82be3da58a4ce3cd7ac40da7678a5f91127431eda65e67ec5e87b0cf808c8f831c54024e859509ff41844ff7dfbdd2d6208d9a6d1793c75aa3e6227b3ba85980377e104cdcd214f8fb318c4e1178dea491191fb3d9bcabc383338ad8d0104c613de3ab9e7a17b29a6b999b03af69cc587c65a35e0350b20843a3917f2490142b8b1c4eea884848a215808c21bddea00608ca1e3f33d8b090372c6f9245ddcdfc84cf21b349b8282868c652bd3ccf6767a918b616e65a6cf053f0d08414bf5ac5360faaa485a025861a075d4b0c1fec34a3bfb009582c81c884cdf172c6daed40f801f0047f72105a3d6c34bafd539008853cd86a3de726e6907c14d99affc4b66a076e46f6a2460bd1fb1b9d319164f8e9467cf76fd375b970a973552b2e1d27f26e39440ccc9ed8e6af1fe1b9ea8d18dfab8370333c022b3f6abee850e2620539b2cd7a135be7a2f2d90b2b0c22fce7cf438df2971aa0e2c25a092c6ee84f92e884bc3b7239ed1da30b71cd46ac9bbee955cc659f1151da5d21c7adb1e6675b93e4f591ec9acbce4ca84f26ad4481678dec701571cfc48c10ebead53d9c21c56c028c5eb08b3d4c46b4a3bd1996352761f3337dea5af4b82e7abb0c8e9be134caea0de729a95bac655cad53a0885d1f053c72e723572dda0456280eff4dd6601dd34a4b34357fefbba5f416bd6070fe37c1eb847f8c05553b119ef2e84df2393ec1424cfd83f1510cbd1ff0e4a87f661ede320a11333732bb9c12fe087ef6d222ba3870250055495c6f74cf56d29ac2a72973b8802547f4d43788d81cfe512f0b57b10faf3fb416867cf5b555de35d988fd0a37581724e87b8bcdccca5930779f817314e4d46201477e389845cfa701ba320935193d7b70ba09b92a0cb1895452759ea59d561ebe70d0302879365c1ac979db86976ae9d34a156f45ef307afdd6783ff6322ab295e757cb96f4579dbf006da94f90e689dbe913f2fd6d2c30477a84c745ea9407b9136cd77d0240ccd64dfb313d8924862167358882cebe256bd2e07cafda88e028384db1b9a7287f6b06e6055c9555a03eeaae26ba616c93d37c2859c4b9650a63c7003821668557ed7bf9bfb94d718f53bb9b458929b0d9ad0b9009ed81a21c331402b21fe8403994edbc95cbf0968939054ad90ead633d00bb31f32b3b05e2bb14a31a3da11309f2a70c9a5f9813eae018453973cd2cfabda804c4a6474e81d89f518cde64b2e5e0704c3585c56c109cf9ed1640cbd7bfb1bfea336e99635e49be85c4b377a482790358fba3c1b8a3406e5c3b84f85125552dddf60586abb63c6da01236b34be923b0071c16d7a8a14e578431f2f41e3dba4afa417164f87e346e65983b79403be697b4c9f9ba98c6d3bc875757d64bcd44843cecc7b8938dcc30506d4abf610938143a836e064945bcbb327f3a3a8eba238dfeb9d16651aa4dc82fa209567c5f5e7357b4d07b7f12e1c06199912a70bf1c5df9067ad33e4a6b9a91c25639a27ca23be689faed5e5b2ad4d45cb5c41015a5aa828e8c02712ba200c6d66a5cf361ffad4b0d18cb3c665e985646a1abe2ca04b6639f30519d2dd191fc90d7fb5796285023288256a5914e429e267397e7601c1e9217a934e18311e7df51f48ef1be9c04965641a25c3ca8e80c2cba047add4c25f394c223139334d7131503f4b88b2d30a2272c7f05e51d079704351735df1d5c592ce648a67c11c0d5d9ca6bca73b50b4f01105b843d30a4ed6beb85070afdd4686e06314d858d3bc7e32a65b50e894823a4be9547713a237d0ee10faf8cc085138ccaaf2ac79854acdf1c608c30a781752ef6633557055215815c74812a14d3d879cd378a79a803bb62e60f6799a40ea33c0db6f100679a7f803cc14e4b5877a88ada23b8dfcc97b07ef1e2eef4de536aeccda322246ca4002dcf857ccc258c064b18807b616f244d22f1510df7600efd83fd20f4f6fb6a824c843ecdeef07c91db4282fc83fd64299d972c7d128336d11b7e41ddbb5d264ec2c278363906be90e45493b347403c00e458a7b0725eef043b3572adaa23728df6abe46d7f39546fa3190485ddadb3d51843b6083f73a76e998586c01e25c2c8065ad7bac76eef5ed7004c337dc74838955baa1e525eee9174bdc7508fc952a6966c966a53b67df8e38495837e703d0bdf8c34a34472079d4f456105086f549453e510aa0e457e50fd9d86a9e9c82fa764d42291f631a58986f7a53041619d1153281d8f72bd43bc6d7a9d4a7f2bfb1723cc7b1edcc0cf303e9f1bfbd5120bd2a8819a8755c1d70fdc7ae75912356969d6420c001f134e6eea75a2f3ecaa84eeafdc796058ac5a5c20209b33d100f213584ba20624791580a373a3880861e06e1fdc9213e4b853d8c206f099ac7861f91b7d1070957bef7d90f6adcf7a60246d2f95a4f7c110a551a8959ff32d88b0fc68151688eb4bac4ccaca9d5a53fd8468e30a1b91a80d84d27c92c8f1c640e038bd8998a9c3452a8674c08dabb966c2a8396fe919bbffe300a1d7d23673d728ff71aaebb00492fdd950b6a6c5c7f558faa8a8d6833ee9b7fc252eba57e23c763d1d9f7f37839ca2ba908b6cecadb1801a1523242398502dfe6b04ad8fc8f71f629f42d8fefe9a26cda44f268b0d3c2116020b3cd774366b22e7171ce5ce4f9968ae8baca61247c2f53d3792018d9c18c82086da6f9f859613bad09983c7547b82d4763f42aef9cc852aba7acb1b61653d9a7ccd2f4a1fb44aba105d1953eeeca07a18b7c4fe815dbc360ade07deb8919409d9ddfb97a0851b571fb537a7af782ed174bb8a1ee5c2843913bbc5ce526e65ec37459850dc87b85e352a9e571c0ebcdb5662d2d66a566c75db55e0556e92d72603d8dbd2ff462945bd9ed9d9e364c6a3f33d9d50ff516b7427edbf32ad968d1b225663ccb9e5c3067935d18531c0210c4239a51d93ce470ccd304faac898ca1300882c46db6bbf1da6c9a8db75f651f366afbcdf17e6d6d3b6221cef77c5efb863630bc17953cf40b45f3d7d8dfd50115b037f862d681dec997fe4ca353d02cdb1fbfcb7f5dffe9d674a3a56face18711db417bd56399042ca7a9a84b6418d36b0149de06ee1714be7007c46053f6b47fad8db8ac57116bd74ba4b441e88ce2e65fa5c05797dbf7059cc011f220b41b6a210ec80660773b1c4a47f3025fbea0de059a9bc5c1b1603f406e07b694dca0db0e2fd6dae607f52ecbd8de376fb9ebe87c02b450e4324e9009017fe593ddf189bc993d8f2aac7b7293ea200932796ce0a36cdde8bfc0dede409b34bc01f014e0f04202cf756ac1d976d0bc3697246922fbb4523f068e8c6781b9cf246b3dbe3faf610e03b576bc25acc327861222f85ea4c3c1b04c50e987c5a451decdd0aacccdf31d678ab58169c28c5cdbeb4a30d449a855eea91b72b79e5ab171f5768b5200e65513a1993d98e0db116fa4d68d749b79dd8bcbd4e3821acfa2dbea45395c3957c9aea887f1494d2ef42559b58f185b310afdab2767879c26f155254c5e7e14fd26e0a91623f4084d396889184afc624cf10daa5d75b3cb0d81507f7d1d4bad3c93b1394dea2a6d6354545a25bf8ed2afc634b4a0c7b35b304b893744f7f58f6527fc08d06767a4a84f29e927e5b7de21a75d705a82f75d603f290b817febe1455dac6dfed2fae1b1c5b67bf4f5fe672c763c3657f959c04005ede46ebddaa1f858c215cfffc0e4ebcf9003abfc017f347fa1019da15fd36d9acf53e404810db02484cf14f17cf2d12c74f3039e7a9c8c970eb9fe387089f475932e0d21c2713b86fd7f080139ed77511e121c6ce9df4d6dc334ab02b1e869d403d922f23f7c844d901a561495202a77674c6a69a984532cecf7fe739f32ad320ee209ffe00dbd3a79d28ceb6d63c4ef77639922117f3c0bd8d33d4fb1fb13b06c81f463db5f1ead1736bffc384ecf4d7f9b68fbbb2023fc640e440e386cf6917b9c153231480eea136f1622e7b9ffdc4ce8814a315284684a334dafdaf3ee12660f9f60a10f8550881043dce0d599e63197f426b672d4b9c519a27c7679d436dc62f6734a96366e6b6f8c0fc0d76fe6f6d249b6fd2512f26ab6060b3354e462e656875ecc5376682b363fc69183abecdad96d626cf1a764437ea11af2dc3930ee3a3c74fb0a9bafd346c99ebfb15488692e12e4dac5b99697b59b88b29baa034a23a12d0620dd196b1548cf2111eac43abbf9583afa3d4bce6a7ec2398662a3cf11cebd465dee4eca2f5e6d63719a173d73be42a462a55334919064ea4829e9712e512b1c644dfda79fc5d6925d3cff3aedab2afeecf1f6406946fbd3ee7299ff77d569c7b32a5c517050109cdb456cf6a2883a160e4c535b7f40e1f1e8901ea7b04959ce953fc5b907029225a9a7c7dc512323fdf3eb924f929199288804d3efeb6b957e5aa8d3294613f926826c6de5cb6bf919f6b6143ea4dd18dc0a624375411c797c319601b3a4f1f0c9b533e249f5e73dbe2ba46d12370be679c5ebef28fc8aca73d0d9417bafb5b74a3469a9b2c7c02a59a0fd0e72fc58ad9f235b9d276b408894e69a77a8435a8eea17f32d61b587cc30c55c3d09ca2b8db1b74fea9b66c05c0086d8c532b883cbf2358cc2657bcacbceef54c57f4eb9a3f64448d04e133cab5a264ee1aeb0a26e1c78661aa6392092217b26a2587da71728993414174d262cb1f54d343134f0cc508aabbe340f7b02966114c939fe64f3b364c80d9eae708fbc93697aa005a81d86e236bcb88107df15b3819c82ba4a149be5b4926dbe38264655b1a42ab0e616741c29327cce7b4f3ff606fc2232006ff79a4c47704f1d509b54defcfdc652724a807981e85f404234c5742a293f967759f950e44aa11cd556967550e6a9afce9d40c60440b490af462cc7cdcedf14e81814f5f0339e3656bb781eb004ab3a36889bae84f4a1ea112f0418d830c2fe5e8d53836b5f30c602ce6ffe0111edcda303811860f6ef031eb31994b35e8d4b54fbc66ee40fbf051a91655350b09cddfcf8447bb1e0702da67bcdf8d604863d2b1a81d4a4ee2c71b350b7c4e630379bad896b3f48b849afec34c4f96e8d8991bd5bd003fa2006870d102297d534f98b6fc25df43597cd1440f4d84126bc6f38949ea48d2b873df4f7c78588bb25eae75050e1315715419a439de1d2f289c8396646fc6b947f4578dcb3cd01c59e3fda23829216617c82421d1aa0c6b27aeb6b943fbd1a1ec101f70070b570a7894928618c6d003a434f9d8733af89e0e30c31b4fc50f92b2fc148f350c1f568f881a448245ce0944c5202dd3caf02fe32b8abcef08b9db70380db6377ea65d21321571bb33829466ff3ded93582561babeeafd6cb7d9568eed8dae6aee8e5222e41557285f2a666d0fbef3518f07c5c5cebf9f2d83ed95d53a7a71e52a265af63862581cb4828c54b0831b3a76816e37836c9d31ee788e218457ec5400a1baf267ac64780fa5b74a90163df970533e8be956942fa6540671391a64353848908e6fb9116010f8298bf53e7cb659353d6f242b23a271160203fa81e6ea8f178e9b9151be9e4856a74d003e0ec810fab2f13f3032353f4ae7cc2d992c91deff7fdabfc389540226610328a664f9d3981f36b0f032aff3a030c23343c52bf311f10c79d79c04508f440401c33c212fcdbec34586199111c1cf3c4481efa46ba0c6911af362cdd3cd3242efcd874ee32911932177ef42682e4185e465d5b1878c95f895a45c422c070f9d625876a087645710e2d0ad96616dca54c7e8a6fd0231c15095bdf4fb7a9e13f450770f66f6a1279a4d1cf57c960a3663890fa6dba0be8ba3d8f9a924601b1ba6533164d54f2a0bc4d3c014ba56e3576a46bb43a39f7e54f6fee74929f64675913cbdeb730a8ecaa8cf69f98b47921225f63cf5e4c5d6cc922adfcb3ce5dbd7883baba67af4099e5b5d11e06502b61f215276a500ffb875dbdeba57aff17d835fb1940255e554feb270b90360fe0a7f26b3efb10b11821acb5ad91e46c3e617774c6d0c4a58a28b00a1170a66f5c81a2732a3d1af122904eab2c0418f4c4c4c25567dbbd6f85459c84d597f73c381738afc0e8c8a1549921d9188503f2072e226ea7589a811374d236bd8458dbe31b529bb6f5ff212145837c8f89ad36e4303af042734b78099811882a6a5bc4dbb3d84517a55d303138d3ce23459f0ad6ceb4ce8e237c7df01fc9e60c0389730442979aa87a098421797a78eba06bc289723066de54217d2549913dae71fbf855d9f77c97a6e554b006c58d161dd134327b2b2cd50440de55c0bf7f0ed785db33894696c69654c3fb1b010cf27d60ca9954289586d2f868cd8d4f3a4be7d3948531bc0a165cde3b2ae09fa9b1ea9fd8047766eaefd3f420028a96e2a47e48d65a2d0271b2205ed9097f13526df059d707ab14f749ffe3d86da1fab5d9d6d520a58132b13a0c29a49085edd604db47cc25b49cf66a99d04e0d0c98b5e8dfe985ef8a8821679e058b216a62aed9810b4a4a10bca4a592e948e6146db54f675a74c4ef3c2dabd64170a60ebc80c76c9c0ad922bf2531e71fd420a362bcc92dd709da9f9f7363cae4fc3eb5d4d208c8a80a78ad2ab4554d5927e78519d0fdacf12c0b6c8ada82b2b944e7fc12f53344d098b943bfabe9f6b3b1b467adbedfd42a6acc3dddd2b4587865ee9ab57fcfd7c85b174e96124f19e544dbff9fdaf9a83714a99e40f59d9bf3e6d11ae17b81c2aaff83ac3dff94adaccdc6f37fbde0a20ae8e3e4ec10f60bcff3c4e5cdae010425e59f326185897a718c398a759a37b3e8ebf09d0fc4051079009b9bb3ba4f5019d07ca4430db56d4ea2969cbab487723aaec47ee06ccea04d487dc7e3cf96880353728aba8e30adaf3624534a2bd3aa051f9cb879bb48aa7eeb52a4860af7a51d36130783d722533b779930bfbb437b7e9f5879dd6a904b251686e3666059fd8a0e881fd09d19287f4d9e5f7f44a75ad8c6f2f677fca381e738a62a7c211482d08b8dab4b144839e5cbda2a4b943475185a9804dcc0a199e193f924bd03856375a368165a20c06b078dd149bed81042166ff472f7d68e09d05c08eff7b4ecb7e5534c85b79aa416acd09d7155022bd6f354879b73ca554920ab5b69410d8adf45b6f027c150c727c49082eafc3a9d4dd6bba02e5325f22369e08c4587347adbed738480ff7501cee215ffd0f722ff3d8c7cc89bd325bc9360223d2d88f111599f33a3804f628f0c8d596115990619e10dc70d387d5acd442e8704e75b6459b7bf996e7ebca49d6f11990cb049b3585c4a8adfe0153daff51f16cef3a48a07e7668b770c90bfee456e111b2eda1b70cdf0070e0352d3a9c8c1da3f8a8cf454bb6d2d09a2b9b0244677c3f56c20296f22246bb08c171482e3a56c324ed68a2f734de657686d26260ae7b0f5c381ee9adc0cbbf7931f94883e5783c9a424b5bdcc18abb1bcc6887c3acaedc3aee977605e465bf582ca8b2cb4cbab007dc9ebd7ab89ca01bcc8942f7c2e3bfb58c1080b43751b82c712b7527fb108c02f51cd0f13df63f4446005cfaa248af733b1d5799f80274243f77c74043a68a1d0003765b71eb289585b924c6e19d747cf7f5d4320d0f80032a5962127d0f69f592d4112520987363bf2f455355aee66790f3107814d92f178ca3709cee9ce11e44eb31b7c08b4e9b789a722a5d5719223f0733bd528725563b472515b745aa082a7b58a226765197181a1df84fffa0690607d8eff64cb363004d90aaac6b1460cea3c95c8aa52e46480e306b6d248c3a56fa849d673ca6ae1903eaeb32ca98eef3fd00cea0f35f2fdbbb0287a5c6afe770a3b2e03149c08c2331c0f2dfa66631d4f5547849d73e341eff3d163ec66f7ccaa40ea049f4253d92c13f76bf3cad4e91f3bc8137171fa98f10e9e524fe5477adfc084bf86b45ca0680dea2d516fa8c2611d340be8e6bac0fd26f73360bb36cae2a79a327a8cb891b5615afdc6331f4d92c936acdae6c54af3aac15b4107e6df685165d07bef95a077350a1c1ad20907493a9fb80e080f76940824bf10301910670f52eb43df89f0f69c4b98368110fb8358f8fcb1567988f6d42b860f73f353dcdfcc0eda1549a4c1c1213018a4b58b57613ac93a79d4385089c2c32109f4b7e235d491f72f49e94333aa0f302df551be640dc62a4da3c9052f2bd5e844874bf608b826c7ec9f03ef1ea35cfffbe43059ca484426e7e525591f5a0f036d0f1db4fe9d3e5a8196d6ae7021ca6b9531fabff51a2c8902e965d044590f024997ca314a773eb5008a20735c10093a5ce07e3499c872dc914a5c5d8ee23dd8d776dc1891e78422e7829d6a9f9531ec0054cdda0b266ddd61bca5f8ea271895338ecf732987d6fe18e60c6ec42918efe243956ccb533d15683c44a2bd5f8624b1a2b17d67dd3d15fd2e489441d7353cb5ec767f84f864207dab233608b48d98ed66b668af0761daa8fd8d8a7ab4ce520ba051a8d89d70aca3569147f0029cc71e0c31066b6b170b78305a16d5fabab79196483f396a40e7f123b1c111afd3d8cb5defcc27ae54ec62b488fafa3afa6bde517465f03a7765fe4f192af082f682886d65859fa38df470814daf308d5c62b37dcbc438a7313030a1c668bee3c11ca9d521df14b1458d8f1f05656d3b62e985acc5ded6715900777bc78115ff9003ea5787d97576e56e8caf2d7c39ecd6fa98b1458e9b37dab6c0276a8bb3de7bce9ea53e537745ba173224c1ea3fcbe59ff38b035bb39de5f3c22018070cc17f25a420b70561fa0651eba5021c6091f3b4527b22bc7c239a6a7f9acaeeeb456154e3be80c89ef4d45df1967cd8fbbc07aadc7bf9b0bb8cabe3e0c218c24d0742577ca560d3546095a7f96069f7a8e860203256a38c1aad82ec7d835a9ae27da8989894bad118cae0e06125b64de18b26a21836fc714b591a3d5010ac54e04e6f79be4da1179637131f81ddd7698f3c66126c6e39d962de4b2cfe3de3d6fde0eb337688ce736cb7f03ab3b95d79444ac9417d61afcbe5ee684e1b6906646e31a20b07f5a8d10493a4e743b92977a55d7484761ced41053e60f20a7acbda967d8f9cef148432eca2aec54bb157c768538e24b3f88471d6bc5285ab18c6f4b973322539ed8b594e495361a5f0d3a127cf56f1932201dbfcafc4375efbbb2edbec53b6b6a15c55d2744428457f7547d0b9c8d362dfb800765a39acb8af2c5dfdee5ab1fd16cc10d1ea5781f562cd030f39f54f6ccc5c0e1d34a161142dfb7f85f2d6548617bd498a0cc8c3af2b4e8f605181d2839902ace2d3dccf21f63ac93e6359375835315b076b5c0943a187d8c7f863656c877948568ab8068a31264a8a3099bdeaec5c51937f791dddb5b4baf8d5af9d644cf33688f4dcd83505e518eca2a23b492f4efb844702021ab579c8131b6dd3cd5584b9ebdb0f60edc3ee61dd7d5b9c0e7685808ed85cd8dfc9e0e8298000c91c33f17c5d6a3349a67ed739aef6c2295fe750f800f9c4b58c2c9e5a9052add3b14e036aedd6ff22fc2fc966a3c01a53e043db0c6f478585206f51603a4cfa10bc9295e0b773fc092bf62c73aca1d2125da7bb90de614671a9ede258a9a033e5a15d51bc91813d3c738576b18057177ae766260fe162d359b7fea46198b5f1dd17cdec6c97ecca9bf64ddcabc02be4ba38dd1ffd0c7279dcae374119975caa3030a005d17fc0d518fcbdbfff35587e2b2615e3edfafb5d001c0b90e140c070f069037c41fa56e92b3f51766e955b5817a81818793623af39997bb830abb45dcb106075d2116b4b292bf416e80526cf1d9b302e99b00cd88e0b933366a8898950f0f457b2ac4265a4a92d6c34e2012f76597b6f08c6b710a595448d869b00fde135e8c60fd2735a274b155689f751811024d030a8e47f31c1fe7f0bed62bb463feeb9eb4b60a6ad2414dfd5c2317a500aa0648550c254ab3efbf121dfd0ef14035ee5250d751a94a93fc33ef69595dfdb71a8e11af1dc2326f02e76f91faf58cfe70b27dd58969df6714fc33a21a85a7ee02fc58d474b4831f2c020a5af45d171df3003649e2017a99631c27cd3c736ebfc98329db70072730c921d98fabe2249a7ba42e2d5c3dfe2831c91277180bebb363d354491659a413a09681b41ae2043b0f8fb5184cc0cb940817a1aa613bd5491fc69ec567d518f9cf626178d46e03b05f23a2862bf7385c82482cc3ad98d3a9bf62f4acb8bcdf9c72d2f827fd69e59494d7e67ee7ebda83731c8d66184d46ab9c8c8bb20050d87b0fbd65712ab14a81cece8bd405361950d6d5b8320b6a64e7156078d90a76011425778384267ac8e2f0070d44f6f4b62b50dc5a51031a8f7b6f4f1c21616994f7cf59db3a4764bb969cea1d1ed8eb17c574ef47dd2fadb5c8fc8462839725d8bc9f7669dc8f312f3155fe7f29563117f746180ce2520aa6fdccfab703f679450256265cbe41b7bbd14dd22edcca4ada872e1495d4e927b49d7b54341d27b18baa9668995d50dbf6d65819fb8973e4f25c4127ed27317acf1204422d372d4dabe436769f17ff00c4c5f3394b3891b321372d50a767ef8423de88aee7ca6930b64e05758e719143af9d3a735b123c17618a29d7582677b2da564727fac466b10c4a84d33498930cf5b5b097875e798e102b90c9fb96070c9dcc39b9c687cae0147690985c3e4f883afbaa346dc47cf1ecd6325ec3a0103b4731523529cf74ef0fb35dc427af563437050e3830e1cdca50362b87e9df263f43b73d20456b3ef4e49c7cba2bf36ab306fc5df82d28c277ac3cea3135e20c2fe44ecf45461aa57f04951da9fcf5b168653968fb9a044ac4c5d524adb57bad1bc7e7e742f34bd895be41123a6f81bbe62999b253b13a9143e3807a09c9752e6de558be0534d16944264f127f0bc94d40fbd7fa69e515ae1d5c4eaf4e0dc957cb98a8f75591398aa72c445bd73ac8346aba82f764fb4ecc860627833f19c87591b3fa1208c2253ba37522d5e076c8c902ce27e1e09a24274dd5195dd8e5d21ce427ce6afc72f9ee4e628bf9995206416fa6d10f7e5ee02d19aff5b3a6ff75fe10d15590875b9d2c483fbb5a98685bb7f73673c3e4ee70c76b86aa5e9cccefa2c2a4230de5065ba67ea7c92e17ad03910ba606d4d5fcd99d0be08aad9f6ec13bc628350b247704a4e1f53d8547c40d0b5f01b9ca7d19bfd3c61014120e93fa5ae01fcc5f08167504210e6543867fc83221269517edf37a968f216a8d4628c1b7ebf77bd4b9291a555692345c5c02e293be507a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
