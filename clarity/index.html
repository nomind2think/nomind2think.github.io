<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2cc72dc18aa54234340f36b143e9a7031e97e3e7a80c9fac77ed003536482cc83c3b79c072528e4a38e6a15795489223946e97515231e8ba93f51f268d254c73e38d0ea5bb23ec8fc9a17ff5b9cb6fb1509e5d2776c661b8fe276fe824eb2690069508d045ab588dfa1205bd9f8c6b590b83309ef9006123df128e5d6507212af99d877cef55bdf82194b5da153a9f85b02d4dc87e5fded3facfc62e5ec1440c3f5ff72bdbd1fec1e48e85ae42e42629615803432d20da2481b719d07568a6064e2b270f519dde0e419d2c316489f73c58a3aa2fe85118f9920ac457611c571de4d2a404eeb66108a6e3f428b4742347ff2f5196c35640c10978738c85f9d2dd50cebb84c6544baa09c4ccdb557bac197d9066c704d36dd79c29edcdb32c82a1f8b9fbf1501fc8bf28f9b3705dd0bef7905bd897c2ee40709d23cecce96b7804272c31895142709c5fc2ded9a96ff4c9e276009da6375a7d261864ecb00d36c7a7dee696beec2bbfe22e38aa067d6b5439b6ee4f3579f2ca0bdc2e43610f0add81a74e9e802c4f4a07749a627761cddb4b3af0cd06c1d925541e31b71cf497d4ff3e230f850aabaf0b0612cd02ce4702146fafe5f5833abb946a61bec1a843b3e016781caaca36e5d276281a122afec32b3b9e5251d35cdc7cccb06312824626995eb7596e7dd5773102ebc6f976d4034150901d070a01b275290ba6642192b3cc40f64b503c0ca30abbd08b544a557d678ddf2453be49bd4b90cfc762933f354937183a65cac1ca6db03c7acb8ecbc3f57722952f10d6a25177ee86120496c091f4f076312aef6771263c19c6e5ad9f190dea4ffe8e2aa9eddd00784822dc3e04ca9a4d2d15cbbaf896f1024e1c1f7bc448a9632c659f4946bef908e25def2c88a5269e86520364e167389ef15d7b482810bca6526028084d1fac8267ee76224ec69f57384aa441c0ee28e02b96db00e66d02433066240b5e9bbbd602e8155f80f1161cf9181de347b929b88470a65139ae38f2e69b9108f773d30852d902485fcc36da2ff77249f907edff4b4b15b9ec592d8b4ebfc431fac55d45da939e2a8fc58b5c2346700cc7e46ad240fe03cddc445ce874b67aa9ddd47b42f62dd23867ebe87b5493238fa120f39c5416d680282838c23d81139dd656c2e2e1720625bda1dd23b93ebc627ac76bcd6b73ffdb0a8f62acaddee3c7471a73d8bde649f93db564c450c3714edc1300b057dd5724eb7f215ae8820c8dd36b4f473f5176517ffdc41aa8abb13c63f0645ef6dfa708e08d3a07cd1df36b4733c01f9c1077c0d22f6c72fc49e19f17007a3474c73c86060e42ee4c46ddc4409a81bd3b6af0952bb2c46c5ac33184c111d3dbb9dba3a2c2f7e7546e3b1055f2a6e52edb74d13b3696acca814c67bb838ffb4a658a8e08cf356ff063a3da4099d62d2656efc9b4bd9f95afcb92a960cf9ee2f51e926e54143f2392a1cd7965fa4e0b81b50a1502289650332955d62915b1e253929da3a0e59799c6bb3c05e3b8ee9df66eb69e38ec060e3126263b69e5b7734c4e8817e96a43f54e21ad26371dd91e8ae41b9e6e421301b9302cdc799392ef299512160ab15356c62fac137bdd6064ced6cf1257a72f23684fbdcf157cbb8023d2f485670f60b0b98cd0e46d821d5fa15036ea400d911236407bdda73c8f5d5c9496b3328caaf250074d5ae036b8df08a27b468d7be5ca51c0517fcd3dd2c5be4a0efceb06f133e217576ab5c661a0eb7f5c43191c8587d891b6dc6f77228faf6a4240f0dd375160858a9297a7831d24b56dd1a3d723b756873addac141d80cd0df03a9d74f1aa22f22f757a972e20a3457e60655dbc4b7460b234f21f2f9a58897585664457dc496c08350e4528ead9f7112d9310afc27ac763d8c3570dcbd204c8492d80863ff7c7c02591433795b9b9aa02a5228c6d2da163254824eada4a27d73843c72a25a0f92aad9482e2b1f829ca5f58a1e7461eded7973cc36dd88f3302613652102ef7ae622bda73b8b08b08a261574f53c152fca5c56c6ea15eed2bd2d67f9e14380513c959da78516ed99b8651deeb7cdfcae6ee9afde2c98dc8bc23e147dd27be77185c7fda60f061ba646d6332e19ed94e90ff40b097d59b14a161c1d9e034e68d198f1cc1fe314fb1d7c8a509aa6c5780534664bde7081103d02f64b53780c860264be9231ae1857a1bf13a293d18cb840618e3159d4b17e2d54ea8fdd8eb0dcbbadd29c25b0c84061287e55d832ebe7756918362142c086db082634ec60b2f08a51e2e71a4043ac56a2eb2096fbb810428909da2b90e1127bd3cf4fc22c9abeb2aafa8f24cd7e2ed1b7c50b5e806f4794700cd348fdde6da85f1e40dba62de72cb5231f485366ffbe35c83d5623020ba4ddf729143febd2d8fd917542541367cdd82bda6cb3eaf90d4d99baabcb53a37869820a1162729516eee7612f3367c72b43681bd36ace354e878dcfd6d8c7ca3e3997c8d97350ae022018f2b91f4b49ef056b9215db2f0d2c5dda6aa36dd8742ba6708d81caddc70f7e43037200a2c29dbb32ae992b304cd2d5849b157a2b02612b0d0b914997d4def42e2471472ed7c9464a0f89b7eb6927cfa4c3bde9a7ae8a4d624a5e9c9ef61a5ea28778dfde70907fd238329bac75e383548a083259bb599e34a7e0e2a66997c69dea13e946275973a75c735830dbd5464d2d597772f4f9dcfb4117bc508ccd73c69d0e4aefa8078c716a95180cd32eeb763156bd154086d44ab96a49d795f2b674a60c7bfca781d87a538ea5e7e0ba9fd0cd3cfc0f51dea15465534cb20fc562bfa3632c948a8a3541eab99115c451d4e30ab8202b9ce5dafae924e95f1cbb7239362c5f00a8fa1912325a02f74efe1c5835cecb5aa04644ea984e61296db220112251f5c33f6a2d7c3e003629ec5fa37dcbf8c1013aa2d776b0d9d07bc1e404cb5615c1da7dab3cce2e57add2662ab88fde97b1e9aec3e2fb72fb5cef0713ee2f02c8315defa64ecb4f3753a451b2fc57c95a4f9cef369b87aa9ed27fd7c24c6261f560a81e6c9e57d8aff48f9951f9639d267b75652a1cbd2db76933f9bd1e2ac220edef4aa592fb1c885c1231219c3856d874c2dba41f1d5989fd6bd89fab1fe9f730c7919b6935a51640256cc515201c15e733244e66aa53bc70e72a6740f44e7670b32cc52d0b4c1aa3c99fa00c729e841ad93a6f3d4d75348417d5401211cd743061f28eaca2cb1d6fc2c38d3bd8047de9dc3bbef8a5c1d4efe36aa871ab8c205c555ad0a9bae1855bd43e8016c80fbe93166edb9f823f1db569c99c3a914bf16c1ee98b2f489cb22fb6d1583d311e26fb22112630a6f0c7bd65da66510a875241c0824cf474be56b4c45914282d28f443c8db9c2c8b1163938ce137e1e562abf60260ae4cbad64bce1f90dc15a275e94e586adac606cc5cc453edfd257f49a7ffe7d968a8fc9fcbe25b2512940b43897827a7ee1e13d5382380e7d9ce06c59f28b9a480d3b6f7be96672d074538d6a90da090b1b330e911d5f6045f652ed8810213c34657b2a3f28c07a977fe7768577438fec5a1b65224fe801f4110ff9e5b6b91cecc923f89a889adc63f1aca93524464c824c2d345f3579c3837f28fb1533ecb9c11a3dd1df07948c63ba6714e3dba7387ed03afa548f3220843cc0d77eb870ba182e4cddf506dc9049da6742960e2622b228fef5b40da81ce669e32fc84fd51856b9bff76f2a82d03e64773b5789a7c0c6ac3590eafe06e92f68917a90e9481f1fc06c00b4a217381680f10cfbd0db60eab6a1c01c8c9ff6ce72b5d5e7c93d248b4b7d159777cfc49d5c7cc6255efba4b0d0a167f10f33cfaff1baababbb9e6255dadcd52f5776feb410888d87aa9c24357192d06878e369a0f3c3a6ae7c6ca1c50d9fa3d0223509f71eb1c5c45eaba6848b13300e51f21f25fab79611add3876e82c7be83872c297a9107a6b09ea205a07b9a5433394eab758d688dc9ef63fe51783c71fb4a26766036cad07243ddf02b8304d862947fb55da7dfc92d65c2a1564bcce0b4aa01bbb6abe4ce7f9373e0b088b285364aba3a416b6930085f3098bf62ffffd95e13aae2abd55a19cfcafbf8dd4bd136c5d7a6f67946ca3274d8914f11ae43acdd47433404a1515539140fc0b27baf62cdabec4e7422565e365a2ee219be3cdc75dcee4f323d1143f765e3be6a8856b3c53d3d5b6ea789a49ae263e1da4bf815e26081d6ba6a072d6ca3cdcd92870aff37fd8721c57c1ec1ffa7107fe65291ebca3fa95f123a0ffaafba19aada65312a18b2ab338c787b0f4ead23cf0cdf2e4330c06c13d64b04cfeb29bfc55e878a8c38ef1c4adca44277870e66e7d3a5ea8d404f20ca70cd6f4da59523e5a709406397f461f2746179264d85b84c3c54224e3ddaf667f82f816dd7b6c0673e5493264b91e3070eeab241dd505463184f9c0aaf167bbc56f5af75b12fc0d5ef4288cb994dd9f13187270c50ddc92e75adedc6a789f785772a615473d6d22b54d6a6a01cb13f210dc41581814560e9e0a09aed576dbe8b0d0cb49e50e60252538652067c6edbe8833662c92de5962c258badb8a61457842fa8580db854c8e9d3f036f18940b6246524a883fca0adc0eaab3cd16c5e3ad896df76e2c4fce53dc039a5cb0fcd75fde78d1038bcb3d2e639b608a91b04fa5514d6cfd5f579592063886daa917b065c1b59368655167c6baf040408cb6c2979971e7fbd7778c4a7639f83dba08b4939bf981c0adac047132738d03774e6c7dd6f2eeed0a08814f482c559afa712c9f6a736dd3af633a9cbfc6da8b4145d60315762baff7625d0e27f7382f12e34bbff6035ccfb5fc183ce02d60dd97eaa55930d3771e63047fa7ca211f63ffb5ca350322d8e53cd58722060251148e038a93f5c8d355b99e21bf9b5670a7f4bbe45a4bb82582187e6332f695661e3a9d08a1cb07ebc4745441093282816300e6af017d8a481ac7b10d9431ed6dc3c6a3007ff7850cea8ed8321b05c72b05adfaf3887204caeb2e1cb5a1c37cd5e7ba15c7793e0425b570940b82d3f5c8a684ae19ac7f8c3f6a4fbaba7dbb53f678ea6ea5ee1f2a8f6b62a47bc184eedb6f6895256fb30315340d8ad869c15c93bd20a4c1bcfa12dc57b7e3a83b2b594c7169952078438f6a04d7d12359029826749131a849e718097faa995b37a14cdc77edb8aab400eda1408d079735d79ac04d5b2a6b37be1b5f8ad469c892c050f9b6943141eabac7c7b3f51745507342dd8e669970483db47d7baa450438f093873372027e5cc493da549f64f26eea67f11b736c220a6cfce6c7889a4eb1b38518bc595ea98167b36c1fd70ef7d009d9897ed1ce941f748ddaab04136ad94d895ef85dfd86515083251c4dfb2646e1af557ece1c8684162114df8f8882255d7f09a1ae15f39b45f560b8da80720a9dda4fed878287f19ea2f8ce15985390fce4fd56dd48fc2adef183dff8ee7e5b83daa4c26d0979c47f12593520aa0de7e4486b9816443408340c5f5e4d0a662a141997ab3e378ad93c80f247cf317fa32e32d5f6949bfd879a0c828138a5eb3b27c7f21d8a2c7205724dcbb2316b5c8688fd29bc61c1ade5c0e4c5e6ec6cdd21389d4af574bba08e73077f9bd52c4ac012544b6740b69eb0a06e65a63c66ade017daa808453f4f4c669b554a89d0929f81118c102539bf58df5d2a2472ecb369d306bb5c8cdf97b07c60c788dd585f1604ed2c20ca39adb689d0ce337f7f2a8bc77b1f970c67961a8278581d6efbf49ff798c5b8a16cd0cdd22bb6a66fb2d6eb434bc7a99132d179214b04f6dbed2cb81e62f4f3685bffa17f4fee26fc2137d1588c8ade76cf0392f8ef391bf642c6841c0eab27581da025b305b10ee5da0342568c43fc98aa730a9267ce802d3da8a6a72b1f13b12edaa39be5fc97b4906824d40a1d0303abfb13ce9c2701048ad3f1c370aa47043fe4d38f2bf27059ad214f85729639a5b71c74310c54dd8f4187af5e9d2f680bdeaf25ca1ec0f6b0731489c7fd7faa01169f69d03d9298a13d01b35785196b09376040c8946dcba2a373a8cda67e250ee37a6d9e25e474861510bf05afa8c727d4fbf176c7d51ac2d35754485a1a14dde1ffa673bd5528393885ac12b5461d6236c5180293f6954a996afd9e0d68c0fc8a36fdca218d2154923ca1aa455664ef632f0cc12a6e6950dfe137c1e772c56ac4923908499df3d56896bcc03ce028066c3aa9ab67ac3c6510288856ef3402132dfc01ca1fb003de966b7bbd7e9874d634c36b07dd344ba95ebc4eecf13ab3577619e1c4db947652aea5d16055ed938b8c430456d45ae8bde1ff424c7b6c46d6ec0fcfc0183e50b9826bc5d5653fe05c7cde31e8c958dde2e65fc8eff7fe2bea48e27491b25705049e22cfbe1a9dff74cdb39aaa87b52653a3c20c63bc9ddea7fe5b8e327c5db590b54c45248ce8768a6c305733c0da5fd5097e0b1789e9fb90aede6fafa25d648d7f65344878b5f33b9bbd36a320676d82c38a7459842169269e4ba40265a04f5d5e48e8977cc371bdb5f814e8d35d01d3bf066474e7d966c9f22801f4bb038ce67e0c8cfb7dc4e6cf61b3300378a0e7b9bead43374c3d8a54570a94999e53dfcea2504682e3399a06f8b62b7a33c42e923d697d626d445d1b10ca1b9a81f3bd1bc93e8df10cc770d7d20d23d421776ea927fde985a0133feebba1a499dbd6c18d9713da966e25e126cb89fd76d808119b15277d0d62a007c9b1966a0a3a2f8025892d87634ce50a07b976994eeff63a14aea952b0edc830c331e2c74b9a616237f85f91c3d81159cd30409fdef6d6f0672eaed27cece656ff1af7db1b3b133e455bf262177f6a1141cbc2938ca542e9e5177c5447b7f7d58372b6629a61df26b61de8f2629711db9fbdc9faf1f8be6c766bddf45fb62be095135dfe9d8afe2fbbcf2c71d5c8571988c7b95a89bf7d14ed316bfa896e835cb9cb769bfae14abdf1ddf073d46cbe0230feea30b7a3055abeb95bb123d1e4f7cc7f3838e335dabc7bc673cde6cdfa3f0bdd10eed89d20060d477c3766aee5263744c05a0144e4ebad9e3099c1e695f4b21d68939609657096f23374f3ee3eb37e4ec29819b83ff6272846757f4cb131542891eee99cc4f556a7ecbf5e4481c2d5260884a1defb87db90d046d0d1f1ae900d6e1ed9052c05928dcd0476b5b96651f3e1851afc52177806e4b9a5c0b02079075fdadb550526ffe0d02672eb3abd233a67f2b74c775ed1b06b97e05b0164c23e105b4a448ba3750163dc8d1d39dc18945846de86091069faa5f5ce2a5f4b15916c4452f832daa08caaa39b41ed4ac40ef917ef6464040686f2d38fc4cc425a2a56afc1293063b0f4f4d6ff5bc3031914388be8de221f2334d304ae2655a63a236dcba078814875213ce943c3b71238efa00305d966d2a39d1dadbd685373cbb32df2fc0da9253b7579ca91b37dd857e7b086e3cffc168ffdc9e545178c81ec6c8b8820f1250c5d68b82ee7cee66ff6c03288fd05a92e2d9048e2b65d730d2a5dae63940233ca575a7adf5167f452798218b5cfe173082a81343ab188c032de6f2e801f426798ed3840deb042f3a79e15c3d2da6738f702b3973715bdd74253adba7f99cced45e53659bbf75d06e584b86ac68e8a7b71b6aa1172f243b285b27376e613d579c356939279fef0285e969944bc6f7ad99eff09d34ceb9c6b6c9e185b71417a69877e97438cd18e4c05561a21125682c0de15872d6fef6978b3e4a0fc33f9a5895a3a5993352d6c0f537e42256171075ca2753f19f5c6ead81c5adeb1e3b2d5c497978d122638e9a47c0031ac5bab7b554b45c6fed20f68cea6cf93d7ce53b71e0aa2c7aaa654bd9c642b08f7f0369de24c83834ec8fe71585a4874648c836c6d7e9b13543ae46da3046fcd0437d536281c5d3692a94c55296e15f44fbe85562a337310ffdcc628798da6a8593ed133b5893eb7fde4ab3c85be2f42c983a2d58b6fae3d827914d1330adcca0f5bed83834dfa89aad1cfc1388e150214fe443bc7ad9ca5fc30afaf45dad5a2399920bc3b979cd452e82aba6e2d653b5ed7abed49272302092b6826918d2b934c673f12f3a19d510abf64678df74bf38bcfade3b4db7dd68ec9774dc0ca952850dff7b41a326ea8855119301c1e9e07c97eb92e8670703e1fe8c2dc9adeca6763bb2c1f7289931f22a604c489dc6c58b993f399e8669ddfbbf271a977a69bbd63d48ae52ce604dc641a61ada451c9df30aef2b343fdc4d629505c4b7e624783ea93e3b9d8b7fb06ebf794518e6b144361b71a20273123e7bc121fd4419ca19f623d3cf74d7e518f4738768a7b0f0d1211cb3e66fba2b559bf05637e62d0cfb644d6da9d0f65db61c981242b952fa0f4f1b5af6cc34c8b11c8ff19c9dbab4c475489920282f99cc86796fba7bf2e19eef64632d40febf00b7fc91867fae425caf843703dfaeafea567afc940df5fbbef52782c9dedecec02fd569736b63057f47b344055a2eb2e5201325f04ad1a0e502326093f97d7cbb94cbedddf330c685501b84a42d10999b08f875eb9947b5cd3b5f12ad479433a3bddd62003c23db230e5ea0d01740f87c9089ec2b91fc7208e4895204cd337178056336ec0c2a53e179e8fdd799486df44b5709b71fdd3a30c169d22127a39308f16c4b3cd7f0649a3f327ffa206ca90195be4b0b87bdecab5958f5e5b57ad0792a32a2c5edcd023a165797e6f1b599712266c0b3a214bebcee3307856bebc26cff5865c1995bce9766669b5c7357af82ea34382a8f9b04a31a7bb8df5a9d2ee59975a1b1404810d3f370dc35ac31cd032e6f1bf159e72c397f94e811e01c68f5c112d2da573b9e359e81589ce499636ac344cc00742b62646e399b6aa34ec2aaffbd96b1f13e7e2f69d2780e77230e9f4ac4daefb37ef374450866f476de4712029f00bed7fc81a3f38e2c2fddb40a6b67f87fed9ba3a4ac7f224172e591d6fee9b425ef9e82b1231363a513d2e22c380dd8a2e8acad33074267c3970887c2b30cda36b1e2d4968e1c074d7c080df19acf8edb3bd287ecf2085fa8c3a3d28da6db5cdab9c058875d62c3e6d2d8e16070379b4d3391b7d352edbc27c2e44393cb541365a2777a65457dd8d562417c6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
