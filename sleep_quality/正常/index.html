<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83def916e708349f1a2cb2da8fdc0e8485587e72c1007dcaf8ae6c09a8d49cd1c61c4d72afd64a725ece14fb60ce9745f24ff71c4ca31afbf92656a44d4f9c5eda25c5996d1b476c456bdff808fb31936bb650d8a6534c2fdcb82e19c254d9194e2338f578a2eef236b6f3e7bb85f8723b19b0b6a5a6f85b62ce2c89dd1175c80756084ae2fc274e9acfe86a4ae318f2d87557eb61928c680f1b64011d2584a5780f556632a2a05a6bd084be2541616817e657c6543514ef53aaa0c98b9b984fe8711c3127ea36804bcd406ae908ac6ff0dfe49c38329b7dbb53e27d80fc69e4f7c2cda55a84407f90b6d830592b355eb3b4073ce21dae12c1eb7b5005061446586d9abbd3d121a97a0e6acfcf67297fc83de86b3fa40fa3aa38a1bd99d7535c6336f6db66cce2369dccb7faafd249817b1686ff60d355dcdf1563df18e5878403491945971f9c5a988b7463c9ec82e7ca8739f2f2167415bfbfb929fabeaedde85310c231553f7a249f8fbecf4fd720dfe6f3393d7730c02d2ad4e3b305f96aadd7ef3040e802f73a0ab3ec20f7899ea54b463c7a01ab8daf7c1349f1d13423746c59a6b88d14f2d60390473c90a82412c12f6c7584d321c6140d022d88f86ae103babda6dff212352d303d81c5d367ac405e8a30caf359fa37c9093c3603808537015175b42772c72400fc8bc462a51e375dfa3171e99ad5061dd405ccf08db9d9d59cd0e85fe28d7a3365a32056fbcf0009029cd07088e4bf83161493a49ca2cc7e3b35025c9b0f1da680255ae27884ec500e11385bc3f8947612a3bcac7d9917005fbb0910fbf01525d118cd8d4605192f7ebb77e993ac1e937a704b2f0a7fdae81b45c7f2f5b949ae26ca4e6920a582951f73e0c95024a7b0c8f930d04dc23c3a38dfd449063360ebf9393b38afd76f0e7e326216a9119ada3dfbdc9bdeb6f29c8bf8f7b477b084cc7ab5b5ad211b9c61a4d68add827e8c3d70316a40e910992138e3fc00cc76bf9c8873c77afb2dabfd1710e2dca9fbe2904c516e55faccd58410f228ed7abf419c6516d79e04758ca1ec19885a878949a08014ac7192f90cf84bb184540132110e56c953a42e7ad2b2592e82d6fba346fe37fe0ebabdfaa8f798307c6f634667bdf4d5e32bdd1c59d526ab0d5b8e18762eb989b245e4006a4fefb6de0f2cc88ff6d88bbf9e14f3fbd28329167d297f889c60e4fe3606e07dbac2552fa9efad7e3dcd0b830c02309f923a3761e12d2bb8313662e007adfcd8396c61754600606147e4f10a0fca7d44fda1cba2665704dc7c570ff1ff2b48150f948a76bca08e87c0faac4a4a016e78c128b1663ee9d1bff8eab43c41b5071cdc73dc47d5af21659c92f99882137fdb03bdffd94b8da6ee8b1386e5b64c92126f06bbf80c3a2e7684ea5ced1d2b93d2db113f07f282f36c9e0df67400a34d4ba35c8a669f958026a4445b850dca80dcdb2833ce1262f15ce63c3bb4785e8fe748ce306d99aca91595dae641c3bd9e71c48daa215b622d6e60529445afbd63fdf9a057246797b77a0e8405bd2a595095697a341be0e038e234a7af041d43e82ea1440684ae941675512c67590d23f3deef7290e3d1722f4f2238e1cf59d7023d17d7ed3edd60d411e680912a830b964d34f18e17333650cedcbdbd1c60258731250d9a2dba14e689c2d8937952e5734e7390c4f3279c2f3fbb71c77c869f2b03e7af3db9f2aed07e1fb511201460e762868e102a60b8838f499401d2ca391759f4d7d953ec2763d84ba05d2a2c3f8319d3f075559b428a316a7c4a2384df55206a1c6e6126a330a4405e31e4f8b10b5d19d0a6dc349ebe325181ffcb4b2985b9b786d7032b891724169f3e4d61898b0c32f99029110c931138044d772512e71bfcc6045f4fa86c111c491fc6a2b4af637804856e3076a361b7aee621b5abe5adda1b7c2a94d9fd3dbe69191456547a7278f3ddba73c259f532e79e7261a9b372cbc1445a718c1d969a3b1ae46f293cf5d351fa273a35b7e6d3732e06c0e1cecc8c20b623ecae0381767d02bd0818539ea595c36b28c624e70c798c3ec77047b522f8b5ad4d1203df2194e6f28575878adf886a614351c9b6675ff3d1ebbba4f3187f945d6422eed17560b673550e1c6d83ec3c39a76c41bc3b202a7ea68be953078a94bbd76feda651010198efbee60a16bac35f996c388f4922cbf71c2aacb7198af1f91597cf9528fa5b8bcb6619ae2c03847dd6ef90b5cbf20fa7b0f45e6ce64aaa2ae3cf30afd3477f7918818895956e617de9fccaa4fd7e7697ca41462200d4c4994bba6529312309b5b5896b1bccfb9c810b5a6680c08cb0df7f8dd0351d16294ca98851d670f98ec25b307f87be6af27d01aef4271d0456dd4fca382ba85f10a68df9ffad0e3270118ca60e41c3fced02588f4f00323024be620d7197ecb032dd966a9d74f6e897957378eefc2add4992956bc956404d40791ab8d8c8220beed3eac19ef018764f8666dc9e36baddb23177a3e290e223f4d6ba98f85182af169909d01271066a703859146876a3b27c432bb1c1fa8578b0478340528b12fbdccb0dfa9ccccee3305997fb3800eefdb2860ca7b761765eea46fe7419bfb1344ed25287665d775873f1c75e4c3a4be43cda4a8a9ee5ea99a302f3999b1d1ff01b62cbaaf91f679025ba78cac04d434cb3c9d34c1ca6a8bfc498d009afb4c180ddc52442f816581892510ce2c22fdd51550f43e66bbb78386a8b31cdc72a4b590c5b93b29f2596f013f52f1807b01e57362202f7cb4400bca8f3b0d7ccb378ad3577d0d3d2402491cd1b998ea25bb0623d70d4b936e5768c474190cbaed05e0f72ad4fac952cf198963f84ec3b0ca3ed5757b3181bc8321224ac5d52a97ff6760a7f07b7b5816efcd669325122b3bd6e949daab9686e473cb4971708891a5604f164e8867e7e4c957bfd9976f1c9fa9f8df71347b47e5b71cb8206e47c80e3a1a642d34e8b76a07708b48de932f80bd242540b0be45b66923c79cbb0a1259eb3b6bbba080f134d8714a58a5316f14e1f148f8217203b0ebe40c9082d4daf61ecbdb14a5bbd436bb1ba2984c2dcfb38a7b16144341578727f7cc871417f4e530292be06dfdd6d4a0e115572da3cf4c70f107486f9028d1b88cb3b30e72acb96426e2ed145b852e88a7013dbd274d37936e9e53652875f6977266e7e2e9764f72473342a0610977aab6c868d50c8e2aec6d7e68163d3a567f64d50b8230e2dbb2c10e3818969da41e03a71639f916d69b599e6e7df0a213492bd82ca7856dc8c4f08c9d3214741267c69f5ecfdb348018bb64c81586c5564c06f2eaa12affd19edf4dda0992cb43d86a6697fe330d1709035a0cd833504536a9fc52b5ecb50b0421ff024d783587eaa01189caf8edbf4d6a2a1214b2689592c6010582dc5d797787314c7828ce40309af3ef81fe96b7378eb4d98ed9bd244fb0afb67222352554be36d4502337bb3dfd1c7e3d46a43babbbba4d21ec23bcdb97961ddfbfcbe95520bebf722afdb75dd113858ff2e4c523bbb017fc308698a0c14658592d391fab9967e1271324d50ed1f3a621d2d5d0ec45721ce5716a7297dc6973ff922b4b831ad34ae43590046d5dbb127c651de9cfccd033d738eab71a3a89994ab51085491d0d739a29438ca3d90a0bf60eca6d95f1376e43753c64f46fcbda6463ff0882cae1b82a45f3896c8ed7930a1aab899eb78858965838f0fc7647b0f83ef591a5432240a99e45a6768b07ed6221346c5fca107e71f85cc36bde3a01e4fe9cee931b78074517fbaccd61d077dbe1de40d7d9e6e02e7b7716c1938df2d2138067962410ecf0da2685c763e8baf16510ea8c23bbb5bd5b971f9a89fe8d72b611c817b2a727363be9ec926a5aa1f137781e4efb583338d65363a223a4ea4e9f93fad59c62c144276785d627f1c29bae3bbdfdad944563a9f4eea4a119d8a953f92b4372b2a9bbc1a46360729da61622257a35ce733b52a40d8e36ccdfec34b52c0d6a5ee0ef619e2c213ba9862ea245088ac0bbfaf44e528739d95586368f77740dcf1105c43f15ca783118db190d0773a0ddf766ad5561665159f8c0b4cd3ad1c8c92fb38fa2a7f20466a251a1d3021dbe5772c9779ca73bbacf9b05b0977aca0d752db95bc158c84d6a584a6961d272780e9cdff0b7b2ea85a07e5b9cdedd8fbbc2d7ede3793f3728389492ca0bb456b96fb4277db61818b0222f54e9f47f9ed58b8e204dce5fe739ef4bd05c3b3ee136e79b826ce81affcf0a27875f4b37972daa2193a403a1d02b10c065d8e694706cc3ab91732cb549bdecbe6734d1175685638788354b76181d1e32fc5da86aca649afb4921b7bb10bf92956322dff473aea60e0e33dea9a7c52b648f9dcd2d788cc57b7bc6048752664eef3abdbaa0f599eed24fd25bb69bec86f6f0281499ed3f39b5fd196335eecdc4dcc730c87022b731e59e59506d58b4c163146b3da811061433919a0c09865b9667b3488ffc9e78033227fdaba39f30b4fdc9fce42e13520d4839212dbe1827982f2ceb0260e23786807f0b32233d204110911961359df40998abf86ac783f141d520c95a3b0602ead89bfcebe5c6ba34c6a963534e9d94940a42dc489d65223f704d37a2c26dc3bfcd2de9cf4921a6d9ccfcd0052a342cf4beb1a013414bbca7c4744a2a1809ea8ab4a40bab126dba1db9303770aca27776e6bef594aa8bf9454b70afb2c417e0080cfcb4bf48235d3e5646237d66f76aba4d46053eac7d129e6cb289278c5739c36a7e34d428fa31c6c41acf8210e00124d28957b4cb5703e4bebaecc22d9d1bf285b35e45950fd25bf0f3ee679cf2c5c85843f847f1b3a69a4d693e0c78694283dc4e14e7a7b2a8b4361cf54ddf5a920803850e8920ab1bba3900f999294d73aae03e9bc5e19542481613e83c6d1a840740421188fc1fe60f0cf30765ede28c840ba98adb281170d9c6db86165dc5cedd98873c885e406dea369d0397e2ca9b43da756c6f8f3bc1444821949aa4f6a82dcb155d38901451a3034e3903bf4c4fa95dd98f45182edfb395797dce57fce7b5565da39c91258afdab0d9544ed97a629060a39fc38df882d49a92a6930bf7ddbece404ce229785ac18fab13c584ce6fb0be65ccfccc5a0b9dbf4b33d1b97a371f56a7baf91fbe851d4f7471338015f79981f0046f9007c51b68ea0d35ea4ae197e0d8ed6cafaf8b4709bcaad16b3f64e6b29309cffc4339fe654f0ec01728898c7f32481cac0e63d5d6c116f3738d4a6e065cb80629baaaac9a7cac81664c3d913ef32f00ba257c03fadde9a57f8d2d4e7313773d7d4c2eaa696043b5e1d04d2d22155c3c15ab48bac8c10b61d1e4a6170034cc39190ddd617fe5f1b4bd8325e9f257ab443aeb871ec7f4b2fbced7010987c6ec90365efefebcefa31ff1ee5599eb08a0cf51931a6d7985e3c9333fb6d6893479e8f436eded1f3b19c866e0601f6454efcf650e216d67272f91637c8b0985d70a5835fa119f9f95253092e7b200ed055ccfe3e73e0de758262add3bd099bcfe179c07565bd4ca87f22b3fbf83a878878c8db1494aed9d8bbc6eaedddfdfacbc7198460740ce7c3ac074bcb76d47b8efb2b8874807799a53f4c3d398b3031df580e5d2fab83f7c8f8877a7eb0e44224e13728cc061df757d6b04139af4a62e69ecc2cf441ce1a3d76177371da5bf5a8f082261badb18265a0697f0b355e129bc324990f1a88dba85de19855474ee90af1c8729bea9b217ed38281ec5ef89f2acd900323f573fb15f5532398639d418be70d8f49748f7bda5535fea7b640337b1eb3cb6663bf65a914881ff77b20d33918cc7b2f873e81f56c1997e01bde5805eeff3ed4ed8b6ae0d2c60d45418bdd08123b2d50a36639ba6ed3c45ed95cc8659df0c6f53f60ed11c2ac3907a91e8b8bafc3afdda9744d20f5901b7a8ef1fa0787331e429f98e5a8e7eb438b02f8d953cc30bae8613ab7f317815ec4f4854320c7528d4a4c89a033f6fa9810b199e150fe105cdedcc3bff4454f51196fb5be0702ace6b202a71523682ef95500a96009dae40fab36e83119cb2516281cb413a006b4b7c969c6f0996bcceb7f19accfd172a424adda305c7b8ebce70f9cfe5d2c7979abf7b5bf3752001a2421aa2eabed7116c2530974ededc05c4fffbaef4ef7c16499b697dce2a1177e095e63071c6444a4129f0a6f9efecea6b7ef26ac113954088f747afc5cb952c460d92bb7bb9bbfae4846f37f07a1c09cb26bb4ebc364b58cac91ce8f35922bbec93aa0f49cdcec50b0506f9ed6aa8b18be2d6f42a019fd9af6d9300dd7425740c51e1007d3f0dc1d80ffdf3d25254b07f4ef677fd312a1c88fd96ebd662ee1b55a0478e5e2f36c197cc331ba6dffe10b809c3d4a3397109a110e3b82f17a04fcb65bb6ae74c8a3f8de29560e4031c0f58a261b57202fc0a0c2350e3832ef0046fbd683693fc044831d5912a3b4dcd5efabc52a1634b555c9acc0a101bf6f42c91717a27965556ad1df6a24b9c04b08ff2e119e7bf1c891ba5090e8fecda63132a62e56d940371b50f7b8ce9e0d591b5330ad3dcced561c166ee769635d269b449255f454101777bbfb9d347581fd590346f5e021635d7f5a3649ec397919fb985b1cf12f106a17e19f1ebd78ac4381056af205278d725fd4af659aa9dc9f933f7b33e497e163352a9325b3f6bc608ac0d236377cf42bd163d17729f2f5f57fc393edf67f97e37cdae5ea7efa522adde53209489d2e2763f948e46e37b573db7027589017004d9c95eb53eddf5ab30c2cc4f43953a58a744f873aa3fe5be8d63bcc8002afa94fa4ff1d16d2f91808a2e4ea5c9320e68efa739d774ba3995a12a3c63610ed839b14afb21ee6f81b2cd4232f5a5b5b2cb16cd0bc493b29d5f60d939c9be4cad75b30bba4ba7c41529f98ec3c987f255d793c9b7e265cc3cf0b81e1156783c195403f81569e673af828885c0d16b64631fc584bf171cf8cf5acf8ecaba497d4074b9b97cc8bdd99f144f12454e9cc13ca8337817ccddc8e7d6d59c03fba540e7f858942a385b725c543fcb4bec61739442a7ff6cea93233ecfe00407b217f0138b904027653a8294e4e8db06ca03be14aabf94f89c97871c317dc3d6f9ccd474ef048b6fa6d678c98479c68aa3b72bdb3284e3588e002c6ded092e27bbc6a52f7730da5c3e4acd142a3e0645f253ed915b250ababb1fccda9da03aec5a46dd1034b895b663b209ca9fb759902d5c6453b93030e6cbb4ea076e9358ffa00ba692803a09df52eb73dd59cd92382062c384664ea2bd84ca7347c3eebd414c7f750a2096961c9251011ce130b9660a6e074019201d41477e9693555929c292f75fbe962023e385dc7b0df01b3187ab14027848d656458ae3b2dfbd4fa91322d5a0085dee931ad97e6a5f957ce3d4a4e3205d7588b8003f267151c0401cfdd28ebcaa9679ab1397c2cf9ecc334b00753cc293a32c11c41bd3c02f0f913dc3b5fa9dea6886cc5308f89b9b9b508d762a8b1b08c3ffddfd222856ca0be73fef2af1744c978549938119e2ca6fe46d2fd97c729742fd5f903a2a3ce0dd8a12a30324f23a15e3f6e1c593eb51e86146bb5435123094f8493dac4f4cb641e3018ad553e4391cbd259bb593370734eb62346ee435e68e1190dfc31a67ffef25a1c4b7766d71a80ff2cf4bc07c236ee2816fe1f9d8987d4078a8db88bda4a1bb27f63bdf6a2d598269a85445d05a074264887fda18aa079ca78c00613d8d7542520fae3b8d5fbc2a5c0f6a473b9134186367af192abf09a692bfde7b32a24f6c27de3ee6c4428e283e1ee233ec20109c8681b1076fd27a207adef6e2efb13d46170df0443326c67d41925b8d68fc6c339ff36c460979f2666aa8a35b956451eaafe0ec01190bc9faeefc954eaa8b6b74ac3b7b39b068005d08fff195ddcdbe5542807db7c1a3a5bd30c172585090cefd2ca427731febc4e51cc8f76803011bc18d17d5c1ddd4c871dbd75f8bc8d78338d7dc95e332874e44fdbbdaf03a920a79e4523aaf1716470db5bcfbd5608436900d448109375716d9068bdc488070666f32f8b91232394acd52f183f121a88603a465f9f82a14cb78c52a77e0a08dde9c5e20a6aa820be32c664f4f2147ea3169eb96f344da770c1c1fb087e1526d26409bd94fd5bf29e4cea33234bdcc65449ed563c38ddb4dff29e4f81e133abe7f33a3cc5e9827c89b581f3a29de260b59e7579600eee0b03e38e54fb7c954fc2b25fff55b0fc4d6326c709a6a5972154156be358963332e5f84c89e63e651d0d654898037189f825f5375c4752067b27d12ee5d2889a938c58f77204244361e236b77c0d4b3b5a52e87f66f72d8553aba7748aede7a84fb47a51627060702e2f55eb588f261425f2de2c7795f38e42a5872f78c853c642a6d278996cf70e48a860067c066fd608ebe052e1e7044bda298b3cc6ea3004c84789be8e27dab4e130d47a5ca5ab6f35480cafc0b5585684e9567be386e0f3cac0b222305c5dd040a67b35be47ccbe62894eaa19476ada9df9e25f21d45b9304e3bc2c77ed26e2e3b23d27735e9d37e653bb4ff5f5b8a1b89354b004c1154b2a087f5b00ce01f02b34c31c10b7410fe12a41de8b98db44c77bea951f95a5a3de7f9a25ef703d35a0f5d6b4e01da1a28fa8cf3a8e4d4cbe9cc2d948c2fe011db96b671c6aac1da210e3c4d5a732a1fe2ba005445aa9098c752c45712000e2a58e3a39877503ebc59a0740dab30e574ac061d6ef9745a79952b3fcf9962751186bae479601f0044e40cc17100a49d27c83f6a823de80dc754ffa29f762653f77895a5d99aef492e079924b782eed5c5cfd9d3c8b586fcf53e3f002fe4f67df00cb3bb0d50e6d5e9963858c34e2f4d0bf4675631da4f9f1e858212bb298d1cd4c9fcb65b1fcc4eafe14d0452e27370dd64455d5b70635f6df6a42fc9640c203104e24ce9805d336099fe8bca12c8df5f82c6f8beae8c3479e1b9a31227c8aa7b9600af51a5f52ba1b1914621e4b5bb0009ea7e7a794f8d3f261a59f8d812b3a9dfdd679a203a0a389f9a41eb8af03f8879e5b912bb49b30e1b7f7c9a1203eaf428a7a81d5af0531b642e53e6d5b238f5f18874994c4e47671ae734009b625ef89db3562a0973c316ae9c360ea976e5c628a3496df7c2dc9a77749857ae631bee2a01a5d753908d806915062160ccd6ae40ac8269a148dbbd289ded6a49c4be05e9c15d71e7bc10e48ba6bea57be19ce15ca4c6032b72ec66b42601223d24835c15824966526621b66768d58987b7c3647af9c5c83dab2e856221a32726702825475dd0e547843857f72d4bf9362aad3dae122b1f8bb597b0c6a5c6de86d4f8b82753d4c9327d53efdcd62abb384a0442f223468c2af2ac729877911fb18bba0cd92d5f410a2a967872009325441fe4ffcce53e415c0b3201d072495e2d612b15d939048ddce9799eb1a5db73a72a8b4e2314a97749563c8abb6c93a2dd71d8467c228bd6a85251dff5a015f60c47fa447bd5d343178cff6ace234c05d8b7d1b0bc32240f905c33d63a6548c4fd4753d49977f6fc0cab5056fe04c173b75dfa1c0d38f307a7db2d41bb85dbd6ed23dd5dcb846f3d02dc96cc262960bcfc7d23953da98fc2ba963676069897d30005839a6e5339b767afbbc57538ca2d29ad21ca8e9d2072c49f6f9e59b5b9115566560beeb2531f6b1f9ca9c38eb60688c9e8876ff03fb69f4adf97048b564d41d0375e82e0a5438b147a52de4f77df4d1f2740072b7e12fca6f4fc1554bfd39606030735a138e3aa39b6ce0e0f1cbc028727291e2d58283447bb2cad45e873a6cb4223efb2731e9894843d2761f5b0e0354590f87e0673fb23033b6fe87b9611af40fd909fd5d94d7f71ad98f8e7aecbc4a6e6c53ffdb40505d43068ee46c2219b52e10517ae38851134c135fcd6fabe1643c2aea0d9f519a4e9a4e0ee565837385bbcad48ba2dda451664e5c5f284672301628b82c1ecda32a23ba841d64e0062f5e5b66292b52e08bf35377d7ea32373251e0b091a97ead30f9ffa2da57bc5114b778d9232f4c857ef0b2bc39a2c5fec1c12061407582b2821a774a1092c77bd9df82eafb9394efc9122d35bd40e236115f95c2b128c7f4e3c5cf9629ef6b413fe7efd7c0083c7babd9754b669347a60411420f822dc9d8e086552c2b82bfb5dd1059e3fbe15375d607fac6b95604d97dca5f27949d7a4d4fbe70b620226fa0bc18bf89cf25de1156a985f8ac3f975462f630bdd6cf1ad70f7d69c32084f465376dbda08112aad122ef49c8d1094155b17be5aad8567f77cadd075108124b88ed255e41d882a8f603afa2729382be52a34cb23df5d329442a877ef94695ac2025351167485b40cb72bcecc98b27ebebf5989763cdd25fac0d59da7a3c70fc81afabe244ba6473bc6a895dc47e6f7d032abdfd1d603072ff06504cd63c7471227a72a1dbacc31cebd2d257cd14b4041fb7999046eb3f9d46a1c6528d47c8ac03807487f7b08f6fbf90d381fe70cb80e9ed7f3aab266eae2a298ce59e5aad91c2fa565c308208386c496a7fa3801abe91898895a23a80998ec5a31aef421982854cbda70c40b317dd71ed3b447c6a5b67b81d02b0e1ab2d7efaab74585d3b8745b70c1681c1f64b1b8dc6bb964fadabc16381c13a00527f5d4564c15ec39e738ad9ed783d2ce50bc2ab586f74e1934e7d6586afe4e28bfe10628df1af4da775276feaeeefaf75f3e890645cecbafeec323","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
