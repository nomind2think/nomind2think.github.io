<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"839efce76003a0141f847abc25f76921f65b0e97445e6b649716a0725475dc5c245831da7095f77c92eaebf84be84c25350493c9d303bb13db8e8c8cbd788ee486f9a442f93a9861ce7c03bc37cc48ac30ae1ffa6cd2c8e789057d191eda1c8fa546bc3f592b91c558ad2a009857584e2ef8b68d92b164d98db6e999d9fc2462ead6ec042dbd0e5dad9522ae12f2d5e583b23cba80857154e8d1e1fbbee3332715a0edb8a303406d96f2baabaa3327dcb99910c7614ea95f5f9488d7fdbc55930b899666719138026228635d85ef0e3042aac45314d3852acc85c486bd0654f5a58a59a9beece9cb218fe71481317c06bc60d62ff3a3f3d764c30c210260389a7f99e623ebf36b3983348add2bc82183e7302e879e142cce93811f0a7a80b7908c05ea874e625632231531de40671dfc2dc3f69d29036a1025aeabbd487be60cb8d518028091b7b178eba3ddab6a14055f62638e504747e018068750bc9a03c08c4a5177a2462eef5a7a5df1a7654c82a08e5a5bdbee1ff166f4762fddd2a031ae0cfd6b3d88b4e4aadf20ac26097b733c69cc2bd7fe69e0797c05425ee09386c4e7e0a324fbee60309a430de159ad33ed50ce1024f651417e23c89e4c3f7678fd3915b8c2450f1d28805225d54b83fb28682eec67558e09fd10547299c75e456c1dabe9dd6c471ecf52b51028c895e247e8ddf4bae72ad681894bde297ca967b29379cb9707caf625684463263ec018788f6569d26f7ff5e51dbd11e782df3cbe7632576ae5f4c0acb574eb79045694da334073386dd1b59122cbd28ed8517395dea8bf89a76264d24b182fc37313f46e20f5163e16dd2a224c7ee45cc7d3db828645ddbbc2669bd6963a8fdf71580a43b087b6408580e9e2e8bef877aabf89b8b57b7ff63a485183564e0710d829f25a332bfb853306b45b0085b2a13a5ab06244cd5adc5a5037e79f0a525e6481e48a0beb65b884b1e504dcbb22ea8a2c35e2454080ea4f93bc3f57005783fa772d43f996a3e7010ddc2402fc8afb626934527bee593bf564727d4b752a0694ca4d9ca8e560930bbd465d19acef9aeb8c47e6e7495a74deae9d00785c2de1cfeb88055ffba36ff7d401f3969e525f5e767da33a9658074627b9f50b6f283166e3c092ed13416b1e67f9c829916fa022ab13a5e714a1e4566a39512a1fbecb13bb721ee0cd23a36aa9074a382f8160e167160789345ec5e4d147283e8a4a8d12f98b3b5e307610165ab3e15384fded1b77aa608b98c10bfcbdded351cad45d3d62fc2e4c9e6b355a5ee8e2f7096f04803c2bc34ac3faa028264da4388b07e79e8471df27ebbba19c981b61cc06c622bf27c45010cd2916d627189b0f56de8fbfbbf971da91d3d9b42380e5be48f24eecd9806a67091de8adb103d25393369416178771059a187e1e812e4766100252d007068edaf96c47ba902413b4170b38d1fb2b0a72b50fd7f622209c8e098415b37cca1484d1cd83115a9792925f454a4431de8bb5ae2432c9b875fe43da5461384df5e4fe0725dadadf5a01d1c675a0a8dad27d7b41d918b1ee63750ced15a54360e36882705a9e73dc5fb63b75b86eccfde15f20775c6106bfa12495db459876f57c47b4a1b16020c5e6ba0bc0c412a5157768c36bab5b9e7b40404be775fb4ee799a100d1ae4720c79a9395fa40837e15635702b0036596f9d825f500f84b22c3620f27f572da810641d67e6428d22f91230ca92fa3a1bd36484b3a40078f820fa0ebc2a989202a218f89051055896ddc5195da5f69b1ca8e87c523eda36f189e68b26b8113b796f7e2e50cfc91699219d887ab91e9b5e5eb349b6b967ce881d0fa4406863eb27bc84ae6c0a75aab591dd5b17d34b1d821aa14a6ec92e0648eab058e7e384367eecbe9f5ef8bfc31239cbff910932ac599b3b644309782d730210fe4d11d17416b5dd28f256b9192080bfa960345dc239913efdbbab5555af1d79816c0298bfd1bae6eb309053df67c3567240848e113e44c44cac8e5a7319b81c0c95341ffce01854201ea2df26a04a97f4d4cadd26681e9de2dc672974df667aa20e58a54ca711052f5f5f7a61b38814c655d87f584e869844b2cc7f1771c306ce43e2707512d141f661e5c0e157e372e508ea5bb2764e92aeab6b6d0c29148734c0f8b8c07d3cbd5dffc7f6cf16f5335e2665290b48a76455117674de46ba82d192780d96954d82cea7fdbaefacefac5639ab12a735e3f72b852d7499c808440c33e4f0d1806d4ff809cfc937ba55f622c4dad6c478e9be093923159e5d7564ed298bf8c91d43518f79ef38102383fda2588c46fcab70f6d4620fec8e01a74079d93d6c6f40cd89784b8a482e9f74ecf29b8aa0f1999abd8563e9149e8b138dee3c25333cb79469a8c751fd74c0ca34228255c94cc42ee373766fba370a7235608b3070e8d29718e5f8863eeb9de712ae39df9012b52000d90f58eb41b7010815bfb88fbd274fcfeba967fdce12a7889fd9ba05d5019f29c58b66a768c0202fb98cc9ea00ff5cba1985c1907db0d43cbbb6f9b23a3c2882513073c50428e7a1715d0949dc0e23abf958eae3c3b228399bac3e4d724ae3301341c701f83684eb4053154372668ada56268815c541388f817e2767d4e16cfb33314b57369dd03acf4920e7cd689005ddfec9aff674d820209d3d2c12fc107e84910ddfb44588734e696d91e61669fc5dafa268ed7073b5cf1cbb34597a6df88f14d60655dbf87f85ce0b27f8b2c5a87ff54cde91204c6ddc98260284e47a277faf3295d587ac55407224cad8547e68068eb56b4ad9b4ea1a8b84a37a66eee3e303b9d27be16c1f41b1e04aaf7f5c7bea00fc360e8832d64f78dad3e7a7232c16edde06067e60a88e66763c7816c5a3e5011bdf6469623f8eea4abd5d8ee83550b6f34fbc4c28f333d15edd2f19c94eded2af8f4067c6e2abda7b3135c7a19928d4f8e5a6819426f9ef59044d7ff3b80b772b0f8f4185febd077d1084a92d1bac20ecaaff258ba3444d3ba9e60c7864a2280f07e4b8315e2677890d31722444998e0e7d2aabf917758104d9bf70afafa1316a04f077cb1d1f2480ccc3518dd268057c212dfa6bf5a035852d437c6613f95a6253aa50701594eef660d08eba8763dc32282ecfc9c7d38f3ebbc20e88d2bc8ed2f7d0abe8df87320a3fdd376946ca739d2ac55168321024c993cf5d227aa5cf8a000ab67d581c39315e48e16f927d4e6906cf07c1eb36cf995957f33c7ca181674259d9f5ac72be87c6a7f27295068cde66990e041c66609f4929e9575fe4869677e37899a71f400aa856ab16a73e916f8715bb985a07397643f8069f0de246554c7ce68847bc62ec14d659c141b610f01e4801d1acb69cbb7d519a6627a82b38eafbc5e47d907f2a8157792051b34020ef740b9e2a744147289f04dd09d2855acde87fc6a0caf25c3cd13a34344f57e07fa846382e2ce491860d3286a22c8a283ad87f36196b51ec4cf96a029b59cd13b2cad39fc08ec1685abba2ab5139c019b3455b01cef7e3f18ce43595da6c81cb9d2bc0ce2e1ff29537c98bafda2682966d6db4530dc99964ac3fc100599ba99012261f7875c8a1ee864c96033fff76208cfc1e6b078fa363712ea8cf5fb7950eb9b29d16bc4f1bde68332e22e4d312f3bab1f48f5720a54496044cea054f6a423c68591794ffa27c6de5f3b068359de936887bdcc493160a59274ec66b3f05dfad0f9fa9a538a1cdbc95cb96407fea73b16c3576b7048208bd3134428d932e3dcb4a20c8da7c40943f936c6deae03d9eab128678a726bf5e6034b69415c8959497039035a8d0f624f718847f8a5e57072bf4e243f185d5e96f2cf537bf78097aa7bbd02552a9e3c064592c4c50c773798c70db2cc9788be161d761b0cd150fabbd510a615c5fec0f306a4adc0e4880c6818f711028c0cd577ea5d89634d2909e5bb5cb8041a2881d4a77d17cf9ed7e230e554a8e08f98cf0c07c82c072482a50edf71b8b8e86d563132cca0b6703bd8a96e07d80ca037169a7e1b410e86299cdeac4c42b2770cf2ed17d4c716fb0efb439ee8c7c852e8b9c65386dd593b928fbbff2dc5926d5ec6e9490075fdbb22befc725549dd97d5e30b62bee235590f111cbe8e0a9d95c13627b6d78ff023a9de51cdd04543ee4a6f0bb2daeb2f0eb5716a861c2a7ba7669c22cc4ee5154417a9d8757d8989eb210ecf5b68463c8b1d7eb27d59760fb2c2125b9f7e77ef3e97669bc720688f7ad20401ef45682bba510cceefea50ead4ecf337e13332892318537fee17753e75cefefbd055acf5288cd04457ffc8f153a525b67f82806f853707521df3aa0a05d99a456438f1b503370a89e7583dfd7da9bad3df6b42315ab54989f2496d8877f33ef695c55dba2e65c7a5d05399f26ff16892e6eb904670b3224abd3800ee5000f1d8d26e192da29aa3beca725cd6df408bb3ae00f1d7914ecaa26cdea6945fb33c5abc7d6ba9a622cb774067d06a69bd54bb20611ecff74ec91992045268d7f74f02959ab578540ec742ef5d7c28aeb97038719c8bed1fec08ded433ac2e17b8113dc34abe4e2ab9206d6d894d963405b42917d280b752680b7eea97de69415ab397cc9505a3209c9dcc601780fd0d070c8b79cbeee4f08024eecf1967ecc5708a45192119adb97b8503477004ba88963af55b2bb2da78e8aaf2dbbab95ad0aacb39915452ab1df91823e81ba1e9008009036f5bae41f7f06ebb1017e516314fd71ee030890a8177f3df3766aac7c574fe93ca312cc87dfde107ae84dc12786bcd2bad3326cbd892634ad4f205467aec7245270d78dd509ccf3cdcb332b7eb577363315016589518751fce907cb99b9a8055417c307095ca0a05008188fd7204c723b0f3a1cce497b459669416ae7c59ba1ef0393c41ab7fada4ad496d85a2f19323602bbd17d2506f0c78b459a1c4e0c1bd6e08f0d6e545581ad0b9ae00d742257467f2d9a61967424f0c1fc269afdd8f5e183a23857ae398907d11b01a886a10ecedd4c35aefb222d4a105ac0d82309c7fdf3b3234d147ddd5f037bff59738eacaca2ca93a3277327881fd235ab51f94553a731bfe4e246eb113b33624f0a6a3c04ced1d6db4d5519d1723962847e07ca9aa40f0ccc8417309dc95fc813ceec2f65ad893547a56459ff2313ec5027ebc4a9c09abdcc7c5d4e74403b56915cc27f2f94b4b911bb86cf0c56164d6bdb5d46e4a4f0a58ed4d46f45434c2adb133074a71ece915a1929ef43b0f9adbefcfa2e7e73d53dd24e55c518933dcaece85bc219d1ce7805018802fbe485a3eb0cf858c21b67e421b4b07c2d2345235f00fcb371943c1db3cc38d7195561a88bcace80167f8f2d6ef2b2668971f0d1eb039f5543ffc6ac438b4abb63c0b79f29cf06a770c3585e0209ee941632c8afb58741e4cf7f74fe1adf412a42a5aa0fe780357a68939b0a47b48bbc1d0c860cd54bed4eefeeca08270d096423dde51c1bf8fbe4559387aa445f7ac77e2b571f49f1ac8623cd2091b666e4337694919e4940949ed5832340130ba74f4fed454b8b77c2b69bec11d8e7b66a045aae2ebe4ea3ddce83350c50bfba494118e9f0c649d2b2384e8f8370c7326059cb1d511ae6a1e798a51204ddb0aef122ab40b087251221a8c6acab224e143a50bedb2b7356fce11ca5a7d7a27d0630c6fb1b6f251d6c7478349ce4703548de2a08f20f2079ae29a1678cab18e30ea5713bf4f2508e02af9264ca968534d2f48b3ee5a618f6780bdafa530cdc2ff0efaf393be5b93e5993865bc48ca0dadaaa337baf2775177b35aeea51ab2788bcee81fa18cb15d7cfa3db10b92e069e71257eaafd94b2b8b3219e01a91fb7b8a5d29a0a34fc1bee0b2ba081429572fb2705f026e4b4b827ed2d0c0e9ccdb7706654dd9a0d55738df16b9ed5d930e38079c56078e973072875d00b61c6b18b7711ba7f0d9fe1e0a8defc2901873afbf1ebd1060e2b9d55486ccf3ff8d90c0b85138248cc88d75d51a89533d17b367822c4f41ddfd470bf3aac97af8e830681684513c8711d66543b74e66c83c0b466d52a7de18c9f4af0b64cab904e4d5202e89137fe01b0219001ab775a26ed208e1f41893baa7c126d2188a69f152a92667a2efd438907634e38e1c46c47c6bf1e357462c2ae0b4b400c5b1e31cb8ddcf194908af8d6c34d8a0164890e87524830a26f6d63f1034cc46fc4b5d12a1cacf6ee74ad9c3c6a3447bb2f221b59603e914c5d31cb12014a99851fe8ff97472d944e99fca61f26301402822d036312a97b5c7af73bcf6991f385f5d711362385cb2120d9cf6dd576c669bbdd2d1f55199689e47692a5da42f58945657f2ea1030f0345a7bd5d3a767d9e7c30d8697314d42a28c6971a28834368118023858a7359deef02210efa3f70b037aa5f54f60c9e912dbdf2e3d1679327571046a19a59a19ee88eeb60ac3a6f76454efb4feda75e5e8134b65f1334c0f2ba1764207ca5ba7296447d96a709deea4b1d128a1cbbd9d62a6352254d64d24e66d318c95407f8bad80c4a00dc5340784eb9ee06eb1c572740f6871457bcdf768f09d3346f3a2ae42496fca331b55c65b050c5e9456df46f338ae6a154a298492440d5f4aa9d44c80b2371289749b1c698cf6f80f82c512b4c474f7b106004d70eafd55d863056cbb6e22f9ed0242f70752782ed52f0afc16863814e5c10e82e8ab1bff6c628b3060e94a9a6f323d5a8bbb912714b23f86c7ab37e1f0536f5e0874c94e927266cce1b29ee4ef2e46b36beaa7cc51e3385ba6009477c91480ef6b54856874e9bf9f7111961e3edc4ed2abcb5ebc824047038966cb3fa1a4da460bb5756f03af70f459f1eddf4bab33c15c8afffeff86997c347594f1823dc2a7ba158c94369cf7ab253bc05f8de3db033c184e3272bb78ce74fdfca2272c9c027070d0de7ae65c1f1c64f43eff7e3be7eac606abe817a7ff342e76a55ad731043160d7fdea763ecf4973b5d55451de5a0e9c34d05f52dea3d41fbccf1342eebb3772d34656e839def523a1339d7bdf76f5274ec1eb9eec07231986ae6e3f202cc3411c893088bb0aa2a701a66dd9026d54632770eed205515bce499521c7cad902d7f843e7690a26f5191fb48508fce1b377f23f5335a29821c561156db2bbab893f873746b29b1060f829aeef3dcacfd565e2707606d1d80e4d99bfb7cb217f85579575fb89cca7445a30441a7eadf3f01a0486a34a74784528771c8fbb5484b669e51727411bfc407fe3aeccccbf161dbc11323c43c381fa0d93c496285c63681585f1cbe1bf811d5b8a5f5a4f756acc681413f1f5a67b8ebbb6c1e2137afceba4a99476937519917f4d7e87c24c368ff50b1e1bab05534b1b6996488226663c792fab116718cd661b56fb0b29ada3ea830ad5c9499eadf296d2c24f33c3bb4bdfc5736814bea597c9b9b537b8bbd9efecb62ea14f26d9e0f1606655b10182ddbcb5bc6725bca1a83bcd0603542dfb378240712d9ce6e63ddfc304e6eef726cd96911f0434cd0349b9472f5581f0a38ac08c14d9736ff4214004961df623a69f5d87c6b244e5688c5594f5a5f2e1357dfeeced79f971c6d8e735534577f88fae01905de709013a19038da6644abf30b2b37b4fa951ccc29d56eb98bf7d34b44fcdc3a9fcb88966a53a15b86d43df90fa6a953e540bc109973690fcba761fb0148a32d16714f99187ef63d6d21e61f4488417226d17f38d296c360b005c95a66e6d575c263b8836b017a3c13ca8c741354df46c2a95c129ad16a852d7f319c80c84089e83b6f7999c518f5b4786edad52909b46a3b92ec8c03211f15e810fe00d9d31795bfa3ea81afd949402dad67c8e494848b87cc79f4953c938a3c4c4c0b00a45f4ccde1c1b18466ec174608164786683943f974264e5e62b6480422e7b4ac55142ad9cecc13e96951f40721a094b0f67a4eeb01d0b95f466ac5090423a300c0bd399d6cf515e3f925a17da34d6afd2faed040c72a22c4913b571feaa5a61fe8e30759ed50ea5369cb0d0d8eba76c6b1b1c2be22c308337e262e364760f478b812d2e36db3f3c34234aec90013ee04d1009c90b44a2fb3a7a378d1cd6befaa6c257e93f10e84e88d41c1344952e31d5d4762af2a4b9cdc4105ffbff4372f68dcb88099c86cd8280fcad9786a4aeeb8a953ce2479f5c3513a209d35bac86def85e84b7f0a5831e1bacb33a1bcaa85d083adc00f7a45ca19e95369944ba8e5c7a3b75693f9c002ab35864637d8770918c57f3a92e7b7e2c0481ca12e9f6f53941fc9f87fe60bf55bb6ee99b2618a07b3beac4d3bedc53040dbe0b4212b837dfa01606e2a68f1d98c76a94504ecd8a9f0c01ff7cf4e7045c3dd16e3c43822a399d710a810fb842d1d030cbc3ce367678e4e095717c14c63d79cec2f71e92ef05cae0e42c10629968013bcca9fb286aa181c9d8f761eaeda0239ec59c01dca8c32a5487c228fea918081fc7628ed6b1ee7b60c8a213aa7413a3729860ee34cf4f8bcd43bc03c397f96ae95073dfab329139073920c91e727b9817318e156e0bc60b2bc48af9daf1abdd50a619a20c876ac3eb1e9083580bbf2663afad60d36f2fcd53a80dc5fa2575898e52666fa1c94b5f4412e8a18364d4cbaec4def019dedb5223661b72e7f074cc45faebc62f27cf2c76ebdfa03c4974726ee9d02b770795bb59e02c776d974c00aaf080c0af7afaa10ea325f04d4cb7cf18621dd01427b8a93fa2a824de503dc2eb937b13c845cd18533015bcb37cdcc0028af4add0c59c2f86ac48e673faf6d79ec5f7f0e6610fb27a3a3f8e35c1f64c7982aedd8f0f58d6f6007a2b6550ac08a6d35689605ed7d36d5cd8a01d7f681e53d11669d0a266905f2bb669170ceb41cd02f1dfc2ea85765c160018b0080417e93b855b20fcfdb9902884aa58b279bce09efdeb900f1d981130055c671a0835f03a59e416d88b832deabea294e317b6cd7c6f09a5fadf9a3c4d3602a5be0b48fea05eab70c48f9235302b14803e50e8544462e34714a167c5dc6bed0dcac4ff4730bdd404f59cbbc1c423a32a070c6e133c13bf916b028f584117735d0722a0e739c7cdb2734260eb75a23b96b42322633237f0ad7d083c0bd59839a96b4330847214e7d49a38743271e9de30ef24d0183007132e4d02dc1aac7a00937e6839f542980bcbf3c9397b2dc97e02e5a28b391c100b29daf708992e312cda81ac96aad0ac921b5945bc605ec43d4240331665bf7522f69f41985f32f625c52df28c9043587d8dd4f34e20013cf3ca2e89172d9d31d89b5fdbc13fee76d08c65d5ae47de6c340e5eb9c409925a18b0c5e101b9115afecc729755a0ac7a89513c3620d946b941d2d2cf8e6a20153a456eddd7e2c35b48ee222e0becbd8a8e4f55db880707bc569420f9b7703729f6c305b8a3c35dfaf1b270483d71ac7c9ff67c832b408aa34ddedaf1afca9f67052c876ac3c92e8757733af9a69032ff314539205a5ac3c527e5e5a083d4392feb34f344b4a7410206f12a8b0e3af1ef8bfecb49176e1f9c5560a2f21be956679bd613032b9837f8928226b630f4fb4504c917fbd6c976d5a3f62fe98d4d78116df75f44ecaf15155f9d110dfc06e38cc6f8a79caf72a6ff4ed7c4f39b32574356eb31c6c47766b149ab93c698bcb51388c47bfd1a4cb5a7d31c2f288c5d4b3f2872bed743c18b9ad5436c1cc8658fa1c9bf9c775b259a666a0ea6ad485c40bb29b00025c24e51f907776d9997c9302aaa9c2af3b64bce98ff61ae6f1b6432613016659527cd5802a841520456c547386e6b8578d81646f90b113d9301909ac87d2a4b76588af0c1e9be1c639c4d504e05f4b7884e10aa63052ba572a73bd410e14c3fb922522d27291c2c8b5bef66564f6eed555b72f4c1bbea7807586a4dd29fec546f171f0883743b13efb295156df8ceb39db85dd219bd55f55489944b4e5f78a4b7879c138c32797616964d73d4ebd305a393cb94553406b071940f95d8ef680a5214c3d9184d56dd1bd1128802a09ab91a260d7df5f40d628b00b47dd5fbdfc15007d1b5ca96ee825548ba7ab793b792ba25ee797853e3fd1ace22035b01ca1b550ea2495b6a2d39d7ca9e48febf733aa2150174a1fb2a9c4761a834c1975bc6f6119f9d0606fac9274994007aaa31598873acc67b68e0e01c528df3027863197ed9d7c38f3f30644a1bf1427c0205c616f5861e57770a20d9f107fa91d4631a3a7789122db45448fdb30fdf32c5af1896c2486a6a1562950736f46187ea33becf87bc68ecd4c6c8e9a0d96d954c8d4793a036b58288b20e19936bd70ce8d6006e5ad30e5a2d900c5cd56ba0989b60bfa2b3cc181714021382a616c548630f4267741cfa1b989c46c8681d7d2dac479480efa68b14e882f0f9a0814ebca31a6e3c31194fe7278f07c74fdc903de9fd1e38de83a170602e96d434ff5e10977ee606096775ed1a983db158b7111ab8ef8807249273f42a326d0bf2e79ac4a8868fdd372f1f39fe3027f6d8c53a13fc621d83ae6f2b1b483013b6176b7a25d5b8617bd1318fd8ac88b047fb8b7e186047189d912ee8efb4d75e75d12790a6dba7139dc1b8f1b14001f4f1357bb2e3b6b289e2f37f72ff9e450e24d0322cf3c4dd70ff10b96a34a9f3af6b812a42b97912472a0d515d4171294733d1cea2c2eee76c642462e8063a374dc982588fec3e4a2162a60a10a15e59602f6889dc34bfd79a6cb2b214ce42cdd9e697960a0b9e8d3fa1fb34153ac94bcd0cf69d89387c2e0306426f31b4073c2daf04555c9fa720b448c86fdbb35dda1b36a38e15581277ae4ef2c13179224f7928871fb21a96f660431d62163e13ca74a1c383c24fa63f6eb929df721fb6f6145ed0bdd278372d378229138b63d8ef040b59fa9b76daee6685a0b24542eecc3c5c2daeaf842422fff0df8fe268d51e5f2f8f0490c388adf583dd05572c63c944fe4df587dc18c417fe533e06a7f14372096a07ef476c748e9bb108383578f7d2f74e289f38dcdbe8df0824b0e1e01f30e77b98b92198c3a8912ad6fc2d41da5d4c794d8efa64432981c887379869fd0f0975d1c2da38c26f6e3d758ca00d0676fb311485f898f1f47aedb5e89c35980714869925a91efd476a0d00b2295d8528d7857684c02b5f39eb991bdd4aaf7e34f91015f0b32afbee35f0608cb78fc94a580f04ca61fd6a22205a7f1173fccfa2fdbcb52ebf17d150bdad349d1aa81e285133f77825c9aa6b420115e295a857267ad5b0f40e46e798fde9cdc808c805ac3a19515156e75d6c3e83b9b2731a029922c23b7e4f398218faee38a35c47af12e3cd3f03d2da1d797b68c3116123dac0444b6810eec310f3e34e88628524076be3e84f5614cc2131083a1dabd93afa322399ec6165e179657f7ce69ab090e8004ec899aec3e56b351dda5f140df4a76e7bfa3cb0627c1c480806f1f32baba4bb270b1b9bf3fabc7847d54677bebfef42458113fe64481b4f69103b55c40ab4e0d0a31884bf56c309f906c5354404f5bbfe1f9b5912b4acb92ac0fa6ca9940e343a32d12236a0ca861e77d3ff10a2a8645f88584620b363a3913c6b4a2de97b4e6c082548512b2d4bf383ac055907ed3bb1bbbc23c61836930c413780c2c457f5a18f1142a9219b3d2be96bea4318b2468763eba08696d49a563d627b9ce055c0a6d1a0b5836b343ba264e90346c6010b119c9f7c042f3d97f210bcf0c499da20bd9311264d9740ab628939af35946378c9c5192628475d7ca8e922efe6bcae5cb3bd32f2aa9bcecbdb1f7338428e176692d55446a3dee086f4c605d66c4d7f17ed0623e7efd0c446eca6e62d8e987557c509e055066f5fcb69a95d325b207b97ffb6147aea502c31a89a6d8c74ef164c6a2ec51c73bae90985f0542a6b563e8e465fed87c143492ed60bec09fdd9440a71eae3a0ec1447fa8a2925cbacc81be54bc906952d409bbf95fce7a5212c790476d078aebd3c7d322bd25c2ff26f01c64221aeed60297880de65bc56b7c286986fd985db3cb4d12cb7a338053df6093c720eedc425c594198d6dea6bccb8dfab7a613c13b2705decdb3bfa4659187d2edb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
