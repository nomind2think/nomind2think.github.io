<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5531fa9a086a452050dd607ad04d1836bbccc67ccddddd98f6e5213c913d9516e222a34eb96f6e2b47b2b78c8e068be659718ba26c869f89f9ee2fea6ca0fadf73bc9015bb80dcfeadd76afbed1b358d1e59671e6b40d0dafda77232c0dab0c08835dc3ab51f506960ed41ff25ce984e9f655449c8f19560211d5d075195c12e2ef69b98c335304765bfd5e62d67b8e3cfb475ef3d5f7155b24e9ecc60396a115183d0d8165271aa34ef2961b8bdd6caa4b5df2d2e0f833a6a194b7e68c6ee5ec420da8ccc27d9c93b110c0d59143774108e36053ef4fe165d2fdf142baddf53860fd4a2fb4feb3394ec510ff2fcb6e935b946dbc77474a0da9632117be836a5a900d3c9b0e3b0529db29db5e39fed6be7685095a7d0dc90355857875e492eca02db1247276e54d6ab46b0369d177a379d54f3de6e62f1d6aaa20607b684d1606594577ac8aa80115f39e4d8e21bf0dc7a274ed9f95502738a31adaa73edeaa4e1dfcf3e03cce166ad0d516511fdc3ffae3f3c46f2845f9e057608d29f73ff4cf658cf4f6fbb85472b601d0a681323ddc70a9fe4f87b7c56cd949866f43465e180588d578bf176810620a85a0ee1ab3555b92d5661c73921a3dc6a56c3c6555d5f236c93d02eb32a434a1c210029352553b6300b23c8168097b5dd3579fa6a3745543222046455da74eb61c24b42605b2251224f8429bd09e05948e5c36e78d27d0d44c4d4bb900a3bf4f869bf27bf94ff8cd409f8daaa58a1d8e15424f088f5c1457f72271d64597a1a666125f8d0c199b6e84246d7399d22dd026d0a5b0d387db256d50eaaba8aec476eb69350bf3bd5b6e444d7d0704b7e6634e9f119f89d5a62f68af98fb71f90f0e0fcd9172ea7cd67150799c07198d8921f7f185eec2614dc9e42c716b303b8950b7c3a6e22dee0b4649534c3371f933aaa3d8c45b9fde180f5a2094192a4c9dd2a71ec59df975ea07b350d7e69f997943d05b758184fde4740447f9143b7bc94b9a298f3a4c89dec86aa5c4004aab501e2488a217fb0948c0e37cfaaabef33e792f81ceccb9b208fc1397a3a48c0aa0cf8ec8c2cc7658fb0f8d7e5529718c522a3b0c45cc182a0827a8eb209a1f0ba8840403ed932d438e156d0843b692a3453fb71dc4d0d7c528000df44973ee8b140bff9f8c6a3104ba0724b835bf422e1c8c4536b3bc4f8ced280d221b5874e9e2a6b389751ec9cf22eebccc85c75dfe70c0f8e2e2253ad473b74d6e47df027cc748e8438b0a1ff8b19e237979c73bb10145bb03ede2eb1546a505804ea790c35dde45ca80a1f0f18cf40927256d85ecbe7618a795ce6b704b9307c1acf4e2f7b8b8e846b5802716ae799e5f5d2d36679809fa703343410d13b4544f87fb3ae863825c1de0ab1ad38420899b248a62eeac8aa848652bcd7a858e7bc785c95bc3859d9c5e3ac8a9f8fe34b03928bbad9dc27af9fab85ed44e465b9932d325951b0ac793409574b3b7bb38c2b0ea3cc9eb527be13ed012cdac494e77ed23542e8584d08a131bed42e20e0905fdcb71f82ee87894640c1df1b93272bfd5a74403e0efaeed96edfcab8fe01a5fb13f83e16f6b2b1179b85ddc246fff4aa4d51f9b233fad33787e7c707e4c3d852d430395cf1b9959830e73f948421c61fe32e786b3671ff645db16252f59837cd25c764718529085b7d09d2f3fd9c708e65351fb8b8a17be0110d8c6de5a014d59baf4e65004673d729248f2c55223a211306298136db48298934ba5b4ed06cb219f0c86f6ab74b3756565a1f296b6f836763097087fc3d6f07e0d00a05c5c5661b328af2b02cb9d3bafc0be058bdeda38f420650ba80d90419f37745b0e17b25cb6d090d304017ff93d8f5ad5549b32fc25513b54ccd0849b45ec7bfb9ce3e7f28dd637b894621d7a648fac0291f74b6cf8f5bb106ec7bfa8d006ace4985cf7f873aaaeeca3819890f0035952f8593b6693d9e3ecfa3930ed235f75e409caebf3fa927cc93c1c37735fc4ce5bcf15aa1e01544e59c445213a8d9a7df629051d15a9e8bbf376a30606f1fe80077e3ad368704d1c6eba123669b335bbfa936962d0e4d06ad1a1ba95aefd87f719b0a0b174a9b5cd127897122241189d472f4817c427e104b69483182e3816113a5d0bcf4493e6f4a186dd016e9068375f7555a6ca778466e48dd801e83d6d6af7046d0d3d54e07d05252bfcf58eae732c518b3e03d8469d1350fa924e5cf86d443212fd2331422b7dada762c61e88f64d97eb977cb313c09f308b7b25743708a2a220e9e314eadd47b32bc139d3316b3087f425e42b9fc44a6bd4e02a1732e15fa3c2073a96816a7e761eb7d6bed83ea7760c255eb0f6aaaff491adbbb2419f7871172b26613be2eab4e7891e50804e6b1411f517fef64e970e4970249aeeabda036878cb7ade06160e8b8fb678a0b09fd1cb3c0b0507c71253edc102a6eea2866660d025dab3e21d1e9fb9b6ad5ee92f5f7108200d0a90ced47e8e4ef3b815aa2e0f9af2b4b0629de510eea69bfdbcad2e5e23c7ce9ba145e6fa86ea67a903b514e670ae034446bc052fd29f918c82ff6fd96d01df5be1ead11a4303a07d8cea27f00de193d0f8de03918249248490bc09ea27b59ac1cca5e5f828444dbd78fbb29cf21a76849d962cc41bcf151855528cd52da41e8566523ac3c770bc38269c0e58da59b7a2844c7e41aebe799bf1819f9c860b51bfd52669303384706df64969c78c6367ddc6d1bb38072f0c4e981a5aa867222a4c6c045d675faf947df1d2435cbe143e497d521ea655c719070b262cc04ede3491968656752173a1bc9dbb1876c6a1d9c61d447af76522e9cd896e71eddf02b95a2192f57afdd1a196b23420f0a4e530c1470933a4dd710a7da65f79ea370d5b488512c1bae15bc5d6007f88de44981850e8529118c344c8bc182c248ee25d65e1f2519a4c4eac5f8969d4e24711e8620ccb96952ea4336e3d821eba51f3d37a21cae282fd335a03b9cf4c451f48b29277a47de84ca53791d6c4b85c2fa7b70cfb6d2a77b46342c12e6ae9dacf83526812fbbe151a3d603df7acd4649c9e6de65e0ddcd85336febdd7a4a687a30822ab30c3fe1dfe2ff58c949b8b3d308970cb693e82b2fab72cf13e9ba452698596c4cbbe5766e9845a3e43d0325fd10760715d191ecad69f8e5b8ed8463ee8e88b5c0d01350dab1055a423628ad35b64a7041859edabb02496a14f04ec9d581b66d009836aa180f392f57f2ab7dea3877856f858794a4ca2cffd8b22734e8cd9168a27e2490d64f6d089735b9ecb771180c8d21d0e303094f3112a54e143510165f4bec9110a7fd737b36fb1aedbc9993e5f859b3f9aeeaad5e0668fc66b666e9a996f1b0dbf8528548e32c2b2e69a87fe9d07e5a99a8ca559ad849f775bb2fb4a2636eb572f9388f1750902d70e298fde8b65746ac72ce12728369de80704e9a98be4c9483bf3a19b416e42d6f77fbece61b9738d82c813bd729bb8d7a8e538286998eafae3271a3a70a1fb2676f6ad760de9bf9dcf1fce7a7cf3b922a394be7a2d6375691f2ee6e3a1744c417d0526a97376199ceda5aba3f268be5631ed62a3c20a1f2a9249f212c75c29e358fafcf8d6015e28cd8a69693efea18120e9b0ca9987c75c50b1447cf6c0ff8cb127aa9d050e86b6dd9f1cbfb4c27ac64e219a70b81de6e5671a840ba23b8d3b9ca2be45377f5db133bdfc78af67527046189b9b4eca09d6d397f047a0bd5b2b7b73c9c811ef5c23b0be177bf55dade41ab1ba0e403ac60de77868dc6da46242f5c08a6be30668fa7783be377ad3636a23cbda5112c772ded58fff523074619ea9fcf43ce0dbc599059f84201711aa149e8b2db40bdcafbedaf134e133f6f36593ccb8498c1f12270dd9806b790d60b7952dd598785f7e722aacc09e51c9131e82be2a396170296f16705f406224c098b168c65ba5a8606884dc90566eb90d6b20f8bbceb0913e956128590716c82f822cadd57c3ca30c112f261fc0815910b78531925d86151bc6c190fe8d7ea3ae2d0e88b65410a1eaa500919fe17764e43581a32f0a2c7f5cc963de52d188e1b7bf0db9670db399c408d44e3e35339abc748ed2836ed4404ee2f58862d81765bd37b219ecba418a45535497ff05a800095a6a1095567ea3f4b521200021707243f98d2052b5ef81d5057827061e80acdf732bece4bad12f02048a81d33d44da1ab9b33664f18521473f850323d88759390c993f59296eafbbad784bb69530947167c726a7d3f272c635aaec25523c19e5f458918ee19910b2f94e203ed4e815e6101557cfd98de1370438fce6fffb6beb9984bef6150f9b22e196fdedd8ffd0a3b59c6e647273e594ac60172110eeafef250317174b3fab0cd2e7d49d9cc1a2c1de3cdb06ed7f75a01c8a685828fda17baa334d59b06c126efa4fee49d08b7b4e68db79119b71c83f6811d1f875b3f7e621ea2f4a601ce2372a6059fccb3c567c0f74b6e0fc444ce93ebfd7cffb73a78b2d6800ac02255a4dfe410bb0fa12fbe3e96465d7e63d62a375f022003c7c29a199bb821f50ad9b2156ff7a8759a5f23d33b441e26b2843df457dfe62c4aff95efe96174a6362efefd786865a55f8dbdb6fc5092efd4573ab56de40339afc8ecc16eef983c5d1c1d3fb7747832351a41ef2527ea9054f8c5fc54e4a8c563b9dd5702c79036c92afcece5c7b30ae551ea286cdeca26780ea269df8345ca5de6b30632ef0b10f91fb2468b24bb76f3a47e5b197d08f2a2b62688af65b81f1ce947ffc3506b77b16009cbddd9320e78f3e0241aaa781fca601d3996cbefac72dc68d80f2822309e8709e0adb52c0f7112814249d2734c538b3c91bd1f53552d8a4c6936bfa0624766a825f9a1b565d319338a83445241ef94d45801f31a8062c004c806b6534325ff9da65f7d66577d4b89fd5127e1f1388f5f8d2b563c115ef7b487d257a056ae88922572a66bab19da0bfced4a14dc24031b950114fbe8ae54273cf0d44c2f730c58527c16a78d40c2b3b9b767949de481df7858f997fa12e7d45d7927407626a5531252b5c5f5e40ed72708e251cbfdd97f50fd3f6357c6b06d6cdcd0423ebaba3d9ecc36668dfdb8255176638ebdcedb9782dc8eff5c4299b32aa78a03702896e48647980a7e0ddfe02e819ed02c182f456d9d9a4281962482e77817e5b281ca8010df4cb7ba634d3e2585e67b7de26afd3399909e8e0fd2f367068e5dcf33296bdb42f043b3507fafd661f1b21fd882cb51fc2e30435528329e0a4ba8746611494e09fe23923b27d386a49edc65b00b537c721d1486bf6bf633e50a403c769cc9af5639cc7bc3f2defa7ad99166129b4bdd229d1ef93cf2578adc4b629b6af4cf9d7974d3116e624d15c3a4bc150a02ecdbc72a4a6d230f1152a826c1b745ef94a4c909cefb1d531244ac5a269987e481bf1c5f3226eff7f1951378e59d4a06cfb6798f16fb451c104832c346a7c8612cb16df2d9034840f48b84dc4a377a5bc9c26a0d5c396bb57ea6f273ce27b33dfa22f5967790b6da413660d32c8a4d632b86e659d2bdca224df39cf5a953a6c051429b8d4ac2f289e4b135dfc0f6d3fa2b928b44d57d5a291c0d999acb0db90cb3cd64bfce37fa8eb8e849c8960889db46484614a2def4585786f77473ddcbd544b4e5632a91ac3be718d366ba1d0b790a005d33e92cb5ca6a48baacba183b11fbfbdb238bd3fc2e989078cd62abb246d7ab9e8ef7ea4134122c7e20335d1707788fb5d8d2e81da25b5680f9e7ffe3ba9fa93817a5b17adfa26db4648b93b9ed91eb7666209fdcc1b17987250a5eb720bd17e43208219d642e4827a33f4174457b30ac5b313ecd99639bc9123918673f774cd4ec6a3cc06b37a2a95d0f12032747bf8bb06a9f56873857a3c74711068f8dfcd84bb4c19c88712cb6ee9dd72f2b9df01234291b01d52691c3c5e05260a1aff057ca04e23b1c7490466dcd38990b39969cbe0a9cb73ded8d9b7973442e17720d54ecc631c890eab439abb6719da5a55f6ffe32b3ac88c2f1b5bc471317f538dc4172637ffc6393d6342be15f107e7ef87fbed49661559b74d28701a079983456a4896f4ddfe6ae0c32083ac06208559d79ce095935db261795241f9f552f57217129f8e8c15605dc3f4cbbbcd736a4a66cff827e35c365c63aea21127973a2d3be96bb300b42404059e9ccaf2fbd804262774890753aaf32a288f7eb9c6fa5936553d87b29179a60331b4b0e859fda78f10ed7bffb23b3a332939ba0e930638c185e983a5f50b74e56f1a5b8cf1ad2d3eafe67a9681ae2fa66954fb9c454583edfa81f31be3e823caa880cdb9887a4648b001c6caca44619fd4fd2e765c65f510012e355c24ce3f2b394c06ed039899aa4379f8e776a9fc61b96a798340681e5586eda2e36f62cbce52a5209440f4b103da07ec66e4a7b56ab411a1315b1f06a06a845922f8e4745232f1160c51dc5c9d1daacb9f286dc584a6f49d5700775a8b7db2aa1cad3ba3d008bc562e9c0ef132ab1b7f2218043701f37c9cce5d45f7b3987d27ada5dd2aa4719203151ad162dd7a6396ae55110e5a02bfa4ac1395a16ad53cc47b36faad3619217739e618d3c4ebfe72850a73ec4b6845d47fb3289e652c0d1e6f27677564d338bd56a2acf66651fa8b340763c634f0df37dbbe70d4cd8d6ae4e89680a53c7749d674a15840d1ec70672f4f721c54d0975f60ae12fb4643ab9b95ecc5d68d88fe25fc2d680b2d9ee7cfaee8de6e28d3549edd77df3020f663469343e8999fead15b3cca170c2a4a5f85ebb76bea30d5ed19c12660967f1450c1490d76026fc2768c9b54490083af410a365d3a5176b86fb38a7cf441baa9731f23abcaea00bcb5f1a43f6a66b7deb8af3772c75a5f61770e620afbeec1b70d6103c8cb0aaeaf0640a87819424dc10f5beae2caba315d6b9756d82cfa65522973d215771fdbe446367464cba9bd8e4b48b1a06e63cface46a550f36b989db3a3413654e8ba04fa2f13d0e70aa83dcb731684d8c9d2a166a8be76f7b1af70460036fe25232e6d0a0e8bf7d3c5d5e0173cae86b67e978872f2b033d4fe689669ae96766aa31bc1265224f8015c5ff837bee9e0e426f4ebe5d7b9863ccc05ae5413b5258234067a6b80c98aa6de2facc42f48d46137447e5739b87b7607071c73b9cc1dba22e1e3526c2ab2b02d9437fa5696d90624cb707e31dc82f38708da7f1bb19fc51c9224a9af8c3d9bd02fdff12fa3252958551ec651ae4aba418e61d8468bec4100082757bc8cc6c5c9229fe94de3104fcbcb770231b5921843de9660e1137b4f8548172f7588f3ee5c694c6c623bc130ae35f046d87b32533e0d7c351e1142d9d51281278c2be9dd49e2741e543ccf88e77497bc2e6f09ffee09da8c29ddde627a7918452fe8464b5025b97f21cc33b41b72b4bb52455280d0b905e4ffd26900b64545cd870ab99240370c7cc077dbab46a0985f448f8d94b7a615c05f51a376810ea03a4a16f6165d8355e9a9a9198503b78751c0c24427a09cd5918e796b7373d2e1a04017daa6a8213bc7f3f001732b04018b310ab86365848295b2771ff0814b562d31b494c1e7dbeb83cc5b080e13a2b9a3be9d55770c419259342576bc51c30c52fb0c1ba09f0d4228eabe13c43013a5095cb45e22af297673851a5e83c40b5651e4a01e5add6b2c702b2180f7ab28b75ef8f91b2c26881f7e72c9fcb851bb5ccf25398dbe672a1a8f3436733c0ae845c4d9f155e61501b63a9f795ad83596a3347342ba8e8c9878343dd543bf9ed8c8a698f4c03bce59793de2ad45972d93cb89290c783c6dabbbc4bcebe413366cc7e2c5d033cae00dff62a0ac0de1140f8a79a90467e0090a6ec5782bd75966ff2a7de618643dce6655227978e291e605949782f2464fa2bf516712d8841ceb4e318ba9de478842aed4b94279a8710a09d95038b0c22ab45a0958c7b8cf0b8ea6cd073b4a361ad63e43011e2afe891922d78705b6f362abd5461a8611d9464619595c3b785378d589b5205153b11da05ca1df1a9524aadf022067fb046cbfb6217fb4017b17e6edecbcb252216dc792117cd95499b37abc96150ff83f1c3ddb9a7a414f17327ededd838c3f3ee26f3930b0e1bc7dcf0356c4333bdd81bf86aa460e048e8652bd7569e5a409642bb3819c5bb868e9f37a095d7b586690f6948d1c87daf19fd2203e8f86e9eebe654d041a28985129cdadc5b6ea638058a7290e4da05e373f61249b3778409181cbd3161a1927dd9ede71e315054ff9f54ceac9e1e997901bb1df431dcc21c4723ea51312b0906f85873aee51d74b87b85336750c7800c58a415d75d9a34363d2be47604fb80fea3075f30bb676ec24ad55febf6fbc33cc959bc38220b7e966b1e85db586e4bd497b436bb182af20b76d5fdf908700a25050ffa8bd0f3d3da8c897399806d7ea7b9d75c9965783c3e38562484a11ca45109f6816cbfd2232ebc1a1015cfa4c7cd584bfd46d3c45b535f62ad162d241939a966cea89865eafaceb35247793ba50073d375ddb92ab85fa1db6748c16a139903ccc7edc42f104f0ac69ce18b6428a633e1a8758b7747098c948689e7cc0918277b78ea4313815c3e179a708643b520ce6329c9f32ea3902642cb1744686b0afaf5311b3e171bc06867531ee0da7ebb8c2bbfd98eaa3625b98afbab5317ef9ded47a520dac90da29fe461f568429c455ce8b14d4580de5f87fb43c7a527ab373d0470f87f7377d8ff88778adfdb5ed5d9ba67d976eae5284e1ffb82f070495a3ac79fd1d150fe026157c7827efa38c1111b80d49a7eb294599a1ae1e800cbc2ab31f6b197313c6575f6d3d623c10afc7293916a3820ba72292180b5f51620cb8a165f35c3e4465bbda83ed59584740006326f30e0a8306bbbfcbbfdfcf6cf07a832bd585c404bbd3bf13fdb03a48e0e0f6a8dd6e87c9f4a0d81e71cf11c1ac37dbceaaaa9feb8b2a01f5cebca6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
