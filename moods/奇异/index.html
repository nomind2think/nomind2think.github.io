<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bfa160c2359975ad30e3e5159b9985aeb8d316cd50e5f37e7b6ab725eca3e6acae3f14a10bf12aed10fbd931be0b3a223d7893e4fe729f3847bb4fe18a5626133bc4eddc0d919687c2e9b7fcfa77f96ce0a9c3e9b81c2a4d2b3efa154ab1aad31138a178d0b8c946e8dff7f28ac3cb269083d7192f9b54f460495724ba91c7b7bcbcb5d916b60459cd2c19427326657862cad595299b609315cd22aa5f7af237eaa377017f10583b8b41fd0bcce25dc62da5db79f49684b4fa6636422d86018e6fda5ac77367829238c315ab814a8d0d7bbda297da61466a295aca8b02ae1e31ebe954af340cdb0085a97bcbcea932ae7ecc770658e81e6a6b3ef98200e2e5b04d9e5766929144e556cdbf9b56d2eb162ecfc86e176f4047c59dbeef23e01b7c3aa8b1b68dd295422882d7d9577a677542ec1fd1293fec1dd78c9f51441723c488bb037d86f135cee594df120973a04261df0136c0d031acf6e843364e065ac2c3f9d359ede100c61120b7e4a32f3262a35145d25be6daf51f101407934b26718e32512619b244118a325a87f3cda798bfe542db2fcea1b5d7d9972898cfcf33bde786ed945b80c5f73a9eefeef32ed3afcbc2880b5ee9ba156a3c33f96825a782685ac37a44ed6bec84ab058f4cf2479563cf15e7cd0f92e4c7febf2913666ca291ac4e3d861602662926621effb6cdc601aacb470db669db8e2d64ee0070678876bf7df56f605de95fcd3a31f866ebaeb07b198b648902209a2e0f5e1b588d3274996309db985c0e4cc69ed8be8cb9093c169fab4d59b9c7faa434834a2358071a47bcb3f7d0bae307a5bdfac90758a3a03b3f88931cd2c7aaad407c4e36d729151d8de6ce44709f800360e0629e83374786e4972f28a4cb145fb3feca6f0cb57db76f3a4331fe4dc39d42a32f8eff4c2b6e8185de0af1c7470418d28e6f4f12d6e2fd842a1425f17e19ee8835f4db32de1e70817417234b9795ee1be2f7877a5c7568afb1763e3e5f070a7cb38cf2a6e89f7d6da0de10b1d16a68924442a8eead8759bff870d47f54eb9c4b7f60c15cf3cf5f5c60b6d3bd594f1d450bc8be667818725fbefbbea305df65f97101f5da9a5e2fbc34dbec0b457f21357392e389dbb9e7939f9a123c7559091159e4d09e62c4fbda3422c309eea59d206823ef04d01723d7189556ff9603ecb13bcac2f5569074423864aad7b850ab6436ae99a6de4509f5fee4aa7e63443531dc1e90ab3835325a2d1c59ffb33ff18b832f3f0b3b76d5ab80955cc61bce2d7180284149cf50d2de298af866e2b47e8185ebd3577bda1ccd22ae4cfd67e05429579fb3f8f6adba2d13a7d315a2a14a3e055653b9817b0dabdbb81f652427f4e37079cc211a3cd6ea5b7c339b4be7acb662f137b789e4cc686d603585f5a0d7c36aec3d6e58cb07bd6c9e90a6ccf2f331b1b08c8b086c6f5a875b4ba9a031cde180a0c69bd4163ac01f4de098acb120b3d4b74de461be2d93b785c8971b5dcab03e13fab80215a15c37401eaa9ffa666a33cd645f71c34dd891f5cb09c85840e1c976991935ddd935da2a94c8e33fcd3e2cf89be4890f8d7ad8f98d09d7ae711a45624065d95b54d684fac3270c32cfeeb13343c2af5e5e5710791eed1b0db6a9fa2055f04057acf2714f7f5bad51d543d3d7d37b1a0c0c427369a476cc4a8abba6adf07fa18908734b9f4dace1e261fd1c0bf25ae0c08007010668af6e5d5986330454d9b098ac95d7e38c5b40ae03eb57bd332dfc799ae422695830343e1e615e69016e605dbdfa42a6c0533950c266a393b835cee6dfd854d0a872c231d473890be98fd9dd630537aa9bcbf67c248a25b2c576b5c150a728f27b343d9b19c0e2ebc2f62e1fcc5b196ee9e610ffb85ca7350ab07d98b41d3c6f11fec8f904d9d4bd13019beb4d513933eb1afd15c5fbea55b77f9b1b26e85321130e643e1c0a9900f93e935fdc1f88485ae76b3edb78e31bac26a90f244f0dc75873605431d7cccd725d5db5a4d5ced394d0e15b73e4f666fe31642c2bda73ddde6419161b406d3348f45c5f390e1cc347f1f65032cfb34ccd26a84ace4fa89d595b7ad4b3ee479901fb702f7579c3310b5cdb6b88bc5c43d14b2a946fe9e6bfa7cce97ff9348afe34736a6238648e258f30b86fc55b8ebcaf0ae35f20959515c16804e1b4f62db64ef8b95463fbfb7d9fc1b53a88b67708bf48c4325fe221e4a7dd9bdd5fefb63ec590a19c1e26cdaacda10a18ee5bc054ece725c4600e5aced0aee6dfd60566ccb80e5f7c03f46e5a0db7501b839d45975d7c0d4d0a59a2c9e9831bfdf692b7ef80bc41620310a5188e74d5792d27b90919f58c5ef11e7343222af07b5a1e5457f83327c0e99b022153379ec5d08f02e20be29562851404463b8a13371a93efa0a1c77a993d921368f993fd4004c8b2fe9aa6e29c75ed4c1976f429305ae0deb4ca04cf0e7307df18ec86c97df427863f880a628de6199147a9812f50b3ca5d7c8c01300c5279bb26e01da8b7e6b8fbf8be3d9177ddc20ecc60a6d82a8e74554d7bcfaefa7badc9aa08322b4b5b6f36a28aaf21532ac3004addb73ac5b5d66ed927e5269213895fda3179a6e0345fd66c8eddfc634fa046316d98409b52302b2fd0973eddaf77ba7c7cb744e785c349a67bdf02cc8f6556a735d5715d2304f340d1f8581286a7d0f0b736a5bf827476892995718343cbe106711fc89336bd15e27bd26f78781f07fe46e4638c87f8e782ffb8ba8b5a0f77204c776eb5983a5db162220db0f51765a7fd3c638257a9f28516c9707fb4596c98e24a16b54531e1985dfec327b04d42d09ab4e2cfa40091b800f134adc5e85be15261b71748ada8cacf2d81609efce65f4bc03ac5f175ff45ada5be08ab0b2e02699085b57f691e587837874dee845b4e5781f1dc558891d33bcc766f94339ecaf835f60e98f9a07572af767b2b1731131224378cab3a811c2bf8ef93fd483ab3b28776231efb3772206df67992f5bacce902784554578a539ba5508d8ae2bc9c77d69e5c2c9b06bebf96ac05f191d5ca91668aa75ad37e226988702d06c432d3af520f7bc6d0282450c51d4f8314ab6df9c940514bab071c49740b3187784844cb5ec271e6e23c4ca6e730f60758a9bed37ab37f3567162f75577094e9492049df8fe73b678e5ff78dcb85fe23327f9a31dbed3e38fde25bc6450f18e4187be80d9c57153e7ec15be07814f2f0159c249b1e877df83f59dc24f3807866964c0a51e82a7854eae9ad8fb13b34071eb3d81e934828dd211dd35171007525cebe2d218baef257d06968dcfa7fef8dd3659f1a874448a4680ef9d58a14bc3b13d5337adda13fcdfb69ce0b32842acadc5bb896a7c8cf846f05a381fa91a9aac45bdc2bf10c4694b5fab94d2a8638d5fbbf8549559df1a978a3004a2db3bed1762a6ceb4836222c6078175b32beba09ca99521fb757636963414bc493428db52c956df8f9020098da0556415c5ee1a665a50facb8ad719b3cb0eeab65022b4474942d00bfd0e46a1d04f91c3f0c792fc7b644424c8b330df1d52940e8fce4a7dcf349d212dc543c650abca55a7648f26a039c523959f39de13d2b7613e1fbc839e36238997747e5c4dcc206d3d400b089789cb8d887770dc4f4ab1bd7ffe8d807d555b9c9cc1c5314c1b402225a07cdc5bf6117b8efb0234c6ae8633853c398f96a1f174cba14122472ebdb9337c911f8ef17054e0985a82636e0da45978ac1430b067a49a71d71a2632d734ac55052c8cea760da2e8f57d72fc0a5293bdeccc6458632c31e2452cbb575fec92b1bbe6a451a5647a743d9aec636451220f35477f6f9d8627e909273dac5f7d30235519b707628b444aab52a5b6bc6d3fafecfccd2a06547ae5b7fbf4a2e5cf7b5689934aca6feb33c48c5624dd1b46b631e2ffc90c911d1d1e12637a9e8cae6f70bc69a4451fecc47dcfa03d3c51bd3e89d02bc37f8f8385beabd03c4b16c6c950906dd1c78b084b9be8e625c4674a72bc917f8845ae789a09e03ab38eb6be06e107ca96598c2933865d968c162f6e8f6ffb1a794d0ff8ea0e2389351f1e772cf70f92971154b93d6b23441c1029e418662bdb19d51a06f58735070a70f0272ffb52b8b8bd45a5dfb28fc4bac2f17c6d2296d419f45fc2cbc5c8799e5502f8592c2299f24478166ed20b7b1a012e401046863ea233591018f6f71a9f00ef722c851c4ea226a0a4afddbe7e40a2337e5853057700347071ab2a1b3e1b78e11e3a30ccfc22234bf350a889da6790b6563054408c61201c17b2647db4f368ee0fde26682baede8fe78157a52a3e87f900ae64773e3ee784f747b3fdfc009d209fb0553aead7658cfce720c9c7978106eb7c1bf434d000ce142a2d96966abd4d8c7a7fdd43eea1e22bb9aee435c6ade7161085acc59d62651d276ce455364e1518ad2d07d60fcad9c60ae037a0192d75b6aeed5eec6972c3f06893de061a716b54a7a02cd6ac4f66834fe428021ce3b2ee13f43084918e35be25b8f4d4e39af8b50aa1a0bf47cfbfcb7ced8151144484776d7711c23ddfaa5a0fe05de4104fb4009b37c78ebef0882f004bd8bbca51603ac4687a044feb2be3db4989cd0127943d46caebf164d694bab8db7b9794a8a0e918271d4fb99209fdcb101bafb21604de6343069d83638231cfad5a013023a09aeee9bba77e4e21b42724cd47dbec81930597ba3628404ccb4df71ef885ad37770f7399753b5c10dd1e770e858761c669ebf73be7575586c56c34c9eccb1726d7475f5d50322afad42787601b35d9abfbc340627e83f84f5cd2b6d632cbb6f3c90bc3328f84b720e0a804bd10cec114622547c3deb5f772e93089644be74f127df3799ffb26ecc92811b774a64b6f90b7de7cfcf265cee340f4b846338537b55b192ad4d1c6bc00608289fc563803a6344f215fc14efeeefdfa4d642ac38ab768c640e665cd39469ec84e0166af8309d41f307074767013772fe45b8864c5805a515a024539569e35506a35391d467dd7f6eb60a7c752e800673b2aa211f5b1f1a008568853ddd499c920cd1faba161fb90e0fcc04cd390e918d36823c629567911ebe589ba3dc99a4c85b1141be50f123f4cb4ffa69798424256b60a7eaed841447abe53894733f4edcae03ebe3a8790222758f0f16dd52e6b41d5415f1d44df49c01743640b0dc98a68b1e913f2ecf3f031124acc2e5ad67226631a3e0bd8e46fdf7b18ced524bb28287d252ee640be37703455beb5571d9df527c27c696b363734403f63ca2f17bcc4380f7bdb3d7870d3cbc580b548cc3d1cf634c42a3f098fa07f3d824afe2a9058de092e5f7f110b1cd2fc5e53e9fb54dc07ffa23e57d1a93147c0468e4a23228630afd93479e43ff7cfafcabe4a63aad80f1b50f62da8a8e66b58fa48e4a7bfc98c7715e99623b9bb6de9292feac3ddc3716d0d16d9a7d52ca6b941f2b2b2a6ed5a35a2b2eeb240cfa2a125c4b8935fab4a0875540e85a5ddc8c2553a152ff7e9e2de8c98c080b0cfea3f291b6eb0fb11d00611c6d49fe221c9e114d90272c1f54156b7c70256354c3ad3b296d72ff372dca3e2231555e87e7bad2dc7f1a445243f837c830b4f5bf23495fb87ee78543cc74c382c20ac87a3360f18bb7875267b05733a4c5c9b04229c7ed23d339b23944168c80b67027dd00c216ae91d3aaa5ecef86800adfd259c837728f3bb6edbe7014fd2706f990ececa7a29c9012ebb6d0976bfb7e457f7b25628634e2975d615fa062966ed3cc90f1c5bc1eb50fb7ea775c7abdab8792efeb6fa5a55db1f4d2a5017394841a5354aaef20049c1ca2224972a6d2c4f72cf1848fe13ba8c67f0d4dc22a33a1318729b27512e7fce662e4d00d2b8aabc6b70410a1a0f794533d5ae3b529339ed7d9e3a0d5dcaf6f51a294baaa61938159cd9633ee52737f0bf252395fd6e37186e48a15d10b14aa22e125ec0289f068a1810344780964690272b30812491c1029945f1467f86c000c3cd56bfa171afed1c057c552fa810f09e8d8181bc9ae4a26edbb06d78d4ad1e9efd413ecc6a7deb72557673d596249383e59f469df6b90468f2eb2c7e66aa6090ff39812bd4a0da8e0ba49f189a64b8ad8c250a52945fbfd5e3b301ffc6f251e1b85150c54112b0ada2380aac9f7360d7cf2b1bf5019517bb9682f68ef2e4b2b5a6fea860134b3567e57a2edb458d997988c058e11f9f3f0d6deb08745e589fc06284aa58bbd76141c9ad4e0d905bfad59bd64fef886062a6dc1671616afc9d789ca0af0ee79c5231eb28965184995b117f4056a677d490d6d51680f5102020c240ba10d64c0ed958cd0b384e0b9a9ddd6d7f7927a6082e28c5498ee2b0721ba846680393a57c5538574ec62d9a890f5d63cf3a98c521c1fd0c22126c21b677efd33f99565196103733cac888fd5fd7773044d82c022c1cc3f6d2562acffd1566d847a2798abceb09e5b4a41909609957dfa2b311880938def88ac7dd3937d208eb6d1332c6689de56b1c15720a7b7e84a7694e96aa05d0de8c705b8c2766889940d5b55716eac6e77a4b8c5e88b4e84adfb1987d76fc228b749fa06bf1e69439be9b335bb830ecf5ac0baf1c5a5d0f5fe06cced6c244f36e4a2c7152c5429d394ca3641f79483eef97f78a89f68f3426e3ef8380d6622c607b9551158984a7b412f281fc2439d4f86c30461fb6d025a5475873e4cf88fa0dde6f77d34f4e95e4701beeb9e97188ebe6cfa6c0143a31dad434e077486b1a670a56e938afcac50c8fba28316b6ba736dfd387a300a6be0d573ccaf92623d681eb77332f95318f8cc1e580432d4b2a5aa0727233955e00c878b4276484fb0b6d25c59810a910d5a81df362d4bbd09adc268b784dccba0815caac1ae2c78d1fcf25080db44f998ae4d5eb7b505080ed144617e3b8b1a5f7a6427efeca9ba4c1f9c810f0acd2acf7f5d54b553fd6b45b988270316af3b1917575244778e954f685f914d41e62cf93b766497567e14052a5ddcd6f5e98db8d2de9e8c3c9e970f58a661fe27e02d84be0b48ac126303c5b3e00001d737179a8c4137dd5201536761f8863b2c12a43af4f737b703b0303f47b6c4bc6f8923a75902c01db11c9b60ecb6e40d75c147dfee9f93729fa4f8d6cf19575b3dc435703afe30c5b8e2de4c4fc81774706beb4a4a97bcd562ac49da301da889c0ec7659bb39575dbcd87acb1671cd8612cc817a24b1fab10c7db8930c74e199a83dc2ee7b84f4482ef92fbdcefc03c9d50ad223e30a923ca636bef0e2bb58b86c4592e39246af5dda9070450d90fda4b1ca588ff1948c04126e34ea28eb740d6805987e64ce092b63c088d1efbb0ee27c7a6993f21955298285af1c1d600a40bd65c195c66d2f6acc5ee18451863a5d4d7d38da6ca43ce02cb5f3003b6edd8453e8b2ec2a2097bbfc3c011b46388db68bfa3915ea59f80fb7eabdef50b0d6a49e4b58db18f6d11c3cece631ab59e0277773ff2567c9fdcbadce44fa47df5d1d122ff83aca61e862d94ae82c3f2efcd254420c651632ecfe4b8c413db3c9f2afd87148a5108566d28483a0ca37946d474f0e2e4581d35362f408f56dee6cf9cb05d67e42c27b1a14886416a27c91768e9ce25d9e3c2094a3304fae9988eb7509edf5b17a3825fba57d45b123c052dac710f1ee8c232b35422a7af8a1bc05aac47f72972a2b7e196440359d2fa59eb84afb70462f785f84bcea8d591ffd760b6d46bcc381090fe0701e1a6da2469ed1717c074862d2cdbe66404357b57d74634e2b649508095503abc669e3b7bdb9b121456806d3aa1b00c0888d53783c293f2bf69f55a3ac03750e3e6e273bb69108b8e6e37888d70c55859b24dfaf82ded2e7c616395f6daa8a26784f246af7cf7e200ecae0b3502dd552cb1c6320e57d13b48c89f2f1329d4c920f0958a8644b8661cb8f17ba319df414ce95a0c0df1c035ec3a45bb557e1266d97b59ec5b11cfb789a70d15ff9fa9c6666722b68136e561eb09b9570f002b174e219eb8ec9631e52415d6ab76c7471c299b0498a3df148319ebef1de07f2c70f03acf519b11d64fbdf2565e21d483ca1140b4d0fa2018339246896776aaecaefa0cfb6381627242f3a7726228ec7a9b4d8683f8e0c79392e46a78bd32830fcf670b9d6efeee2864a2c3b2561b46086cb3b2665d4f80b75d66693e1484b420df74b8619e01a91200f392423f0d95bfa55a1797ca90bc2399059116307c5706c6eaecc260c2f0f649b648f7eb05595248110e4ff86e38a9f913f0a957a2af314810111714416f95c288c350e292bcfe0eb7015d713ece64fb90eb05d76b95a55d79d654ab701b5ee86805fe8ec69f15cd204ead66782acc1c9814f07fcd88720ba97ffc926b44f58c806a28848fe93d823c3708b6651f5a9aae6d49fe7c749349bdb76b7e337cedc63e27bcce4b69fcba969e9065bf9fcde0598512f3d7be955ff595841701c418c3e26106c836630dfa24eab4573433ba31474c2380a9d384a8a78b09953eb84fe66ffbe05b9495f51292ad9fa86efa4e1d7d0e0b8a34a89aef59ea43399110e0588bc43730b50e5ea490d7161b0dd702dc526dbfbd1ac75ff2419dfc50e4ff9ae322e17d04884ea7189c2eda2b9de44d84fad19bd8008d87ccbfc8e08dec6be897e13c600bb3b1155b47536ef727b97dc424fc8d2725ec2d0372a79d9a2ffaaceb2d470cdcbd9528d0b43d39dfbf75da854fc8f5bde33082974d3f3a945c8294863623a846d13ce73c15772dee35d51419e2dd3c6cbf7e516ffce672710a9cdff5ae556d165e7eb8246ba9591fa09909d798e9599f5502c25e4220beb290302da32d7dbb669eaa99f2dace78232e7377bd38671c5cb0ff6221b1114a4d1c453f3cd0a7dfcd23cf7980800f49900bdba47cc2d7dc11b64d12f6c1d16ffb1fe414dbdc35f074bf854978ad28771c831b3a24a809db88a0a557bfaf1a40cffac5660ca59babf43eaef58a8a3e3dff593e9790d27321a6b62a3714a4663bcce3ec9256ebbecdcc00f36ba92c2010718720b3a1b2735bcb53df5cd7c81018eed6ec6f3a45e24a8f9e774f174c311b800b9fb17cf65c294c353a295942b81f0ddf8bb92074d9a1181a550c4951cdd853c3829084bd711ef3715c28a5586276b6a4119be2d8d578353c6f047cc5ce2ad5753571568aaea5a486d34e238feeeb035b51cf977324d02437b3f08a216bd48c1da341ffd14e0dd1c8c6783849c32aceb8ffc56a92f69da390da32e5977ccec646e5ddad2185dfa7e8dcd908d15e7948fad11b64cc00255e69f3c95ba6c248755645b70979dd799afee6700e7221b81773e6622e936916f50d15a0d959644e397aa6149791143d73f948be17d8e9009e02a962f79ce5eb0e14666c82524f893f5255e97a6729af3a4c952847f2ab6942351aae97c3a7e0c38a9de0e48f9f75b2be85afed0562420c471422a6acc1a0a08e3be2e3d1b7c0e6aaf14379e5c62055de32d6893476b9b57d894fe40779e05b7d622cca359266ae117ad86603a3368be269df88c1d53bc1573ffd1e3df72ca501d5720db2866bcdbfa97e3b34a53806cf42e7aadca2f5d76b75cc04893f41320504d782cc7dece6ca4019888df839880849d63bc47c3ea4fdb21c74e64c2480798b46992cba76160f15e971962ebb802dc5e4e16fd1dc2cf71089f9f03c5f8c7b769687a6bdd83e8a2e07452bf903f1740a7f69b4d76a8766d9eea812f80ce0eb21bb3ebb6a84db36a79ec23144b1d521e5f0e3225fa25b7283d882d640951bee559dcac263c9ffc6bb74409343ccf4fd824580f240bd0c2195fda2da21d68e6baa79db9871fd1074670dbed4cb683d0f4d54c3a5909541cf429dea32d55e787c70971268fe2dfcf35a73739e03c08383c7a193aae560562fb35a95f068fef10fe34029b45b0850af980721bcc13842311429a1c71c9adbf5d75b38031cf2dbdccbe6e37380f14d394dc1301977c925b8294bf11fbd1a86d964bac00e8d6c7550042fccab1a9c3019c2ca6bad2eb6f7454bf160bcc283402bca7f5cce8bca224343c6686f1bed814197f7ab2abe266d9a903b9e0a6ab962e14955faa5d58ea4503d87f7cb55ce4d532b6ddb258cde085a11b98880ec3d4ee203bad8716e75f96dea11d8db46061dcde6b13c2a7cab7116f55f8cca7e6cf771b4bf9474b2f0c3a2179eb13898109c633178297be56f1c56b0d34371ceed7989f4c8541136971d9522fe74d7d797139a0ce7e6526515f5dacc291c824b2736f2c35f5d8a0b4efacb7b7ab17f5aa57eea5342d47af4fc95c777fe12ab6d975fc06d40fab31712fd9f867246fab65cd34f2de6213eaf2ce88f72ef8a302f6a3ad56300052f3999f881d1a7c445c9a2112cbbbdab16cd773d295f608c1ece84a4724ac9511a2904f4d9ef509b43acd4c6462f7e80552b20bf02e1e8e7175fca7dfd6ed373f0182b75dc8b9143c2e45b680fced21a8f3d265a869756cffab71ff8a7add800d17bbb400308d52efd71d1031d0d62bf2179e475f68dc9e03a1aa0b7b65b4802ecac875ef7c5a3d17ba4f260031444148569f630097e79c4a9d8976b25504b5e8ad82cd9cfad7476e7adfd756301e847f94ea376d7ee77c03c9011a1440c392ef6204e7a0d26accffa95159356e12a08a1d67fa703a09b0377224911b5546f973369eeb3dba","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
