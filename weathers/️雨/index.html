<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e9543e1517616d5b781f42698c894f9bd09ce33c9b4ed0d082886c7ece5105cb0feeef0240a1036dad19fd842983b6d97a02622d55d6bccd1df608f3fee710bdfe0d49e52edc968414317b630f1cc64fb0ce5b680669b2ac6c38e1b8d86f6516fa9aae702a7895901ab6fa5b2a98684c9a71217349a1453bcf0b0cd1b5eda856f9afb91d54f985feb0e79ca726c7040fcf0d5f5902fc489a8732501011623410704644bd67f9b195f64012955169b5642f4540c137734aaea205e9635f5ee58cc8ba7f0fa89b9edd9eeafea0e2084631f32778ac37692e921f30dc8636d83a1a98c01c8a68a8d64a6248d384aae22f451c5dbb09e6c5993d43c934986190771c5206dc4f3f079110688071865a9e59938d719fcce19d38dc1808c2509c70f6ea31a427c474bdb352481ac1a90fb42697f621fbe407b2cd9f7c593b57a39ad8199cbdaab4372bb6b704e0eb5a6c091d96d4c0cab04b3d25fc3f3325e2416a0dfa1eeee301f15ea1daa9557262f3a9de1b9ec9f2bd453b4bedb2ccc8621ae5b67578340809222e39f74192fc807e5ade8e83a2f3d35a4865424711affc611f84642729cd83cb69f76774970503b3c36bd08354ef03b33cae2bb555c067422b9926f4015a2025fb4543dc6603371da3a12704f0acca49d08549f13e8a14cf3ef1a99df001939fe2525662969411bb4e9b4a618f7f19b35f853349d89a0328202b7955011f3725ee038155e44811e8cdd6c8ec68f052ae77aedad34f2406924d080e3b2b713f91aeda55b27435fb8aabf2fc69c879bac84a05e418072cf9d70ee6d21e95930c65846746541e22807c66e40483123229b373aed90fa56336f2b7fd0b065d2dc28ae6d46a93cd0ac7a40ab4f4a22aa4841781df978f96884d6c565eaca3b5f61ef23e1ac3dff1de5e280530e917cc3f96c2f6e05fd1077486d10973af7f1a7eebcee2f2436feb9a3603b0c566676424f5eb89c2653f630ad6e2d4ab8ad07f2b7d0a028dbb12a0b0eac5b88ddca1af7f8a2e507fc1967d2ec793eae5003a084c1afc4e0532cc12199a2bbc62869a8b03622e72ec29fccb42436408239a888c05520dbd222afea7fc9fa1782423cfaad4123b1aad985f940cba0f709cf70255d635058e0bdc412d4a01f0a5ac80d7b930a443dc3a8afe29dfc27b0bf1e4ab9cb4d67d87e6fe195df30fdb939e0313a75c720ef0c7275c1d77ee5ff7f054632ce598ae2a40084e21f53cc697644954504f9b214b4ec9af61c16f5bebb84a849cff646ae96b875fd5520b45bbce965d7de8a39eddf3fa42ad79d9ff1c62d565b1638294d96e8629c00507c913a4fc717c63aafb2b23a398bdc2240b14540ec729b84bfabaa6f7063befe3cd15632863ee7c0614a72709892a04da6f6ec8124b400346b154db24d3bdb8d19cc715d2aa25a20154b7d4909ae524cfbc8d1d47e8892afc1b81c317a1f791dfc52bb145cc926010202155f5c540a2bee782c76e9e5efb3c09a53232c98a7e97dd97a2c51831ae0e9823ca5c17a40d957e43a4d6fc4cb4048b38a792b2b71349ea95834a2ba4f03fc07a4757383a8990eba03b5e969f71e359bbf006d0919018f3a448d361a319d709b5877bd81ee4ea00c70c99511ccad81c9a69a14751f70b24f3a317475afb64e1a9f87823bdc69a598714b606e6d806451a49667c31c1938a5060428f6ad29d553c2a19bbc09e23337fe50c4f8041be4bb397ba782ad3aa45aa4ec545a69a9f08c80ee2f7c068e6ba6c98021c988158719585fe2f22acfb992af697567166fb72adb6d9088cbc4eb65bf31ca7ba850b1c20ca973bc4857ea3cb4cafd579811e179ea909253107a559f1e04e5250b3df437ea6f7c0b46db5b0ba39398f6b8bf629fa41726566d71f045487773986b6102853a8bd554b30eef7757d678c161a24248d46ad47beba04ac21124725f0bc65cd49b1df33c6ffc08316b4806bc4b01d58691734981a55af1dcf8518701522860150b842a6b725c04b4a7380222120f4208a3704fe23406d9ed81213975444cff1847930622d715d5026846db0c985c201a84314ab495989b2860fd5aa57adf960c42132987be8130d01b46ae58101282b9cc258dd16e7992eb3b0487f9109cba82c975cdcff198abcd14b3492343654e6c70a841b1377547d856cfd951b27e4245a92b6f9ccaffe15e0db64da02df5eb6a30538e32cdd053757560911807a1c1712bad75a2aab4bfae51ca2f966bb4cb430e229e6db972f24a152498954b0a7ee01630670f156af770152591e5f46693a23d43b0537fd8ce5d8def33c53fcccb394f7c679b6168e175140b467ae98d654cfb665a8a3ba6974ffb52275413ea2f622ea7336c889550977940f3589ceba01ede01e8525e388b3cf0cc0e561cdb011db6d5c3cea017216594321d803e2fd896711a9165a4495787571fda7548d54d3f39a9f7f6fb470c0235bb264bcfc141ffc188165165a392bdd0e34472193c4ee330f983038bd41dbea36a83adf3953a909c24811bbb0bc0aa86284e7c8dbc991c64615bfdcae210638a98f77ca5214bececdee26fa24bbc0a99e76a3813615915a6619e783b60947222fd8788ed6208d9cd1675fb10feabf1f2853341e72254ca8b051e1d1db151343452c5884d8671cbf57328dd6bbe1b75c26ad31819d169f12e82fa36f21c0036aec78f190c4cf4e41a311326398f908e4c2a1a6fd48c01ddf94c120dabc111dbee438430910a282e3c69f6a8f73e018dd209192235c5b963fdb4d67ffff2a8c9ccd1eae6aa0850247115ddaef50e845021bbb71c4a52504e8f033ee20bd0d801d70b94957574b4cba4ad35abaae51441c6416a483c02af9443fa77a6db7964bfd50f753659c9d0c81a46b7dbe6522ff460c5c4fbbc2cfd3963e7dcf804e239485a6f272294e411cdda17a1524cdf33d46a7e2963400358636186d344a1a6114426d7dfacbaf0247bf789ec8adb91240cfb8eadfea2e359dc051e87fa3f486c0594b84bf6e2f8928253b95091ca90bc1cb9a6791103e2e4a7566b2952c53942eff55e523017b1985022a5a1dd88e7a1c165e7ed331fc0df2f90ef365e3490da0fad2dfda0d64ecd32f3c94b21e9c112cbe99b19369d819ee84689b115de9209193047f890556bd0238de16480e836a6382ad54766d5aa18c5cdb3b4a7c2f1175f9d76555a01fec543e193fa09eb9bc7889b2538d3dff53484689fb0ca495337005a696d15385773b6eeefd29ab0abad0d04fb66dda37372ed06540a638f21121863e09c5409ed40b8e3c068b117027b2815904ce06d4593e80f669e19a55fc5914550bbde46230175f56ae3cb66f0c041907b5de9b7c4529a48d8907e7edd0640b03fc3676f35199447fc985d80ff12e90e72733b3655acb8e85257d3fe85fb5ac7c12f22849f08e2cb3d3a135131e5b4f877af5765736c9e042d73595dfd3c888911a2b2decba705badcf08b9d7ec19f9048d6e6177448448dbc2cf6ff77fef81965e4acc99992652927f9ff097f3d518de08dfd822f4c2c0615bc177d86a7d55ea693a82f5f13c7cc268d1dbd0dbeb3c4382f51e2c8c67cc2996cda00eb710173e6daac548d1971db2c24e2d6c21afe5af52173d46463b6b034b7a6c8de1510a487f806fe31d6b9882ee4c5a5183927af012d3cf7695950f43ffa418e4e84b2057925cf5afbf646ddb83d64c724dc5824cc46b587c792a47bbf651f356cd4300dbeb56a24649f7a163076f9135dc4118413fe02553798d7775c47ecec13d1ce9f23c103227325ad6e8980890636fd0fe76feb401f8e79a2c9cb676b1ed378eb5abbdddc8638072e2f79553a0cc3cd5278960c1594e95693958322cd59b7cc307ef5ec3c3046fdbfa52f2b53d6146a0a928b17857fe3cafa5866b105f83af37f57889f82985d1c5726808a419441dbbba21aa90064ae1f71cd72ded1302a475dac38b1595d057b4bf030e1ef5e89b05dfacc77b301998f6ddf4153f3c40004a3ad4a5a57418a2d0cefee357f44ba013808fddfebb810165fb8e3969401feff8e2445ad4dd69572c44e2ade28484ccf480cf0da70b55d1660c433bbf4f19f07084a8255ab41ad872d5d198ffbc55491366369ee747801e6e80af968f0d4d59b25dea707321500b49437f663c4004fd60775fdda009d2c2c779c038dff86df6ec02145ad534e092d0adfd5a007845082b6a0a14c4d2ddbb582722b8cb5c7398d1c95a56159bd1811f82e852a4dcbc6d9ccc3640e3b8deb8d3d3ca55f6334731f2985250a501275db7bea8cfec2316d72f7c5e68efe5b435772a7e794285606cbb2b7b1d736eaf81700f4d12858d5ae9bd3bc4894bc5d86c7711507f29d8160501c01c75ebabc02947cf69d14d49005a396bb0e33e3883e2fc5c69b346707fdaa74d1dd6e9d71aff6c040ed58e7a3e2d15b4d9c518c45ac8e394043ec68227088c78d01ed740f318aeb32f619c6a6d3a0a9dc587477073159df0a900bf5263a1c7aa3dd7fa83971a6c94bc795497dbe1ed2e43ae695ecfad58339df583f4eb9fc4a2a66ec046bd52d67d499fc6f116eabdfc62e71d80eaf9834db16303f0e21b3b4668abd1e8e0ea78e17e439bd83179f7c6238314a4709a34f2d49553911bab7ffc72905ed9ef626e57d5c90b579e4b8507a2af02e6e1fe1d60f5d55c5ecfce44c7b47c1c8fb53d0509cb7beea0f96de22ad8fafa2fe0d7318743d25762d2c9929ddb68552b9d9ac61d9cf182256362700dd533e3ab36a7434b191ad7ff9363a8c13202531e25d886088ce7e7c3b444b5ed1461a8467650f36034610a503c0fb5e76dacc1b025bb03e6b12519be8312226aa56b28ac33071ea055aa0f86b108cd0057917a5fafab871b1d17759d5f0f70731f64858974912f64865a7a4a05296c48dd6d5655a3dc819d93d3ef34937536f7dcc4872121c62b7c6b8f8d0c9db634032533f6d05194915b9462ba2ce0aa87f033beda5253ab2210f0e85592284f604797a21ee9a0bfb51c9954c3456029107fad55df9f3c976ae18bcc1a3b1a69c9082089267c86e482af9d697135c5f562daabd79f12b6a193151bcef7e8d894ac1290005c92680e88118931ec2a8bfd39774b7f3e83f7803156958af5c5bc33c16087ce25d2eee7e77737e5f44bacb97b2a34642756c8fcca47b12c2602454e12e8b87cf0bdd2452e218891f41d82637f35d1afbb3a9ac650c6173851bd999bbdce38b3c952dbf7b1a26d79949f760450fc88757649124dd452f26910296f99c70e35c3fdb19f2156772b24c83814d76b7aef9f639a3c4de70b32269dabb095daa6f15fb2aedc122b08853eb7bdd738a82198848b852a8b159659b396b55b67c2f8ac8167e13e04b570ff1f4979ff7060ad294bec9a4d798f52d131186927c5d43949282259e297599c93ba4c0f0e40382d0f587638c3d58bdc28eef34d875b1d08407920f0dc7fb14ed266627b248898881bd21698d1bda237813618948c0047cbde42ef39a99166c2e9e94b62963ddf48fa627ebeea4d17d05c4b52f22fbd6adc7174210dd2c223601df237c67ddb7a84c4d1ee31b8adf85404639ee2b165d2eb9cdf4172fb18c6a493f5d869cbdda20e5e95e40a31027a555fd8686e1475c964508be245871130df862ca74a49db455aad97e4bc56d6dc4fa4e59bbff1af42c999a588941be59f9acd986ed2483d7d254272ba21bdabcaf404d48caa4a940dddbbfb8cc9633020e7b80e04bdc2d4c781bffcc43e3bfb8bd43cc401a956b7825f1485011054099abcb3a8953aeb8bfb149b9b5e01d923717e4db5900d0cb090e203d103b7c1e5556ca6c685f7934859a9ce90ee7f1d1e5fba5b23ea7364460dd3c21ba9c4c3e9087b25893c391038cde5777575235e35202ac07b699e550a8c4d82e6bf477f8675b6d589abbee350e6fd0a73fac50d5472528b808f7c8ff819fb4327dc706408ba2e204f06d4a9e083c0dd96fc52e1911a9ea3b102cd1e3b8d0ca466c8fe9ca61205fb43963f66031c01f39fb0b2d846d781e3aa30f55d1fca9940e7993ba35c8d5e6df8a33cca80ed7d17ae94f467120302adf5bf4ae0bb149b6bc696510827f385321186cc34537d4448d183fdbd9d0b977a3f15201aaab9e2bfc1aa3dff1ed690b547cc6e84459e114459b164d93ad3af959dd566e7eac41e0cd011bc71b90a6bca465e4713e917b67043bda47e451b19045bd7f692e11cc861c39fa1b1e7bf15d1fab35d46ae79290740619700308bc1aac538a51da2003366a77af324fa9305bee9b17a04e0f0b7922bdd487e644fe3173560ed3e928e66a46364fcba158798afb2bfbc9e7c962f8524d1c50dd56d6b303967f80f2e8cb18b535cb257215f6a3bf3d35fb24cb0fd7cd6b623f78c2d631b8dafe48e12501729e87ef5c23d1372cf5bd9398ec4bd0c4b38271b7c4c9a54a50f06c8ac715f5b08ece9fc5c2d445179e3474dd5e70660dc33f4389a6ac7ad2eb757292e2a6d870b92a36152dca7b77f209f953cebc8413133282246290012b7024ee98804482ca2515da627681bd897b3bb5a659768ff49c9af54b77c085fb28a0d175b82362f90a0612550db16f3474234fa70d77db3d031f7122ed90b57f9eac6e068e43644c9507f44d1a0d2a7b00a0356f54dd040b65826c2194098fe95b39bc2dc705835885e2721062c5e901d5d93eb5ef2a385659951f81938a0f2d6b4e31ab8c9a2ec55dcde95dff197768e312106d86611ffe512738c13f491ec8606b1ca26cf6ff9118f7b867b70163be5759cc50c6405ad9ecc92a9d0b82ae5b312ed3953717365a213210525e0c97f0bbaa822d8b866df66b089515cd6bc027b97405fe3922018f256052f4d1fe0a3a50c73fea42dfc3f4e61092d588f224d087a2b490b28fb6ba71699833ea196b12a9bbdfafadd609900d3640122757af09c4f17551e69c588c126b0e23393f1e42a6e2eafd83aa97f40a5d0ab81aa91d25181ae5e8eb674ed9fa6e3b8a59d618e98b2eb214608bc73f93a620ea81478a99d6f4edf64a24ef190c769448aaa82633a23af0e3bc3a3cf8717d03c5ca4dcaf72572c0f30e7c6c034ef33a1961ef1541492465b4b35987e38f809608106b2aff0cb09e52cae9d5aab26c1eb43cb26dce6951c22e34677c289f6fd3485ed2ca67e50c8e6577898cbb33645c7548163ede0f69c8a998eaad69443188a5d51365681ef5108acdb694bfdd6c725af143574e5af1f85d2c41f598f5107018a1e6e52783e6a7e7adc515c154ba3c249c97815b6585d91f9f42cc005e0e09c3f4dcb36fd457b437d53bf56834e010264aea1ce4e9245c00838c4c4b3cacb17f93bebef212a29f19d5f2f93c8c74b9384c5623383bb6464b3d64f22a730ad634bf4d9bc5d2b84a393ae95992b05cd10c9230b5b15566bec287c75f4395ba43553a95a32c7184eac78759308f6b49c6b815a155b0132926cd39813c61ec251e9cf77907aad952c4e97300b3e30f4ff66d776052e64677417527a79868647fe7271856cadc3f5cf67e479dc5ffb049f6386ab6834230409b5e52a9d7e203bcc6d5e957c36475457bd160995507b3085802ebc47c9323d50bbd691d9e9f224fbd6fc81cd65e103937faa6b6d5b48c0a3ce7b6bf4ff510163cba7df906497cd0d508598f8633fe55f866aa2ac01420a638876c753c6f965ff809e12f061b2fb3299584bcada47dad80e65be4bbfe3184a3494f30ed423600d1c4088b6922bb535bf6121245003a1aa71637e4bcd4e2cf5bee70246b8d1af9db193437c342ebfd260621ddbcb6692c9f7d86d2290a925dbbb9e5b65f0c413adb3d0791941c0dfcd1634244fe98be627713bc0dff8756f3db75be925693a7eab9eff4febb9b0d0ef52c50b19518a75011fd73e41b3127a43198b419a2d35869ad9c7096b637e2c7827c98d773aab15aacc5a8c7d8a65ce15e2edbebad215710acf46b3d2bbd8c65341f2da01bc96669a48dab6409cace317812e39630fce486404f9ab74518ee7e776665967069759a8296bca0d9ecd985a3e4147eafe14839d9cc3640212d0b1889cab73190bbfb358ef7e45b63cf0ed665c9ae8241531116efd1b19aad1104e61a1dbe24dbf13b4d7c284adb4ae7e05d16c7555455add9fa3abb234e08a67eaa3695232904f10a46ec32ca98d4ae821e15f338cdbfb8318f5290ae9e1a21b2f20a9be3385c001aedf15caa76d7e0014c02d8d386f149b1d23a77684b9f6bc49f2a0b35affdbec85fc228fe339b6458bc6f963c49e3bb0b9f79ec419b62247ef3795c5f8871dfa1a546a25063929087454cba61d3e6d34f08997ef93f7b8153dea7896aa193ba09111ef16aefc0e4908c288bb5c0b273faae627c930bc6b00ce85412ff87dae86a0076921ce8283ce24762e0cf994765fe07dba511502ac479bb16cf1456930eaf2eaf5c615214015cb99e93ee74f58685b19d76632db329bca985ce5c53ec0bc6cf00199b30e6529b78eb55970d4f8766e5459ab34ad941d999ef07d9b75a130e3f9c45f76ff3efa8fd63a965857752080ad190cd2927ece8f715f79c09596c69792e1fa8b5c3fbc29964604fa088e15494c9c3eda56911f348bdbd8cd346448403bf7821852449e2d92f89da3a2f45e722866f68e117d3d76e7ce175a3f471f70514ba7ea7de25c86f94b9cba68d9f859ca7460b859e27367dd992c9d35caa09135dd1966927c15d318071cabc0f0939c6c65f88ad3c104099a527c66671f4d69fdf578e81eb08eda34198736c009dd9b9dca58e42b6338a8aba7e2328c1c6acf7224627281baa3883e86125a7000c564d440650d65bf2ff133c8e667c0a29be99fd97c65f7b4a00867b2b428e3b11953548bb6c1800c87f6e3e350f198c3576381ceb9613a6cf104d070dc4572673419a4d24cf1b52a0ded0138df47c0405e3dab88f3c7073eeeb7d827c5e77bbeefd713282ae6908d8ee8fe64e17ab003d1178cc6f9dc8da4e6af79193713d278079cde98cff06d49cdcf612d1d0f1c4bb84391a9161ef2d1da811464b467474cd2ac81965325f2975e8f94ae464522f3291525b83ab479c5678626caed4fd9186adeb1915227b39fd835fcf3bd89f6dcc3e53bf8b216bfd090a4d5aeeb7b65a8cda9343c7c86a44724bc199fe250e3404fba8b27a31bc1dc53fc46a9d2108dbf5995fe60a9d50475eb765ddbb744d8024d59573ff907f712d28b3b8174df30dd6475c60810efc9c9746c99caa9898a3d56abd4921652b5084df383d0dd90bc23c48ecaad2e6a2b4565355484e4a5349a495165012aa26b87a64512a0c8a54422999f77d680e64a45e6ced690ba99519e18412730fa55b1ba6e8a3484e348e2db172ef16b7d75557b8af2484613eca8e72ed4a7a2522cf3f0eb85a0228a3b6973a98d96d44e97159335488568a75e2585b250a4681c1da5960bc119bd9fcb890615ea32037dbe59561c8b05f6a5a4bee5368155982d79e40e7b8229bfbc24dc96b430e091509a1e8fea0de5c5556e07cccf0fe30c928138e909ac758d51fd89be7b07b2a4ffb2ebb8831b931dfbb2a00a8f51ec88581c315e24e576eecf7deddeb8990ebb73ea7a8dbf904f63141f4205044e073a151fb2fcedbdf906f32225303ba206096f473a80dae0e532fbedf90a102e6c29388faee1dfe01dba1959b0d101ef9fdac69d15a56957fb4e297406a7aea7d1649b12a64dc7a20004d0bc5f8b359b4481222a847884647a089787fd3c88efdcfd59b71c9e5d24fea1da97a803c70d9b3516428f1a08a631a4c86fba2a99e58e3630e1f2df9215267563856a960a8c26969b2e821e01262978c9837f96eef46f61c41956c5f06ab124e2d2c013d58db654098faaf1ad9162aebc231df3c8ad0675adb2d2b1269934a3212b6d20a8be81620c138808bc88b04abb130fa3b0c0e2353b2dd3d9ad5cb5062ec74dc6d5d456e5760ccd4bf179da4b22d4e1ddcd8a18d5ce1707cd62df2e73f82db4c790cb661503ee7519afd98b99f724b53b4605dd3478815167149e22b6f820d9079a5b4e4f8263a60c86d8dbc4ad2d992b07ddde66efe08b0aad30696d6a9ef02442ca9b8af5dcc276fcaa0bbeba84238c30364e297efce68d2a8953f4f5b891c5757d742dbea40b20e83cab2eb9eee3a85f4a2a070ded9ec3290db8c9e685fd75fbf6d0920305d071affaded81c260daf74dbb57364d2599710e3985eb146dfe16e0f44f28bba4a331d986cbd1895294b5e3dbc284c5365c2fcffba66eba44cba2e95996238960cd3f1beb3d316f181f44437a3574060c6a4ccc642111a0c9994e4d3be0ede50ffbe0604d7054ad22e87e36e3c1bc0b53f3f9ed70f5b6da7664b96deb4b2efa9cbb10e8ae6168701ad08870c686c89ae03e0566ffe808686fb52dbe8fc72e26875733b30fe47fc46c388039cbc041f188a187ab8413451504d6b7fd4416a596adf11e328f2414787135b56cf7cc33c458ad7b69bfacfd766df44e6858caa187fef3a09cd31c4707a2f804191734c6619c56c5b39e8e0d167aa8fa7d92af65a0af8bbf30bafdeda70cd9ec689e57d7c333d00933c846a4d97b7dd8da422fd74698cc2f321d7bc8eb705f5e1f7f126eb9cebe2cb7be8f0d8b31414e7431c65542af5369e68b69fea0eddd90d3f3262b93d7aa75a62038c4fc0d6152fcb527bcee37c8248aa947b6b343be55a1d654990fefbb5e8b5bb24050d359a10953026151f2adf4a8d4942c3c53f18aa4fc9e984ea15229330196a9566d6eba8aaea6853855a3813538ffeab7892162a3f5494c5b1752d5656c783353e4ffcc4a9366fde672ee22680313267b61cefd0fe0762d78a9d318b7a87a4a53e77ae825bfb99a358833f107f5f430ece1462d8de643acef92ea1f00b1d3d6924695d94a25408f8750c01e29ee635e7a08b5f620293c1e30931c2bdfb76da07c51b535f8552f5f08b25aa6079b02b26aa4931ec628bec976f871888b1c76c4d417964b7aaccd8463278bfb10424c64d0fcbbd416c2ab650f50e01bb8de3e4e4b628b1af888874e361df0cc8aa4b886fcbb1bc056914f73fcc5ae262f179a04ea3a6ca01e2b61a8b9343a7cca26fdcefc264a303e1cd180d6bd7e9c941a6429dce4ba19b24574eaeeb85d180d89b51534a4c9767b62939abbd7fbe2166d99e20866aa64ec0e40c072aaa58ee96231c4ca72a2f6fa50845a12e3e4e5f8650afbf60b949cc9fc6095e6706ad5d6b676d26ad7ad66ccd1c8812812d32cceb0f6695bd68dfda05f7e085ac7a87919a117c3a0de904517d437a87209ef3e40843ad7e776547af680d7cacecc61c4d282543aa252959be89b48478e5f6f0d3db710c6fe3545982e219ee3b74f42be1761e60f6271f46bc3474ebd07f766f35b2d665fec2ee35fef9acc503d87d9bf828d07987839456292317ec7682f2c7ee646edbe0a6abd8833d43736f72a9d0980cf8116ae978634cb66e1a0ed454ec930d067701d346fd88a3d53bac62ed825de60768e33c00fad21dc8a0baa24d5389cdee14ff28446eb30a78b2715c23ee030638c03367a86b649b098beea7c8b63d1d191b3288a6a5652aaf36d27a6c830fd33809b103f969962caf2ecd25887045399fbfe2ea9aff6ee14136d5d2cf8b13dad76d360f17cc7b3fa95f40ece35dd19516d7888fd038386e576b2f8104ae2f93db7c4b104823ece064f9bc53745a1f7c1d32a9551ca6bb2b5db08cdc70551047fad81f15f496f8ea2272e0f6decce6dc01ab41abd6521bc471a4a38fa3a457719a3f282e35c9df26a435ce146ff4cbec89a6f20491ea6cbf27f8b8cd85f1a619afbbf7e3552783005290c2d3eb9d3b1074fdf3247a3cb0e92128876992bb0d1338a7f40fc8f0693f189b4a4d4a15eca09c5f50cd468a2ffc30cdf73461a8db2e7fde1f9b4462bd49fecb5a93e56e6c61649ae5b1ae365065f1895a3953aa453b700e4a5b2c6b74b8c09968ca075075a70e6313211ee3f0ca8b412f20e9d1ecaf8ba33e2a90d3d211e74d84de456083bacb3153f5267d115e7f99a663aa22b84f98f8ee78ca11414eafc795d6673d576eeae79ce560fedfbd04c08243111c0f64d7ee7e70bf456863313801bdf586d9d4c736ebe5006ec4b4bcf0edcdeffad7703c7ea67eb24c7484e336dddd4c6caa8e31051db7510f63f170998be434c8a9682348a00dc6f6aab4d1f1596f1bce1792e884f7f609298254baf8b09e453d61b85510116247a3e668bab771c216a16caa0d233a2faebeae14f7b5857a1556b47859949b37dd42b84cae9af1a3a74f800116d3d7dcf24ea0a23ec7f5683815930d68462609f0add140925ad08957881cd02636add919f697b48628fed5bd02869e76ddacbeef26f93ff65c4d7c97b501e748c727acde8722eefbcefbd07e36191d2b4f204fcbbbb0436fbbecf9ede36ef3ad199b6587a7c1a064573e0a4892b018dd4a03e66da4f7345db0ff6b122bce9ef13ba0bc30de8a3a0e19560eec1c84950af3f270c095b175e318c5b611ba982fb4789e2d7730506ba956a648cf834721f4f45a859857c95f3d106da0116501ac1c8cdae60ae4315cedd91806dede06fadcef2d05436946005c6b813157c640ffa1ea39b4ad8a61e591e025d62d58f77c4b999f5f1f52f4dac30afb3ce6a8b6e2bb415f72053ffc2d5ead987fd79263e728095544c20056e6c590a1f3d1f35952ce2d7bd73965e05b9145717229a1437af3e7c15ad1289a70068001aa758b0c90086d22c0a567a5f21ee140133dbc828037490f409a2542c74a8ea01251d8db982faf188534f0d243233523e1be3a3fe0f927c9822646314a10d5f95ae20b0f19bba8d823856b00d771f3246a5065ea02c92a29efa2bf5c89b0f6209416c727f0531d90e610bbc5c64394580a6c4097c02aa2a137b953e5e8ad459d0723c963d7417e107b4cf14394f2b109ff19994ff3c86b2f4770d9c097747b007a0eff95aba568efe0a36b3939af1d351f9d6f63625fe29fc59d20372344225e3cc1a32720a385efe9302de1d577f3dbd7b59de4176e7f9eca0a437247d31c05cfb2054e04f652554e93b93225bbe32293469b8ce8ef6e0ea626c245de0f8b6362782285009f3675557d99d44226e183de772c40c0f402cb4f85003667b73e6e17e7aaee90c37b0095259b92811effce3bc46bcc9d5c521bd0e8c45a5002a3b6e3e75f8f40700eb35da1149f674d7765aaf85238819b702f66a5966b4f810319676206c4be204b95f5eed79526d348d1531bfd12aecc482a47c6abcbb1bfa016814db7d9c5472f9e176c878161dc28e8c2d6869c5648b4544031f4b9d7f4a14a43edf8efb6487978242a8b3abf246f8a7726e7b17d8368821365fc2e70d8a266917fc7c2b883d6ad8e61b60cb0016db7460e84ed9bdc588a5939ce7716ab64c6b69bfb8c3bb7f440534114d01a789a61d0679e864843c7b67b312fede387a7bb6fd01f07de35615f03524c8cb41f50a60d6e69dd2d5e0de53b849dadfeb915bd76e81a368243723b5d52d52d10f0fe0765bc9acfb58b37bfbb240fd39c0eff8289e761b57dc0a8e9772ea65ade3faac2ebe9386d693900720d9623d089002ba2450a657a524f8af23bc9ddb2b4ffe1375ad1a535c058274ac6b79ed1182791a0c31f2ea8bda6bbd50f1dd9ac36a2631867c1be1444d4377e4db4bf688d1283d238c088c6f7c981c02c0dcb14a19017753b78e1356d1ae7b30e765f9d7fc5eb70592da8fba69c44f393a3a58c23c61d24a5828dc718d591d76e54191b703627ffbe195b6a67d897967a6f6e8d3497e401f1d5066561940d43bf8f93b7069cc271c9c644c922edd4e786b3a061edd56dd740a0fa8e261c64a4e5b3ef410b6250fa82227ce52fc960f4b20915fd301c5926a9115d46b7f5357cf1d23a35d23f22d71648c29db1d704eae5c8dbd7667715e0a89198695f6bc405affc8899176ceb0d9e3125f96d3464019da6c3897ef0b9038f5cca820f5f85d889f6ef03f54079d5ba9f57099df75f963bae3fb308f866bf4e7fb583d3ddb6fb692a8db2da5150278aefa72b8f53b4652423b6426fa0c9890d030754126ee422fb8a347ee729b0813e5a8854aaacf4f5724e321cde392a28b70ad6d49676c0963606ebca31185555ebc5784b7c6f9e0784856ec3b9d3e4b71386546c0de07e69d54860ccf9b6ca327636c20322d32e302270017c2910f7f4eb27b9a6f7668ca2c728582375a24b3e3c1a5d3f96f889014cef3b1a418615f5ab0c83a605f24e2767c43b00bdab43f662917dfd77055ee2a4ec98a866a0261942eb9123698878519120603c08a3d00cce1dcbe7fdfd373dc5ee122ae1a0345262f554f2dd3b6f62f8823d45192fbd71da49dc913c03dc2a7a039f4aa836e236a59b33d654ddc53846957b1124ea9fd0e838b818d009a65f33afb62c5ed3b979562c856926c374c74291c559ca7ba5ae04e0dbfa1efd2666e29cbd59dc38e98f66faae4cdf0776956851cf58bbabc5dba113f94cb2942e170f461ad9f5be45194814a4b434afe80f75a2ef2589f5b9333eca80cd0","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
