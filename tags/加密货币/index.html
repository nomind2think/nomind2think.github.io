<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68c828e3759117cb6d3ed1ddf4a8fc9ca7249ee151e545fa65515c294ae412c737a64d95ad91ac31a1d451dd3c3fd594098bfe7b7e75f8473df1bcc2eb9132b23437bce4e501e6296574c3097b9e121cfae6b5a5d4e7c5dea20b74dd40397724ea7e0eb9f7501365966124e156a3e8558312c07a0656dd80ae99fbe8aa0eae6b7f4e82a203d4bf86fc3221c05db249789ec74a0a366ec67b7c6f02ba84ff8b9a7138b7dc11c9a848c64b8aaaab7bb65051e16fe36eea716d23df0e4dbb46a4cd5948e03bc7290a8b0694ab608fef2957d6cae036e14c4e9135ea233f131c075c70f545c1174ff1970777e346dc76f38fdd3a5da22e86028cb20179c97c77f1c3d6300d668afa9edad5105cbf3fa049c7965a6a64a74f911c7e8980fd14b4e2f44ed1ad796e97016866f07a09036520e47fcf58800659cec93473243a8d7d039952f197a7588998610ef8f5dcb732d01f687f55f1736c189b7c5d229e255b73fd74445508b930993d4a61477756e5ef149271773d7c293c2e8de5282359f4bf1b8e262bd9a5fe86b84243fd9aa2aa5ab2f51acda61bc8877fecc9a8343685f1089bcb18d56c8cb68c5f549f71c339920643cbd01db9a04665aed988c6c26a9b9719741e405e23d719c7e2ae55e40434bb6ad1e25888f4feffc591c828918cc6475f9bdf7e88fc2d8e2ab2cc95d05bd36c06379d2b330ed4bf48456b90565d9f5c6850365b73cc73b0256d111639e97b88e2ba9a84254995798033335e508d05b2b219cf50c552f096953c1522f47ad18bdb1501853d9b54194bd294bd8bb6713dd41fd31fd9675d75453290ee68c7067f074a833dc5cc109d987966b31f10c16e88b0422b53e94154faa7d4311778bf1ac0eb8cf09db8ae82e80be49636d56c09434855a0bcbfe4b82e85b3e9960f98409d7280f765cd4215f4fe5e415be9d63c549158fc022a2a0e0b91be8a3458dcbe7353ec7deb1f5e1b6cbe7f4c9e4db7f971c6047295201a4bd385e5fc23912d2ca2eb0b578f2d78eda638bac4f1cde3d77c2873c4eb15a7989e821fbe5f32eb92a12e33c5aee3fc43d96b96a145b5a6b7a154e66576da629e0530113aa618aefd5ae0e48d0e3f3eae8934f7956af26c3633d784d03331a9a32d0e9a9035da64cc2787270b43532247a85ae4a4887aa32e24cb5ace73177f996022d8ba2831b2457f39996f81e37c156ba4fce4a19e0f97b415baf7ce89164787cd8c904d1c2756d0dc702d3ddb3cdc1b84534ef6b116ab632b06d7e6fa705bf8ec7d7d05fcbf8d0bdf2e9d79cf9c1ab32a9d6f856578c005aecd90ec35ec6cf79b5c8519723a0b88e410275b099bd16f32c11369bc882e5042024a2204be9ae5a36209c25e1a71c4aba66d2413d7ca135a3d3e068f70ca9fa53214983a939c3bddafa79381ddc650d6b3578d882f9907bf1b0c1704923da036268ca1e40b6da3be780cdd9e7f2888068089d6c087555617b6864ffa1444ad0cc1761694f4e08d74e855942f59b0bf3facce1f7c29cff49987f1a136a32abf9f169cdda2849c56f084fe7b1881ca5d60376585ee696f5868ea078e5837de4fc3a72ee1d3e8252fd9e8f02ac97ed9954d94043ade0959cc3ee3b14980eaf0f37f6ebe887c9c6b8d7ae8b3d8a0fa528ecabc91ea94abc9ddf7c1aa4552dc231cb6e72e21cd1cf9ed867435f89ace2e710e9789297aef1229765d4263cb8488ab19d7994023824882154f3ddb6efd3ebba53c6e5b5006edc5621e2e988f5a6eea0b5a5ab251f7e26b718f34ed17c98665ddee035d1ce8aa8be5d8972e9675a3facdb792449105312669b1b30510294bd0f62c985b5beaeefdd5e50d6c7bfde54ef65b9e6834019477dafb2872561ede49a6dd8f8e0612cd6e72007ecb96bf775118018b351c8e8d7ecf4ad9a34b90ac3777ab5f9f55f546af35cc0327aee6e13f5b6a552d18569e5c0e09aa88808609dacfd9e23905f362594f1ce4404edf2600537818fb180d1b4602b101269bdfc5c244c7f1ee218c6f4661281b0902865bf4b815665661f89503bc0efed31f3ec2c1625089e843e24346a96393b5fccc1044cf551d63116e3b2c3a30c0870d52f0fb3cdcf9a941214613e4e3306bfc74d494e9dfbb8343219c4fc1419e696f5b7baf9424b2119e0c468c43611fcbdb29dd60505f73019d1ae53be7d9abb8f56d5a6e106ab8f3e3f530a26e555f7f90f43a34dbcf4ccdb26491d82b0a28f222baee6a5da9b2773f70b4b10b97292bb6f518f96f05bc9d1093cce2e14fa816d1fe4daff303ae7c5de169b12b64a7c15405e03301e2a8a7594334558ad2a88077254960df0c3a36c7efd27dad30643019dcecd99074ed405adb55539b793112940407ef9859c8c4554d06c7e616dfc84286590ed780567d49ab3a24cb8acaa67a3b7136d12f5bb91be7681222d51bcf184d5a47368205792044b5dba84d5fe1cb2a5eb5942f4feea0d6e7fd5c666a3625368dffc3ea68e9a94acb3f172cdbc28693d1f18b66a0cbdb2fbb80dd6db42e3f55b25e59b85f8198a805db3b96a1aac2891be6dadd7f76080677cd1986aab3fc6658763d695b92d416457856dae19d24a91aeacdf128b1e008ec8c9abb793471d427951ff0d5f0cb0b2a636dc38e4198ba405ab206caab0c2e5b85a214b78df0d3629e0836b0845d250730750a0c5f7a2a4d12199ca0c826576b423f4f26f7b45ba0dcfaab736845156c8d75034a6225c18e06a30751e4420a23281adbb52282a4b9fcb445b2991c988de60b3e1ec8dba9f03f9b946a8159e8da0ba941581392edaa6703cd7a751fa9fa4dfe66032b34438d8869c1496044ef8668cf1262eacff388a6e85919bc16ea13324fb19e73d9b16f14f41b6366d4b16d314ee31f39279c677f97b201d4e6b17c3d3dea53f539cb46b9f8fb54185e60bd9f6b2bf306b0514d29a5a2bff7ef7dbd07d788d6fc19105c78dd3ee99bae4d53685a4693cb35c4a25e2a94a746ea16feeee90ded433c7c0ea658e0edfbdc8458af373a0ef4f970aaf0dd287156bffaf5f4908111bb3972cc62bf96661c560b29e689744f2ef7dded818aa1281729cc7a7abef862b9f80c702bb38a2e84b982b0737eeaf96181f25365b87f489a5a6be5a41c03ad8eba3ae15ec769b9f4019767394ac1ca4d917ee9d1fb607bfc4ece3fcd08a00db638edb25e8d0060c9e53c6fbc629537cacda5cdd1afbe6620194afbafe48f0c776598b6d8d86f6db9c270e2e8e61bf5c32a717e1fb85b129fdcf8503f641e711103cc877b60ce8c04336dd4c30b547965b30c7505d1808508fdf8f363d33349e804b38a716095950294da065eb551df55a8cfc8fb062e5cc3febffe013157cec6d1a64ece26737d53d37801e85847c02d3dd85e1a4fa5df066c8402b05b26bdcf888bf75f76e99ec8cff3369aeb4a15ba4417c40f08ecd6aeb7c3c50f4840b3fd807f72c7b999cfdb18007b683537cef5499f43e0f1d0f89fde50db5bb29098ed248e5b3e431a8b276fe743f775f9ceea3da615739141ad2f9b3f7f27a6c968cb13ae7a6abf87e7d92472fa7d98df95af23c0bd2a8175856fe069a6735481165d95efc3597bbc0cd9cb748af576497be04c7f68e8ea05e0bbe024fe6ead10ffebc9afa51bd74e59ac4dbdbd702f4ac9792e4f0d4074d8b56e4c52cb47f9841ae8e831596810ea1fa98ebfd35261503d794142248808fa2b91ff537a454eff74d0fe94a5858b6b4e3f0653aa39314e4dc4a07f4176eea2990ad008149c1752650bf0e63e5da995e98d636a1c21cb3020725e83d33baec3f5e5bdfbe2c802ce5a37934fd27f5a9972a5eda1dcdaaaf2941946676bee7501816486165da4611dea5dfb5bc63eccab1c4dd9f95e4e397e766a340cb78c669ceb15bf973a3f6ab90f8c1038812bdc0550a5486a3593bee0e921fe15b3a0339337133f0a2f46ac39a4d22f4bf6fb1c1b5fda2eda9f69e80065887ee4ee0dcb517edffe343430f2778dd0d23fd5223054ed0b69368bc06f7b880895648c15df7b88b3ab8a1caf2dbedc9d37b62ad2cd1b37ea6865992dcdc705866021570bf9b3c9dc49b3ef5cd3b102604b4560e0b0d21ccdb675fec9a931e3ac135572c71b5556cb8dadef3be24168adf68db686167901bf30ba605fe7b8368df3a8c449007906ab05308b6c47b09d931093677f636e4ebbbf84bda16bb3bee0758e811c492a194091c8c66168e2a08c35c4f93bafd3e9c888e2000d043300f6007667fba67aeca1f3b2b36022f5fdf4ebc073a7a42d9e62a402ed14ece7a072f04f6371b613f282baa565a7cd5803b2562174ac3f7f3746eaea5d2d130c97e5d35846ed5ef8effd088a8666a4d4177e43f174b027254f131fefd25e17834fca53d020c75ab733acd4ad747013459bd81d6d5d6495c29033d7280ebca0386ba8a37d6c718f19f7f857d5faf26b50bb78f071dc1a79c4a7fab7b18c8647b24c99696855ab89177aa7a9800e6bb4ebfc3cefbaf7472cd3c4d0f61b5e5d77774d66bdb18f47ad1be1aca6a5fefa7f86aab65475a21e3740964a66aae1e8609f9af42ffec1e14d3dd6f8b5e990094f09ed3b54fbd0e5d53e780913f329aa19738658c3b547b5c38e97925acbd3b0acd9fc2860ddbbd5f47a02aeebf0c60db0c2dce82225b895905a1c89d46ba15632b978e4e87452920111237cfd57f7d4ca98276369c45d784a78ed14fdffeaeffac415422d421426b30c6a1c1475989daac2fe28f650d30d2f7f5bfa01b931bcbc04e76d7b2c73c15919e66c42be40d96479ee061f2921deaf64d96f499087cecf4f041c50b6717119605b41f6ffa0a7f59d9074d14e5bd17d1aa0af13028e6d207072917b0981da63eafcbeec305312866de584873d0821ba9ae42d8693ca47a8be74898efcefeea5c665ff2b8fe54b5eebc8a0a0de230a8ab29c3ec1e32587f641822c66840a0b275d32297a0046ca7d7f9573a46cc4303f47ed3ccdc4c46e24f6f1107f48efda0d712b8fb4c926bd4f02f607b621141778f44e6a57e3271c55d434e1703ffe0838b6beed332cc28aba0a82dfa3045cd5b975a1769af3cdfd9b0d229c24e1790c7d6bbef5782c68ead9df19488d3e123c1b724d7f2474ca7c08eff51ac7a5aaa821b5497f1537a681e925b575eb0b153dfc3700de7d71eaaa6501bb7bf7f3cfc1b33683d1ceceae3d6f53ec0136a262b076f38d6769b5b244d7c5cc6cf9b1795388bb07e7c94865133b13da96c0eee5e16df343262d58deca4c0e2a7a558b6416212ac18c83bf1e1167cb608b6586bd93b1963c63e9722cae2ce2071a929966304c7ee10ce3c367ba316e77214910369d2794f81de0b039fa8522be5cc54346eaf92d801c7e6d2908c7b7e5ffb3606545e62f96d1bd5155d500409599d60657c6379f1a99c14a728345c9729a356eb6e0250044853efc6122bc05d6ce3f3ce2f650f361a59544b0cf86aa8fc5d3056a7c4b48ad002321664f5bdd6e2556aa00ef737e80ed7459ad9130e58796af6b6c312d3ee26c93e848b8362681c6a3c8c7f51627756675a5da48453f07c88ecb77dd8c724e88ad7099cbd14401f87c08c953cb19d95103a9d4ce6b2c4957aa2a3935f0b3d1650507ef873853e2c98de2fac4cc44bbab57f2981911ef81c377024b29b1826fde6324161986e5b74d6690d4054ce5b114120e05f77c6a4a919f1933adae6ae2ca39b385fcd598e50959f7edf857f71963d8c39f764313fab1c17d6b9027ad65c411ae98bc5d0ce3f30964fd1fbc41d48cbf509084601f8ef0eb0b9453a58975d9ed073a1357811bc2bfffb62e98d2313d0c9fb47126d7dc48a003a949ca17831d7536803d484fc2bea003894caf333e81c10c3a5d28957ed4408c25cc473d110d474b3e9ca4a70217e2a3f23810334fc7f7e583071344ced89042cc59cb2180cb31be098a7c387d7759840b4dc9e23d8d53391078ef0a997f872d497542a21226fcec888593f1f4e07337bfb1c43720ac68906edb0c8d2bd6484758ad5fa27e30d237f20e3831d3ab5638244d796210f8588390d36dde7b5aa2ac090822b77b8da3c7239333d70963b453859cdf3f985fab0d7b40e9c067219424aefe930e6325404c8b7313529a3e41dd223ab878a5ec71ae9586167a0e3fbaa7cb78ff715c9f1fbb811143499a005e1d0dfea07810e652666ddbf8c0e5f9f725f53dc1c434f390b9ef8234f555a80ed228fa0e1294e1c46623951d502f090b9f5fbfe9f583f4300c84c791657ef0611de9766cd155238a9061869dc257b7cea427d16214831b59ad8dd85e197d31251aec38e49a04a2a6d363ebfec90e58306b35ab75c11ed78fdc14d689357240d6ac1ebee7174fc58467f19a3ab4ada54ef8d9fc58f5da0bc94ef22ef56f1ddfcffca35e13595333a07e624dd6b13975dab52200dce65588b36871f2e71fe568b518e20ab91c82f40364011f2920b2859e0d46dc23fd4fdd28b3bd0d4ab41e32d67e791a026e8147eaac03ebcc460115850cd16782a6e71fa4957e98b87110af9a5f94cfcc68c18dd86e4590ce23a5ef8428a3a8b773fb0d5522877e514b4d5dbde345fe0246f8992338573d75bb792c1158223977ac826661f7bdbe3b8e849179c52dfd6774bdc4fe670ed92c3f0caa2f78cdd0a69588cf1a99ab44a1a0642d2acdb5145924c68134b939f13ca214d8243e3fca76e4b643acb1b878f889ac58b8817ba2faebd00c1236c0e15ff063ff7853801e54d5f1bfac32598ea6a5076d6a8493780aef35d23c3183663e574d8eefd7806419bbba53c69fdca53cebd630179e6fabbfd83e530d79c4ab70c4977b58f0ed503220d965c2ca128239adc786738ac496ac1e3dd8d8ae1c05f6e8deb8d4388a8db43da74a62d27e645eb0fcd7f6775d126ce2a200fd7bd2eb2ec5aca5ec7b76638609a18bd4824440f1089b5aae014944ae8f810d5c8f896352690532fcdf10c14c01a2d7c21f6ddf97085375db42578e24e0734960d878b592699569c3e16eedcedd2204caa8935e172b68a3ce31ae44e13d2aec27f64f38e3f1e37d7fbf6a5a8f69860dd654dca4684cd85694b40cd3cc90d9713935aa008c5455472ad6c4e708c6d0971896e881447598565a966a648d8b9fa1540eeb7c988b616f2a85fbd4eb7c04341d9865a7a64b81455d9f56ea67323355b7034c97caefa45730ff307c96988b8afaeff55624d18ed13648458ad7fe83f692f55e4867105b5dd1c8b2e651ff4d518800837961ea3ad4714b5108f1eacee8787e93fa150918c9b4a945911785b109bef59c0ac62b7c59879c87719dff7dafdec13720d3c362e9c735fd64a6ea8d4884be40f40871d2f106eaadd8ed41cace3cad45c2f0a130bc87c03f7d5107c4bc034f960bd22dda816e8f9b97d3ab24e8ea3667fb151c44611cb37d98020673f606724caeadb619ba47d9866a3e3490ef46fde92b573c74c0f985815525ea4c9126e7b21afcdebab022bee913b55a77485038cdf44d05734f1d46c5c9b2235279ddc02638e389ed8ece5b2dd82848f805a8c821acc124f01f64f38c698ea3eac09c3e15867e823ffaeffe1f78b6f20ba21eeb6c63acf132cd8f5770e6fb226eb76f88f905de51f64e8e01c791fa01da8f5690364017990f780a1286166e973bdfcbd4e9189b7ed75dfdcf4b8bdaa02d2d1caf85e7086089dbd78cf2a5aa2635ba311b6510ee61fbb6cbf0abd34c811b8a8a0fca1134df8ea3610c4920dc14027c97ef38a9ce3168721f3b149a8a44e88f4512f1214d213cf3cf869053dc55ba523284e4b0cf89cc99f68748d997f203a64ba77325c3cb2d43b81f49e142bb05868c246b0b3f8d734288d41c7d8e31eb7a0fce4ebcb99dd2b584ba6279de92fcc08c9a389499e96625cf75588f2d438b9b0c530c3e72413e5b8f15d35dd00772f0744b1f78239581849476095fba04663a3e9a29f222b6aa41cfa32b4a9752d697292bb1e39c7052a734fcfacaf0f4667b3e3fa595439708ac32744edcfe1ff288e258ee5614be1e328432cd4a63e71aa39aeba9eebc3184d392d93013d2fa8fe2a46d18b86197d72c9561a429c7a2034b24d517dacabaf7986d77ffdea27f282b8468db538c93df2c6659b8e7a57b9bec47b77ad68e2d6c22e2dd4d9a6e150c9f399393823310d80d0341b8b97b8bacfc8102dbcb53be2fd15726f802ef133da6007aa1b4bb15fe22b75d84c11b1674150828d8e9fdc98b02d0d5cfde556b3efc0dac053db672161aa6f421482f3f6ce31121accc488f5ce378225a45cdf24d168d2f7e09a4d9b5936550857c759f1d48b4bc221ffb966e3fcfb5e437294671296ea97f55ef7af570f0b1b8e18bfc9921c4c47ae571baad6f6dbf24005978d437a08b133ed79ebc45645b19bf9607e7a81ad368a1570ee0293cf72a12d375a5c2d14b77aece6bad7564ef28835ede8bf627e6ad85149849fac480c72a663b126cd1f990076a54e7837ac0d322f7422c8f8db2b24ef99af67187b6cb896cf6deb271bf33b51983f6bb2ca3ce2c9d15956822e62988bdc67f76613fddc6893489618d8bc48a60b252b868c46b1903ca7ee5f65553f9d30cc67ec084cba25e4cc4fdfd3444cc7b3e85543f9edadf13b5b786f9b82d22065fdeadb8cf2be74bfa575d115e1e6ae3656fb1bd7a2172ef3401b8ad4649419e81b564cc96cfb18e6bac69b399993d835cc7d575ecf83968a7313d2d34580c53c1ea248a0289e12b366fe09ba00d80c1a5de34786e055280996fdcab72b36d60d0776397192f89398e9708d8c2f949c30e5743157c033d7328f4d7ecb4e25ede68d45474d7042df83fc3e160d923137cdea5c4cdb284310d450a318358856913589a9b7f1d591c99df063d34e5683e0bf984b9926ac413edb02cea6f285af22fc11bdd0f04d87e78ef730b74ea084b1a10c8f878774771066004330b08d0d39333de3afe992967ea85001cb50dff5962cef20a4903b9a2699c7239c02288406cb8c0ecd2729f051e3e82ce0dd125cdb386292ed4af789207983bc5405088f5406451255989e21bbb85d60883082620acf4fa987ce6d99e8537ee7dcf28d149b96b958f810f487ee7b6903178c77dd56629608de41593830b4dbb7e1cf8e1fea6e83998fd37e97ca907c004859259ae74e5acf63ce6ef53f9fa8154b8417786865715398dd92ad0a15476707aad16279748e6f60fcbec95907d2b2fe825786357186857cdcb5b9c4813eda281e3735666ae8e518450a4ed5fbc95f8828b4c53d2d67fb56921912e4ed58d324d2284138a186e45202fdf324c8aa0707c1998ba78ca64206cd2ccf082a5e667d0e40fd7a7d75e246e7e0a0679fe8fec1a1f8766cee668d65f27bcb5cf37d628d9aa4bf97370f23c4630459fd8d508f62f9532a5955406cbce25ad9a1f431faa5cb3fa3203d2851ed8b4c5cdeab7db13d3d7220f1bf7f06fa0dac2099b01f1f9f74bbe08dfa1cb6065bd8f2a35bbbbd0ee6d0763d88147478c8fde6c316b81b4e2f0b70aecf03cd81b20535854b7e58fe4b645089da989501d522e5106e388bba24e1ac5be4b8aac61aefffbc8862b032268be2b67357ec73546fb69f18f764148c93a6396f26d9b218cdc816796501e44dbe3b5b260718ee7cdccaeb22f8f23e8ed5dea50d52a8ffa311aedb2da37da3e4ae2c1d637d978a97ade85127c5f7e097eb73536ed83576f6d4846066f76d439d83fcc50a69872beb4fddbac8a3618940c0ad9f908df4b59e64d3103871e3977b6dc2117f985d2296dd2a055cacb635819a369049a83e68a86874965dd164390b38a2e61436a2eef46e7db491d16bd36080674037e7287a25fe8c36b80abc53d2e42cdacbfa451db685cb7a5c25d74cb4273aad8ec7ae61cbeed91557f061fe4eecf65c60efcdc35954512a4d895bfe10cc5ef967f4b4478eb919b41e8a33e8bd102754dd7a11622aea303a6e18b7cc45ab758da51892779e96bb941a48b667e37efebe9ab9d47136c3bad1f7fa2492377b05ce0e9759d6995955ab73c2b1a4e9d1325af75db844e4a85244d9a72bd98bb620b37b3ebf84694da0e748cb4b1d3b580d49cb30c325bcb25f6b818f16bf6c30b4e62003cad2ab5c4a7b72cc2e9bb988e591bb43237f195e78e6b2416075291fd344db9fc3bccc381c85f984ff8ff7d4bfdf3018b1d103ee87db2303be0b2b1f37e78d2811b9ea75193dfcfbe7677d467c099cd04d5a3488d9ef67f8f7e56235431bfdd2812467f123b7934183b1dbf9fc889aec3ff7e3349e7454a6bb8cbbe3e3f8427051f38dd8fa1610c0c79bb5039f75f6404a75d8ce3ff78c861ddd3a9a4a1c01c6bc2d539cc0ed8432e61b30dd620f8bfff80511ebbcb2734509b4248c8a1e36bce64fb002f4472125072ff958849308f67a6f0d7f91939b770a30f2338bbd1ffa851afec2dba87804485bf7c196988b670253a2dc4d5b8021eb875d1f712f6d1042292fe0663345ce992b82a74d83c7944fec3b69cd18a743547d4827f9d1316b8c028f0f4acbaf2564c5ff49b48ca0d39c2f65cdee39081be29dd0c43f6f2d4de8e9edbbfabe67dfddd7a4ce6b58e5230acd035ba61326e89e876828aae367d9a69091ad2d9f89945a23cc69e6c9d3fc6d22435311b99e73f3fcb5dc593a7a9056df80e47baa500e183a5027aea644139d4d4d613bb97ae1fe5b59847e6e636aa7eb82845f219dba15b2b4ade88510a5f20d5335a830aaa6c15b95c2f38e4e63f47958fd4f9f844a93bc5b857e6e5bdb6066d782302bdebf7dd7362319183cf14dc5fa6cc76054b03b77924afcb7ae82ef26ebc4baa9072762d126cdfea2f941afecdba6097a6d1a61ef60a5de0118cddb90b61879a13df3436a94d08b13ab0da06fcc8db83a97e9872661e99662919e90f20afb4de468067fccc2557d500e1c1a79d851a76883b99c16aa4dc0d891e3bdd92b1a5aa6608883252ed9c8044a61593c0476a31eaeb839fbf5d47c7a0e0f08ebd317acc6c9ce6d7dc0a4b2c85b408930124caa51127074af07d5c77ac4f1d769a7a826cdd08fda7ec245557c64ab5ec96d4fa39ddae210a89230545ad37b563c28393741ee7aadc6722efc3d47883c86bf4abdc69cd9c0119038f84edc81b468f850c18bb35e6de804dd5529ee8691e3b7eee64d38f13ea8ca3c07ecb82aaff0c88bc8f49dcf4e756735ef329ed206a5599de596bad29b6669484511564673759caf292aacbf4a065dd1626d6aa6e7354afcb39d7fdb194b20c58fd2cdb3bbc0d440a5ef148aa479e02587cea64a41fb3cdf546d4801d333b9165d594284a207c948036e62cfdd7536630618fc12b71a72f1274d15266cd86f5b67be31a3281bfa9d9132cac9895119a222604aefbd89acace0fd2121c0c0445a66fe6a95dac43d00b0457c6fb88fe12fb007300e7e6f0b0dcf1746d8f785953f26a477eb8daac77b58e32f6311a8dd67dd54d3847fd9d31e10b0065739e8b24eb70cbf39e5c57c39a1075febb87c1162d54f5caf9ec92d9c3c5a32b6f92e2cc0aa226f712a5686ae01e855ca43a51d305014b272d085c67baeb7424fcb506d06cef770aed91e07385612f93b047866f8fe91ffdeed4e69418b55594bfea6707b80705979403058b1f50c468da7328a4fae3d2a09456654b7472207c06b0ec03ee5d72e3ddce88a29ea05219f1a1121b47419e48c8c37a20a8505d464f4317b48972d8867b0c2adb1bd42e4c7d6ee14c44f2ba1a2e39e246577eca2f75f5d843a8bd67b7303ff0dfc0034174c2fe57107c904880ab3594a682e60c775d2fbd0830faee8510752b3fdbc0832ee6390324e5b32436294f585ebe35854ff048f09e1f32ab0815d4c742c06728157eb37b25176530bc02fc035a5e29a75039531de6acba8d2aa8adac81d3149c03880d9820b4c8bd6e56563058be055674624556a0ff6abb088d2731e8c6659aa90112a78cc5fdf336ab79440e5172a1abdd140df98f4ddd9394a99289e5b0072cfb2d84e512c488337ca3dcd5e50fc2b6229e71b0d0d9e8be49813ecebd497d02a08ead32f12ad6467b6a83bbcf294e61a643e6a6adec3187c68687dbfe3850afb9e984abfacd456cda8cd12e338af80aa43213ff2d2b5ebbdab01d0fec69c9eff2d8a7244ab536f44191ab09f7a00803a206fdf7011f901f5a7ae7fe776c074baa8b10d7b315f01bcca284d1cc4e5ad6dd8c3357c90b00f3ddb6fc79337af744ec2f47167b1428cb059407d9999ede8bcb3f797f59cf82129df277ef8d7beff2a2b06ef066275696c37871aea46e5cc0b13b2c5840d642b588bc56451549b8b4f1b1142db00e75eb0fea39370ba6f1916d4d349f7009c400f0a6173661d8760fcce6cb7aa097fd3007567ea0aa","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
