<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08af5704c2736989eb43f5ca9f2c8c93ce6549823d38821b4b3a2771b7f45ddb2583570f713008e0ecc72aa9514780390e670cc9fa6f85a55b4d2cd4c74e17537f385454f77f5296b7bb93ebe1707b70297a306cbbf4fc27e9ce4f89017f23f7073b5c45d16c099f4931ae1cf9f19bd0206dd1383c8973445a2f91037e7f599604423a52181a408099eb2d196f1ad82ef650715b603dfe22a18c69f7fc3bbc5033756eb1e2303ec30c5a658d98d3b8a4f95b3dccb43a89266e730911111484f4f8d7a132df912c03af812d46905dcd4df5efc1af9f99d968cf29d60a94f8bfe5a232317d7c9595d38a5d635266556f4e6a2d163ca4871b468472852e1e16b6ab7628ceab297ef066f34da335f82dc08e80a0c6695bcb92e0d10bab621a366ffc8f55bc297970d4851d21e88b065847bc674eb8abacc074ab6da71e165249bed22556bee2e545f5808d66f97240b1fd87861db8e92770e71bcd82490a417e9bbaf246f1588c43ce43aa7259e4b45b02969886746b2528e9e675371096e86c1d661585518bcb096f0019bdea34f08fc6e708ea9672ad48898c7302e8a35ce7f5bd94071180777c805a3056bd616cdfe12eba589031c288f0bd79a0d6b30286ad22073eee6b04a1e166e64567cf0db229665e64409c40f2bbfc4c98035187e6038ab8060307e03e2bdb19433093f2043b807d040af2be950349481458b015780bd92676f40a89f7a6d5c2f1d82419acd29ce391c5fd78ea60ef0cc8d0986d89edcffc6ce69358304f3b9f3cc463b0fdce6080ce22d30dbcfb1bd0ea988fdfe335650cd5bc3cede0e74c32fd6593e67e69ac910ad8ad2b8a7d9fc5edae683749382b0284f10fbad9c7ed02425760d152ccbce3d2dcc1b6e7ba59e495147b699ecba4f30bdef68ade458e97070705a0261f5b1a75f3d0d3942bf4c5a0c00d3ebb8e421fe038b75dc024832fc2f170b701dc3d1ecd0ac63333fe47babeeb0b90ff9df78d6d4bc19177c8ec6b478d53fdddec75f4ddf4513951a7c2568344bc2bac9a6a96bf204480997c1b04fdd647f418b1f7f127a37f51c9fb69482c598130485d9ff237c4bf1055091142fb51b322cd99189637b58c627950c99ad8369036bfe7546bc163b5d040b985a809913597a5330966b0161e229f6bcc4e18ad7c8245e04c122995214336f2365915652913283b44c403497722e4eb9c42d46e2d5ef519f7bc934c739eca3e229283a9bd988d87b4b2ca38a292fb1ffaedd3ec06439cf9c5846965b6f06eb722a6aea83c8e68c3a58da65dbc2740d4b79fab3cbb95e41b83e167160c87317ade03ba1c721d6595f096a9204dfcecb7cf6e5527b49907f0b86e18179f20787bda53564a12f7cdd0b0e615a42989b3c36c0f1977b136033a829479bcc57d82e2fe498e138e5673a0d72201d5ac84daca223f9bd7625164ae52bb099ec77912e20d1c308c31555f3af8f0868ba2c5f5e99e925fa849237ce991de2956a1970edf66aa1027941cf3808c05988a50ef366a5653f0770c8ecbea940ab52b0726d31b99b093edc6edd6c5a00a1afdbb648f7dab1872e754b93ca459cfe40886b6775233fafb4b0c7fcfcda147d4ab90d1a22e6223fefcbee338830e5c1b5104b66d1964ddfaa0c617c8a6242957257d0066fcc7d66ba886c1ab26e136b08fa6de3de44656b23ab37da35957abff90affc371da26c8a5c4df3b5c1376deb4054d2c71b680e1c9df9b01cf4e23e80e2aaaf188ec5b960fc5a487d4e9fb00df545f76e510b1ae9e8bbad31fea8998e8461426c9794f886aac7bd9b9d772179e830bb9541bd22edcf36ff6f2b1bc253625917922e01fc0c18af43d0374308b324e6a628e859905c157cd17d975ddc493bfbcf1e1f5b767b1bae55419162875f8db9ef512e7ddb9ff21c3ebef1c08b4b37c1151538e43c584ab48c5162349287fe42c1e7dae2faed49d943c66655eb6cef271381caf2e4d364304e71a7e4cd53e69df822351ebf139cd4c3f0fdd4ec9416a78a4a1e247dad01fa5433e2cd8d708d6b3efcd0c005c74dd402dc45ba318c514132b48b09dcc7340fd3ff84ad6e19e6c58de37e0f9ec17566628d69b8ac88c37bc53695252bb417494c9dfe99c37ad6f7eefbfe57cf719fffc7330bddf1edb4e7a95d05e6da15f650510ec20e83bb5f1b93ed43de1559e70fec00f084f7310a3c6eb6f5e170245efc84840cb1009507aa9d0a913bfd5a962c7ed49f39d8a78e1bc85cd909f2d9788abd2726e8356173aa15fdd28dfcdeaf42cfe4dcd008775be15e9457f56225dd2cc03c10083c9c9696673bb4e2365ac5ce9e92fa1b62b9c7b2c5fde67e43aff5905a1e33777d9cbd4df8ae72081eb7546c881791f8da7b9db23853c6e8e2d14cd1dc2d62274ad417a700ac6b08e4a6665cac242dee0edd8a7ab6302ec6f370d07ec89f0c21a4c29829da352b9f02372fa6de742b61e5064c6a29a810204c9041224e73f1b07e50d04e299206b3607251a6a58ac892b3203c2e056226b35c99befc1bab91a914babcbbb1a5b4b01f41f6dcfa84c1c5d6d84470caa9146a025add4b702badc2bb7e488b404e139fd073f4aa57e5402298e4614338fb299aa55a681dc29bf00e35e7dc79046dfea730556773875c1629f21f5ac0ba2d73827edbd1e6325a89c645fde5d09bd911b21a9b0128e8b860ffbf4506d0203a9eed4b824c9702ce1e00bc22581371757c77ff187c2af79b9562c7d9b1920dd6b640bceb1557879fbf5c814733f841f1dc275286da096ae24e58624baf3b57c0d2d6904f7f2cca4e07cd46bc1a9885dae40f0cafb18d7fd1f822ac5c779266d65405888d644ce4d7b1deb5d4b56987b1ba2a378598d80ec238fbeeeeb665438b3468c09dc0f9e5a23beabd4732d986875b933e667b20693d70640b4fb82a34944451f260ad4ba3e10703fd4004e1fa13ab55bc274003ca3ca9885b82f2ca7ff7cb4fa515d80851b2300a54e60baca6323d866faef3542d8c7227f31df008e1f9df596e42e08c6de40326864fdbf728f8859705e687e9644b56da38c4b4bdaad5e0c26ea84a9d4e5a0d0f482939c87bdf33a3a19b83219c2cf0be88847b6bcfeed926a730a6ec7b9a30f0ecf270f837bf87d2144c6e83bc6e0ad0375b1112b28be357b673073cc23cc75cf14d3c654b2001bc441db5e7309f9fe9e1fba7eb6c19b426c41a4f2142eabf7486a71c31a68ae2be6b0f0764fc6415f2d8d01c67379057f979a85eff79464454046d143dc68e471be868c80636b6d0610ad02ceae6267bf91d39c9ec0acc8fc22c807a79aa61f63b09f72bc807ffd7bc12db6236543085dbcf99a9c14f365fd939aafe5c5cdf9598f28cf3d3ff245b21207df9fbe6a451a0ebfaaa015dd4d28c4ceb3719785ed6199423d17ed94aeefa1d512fd39f437eb83489a4e2549ed317a7c1b3f6a268ff94c2be0050b9c937adca8fe164cfd1a8100213affd3da8c85874b5330f2a8ca32479401e6067622aac26ff6d39feb95b09f020f10f9becdd8a205fe0202d3977ad8894ae390db43a13a0830aa8d3c375d1f1a877a8d1afb4e2a401449a669a83743d6cc175c2a7f49041a76fd9027bde404fb9570e2a9b5232f1b89a7e3af4ee581cd584a7a6c175683944c78753d50d979def698b9c1658a48d1131997a26e5f0ad0d7c1b50603b8ad128f27b8bf09876c41f6a939c3c17192ff6830e8e1c9a328d3fb0a4888f59228388dfe899d922c0b1bde48ed4cb0757ac70f129ff4087d18c2a87847348dbecdfcb190b13afde328437a8e6ee8e78fab08dbf62b381083f4a2179c3d891c3711da37c9685bf2e92351c62088099fc0e08dcf3092ebe59cfa1684d41d946af9c21a605bee4a3fda0a272cf2a3618570bb5b7534038c9d19c37577d2482a20cae367d1c4c68f1bbe15cce3200f162dbef2e5a5fb0f514c6a08bf99ac408592ec052365f00a48bd5bd0f3a3f5c9000ef4dcc8971859ba62ab0eb094b29f2c250368213a5b2bfaf6d3ed0a17890a6ff5f3376681a6d56926569021b6f750df6313c372e86559bad33b8b67f24cab630f46324fc49f249740072dab26fc4484ca745993db78aad9baeb87101590e40db253608f4bd86d449304f4ee98c6388439c057af45ff8a5ee965ff756ecbf082f135dd6023998c12c77aa8d557ddab2ba0418401b19b522a3cea0e0669c2fca7ed64666769af27c12763225c7442f17973475075c0f4530b03e3b509cd31ab0dd6708141826fd6b26fe8d2553fea65987d4b41f861fa3742c6e27fce0f77c68191eb67358dff6f17929af26028b3e788d6451d7a16d5bd55935c88fd78805767b095d28f7f0175705b43c92a7eb657894cfa64e5d1d0ecee4c500e64f7b78f9678ea76564116aa627ac1ed4a2a271ebcbffff1585a512b665070a4f371e2ee9051016fbe390fac3ce34ed5992625e32fba8dad9a28e105f48d47b710b9ef96e9528e928b3fd46990863730d5311a1649aa3753919cf97c9b9734b8883b833d227a36cc64655f60b7f948a9279d1608c8d7935f06b8c51da7dbe6e8c414a1f5f9e68dc42f83a736bfda0a4a06f6f7f987f1e9c4914d152a5bcd33b20134798d09dd094c1c12cf57c5a2ad457d67ae7b5d0ca9499e925a2957384a04d9b9dc854fcbac4b064e621a410bfe28ca3ffd3262781ca2ea0858cfb03c6a6c494c763797fec555f8646e7d16d86f4134a475b898686353f07a7e88ff7d28d2fd3fc2256477cc04e09cc0a0238f4aa22f8e1fcdfe934a671d0da1afdbf40bf07296ada32d566981dcda364f6e018fadff3db78a8b7ef576d8783c1f960a0a60737693cae15b79820d31801c55c66028a30bc5ee6d7678acf0cdad67d5d09d2228936ca870f1a9519af00c5b426b59fe21b4b99023bca85f513c9a27fcd78cee1dd3a356792be90dbcae49d0173d31971abc4b41285d0f2e4e904abba9cba6b49d469c78df676ae4929767f36494630061a79bb4400b243f822fdf6e0e082d316633edfdf78a6407372cd3c62a262481b8236045f738afa3ccbfd3791ed0d60e90fba8b2d541e0e550ed690dae3c7d899c10466fee595dae0b5194555f2ca92e1daa2e2ce4641cda30be67d928ef029b2f0c95c54789bdf479fe3f5ee368037cf09ce691318e2bb090139baa8416f8540e05d0c1c4aa3c0f494f73047ebe176c3e1453460b44f87221ab94a57b822a2d04ee86269ff53f76c33f61e533651b2773140f4069b3fbd5cd06529c15584acd4d2510d3061170ef1b8c5fd347e373c0030fedac7c82b627e4121a095e4ec0242f9a99cc83585f8a3645025c3ad055e5954ca803ddad24f75376e332e21a4630b70e4a1d53558de9b9c8a903f7e95bf08650db0dfb14f9d771f2d08bbe49775b2f8e4804061cb2df750e12cda5277fa340255543ee1aecd634a6817f1ba13bc3b829f9267bea83ed0c35f54d759b13dc45c4e4a59a060944c7c15b933c78235935f7e3b822be9924955c35284059da7327a57fdf0e484b6a2ae9a5a9ecfa8d33baa7379275883b260fcd29b7d6815aec2b938767e20b92db2b9f8e0e96f797571377db87d5718b100f6fd054f6f497cba9fb2fbc8163e411272b96eedb99687e7be09070ba8f5a82084011c3d21f89b36be70f582360fadba749ae6f800b960ac5e00aec6255c43feb87427a04d1c2d9249c6bdea3365454cfca31b42480ddaba430c92e17117894e8d1e4590dead1a43169bc45ef792d3d6850c8e2fc51ddec3a1bd28baae2025acac4e6697bc1b8c00ffc279f8acc2ecfa9e7ef76d4c6ef0d4ecef09e5d0ace82abf15435216e8d76eea4f84459c2244f6af15af96bd5568cd5977bf945602a2b1e48e446eaef0f7c49e59edc576c213eae672dbc0bb07c9987318980d1def75d44348b44cad8e56d8c818be7add1d27e1af41829e4a7ec3772c6a69110c476b63f3788470c4a0067c3369faa4c76c8ea2c73abb144a7f310220f0de1cf1ff5d315e7e24a0f6009df7462f38042a08c4f51461a495a7e698a827aa448f78b855ad43ddb45490b872ab832202809230987360eb496efbfee848a448b2890d5a66d1b2fcb658423830051df1bd948fdf12b211e18ea8c5dcefc40fb1b7f2bc1b68b60f86c1e6896837e5480425e295c8752752c03197f00e39d9ede6b2e32750b894689e0105824fd8ca4407a5ff57551908f592a9786b09e9c1315b79833007c2cb515dc136fb404bf11b90c42edfe21d49bd91816f31e9c4606f14807e3d6d459d713a59a38735822d4005cac51feddea0b9e6e4a2f17497e66991ae0c1ce87dc578f3d184d44dbb65b8c1cdff2127e7fdc75af19e48f1a9b9af457ab55bbff0c319bf080c1f18a5875152ca9f84237cf0572407d5e8cd4cde0f6b6c50fc2bcf7b78f177f85ebe40a04d2f1e92bfccc772450f58637489a76de76214a8a0b26afdb85ecbe2f2a6bcc8a184340b1e7f949a22ad44cb8f882e10311854c4818c33a376fda27a5af514803cf6c41c2fd209070276a36a847f418cb40ce83d5aa9776d9b7a84b59882b5e051d396a04da234ea8958b350c9af61409312b28dc9278a4c5417e39bc479bfe17aa35b9d467c14a2e908bcc2a432d4f379d408f6ff1c36fa80c89b68bd2563369fc4d41e0ac52daa8468d73e3c00753a1ebe81db144275aae0ee654ee2ff61e4f9419cc9729a66ebb632b65d11fadaba19ed018a27a4e3d25f5d3e318d14c8a2a71eecedb742cd81c026c6eef6d599f5000458f3325ba00cb7e3a9a4a8122b47c2800a2aa612034db7e129d3460fe91a703542095262663bdb9592742b7766aeceb1c9bf77b39ef0247dd20cdcbf97043ae7c3f0923259b9576d8bbcb8dd29d4976b95dee47ae61f0f97965b2fa0d4087aae027010c8268e80da57d2d9f78cbc01c8182a5bc7db662b5f500e79b4fd5122a584dc501613c44b7f598d8f3aa6668532353f96b890191a8a76af5e1496d901b7ede66d2483c89f8f28dd9a80913c10e9653d049b9c469d01799612fbdf56536d70c4690bf9117ac21310d56de462f57fa972b0b14b29dd40dcf74f6df1f8fb427f04edc39be5c0cba1086d8604b95c08dd1edc136bdfe087ad86aeb7910f2658674ddbfad5c937722b281ec15020671c12898d952695925909f590f2bb9cd7dd10d436f2b50f9ee611435cf6a7de290c876f44ea22c61fe5682c8885ab28df157532ae44a385a656a06ef9fd4c663acab617faa9e14fbac2897857d2e701765e0a258a02b65705b63cd9e024ab2afa9e05ff3c3787750b52b448f61d2e3ebdb0f35ed26df60f6dd961a2fc5d87f3d3eafee905e5ea587c4f43f91242ca48468327186e1ce531478a8b3d67a5804dfbcd4d7952e8c1b5de14e25db997e1ec10d35b96e5657dae6e1da3b54c8e84690a21ca3420ae7c743cab933a03e0e611ec313e895541cd0d8034e5354d5c649399db0235c260aa5baffb9b0b44f8008c8c58a0a500e730e9afb11cad184d654e242f861fec15492e887194f6c02f26a6e53fdeeebbca02ad140bbf1e1e3b1b662b4506e8663413f18596b36c8ca4c596604fca8bf767a370e927337e65d0e6cb098ed08b8b992417ec75c725bffa78478187134a884f7b0836e03d7cbb2261d427bb9dda569f42e0743b573467bcc54c88f0485893989151907853a89a0343b2bd566626fa322db3e205358140751b9bd5340f85fcba5738ccf47735ce9cb1f5b157dddfac9cbdafd7ced5bd88687731af2482002773063ce8baefe01d8d1c2487fc07b677f04e724ee299792bde2d6c27c483cbf33759b0a1002fb70c85e0f8ab6d0fc661251dbe6f17ffa657818ab0af5576ddfff24fb163faefa4a612640eacf52c0d885b970aaa22e0df666c3f5b1049ceb44b3cdee9447cd97379364de64e504bc94f47857a362605ec46236001e43e82b7657d6483922fd9f96265efb20e60bd0e7b738f393fec19741c9a2d6cbd3105459d841e83b9374cf447294567e95f3e9fd432ec9a3654ceb877bae0c2b408d0133902aa70fd45db49fb7acf9dd4175938cf1a1afe9ca7a9bc0001e950a98c4ae7bfef879bebab7fb54acac20f0367b68973b89e1fff16bd8f478e416f863ec9f292e0319ba939ec73a98bbb7728ad674a9d9a4786dc898e0f7ea46cb669a17c9993d5c4b62f8865c266351d7248f928d04d5b8a272e3d52f4593b2cd8b11de2dcf35e4292d4b38939b738f5461475cf17334e4b06f0bbc00c48927a97331d2cd2b249c876ee04a04065fa8ff11e9adb72e71badc432bc19388c2c4dc26a91ebdbe6034b8d09ac4f78b341c96437679671b5913f212d88151e1b8ef5ad882125da82901c8666ff50efa9a01c457148d2a0caf149dfbe31639de4c6114aa34ddbe48a965d148633b59380d9b40189c553644f1e828f98e822de08ed9484f164c9794c15bae70460fc580aec136f66fbdb9981dceab202b70fc79f0f1cb9c5737fae5d81d9c14fb59779d5313e9f5c1d9ad4ed30ce0072bfb03393ac7328a2c061c268557ec1bda72746e94b6367d2f6d623ebe255a5cc620f9910100bf28f22b284bd4190e5c82e5fba44bdbf3dc5b6cd6fa44aad00c725b0a025935a4b12c4ffad1098edca180434db866700c1b70fc15f20d3848e315a5b7a1a20e33bf28cc90901c49e7b9e29c12bd90bf01bceb71497d8fb442e8a9cf9137ce860d1c95956921da1c13b9f608f058a2f92fce64ce62a109952994e5cf205526d2b1769e3f3d1d50550dd0cf5f3f2575e3f884dcd973bf965f31be0726a144a6d2c43a8954c23cb3c3f953f3ae916f12ef74257abe28a33e54547675d91221c0ac9ae9d3e7e37e1661b867d14c0e40a7010b2aa67942854e66aadfa3349f449ce6471c90d6da242e1d1ce154af0e6d6b6ad51c8a21689718bec6561fd650ccf069c4c3f13933e68a3a51c1836795fa76f741cba6a6ea3912c0c36ec7c86559f7c93a4bc321e6b576a586d9d83b06b99ee5ba94b75fdc220b0cdb92e0d030e508b575f1d96970cd967b030aa9cdf7d25d20fdcb17e4fae7085f0dfbfe9afaedcabda3ba403eb54fe2d5fb6cf8aae891570444f2efcffec635696337e95ace08f866d22f6fd18f9f284231f26bd1d263bdb3b2c7075eb04851c98ef25c3b426f5a29f384fe66be7e6841e725fd293de2a0f305136805941cb3292d0237f6b7f4c20f86fe28ef5e28bb0889a26677ed12ea79d0b2d2cda692d02e361cca377ce5dda65327618aa2d1078811a4a0596d6976c22326fabdbf95a1171c4a40dfbf828767967cc67ffe069f39a0442eef257c70aeef039d4ec628e807ae3b3629892d9342a85a93fd60421923bfebdab53ffffb561aee0dc233f50f825382679b24c35eaaac0bd3c26567453a73d34a543c34332a1aacd3aaa13a0e6ffb73510c0963127e73867cd9f4d84beda92ba0ec4425aa136f96272a860ea75c28f5f55a96065d73d73e19e6ec6c2296ad6f3b887ef3142c4fa1b6fd9ec5c9096f7ddf2470808e1daab99bd787f6280f183303988b942d4c6c2d09aa0ccdc0fc06b8bcbeed9c763629927145066c3b7f90565ced4ab5be4b85766aca85e85b2a7bd3d9fa073c9dbd733704d67d81270522b7f997bd022f936f6b78410a0e0545c22ab6c24735600e459238514b7231ac514f715a6dab307182e647f638b80f5400de647f585ef695b0a9d9591d4807747a49eef7f7b5eacd740577a251edef9b31afc26d65dde33b531b2b08b9345c0dcf98766a8410f2c8a0c9f55481819717db42f203eddf4dbf4b2108a9260cc751c27f1396c34aeb463f29ea7309d1b3786c0155579b37dcc06e90cfddfc1c3984eafacd5c46aeab5159ff2b3ed3b4ca97eed8505ae1761bbc0587cee69d2466894fca3c1a8edd5f643eaa5d29fc085ef46ec50e5b31e5b84a204ca7dbc0daa1de8024b6499834ac06484dc9e60fa307864405dccec7da4db3608f1f091599e380539c2eb9bba8879c3eae65b43d8493b6cb13432d9cb993d79d3b4ffd5aa4e6390de87dbae11bcec992707b631a35875a6195106a488bbd658f6329f6a24f46ab18733390180ad085dec63e033ea3c8cc378fadddea4eb7312a38ad30507ff8fc607b6af01fa4e88bc7fcd29f74b83f6bafdddd8e5c72c1b12352086e1bdac65e99656d1531b07df0bcb277408db2b7aaa963dfb0fd4a55f623d2638775233ebda1d4ff6fbdc9aedb87fed643086b48272def09d62b6accdeb753f78156f7cea249ef468863bd140e1ab3b583200146d9a8f35a9eb3fc6a8f2820605c5998b02e1d26824b357dd2056898743d80f70bf76ce953317bd51b141d36aa321aca09d23382f7966821526110df5bc8cc78aaed03186fc07a25f02e1b38a5e2f8f346861f72bfed4e238362cb0e9213a10677d4f02ddc6be04c4fabc0bcb0f9d9a69603440702149e4a378c9f9f8a5ecb80cf04ef253c8e9e148e4a3dd82c8c766e278f996949a910c7154c488f69f266378a3cff7552a2f814b4472360f3fb878f5153e08c49dafaefb1b2b8abb80ac066141a6e48148c10994643ea1795302dd93bf03f0844dfac80da458de45bdc8210ca975cfb0e11d7384835cbd828d9b4cf9b657e26e9d5bd765efe06eadcf3cc72d106c1e6d4e99cc85b39babc42876f9d9c975a419485c88e17241df5f976f9590b57146564bf6b54d0ff7cf5238d65dc67467cf45faee12364c3b4a49e992d1cea93a408b54a1686e87c0e4e3a419c0fb178a1afd9926e610fed16817df96b22beccbcafa45ab55b14e849ffc0152b125eee61d55e37e574cdb74718e93fe302b9f56113f042c75c58497eec51cd0f187491bd6394d671c5b44fe2f92b9b3c57ab03eb265561b16e398afad076976779ac2210dddb5aa8f95b558bc7d435cc7411eace6d028ceb21ba35502eb3daaab646d4f3cf6923cf981604ca012457c8c919ea50b8cdc6872285d2f0e2236f333b3d1598b76f8f2df18c60c9bd33e7f165fa406b610ab534ddbf45f5ecf1dae5d4a3c0c9bd72ca42c780a1e8139de42a15c5a5cd67d65e00a36b6e80d65eb5c1eaa87081d1f22d2112efd926036ec85f4c8c450588e0cfb841c0f503ed4670377243fa5f782f43a1380bda69e165748e73fcaba8b417d541884a5e5e6c53f61f8777fd776c7fec7b226be670e3450777ec6af0b03284d712558ace11ddfda10985c26e32151f0bf189db9390186dbe7fa9c50ded57cc39305fd761630e9ebda5066a070054fa8eecef64af7c36c8279ff9710977f2ffe92a5eabfee4b2cfc0cfd50623045cc37baf1d7fa192fce9e62b7d72b292f5f420172e3a6aa6e7968f2f31b55efca224006dd7bc64859dce8f285e58c4c621c5d95742c6dc84aa511068b713d751c8756a4624c0d71ab0ace31ab4ef9290b84174b77c1d732e404028ce5edc8ac245943c63d808c6c30c122aa71a10a8625b8d49f71b403c076887c5d7e86e179d8e9dc72e2629dd742ae63c8b9229ea6d187fa8c874afd9c2c2f4f12e7e806f7db80ec60f7ad4f948688468c63385e730031bf63294937ca1a9aeab6c710f45c88bbe6f8b29b96552895c519f0be46c3801528e73f5585b2c4a2cf57223369964a1cede6819e186c5f91a9f03f627ad03e447b3594124d5b21900f2ae9691855a7279c8722c2f2ba32c58adad00484eaf19a9d74132201bbc1bcfa1ce82ee47791134c206ac7bd3a0b3e349d3f9d5eb6ba9523cd68b295c7f6a9bc6aa236d766","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
