<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48caf1d27e34003b93e6c6235d7c407c2b9a7d7451ed704076d4481d83abde4422de609324f60105ad72c57615bd3113c423c3554ea49c6d780e16c0ef90743834f863678f9c9a2bd278aa530c8d7ea853b67de0b6144c444e2682047d8ed8c0b21cf8699d2f4522d8f0afcdd253bddf1e05a254559789cef27a9ef1286038bd0c5cd7ffcac39bd74279ef107f17ccae81792673c30e9b378b89e5bd9c7ea9d097dc962a226757f213f56fc62c9843a48c9c4fcece8f4d87ad4016c1bec03d881b0ec14e23eb50a5485ebbdeff526261d354c0d0037b5ae95cf2ebff8d194c95936ead048e85498a53714548823e6712eadae555e4fe384878e149d5aad8c8dfbbe45213d20d6cebc62254f541c16fb1833490336efa9d250594bb08678b5a67d3037aa193cb881b11a04dc51b235b9ae778e589037d8fe2776ead0443e6a31f4bc49c16697af11ac5f8d3c38951538d6ede3ecb8a60d0f227dd9391c3ad4675bd212e47e1bebe19ae3abd04086f623a91d0c8de4156ae5373ff4feeba6e1505cfb7c5475f5e261f7c2cd5116f49f77068026d9bf68d1dd12f5a86297fa8c93ef173354adfec4169fbbe360cc2c1408bc23281f24222e53070195c70c96d5e427a907bae9da31bbe563f06b17043b67be890d0af8c36166507afd1c9f201fc51c5d71f00f4286b539ddf93b6e26db0c9970c8818d653c46a6bb98441cb2d004a3f4c0d1b376187f7e6993ca223f0f961475cef2aa996c1a89ef6a287fda2024194b52382ac09172589e48058ecbb36172d32d0fb62f772bcfc58a8bc3fb7eec75e594c229256b0a5d21219776c285d13c25042d246c429d87c005345068b84410cb49536aead7a28055a7e63c09a43e2ab86fb3d0d1ebdd0ff7a0d764b265e31ebc1afef97557a721ca1c1468a031945f4c28751f615ef279909e45b915eab220e2ba1837b412eb428dd0f41f6fc1a4a3cd7e8a7d6e1dd9fbfb04380a877f462081c347363415486f8aef3e07fb7e67d9a8bd5fc5a86a83a17a8bbca39587f3d9ce46b09a5f189338073a30b06cbd6adeb14b297e850d91923e48393ce90ec56b9eacf33aa26da84cd82f4dda8e3aafc5a20950db840d7a8afb5ae516aee64e0a08def3f81748414a4a02e92c947c53ee491ba2fb03b5e4f60b654f9ba208ba76eeb6946621560a41252070619f003215fdfc88368a0b3b02651da1fec6988b295a4aa278b60fba422d9c57c448ee0d6f0bc5555c94b52633423411f7d8f4ebcdb730995b05ce60ff4e3afe49e95db2d40294d3fe77cb600afbc21abde6a09517ff6491e7c745af699373a5e2e6ac69ba2bd469c2cb46a164b2c0b6676c6b9a87ee82232ca55a6b33c18e98a2543bfa5f018d92e2b9e595e5d40ced95ac8c901bcc79fae18eb7d8d60b42977e8df772f04023d495797193715965a437a2aba9552ed53d5b0dd35c5f29c56dd0ca83c85d332e6dceec936df37be532251b0704c754c5c643df6eff30f68a4d030f77d7766696251911c32140803874045d002118164875702344abed95a7f2c9b8a6802dd3b9b58d6a72afb62f40bbeda4f7111fa28f3dd11dd827451fbfed61b26697a798457f359c7e0d949aa5193e5ae6c4a0d2c7ab1c1d122718d00bd3c48dc0a1baae07254ed71692980febb45e0fc5f14f4b91281503ec58c330eba2e9b6e727e182297d1f06048ca931f657409db70b7ad9900505605e00cc2ffde5ff4979b18acfde1f57600200314fdbe51ed9316b64bb0edb8d7eb9efbd5806fa6bb5126c7dcf0ad962a23582fc240d999dd3b1832ccdc3f89240b92ac3ac819d06a259f69e131380448678cf81ebc6273b62724d1d8d73653b2bcc6d035d1aa13e3d53ffb1011fe7545099e387cff8a99a8f40c11e6025992dafafeb4801875043cf6dde71f6b1622b171378afa3fff02beb0c6b2a013936aa0342b74ef103fd411bbc5d2dedaa35367a1353b01836004dbc9f76300793e1b548bd84853b829dacab788a0a7749e3bf2b524df5dff667e2ead477c6dacb21d6588c464b490e9d22f52ad97d0ed13ee67663b896bf6434260de7ae069f5596fe6eb9dba9097f8a12d1f94b2027192621e0b2f9768f7b05d276544439e00979f17ed3da663b08ef52a5a47e2200df0167fedff72bb3359ba173c8b7b5c17c7841be2b9e710f25901e17aab8fc1b9ab444e755641daff188eede22844bb41927ac402361fe4b88b2ec39c890d5af72a897ffe954170c25ab12e00fe003eef09bb01e282a7297e8281df1f29f93471ac478294139de282fa2a080b0bf4f469cc78404aab716b2a03c95a1122bcb58327e39bd615400524d2bd9fcac0c2b8b87f5cfe89e98bc6efc794dfee4da6866197d7cf0ad821fd56c357136195e72794ddd5a916c04ab055775f535f5056a4bbe0d13b310bd5c43622557ce110fac3c6c0458a4acce96ed1c79593dfe66cd824db172cec645d398231c2e901e6066ba48bfbd85d91904587aad1cd021662ae8e4c67b68f7579ecd85398a1452ca88bb4d66cd179c720869f2382d5c077c9925346682aebb813b24e3735adbfa13af18b639d8a5ecc776daa17a815dd3293e1687226e2fe7d4bdc9726e5c884183b92f1401818b82124d12be26dcf4cf125244d281c9924b1a66c6c116df8a3a103b08c591ac6803722a30fcda95489709cd304a491f8eaa243f94d8dff8acc4047dc389f98456342351eb2b59fb3f5bc3cade7888364731ec711b0b9078cb73addbc04cac52002abf593847a3427014ff980f8c449af4d88ea3277e0226b94ae476fd5ad69dbd7c0327165d65fa5d61ac2831bc0114da409c3a34a7e1c379b2deb0f7ccb296c9506f90b6e69dff0702e326f705fcf632a80784f0291edb3ca248b0502df7ccaaa894444db973487d309b83fbd3f9f9f7cea0be71bc52bd1b8df8043afef5b1ac3276f7c7ff3f4a7244dfb057d2302b627037763eed683128916de48846b288c4b66706bb418811c776f514d011dd6ae9a13cf92e51b6505d9292e3e52edc341872f5d9c19a83828fd7017794c08504d5973424187ed135c3a38bf3ab804a225aad2dbec61eac9f6488232d70fc1a8a9b65c353aa5488cabee230b8735c5660b110854f2987e49ff5299c381c519020fa0473fce99ba78eb6fde30e4ae460292eafaa9750a3a97bf26744799843b2504f99b486d478151fcaafe0fa583404d280ae30b3be82ceea918f77e2f106d79933e99e8f74816c3a8412f1954d59ba29b46b619deeecb207b4b6186180ab0729c671df16056881fc485b4e85544d4599059b418a32b769c97c55ae8d1b0f1f7fb99c02297fa38f6f024b98bd30af79cde091687eea34fe695c60a4b09d8b9cb24e9a676145125f0744570a581c8d9242b07462055c16d47d1ef54da025aadc341426e31ea6e83daeb445f551f0491cedf067f6cb4de6314516f824fb628760229fa2067f34e1203545afa367193ad7bc851036160d399a7c6c2ba01d6a591281462ba1dd40f39a92aede56f8562875c3984fda8d19db5cf9b14b71180e9610ef4fc58a620d4b7077deb0f8fcf687bd66ba800e9f1a7240306325e09e9c41623c7f183dc56398762b150556ac06244c1e1236fa398b8871e5f512809d9c694d2e8fefb61ccdfeef023ed7234f8c963c150eb9f409e7c6fe965b63613fc6c4bc883493c1640de4d0fd0e062d445eb191f83d804a38ff1f81bdeb8b978051e1173db5efed9486ef04b712b1a63d066824789b95bf541eee636b5dec333b98b11505c3b9de6abdfd3c8ccb5b8bd2c46b5a744a36c6a975932af62844a18854f8fd80e11f25a38b9368135ea14b72f6ce0eb36bbab76dbef5fcb7643d58fecf38525bddd66ed6fbe30ff3ef7ffe31bd57596ea31969865b7bb0d90c0f4ffc36e5700faedc469c037204aa6c551873a34290ef266bd07aa6dc76a96dfa92d22488cd90cffd28d3ad1bd7972f80f73d5b5dab298b9109267c4b9deee915a345aaf5c02727229a5d00b7284ba05842e0ed17f6cd02142ed772ec6cc4356c9a0b75434e82c0de7e60260c4895a6330146fcadf5ba14891d1fa5cd6b7f9b6d40164b59c4b1787cd1373556d4d6a2e061ef3a755b552fc580a3e2c8e6bf0b95473615e85e5acbb63e751bcb377e371491b84bbfa81f3b5da2abfc85ea5feabf5a45306b3cddffdf2c3c2cd5753673a57c4858d4b1e98af4215ccb365cb214902a1d379789c183fc2191d658d3532abde467f86394224d86a685b0b74e4e976a758ea4f5e9ba762fb62a478e20c249083f7a46efdbb0fe8d200fb14684d7bb8f06c43578d3170b22e0a28adc31da6ff3e4b5419cdb1eaf0b8a9ac82559ad02fde00b07c3951dae393e96e5404a45f598da70b0161e9f6ec5d15334380e5e30ef6fd89792431ae7baa72cc91ec6bd2a60276df4d81b8c22bbee0212ee1c5fb9e5104b37340ba665c7222f931efc722ef23007f2d38c32f3188b743f3dbc4098ec28b025f042fee88623529bf5d950caa6433ed501679304c4bb051456f203ee540e7623bb48af82088bd281503513443bb73b1a6dd631f401e9e3e7cccf1f69053f8a8f8290fb3a8f346059a571caa4012c45e3296039a7543f16428891076a8fd95a3c36b93068b59de995f07e770b479b162c97a9375610ce8b1bfd86a44a7e202bd67df4112ae6fe2e0978000a5491aa0566ebde313b8840c9a2c4df73ae89858e6cbc5d4750a92429d5c4e432ec13fe8bcc8ecbf5ad24550c1a5fd0d98ea72d05ac775f81685e6096b386e0a7d1feace132e1871b43078caaad5a99f85ed61677ae95d3087aed9859807dbce1068372bd100b9241610caf10d5be225bfae387689f979da7e2fd5ea30a31a8e357cdf4d1c2279934a633b3914fa0d40e2a136dae8728c8b276e9ce048c8425fa827957c206619f6959a5bc49d54616cf79de1f656122fd4e32f9929019a5b9c957415080071b1b1094f3a26b6b43de35feb6c232ae90cd0eef703a060eba8715055b46c3915ede1e02ab147895737a0771d4cc6626242a8fe2e77dcbc1a2036d4e6e5a5f0089192754f169469be6d50293bc968e48c2203852c5e0da51f75d279d382fa0315ac1a99694dd684660f351d6bbaa2b2ae36985e4aeedfa2df13febb218b5fa874e7edd9d8d865f207eaca2a46e77b1ae732380b3cd153a8fface7e3c89001913d5b48e2be8edc9aedf798011cdb3234412f29d294dd1bfb626bf4f21885123ea2d27dca222a85ecfeeb0f6ac6ad1f387ff9031da34bbc065d6194f4bf130096654f89562e070ef4d6ad3f880b71073b0ff400fc519b41faf30a8c35788d38580af81d968696d7415fdbb5b5ce8bbbab2947d535bb68784a51382d200f30b27089a8114925de62da0b4184112e9a1aa1b818418cd0bc72e8c9a6f68c49f2ad7ff9d886176c4933ca49baffe8a5403ddd40d7fd83d949175f04f81e4177aa995e44989896c657ac41505b61e99a85c423bf2e634f6c21701166c1455db858d2a6d22e809a34be1afd8e1a322b63df75809a449c5c3c1d27bdf63a40d46eb4550312b5a990f345805a376ce8fb0e32a2e033612b7a7bbe7d015acd1988eb98be17a83003d11fedb23852595c550321a81d7faea5f0675fb358c293419bae86ea65c0117972c2ea6bdcb032f38f82a99c3107feac2c430e34c439fe6904f9d545bc2246ca440ca1bc083207a911e38f89b14b1e6fe2141f8da812a8c57b7b0e3a6b46148eb11946e04facc2e860b07d0d1f51ba8f3a5b022aca612a6728da6e21549230a4f175c57173973b1355d55d8f0d06342dccc1016800678ec83f4c70356743bd7831b8bd40432f192f0a536ef669df44adfce2215abd16f2e4d8425af30d8ae604e1960b3d17a8826821fc093a0188b976e44d6167cff1d1b73f4a4c3d5a4633d2c01edb586840d96a7b0cd9600da77bc0dd787f9249a1c16a3e8cc5b4fab63de2aeaf1f2415825030048ef94f3126c8d3437d6edf40d769e049d1e46d85452be8d6528a2d63288b263ca651d1d635e3c48e51477c93dc2c59de323851e390f2b8ff2ac800ccb2c009cbe2ffebfeee3b8629f1fbd28f5104df81bb2abfb2457477c43d736bf8af0e9dae43d8190d813833f01917a13269cbd0e55168e179d3e281623450272582ed5a6aa291c40537946d4515a2d59dd1dafe36d26984949f1ed6fe337c7eaffe132b9e37ec275149feea40e182170aa031ae223bb2d98ca6b5846992fcc827007dc69ec85eb135d131410634ac672a3fd30dfb39769b6a1f9f92bde0ed393d1e6dfd976935c7fdae892de63e6f8ed82c6a07130bd2b8d4a4d3cabf42054d39e6abe4246aabe8ec8655bfa8122f4cb7c359bd20a3675726364a0cec02ed31ed5184a8e2def299b69c5d5de4caf2958f7cc29820490e40492b03e24566e1cf60d51e2763a8b4eee7dbc00c3cf6931ba2f526f73ef77262de4ec8fb1f5cddcfffce79b0fcea1c79a2eb99861fa8e7bcd0f7053de57e51191ce12ac82d8a77591913c3b62c12af8c3b1ceaa625df886fde06dceac193882654e7a1cf918d85a5bd8d12d5c2b84ab9468beec75028cf0cd994be7dc0bd2e30703d54fa6ef95a219a9943fcb0b8945be8f2f8268cd8e5fe88d89d850555ecdcfe7cc750b715bdd44d088bb84d603f6a3a53949290bb4cb6036a25d699c913f61a60606793873a67658690e130fc204513b27c12e53e312e6e46998d2c2f97909ee028161c093f8ec1fef8a038ddb5ae5f10a970b48ae4b48d939a494cfbd0a6156b07e07623dbd3366628515f9d54946bd8f666dfa6f8b8652da4a128b5ac095331ae1e109b60b7ae1c1c19f3bdffd22786e4c3674c7a358dd17fd114fbca995a57f5802353502486ea22102a310be2714009f81f26cc0930b0899f8b39b2bd39d182a1945f048a82d32bd5eeab60af88945d82ff1d12d133485ff688227c243ca2fe819392edcf22a4378a1d0115954cc8b0f233c570761171bd4bda813473443ea9480a5973a0037544ba0d64af9f0ec6fd8d2fe91cebab367b03f5c7e864ab6f9a09d0fba53d38c080e739fb5a2f1e675eb53788eeaf4ac85babffb9a0be590520bcae1819bf179b01e974d319b496e67035763ecda8f7f5a13db55db8cbe5873e6df7160126530fc385c6d93d4f3afe0183e25a28bb84b1c35a0a151233f067ad4444d80e0793c8f9aa1c579e1286eafd7c1a16d4f21895f0d4bae1bf41c01f524dd061599bfc5072c2b671c010a78fb7b7e114d45903f36541986392034cf485be92c9f37208274359ccd9417138bd00ac64cd2eb264b6ee4d03e0071c6e4d4f0c8469effcc18caa4f775ff314373f824b097a8cd8e79d19f9acec41d744d74c4bb063373d2949bc848bc2cb5a1ecaefad92dcdfb23a38f2aeb5ee2e6a99dc0e604c644d9ebc93142004363f5e728d3f970aa4a82ddd9bfe4000ee84948c4b86465dc43f7f0c819495c997de2fb5bac7f735ed000e8842512b9a9ee2a7c8ec1414b5b2362b2ac466ba321087c5b0a4a90bf9c316d6005eb55cdf9529d3ab7cf7f4487244dfbf5617d300a0bd78c3834332b28739e1637f54bb3630d4cd61ee5a1fa61fcdc83fcb6027f7efb368163c77f5f8a23e0ec71f7a3297667edd99feed98abe81b4a9acc86c965e85db6a065f18842e2430cd26a0acdc175997a8899ae8333c33d0c682b956d6b72dffdfeb2a1f98d627ab685ddc9dde3edd71613df8ab1c43d36e98215c525a01afa77020e50cf4b3f0329d896f3025a23985a9aeb2632b8fb2b35623d0a72978ec60c066129270d2c586b73e1f01b7fb798f9b44db09179ef9dc772ad9cda4f8bc3e84fd9b40d4059e109924884c36ca4ca76358de4e5190ab009dd03348f3218e39c7b88d6a3f2342f17b04fe82bb46c27a43eb60df607f6e72484d31634a304c494684b5dabddafac8271a2892253a5471908f6d7f5dac2a58bbe9bcbef2e788a7ca6af4c25c70cd158c64f9aad85eb4ee789a9fcda349b63c1556b42afa1ee354a958e0490ff87e446ab910eed7768d04d94cd719a30bc785a69058f47f5f9372add178eddcf76427c7d6321d1abb7b8775f354877156b12c28a1c008ce9420770de2fe9ce4a8a2c3b2265fdd6e6b62cff4786dc7a9fea8901858b1e0a859dc271962953b93a2cfd7aefe64f3419f281b0963bbca1176674988ec8ad52e828fdf032c79b7a440bdd7ee570150b81ea4a4e41e389a8779787e8f716b5e1a926796f0de039f4c0071ff3da3e1b00031b0aa34d83b41bb8ed3d1c29c3dd73d3811626be544f1580bab6afb77d9b9101d15ea07328121165ce251b4e46a228056e06e742680e2fe66c18892615ae380e7b0408111b0ee33a340b331c639004c3f53c68c6421b767636ef44852b531d9b5e1e9e2c07cff54c65a8ffae5db1e503268212c6ad049d268e596aff802c573b0f07f9793acd949810f390f2a60b8bbae6d1c5560ab08e5ab02bba3cbcafe92c146afe6b58a5633f376f97be1caedffee40c605bd07506bb3a6c73132c6a55e33ce9f89e0f8967d175d4b61e0357fbcd1b8a335f3b97b505d46226ae1254ba98dab5f9e6cdedf354ce1340565c90e19341564d90c48f73b7ce99551063516befe4326e14301c7ba66d17054b466838c8e79f4540d8eaf6bfbd0ddbf260e1377c8fabd236998096b7ba034339ef955a1f86d630f478fff3a935c487002df3e864a557ef8f93d3bd68cd8985c2ddfe56e19dcd767b34702fcf7c06ecc1f52f6c5a17b112c851565acc040603ac06de118d0cf583ae328efe0d118261d611873967696d1c871709ef01ac83bd8bdc127dac51a82cce2c8f6b24ad2272ddf0b2b27c18cd28287629e8b7bdb9c46f64757f0de4b12de7a1081fa2a3429c2b831d1d4591eb91bf5de16441652034dbc94f69648413f59b030ecce59b9c4925569b3aedbec5e1bc60583a25857fbbe6f2f51fc084fcc7a2cceaaeb7f2eec246e42bbc0beea72fbc4bd1c391f5af9c7afc947d15e78575ddc72225622eb515b5096b19f0ebae61df51112d8d72948da18d80b1f4ac58ecc3251f9d01882e9dc68020522ad8312cb82d3161dfe99ef96197441c01333d6a45946a19919829b4965ccc10249e6dc40c78b4bdc9537efde94cbe60cb7216d275ff38853b67da6d602e5afdc0cdd87aa54f0cdf0dd8aad63a50de98ee9c1f4b31c20c93cf92b6558a394b2fe547cf6ce5e6f76603d5f4e88cdd213ba1d310eefcc39fac62016b0849a5ca57d515019b18f318c23a98abd5c108b4e42fa77a441bc14eeae791a7f98bb6c1686e3cc3554b75216815191a3bc5e49d129febbceed805d1f2ab7f3216452cc688fc44c8b5e605793d0e1119723705f83d1465fb3f4ccd740c5172a32cd1dbfb3334395d72af9a3487fd0ad5f78fab4799e26959bb3c20bbb3966d402b706cd6d309a2e0b835c298059e31898e2d113460ffc70334b9ecf28a3c42ebde4b9560fdb09280ec11d888f6c977569667a9cdca6c56a8f765996ad721f838883a30f6e4412d829e53bd6884c7c9387cbacc11ca7ae2f0b2c03ee86d4de94e7b91fb43dea2bc7a59","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
