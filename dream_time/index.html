<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f33dc49c3476b00502613d942cd666761704a6b25b68d5d3778bde9accb1420581d613203d06a0d12c9b5ef2b50f8714768aa3a1a2e42f0464ce6f7a82280acd3882d1498a60f28dcfe8a17dde3576c225ac06c6e32071da6483e90cc85997a91e7b1eabf5d198a12b791f5bc954ec0cff4f86f4388155a289bc9c50806bd4dba1a5342bec3d23dbd13a7dee75d8edd39feaf57de00b3b0cd9776fb618c0459a2122064d0dc4f4d87ff12f0ed0f9b5d32327501aee32169a2995afcf59329ce4da7a18abc6a97ef7a2065957bf282685c9e5417b553f49188b198eba97eb38ca4438037b110e3ebd68cea791a43d20f0a606207bd35668d99713686f2c3c9810b73098c8ff7caf6235798eaa9dfcb8cbd60d63880d0443447cdbecd49d88797fc8b44c30823157499ce955897b838c44208c0c7586e8d177f499a72679df61f7e598f69165baf79cd77476bf25f04b9d078047fd4c960651eb9826396a145690f787f137aa20535bc23302b03c5daf3e0e73eea03ab199608a0102d5078ff2f79c7063630ac904b60fba188805ff3cced229089cb5f332625054bf9e905edd6d0f1532836f87ddf2c12d92b567a49675331329b7822adfb33dab469c2dda013d975f0d19d5ec4e4c1f757c95e56bf835296aa518f523f9d9bd77c259cc8723b093a257811a18ca20e39ea265d858c19344933423b38d57379d819610fd75d72a7c842620d60fa8176520071d9c911013bd40cc30527006b5b60847fcbc1537193eda0ef4328f42ad693a3a093c1ffea4f4c4a23e3a455f7e02436fd795f603491284d4f0f7b9f342df3c9caae5a1ee124504cf9db7264137cf1a64fd5f232f673cb4b1604f2e81e24928072a6e27e32c455bda8760327e1ab69609ce569996af65b7761bd6ffecbfabbc9658d5eae46922f1b155bd030c334e547656a2169d50c32258ae4959678da999d095d79308c47d1174e314e6bd2063b91e1e3f687eabb865c59e232052ab4635177c94e11a86c2073682cdd8591f3e8e1a0fffdfa6bafec0bba827f7e9bd029d13186f95f18509dcf137c2ac495542320e6a084b617fbc3180b26b75259d3e750f73db002c9f2026292a2418c9666268c5a1c864224d5b5e506f8111ccfcb7c3dd9d5c52ad9cbfc8a7e59e0c5a09e628a0cb0d4f18fc303d69d0f36ff6d420be023425bb299c65a6ad02eec2e941ebb9f80bc3b560a51ea9d38e1a5dc8093a594eea12f3a8d0735349781d43893a5cacd027609f8e9f71ac234bf9f6bd1f0ead8f58d9fdb22d828610718bb2d5e6df343fcbcfe1dfdbc6346abc0e5d0b90eb05bac4521dc8086784c6f0598a860c6f45c898556845db04253666804754fa55035eca65e683f09c2621cb7704d2c225c0f70419ab540af836ce43c35cffb392c47c157468348f1849b589b6a1530d65b87e993df4285ff704ff13769ed304fa43796d06fb725fbc3d2249fb20844221aded6dd2ff66905d2e81275889a5289ee10de1bcb72dc835a9dff0046cb2ddd3424ad9123551aa5446e1bff4078db581e56d7b3462c96baa36debb4898f65100486b8596bf57fae8a44a11db7bcdaf79ac450d716ddc39a628174afa8aed4098b7dac10883a071933311edd2111b5394cf8ffff3333808c8dfff898501e34903de293ac29b774817a7e46aa5a4b85362b8972a5108e8f4cb070ae0d7642fe5669bc9d418748a60b8e932737b93441d800dac068aa644103926713ef0e75473a8b692121db816797e8bf3125499effeec18ed344d8e7d09adfedf5ee4f00edbe2174e906943817cb87be17ed4160a3c941cd172413c4981a7dc1d94da7c4e5867876870bf4937119372cc0676255a8d5fedec50ff188e636da89d8491affd6c1a3e3e017ffa355c4140bff08e813a39c683e249704d2095664fe4837e7ab5be9f39b6a7e6c6122db462e1c2851657fa89443c97b2f25118ea3898833fd14b85d0a2c73d47b7154a48df3189406bd5fbfb378ff118697d3d91837651b65b5d86ddca51380428c2c62e021a61eea415c2849753f2b1afdeda95d4d6fcb912f6992a53fdde92fe24b82ca387e31d7bf240d26f2bbf7801c341d090800750e54fd64cfedc3efe8ed4cc2bbceff03c039a20304147184ea463dd73e757570025e5a31f0c6a93379718118fd73419e6a44227f5012570401cb7c65ef89feeadc8d26ae389e92eea181212bfe53717cc155ded4e7b33282dc3b75647e4d0516bb3544d729eaada31f61cf694b5e09c3fa5f268f1ee0f7921397b7e5b69c4d7a7a3f183757b068f8363562b534ad6d26a99d7823cc95e325096c10a0956824884e7a347e5cee95d349c4bc822533e3aaa104c0b159d34eda03813009b0182ae817fb9acd9099e1f9f539455a7eda63784b27a58a1d3d4dd969060bc375f0d96d080a140c455710c941886914a52b4bc1c8e4d648bef0cd6522c0085c8b6ce66742523301ea2dcc4ec13fdaa0042c91ff8f52c8bb844c1782e49a413a7918ec3c867c651ee5a9dfbd828635c6139f77a9ee123d9805119ed480f6e715260d290f2e18b76180d412141e3f9d3bf1c0b077c190581cf056cdfca30aec8ded161e1bea173f0858db14e5c14e5aff46889d86fd87a866e42d17ff9d81a2e8d59002f3eb62c7960343fd801959c0e7b194cbb85b62371134fec641354bcd8faf9e2daad82172eb96a035a2ab670f8a9792f53f1fafb806d7cc3a6674e1ea5b85ffd2ea33510349ed572fe36b58a3ee502453d9f028b3fa8ca9d538291d80b9c4ad5369adfddb7ab596b9bb15a1b5db37dc84bfb8ffe45ac4df93d8124bd6ac42357cb75c76b027aa1fdf5f24d71c9a67981bc9fd673789da5f28dc71242faf36ba0339d3de4fbb97f6e565717b5727ea53f8650046fea4457b9d25d89f65bdf7b6ba0b28cc784e7e5fae4265e3afc1759e95a2eb6b22056bd045d901ab64efac456f5b0ea36a284ae57fa5fc28c2095dd06ff0173596ea80e11becf4c5cc8e38f674627622e7b4834fcb0880b5926b8b646f53070169791d5cb4affe3470fb6ae753a831f1a24e6a2e98dec888c08f893b00dd72cf16af8471285646abe3432e6174d9bcc2ce1bdf5389dd02397d7c901fb06482a9ed0aa0c20c65930928e021a949bab3ec660211b0e21d8793fccf059c49844a0d662325706b25cb0f20231e3817501b82ff34aa64c9b77db970e962689b3d547c99dc4dfb86e98f28102d4ceb46a25ac95ec9d6e1d778f8e5078300ddf1a4d5649293ef637ea602f0352bed56010d1b9201ce9b578905a336a1b083e1147c04b6fcc7e132fb1e4d88acb4aabc3c03eaf0f2c3d9906ab43608492273166d1b0967f12196e9c8dc04fb475127023ffa241eb7122c6f8b9bc3a0ef93cb16a0593a59c90e094b48bf6d42bc57f7f421e7eafc52412872c2b2a6ce9b654c1c42c0d95d4abaf90d07ef8f8fa816a09076b766f24fe2f411e49d4363fc4f3eaea1a99222049f8077cebc49445dc14b81dd53d381f0c171141eac28d1164c6199a2b259fdd2c79f108e21c8728c2a148d0b0ae73b731bc21d8d2722712243ef9429c3c921870b045faced09f8937eb0892c5ae525f6bce746e877237af2ceda0be90ac677362ae42d81e8caf3187a68876116438f7dd8456580d3dae9282674cd272660a30c2b3527a2ccc937499f68da5a4053b23d49dbfe2383ae77151b9ffd0cd8ad4edf73bc46c151dfc9f0b147ddc99194c0bed945aad194be5878785d0af2e6aea8a1810593c968a9972894a2f85eddc1a0a45bca87d4a5bb648288fe4b59bcc022a23ad187b896e66178b83fa952afaff59138f53c3cf5b76b9d8d4584bc2453c68607acd46459e18e84009657527b133fe0784a5b0587e55065c3fcfd40cc69417515cf1abeababa5516375010d51cc3002fdb0cdd62f5f891545effcc1a9c6c8167d51a449947377926fdc48afaeb3a3f3a1e17a1d00d69f0943314ff1f889474969e6335116854e964fffb75127c4151a037795278135e3d631fa70557666cae4176878e32cd6386db613e368bc09a309b607567870ede8f07942e935420b1b694f04d605129ec61289fbf95b2d3de5b747adcf6a7217012037f7568ddc169b328719b9b3c4d519994641363affc9b5e53a5d04aacf2665ef3e806badb18fdd2c131fb16b8b8b7c8619d781f1b7ac68bcd6d3dcc944ecec92a0472adcb1a2e3f860feda8924dcc7fcbc3302e5007e154a84cf22b69c0518e53f4a698bdd82620926bbb3af5a6cd098922b9d0b359b81d12b1953b9c38e8e1cedd0062647bf90de259bdd285b82a465cc1d22b25f9f13ec5e2c22541c6ef6c39480a7fb40935b18e6162d7b72d59227d2a94c1adecd9349e8d1eb778712151b7e831551bc91c3fa7a79b8a80565af8ad8ae8a3fd3881335a44ac8e2a8b82a998fef1237122223d0ed9258db9206e2b7fc433a6926aebc7f740119db112cc34500c1e50a000c139d687f99120edff440c91a6c119096592357934c45a429526940f27bf842d389c960c7701e35ab6024e03efd7a99d718c305fd7a30290938b6a0868f29553f2377d65a84d7787352dfb4ccb59476d53ae9eed973afe9e8f0a019745db76b714bcd491f89cdbe21ce27b2eac1c73acee8bb5988501349f9032307460fa03cc8b1c6571048675bd60da7051e9db9098b2d8e258214ed222a9f99895e2e00af2632ebd40c54b533808be6d7966920a66611d278026003dac8929afc5aacc49aba749121d847f8a94d4ed3d096a6b4ae542b93538fe82061dc12d6753b3f0a731d8fb89806d1ad28158407e3f015e6c88d8166127179c667ecfb0638fee4d7acf46269fae4af5b7c0a4953f395caacb9b83cc5c9b81e7b9bf9171d3871cd0d60547c80de803bef83bd142b8113619efcd790a814e1ce860d62a284ebfc432b0cf0686435b27a42c95607f8d370480cb2906544a522175b57414203c1a13a971dc800c75332d2b7e1bef970738f25db1f1be66373cd366e943f900f2b6abdc13bf7a126f63a71a6009a6e123d41b885677e739f3014807172a9710d7cddccdaa9844a7a99da4a5528092efa06089edff3a5b9ec2191aa9defecd856e62849a8c90f1e4a936e7f894fd16ad2cc32a3f7ffa798aa24a92a8aa79aafe22921b849275360b14206dfc60eb675d3e32d888955163335d20b692d1b098a0a2fd2f221d860ad6af342f3e3a3dddb361bff74db6242f3733ac2e4812d1a51fe57003697af592ee22e37f10e5ab8d0774892ec512bff086afde70361ab28b025563bbe3ba9950a9a69966c145de60c258d9a91ee4fdb6edb7ab205a67b27066c816fed4f3567fdba3e95734c888c2231db959122bddb499f904ceaa5d33a3b97771a58e67f43c257f8bf93f2f2d4c4e62786892eaefb5e4fcbda4e7a21fbcfc97fb5dd1d5fad8a606a8ffdee89b9d21f50d018007ff449da9276c9855c32468f449117cd84fa0fbbdad43c1585d33a88d06de5349afbe9ac4fe20a43697d4a66c61dfaca570c0a14e98faa154056b9cb82fdb11702b830f126c2fa6d4e68342c4f27c9c9da1ec9b87a13af685c5c0eaf1b0794e51a456e180e8705e5610d6b79055f3b5cbb729edb68665054bd770a2e0c0eb55b4dc5e9819aab422a33494333e24043016c9aebdfe145986791363f2241abd9dacc489ff55f3cffdc1b2b77ed92e5c2863b3d9e4386a14288c9c2c563b9e957076dacdd30027224b02bf0d850d37c932e28db395fbe5baa4d6b159a04cc9ff50f2b5d649658ba4ccf2f15c42d7fc7555e29d2c03af88b7b7fb1066cf5335100d31f3501437df5f59f56c5a1293ef21257277611a92193c9180f603765d3756ce98759afd83f9be5d47e055ff51e6a1c79356908d043bd468fac4bdb5605bce3a10da36e103d18a659016aa8e1a009327c889e868369a2ab1c676cc3b2a8afc860a399b3a9b46534db17a9f6841430dc7268f4f068c281111c7eced9e795a4d4abb6314a5dd9e3fefa5ae552fed9f9b2b1b713f33188bdd1fbe8586635c1cd219a4fe836e3f6fc7893139dec9e806905b0cdd705bda213a4758683041bcd4e91395deff75cad9ac0f25d2f7d0d560481f167558776b3df0eb8711fcf4af7f9ca4e79ea4676fbb0f10ba993da046dc9c4b41aa29e970483db27b17f14ade4a4028ef545cbb736ca408178b91d73544264ef74d5753e50a1932f9396dd0ca97f2d64c422352cf11b4f4d012f6ab0e621f65fc91d22ed9c466873e8f996f3ab30822723a161d84604c6c4a6b3375126282a948a885d4a4bbfdeb6cf7fa6f3bd743eb5d1513b2447a993322185f98b1baca813fb397f0f332e7b0947a911cb473c5dbec3f79a70f21598c655b891bb079e7c9b8d3391677f7b1678303179da6f81e0dea78e3e35a74d14c502b9abcb22ee9b9011aab4d1c62afca49c625fb20119be064c13b9b7664e63d7add30cec24fe572a259fd90420be09ea5144731e7765ba2310a4be88ce225c39b3ea5e52dbf7cb9009478cf86eeff60df08ea9bf6222dfc385cf9ca5c02f72edb95bbe2835d490061a758f63e5d52bb602fd29e4f361000cfabda290bc767002d21b2d67493538490f8be8f1d1ab971cdf8a554a7564f06a9f41038b2217533d6b15709d18b3e7068fe81423b9aa6555f83cbc6ac799653c2ec3919e174ddde180f7f49b7de894f4a6817dd1efaa63cfd65c2a4803f180c72c49d0cb4542c60db5e8cab7aeb8828447e1ef9ed4aac4b2bb094589ed686f127505ed81b984c3d377c4827974f59b460e957318ac33fc8d728072f94c8e20d2d9442073afb1747ff2e2e431469cdb36e3fe68bf79afe247446f5feb1898208c425be5bd7ea8374f89f3f11409648bc925f3e25121c34c1146a7408b7a2b359e44dd93f3ec7121279fd390490774227bc832b78ab4c05df937169634a9f7049a1ee027cf64a36e4150bc101d9fa5a7f46b0f151eb4ae9aaf27acfd2df9639d6512187b0640e564145bbddc58c488ed676189ca2356bf73269fa00f1e97782f9b3d72afb0dd633206cadba7fdf8d8d094479623e1b260efee32965d4c3e39a1f2fc9362446e8e0c8960d8806e75643c5f60eaa0371f1295dc9faf54e023415a60576c467309cf4e3431706d61abe2043b40ad74ba862cd75cb437561b8601335acecd44b5536481d4325445c592fcb65318bd0e790dabc3ca072fbca2e759a2063c0efb638c90adb429d5c107b103e833628c9c7e2a069d0c855a252167c29a145cae92803bfde72d821bb10eb32a0e8bd82a887ec964403db5954b63a1b47de19f3bed552989ca5ee031ec5d9642d59f71a9682a909c2a60fade72794d988735b9fede0ecec2dbcf4c24a29397f6d6b333c63e29f509cb8980d96a06b9c846bd0f9940ea23699203f435202ecf3ca2d614dcb727e1f182d49d01453582376c92fa5f21dd7b82066e3c4fcae1785384d46c6d5d219559148f3fde2fc33394b1881c7a5f489d6453d30fac1ea51b7bd1d8b386ed548b5f17872aab632e1c37c0ac39a1a08659041d2f8a9ee4d0200b3a97b7adb076d3bcd458a6a4d1ae773a4cd79ae4fd3bbbda47c73b87c45972227ff4a76db32ec12da3cb88f13d6b168d0a1e7ce3cf635ab1df7670e1d6ddbf399eb5be82ad32edbaada856009bf85f58a46c816efe7fbf7291707f03115827de589339194e82c09cfc5ee165d07e48c645d7410f9be5dc9c79c6baf8509153b2102a085ee3d20417eef59bee7ab0fcc29b909a720b3602b94a2a699ee0bf6de6b4de20c127c35d360e1c40992eeaf732d8e925b47e6b8a3200f096d90652aaf77b9276fba75b99c79bbf1df399035fdaff3168ddb9d45979674fb812f492f203b6904e3de536e51208c33ab86532a71eb28a0079de0b11a2d72217ec467f3deba7ecdda1cf4a4922f037957acb12e2e55136563a8aa36d420d42be2f254c60a0768849d57ac82d3a9107751e2936e20f4fe18f117529a7442439bca51e12ae550159cafaa76cfe83d0bfeb136339b66829a8ae5f36401f8fea1e2e6d4c208606eea42acf9f60e04624ba601435dd9b1c3a13767e4b45fa4adf8b3bd27c5b2815778b178e2212d5903a541fd9673cf390c236f8b48501b7ab3772bab9fb7e5dd295fbbf9591b5f040da52ca28215e2b710b03fb9540b76c812c87eb6d56e9469d9b0cea61dda12f39688b2ea6bfec2777b5f4794bcd735b2be04372d5d5770e9e90cd8149a62baed6c3fddc386fdb0c3aeac2b48dd20ea0d04ec9ac0ae3de5bdd73cccf14c9943158e754f032e248538a228ea5ec8bc487a6b184045d06324e4ae8aae6f38e270b1575fb730fa579c3dce4ab9305cb2ab48b773f123dbfbeaa419b0a17ab6ce728d08414492d3d4644f576d454425e6a1bb79ddf642d08a93a97fc6acce4fa6965622aef5d86a40afca02e97f7f094f8c6fee506a818fa3102ee2dd11de041bae31b406ed4534c4fffad2104e67a5790a5441cc2d6902a48b687e0549777fdcd321e9ec374a83ce5ccff2d203caef9dee3fd8573fe1e66ea5d0b8b9fee730dce26a75b5ca8d5420282a9d2cd730919fcc7bb7762f70cc18f5f8cd90ee3c0340647593bcfd20846214ed81d0851401fbb0b745d37af3e837cd0a575071e3f77adc8d6a0c0277310fb4a2acd785783a539d8248b8df6fab407f90a24b2b11c4f5f7402441a1d4eed82df7509c0c54b8c0932462c33354c8dd9cc8f7bccee7178effa355e616afb09b513e85089629c20abb7f9d42e2df9ff8d1ce1e26c631d1d8f45ac6cea0e8001bff176e1ff6926c81eca99c502bcc26466568095f4782c7f9ce35c2d5ad5ff5133e63226dbcbf9b098b77fda158a8b4806ef844a1e047b7df479286388aead7c5b87251d57570ea85adcaf64f7486477217b11de2ad780dceddcec90e8ccc8ef61bb6e2d7c2c1509f21201c76afe90f7dddc448070ae38a435ddd3df410c18c555cc354289527ebc46426a2d6520574b9dc4b180b9dcfa5e0f37b179c0e896dd6cb53fb85a2f63f9a1ab1f7f119a049439d9fa67ae579d989d9cfa92da58de496b43411afa693a2bd18911a2ef2f9c0e15340f6ca0605f14d8091d9e50e9d164ff4efbda7207ff529e8b0b1c657d3babd62a87ec0795efffc4f752c1d183e6ea516d80f08c0547c517d109895804b5fc9f19c2bfefbb796cefe45374f0e3bb6c12937ef8f9e93fe382d2460a60dd465762","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
