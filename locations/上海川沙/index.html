<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a32ea6e89da4e654b4a9e8e770bcec807ae71354ad797469e810066566f19af98c276bca1c705b9c239b60a736c9144f34b994fc298200b81a7b8633020f55aefb38a0f09260317fef27b5e448c4904c34e7099cbeee6ad61570442ecba1b4e384267f71e272d490ef086f695fd96466262b65f0df4c4a768e98dd6b0de98a7480f27f12d9369df1c87d6403c5ced0db38fd2b97209afef2f54eb140bc10a0d6e7a2544c9b6ecfb57d1ba23915c23a91db827fc40368146e60d81ddfec6cee606fce3c5612bed05861137d82ee82b810a05e56ad701a79e4f2ddf2fcc324070b32e84ec0b70770e0e3d10246340e5f0b5e92aa262578b2a468f64c1ba30655c6f8503a855d0669126e9236003cd8fdfbbb6f6bdbd1ad09b8e3562cd721b5b221b8b47f9bb77a65abb90cc2c7a783baa55518ce77c97f2d634206596440a8b2151c09e17c495e6bfff7c73886236d25593538fc515fcd3ff46134b778d27708add0146b362369414d3278c6b1ebe9a1878b58e1fa335389cfdc07f4a89abd982018c38b5202e4b5695ac328762daf7ce3541a420d2970811da9cde782fb581b7a3884be3dc646a0937792352673dac9734b52ee2eeb6ed38bdaa4ed286a92724c7bf9330e2e09c9985e1c8c055e4e8ebc969b823afe1a3456ffb8ae46c8d3b74ea06f672c1c088e8bdc146fae7b80b724ae1b9a9ad830c45a175c8dbafb29f967f03b290a83bcb4ea01cff747688bde266dd108c5021d7155a0c159079252efc3c4bc41201e7eda042aabeb6c9e814337268016eae2e12abdbc603cd4facc2d046c051e724e2b2694085b85e7ff473f7273db044040541ef38c2b497a11ddc71db9c1f6e709e8dd7d76c74a1cb4b46bd2080720682f86f12e9e7f116cbd6731218198a487ce2be06acb769c290c3440d7694436f67d94563109ddbe69d08c3af6ca23c7b2e5a93932540f34c06470295cd0f18f692b49ef0daefd30db337081aebc7e5a1b1e4ac1cc258a824baeb6fdc3f1e764b18463288263442fe83b32e16c657654745669eb3696fc42eac458af954ba075d6f5004d7c6ff4df7709a91e6df6b698a79c4f6cb53894dd55aa60859b40121dc272c089673e95345e5999073ab989dc783874a989a2baed6f67839f2e5333974219a4264bbfedeac353f2984786e70531dc69fb92d50979feb2a0e29fc01c0ef9734dd8f48e1ea0fa43e4c2489eb0fc50b4ab376fde4a44bec23ef127d200617f62a1042b65a991ccd1c5c36b81e8354545b64f44f8521a4068c99ecb130e2b68ca08a9e6ffe1bb3af771eb6d81cc266181847a6e39c9a6e638ec881057f892f6f7103cde7561a51e8046815cf12fef3eb28deff5c34517f5a828a971b25367cecb33b1ac6fe84729969bfe64b41640f0ef66a87b9900cba3da75454e74a011706f436dc279eaaa1d019f0aef58efe4ceb67a89c1e3ec855e9074031e5a80e8289a120ad777adb5a2337198ae62f56809694238c2faa5c7134c773b1166e74d39f0fc53fcceb6b3e3a977ab87f1525149862ca9715c9bb0bd00e8ccaac305ad513d539a3f2126140280b84fbe57ed7a73a7d93c9d6b274fd9cda21fea6a334e2d3f97f68d07dfaf63084777b07736e4c99996d461a1dcbd0df647352c412180ab1e16e7c1613f16c0d0f8e13ec6aa528fcc2ba04354adac3f744435fb97d24ea7a477d9f404d45e62e1d91cf9c797164dc3afbcc8032ef2b8706421bf53c280c90d16145aff60c2994d1191e764c4419dfff4520c076e747ee9e995554ee189d7cb260e3fc1c3973b70a4179e3ad2df61e4ef7b4636a6f5ffa4aa93bbe979c91ada6c809e794875c6b6b1319fc3fd35bcd113ef38e15660439fb62132f170234b4dff9c8661b8aa18c4a2aed7345f41f87951111e271ba1138f56f9372684c9d356c773727440b2510d0a75b9d0b7253ce2fd9475f468a8bdcece1b2855e7d0fc8ce57888607ac9745cd00b93af299f743c619c95cf89b14059b9fa05a1c6a3c30521260e51f6e92f445d9dfda758240d3fa906889029a83b269536898c15882e00d80ba413cdd0a9eb2f2b48747a5165fe6b0b2689a02ba1de8de8ec8efcad491f35beb2fc1fc7753686bb6f20106bec902b40560934b19f8003c7d1375c820e421bc786082adcdc546e783f212853360af1383b3b5f180204f7cd2a8cb44cc4ae31f7edeb8f0f680ec40c97ebf97a375aafc1bb56058b4ee4f48d8811e16c6dada544ae07282ed316ec4fbebe661d16675d8ea3bc53027b5bb248960b28aeb0ff425ed5413f9eef81e717fc83d41a6f62e43d07f73861a9060320d0d544cfc81d6a90afb90517262db2571c6b081623aa762743184bdd750c66407e1f419c9f0edac12570b6597b60200a7cacee65585e4f957f8672b70956b910ec02dadab8bc45fb80205124301addd87e8f627539230a68befc1b21a86ed005e409b53b005502eda716a6a46caee21931e822ea5f0a6cf6ce06bf341673b1ae48d646e34ec497b4b45d2e7f9ee3890a26eee5c96061e2a3fb18b5fecab4c1ba99d63867ff2ddc7fbe2f0ad243c6f022a6ff671b1a878d319b0ffa2ffb62c28a6517c727e0fd8e69663ebdbf0d224757bb3c464ba4aec20403c425e2a24c08d2051ad821bca1a48a77abdf2078ee5b6f3a92fddb6c27920ebdc0fb825c1e011e8e303c664adfc8a1fbb25e6fc8a1140be4322c1f57921afbe06b029f62e38b199bd0c824be8629ea70a0961bc8952adb26207ad8cb0b956ee84c5dc1d3026b51b702eeabce1c7549b4580b222a491b9250299c532ffb1714f096bf760dd42057988a9ccf213e86e2bccb56a0d660b3540b4ae9661d2c14330d3deb563450e461f0c39039b53a390d91036fa87d7a28f941540da45eeb56f51abc30c4a3a633865fcd7a2c0094667219e224610371b35e2aa66a8eeec68471e871d92ee6e3c6ea1c09d0a4fc408aca2029cf6bc812000ecd926182e67fccaf4ebfefad1b9548e1d4cafd4d369e59a05fdce17283d7d787dbbfbcdab414fda80bcb8dd6bff64d9441e2176cdefe50c141ea08139dc61a9dab326e07d3a851d4273f2b2226689ca3faa6149e96448ea00d8a353e86b3e5d41f029e60401a777d1610188b52ca50594d077c2b6966687dbffd0327b562c859aa88e2cfe458fc195680732dfd0ebf3e5ae1c063df410e440266886a7afd60aa8d99d9a086c6fdd894f7ef3435dd9c636e0c457a6255566d84ba09fb72bd93acd9c3d11ec624e59ceb495f24c739b80f67f722c23f2cfd02e0f5949273ce8115bceb93e53f443024e5c89d3a31ad0c3e0b830a1c360f5148ab0dcf0c07d7d82405d00f5ec617ad8498733babbe5228037550446268a24083abc87f01ce97e35241119958344f6ccc3e9aa76e03d2b855b8c8c440f95105d57a8e90e3448b963da54ad10e544e203f2e66efe125a58cd99a79405f54c680b2f7d336db50b4b0b544317dffd36d235acf5debeefa396a289be18aacca548446143449a66f7bd7b64541ae5042247776c2afc8f1725e528835261c9d20b46d5a3535045a68bdf9aa0ed568082852fe86344b3ba8619ec72d403a52db2bb3c64fc355925eaea26f67b2443961daf3ff5421f22f09369af9f54bedd9cf0756c6f55593ea31cf3bc129d87bdbe2d857bf950a286b66cbc72c8b7c8978e937632aa2d98100aa483f1aeeb12300c1c72ecfd1fda3cad8e393ac98ed623657363a0b002e74e0510250a230c95f22a83b35800179f3524b6f3655e01556303e0660b02d7178a0fccf28bff82a93ccdbb0e87a0dd8b3cf3e7069e7c21521a743c86164e5ec7b0b41799580d837df1fe44fe51d4615879adbab8e6b0c027afb271046e6cebbca64da289bf96273bb1590e080428940cfb2dbaeb86f7ec31d5c69d356e10b5250446ef8ff0e0ffdc8f42e12724ec4a6bf89d0d7537a5450ffa16c14704bea35ab7cdd694103d4f20a2f2a6d4c05551fe788a9ee5c8c661476b227ac8a40434eec3bd007cf53d2d593b399e44d350433adb98829b90f2bb3c43834ec823184e9dd637a26b5b271c2c9897c2889a40248a893a70e14598acc38adf3665951645a65dc42f9601f9a44ef61b8640d38531a07903e73ff8247c5fc9a1ab83fcc0cb156dd618634d11d252486a1a9fb7cc5993d3d73eb3371a2148b7432f9ac178a98e86ae5e52d2c6f4052828d8bfbfa77c5cc59b8675afce2522c6913ea7a04fad8d584a19a257bc28c6cdf9ef5ec93c047013b36cda4bee59e8645b590d473a4a429d84ce6e079f1adaad866f93f69f5a23657e1ffcc44e13a22c7a20bd2dd7934d05cc89373e0e87a29a70752c57d98f9918b6290b16076f1a258412f37322a6c0b4e7adbe0c9ab9508bba688a0e1db0f48714ff95ff2e24aedb2537f6937cc292f1795d261f16b67c0f288d609bf2bd2e1b806e7023b27f864615aa1f43de043eb51639372b569d970cb740a5683a3563e2eefb977e878ef029025342b4a031de12b63add73c1b462f2db4260fbf508f405f8dea2f340ed7ebb3f71bdc9cdfbeddc00897be5db718b404c15b1fd7d3f938c25dd803e300c3fbe01708e4c914ee79d69146df26515a411a0e6cf979d9d363ed6f7ebd5418ec483b9dc943fb4b64c69f5a5b01aee4c1535c6261c54ae64121c0ce390ee9007418d05be0c8e3147c9f682f1de8e391defc2b913be07058f3ffd197878cb89c0390be2a8433a5757701d3f12f8ae9d8d93b559b27a4284815214cc790a78bbb06500336c2dba160eb7b594f220c8cf748a7ecd6233b241f1545d9b28f29513344a424039500ac3ae4982468a06393d766258876d90b2dd988ee0bf652e4260122d2acd02524056a7cd2ad48f3b7651c94526207ed47caf541f867a0a6908d53604359f80bc6658fe05046a1bfe4d67c119302c11ee8618a4338822849715514878467cbb2ae309a20432fabcd7df88499efa6c9fe3f29d83c3a5113186a668acf854a562ac713f3328a6f716fa052533b9ae4ff48d016a2e310790dde0eb23b347494d2ca67369a1f2ec0d87eaa1fc56a844b997295f786cf714f4bcbd77d64b08d50b23c55eda14c974299af5da4e3540a32b4bc3c76a2099275c99d9a9521e0e7a457cb0490f45b57e18e62680cd5977398ac29cc472133d4877cc98b885176474e56f1aab721ddaeb93d15e7d6ad43e52cbb73e76fd36f7a4f50d7d5b8585b6d924cb366905908d462ff23a8f684dc91d4d5522423e1a3ef83a51ddd7be5f5c11814ae916a6238cf7a12e6ee0e066ef56aae3bb9be654ec6e3e61a929084607c84a3787573561a230e7feadcf4f771ad6fda60f132ca087183632606f012c8ae7d9869e6dd5eba107960c0c8c4a23fe89255fe243588bd99b879117b9b8ce092d517e122976bdc9c2e85c31dbe21d6f17b6aacb8f65b968ea1c37b273dd1d7aa6fa121424354b1b964af20bf8bc0307407d92506c39a15857fcb1400b3fc7ab5c1875c54d3eb438c6855673c82e3c6973b02aa28c8ee68407b6062a5a75cbf4029e76a7960035f8a8bb0774a65f6cc45b9c464f1de812e2c1e17428ae15e1fd3818b145ebc5b0ba855d852be90a9591f9dd2fed3d59e2bc3af543e06b55fa4a6fcb18b4b7f0fe96109eec7f1ce0bee6dddc9dbd4764fd164239d41bff7e0a0a329adcf69542d2f666df7e7c2ee7df17212cbbfa68624b90485accfa14c2f79dc66dac0b40816e160d24c98753e8d1885d79721de8334722dd08ce616e73bca855e53d100eefdf88554a8e59aa1b160c55efe8bf3973241dcfbfd95869d4e78feaf9d7e3fc553fb3712e334994d28f7a3dd5d1b27c25721edc97060b6ac5a6cdee19f1c72f680682b9bec2b1e5e8a836de8c3f43bd0d380299849d4131a6899781f18e10659daa3d2eb6ad975ceea602683ec9c67712b9c7ab8571cf02a905eb76baef36d6b5a1839e15d6f00613e22c5428c4392819db497bfc79c631df1d750b178be641d55fa84cbc122207a940bc1d25bd66f91304cb793763b6402f534ab77e1ac2f9af714c23a13f3cfbea3be29a778e51743b8824d2c2fcf8ef690492c149baa7f97841221fabf6ae614c6f8dc80ecc794e010349f84ff5f050d62f0f5d75266df687d07f536bcce28109d9bce06d7ec538bc6b52cdf27149789bd8fea7e2feecf01eea1e7799e138858fe5fb46c22db05242486f1e105aea612b9038b470320f7e9ddff48f096e36b62aef7f85bfc9c392201c675e11fbfd145c1c7b5e6addb8eabb741dad48c0c24fd2914835a5d4378ff94b2316f01ec627a531bb668a6424cee142e3cb4892c24e6af5f6a5c7f0b3c2c1f5d7a1bc4806b2a4b7402e2b3166c124123c7ae2ed1e58d19b90293a15c8d2cb84c3bfc577e3bb74818897f25147f6c8ab144d27ab0a7b4de8b0cbeb6715806423b420035369c6a3a5e87e31e076f4e943713039cc56badef4e3a4224db7d61775a8d338798a21e93da8ed26c530c7a45b0f43c526efa0b21b353899a28bc0371fa2ffa9a8dc726d22a7de180c9c696e41134b8866f9b3600bb5f9c2cf735709c25e971463397942e38ff61c6fddca872411cc160f018bb05a93580da3bb699631b26065238eaad0e3a91340a8e80854f7c6f87e412ca02086fb89f794989a4a0a90f758f75b739884f892f66746978eecd8c347df6787d88ab31a0ffbf4d31cb3d3663a0a1b10f9a8ca01f54f1e1dda6a0f9554427375304bf93dd171af27e8c8ab289633565f0170a0651434bdc298b1fc3b767de8a8a3608fa6f2618d899a02236619c15f94e4ed21a1a8fa862ce0d1607f45d6b5252b6137a1e6abf6770ab1d7714ef122b9e7d249c8baf9c19cd8e01f603c9790d36cbd700fec48507e93288f0db816507e4896ff8d125d24f0bd5a1348b25ec5e6803c93b4a16f17f7f213aac299cb9bda135608f933687aea15b47a7a7c2c2a38109be40340641a24997cb184b253b878f0ce4ec8585adb8e927f51b99d0d5b6bd2078fff94d19ca4e92deb9a664eb82d254dc48ff90d77ba189bdd4329e35b29d4fd2f9a29f7ff682fe2a35b5983eda90fc27cb2658b7c0d3405a4bb4ff8ed99e7b6e24d07f1e2cd298f84fa255ad7e91288410ba7ebee72afeba74d137af504031eba0475dfc97c66f775ce2f1defd7b70f7b32702eefe5cde8f9aeb3c5c44fffd00ed7db9a47aa449f8fac25c1fe876e55817f031f3b4c9006dbc3f2c84f21afbce850cdaf56f409ee867cbf2f5a80d49052bcc0b812374c0af67bbc422d5cfc9709cc3143d2ec93ba418d03b083246ad52218d97c987ceab7c99ca78da71dde8d5bb55e90e0b33ce5d8e33bc3d5f8058152f12bf11d1677c0874c5c64b8b3a585a80ba41d5fa674af53fcc6f0d75fc5031e1c4eaf56602ebccec5fcb59d7cf4fdf7474bc1aa193492bea18ba9083205eec483390a0f2cc7779e1737cb59e99ecc76a51026bec0f22f2adb2830060db89225e5ea46b89e7dd123a00f19458a46d43aea6b8d63fad8166d84a244efff65c1a0e09e095ba62327750ffad1a7be034f89784d2c3478c30478420fee61c4914f30d45e6b08759bc7efcf12b67ae4c53a7e6dc5e47372fb8cd7794bcb3cf70d1fee6b38c3e6b777e3e79ad8de0a5d6b0c800a2b94f1c79b41c19e7b74e92814cc053903d03e93b4f4bb8668a0ec01832f92750ca26d94be72677d9553b5ee2ff6c34ce2cea7dabf884b5937d5789ea2e30e5a20b919bd5d433a66c82e6d15b1f0eed984c71ff83140cbcb44e67f70bc8e4d8245159da2550b6506c43408a487b53593529542f261a647b2a6afd41aab72437df2d0cf87bdea2e60ab6c99b3c5f57302f02e3c1c8e74c9bb3cb0dc89a1d4f535616e2b2fe653692ace27a165d3b9d2e42278a056602034973c510976bd5d0b0177418368780e5ff85a922b8231eaed8c77851133f025d6334dccf82ff8e9d8bbf3d20c8c83868bf4050f8175edb99d5b1d9df59c1fc29e03e0541a5c4a7c5d61e7d0a13afeb6897782aa916c3965f60872315f5bf20a83ba2f9e87760266530188dd0d0c1f9a8b8feb100347aaf279fb664192639b3d72b6457206ca7d1f29d6a67ff74687ebd42c148927fd2f9183a2279d955a5ebe103f2cfcbe6dd4f562a28926763b94e73799a174b43865d506553d7855df6ca469f6a6032d5b20ea4fad7218cb58ae526d39374419cd34f0ae6344367f0fe8145d81e44e4b9c41b2255d496d23b6591e625174f566a7367c15e06f9267c9cb2a2d2f9da6d41996065dc0034a8b6b5becbd07613d0ef65f23136bdd4d48ae05f7ca8291f4b564cfaded9710147a844fe5a0e726ae6e68b92cb7840bc432fcd96e7ca76eb83ce77339b6b06687ed31be8aa3931a551de7fbdab7a7e27428923aa06f9a58749f33595446178de1e57d6fc13146ce6dea499dcfa4958206d3125525562bc54337f81ea4ad18a19a6756465e7bf338682af963341abfb59276f7fa132f43eb701f407243564d16e6a31a5cad9177360575e305e85f249302b201013330d8af70b8e4db51eb7ea978f177cdee3ac5d89e64cf899a73ff27a0567db8ac0f9156a8973c693dabb8d45bf7cce36b4b1ad107f94e36b702552ca19494ccd324dc041c030b8681d021dd9e84bcacaf1e94d9c766009279265b0708e6b5836ff4c7056879092a99908a97d8bb0b2de26fad6d96dcb0dfd15ee30d1fdaed491dcbbd1a2a50f707265047fe4a4437044f2d405259e97e62251675b3206590b3877cae16f01bce5a5eebba542c2a8a5510de453585085c341ae09101b2805c3a9bae18e66fbb36847430a87353516a630ed508fda6928b642b6880e150ba202ad164979d182f0b2ac34aaa06e282595c8647310bed7b85a3eaaf2ea900fc96df7a0da92e9baffcedceda358eef34b01f5226503d0b99cdf484bfd67dca985da1a8d75a853e1d7de4533a5112466f71bcf194c3b2ac3bf02c2693a8e073a42d51c1780eab4b8b2b134c1cbfd13f5b4dee128cf24e617166e7a3cf2975b5136300ebd034bb3d47598d356f53bef345ab000f2fb2deca51856f93197a2488fc202c65c51af3be11f8cbe977b2911b711e4bd8850cec50ceeb382ff93be853bf70cb866c8642ebe3fc32799ebe9d75669e0c3a47ef7dbc14a786d3bc788bf1d517669df218166eaae62cec0b8d17dd0146c26c580d691e4dd0cf3b3ed37507c2c1a1918ba30a61d65df896f50da2f73b1d593e789dcd590797602b4ab0cd944b712b4843bfb7837372aad8d220b794566027a724a49022c045d7c55c0015f7f03ff9bf87c1ca15b46a5f59f1dedb5f1e356ebb4ef50eb3ddd5552076ce8ce7d5308f48c452aca02a955134ace124bbb4742f2ec99b452f524410ffbf6eda6fcc84abbd0be6460dde713acdd05c451176d55f9e6636cb32fcc97547a4cf1d122a2da0cb001e49a85640f3beaf656a198fff2cebd402688f210d0d75d3c8e6664b18afbf7d6ac22974c1d8a765de02db9cf1b1ae6af849ea6d400c290b41ca639425a4dc997efbd1028eccade80b9739954e37aae3e7a7b6a7a343882628988ccfc9c29a3ab939b94cca793084762b91e99ade2eff4dfcad7b3860da258fcd560850ff9978cf61b4a9366f4e5138375f577bfa23b93afd9c293de11ceffdd1871aa05f7fd842136849b209e85e3e5324dedda3d50eb09b5a005209ed085bd30de111e3b1792652a19c6ac0ff08860a4d27598a52156753612c6d21f8ba8ec5ae312a9cd3ec2100e46ec00af48b10ee9517413781cdd363f50c6812ef9d8561b86708b91e7115f8003e7154541a12d7b9fe2daf0f5cff84f59d0c7373374e8b93f372e4a12e09afd6b8976d43b1706c87d07e1e26f9520fc781e7c371af9ea1c944b78f109abb41655ffc92be059763d29ad1e0bd0d0f9556f99b7b6c9bb433b62bdc1a74d154281fb0433de335426a6fd4d58cdf3b20cb8f99c6f3c2e68b46fc8a5c44e5df4421d93bdfa02b3fd21059bc18d3cad1c8c69db78995aa47463107a19bebb5861ddecf0a281e0f0d88d54b208b392a2151fa62926c9579e1c60c58c192c742d778bd6af6c5997663ef1c1f9acc630a3aa0956a3fcd1bb0f177a6e0416ff55c41b68050bb1aff9a998e5a1ff19612557db65f787240b2965dcf397f6855109b63d16cb50200a2151291716e2ea45eea664531f95300353a821dc522e6961c3017974869500c8e3c5c9f14ffb903fcbbef3327adbdd47d7dd1dbefe2b574f134ee3d81bf7676a71780f02f78238695d2d5138b3edc5802d7c0da64696616f0f1dc6bdbeb6aceb9fa00e592110ba7e8b0b632e0b77c13b39212099062f605244e4e4465404376f5fe39c3b1dc4fadd7e486d93b20fe7973612c1d261a6dd0939d4784cef1edb72ff34569f80d34d78a880de9de29f9746fdd29a176f47691976548e05831f2380a778171e95418b3bd6fa4dacba1947e7edfacf9cb8eb15731027a8038769ccabf2bf72ac3053cb5cd6241baaa474c9a1bb0081ef45e80c65f97ad9bc72f20fc2526f64365eded006ce068b480ca3c0947f4948f346c565c0ef82952792bd6f4d8b46a051b421e834558160102abe00025e1e27176a38a127880bdfc0f6f810e296b8d321cc495e42fb7a057d7578dd3f24a14e316b0820d8d769ee7571b56cc4ba52f27e1b08280edfae254d6918677e22c81c823d4582cd85a715be32bd35c6501a243b8a26ec9f9288614f30be5281d5cbe2e7d3a2af0fc9a6e32fc04c6e83a3081c4912efdfaa06d284336de7057b3973b337a284374360bdacbdbc5c983cb9b00192ddbe1381395e3a869b3801b69b91c2f8718afd5210bdd5c455f820d7b804ab582c85f5e3658e74a40625fb45355a33219906217d5b9f33d7a539e4c21fe8ac1cc207186469c4bdd80015b5456acf8e12893a85e7bc490086ca4af2bc605eb0dd86b199824836dcc2b31e53815cbb0e92b70a0a95e3d05bb01e28be6bb97ac0ec3ab8a0c4f796c9376d80e215408b83dbabb944f2a20f81f4ddd72c2e630d78dac9cb56c80b8666ba2ab9a6f0786c327b46a381847236ea1a900842ef57485e87a9a6275bc4e17e1a2a9c8f50e3acfed3c1574d89c11c9ad4e9ec4ad901a45033e18e1454ad5ebf31b28ac20cd138c02225dff9dfd5c12126d7f4706e6db73b9468a3929799be3f9a3d4b4bfd2bb8e55c35a01296477d5a401fc651e8cd08516fc6b0a84bf0a9714889fcca5ebf581a2ec20758e200658d97869a47b3d56990b06252c71820465d0c61c44136c57628a2d2750a913558edb124251a3cb108b699965628d19204f15abdfdd8dab46e373d68e0bf619009cc1e93f7b38704d6b8e5730aee7bee93c71b807636048ac1f6e35b40d0914cad4263a5d5e7f0bd4d197b57f6366ff67dbf54fdb2bf27c40ee07e55cadda08dc57baf0407bb424742fa776687c060ab91fd8fbb73f2f9357dd76dca71fed6486d19db634276f19508e2ab11c22108dbe3d7c63213211af56f5f9451d7f08ce8ee8a25c6b55bbd9cc56e5a0eaec3d959906355e534ac5dd8dc444d6008ee0a67209186a8a7265ecc172d482c5804602034631aba98d6e2fb017f8372d5f4abba80bd85aba5b2ac0772a3c15c6c7a7f5d9d5b7262a2747a35508797d7bc4d1c94aee804b8086305f882d13afb7a672b2bb40b94d44bf47d55b1567cd7496766a3cb9613fa801e9692b5e90c9a444458e67947b39519e012339c2698951e4a8dcffeeb950716e0c7d4a5e23892cc30cee4392f6b610c1d4da344851f5cb5bd943592073abfb5cfb446f81456fd8f28dbd34e4ee8d4a4ec8a058bb0ba67812074050b531fc06e4eb32bc6540348e68eeac5d39dd5d411c79d5287123f38cbdaf73072afb3d762798913b3c05cc3e9aceafbf9a3614454388dbc29d09e782f3dab0478c3f44f1ab1919e1bf0ac7d585b7336493c55fbbd5cddd7bba4de97eb75c8bed865e44219b48d9babccdcd4894f8694876775afca683f6b1b8d15b1a26b8bf00966bc0dc87a2cf5fb5eb223dfb082d306962527452fa74bceaa46f1bdb37ce4f05a630371d4c1a54316be72cfb6e458b6c28a6b3bb5a3aa15504bac10b11c36693b8536e4bc0bcf697a599bd7bcc76e109d26ee3e75f466131cb51b42605d285be4fd63a11a34b1d789cbbaf03c8262c65e6c4163f8184f90d90ee21258b1603aa56c8d3f45905060934e6242e6bc8b69aca4c515c028ea2b833aeb6df94e15fc74a35a5738e10652cfc2fb9844eb18b058c1de564056557ad6d61f61458c4c9842c14a3a4b50b8f020240d44594832f4520d930b3ee05ccf97740079e6db544560e6b7a39512ba139fbf635a91542f30095d7154bedcfbca13cad8a2996912e8cf2768a1702bf62afb7c2b57bc1148f6f92edcbf7e0ef2b924b389538bbeb63f43a55fdcd256f6e612994fd3a96e240b4af2a2994196f7374516110feb9981570fda4fb468c56d15d9fb113b24ea8c6494bf71e8a4b1c97d023b9536ffb0fbb22b05204893ebd08e34afc901a5442fad3d344fc3e9ebfcb84f9819c0142a4a3cc3582d777ce6402482c04393c4ad3726eb93b681edf06b26219761a775324938693fb37c923d5cb7160cca483e64a2a9ae468e5fe1138b745f50adbd130598d171e3c49b3507c554a43be13d753bde01cccbed4dfe46b2ddc909ce018daa1f2237350aafbe32c58d8472068a1b4ce914a001732482af012f75bec4755543b8cd8a30512eec78f706a5cb876ffdb787eb3f143edb1b3a8cf275fc38edcd5e05ff7b2a7547a3e1d4e7a9ea9e3fceba3f8dc55d1ac33086d2f83e5296f978e4e96cc23233f811a93b13ed087c560a26e28d7ff220ad07caff4a6125238ac4ebf39292fa15687a2a8bd38908cb7e5b263e51197b8739c4336cbac9fba67244b964a2f03b275b4735328251dfe321bad538b641822a8c682a01b6b460b1f0682f38d45bfb1a6b44cec2b8f5dc3d68abea7aaad84291cb3839742dee58f10e5c42d18e897f77efed02f97a715b29189ed26ebc0c0be9510adf6ae339f011ddc3fcd4d1248864e0d841ae415e751663a07e9f32e896ba938266df5f14311dae9610661623a96c66257ebf3a2db4c6ed287015d02151a5c204fdf210377b6c43aa4d5dc6ce24ff99d2f11d6d32996ec37a04c5a2c289e8048fd9d8a2ed1181578601380a6771d6dba5930fa8042143051c00328d381d5edd1e38c5b1c2d56c86abcfacc19854020f9771426af0b6e14f13d537b6f8e31a24dd84ee2f5dda5da5c39428cabd5e86e8340cab8f5f5b2f05114bb6fc0a6b83fc7ec4ecdbe2b7553f98472ffc2a73442df21df68bc6410c93108d2ef47b6fb7607458a95dbff4ca2b75e5cad387aa3c420fb338bf9b1bf69ba23a6cfdd5fc628a0556e5758b2f8547b3f44497489bd748e4972c7d515b639adaccc5d4068c6313487469979b44ca0ee293010b22cec9e1cf4cf8c9bffcd469cb968924edd450a89b2f3e0ec61b1e8f8838ae848864b706ecc21dd51a9e04698da9faaca982241a31d7694978651ce9f499affef1613813ac58c06d6b0de3913e6fa470598e20589b8a7d0ccf79fcf2349596b602f73290a4b2e847d7cbc12ad2bd521f9a608d089cd83a731067282680bef75837858347ab5d589e10eb50e5d6f57f01d4ba7e02b3e1d1a81c7ee0a1350b1647114270435042fdc90c6e9480c7b6400b575c7e2ad48496381621f7405a2d0be426d94212d3187c97d7ae50efe5bc6e0b393b84da3c22bae3790a87a87f65648a8cfb2b6ffc821c9c76b8209893b6ad207cfae6ed57bbce78ff9ed1daeedc36ef2ecf405d794435225a550aa5be7e67e5a8ca5a680f7efbf6fde5d9a305cfcf6cd15a13b5adf973c1066440ddf2a330c6ea3dac4d5e4a8e69dbf2f58f8bd35cff7834049eedb5c95002ae98b7becf05f00fb41f581f4aa963cbf530b6e022e78d33ce9cecf9d7533489c533958b5c1506dbc766ca74dd2e288018f663e55030258050b85fa4fc5141523bb3be7dc37409356dec07da4495cd1675a7c9180fad17d47f27d92a64f0b2e3de5240fd96090a8388211468bbb1a8843cda2cfe160c4809db06b5452d449a5abe025ac476e5a076fa51878254a5c94cd7ff1fd94cc239990c71c4a970605beaded0d14e1568249e50e1da64192e0ff5caef2274058501079e9862a23a2d2cc065cd4d43c3a3320ba493cbe1c8053fe874b672ba02c5196f42aacaa0c2c7bc42e93c37b829873ca42f9f353c9f878bf99ac15c42e3b6385aea5c06c1fb136bf6e6dab0ee3e7a3c8e5d00b9a23503b0d3037a11338de939643426b8651ecc113a485de8770471b480d681da8c5b4bdbe719e3efcf6983f901dfa27f32a142f3522d87f3623d4673f2fc990115fdddf04beffd95b9c7b98c84edbfda822b8ff816c58cd22703df158d5ad6375c97b15ee699690c8b739fbddb5af4a647c232ac81c716f97a45b30bbb98529a4a01382e18c26c334ba1190e5de0b90580548fb854479bd2ca6319299f5d186975c32e23890c24ad0e0b8935ac12f60095f9e4aa90a8af1d4b9c8a7f4308d3fbf726f6793973ac6c39f6a4b08188166fb952903e6ca38c4b4b149754773cf9bcb06d0c9422ec9875599e5167423fc5139f505e1e83c7148906242d0166b0b731064b61378df02c4846d2a762e40671c1e354a589aeec46715f57ff10b434f5f99e13955a157f60caf42468f91bf92388bc54a4533e7eb27074388101cd10a91ce486dce1b28535cac0ab6dfbe177bc64043369d2643980be2baac3d423d71d63ec7ed2af6470919976537e59f259521a1b823682c9925fefa8bebbaa804391bcc1de3d1566f91b8253fb45d724d56f9226da406c61fa8dc6eca6edaafee3d8aac81e9ea9dc303e799dfb9a29ce47a78614ba6ee70741b706fea8c4c9b48e764b70b4d94696ea5acaba7d457c63b8a3dd87154470f5330b3bce8ba9150734c2dda19c11c9c69389cbe3a5f8442ae7957a904de097ca446e5c5ff79ab7b5e77ed0e3070773518eb03c1d1a331098985b85ad9265c74bafd56740de674512700d2d58e4152fbc9b403b1da6c6fb1a97e061300566e788648df9ef4d5d0d71b9d8af3b309f0082af71fb4e7d942d9a485b6c3334268c9d133a718fc4612a97d80de6689af80dcb17138910d4d7bfa05db9ae3dbf7fe7b9fe4bea7f5bbe3b2eb54a4c45065bf5bc51acc3ea62444acbbe0f14023245ea528788eb4715c07545d2d8c18bf3987aaccbca4813821532dcffd5cf15ff6f6ecc307ef35447cdf6769f69543c6164a0eb816b28f7245da2395c9befdf641e1af9d347d7cb20655cd5de04f10078d0ef8a39eca6a6d9852a91557cda0d0880440bc2f2115c60212fada625e1bee1435372ee47690221fe60ed89946d2743444212cbbaf398898a8b1f6265ebedf6551353aa91dbd62477fcb9d4be52f17a2da7e5b0201e84c27da3632d565888fab35f66a232341819c532822f9a20027159e0851a6d81273ee1667f1ba4cf0b1622df9c3c941b7817977c9f29c9d15974941d82c4abbef43a7a9903c204def917c96ec54a6d0ed4738946abe4804c1892b403c3db11c88bae10d2c764866031a9f7650ef17c61dd5ad199c9ce16a7e25a2c4ff76fc5c6b20049528aad6fd094d8bd9c48dd1bd9cd3c77bc8f20c54e7e30928469bb309fb55b1ca0fff223c7f484669e3d8c47974e849ed0ec93b1a2d3cd23aff5a2116c9974d07189ecfdc126c586f3874ffaef28af8f373be88e5abbd2f6fa3fe0210f9d64701703521f7e8adf8b96d6552ca000d7b63aa5a305c9068eaee3f2a1c37f602bd3f654c5d2edece3c5768ea276969d67a04f17cbb58e06620b023e7037a5b2317b7e9cb3b212c7ee9b446ff5c22250f6e40bca78ae47639beb870446e6797a33b79fdb2f273aa031f878b4e43bb5030575b35c2542729878d49e7a07d6cb567bbe955af73683a78df134c165cc98691183e9209754ee0f12b42767954a438a190e124a30b31a14261314c73aafa0db9601eab1aedc2a0e1aaff04e83be91170093fed6face17ca1ce942495fed5032c9507b597490207eda39cacd7643663b06cfc6cb12db847486f81ae5afebf96e6bd364006c6689fde59acfb77fa03485748c02e6fe24bb8aa7e1b772bfd9d23c8073b0f16e4b0145cf5fa548120267eb53bd399e5d661a19b31b465fa6875f5b903adb5183d8ee6f503071ae1ae2befb4a7f1b71b03ef1ea7a5f66fd6c41e282ee61373d229cfa0a6ab965a4b55b00b2fd554c1e8f56fe9cda4c23f9cf4be544d22a32cb9c7088df084116822df96f5e5b1bb41a4f2a58a218c278bbfd4bf3e76e647b20b3ead4571974be4eba17961ba141025e9b6d52a5035a010663fe4a8da0d85e606644f2c09015a0359ba3c98d3a1d2071f2f03d86d512892d47e23570fb00e67373edbe82d2a8b7da595e7a632c44a1f6235fde69ac15601602f1b38b4cc415a575763e54b4a69c6ea6ad6eabbdba79a92d0c541ed62dabd6f0c3aaca7636bfe93cc735d14b4b6504680e9a4d6c81a5eac2bc297177181670dae5053e3ab572f1fab0c416aa8272bbb1574a3ec1c36e788e521d2a8e1d1389bb10d42b8952c99577baf78edee76eb7290b75390423cef635f583f79ff8f8c82b9fb6420177efd799d353e57b2af5c617da4915fc4e5954a27ee9aac50be56c89be6ae8946fdc8e7930c176a63f43c0bd723db5da56d032505ce02e7aa542f47430a87789dd0d4419a6efc6995b666085ff912a60b885e5e70549c14503c4910b9eceb6ac8dd001a6297ae7e98d7b5bc35ae828bfea7a6ea38a2d3dc694a9ce79ae393c5da5e42960ff58dd2056869ef6ba2f715f9e2b06215eaa4049bb2b18565325f66027d3fd6a38479338965e8f53e8fde79d47431d3c4797c37db250f08b179e8edf098197007488be9f658e6770486c659308fdb3eb4d18058291afb485dc635bb7378711cab938daba40555c99a7333be245fc69d740de7ea9580c522841da3533ddc9d0eb74161b62d90bc093f17c718e39d530678c853c945b8da4bc66143c242232b9deed5eda403955dcb96b888d58434a98ae10f50558662d06b140dc7020382a5887d0707aed3699c1a97225c0478edc87b002c485be6f6a9ccf2f791c0f671a441b4397202716d709ddcd15dfb5c65f415f2d66b0d3d57e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
