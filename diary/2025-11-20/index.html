<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74e67fcb34ade18955563980a777cf60796447f69c118947c74c76e4197c982d4d1deff4b2c0fa797c0f51fc3acec4921aeae1161adb747c33c9e1e3627d8fc3603352a895ae75a1f44f0b14e62d077e66d870747d2f94416b05542eaa7d9c265fbfeff93811e86f55f0ebbb18587ba687068498fd88a47514f9d0c98b7c2184a64d64a6a8995eeb891265afa1b66ebe7dafb2648efc04370bb7faecb67cbb39ae260420839c39ce00308586222e9df552436b4cdc681339eebc53f47b5730b325871469a3f921eeb424d99f13e6e151eadadf33d56abfd363db12ebd493017057303e8b21eee9709d985b47ff0f23ce1744cbf0fc8537d565890a2d744159edd910942eb70bc1b15c062797b8b099c3aca888a4b2cddc1b51439e1542f900512c4cb7100f5255a4b573292b746da59e1cbee12ace04332279c72344172428153b368bb7e8f2723a3786994dcafdc04ff0f36cb777f9eab76f444082e98e0ea8de07115f0e7bed6b040b165cc556d143bef7a54e77dc66e2cf7d4e9811923d7bd9f6ae037caea85ba3d89eeae75d74d2301fe0557e62780f189a465201f2e38aed97a0d131636552361fb39092dfae1ac3f6a6a91c6ada5b8c65bb374c6dc0653a9f2cee3e9970a70b36be29eb0b6e5714bd06fdd81743805629ef6c37fe92c7c7966bc3a7141a1a47ac27b7a3591a757d5d4fe59b4ece769a0ce956ca97c1ad30df16851cfcc4dedd42b477a2792fadaa0329f1e33949b21d99eae73fea330a3e26cbf4abc0a493b0870fa07697fe26d726d3b1e980daf98b5701aecc38891b40c2bde3113099a21bfdfdda8147703c76fc34959b005d826b3bd84d713b54a8f85214953f054318dc45b10dbab80d816a1fd1b44927a81543e35a2a75767984bae8f584f2d60f45bb881cab1ea27e883c98f272774cfe4d87aa5b3ec9e5cf21f7b4d8599f869705a6c47c07a0aa6e48d3d99a9a3981b972779d68517e80bfa22084fc6f6f32dc9e7cb52ffab4557a3c6d2c6c8d5cebf3dbc22caf8e5ced6aea8dd9282613ed6a28dcf6957b3aed4a94d463f30dc29362f84a73cac15d7378e0f61b7d2c090df831965bffa6192815a7ce9896c13031ae22f8d2b663e2e01ec617e7478698ea09d945007a0d99667fdabc75c3ffca431f7bc46363764cd4bfd6d8698150a8b28139bb4017bb5b2dcabd0b57f3ec030bdcaf23e6e034736d8f3a013daee664ff501846a0e01f54a49649bf9be706c0e4516a90207183e4de970c219f4890afa6e8653aa26a9dc5b4e719caa4368061066effe0a8e5844d6ef3ce12dff4cb8de83178dd6a66824debff4d58a41c94676139fa80261bde0dacfee4ad99132b3753740dc4e8247db2e755d427aa0a3dc53f2713e201a4c43b5ef6ac53a42e04a69b60f6871a45dbe60e736b05b33f2213a220122ddc4dc0a5af2e1027c6e78577934569069fe999a75966d45df86006323063ef9647c6c8284d84fb86e741ef490fa663ce52ae49bf3525bc8c80521c4601c1a020ba4f07014c90a5529bab3de09983830b3edaef127d4a1578669b32ef5151618cf3a05aa9a0c0d6c0e1b75824898f68e5ae4267f41ac3df8f1d23b1575de623ba4bfa1c23612e375d8a173f0b8dce2de120e09ff5902499d5bc02a5ec582258bc03e10ab78264bc095b4e33e867cc0a59502f0cb15c44abf7c2d970353e4439a9b8d13d2c6533b77da7cb3473c7b2556a2b4647c82ff48c235bf8004d1cd7757ec19d43c0503607d9c3e8fc748f21cab6ac7d65c8737bc11c942d88af2158591655af3970c001b399bbeb41ae1c679b7a7928d18c9fb28574469246e8cef929473d3ab68ee7748dd14ce25f19d21c7d68c5a20e571f576764008fb22ef665a8e1daa5f5c47ac7c94fb9dd6dd3fdeaa814036a49aac7ec7231d6ba7a65fa8d308fd1c3bb84ddccc832e567c9f04b91fe76b07061e157ea2d559811404af78613a1775fd9df9c955c1f83a5241a741fd9fdda9cb3d6318dfe392406670e1e57a1738956030954ba6bede8c69fa4b5c71dec9b7c9cadd9a5d7f6d58d295350b651d592cf342f211776d05908755a09c5feeca5526503682cfd461480e371347412ff8e26e1d127630e2f29e24ac0d759e48d53ed9050e92f7a170eaed28995ed665ce2a72d517c6db9cb9e342d8f1bd5390660ae629461eee07d84bc65b571fbee0876a93b99bc01b55f637fe9fba382f0c70cf76f4c253a9590c7bece1ec8eac7197e07bb281de0457bbf8c377dbbc33ac0ed3135d50587e2c64dc200b9974bde3b823f8d43c2ad7361a52b764cfdc558cc478b55fb4f662f7c28288d8a975379a06d457017716a82ef69e914f20d7f76eb7566a3aa02806a0cfe2382294a055f9821a659925a6a5166869a8a78204fa8cf255cf2983a1912b7f2ce28af5f6db38704a58cfc147686ef5a0a1e5e9649d69bd08c09a68ca4a4890a0a419a81b69ecd1d169a1d70cf84c04f1f8219cc2d9d887c84a73c9faac6f02a1334b5d20f2e21555ac08d6b41e640ceb8e6fe6c17d5186e7df8a1e0809f878733728f8ef10c0b35f51153e6faf6b5ff1b36b4641fd6cdb3936c61023038541175e639529efc6018405f30a9cd5aebd262f986477caa54691bac389a464511aa6792ce82e279609ad430e523a477c3328e6864d801884a01354ac344521ee462f9ba51c4a6a0afe227068c96a538c74d1c7e4bace81f2878aa2683d5d4edb30c704b4e1b4a10f9bc5e0f57a22dafcf0587a06c04e2baffc940637346ddae540d2523d9ff0417d31e562ebf6face3fa87fc894877dc84e32be30b7ec4cd7c1933bc686e8688edcb31b33322af44ace7196b9f31616d0abd27e27895d30a23952efe4c30055771d8706393afd5fdf4210e1ddc4cc23e0fdf8558ec5beec4eabf67ad58efd41c1051219df077c0f2ccb6e36e20894812ad000bba8a05ff3e8d74fc086985a6332f119dab6c50e093442ac0dc8720d75fc5c3e1e867f7c46550217d2f36311355c7fa32425b81180e0e6aa5f74448f7eb7433e49f26f03ea9b81a80d92e7455ce962d4d0adaefbedd41b101a2d10890f533957f0a153764a6be60b624c4cb685681acd64e8a5cbc10163ae987d127b2a5d8c7923b19f16481311fd320cb139712a2623e3618a912944b0792dfd031c800117a1d0084d624d5dc092191064e2235a324a067cde701dfbca29f35910470caeb41f90bac6a0de81bca32fdb68efc81c199b75d9e4f7fcafdc2614dd714cbef1d5b3c5c35760fb0fde62dd9df2a3292160bb7d230fe07b07e961eaba726eed6b5bf40a15d98908380e46dae165fc73dc15cd2662d8b4d8b658a29773b890fe35c023866d0cc877880a9e0133cf73c964a354d8f9541f08880b1ece9844efea2bab9f130c6f0a19a6052b9f92ade3296788de6bba31404ce3e19b037044f87b6a46a85e6fdd3917d0be552155a56bff0eb00fc670ac6080c237774c6efc229e9bb86a9a9287fcda3873db86cb5a85b32397323816484e139e29f9047486255f82f890405f9a67d9eb58b50c1dc1be32b5cc8b901882e79eafe5279d0e63563cf296415ad2159d1b14c5655b068f80dd979ff2201a6b8d166fcbebd803436377944188ae35c83d56e2564010eebb2877891e7e7861ee78352334600402217ded66d8e7ca7c48a6a0a3fcae53dd1462317c0886f0a161444e218fc16d382e343b2b4e1295d9ee3323921f11533a081088fb20c168d6f41f4ab8baedb548f4dda3a8d266b9e96f354ddad2044dae6b349e024d42f382101b2c41fb7f9df14f2f9aaa3bbe9d8795fcd12b031748dbe0e844b83a3533743b55b1369c31674d69f47db1a2444d89fb53124cb198f56479fb79a640575d60e0f558b9975b7efc90e9eb38a8205353ce7556f9e1c7594ccd682bf856f7add0b54cd354356b11c5e822c8a213d256fe3e6f61f8ef55f1ca6d481678e86466d54932bdf6f56a38d3a7b0ca427bd036c9bf08d002a4a29677e473864f0816f82ee18ccfc75053be1fdf85e5d74ef03a6bbe23c19f3b30b40d56535ab34c2e084de34a2738da7955586350df99eb6098c8df164206b625464b5a14a1ecdc30460d699fc63801d5ba8becd95b3dffe0c4f6764cdfe0fd063448bcac177205b616027d96066998cd980cdd0d6545b7352e235b2e454108bb320049345ea013a2f11da3af0c8f5c82e572ea5c7360f83df5d3aa0de27cc1fecc7fb735aa62230ef80057666b1953be2d91aab96d35ecfe0e789006f7ee5da85a84a8b6a903d7cc7701490a98f9d5ffeeda4ed49c91c769ee7bebb519cbe8e3ce459ba6e77d29154dc0ce3dd1750cf4e818a1b37d578ad0c951193ee8c9094fb4e620dcb63f8d04caa96a155142aaf1816202519b36e18cb9af5fa626c6b882e652e58caa5abd2db1632f194d9ab4031b67e654ec83b181799787145382152c434e40365ae05d69d427f741aed364fa969a5d51af2beb489bff5103fb0e47472dcc2c2e36c929725ad2ada575ae77858e11b44e31932d8b78b6a5a489af9250ad43973a13e2f37b9794666052fc6f4e219fdd9c552a515603d6e8319d4477eed4f6a1ceb75f16bc49799d7564fb9c0743684aad0ebb717edeece2559bfdcd0d7590ba86cd7df89d9d38179e082be4bfa7257c2920c366caeedf7ff3996564b7944baa06948cddda77f2766da18fd4acfe7d56da6e95c21d61b0fc094eac60a4f094db04cdc1f5f3e0409384aafc11ce910136f6b475246252c243bd82ba8e9bd86a1fd22d6005ae37698b277e0d332846a2824b7ab354a2e3038efcef7c83847e610e331716135707f314d34a26835cf72a3d4e1da0c66e95759eb4dd5ff583b3761c1970cf85824d126df99147822a1187992cb970e1c15716ec2aaba7cc542f1a6ac755fa62bb94af0cf72e07d64652d7db9c4748f8f47baeadda6e7b25329cda7b29d55f1c17bb4644b23d034d2029d8d8a44e0dcc479c36171844d8061fe6505ab2a615e6ef6bcd15e31c1533f24c378cf0ca80c6890c1a28a65e079c479e32277ed677970f23592d8afa8654c02b336bc737c1db880d5ba4e01b78512eb94524bc65834312ebaa057bbab554367c681b571c8e7419c920d4c8c55be7eebeda622ab0c372b8eb0fbc5bbe9f22854d0e1eaf7c3ea0a1cbffa212433f07f58224e1929763dc3214f722f6cef62cdddbe4173ffc60196df53cbef2cb673d62d6059e40e6f6036ce960cf88c99c095f9d7c5e60d2152358cab49f68e538e461497bd648e7d3dbd37616b127167d2d8a093a87c0ce0dd24f5bcc3a0858b3c1420f02f062ce734e9a57ac2cdbdefbbb030b7928a1e3d5c2679281786636d2703608b7401971156d20c311fcd7490c4a1e91d886da121acbfe8517657b8c6b417befc3f9b051efe4ff6b0c89ced608923024a29b6c90ed7bd065202ddefae8af408fff4584be425885d6a7b87ba127c07caa074b40b46d3cc7179b6dfec9952aee426d55d0ede61887323b0fa337194dc02ca227cf71246fa8f9c0b50e785859e07f9010dbfa12e264691c4012319cb84a4ea4c2f47e8269b8752269beaa402a7c13645ad268b46f98f68907bd08033a294d5b670651b157845b425d0d8c75304ed76fb31d66f095be0d9f503702a69509a2d94b57988635c86542db2faf2bc171e9cc41d3f2d9beb9fb10e1dad60ba45db79fa77a2de4afb01f84f095d05787a35f3123e4e6c2ef36c0234a5a3389a2a45a2c3ccf39b67364a010da43830e6f0cb2e7f8511c52dc1e3be0ada282342899c940ecff7299ab9cd479010700b55230131221d276ac280b4d3901798e4fda7008e0510030853768f0a928b10c193451d7aa9d409bb9615802383f3d2917e71497e7ab21cc11957a2a1213570eb9774fc637f384e6c42722d225c8abb0b3ad90d875d1de8c87a4cf06b9e064b66f625adf2d466d3cd1135bb2879f08c78aef9ff2b7e574b797b54172e2a1304f5b97fe95d4b86dfcd2cc63ae7f94c03f058995571084c2e1367f61fa27133cfbedafceef537e8275144cf8950efb2842f200fada79071ed8756e57e5539febb07c554039b1d0b33735ddb839f8575b7e9093398e37da6862a6c3042fd259f604fe9992e1711c6a8a6cba37fa3c9df09aa49686dfe3fa4b1cb55793d2e10c0ce043d005700db956a0b7e6354ab23193b477d2438b4c8ffa1066f941db53379f7ab6cee3c2b23869bb0f28e57786f4b9cf9cbdbe38d80eb91135391ab899b3c710ad7815fd4a17f082abfd1afc2ace55fd563a91ac31270fa9e1a8cb3c6e4e288457be4bc7dab680829a1303900c08f3db9bf040c099beea86092da0ffdd30bc8a6f11a894435528cd52d86fcf1feafb12e8fdecb82b6e9f7ec147055cf895af643f065da14f26eb7d7e9de6d9fa4c2f79c41143855348f2c468751402c1779a8ccf15aa6bd67891b8c4697cc6073fc50fd14e43fff9232cac519d1a07d11c28eadc440af5ade43d1071863bd00f67e1f0039b604aef3e92358775532420326f7bdbf1b34d3fa886969d1fafdef70137c30e97adea1b14f314bf92ee2154a39da817cd3da7bf957228de123e18f4b4236e0acf763eeb8590a7845e8109a906a6a69ae02fa8e99837258150097db86d658f3b97a0981023bd353b61ec05923a6fa75a6934e2a632f196441829bb885a968db8bbe5ea4dbfa33c8fba509739036d585dd35fe27927bc3b98a89b67e2239da64b3fab999ffd4d78f937252d31b05b1dd8e526ea9d8be2ceb49f4ce18eab66c391c82a4c905243018127f64ca71a00bb0c42b5d91ad6e569944e52efb6bcce804c07c65087a82dc72512f93df03e4b1d00f0f486d1f3d5ce6d0bcf6a742a1c871841651be785d671e1495b7062f6498c0f1d4a0243d09e60dea3ad81734ed0892fd47650fda90aaf1fb032817b0ea2540e43ddb26ba254b9fab8cb7ab9b45113ea4990cc78de0782eefeea17a034c16cb008385b44f2fd4e931625244939b1d8488b068ca4d866af53652770542278e537add777e14691036cedfea31179eef02760a39f7e1dc264d438fb026664ddd2fe11c98c27c064d99f2e0d88d5431b1836874bb919a56632a82460ac8c28c49edaef59881fd49ac05ca613888ccdde5c19b6ae8753229537e68aeb04f64702fbd88bb7938a9364e9ab2d2867eabdaa28b68d1998711a50e1015b3352b60070b1c230f29fea05a74b69da49635db12877c5e7f2f38bc5cb07c28a7ba850a0e8a8a6128f25249c8adbc7e3c02fc55069f7663b55b53ae4a6019e21335fd4eaedda481b2e2a79a85b0b6372f3a53b8d298f2c0f1792a6117807782cee4887fc27a982504c2814071afd625d6945ae1394489162ce4e163c5290da1f05b3892e683cdb5c25b3467b4e2845a62e608097222e3064c1a1bd828b7a8e5e73ab3525fe0e6be2b0c65ca2e9256af75ec091239a40a4c8f941e690932d042f0087fb38a2b857aaff915ebbe624dc5dcd312b3c213e49c8f5852cd58ce4f2f90731c34df582fa72804f739a908a0b33e39617a300c678e6dd42ab66a2a8631ea0ed1d475c1cba0e53a82d8340d168b44716db53f00cd48fecfce76991a4fac9a69ddab081787921c7ec404577732b277516eb0d7af2467522f9fde5553bffabc9f1d57f05da21c6db51d3c301aa776b9b2facdc6e755986d8bc55085bd997f67614c474d4cab8a11deff6a63f8e03f1526138a6c2beb6f4b9c4168aa3becfc19ee4a6909d68840b2e2cb3127c0b2ebdadbceee71d021e7daca22e28083b33a4d26450a22a89f3529fd638554447011d8139816dbe9b87b2c3eb0d1a9fcd2da214f5464e9594dea32d2b897fc1ac3cc54b4a02ad846c50b2e74050bba0ace4514abdc567e45465a455249fa739742f98c1a1ff9b5c8e6a1304b9c2a694ebdcaf09a156248862723b3b50790dac0849ff7e8c5b10dfbaa9da9313d495aefaba43e5d8982e78c95d3eb89c5ec84642ec4eae71da859cc904f3c17f05f10957653eee4eb7bd55eb6c5670ca2c999aeb409f4c5144c5db20bcc9062c4bbbe5bb4eccd8a01288bddb4dd64031efa27839da651ea238b17e00614477197eb27e7c1b4139edb345fa6fa83dc6db46c8fd4e5005f7d326e81feababacfbe7bd184e3b69b1fec35e49e3733450fce70800e93ce40d96b8f4f9358b1e6f2486801ddd2fd447188a340e3b9550f6df4ad3f5447498c1660c390b9f75d4366320459f8e89546ce1a8caeaeedeb9deaa973657b8085a83fe1c95976d8e8f54c83a1e8a1d0ef054262e7fb6b1f14d3e304b4c342cd324be27aa07655a8707b5136aa2c8cf3b345921a1f72fff812309bdc8c08d3fd3857290610a63700366c00b4bddc320485f80ef16d9d5e185b1cb61cceb7e7cafc3a12cae990fac79fdb42d76d5f1ce61e91b0886612a4b314fc1631964bb5ddb95f5ff0af9e21b8087c1d42e06bf20ec9ea4b1e8cceb2b2187560982994622e2e1133d7e6d3cf9d9fa2af39584bb0d0c41b4b9576b297b50e218c699058cfe39be7e51a28afa7f2142a6540f19d8991c3c11dedd9571efb9fbb0a82e7b227cad68438d85b762869a3c6ed3d4e53de3b4597ca16d355918a46b64bdcac503056bb3c8c9da541a32af4a03ef57d1cd7c97aaf86cb5047f95ea8d157e1d5ba42a4cccf314951885d8188af31c53a008108fdd2cf23c033521b2eb82f37e76de8ac676e2caade6b1ea0aeba02ad15a440c6ce5aaaef9dec72b4a52131f46338e5ed1755e698387741c41e9822f362cf5438209a62c14de5468ffee4567e533fc03cf6685661ff4d0a21b536dd4be215a6ae9dc4625811968addf72f42da6b068d664bcbb2e9fbf68bbe61afbc76498217fc25c2664badd4a4f9b1181adbf36c5568e7e8b162f2da4435522d1dc42ca8279f908d545f8b1d42f25f332d0e6d35faf69c974455655d2cc226776c21d91c1cbf23ce8b0e39a4b201baac82f5348f10fb23b7efc4d8e043c18b37e548ed7ebd9a471e2b63069160c8cee25b30d746b73875d936945fd25b6a43384e01a61961340c7213dcdc29d848db9780a11b4e4ca2ec7c2a5c3429261fee87c7731c801e3625713b8f1f452a2d4c2364c136b0f618edcdc298fc231f18daba981d844b685c278085f8a52b0216a417d0473ea107f595a88b39f0cbbd929fcb729d76387abe6052c95e9d4bb1a8daaf3ba4c3de3925d1851418adfe6b25371cba991c284b4771b13637948212faa843ba3577fad48d1abd6d618895e5507f836eee25bdc666ce0a4757f1f27a1dfd42ef6803e9df7153c57b0f7bcc16ab1e9dc8e0f76fe7b62ffdcb4b815743d4239f14124c5cb6f51c6fcc4915c9bdbd2b310c2aaa92b4c8955307fea430b4d67a8a8c7a41e7432ca96110a0f411bb792a676c56b93d9b1039175811cf56db44fc0c2250f517724971f3be9efdc4d381cc81d5599190242dcc39c8544069e4307dde63d0601e0e0b40d58eefa93a9cc0b2723441cbe0bb6dbc946fc89d0d702dc9fa49d95ce8c72c8d97ab90312ce841fed9ac307e67bf2d3fac7318c3d8322ea4001368da04e236b9ef3a57d0e93cbbae792f793225e521b63955d2ce9076381306bbc45e730e2181e3206e056951cfd8f0220c653777498a432e188dd57f8bf3120123bda6367457bb0685703053de86ce6ae99c5510d8152d2309f02fff29178fed8a05408ad851726eb5cd7cb358c41f499a1b00087de7afa193e58a6b5e44f467ab8b33f2815f895b3e049d03d560d6b97e71e2b13df030100412b04242b59487bd2099a4bab03927279ede31025f51a48119f1f41e733df7d7daaaf92ef32795b19e400416e618acbdbc6199c5ef831b65abfb41029f7b9832e97c9d085d7bd96965eadd54459f32d09e4fa22da0b2a20257b905d6d892b42f95b6013336d33c4c38f9048c74ac7a78dae4aa8a0bdbce42fb814fa73d696d6839bd5dd8e3955a33b3b5efe4646ed71e4fa773acf0cbc07805be2862466e062c5fef3c995fac80d476acf83e391b8e0019efd8bca4839021b02e85797e16058df450179444c71af3705437325ac2ae9f649b76806c8e0ad09cdd1e246fb3d5dcfe91a9d6b394f443da961f81ac4ee1fe324cdba0c4bd9a36a4fd3ec0c3ff4d837ffb9d04252f4697b19ad215f38ef57f7dffba24ed4f3a09849f1b299fefb8d6997caa7abe97023dcf50a96f7e8ffcf1bc0dfa2b47bdcf64d092b16eeed7360458b430b5774402d15de5c685af8f953a1d37755d59af02306062e32b7e665f8c73f71fd6b93df21acc1265ec750066aff2021aa33b4c75020bed462f2292578c74c3f31215f8c05a9506f63984d80534b57a52ad61c03897623a93b7f2944145b5b3919a7a16570e5bbe0b66a906eb0913c33f6ee639d1cab3574e7b66303663424a5ddb20aa9e687cd5bbcc27d0a9fa6b4ea098f417710854d5387d9c9ef788bf98d5e7f7e7de5a4adf214342cdb2ee91f45cfa3ffe7b83c541c4a6d9e50441e00fe75cdaa2d1bfa15346a7b576d493746c22badb790fe167130ceee00e9ca7e96315a021e8fd36d2f1f79cf6090f89572406cf271190b1eae32628b41dc782196f6e6d18429becf1e34e56488bbdea9cf0dd8815524415ac5ae49cd41d5401518ae8bea8b4dd90d030dc459d21422b4c71400d1d719840637247903cc4429b0cb609aab46f627c947298f8110588c943b3d0c27baf38a8831d5f7d617ddce43508db1fd7da28458679e3c475f46e797f8bbb0cf3a866a545c35899f8b1dc02c42bfc3578bd472b03b0d359ee6cfb266e2c37fee7895b0f68802e5148306276a2e92d98c60516c7394c52790896574e9505f67b9dcbbe2a3ee4cbad71428de0f2bfa5313cd158bcbf146269a00d7983c6ca5dd28c99017b7d344999c9604faef32be873610c1c7f1838f07c5597e73748ac0e2596009a5a228b7753c5fe59fd1a539dcd4c83c04c9ee57bf89a532c1d434fdc0bfd59d412ad43a689198289e3f11aebdf88d9f15b9c4be9fc7d21b9f8f315b1b8ada117280332df6af88778bda4888016c96f51489f807400604d1b791e24297c14f97489db608dae3def60bf7ca67474effa8f6c3dc91a53002bb3613909bd086afd95a11e9dba0de062f5ce0d001192386bfa185a0cae069bbb23de2099afdf3ffc362177fc6cc1b8bd098484a83b48e6c141b69e167482be61cf60f35a8112a00b094f02cf983d11215a5362621da47d303c7bb50b8605f2b512e94173a109288d957ef2fb95c0079750bb6922fef40adb515263e8e7b26c5b7ac1685b6c573d6ada0e2167cdc5994de73ffaf6a68a837e8aeb263a8102eec05155acd1a39ef99fa80dd3c96531b88e95276356000c1c3d8173670d04f646393ee9082aa7640479606e1772dface542c787e987a4c2f206563725e5b4b71cf4358fdcfd394af8c3956c4949299922f0041ebc18ec73821634f6f5a92c40460058789568af57661cecfc97874230fe56a8d539fed9ea8580e0b72252c7cbff604c161175008ba8770fa19538bb7077a42cb2de76ac6623f43e9d698eab756a18c9cd782dc20a68c8d392e9ea3ef641e93cc44966210088b177f8d1a672625a830a02c086f27fa92f341ae7977cc439da9b377665dbd0b0d79cd6af4baab1ee8bbbf1b25d4c3efa5e8f37c84fbc662a1fc8e5fdc3ef17c52672dcd31dc2145dfc8c0badd2983ccb5fffe2c46e64319b47687387426c222ec781c47f00c4b0b228e5bfde52401fff537faece485ec82fa2427b8db6daa63ff429aa2d34cfddc27febef7e74f5ef9158d1a394eef313f9c8ce4bc50bfa60858d4059f69e228801bacf6774e063092448b125185f25b8226ec5804ca1be723e3059d6e80a6e0710621abe77d6b98ea5124eb694149856c877e9e49d8fa0eb5a24fef7b66a855a3cace07c36602c65da82b22a59c5e02601fe4e81a3c194365658b3a8c6df4f113eb407d4bb66bfac023393e8e090af090e54af53001613a49ba54da14c37be25d498a079e440843d31ddafe6e3d7ddfdfee8a5e4be551208d1ef47d4aaeb0753f135b2a8e226cff0bc89a054abc0e817c8412ea46f6ebdca56a35eccf2e30990bbb28973a6bb9b0dc1712e122ce3684675c37d0a13b4783f6275ff1bede7df637f2bb47cd0e7e0e8979c02fc87bd8c9861dc0cac11ce62ddc4545681769c3b840e6176dd0e298a0badf68da93914a10f56e9ac16f6bdbec5195446050649a48290e072a6327c7bb7f9595e73b890d7d0b1a304864e7626d4c53526fd2172cdbabcb5eaff6e4f0578eb19fc3a1814aba142122326613a1ed67c29abfd50d2c827da30313a6e9642b7e9076421f2730443be80f486151f19e1504f0c7e95b584af582ecb7f96e5a90c4f24b399f46ba633696f815587be8e6614e83109bbc7325395bc3c3b5db2388eafdf68237d4eb0cf70be906c76cc6a2b1ad210a504662456c593bff46458d3761342cec4d9d67bf1e4e47442dfe40615e7de51f80f1dfdb12e420c3d77a7de6d5e01a0f4852771cd24eb4590be5f8f145009109308b7ed8ac6b84d8c658c6d8f83245a88bf6434413ac511e8f87a39c5c1dbc4a6e83df2f4ada6c0753b4e99cbc0fe50aaa1e3f46febea009db3f50dab399d5b720f1fe4f3337e42dfc31a64f639286c4b9dedadd37c019f73cffcc849aae6fa07602afc61708b8f74b22bfba9a63bed53e634c10bc6a2307b8e046ddc97f0f573eba9ddca2042c1c3d014d0f4cf29a76dc269e1288e8daf19a76b8197f09962053e72b403d4e8c568f7a59d8357e52661efcc22479f3153a1c2f4ba91727de459c12a53b22e9a4d499ccf1e5000eeabb57ae71a2214a7ad1a4ed7e7e41fed680c3d99d9656ebd82ef3d5d8f330923bb70438c973c99d60e7f723634e8fddf0ea0f26e0c65800c9877e4884ba9b64ea471036389a50b5b120b9f82e55a501d374b858afac757c44f32f5023633062df5e85478446982cf920baf7e607202fa57872bb5f9e7762398d501f2378369c5a0e7daffbfe05686230cc7de4bf45bf842deee114a7ddc1261a0c88081c51f9893b4a46e93c4d515694599b39f891851eeecc3541c32ec0afd3a17718cc22c8b74c9d2439d93fa76014f7ee70b9c1d6582dd027be6745be79960670a9448120e50368c72fa1682b203b233feb9591ebdeff12b947817d25169f1fec114362c1ebbaafbfb11c39af57719f6f63e95e5a415fb27e14650fb72abb5f9fdb13f8932eb1898a5df25b7125a314a3043f1822c76eb3fdb6f43fb1f9adb71edf60c253941a72318c1fc143bfcb5e77df00247ba7a149cf16d33e23cd0d345f844aac8ef18bf0b4b5fb142dd32475a42724b6b84284d3497611a368ea794c2d95b645e4ae9251926bbbc054ccfe6c2d6c7913457b72e2fc8cf2d6b608942733c0d175180777478fc9d2f11339f9374d2bb143dae660395d6518e8710df67a0282905e6fff306b8e51d5326fdd69ee4ee42449776a96480a652f8e3912e5014d0d0af1ea6fb358cd3f03fd1fe0b6627da17b770f7b62fcfaeb1fe4194592683de11d6790f0a08cbbed73bd1af6428d8b69b9c5ceb094ee76314fb56e5d1ba302b095af9e36677d3522bbede5d47e54d859ad0e9a74034760ffe15168bf55409b6aeda40fdb4a5008602f7b0ea2c9be782401d66dc48b4ba72b5e7f0cfe6b2bc77e9c8c000d3a68ede66313e53d297814ee8d498b8d2f1ea42a8c08f0286ef58504b7ef69bd5df70a3d43c9ffde68c573d4148ce948da7ff4253fb31252036b7d5eec374870d82c96bbc2a6ae98d61cdd3b3e05805d4bff1e6237216431b868b5811c1cc2b86d34b7831fbbfe250a7bc3403c40fb6156b145f8f8cb69ebd3771753e50ae1c10786c58ae2c8dde20bf066392d86a3a0b7bdff7cd84ca7d419c048212a62073f26bffd370f4a7a4689f66b19f55ad975c315007fca0c6b57f800e61396abca941ad5aa1805f79f88319eb15ab9da1847e2f0131812f46ad6874d34bd606dd8a9382a72ea42b5cf289130c227ffaf0fdbba141f36584f94f04490f6f7979ae1b947ce8524198eaf8f2a378e36d6adeae4360f1553a37e49a986f0a52583ed7694ff7804b8e1414c7446edbbb82a537531c15e216173564c319791e210bf52cdf61157cef5875181e41cfbae7d03fbc4e228a216315a127fef7787053ca9f9628f205395e6576f912ae93196e27adfa63b5a6ebbcdcb089060700b32f9d381bf5100cee2362d7598418af50cea9edd72f88059db28173d0869b016efb9ed88bb250ca41aad784d585c18688f33be32b0dd5997e4ce438fdab3c71e9791f8e2a3ae24fb4c95b92bd4bfe17eecd558ca509fbb83b190ecd70b67a46c2b5d6bd6b16608c805bb5463236259216585f77f348f7ed37d4867688da503b4628d5d4420d02803435d80e60ed32db785dfc011af331f068bbb7d5970de61ad85ad53278187f6f45049fc85feb1a37ffe1ffe27bcfacefe1db19d6b04d9ecf692b9a3274d1591a3cf16a266a0cd70fcdf97622b3f790a0d7eb79c00d189ea21b9b84296d78e892e00db28024b8b22ad990d6a3d0ff9687a57dad286ae0e16f64ef2fe066c615d28cbd06be04b944ac7af86b0499a78b32681a6cdbb663e321a33917e669425e840bb10fd7e603d91152a6bb601cdc71cc4d2d4c3506412b0ea4f3f753029c56126e3f4263c1b2f478e61a53780ea6f012409c7066779ae015947d9bb10dd39599094bf322e4e607835ae4196e84ab3792a32dec123e1d74b545f7802542b9722d805076c8f5894e1b0ec95043d26eafa0e631a1301640143a478427a0d90b57119a6b0dffeb14cae129cfcef4a20e2e501ab24f564afe07b4d808966fa08ea9286f0d3da23464cdeadbf64c8b4703efb9fd4474e23e42832f78f8ba15187c4add3c5a7752b22023ba27538a03e2db79a1aae84070f4eed5fccefef1b886e9bc04130e1198a1a1297df5c5a509a80b9b6b2006919fd16446209812b5c2e4165fa537fd3a0a58174b4e78e7b0578b68ad1cd4766503681bf2976b26eea8ff3df4100e044b08beae2699d58d7d8ec57e1ebf5ec703b2137d342b61fd2fafae036dba681ac576d906867011144e7ce82416f549042e55a85847ed96bfa06c5c23648ee9bced5144f42e97d6c2a5d854525dece46d1e12c0da6e84f12b508616ae68a448a93d83eeb93d86eea290879d0c4a0f3f9f3505ed5f4f611d9f4b3cc8f66e857ea224f477d1799796b0baf25def134e445dae62c2b4bb2a003a53a2322d6b6766c4e764543989dac0747aac4efdf55633fecb99132bea8b71bd3ed05a9e568ac668323541ddbd0fd8b751c5819afd9723b878e6ff5ed7ecb9905e97fe63de1fe53a2026ba28d6525bfa25a2910e7b1907f73d149e7fb77651a16a554c7aecdfca4d760ddc5e782bc7d8de42770c04c15831a380b58ec14d0bfea447e4f2aadeaf8ba901d6de30a4d34625b92105d7e5371af6469705030ab4a01a60fa6f13d74890ae186f2ac229c51e9618a2d68f2520e3a9249c9e8f115bc37e243729e328a767e729ec7af046a5ff51d892a21d46f1bc7db607f3d0eb4c8a52d7dbebefd9713316aa74525377ab7eaaae0b9172517f49e403aec3ef109cf06b0765732d3ac2f0938bf40a70de05f24a5cae5234acaf38ca76196d7bbe0afba941ca1bf58206efe1821a1b3ab9c205df8ed9e8fa4db1e291ac023aee6d45df1f513ab0fefb322075dfae95322680986e3c6c5713c88d7d1168c3f826ab93ff2c74e97d21cded64242b210de7100ffdeb8423800e9aeca9fb7c15c87c6f0126dd0c027c23c8f0bd03d91192073e8fa708692f8c6115c4a41776dfc0f1dcce8db3a9f4d0429a4fa33c61057834c4dc9b6c90aecb97a889bca896f91df99a081bd65cc4c149e6b5aa4590ba2a9af36c921b2f3537e4193c19aac393bad4c913da31ed340003eff590a9ba2e95b1d4edef3e1dc1240fe4b003f9618e2980a6abd942413d438cde01cf75916fa78ee4e8d81fea1162e56b9bc08d2ec65cd00c2f97ba3788254b8757366857166dea86913ea554b6e555604658a420ec1d06d5fbfb209bfb4b97244eab3034bcbe7066304b4d6d95b5bf1fd9e32920b4af42f864979c3ee4d2c38a83f55ddf174122d5901870010ce4349bc2efdc95ae2c0033c0b9366fc9cc469a4e5589c83fb6447390a388125d6022762620e415d6db80d9aacd6111c1337e6b0ef84939a43b7d9ea06464a8a8743b5c3b9e7b069a8cd5633431dd5ec4f2f81ed21115953a577ce03c377d5b3e5c6541528f4e6266308611dc6d231d4a246bcd02ac9f3b564f62a188974b843962ba88651631b992dedb9ee78d347787b38ee93318541712a9a8dcd45f8a24f1e98137dbabd8a6a60cf75e9509b6ffa9f5b1851bba2a443476aabf6fd7047ad462a9e5bcd5da10fe53c7a88e6fdd4b924ed86f18db4c2dc994334a946bd6083ca9c5f47907364924209067ebbd0371ba3af05438b061f5d98e49b65b866c7dc4b344a871b182a8d934510abc746892a52c52f27c66956bcb79659c6bfdefed19b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
