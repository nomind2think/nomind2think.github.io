<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe4d0db159be791de973fe55491edca68d152f5aadfa58f8f1173e5038ef51ab5c9b0b8316fe39ae0fde6b88b1cfd1c91ced3a64059c98233194e1c0efe00b17bf8c9beef18a74860736f2b3cf93178a5c858f10f424d5a87e2ae83340673464ff7a3166eadd73defc4f508d3cb9a732addd5b875d2254e647950b5b291093cfe55787055b3346604f00e3f79209f7e5b6c632b96b7997e380d453daee0f17ba4f831bc4b4d1dafc2bde9a1b174db61b5a5c0006342b2ee7208e3fd46901451690667d269cca67dc91ec98f74517edb421574e77f1b2d587aaff7b452f986565a08e4a943765c4cb14a81b3b62e08bd91a6b1b29ce0d0b61d054d36da9c224ed9a49cc07a1b14da1fbe11f84899037cc0aa34ab1ebd5332bb43c5deb9321ff49f9a21c7b2251259888642a2c419b62772a4da3b1d04bcacdea65e816fc7b123195fe3e02e3e861ba21ec203f959c632c020e128d7f863cdb4e291bbc2d9a4aa9c2b7216faafe208817904272578fa5455489867c6f261ed9886c6e02595a5462ab377acd19f31c4d53cd6f244fb22473afb614d92e8bda674aa2eb74be9693022ea65b9078414cd12fe17213b480558ec14dc5cc23d01e8ac668dad69ba0e909be8600980b19563768de9a08f70e3faa7c478e24841d54ebbbec7348e1ea96ecf15ab99b1a72c4cbae5c00b331e04c5b522631d2f5f23753a21a6923a7a9d31179901b391a6b1a3fedf9527b4febee510fe4816a14ac718263358a564d6e4fa92473ce021c9ded36f6f60f97b427b5971b970b18763c75a6f89db528c0a1d3e900cc6ebb97215baf8da4c45245f41c5e73a68b22053fb6144bc2ffcdc726b27f47979077e64663b81d5f68e62911cf96e723ecac014b1c91a680d864a35caa2fb5c29522cdc37f7319e5b116b0e4a042df8693dc9c7f94c43bc95789f62d1bf46bf05ed78ed0b3241767ec90d274e3c7a25c175734d00685196a3d065f10483d3cdab1fcba6fbfd4c77ca30f7469acb710285760ac71c92f108bbc4aa6e861a72c06075bee57208e968e8c199e2fce0c197d80148bbccaecad7cc2225a4c5a32790152d3e3e408c7b35bcddc3e35b03fc7839701b640e129758e4d05444d7ac964da7f81d4268c133f67b98cb83dbd07fa4966b6c634538f505af357cfea05bfe9f24cfd17a6317a9d0816e948c7dfaf76b35b31934c81563ff8f48a6a6599ea5498ee69c05ec3aba8d3ce8d38937e3e6517cfa3b7d4d678c9a12313d98323281990fdca5eb4a040de1480f43442618616d02ef91f8e2fce5d6054e85aade227fff78468f0106b8b6bdcfa7956ae3ae6b53e40216592ccdb0dd083662ce3f6774265b3091c39c76470ca843d000917c86a7575e55e3db7a67868c886d18faf8581853fbfb6b48c62d871b1fdde4a0f5511e38be416015a8eee05281c4b794995dc1343743ddfb7009d54adc4d37d9ad8f2f2cbb7bbf55e744022c8be7986263c8ad392d1b78ccf877e57c96e7503225fba9b6261f4d80f5ad78b56ffd96408312b96e4bead7370bd77d8e9d13668387fac3b7fd4f63f41167d398ef1c72dd7a611a602ba526b1788fe8b86a62457e544daf375f86fbfbf955fb172e308c8ff61848cdcfd834794d24b5130e35f786958c8d28b25e584d2ec95b3efbd1d50b47708f10c19b3ae9491cbd48973ad4b5e3ed88f05e6b5926f488db8757caaf9c9a23fbbf5c60d1942381419669031d784c6a44045728c0143479623097cd5e7a663b29329f83842c97fdd45067b1bef982dd448bfcee31007b59f63d43dab2b249bda07aad127f2fdc43b3b44c26b98009032f991ad2f37988fbdd4c2f826cccb1fb3ca64fde441fe8a6ef17b0928663fd3bbf72fb9ed4e120ebeac6274bea8b4610e03e25fc9df29db1bd344863b8507efefae0da52dae636f9c5a3b8aea8e0d4eab27c2383a914056d04ed56f7b03e9e25a67b04d259c7bb4f59d22e7137a18fa3ec6e649259f6cd2073ebf24f863919e6c85f1c73862ad9a848c01a3867d2a693946a98de50f01594460d6af4966c847331c912f8aed4b455b3bda9170987eadaa9f800010b05376aae70baa4cd37751f55347e6c53851a0e50c471b3ee9bd7f2f1e6ced9f67d8d5d1d37f7c5bf9cee3f9819e4d9c84c6b463b3c4296c7b7d75e84a91337adf1386433418636a6c8ca38b1c43cde2de0b7fbe9b5c98dd3d573b815645d98d54ee5e6558bd5ec9196c8c7a1eff87cd758dba4551abbde54f4d7dfc4a31a00f28a534056277c6a3eb3639369b5f344af3d7a1e6d30937cc99d5defb37230b18615a262ecd479330adc1996950f084468181bb032008e77cf235bd8dbd2694b0a8c76ee4476b59efb32f2f6a1363eb21c05296a21ca435c88f10c1aeb5ad91e650dc4bba2826113c8fe4f58bdf5ef0530b63e92e4087d3b384108c4461b103f3c8d211a744cea1bb83be18a5a857c4a669a3c1cc3d9846f57526d536a75648c6d417a26035ed9516e51ab14c92971fa84546d39eccca4c21e8bdb29a3840bee9a896bd83c4a1bc95a84dc2ef3506f92a48016057a56a6e9f640886b762b53adf2c2db04cbf6f74513769c7415a6df2ce9852a383e789ddf22807fc9a46ed0c20e3b4995bc774ffc3b48c30d9bf2b69bc9a8fe423c57242051ac3713a46a7ee731eb1767b6064378f5f5ad873281210178b1ed102a83880bdcb43f1553d339db021f5041a321f5c4d0e592076f34f5c2839216009757934f892389048333aef3760b0cb1ad2bc15421e62c8d0f0394c482a81fa265bfcb03eedcebf2f883c774a9af21bacc2845a5306a631cac475143a10b46b5fcf19831083cae40a70e450a828c8602ff1ff6f6fb3323e1c7ee61bb254c3ae70c32f0f757de66c073fb246174f7356db5e2b9cca291863802b312eb49dc8cd6b72226b6f7c8543f1c9afd468794725a172936250a8e50e8c161c4d38c3e42364872e1e09cf056e2828a885a673d60b35cbc5ce8569307b02a1a7a43b68d39c9215e262660ef9e6069a106bc153e36ffdf4ae4c945243b149d507d19600df2ef842d46b0639566768811aba59c3b6fef47ea18d6f1e9ad2945a426123b25ebe118193aa4d2adfe4f3dd46774ab307924eb55b5a8df135ce99cef78e9d84dab677f3b6ddc3ae380b8232b955b8a1d332835c08654b4245597deb37411aa40a2bb4fac40adcbf79d86ae486468f1b3fab6f7be5bc1181df6d57e641c9d408dff031e91ea52bc01ebcb8e51d9706b2cea3e857ada1ed67c23a249177c6b41e238ac091066e1f0daf724d200572688cb43fc89ffa05ddfa3cf30830ce5bb00159f1d402d6c25bc656da847e6c5cfe2185c578efa443113d294abe56c96c461fd165e7b32a8b9f0cca4811e33cb073aa563605c8242ab35743cec81dc4b24f64f8fcd69c4e7e300e6e7396084e065c5932ded3d7f16547597de454fbe46a724d5e1919245ed1ad293a61e64be8c53701f5c76377ed7affa576d175779321c8f66d625113b8584630b3d4dbbbad0f85f0bd14db7508eff689e1383acbdf9532c9a867093ae7ac8283038ce2d0d76edec784f5174c815815f9c6ab89320d8f51257b2c9b45d9fbc81d0eda714a0ea1e08ec8c6381244df8a212017380571ff8c23712e1414fdcae323e9192b1d2cbb358d94d40f7e94b3a65ca47e9a9152d899bdb39564594dbc8858eda90fc868ae5c38484e5f5269ed55ea33a1a19acb47a19a25ba3319fac1071fd2591290cd13ef086e38b26b08c7f04ef21f253b62bb9a32267d68fe8aaaa05ee4f2cca60b287c7450824b4dbb0599c4471f41fd74c0abf6a65c4ec6c0b80645ef728152f66e12d78bbd4a0748a4aa5608475dec61e260e9772fde7210d0df4e1c861b0c2cdd1d5edd94d75d7d6317936d20381eeeb04021df6323f6326b0adfe04dfa9ec0263903606c16e27b7a12ba51046d8cd6eda563b7d1b9fb5274881d7f4c5a379a180fa82274d0cc7ab588153e9369f68352b852a0084dcc12ce0cc908bca765a5c87c1f224754015ff1befc561498faf689aff9116621a3f4b02761391ae0090e5d0d3df639d131d43e836398555d68ced3f30494a2ef5b6579b4f0ee61002a8515fffe84d867ead28467708169dedbd292083393655dbdbe13fd16bff9db756b833a682c3caaa388a572c6e6019053063871b7cfd1bd16c3c374f37cadf24c50bf992433e599a17ec3187bdf2be19ed4572d7fd45c52fd78837151a2055795f53902d8c352af3621165faec9fc6d438abd515495049ba72bb04753a3676e9d77075632979520b75cd7a69969aec22b02696ee645df631aefec79500d1037a8951833f8479ad0de1f2b00de95c0e6b2ffc18f9520fca27cc6a35978f8d92cbf75ff220043d749f8493209ebec0ad23547a86aa307085d55a2c31eec4848879121b622540293c7a94741bf64c1e16992a7e1e9b38b610e0cdfffb84ec8c0cc7ad638dd942517c9d5d7eb995a1ecf8f62e9729009b48db189beb4c0d5da2a8681ed597529e6cf01b037298f79e0aa3970b3a1fec8c4f4a51abe08d3e2cd3fbf4689b1f012d3a2283f119cdda9fd491cfb0e0e47720d2531e53b55ac45706ee9306933777b9218f84df272269208fb9132290468dced2f8dfcd754245d9c1df01fec1bcab07f946d7a7dcd79562c68de0df4782d6354c9d2363b789b37c568b059daec78bb8c16ebe71c9357cf73a9d2a332772f19c857a3cc67436a99264641606e167da7d1e8247ef84103c6f25d97348e668e6bfd8122b74b6fb5e214f9c68a03df3c8b63e0b6afcf6b78d596381e872169bfa345f56308eb1c926e9001e0fe5d4717a43b0066a419946dd539c07b460620537deaf7de5283d70c2be4b1a1c331fb417e9134e6b3fdbb00f73034113d70ad8920b34d9b5993f3574ec97aa05716a70deec27e7c8f4a12be6a1f99415d74bc36189cc2a8d39d0354b81c3da8ad385827ee0fceb71be70123146da67d9af63b92db8445b7fa29dbf524c0039ad31edaf6c973af2698013c6b1fc8af74eb22de0fe958d61e79c72ff28984bba2b05bd552d4d86cd0d9e832e77e10f69b6a7e04c8053565186b4e69fe6faadf1f6a90aa1a0e6fee174021b7679a9416bcc2bfdabdaceb01938d259fd1aaa7df42019034b622d0182307b3be9c2c6113fd63903a315a2ea4d90f5fc10772bec0c6a8487333f2fb8f6f3f2a1ed1bb434c139706b2a61f8190e865da3375f47e0de1c76c7d79bf8aa39ef856d0218bfd846b11a3f849199c951d72a80323f068dfd2cd156c9085534eb6e876e218fe42e09fa854aa846cbfacbe30c70a95ff784370d75af720e06f558ec737b223ce02253b7545a7e4a5818a708b9e6a096ae334347e65dc6c5700e3b2e1deb1c314318d00be67955031bfd2f3a23c63354df362c10bc987709337b3b9772d9f705f2b0842e163fbb38b527775567eb90f38f29c5878c80ecee6c732f237d8f075841de32407d4d3f57830c39c1befe18c53349064ef693f7c88acac6c51a403729e98d42c0ab0b076e9283fd090188b0cd64693fff71aa1bd1f25a9beaee4337222a33ebcf2bf0dff99f369b71202cec68a24eb214ef62a857cbb3834a0fa1296cba3fe0714cedaa1fbae7e36473649518cf3fefc69c4cc425345d1213e615c616754e7e54372503cd41790806ba6a9438194684a8b45a6586ee6c8fa687be13908268dbd74cf9840ffb0cc26ad4cf71bcec993ff86305316f260d452b360ddc29276534fb018b322267464e7e68d8693c2ad2d9c9ec13404113db92e72c54f5a006f743568d35e2e8bd0e4da3e8ad1c26417dd763371cd065e252b377bb56f77ffb9f8a197fcef70366b932137c01c12a5260b0ab603058c5fa152f660a8c9b3420280a03859094acc023ce1352e5e63af52690d58350fef2ef8df3d2593d6fb779841ea89e21c14071fb5698288bc1d0aab55a2cee9602442723d8ce5d08a0fcc76a6d89f7dab58b0d6afea902336dfc194d46f99a331ac40d64c783eca8633b58ef2e25ad99b55ab27e080bd563df9b59e1aca96d24a344fb16c8bf13caf6e70e8c712b16f81d6af131828977b1c8147d3cb631c59fba579d4548ae695ac9e9c92efd05f818d81453d2e71a296dd37c6abab454edbf0498b8d6d2401bfd09948611fac07637712fd91de0901990f1eff7cebbcc9d49a6e15135c447e8c7dc47d1505f7449b7ea1879ecd0fcceb2b413d2d22c0a4f3bb14888e79028e594544dba1bfe459027afa614325b548270400ecee2e0953c33739369817332b3b41d10a89003318d91b63517b84c3b5dc0b4eff0cb294434bddae0d4d1370772a89d4445d1c1fc366a8c3a7812dfc83233ab148552d6c1b9d8364b74db6d51fbf7e17d268445f45fe225839e5d9ca350d37018446defd828ad2516a5ebc1a42cc1285bf5adb9896e9f66a8270a830c1956aba0ea897a2db63fad3906f9db6e2093fcac6cbb0405a8221d1be8e760e7f4853c1e7b6b7a114c42d9c13ad560ff698752fea6d73a3164e36236b273f269aea2846511fc86ffd5c149814874af387db64684ad88149b545ddc105a663fe9d1d8610ee7b8dcb1a3d9d086dda8e9e1f366114e1254158db3f950b7e68fe620e77f2c0bcdbbc1aad7e97a7715bc9040397568879134513f7ca77e67f50febd8565826dbafea04ed1993f311b32860879820a40eb86d4f50d474da5a3bc3a15f456347089f3f77d785f5bf363b39f943b68230f8801219cb7983aa0e1e35c7164d6f90625345060e56382334710b06097a0d156fcf605bb8a929d605e3356908ab5d3b3a89dd50868bb207ed2d9894369537143305cebaf4f95a6260e6f69f2e236feaafe40d3d7e649195637d43342a7e862faf8d43c1cbe7db12d0ecc0dc45b62b7fa7db05211793f1e185941a4feafceb49df7636d57958ed5342de1776069aa55d9c3d301527520cb14c7af15e42d52e4db4af293fedd2d75d41f987dcb7de3245747ba5b0d1101eea0541473721eb1b1d5596f497548b20285b2ab562ae332c39f497414b82fcbf7c67bf0911aafd662488e59a7b85cd9e682157d278e67c3921908375541662e3c4c2a2c1ffae00da097f73093bc2e244207d859d9ba494e445ae326937f8cd7a4d55f68beb11d34465f40abf04c12cfead105cc4c43b229155beb33b65d9185dd7c7e9063e504b23a20a39e5c5c2fadbb719d74b3433f25744913cf5aba7a4e3534400641f380452fd52a29146a5509ec5c8041478fb803adf346c5520a47fd86c6c20f6d4c3e21498b94a9bac127ebdd29c64751d76b14aa5a0f089003404e605473975063b657cb2bfc4cb74eef2a865a1998f3feb6f6183dbf32a2b3d3d4be68a4d764342bf197ee75f4a398e777a318aca717b2e469392b31aa215d9826024538de5153a68bf9b3262e126f370670dc04deac26285d6ff87883fab6e0f47194f93213bba9266b81773ffc598b3173c6f4940b9caebffd158031d84f55869b1cd3fd3b8835a842145f2faedf59e01fb65006f0534a7bdd0b52fba93832a49067b9519b87c2a1fcc244f460c9a88f161c35e6306736357cb530e6837d6e86a4c69db81983d883c69b3a95eb700af22a08a3b23563c29d15c1a48a7a8efedb3ee6d84ce5151a960e8b39ee6772efca4995af66a2825ecad5b6918fc80de855615f4b35ae9c0697a1dab8b3d0ed7be3e03cb4fd9955c1a30abbf222be07e8eaacf2c95a7ab704399abf3ef9abc342a46886bef144e5e435acd023b2829af554fe8530f9bd7b62136c1713010db3ee858fda5b7aec46b3b3a8d75ae3eeba7274bfb961aa54cb2846e98c2bffd8472f5bcc8c5218387947a36861f12ddae20f7c6de3c14d29306b0fd4768244d7667f5f9903c477179e803b89d80a88751279675ee16f372e096da9f0bba06cb6ae19e94909a043c3f1badad544cc85c5a3a5c0a8ec65700b62cf4be58193a0357b032e99d65b4e7d4a2f568c232f082fd653abd4e5cac06f911095041ebc5560a832fedf4d9348d203fe6faacac8d2106db27e0f0bcbdd6c08a128127063867655d2dec53fbcac42786d122b174b0dcf08725f4a96130b7202570d6dc4682ffc5281828495d58119ca0a755e2bd600164afac17448be29ad03b180705b33458c1b3e968615ee71f2cacc22f89edda37df8841903c82086123a50d340b747781330c706bd46e3d6cee61f4534ce708c466356665f2e504dac79e95e6cdb4cbe0575004c9d832bfa684208b547d3ca5e92e7d47b98759c3988515d1899b12337968eb0897194210c4ddbc6c4f11eab0a43d543aa0536d51d282449e71146310d809b34d625c75643635bb2827a7ef755d409c8572fabc2c54bd36c6f0599f7cb76465d5b4904b64916d6ba43ddc7e30d8c498c6abe5ce4bec4fb115847a0e73393d8443fc8b00529ee355e6ccbd02be49990cbdfee48b3c9cb3ade5bc65aeee308745b055706d5f46ab551272c50fe3246049949fd5f1628adb7464bd9ae640bcdbcaeaf3a7f5e103b0a8b47e14519f7c839fc758f4aa7bd763d47e7a35ff7ba87d6ae1fce547819989d7f8c24695949a7995915bed98e789e55f7c8690730514e5c4d085f12e5bdcb5df1b0c005f666d2ed47862e8655120026f8b1c894c75698ba96f1f64a8b7562f4d88038737eaa96064dc0f486743fd32cf828e9444391053fc6cda8eb4ba953dd3f5dd3bf4277d7ea10881ab744b50b5ea81b04f9e5b048435432683c379c7296208aac31860e405aeeaa1e89fb41b16a0224b311f989c8ad63666d10356573c4b1c645a4f678135b5275cff9dbb74c15ca26a7545f96772099ec88cd819a2a989bc6d57ccf2aa96383f34aa05dbfa254e047b25363ee978e5f0bbb0ba7e8dc9c94435ba09aa8afead01875cdb5e6bb56cf2148df12349369c3fe6cbf36d3a16e39f2f1eae33397e4f1849c342729d1a79231781b65f44db1d5c6580643c84c1534f1bbc320d9dabb35269c256e19484f6e3ef5e169ea870993e570dbc73823a5045b4f2f91723f3ad408f4564fcf2e47b521fd40c22ecbdff5cea589b8d2f0f33fb3b953b3603de7e670f49ef313f5a40ce6c661a0573d16841a75db9c5030e18737b8afa6aa3570f99ef5517b313572bb582a2289f8e60f0559d2552d6f361f0bdad726b62252558e0e5592f1c0e73f2f6b2f05baa89f4f68b6f5e687d08b7603e845f2b7233eb769ba5ea51299d160ec8d8d5cdf41e62cc59e08fa226066b33efc8a622458f63a301021f7418fccf914327ac18c6920a6498fd837af15ef92e66b8e1bc73a1a7080094307b82fc8c67b1932493c67da6b159c4fea02761f19c23a385db75849de6dee14801b4def31a3bf57f23a312682695c679687ae8dd899f88c822b6c5a15d1dcd63d53ed4e7e2b52c86ce9f38a6ceb344c3e6b38015b25687b8fe5742309677b49e33cf40b7facd5cc89ed32fa5026666b6889eff778ba61394090f5818754e362b02023190c75b44340a1cc765b6d54f8dce6ddd1a116692fe4902bd491d4bcb13e8ec34c0a7a34b1c1bc9f223566ad8b2d33d6c4450789fbd651b3ecbbcecaa020a8509030888b8cd3c6c5048388e2d61e797ca3cb7d1fb16c67edc7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
