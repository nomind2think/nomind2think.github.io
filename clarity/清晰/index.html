<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63a913b87854f0f804c93cb274dd39cad369004a4a24c8f4972cac3a012354f7c7b025c4ad6e21955783b0d0c868d1547f7cb663ed1886b19299780c2b35d38e7630b028085b0574f797e041c90b1d4083cbc07b74a08620df100551928a47605f3723d1cb71c5c0bb595d90b62b09a260ce77828bb1914b6a588234d4b91eaf5d737b164d37453e5a4e5226bd6141735893fa4f060e1a2edcc96932552141d9f27c7a88945a21382f75a7d9647ee9d74f6671a17dc35f7b557eb934074c39ba111b2a5538acf5eee692da24b707dc3b7787aa2767b50ab725230171a1fe6028befbbe6cb0f0f5266cf3e4102e8396af5f2395766a216b96b6c4ee4ecfb930ebde4b3faaf514a9edd1585a236dc6d8a1f406646bce49176d1952aae905247ffb656698f0117868883c2ba669549fd927fd4b1bf1312873810b3a12decef2a44fe7e5734c71830f9de21c273ad2daa92a3513e37ffebaad17f833f44e8e9671fdefb6560d1dbf5ddf055c402c455ff62568c66b67acfca28b3a9d79262dffac75585766ca11c47c8eaeaf8bde4f59bb90a43cd415f9780caf046bf91424a2ec46010b1fdd28e7b76af95198a624ab9e2f23ad4325beb9db468b13089a6d0c9793ed8c4aa606a9d40919a6ef1054fb5d08222ff943e96d139d3ef3c686dff24f5ddc69799f9ed1c071a15d7d728ff215207219177e45cfa7a6210ab9595a80c71fd8eacea8a06b96d0a7ca32fea132b077da3b58125fe0eae411f64ad5bdcca02dc250976c6a9e4f19f6efb7d6ec9f540c6e5fc35913d534fc9c25f3b5f8c340948712a1f2466b932bc3de7aa294b744ddea1fe6b7d74dafd475f89ac2b81a30f6247b438f2f7d63663d1bde5fd52b08f34aa50134fbd13b77d09d099963295d519ed05c4e6956b7c926c3e5e58f2bdb75d4bf007c4b8efbc6dddfec60c9505a8b34622ea2a9c4011350d395fd2a0239c08caa84dcaab5b953cf74b774211ccc11501f7782fab00e0d6f4c2c00e4f79d87bf69f61a1e2a50d6718a45cc538a85754c16beb1ecd7eb8e0f81e8a5759bae004888db60b352b1a545761cb9aca50afa19f5713e73abc9d3f29fbe8b6e62ec2a95065716de1ab1147f986aef51a039d075ac9506cb12bb1ed6283c0b03bc8ed19fc8a9eed0d38d3b8ecca4fab40cf1378eaaad9f17cc139f51bae39db04d62e52db7305c6ad47bfc59429756129a29827981f60557c6d04a63e0db02eef89ec452eea44b5975ffe130b1804c3bf35b2beda3543947b0c547a3ffea3d4e6cc3c187d1ee753f037e124c62bba76b1e490b6568f88ef9f1c37d3c818798a8848b72f1bc0ffafcd2c2d4af2c137de446881f84332774d836a6ae99f43969687d79d1c41acf071e6315c86b3bbfac4dde1d361e753127622d4e639f6d11806620f9e8d5132f7dde870eeef04d75a2c871d6b67f839731c53c9a36b08539bd9952cd301f61228fb9bfb64d53a24f1936e6ffcc85b549597c77da7c32956d1a7b419426879354cab437d185056cbdaeac39a6765777bc4aff9d1276009a84c2fda6ca95f683743913f42ae943ef81756648cf12c890a6a472389c196a80bef4cf2b155265caaa50ee981fee52c6ab566ae4b5503f573ad82bafaf79bce6f2f88d243829f3d8fcc50b11f8de1bb7fd3e9e6d36b14dca8a1bf17eca8fe85d2bd95dba3e87b7ffe193e0f7c565786b8c6b759d39e22c1ada75a5588be624c015e053d5d190c73c94a8d69c841f15f504311568424630c551b2013b9c3050bfa9b9789a8e3dc4d54fbc228b31730e3adceb3cf3a2aab8c9bec1b68a72e15d82d44a242c273cdf05bb28093f1a6deb6c95d4ec406593d553753b10ca548f353b7c8b8c1be539c0f38c9ce9596013db81ea7fdf428a8f2401cfe666d386eb03fcd1153316064d01315cb94ccbaa9399d93362b5f0ea49e84498ad2ea2698ae29929bba4ac393875702a4679546e601fc0151e720ba87c7a5d992efb1967fac4c5b6ba689213c8d582f6a1b9fbf09fe330c8949d62e96cbc692e3d9cb69c98fcce98478fb326c9c3aab6d4276c6a2b3b6d71517fff3c2e8d6e513d1e27af4f2ef7a99da533c1dc7bbc4c8812064574a74713115140550e568fba551a6111338de61b74b6a6dc02d57ff378f31c4eed6a6aae964fbeaed90e6152db3bccd4b9e59c7742b8fe5827c9ea8d2e42568f1d86ddf4f1203cf581bd42d38e681e5106bab076cadb9d2e2f315ad08d1551798fbafbffb122f6c82cd1b3046436272d6a033b395f491f1ed33654708909800c9ac433f07192801e753454377b87ce75b149e4cf4ff8999888412c50a6671a6dd1c20e4fe43944333055ac56a405a5bc9c3f4c440347a65fb31faace22a570bb1ddc3200f8bffdce769075a6f5c607d5a508a164ca932f8e1b61b9b46f93f3a85bbb037db2032d8d2bbbfda15cdc5d37e9445b7393dd0e4b88048bf18b659129efffe716472117a18fa918ea9e99fc372cf2495b68dd8d0622b5cae3d07f16ecd434e17dd0a4fad2513947610fa75fa9e92d1a4cdda4d8ae3d2ae457c21bb90591134f8b1bafbdab4c2b00be32e5abed29d0e6b44e001940674ccd1fb425de4ff869adca11e4b393e7dd29d61ada3949ba3cce0620e4da3070e77f4d0209bd5b2d4224341d69b157ce335ffe31b60e2521f1d3fbd795ce91dfed7dd2098404b5876b5ed828ab2367da1ce5347647e9ecd99f038fdd1edb68a4465cbca7b0c3998e5dfee56495a7ee41831cc7346be3971c0a28be678b0b334d8fa79d72d52278dc2bb9d5707e32dfba39dc838ad4cde6467b8ac929ef1b3a35e4a43d804ac8e5f77eb7ab0317af07ebfc2d228720bfd29c9c0338b24c24149dd461fc052be75786bc6d1456805172c5e2bd1b98e3491d555051f201a7612d527b023a4fec7a608a1263cf202564339f8498c7e5383eefcd4e76a99a06315c0006d9671f3d6f25584ca64fdcac089e07cee9fb641efe8e28d4e5969da27a3a9dbae3aa182a2c3b67504df599dcf266e68e89176207d19fe4b437fde63b47ceb2bbb3b357e554f42c51be973a4077676915e979b228a0cbd30f1727fd184a9757be9512b37d97b585aadc20883885828cbec99c182f79f43eecbfdb04a892a7c0b4e353be764f42df7957aa9c4dd4767771d264018760bfd694a5c1504f502eecc8ff147a3f258221dd2393cf55174f5ae2683cd14c8f6e196d80ddd2f9e078a52eebd9ad4e03d0168be38b5a58f04416817b2525a20f32dbacc77831c2e9386a6ca8212e485cbc9dcacfee9f4c21a4df7425288d81877dac7b3386793649ff5739d5ecc3372560123dbc66f1c3c6e4d056ba6e5c02da30ac2584c232bd86f2ce0d62b75c82e3eb4e2fb2cbd41cf839d5b484dc68e955f21b2cefbc39330ab85667bacc925b7babe6f6f06874c37172b7a04bce89e8324d955a7bf9e47758767fe09111e6822b8de4cef5782f245178b7e0cf18846705f6ab76f7e3987b011d4dfcbcac470ee7887bb1f9d004ebb0983fc7b5fa5e71e54b6a2997c36b843a745bba9a33d9822ea8965fd8d05acbe4815fb8e78f433ff2f7fb2eba8f8f36293598066fc0e2ea8379f79358cfd19211fe3b5be16f3c684fac343d842d73f14584800863db0080291ebbb96f9d7d9c752069b874b770396d3f499074dcbcb12707b6044a17a0ec2e9aa9274407b35e0bc3b910714f8f3f04058c0ca55f920719a2bc19f525db84e160559493a24d3a9da1ea9914ed15c7dd4cb68f7b7df3234fc95bbded1a081475710360f8b5b9e888a551e557f70ea3f5425a758d932ae1f52546a6191c24c56de5f722fdedb3afffa15e1308c15280b2dd7fadec6314af579293e0196dd28a98bc6fbcba0309a3d7348daf4219bea400aef966a5920988706ac5bfa5902aa2d6a00859c6877d7fc532563a24729ded839f45d76594e7cfa20c7d274f19477e422ff66be124fba8a1291838137d69cf324373deff6a5e9e05ce4f991966fe0bdb02d3a8515299552cb9a5fa90811d8b52caf8d42609d59abdd5c90a7125be54c7f3efc64255c06960359fa1768036280638f7387bc1ee32ab521e10d6ad5be0f9effc982384a64ae3f19cef30ec203087bb07c176eb0fae5a8f6d8d7f6ea6126a29d1d2d5c51829c5a819c64926bcb8c85e84cf862c64969f332dc0018c361ae1ae0382ee8e94abaa5892f31e2fcb13844b39859d1ffc549a28b0e93d07f8cbcbddb3098ea84eb23ce6c1ac8f0b8748898867526abcbad24c3be175c7cde3d1f978e6c39e819fcaab7f71bbbc7e422492807688c2ef4caf360a16a5882898817fb601094c487eb51480d22ecdc796e50a83c1199b238cf9407d53424f6300cd04b38668e6cae29ebbb7d438842f2d71b5edbec3b194de456b49ef9764eb0c964734c5fa28d8dbb32283a19db12536833aa005a11f6fac0e8f50aa703df6ea67308dd4a8c9020dcd9cc85ff2a21654e305ef0d60c72ae5bb4f7aee3209896140b30cdcd7f23949704151cd1000b2c9de0d97f7bcdbf28e6899ac6d4b1ffd8c16877a09e70ae0de4ef077a17b24e02a5e5b616e2d55116e61f92cfff9ab8e3725a2fc3c8f98936c6df6b806ef93fca0d09297ef5f4d5fd52243cbd5a951f8b59e1ed1d820fdf69d47dc1af3be7ea39db78ced09cf636d6bb2c227e95e0c955580c11bc7b9dd1d0cd0b44da5b7d43c971c4ef3848dc34b36285b219998e3617e8237d6c1da269e47b6281953fb69826ef4c18b91334c3398e2e0bcd4047b20380539235da3307401bf8205bb60709738ce13745f74b773b22f2da4c19a7c015bb21b7e14d5983a38a6b07e6e050a294d84bdb3850c5b5c4819aa79341c9ced4e944784a3ac6b1cf37a06a4b141dd41981c449126fc9686b1f57551cf4721e8578cd51d4033a977d270ddd6e4d47fd0d8aa15e1a941ff580a9a52163f278ea8906d80d00d2bb149f8c9a9c6e7914930157ea0e5cbc886b3b944cc63aec838160407a3e25b766aaa57f2d8fd60a31a4aca60c6db28f6011833694296c5a140ef7a161b88dce87e04a0898a4935a1cc6937be18bdc16a947ba4a84e6d55b08c78d2b0af0b6e920df6e5f3b8ff4c60273f6d353534178be97000715725afde29c5bc222cab9f4a330ed04a6ad156088a688cbe3d07dcec4e054c5fef458dffdcb8638e978586494df4498052a3248f7da96a2fe55ec3decffb0b99be4c9ae05175a37b543c9db792e309a587a832a1b1b30b922e0d3e146e810f8a037d0ca6d9e4abeb808d02d4ec0a5dd544b532f18bdb34d6ecb8b2ca58ab09c16e093d8e990ea02c1f7e2511b3f5c0049265ab0ae2ca74397801fd8161df7a430a722a567e7de45917ad492b0586eb55e7ec12e34bba52dcb16114fab8c28bff6e4fff989c83ccd388b0d5bb33fbb3955ef0d93e1e2cd50d95bd0d8859ee3ff444ebecb62a16539afeb3686bf89fa43239578149dc3bc1565e2b160cb713e52a4a17172531307f069b199fbf9c79af9c33d16eac72e7990865e2bcce1fd203a01fa66280df71643ea368e320ac2ba5e9977ad78a86b9d03a3cc2ca11085b04ee58bd134d0ab021d1c64c8fcb36b034689ae5b4cc7c3707d463aab28b311cb42625fb9ba7c6e8d028701c0888026794812a2a555a674136858c6c366b63fdc1190b8770974dd17439f3e3ae338e9533d157d425665b69f60be2f4ff9b351087e5d3dbc349a9fca598b3c46a62b8042b965dd42ed652efaa71a67baa561101d3b3d4f510a935df74dd31be1e8e4caa04880c20254a13e5cbd7d64980bdddad68984fcef8d93082bd7e334a008031c2b274e8de88d8dcd7a0017571fe72b268b47f61d961ebf4fa39c5eed79ad873ba7ca81f51ea0f3b5d147c2cd1d8b0167709c3e90b96e8334249ea53ad782e7b67134b95598a2beff082ce30834b9247679d8b9ff7a4ddf334bba892184225dcd0f56c33663baec5479236c5c572f2944e0133313dbc9effe3c6a0475faa7c0be20ac12f887052d672f4a709184f442a68e678adaae88ba19889eaaaf29fe316715bcbebded9180fbe5e82c1c7b4b9cd6de6898c2654b548db8af20acc6dc78fd88929dc205ef224d7a9cb32ba6b2fa97cb3f59887de892d414326a6a20a59660853b33dc3647712b0bcd3d8cb8098892fbc46cb334eb6a42de754eac04012c40cc9a83068016d21aae103faa1c24ce0c866f23f7504d5302183b13944ed6af488721a9747d130679bf4dd5d667a9068e167f6436ded8bafd3c45010652c985ff0ca94c2e0573895124823b69d1234222d7f17c40b776c5fdffdf6f73a4d39b67f97a1aaf17880faaf3f17012759fbe8f881c79d58f0506970de546df4b9824106f1f6da35821f850e497f9dbef5bfb7031da140f779a805c9a9f327e40005b556641a3613755f78e1e9d94838998c77334c1839ce0ba764f9d6c86939db91219d80bff8059a6da699d8d48c103c07653e1dc895e8823796c35de8e94b5022f22610719d47420a4ca991bd7407721065e402d644082db9ae953eba1b40cb273ce3faa1899f194787804b93139218761bc0e038eb2404dbc583c68e98fa3fc82b0039c92097db8263b9eb9afd0966069209cd3247dd58082a676d9a468eb3ad45f3fecc727f695d0beb21e916cbbe6ff0c78ee4a7de49e31594e5749c6a8208495587ea8708521d0df79123ec5ec1c374fe0bc7f418960260aa511189a87fc7fc90fffaeafded10906ae9b04dd16787703c9b84c91007baba1587f7a12e3ec19b7a2448d72d1189e5184c7c6b5e364b604470ba69cec0412405e7b526b286659ed3b9d12e1e9b0f18d50779f1e033cddad20b0b484ba6d89ecbf59f94938849f87de9fe5fef4b84355b65f6590d0808414e43279598342b80e7d545bb8ec706f2e2eca91db4d7fa1a48becea8a00c02da599bbd03fbc8d93e980a9d2dbe204c76baa206e768a51c6bbad1047d684bcc4442d70361aea1275e88085c2c6bf70347e48111f529081567ff817d5c2b76848ad8a937e5594a8281c7b731de133a82c2aec16d8c7c9524bf85fe4607ec12472cbea47fb47eb77e94652b5383cf2fc0674af3fe2f318fc540cecfc0c4568aaedd863f4caaa567360b170f6ed55e57d4249090d8e6a2c16705e4df4439d09666d7658429215ef599abc4afb7a53aaf03d50bc7a4b7718bd9b9bcd0934f5ab0bd42fe0ad6a465f81ee3734e27b86a19661aeef3bcbd37f3d78736d6bb6122f906d4cdf26fad1fa42f027dd31d291d9d382b6fac8357303dd8b60499941e03210fab05f7b39464fb015f8664d20df39b836205f750bf0de07a0bc829ef3a8704b34ca50863ae80ff767834776f14308da75ded4f324f5d54792b6d390ac79eb279e1e0a51bec07dc5469e8f5c4eb09f72e3695fb97804530584c7797fce91ce92f3f4fc7514dc8667e6c323d6af355de04e9a2f822e433f1d8dc0c551a284970a2109b43dd92c99f926b482432b6c0d0dd3eb2944a59748a451564d60058e7f7cb2f796cb712b35ef4a90940de8a9748fdd5463ae0f1c4dd9c0dc6ac00fff0194a128f88d4b74ebfae007e3647eb75a86a6cd8695a67b1ce51299b4c34d904e86c43c71c7b3e978f3e84a2ac261b933190f6bdd8201c143bb7dc4fca18c7b88c63bbcb4f7793e538d76f76f8d4d9e3a5772b1a1f6394d1a267231761aac9bdfdd2506475068d471469a86b7f75130b9488a8b076be76b284f2b0842556e9a108219a6045468629268b4bfbb196f6710d6aabdf1687eb4f358d38ea7c31c277d088580ec5ca0d2b488230c49c92aea3a4f89c4f6dfbf5e3d0289ac989edba3e33d9bb6133580dd4f6d512942e468fe78f2d6866ccab6d99ae84221f973bc1a4fbab37dc5b0fc844c8623168eeaaf926996a7b370f5fdec6c570ff917803950c84601247c1f53081889dc0fb4a7a288fdbb79b07acd60771b2a910f0347bdf6443b42f774273249e45dec1deb27b6d5731d2b5f822739d77aa18257ded6db96be47c3fc59e229fff9de12a154d839314fcf012b4d9dbea4b3abf2ba265d25dcb827d6755420ecf5834f5ec18b926005c34eaa008df2c00fa6a39a70bb269fde35ce0d1570deb2de6484a8dae538068fffb544b796fa010f55b1baf7d307c79782bed8f947129d084128d53e00975df82da61b886325ca669eecfaf0d3f9eb9a89f8e6ec277f7d324a8eddff73a12141fa4258fa16d62868225088bfeccc0766589dca57c6f604d3c43360a8bdedacc0a444ac956d3fc2d438a201c564fc943ada708ab62dee1cf2456f651202a7783c150202f62e3ff045701b912a9ead5e5d83396fb24ad0c01d1a9670edd562520ff61fd365ad4a6571336ce5e9de5496702d81aead0731bde7f11a816d4d6dd228ff0625cec179fb8addcc047b5a91d4e15af2594b67f78ca13c3b803b1a35ba231ec5843295e0caefef93ae3199a684b038c30cd950b0ebd9f9f56f46f17afa359c6c859c99aa75fdcef2c7ee05c7006ae511f55daa0b593fe2b96c3d16362b5882d5893825cef8a2a98ae91c58959bd9f81468ea530f9c1b3786e489061f5fc701005d24cb1f0aa6cb23082cde4b12be17fa0db9ccf4d97dcc4a5c37c7672f4bafa29412eac5091aea2adf5a4e41244c42d99d339ccf5ef7da2d878e3aad2e6138f8979526da7174d8222db69f5881dca9582784da90a2d0f75555507731f4fb57cdd1ea46617d83a4b5ef909c2646ff82d23f1af0949f6e8a83e68fa397e159f30477b3d9cf404192e204fe1dc8ec1708cffd5f76ceabb43329479655f7451ec50aa6a8c509adda3b02cefc2aadb6f3810b0a8593db8df59680f007a237c5b3f45366e672fa93c833dfa3d7a2a209ba44add850d343575716e1e476e0c3ee3acab28d9757c49fa4588c463cc222ceb349cca0704d23d829d45f98457ea43445a66c784562d877e398c0cff87f4e2f888b6629aeadf53f89d2cc683819fb9cf0330d5095a3e5771b2e4cd5f5080268e1492414cae140dfc593802e6e978a5442bd53de1fa3a14282bf79507de425ace2f3eddd40a0baa87fe3f5ed334f4d88961647818ec1a779edf4abe7b3077e7d3535d94a01d5d187c9dc0d8a21189d23abb2692a8479efdba3a8e1e9ffd460c0af89d6b68c0761d39bd5d034300ce3403c518775b936f1f3031aa1a5fae4283083d7b5a65db1770977b27dda0b5be2ccd1fc321e86882847ebb52fcb2b024af489ed9e7f7bed2a27837c84db8dc042926f835490f32ab8f84263e7945d3392eeb054202d47b93f2978262c77ff5a8e4fb5062868d7ae3b3c067dd40a5100eb69db52fe33cf0189012c64af5d85236beca45c1c1fbb20305d40369e14c18976b42ae21734cf3ac57923a11f0213011b338e483362fd86da62984c34a14e764478b38b46e597b39022d7bb8f32b4c4f031ceb43a03fb8b6b0a935710ecd0211e00b0eab64ba20062f549bd049129d05b04fb0f39515af6fd0ede49abd2a5c349fec232d91c5c850955e69cb5ef725e608483ffecfef954593ece0aa0d81371ebd6e5cf5fea442050104f2d4cf8b9a975b5ac51d1e0aa44e5b1666fb359f4c78a0f34d9e9e0a1d7af4283d75e70752b1c50a6b31f64902a7e7257dbb5d98339fd7813568529852c6a6ef09814a91df76909c6c8ac23cf85602ea4e872ce2a24202afc1d4d3290a9252436ce5267e53982de3bac5e271b3b500a555b1629ebeb70f738608ba5b51501bb6b98eb419118451e8535221fdcf720a4683a86aff812acc73af0af38ff9e204c44ae814316001dbb4521bf2e79ae168fa8036513841c41ac80c24a6a090051d6c809d4ebb98d35e5e6b92ed249a91d2ff9ad5aaa187c5eda035e50982bb8ebff39b09a09dd2cb70e5d17ef5f5d641248334592a0dfad187dac7161f1befed45c475add912e74f415cc2d50d734ac23b51740e39124ce7671981006b63bfcbfc057347b261d68251cc088c7967bf344174b356a892c042076be850e3a29bfdbae8cd7cef7ae561d4007b97f923c3ab0c36d717e6ddf9464697fab8c0b93006f261b25eff0439126c26ea67f2ab8803e1678cfc9d9d9a95cd69215613acaf75c9a015ea78a55feae76a8c934fcd34c8a446128e0a1031f959d6faa854863214692836d6a448d4df37ccdc309dfe0494e33c198bd93479778f6e551828dd42b80423bd474fd3d6af3f21d18a9d4b075382d84f7bebb7e5d074c0f29e13248f3f12ac69bf560ad7894917ade7522e6fb30e48514a03c59daa48bed2f6a8071f36a3d1d5b45622247a0effd4f8d818c5e40b005e60d387597d3dc07263eb3ca9650894500e9278ecb0605aee77b2db4d9fa60838ca8721b2063a3783cf39bc648b6f702ac9592c86dd80fb64262fcac1f3ae2e109a63686d18e9ddb4f1d77a33c4916ab8ee48dbfb5e2a52996b8349bf754bcd7dc66774c6f2a1f50db99e717c924dc409b807015b7018b66a9273b3be5d35657e795b868a8fc4a63f574257dde959c43f5967b7803bee354a983fb8a79154213b869148148a33771fb9c9a56401d7411a0b47b896fa8ec73030160eecc80c9adb561660f092a9a949ae708a1fea232236bb3b98bcd8ed53ac750fcf380e975f226f543822aa0b5a7124d6c1c5004c41057c4fb096b01472e26c958f771d64649174a0527740ed4c41466f89590752f516ce5ce8971ef82c6eebb5d7bebc0f9d87b0bbb42865c1a1951a74e125fdfbe394a1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
