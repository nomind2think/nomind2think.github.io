<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76b41588d58ff85ec8baa1764a4420237fdb1135630b83beffd97788d9aa51405b9b8582b805687fb1485affcfe9c43356b96adaf29de0bb3294b4139bdcfad67f9e688a33309e44fd42b8a3a1339bccb63d0cf600141db0d41874484d4f6c3c5b06440fad4d94635723b8f5f91ec977a72210f4df36a639bdfff3709e7869dd895081a9fb27feab53d68b6bf2e5c00929680b7cad9419ccc4fa1bf460b12da50d4ed3549b868ca4c0c6e76a5fd74007b72cf0fbd27e8f2ef797ae54fb026f1d95c4db7ed7b84db5eb2382852ffb68726c1dd47ee7cccfd9889db9d1889ea12ce401265918c6cf1e2eb36b0929d3ed07224c4b3a1fe939e16520c27c030b2e70af34c1fbfa90a3e217a4fc9a1f2ec001f6ac847a51d03cdc999447bbddb001b42d5cd23e88b7e4b2e303e6db56cdc122fc4a6e33985287f471d5b58a55764d678ea47c3db04c9019341b30d28493ef797554d42acbc1c215617ff5c81a8dd35d01ee198acbc4e4334b47192c97d472d1fe7d769298fc3877a564951dbe1bb8fce356b4ac87c1ff01cf1bbe2918ab0c1107eba857e4b098d9191b6c2ccce08066970cfc6bd4b67163ae8a72e534535bf2ca54c91d29fd718e1edb46fe113fbfa26b5543ab68423169a3dc6e838ef76b69c5aec632413df704b19cce4d4b6b3f1e2bcc864c2ca1143cd1c9c9379ba616e401837ce9b0ab3e2c991abd5eb2f781edfd53ece355909d59efb1ef5a6dbae20df71ea8ffd28ce18ee9e0bd9de452ba64c121f660c03920b86e2954445a44da93d3bbe5ea7e01702730d8c29b1507b80848332eb86f9fc5fe06387e65608167c24e4522c0dbb51242989a6de75567611f121413e473089a338ef57bc5f93d487da08426bf8dca40123e70c2ec5016da04ca0f6106a575222b03e8d45f362069ea47b7349bbdcfd52f118feae74c08da40d713f7fa0f067861800c1a2f3d6cf4875d31c22bb80cfe94b570b603ebb3fb940507729d546311a1fad1cf15de3bb6714124312430b862fd6d7cfe6724107d732b4322cc6be7cbc7d3e7bbab1b8a124eaf673c240c5befca68ec59f781a747e4d64e846ad965e0fa31d86786e473037e35317165fe7e60f34d7bca8ef7609011e2946668d5c2c712d760192ec76fa0ef87b3f9a5699b592a9be0d0d68d587f1ead0a53c6f7df3bbe8178c7d61c0e57d70dcb4cba26222f7816ed048ffd458e1a0a8acd46523b9d8e409fc1d45b113b90b299d7e37e5dc984a530f8c701e7ac3c35c1c3cbbd3401ff758043f6f9d34dd43b5314c462351061fc0fb7d31505c90533a883a831e393ab9701422be6d81b1561919feec834d67cc01a3e6dbfdf0b4cd269c46d8224666e44a7a9697a6b8609ada659fb46441187a515b1ef2acb60a59e3d9e50c2a9aef8dca4410206c0a94bfcf6e89add442ad6339a99085077b90a0aa9e92ca363a7cadfd5ce6cb9f7f637f4876e7d8cb6ba3ea0050079710b0e8b7cba45e2d5ba72489b7f40d6cedbb734677013b6c206ad64f649cabd5c8db083841956755b49705c9b70c6137d51479c6754858e2140698ea192e856c0a1bf475c6dbcbdb7649d042bc8ae87232993f625c662f39f54890535bd4addb0e1237a39dc6027ed22d4625e6630d95388a1bf963200a0bc560d9c03b853c1088e6f9008c9a8ad45e6ba179f7d847ca286ef03a7de530f358d7b4541848b37feb52c9c741adc5f8ea590d1725c3a8603b9b4d514b473b5427b30641bda2b7f56fd8249fcefee77eb52807befb024ef9241a9f49ecfa37fd64e768afb69e6e77c707bea99fbcbdfd0b3f422f4f5f30dd790ee9d80e99fd49740b46eb70c0446d3f85098fbad6f1dcc5b146385a64824ca6744fc7add8b60a7e06f932ba1f0b47ba13677259d6cf3473179c697374255eeb9d064fc833434da6b9d29634a5bfa41a4436b33d21ba55d517b006199bdf8d880f8e69d7286c69210a9794a478f0ba66f2027af18c3bf98354ee4eed626c07286bbff15440627db87334616229b4b755b915383fd051cfd363b065424f6427e60986dadca310bcfd636b9b16d2972ff9b39dcc7883279f57e245d9a47e96d7ee2afadd60b40273cec5dea26ca4b39d6bee6558eca6b629f5853be187456d8ba49a5267e3391de0e67151e6bf7d7d7874c26c7dd840af34615faac85fc56ec5b9e31d1dafe0f163d1c07f26c4e8481efca188789a43a89c80d98694dddc27a56f0aeb1836c8434b0453be4e418227b5d5983f4e9e202c265fb06818c19123c14c48727a0cac3a1fbe3a4c43809f9036441dc76e19f79617e4d516a187592126dbb0096f46b8548cb5cef89d8e738ff2e9b0f0237ffa7cd3930460a14997362548d23703da858125cbf303f38d546cf48b2ed00a5835916cf7a4c04fa61ae2f956cfe260288c4d8f9b65d35a149e076c6758288b9942a6218c1fd776ec7fb6988f4b5392e54de74b7873d5a3d9efc8f8b39c4e9e31f17eeea9b17bead17ed9af0708d382830b31c310315bc4cc50f23b05d7b32cd02430efcbbd7e1e191f1525e8a2be3fff920bd043e8a92ebca128fbced090a1786d21da3fdc13129a8115819e314f9b68a91cfff47c6abfddfaadf295b78ce52230045d166f6f9b106edcb46f50901484f387cb1bde0e2496281eebbc5d72f11de54a75f705db1fc5c027730d494e7f9bed1f8cc4c2b5dac5e66802b8ce8c145287b9ce35dd6042c83fbcd3d255f5d55ea622c369bec2f2e9acc83176cf1144d5e9738e679be60062c1903af43cebc3e3e43c89834ac6f0306b0deac7518c79ef2c2aff4a67d2a5e982ddea7c54adfdd99c6109b3370b1c1e8bbcc71112f0644e6247388e58c3580245088ab43275cd57fcbe3fa31e23d458fe6b1bde69064cde97c8bd4efaaa920a1232d49590d83343e6fbbf4a3790eb484a581cc1269567b9e3a4259e329e7953ef45774d6ee466126231a25ad4cd1e29f2de42c1a5287f051a6bafeabce195637ae4f9263a0f450ad5b190495e2a1eea7ac54b163a2ef8f40c4c5e02ba4e61e877d7de016fba1a902a23253edbb31a5f9e3eb9c608cabff359de44550a7511983e00217d12c2c8f300fe29336041581f789db33b5ddeef93189b066b07f6807c6759fed46a3283c588c38b39143bf1d9addad01193900d1fe4f416790d1784c96c1e84d9adbe11dc0da4bed6a01afa1f7633688c75412cf6b17f3337486eacab43108f9cb2c9d7f410eaedf60eb9d27de4ac9814631efc6db279913620affa6b4c3c36a9df9d3b4ce3278eef92e31ff0b4ef0c07d053ca26739833eef1b9c2bb64bb8b7da8f1e3035ef035c3c62ea2dfc850a1613a82875c790e35bdddc11dfa1345344eafd7f5e67ce9db50c509a3c307f66611eca8059fdbfb7a26fc47b8fafbfc06e801ea5fc0ec8b313d01900182eac83bb4407e1565937bd5975fa780985e7d11c8473e86ed0763353ecf7197eb4f7f4b4b48e33cd0bbfc781152540dd176cce58609fbbfd8831139b73c7e6aa6d8095797fc71e396237dddff1a79617254b59e1229e182778f0ac1faa2a5429f4b503fcd12fd9ff56907984e21868c1aaab2de89a336e6b190c292a6dbc9cde31a171cc6f7f5ed8da552d2a31bf60359cfe80f567f2f5b1ffa5984ed23d1e359bbe429e49db6a1681f8904d1681b35d25d3893aa73360ea02fea3e0f21335c4a45785756edab78e7b973fc4de21fad827db484933bcb5f4e60de56d20cba5dc42ba625db12cd8d4fa10d4e390c62e811d75c1efb922463a4d6722056c288e33472306b72c126a7b1eff6710a0223fba231a2e7ff5c86143f23bb9ada1326f3c0e9bee2356576a8eccf242257adfbb373171b0488381fde65e8c1f2488cb71c5f5f82c7a900edfac7f08e82950a53c36a19ff5c2f6a553c899789f40e6790931d83910b39a218ca389514f153402d19fe7958fe5a8521aeb2ceea779335965a861dd74cc98e62f4e9f697c9ab8fafca1c25610af270c98e0a1be84b30acc7e99806c835f7bfce4cd38f88eb351de9cbb7b8a0bf5de065a71b54e486e5fec50f13f71a092e4a7ee8b2ac25689e842e914ce025ff987320a67a1d18c898c156204b6c05fcfd11186445b11922c2987b5f3e8f4514465b693619634e1ed010874157bd023ee221d907bbff5a847d0de6487bb0edd41417eee293c0ca2fbcac70b8fa84c0f6b36641137abd1e6320bbc0c0c21f4eb8fc2d45c9de77aaa9f8c2b3e95f254e904cf67a63e843d3755e478373e2d5405d549d672fadcff58803a0dc8b5d48f09d29a3481864aaf2cca16ae99dbbf26a3db24d1905d81539f1961c42a632fb1b7fef2d6aa2edf8d598767127f5836e05c64fef0c252e492f4a56d369d3b7865c8d85102b6dfe4488e8c082c0aaa4a1fb05a86a56498f28b3bb8cf64ecc49332be67c65d4e45bfa3086a82ee0bc65f096617f3fa746f148c9907fda9ce6ec324ac91c81eb08993eac77cbdf21dccbd5d4382b87c178d0decba88dfa10757609614a4e6d35c2eee5a35e422079f1be1404d50a82fa36b91ebfa3fde672a9439b5fda3533ba9580cadc3116c1142f3753261978da4d1b94fea38ff5a3674c8f5aeb835558199130942017b46e018987e4cdff531f8dec20ddcf7db6c21804aa5f2729903a259df4087efcd794e5e07759d6972ad862ce6ee2bf4a61a1b20a3d0930062b9d62c9a5926ee5ac6d7f123880aae64d100c913e99f2ef0882076f60f640a1f3803eeeda6a90266f4eb598c5bc5d04326076abcae9bf9587d755c8f9e345669898f13e4044608fde39696574ea85f3a063b7151459c0fb90c391067fbd35fe861833cccb6a1bb8fc2882973ceacc97628434921d652ece6636febf54b387931a9e273ccbe1b67155b9c85b494d53e5811087030866facefd9d65091b1bd6d0a137bbbb93dfecbbfdc67be1c9ea6438d5dde8f1a9641e356efc54e6c164c4318de9c840cf44d08bd31b5b2144abc916f895da4494aa3d77ee97566c9c90a8b726b121f6a0ca0f15fb1e4378edf7d2a4f145f1bd6752192290ddae0aca808f7b954ef5653d3a607497477ec690a12beba086341c3caa1bc09214025d6ab7a4c624e3b101ff22c43251e4c9ad7eca73f4a8a05ab2531ffb9e6bc554e8be3ff4196b7eec1533eca238a00d9c6631350dea6c3e0cf88a3013bd6e8ce94954f82130fd550810a9247da6a35a47a8858d8bd2116ccf26b412eb699519f58adbbb56ee42ed9c8ec02cff1239cfafdfc9a9e050bf1038f5012ea4c6a6087a2361a09206b47a1222f30ef09767218a20d0e0831db37c9ca28261459f6ff837fc42227dbc9d30d179384502b2df8cb63cbaf99860f868a071ba92a2feb19e7a49964e90ddf203306e5752abb6e0f5fdc6400525b17b49515435c586bcbee8b11e7e0f0729202e73faa13db1288b6c25cfcd346a203a4b31d365b342968df0001e92a1c1f07a2ccd353f2afb8951ba98278484df72ef1a9f1c4a00b09bfac633a003cb9ea1495c8a2f88d74cda63cb102c41a104c58360179b7dc277b242a429dc097546c2e147b1d8de5b78e0af1f5297fefc654a6d8440c15d3c9d17a73316398e6db9b2f41069522038fcd63d88aaed1032d2e535829859f069b6d465868b7e3c1164429178b016f0724ec452eb9e958f43e665b48bff170d98cc98527a76f3cd4360653761c712cbf600c4ae3df582533c53384f597b0650e96c9eb8f7f26cada5340a2e23af622db91f00b1bc1059224044af2bcda7cb345d1164ac0976f6cd746ce933cb3324ffa12798b604b0f43e881497023f12767060a32f94051577a68af9405d0c22824636e3889608bf6f0b4bec9ec08aba4a26a1a1ae9ef54cabb41cd036d24faf3c79055dcea3a35c11c01c7f59eff15a8d7332c2c178d77ecdbb2d5a36f4dcf2e32fcc0f87437f81b2bea72c758fc05d2c70df6148ac2457b306695e51841fea494fc138bb990816d37fbeb262bab3891e4083ed12271d7705d1c4dcf61704cc952121e65a6472c3f14b42cb4fd77616cd75ceda721f065b124c6ca459c40fbb1379e4a31aff3ed8eedf6e3b11ac0d6346adb5a40ac52cd1a581871ef07f69e2c86b72d8cb19073ca2c01f9aaa192f5dabfedb4cae5eb3a939fc91be8cb49eac2242fe1566c2f61229e5b6681c1439a37e12595af61743ec020929c0a1bb38650b3fd003ea7f34ddaf917c3db0e727bdad80bd0cac299030b02226463c12e54b100a8fa6f1ac7b5b12346a55ad39875fc734fa7a5f67e104610f56173b13698f4a727992e94d6fdc00d0beb7ccb5d971de3d14ba01c1460a67d61ce702cd9a42b39e359fd2f36ae3869fd74f1cedfc21e0d1031a605d237a5f6e9bb255f54a1525f9786b961ed81f3bb342ed8e7ba980b260a6e76af12e5d5883fe4377a0e4cb833b59bf0b19a4bd5959ac95a77f8e562ed845c470e5caa161cfd3b2a3426f6d3ae193e2161e3214c35a86a219c516868ee2c0d337747ea0d37e72837b366af64f5f5b7e41556b63910b7b305bc680f495108feadf68c909aa8b59c160607960675e9f0cb9bd0f387b38da2978036cd457bebe9d673bed981bc372d1fd15f01e6667bd959026c93f7c4d6e9d354be12095d9176f7a56de6309f9590b3fff32eb44058cdd2dad1e4a4554f469a6d8e2514d879cf6552de7d9f536ba0b267fd6afc564891df1681b2c1e00439a2640f168da4fd4eaa3bf42ef83cb7c15bb8a6ab10d7c131ac038fba09a4744ad51e89277f7de1945b7bec17b93def20f9ad14c6fd993f263bae125631eb99205d384fa620aa55db7f8802d4934937840dce902274857549eb2a890bb4065d8bba6478cb0ba8593d424b1cc1888dc230eb06cfb6351f9a39959f5ff6cb9a0e11feea15ab49c27d8af29c6223dc68b4e148af010555431a87fa45d0ad690fe25254232b4d4c8a1dca3f554cc8765f193a10936cb8ff8bd045827be755de92e1a2ebd84bb6fa60b02622edcc7f770d3250667b8d08d3dc19073ac12b926ea1c4cf73516de334d294eca68e0734eda7d3e70747fd900013b339d3210bf76a0212cebe0d6a201ea1cc8d24a430d75bad4e2d9eb5d19dda977eaf42ed032e92b1b53768845b4fddeb564b970706af984e949230c0eff2a463cf28e90d5bd4991bcce7e49a9b96435689c437af084d811e905b444084410d4b92aa53584f139678abab0bdcf3ae5fc5bafa4ca7fcd2d1079c352f8194364d817b23ab9fcff696a80d46ce7fa3a696159b558c51cd6d17c2e25333c53b4c684c85769ede2d400b2061a2050b036b0dcb79e6a6c59ff1c8b8e41cebdb98f696eb8487d27ad9b8c3a68f832ac68c57d1ce266c3c8c8245ad8ac20e38081faa84d4eca7fc8fdf04d83301fb9e10d1401d536c413d9cc586f4e1f53e3851f8f8c9daa42a009882efb9addce9e24c7631644d979287d7de8821a003e58dad832ff8ad7de54a69d3b7b5cdaf9e308ce8bb3cb4523830873eedae38a0e435496d796b954b9ec265368c633483bf7a4081208bb62c620882f22c9227770dcc0f356b465c2af1989ca8d1da2e5803bcc2ade8c0557a79e2dd766fa25cb705e9d4848945e7d80a5830a9a29301772d0cfd31751c1617228a16f3539e0ff4b399a61a43671df044c963b59b883e9debbf8aa2499b76cca1198846868d3e4f5ecf4bf74856a19a251360251c02b2669848e5b99ab6c67becd52dc2cb17e9f2a541d1d3570520a8e265fa40ed6bf7b05ac0f0e10729e0ea52a041567c2932150bd76db282ee9f746e122d4e2fde952eb3ae8ef8b471fe3112e88ca5131a7a320a3af61930ce54cdbfd9f5efd3b12cddeff8fd5dfa9ff9aa7dbeabf70d8e8edc688c5a1eec9153539072ad31f4c4b475c20edbad0c42ffe88ac6881f56f1dab7d9f44615e70685de9a9e42a8ed4bbad9ca8307235d5a81030cf7b49dbd150ce4baf8c4a8f7d64afeaad36036d0275fdf4bcbde3025ce0aa10c1da4e83e06d5486d1a1e291c98b9e302e8cb74c8d0dbf3ccca12713171b73e14d4ad3a017e3d7535cc972ed34ff8d3e8703c54c4dac0d946eac8f8ba49932c3e4c76dfd4709a593438d3bc4decd808c620b221341aec549012f854e7cedbdb1398a48fc371be886ba388816e0e7100b59fe66e4b5a81759dab90144223d01363feb975055a5709e17ca9cd4b929bde51f844fcaa05ca55c7377db70c747937554515afd13c307b27a313609e8f6bb005b2850883c3287bc4f8c685596c5238fed6012038b35e413d782953f7dbeb38ec970d45e15d2a59f4a5188d61d57413726357f486921bea7ed8a767e0de94030b362941b0ac7896c7885d0160e46a65e73efce696023f0a51bcae89494a9efc69d63a7f0a455fd5849a6e0a6657678e405b3061d44ed6accb2a679a650a3599fb59d542209c1dc624490d64ca36619a9a456e0b2b6827053845c99d496587d9417bc4d277376b057d815bdfdf86ac5fadc53f9b532e92f3ca4c58ac4fe90ee2e514b40157aa29c47097976688d01fc5c777481de1caa30ca772304edd158997b757e8be086f6269e54ffde2b92c579359c1bd37f1a416afe930ee7c61b342cca6b7388e3d293c02b82574a3268c867330da6bd3e6e6d6559b2d8fc439fe6be1d452f2cecaa8fffdb8fe7cdd8158317c2f90200c84a25fa0ef66768e52a556f817b2cba0bc30c40c59ae9a25dd94ed380d9b8600578f04bba7b476979d282628310275598f217ec9cdfe205516268561f98f0d9c8d602885518927ff59a07f0b43d8390f8a58a6d7cfbc6bb788a0e16cbee85a123034a12a1333b454130b190094bea2090e18021d507c85da9a79cc57fdb42b004b776d83b3275bbfe314458597c9b70af25f71bb72c29cd0b068ea972d3f2f435ac8e0562407254fe550b4abaa9ca977ce992877b2741b5ab4fedc1a12b98e925c0af90cb80eadf056cad6f572fced99949f0a8a6fd808ad234d7ef51361151ea65d1ea67b587431f76334d9794f7b6c24ec90b47349caaf31d64685e2da4bcb602983741fe6f359aca500446325b3244496084054c1fa15e15299a637919a65cbf4dd15b53f6189506722ec57cb8b89cd6286b49bd8c35dc35e0a727a783df42bc931b8c4bd0e001187b79fe5d7e8dd41ac42b071bb0025a9225a2f81cf5ff6e2fb3ba096a25c4f6f432aa950472457143882e27eb1f3522ebe9c8cc382ff960f746f4b9565a7243416f0797256aa1af1fbdbd4a3ff64ef5b6e5a181fb4d5f88e879c060740b95e4c5e73c081aa3911f042c8ed6b52ff30fc8579387035f2da0e66be587b6136bcfc9a0dd8b3c5bf6729fc59e17fda760be5ffa54165f8cd100f020fc7f402f66b520aec2096626145f6669c8e361e4febd837d3fcb83dfbba4bf1acbd39cba1e48b92b157709fbafdf45e1e60634f3d0397a22796798f4489da29976a0eadfbfff37cf22fc3e070f82c1400875f52d0b37aab904e790d7e1013edfec0b33eeeb8ea6897818be7980a56ea3abe4cc18779f5da385ba400892d67e3f32f1b96942da2164339f921f49861f008368e2c80390d63f6fef5826b7de3d19ea2463a4c866073efa0f7044675078975ce37da38a868baae2d63480a1c0d15af26953c864adcac62714065c79ee3108df76d9ecd721ccd0007432f2eb89f6aed5834a83b8f91b7cb4789df8c3da6992509ebba9dd699defdbf23d4a9abd01fb80b7d89b68e8233f0bc8bbcb7be5a1f342a30b8afae59c322b4578bf9a144667b50f41cfd271612805668163c0062b92ba103ee5e513d34b97366d042937ac28051b6200a72ac597442fd169613e35fcb53123b977e7813dbc9e4f2716a312014490cf8010d364297f610314124203901599d5d2651df95b899ef95a3b23616bd8fb018a1dd7042cc41ffe4dc885b64e275368897fb6a67c8d5779bb3d34b49808b51e540d410c95d5e38d944df478f17186f5b603eb5afd05e6e07c14b90a0ba86190fb03dd5d0fa5fa329f96b95fc84c74d292cba1c3e7c0b1d297d081c2599de58dabc4eeeaf97b2070ecd4b0c65c511a514e51ae9a0c5fcd9ecd0f71a2c25b27c4e9fe0f495760421295971c5761d5ac7a4a4f6555ddc7ddc7dc1b62d3daa90a0402117c94c2281c0d37094b2977fc014b7495372d668b02ef98039e94b276d5847c3cad37418fbce561db9ffffc01650bb9303bcb94c1033543edb3f3f6634ff6365f34679a40ff8ee4d8edeb90e18052ae108281b0de0b40c5d3bd22f0d957c3a9c69e90b0dcf669befd5b01f2133cc7e55ba22c96ba062b3429a46055a4f0240eeab8968b0777d5de2f54250eed3397c2ccbb205a27aa754706ccf05a3ad0c830a48b38b165542640acbd8a05c0b6dcdd00920c9fe7738117d50e5420439568d574d449335e319484ee5e0e6380a49dcd1c78a945f074cd80f756a639831b3e39e8a5e72067870a087325b2ed83349e46fc08d45bd4fd9835eafbede50ac836652cd463b9b4be21ee4b6fc33615155111bd0fd32402db1d058e10468f6bc601b99dcc92e3cfc972b2d2621d7abe856741d0914f045084c729f090e945bc52db7e6705824e090001ac39c14a79abc051d96a3c46503f504cd0613b7c9f411e1767ffefb3fd9c49158e408433345c46b52838d61d73b16171f9f76fc1bf33df99cb76d3402170318fa44e3571d2fe0617cd09ec0ba701c5e23e008cc4bdeb203fe6b4cdcf11c6681193d86c565c3aaadb4003b059e4ffdfebf0dbf435543b9a157a0a0bba7b89e78457953b0ccdcc8b9f828d6d19c42f79404ff058241a248e2ca64c29d86b0d2b6d0c607876f1c5787c1de0d95c816865c7b1e824431c04075f4d535443c241a7f79fb76928c8f6659dd69c6c11ae896d38f1307d3e8a173a50e5d9a89fb088342427c434f27e26a9393c64b62213ec2e437499c1cb0f7a88635554604bb8915486df66b01e8c8feafe90e96ff49db468400329d971c2bacb3b2a0b27e73746ac6d60d2e78b77cdf93252af7de330e6be6474aaee30dfeb8f41869ae4f0d39a01623939c6f077917b79e14285e2659990355456ca92202d477e9b6951ac296b521b3ad5c5287bade0a0fb0c16d04b01bed867f60380a608d06cc4bcb21d7791bd1da700d218ae831b87c53ff120d18d7973ce1eab858b7f146880f06caa620eb33ddb6b2ede08cb7a00950df6b87eab8aaa3a6e3f7ef914d7ab539e90f607135e0137678850da4089e5b271f44eced8dfb2835634cb8b8acf6f6272bd2c70b82798f713338562f4ebe2d1b82f76b8bd23e1c630616472f6b798467f89d6309920bdc8d382a7de33da4f674208216b9745ed4fcab38a1b08a1d585599dcf74069f80031510abb77a4a854fb3f3de53c89d25d6142be1952fd77fb2c3e0aaa13b61eb12f7f19d591cefad7d3f7b3e69cf4717ce9522ddd05320c53f17cb60710c6b3f046d392b31d847d08749b5ff630511a68ec7dd1e218715a2e5a90627465fcbc0331e85f7bbf61c141eb299579abdd61490162f9574280c125b725f1b920c1a2133931c6f79db88a7014eb30cae0c956e529fa87fe589a656e3e144e17787482975d0b54518392f8669fb208e526e94a6f1e4f885d2fa14c666b1bff676e82847e6d8660057c0c21a9b0050f53841c583a48e15e3d6b4480b8d2e8b15f6ae6328d1587b5ec2cc71277baaa24f365b46fb011ec7c44b9284738ed87921d809b1af3bf457ba74906d564c96cde5fce93e13cc05a90aab38fbe120488402ac06bd53bb1907bd05aec611ddac01bf54d98ef92d1971ec6163897ba800ab5915baa41e3474c23830f5872b5d8ade79820e45c5ba6f42d860088eaf9ab3013af7b404c3507ac441d3553c244e7eaca2a30c498ee343541059a2330df5b818ffeedd59b9bf36badc30a85436d0a1e0eb200ec8f47a1357a348a5ee2bb2c307fb57c3697a859f296d48668a21384f2aee7e817ce1d8350018793c5f2c4ec5393f07016286fddf82466d4522bd06033e38e3cc5057502b78e7171fbc10b25f86395a7adbd7300725ecc85c61b13ab2e882d5c45c42c42f2170c69b7b65dc9cd40088e99358d54f93a4383a6744ed8e4ac445c80dcd503b36465a68d8099301021f77cb5e6b8116e8acb643dd9a9812d04a851dfc1913bc6b865216af89b4f9a15614c7244ef85ba50c73474f770036b9fcc0f2703e7a4018c0b0762f98d347f6ee8d9e76e5246ccd984a450d6edfd118ba2619112541c389d341022acc4d90f820ea75296dae6e8733e0e84842e62b1bbc5707028ec8298c00156c984e7a6f53fe97770d670a6e7cc52904a101dd3328ab6836e838e1a22688a9f94a41fa6421b2a62f801839f48560728fcffed567ab069","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
