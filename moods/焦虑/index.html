<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d802f8e998d4dc823b3a514595ae2e673cb8f20511a4584e8de90471872a8179dfba43ee27aa0b815c15ace70bf321681d925da253a471777cfc8b0f541ff2634a0633ffd0fb4c6464e9e5c711ccce65f0542e2fbfe5db392e831d34620cf9f7ee8777ade5f08abcd6d6c5f5d06078c6423ebabf3b78c30a62bf312eee0c9d2f43070071ce57dd1e6ee6740d34b89c3f104fc7a690924e9ae966db0ccbb451f341ca98fd5148b1917874c0326800a78050e48ddb20314d40847359283bd0082383c0ac0411b6bac643748542a0c919421e8d497d40c37840ae18ad932f7d3efce556f18008954567b6e874ae8bfbd31ae0ffc6693974f4dd4568acfd682cb9ea9bb4ad3d46c7e04101cb704ddd24d283c9277ea3c4768b7fe1e97ce1557077294c0500a322837ad0cf691ef639a990e65df09804b3e7049bacb4e0673584c8b84c73647d91c53dc8fe8167d068f8a4a0aa8796fcdeb39047446ae848d2c4b8c003da7a88bbc7fd135e5d0b858432daf4bcfd139c243d70b9c323e83eea022b47b38bb2e900eb79cc6af43fee7e2176dc821b1be1d7cdc7ec702c453ad56557c80616d2475a4ce4b388192724ed3b2e2ecd9a6a24aaa504148085a26f0dd464f21c2aea99d5eae23de7c718833c9e52b37222642c33eade5808be5cebcb3defe74a4e0986b6434e0497089b748ee7fc474865d4170c09d2aed72a3acc8cb239839139d8789e5d9fcea42dd01f05b53460163d2e3c0d610d0b72c8f57c7b1ad1254e4f4cc0c88f85e816a8487a84e0d9740216688bf63509061f12acdd8c0addfe0c9d4bdb2dd16afdc29ff8539e7a1c03b6e352ceb5d53a3087f0dbf166453d8c6c0ae094a91bd57c4df5e274242c56e70188a30ab5927d9280d38c52772e73849dfe122de6a40476606eb184a3142e5be1ddd758501a6486e78eaa48339dcff14d80e8842eff3d140dec869cc0a8ebc5138e32a18ed15d011c4c292762f0c07e6764a3dfde08395aa53efa9eca746018dee82cc7c78b44cc23cd37d739327ffc2e778665dc8fd89f45b4b5bf795123ad65a6223bd555ca0865f59d76b1bebdec6ff5ee83f67ac7de227d7383582035e308e2fcd315ff8475cbec822ccd61e002c43de9f41bb23978e64b56c2f2e210d4d7eca6f5ce8c69795945cef044867215a2634b6b9a8657a217fe4b3e4b81c6aac04d71d55a1a62cda37d7e4ba416235bc7283d2b5ab86b2cefbec0bff5abce0d2dc1404c8daf83667992c9991312f749c461524d4b77c84cefbb08826bcea91d8b137e738049124015c09f0425ada692444047591651482f9c744ec347bc9cde00a645138a86a1ef4a8339350236815fd4b258ed60fefe9d59f49a2faaa1085dbfc30c3de84aa5d6caeaada38588da431d03a1c114007bbd2052fec8e6963758d686b308ce1f8183f00958db692ab0db0cac6f8cb40f78275b47397981108a881727a84c5290ea391b2199c27dc4552c52ac9d92f07da30f15f03ec7a45a53301c3898feca3e61b1e18528844b682708167ba313d70c5479eb7517cd0761aab3d47b7507299d5782cf556bfffad81527b2346f04ac94b91c4f9f2f05f3777e07120cfcc762ccc2131326cc567d21d2d1447cfe87e6ac10116bff2aef2ca42c076e9991846b45c27de04de0f3bb20922353d54a22f714ba4699ef09ba01c4be1538f084a7aa1be62d86038cad4089f4e4f915a0c26148299d8e9ea54831976ef20e8b6a3c489b63095b5030fdb05b8b9ca4ead65c6e90d0bd991448da76e6b74c3d9daeb4434630860dadac087d2a66ff7e3f77da77c90acc9290cb1be3223d19e7e3f1336aa04c36c3afa18a82c597e6bd614660ec77740aea9bfeb3dc1c193015ba616a46aacab527a810a96dc1a46c23512edfc1cbbda4f41ec0cac85f0f5c8dbe145c1ee9b2e9c120677ca5d5b3f6897d932bc7b131a3d11af82a3d59424e440cdd43373247dbd378ca1074a2c4af41b762a37d84a39e7e3d6391f448e453f98149658ca042361a75dca4e8942779d3c98ba451c3b0ce333e7850aa99c91acd44500aa7f3a53f5a636590dfffdf15f52be22c35e0f31f57d91bd81510de8c2824af0e4b90cde7f5bf688b71a1aa344346b9ced54628d1780ab1797ddaf2cac007b04b36f48e675e0bf38efc48f1065c8d74b3d31523f6b42fa4154e8cc31422af886d2933189401946e76a7cfc0828439f520cf502bb81d4cd3764b91b82fc2c81c59632c02805390958e2d635c7e8d6a6ff852c82ba7c24f7f5eea5119b9bd0a032171fd7a28cf93a97dd4c364acf3c7dfcec81a049311b7e8faefcdbdcd6b4e05a4487881c1742c049c69478eeaac4af379c1f721f97069cfb592051339e200ce9bcbf5d02db187714f3d51e8c81845ec799b92e076cc143a94eedc911d008102103b60821b00d5fe409cca24d8b21a55b58c3d874cdfafa1a328f30636ce08d9791d25d53f37df0b418424a2d9ff0d4e8c73c2febf3b437c984efe30d96e508ebc3447ce567945f977ce59038cfadf040d32499a030eff64920e08bf57ca296fa08bd6dca15f24bd8d0413ea1dec11f1bfbe0f62300de16801b2675a4cf07a3f68b03c06872dd3f5cb876f5525554bb7585acbacb0c7264268cfa60e4aa5044f80780b9eff3df00d227b831a8b09333e393515922be2542091a67cb096bc78e544f474f05b44a31a4a89d63fe25580f6a9d8c4c4480a73c2a7fd1712d60084b676d6a1a0305efbe3339ff799fccbcc81dbb8668c0dcb365b4fd6f02e15266efae7148becbc78f3b87f76d1f6d8b94ccb7fd002ff82c87bdae7aac47877debdfcaab7c90fd59bd666153bee4bd04a431d3d58fc007f19144a48353313fd5b574560ea875f0ee547bca8382e389e3c78a3cb765323b023f3e8fab0b530ffc380f63112c35ab01a01212cdbbb1d9b6f2e5b4625c83af46c34ebedc92a480cffcb662bc4d4679ec093ed5cb467bbd1ee05743d12a47ed11b03dc9671e871bec8851c00dadc44dc6713eccbe1b3e4ff87f66a81638e96bcb5f480762a1b01f7162269b6e20061f00adbb33574e48e1b5385497bd06745261c7685953cf5df4b6cf31457924eab44a14bf0d0675effb7584b298449207e4b6ee6e64b5663b930a257f9e2f610ddfa3664e3c27409948af1ae65ec95e28d204200b7426ba1cdc6454a78e8e219152991944d5826ddc51d4f4e9e848d4b60dd542c8f5637f2773d51823f499185223982574e658d3187ab6d3525a279ca0b4c7ff81db78a165dc2c412d861a547aa572d0c7c72dc631cc0765b6d11a5126c7109252b87e716fcd1eedfd5a670e5ffd55490d669bc8442e00ac1040896d89f3a44cac325771aa844b447efd0a0d3013e7d264f5f5ec847a8b87c942ebc8322ce909d245407159083e0526c2e7a3cb109be10ee615277be6e09a25aa8f05c48e816deffaa7b29fb9164dd70a41eb59fd8be18d091d08d931f3b129c51f7d919a1c246cd915d159f0890d7e8610a77cb5e1877f4b1d806463d58ca95ebb0f0390fd60466652b9ca6fe7a8f5f3272b001443f47e8a7006da70f78e54480f5bb0487f3f1459cd480dab9357078e2107006424caf3e5515525bc59100b06e72440566ff496119ba4ed5d5578907ccfb4b01f22752290d279995c6bbf32238544be32f3ed0386d0d3964e06990da1fdec0fe59df1f17729c767bcbeb2ba8a3ea091839149ee581b77a26f5481cef44c93fe9728b34ae9ca544e2c99d862755ef452efb73d23b31cec04daa062c5d704b2f0187fe707e6a2b8c4e062ff8cc09da91b1a79a458784e89981c9441e42e903e6f24485e25d02bedcb3ed97b5fe8f4401fe1d747002a5d6c88212ec06ae19576458b535475a0e08f8a9f20208474499d3c6d3a472e1267e63f914591de1e2ac126a181412bbddc5bbd0c557888106e7acf6e88ed072f3a0f40a1b0dcdfd782bbbc26947ccfe3f2cb3faf2adef70db84897103b5984ba1440ecd5a7f44993ffa968dbd40d8baa3590bf810ba699e9081f0aaa459ceb22b308a61dfcec40ba71632539c088ef52940b4c0fb1f7c945a962f8ffae816e876b60c13974faa0c08183a22cdd0a83a3df82b2762c9e090077beadfd7dde5fa411ec000d4c668dd0d3a58c5292f32a86cfb9de79dc5237c34fedf58e7067e7f4823bc035121cb93a1c8203db5ff769d8d5c56b5a048515c855d089ee85fe45177d7aa5a37dc46cdcd82d451677709232c19b60974a4c688839c9599ce422cb963457220fc3628ffdf822a76e6df3cc0033ccc637117adfb1c363ab2b8a32fb38d6faa20ee6e624829fec95f51e8bdbf85ce91ca62aed128bc65ce86247917fe7814841ba919e68f8c6f07264ee3d24a4ef70e6a3e4f2bb071d89a41e8b7c1864f279d24ff47ab7d7b3e4bc7e29acb56676c249fe95b638a2fd3809c09525f208445638fa0e005178f1f7825c2fcb4d998cad36aa01a0ce2548bd5a554f57b99efa0631308db1f42c079e0f168e86f4eca4c97604bcc911bf5f881717b76f1685117aa971d4f763102592d05f42482ee8721e92560cdb3326d1530e5fa6f8f6da819567e680f00cfdf83b6d2f0c3ad73ec7ab744424116084ff13be0186dc960f44d0020fd2a42421ce22c9526fbed79800ea7f823229530e96e094f343e23901cd040250cbf8fa8b1de34936bde87914a128aa9ccd705de0f9df7b32e76dba5da73b6ef7ebe7f05f5df16d2a4e3866906bdce0c8bded3e20c53ee200fc1ae33b6c6c66445b2031b9a4fc5c6c2cfd320100703c40c3992c688f4443ef4942b4fefcebc4a808ac52f8f454ddd0050a048d39f4860a5690c50a87434db5b8e14ed3e1458e2c4e17e6428365a42c2033e1014205fb2285244886f90b5cb6415b61243c29ee98dc3ce3ed10bd12ad9d7f10ef0dbf6a42cd1a9e296ef1bc76a67294d6011f0b3c6f26c5663f38da9fd190f55d9200e3bba652f3cf1ecab72cfcd0b517104ef8e21671f249296bb11623afe82580247b4b1a27f634e87f4ccdbb0e5e5cea5346715adc7cde643a0f7ad679b0d2da7de545a8c9d6eb49924f8e8a36f2b60254b91826d87e0ce0a60a4449f7fc4a0c2c4144a3dba45eb2e130d25b33a87d35a620a34245b8272388b1f1c57a8661d0b45d8281deeaa365a354b2aaabb536726e93f5b4dd87794739228c053a33d8f223f6df47ed09090a02bf9bb49280520f9a9cab184569a4c7b262cee077180d5a9ce9ec464746c43ecb4b994426b9b5ffc89f4517c70f30ca43fde8794acf52c9bf69d643cc5817118fd07538c41b8f51251d315d376f229cefbb297aab59f7d3239278119d25d179a5db53d03f3f4bfba11b3b5321b1e83c189b3cf37802dafa383543e3aef93c52e56970935400b1640f40d2b24f1814507e07c0c8a9d36f3ef3028b3a449bba27a601104bc4bd55f235a2710b6e70d602e307a7019cb30467d116c92aff5dcb657341a26d0f37c28834b10fc937cd6c5c73a25a8d0277fd9d70bf7bbc96091454eb9de941fb4ad4e36145de1d7796e0aebe896e53a793696483aacbfaa6362fb994ef5adf41bd50d548c98bfc6ea9e0541e2e362b64f6f1ed9e775c7a023e1b28a87eae77b91eb6055dc38cd62a7cb0b1d9191c81507595bf6de37ac7d2381761f640d30d078434e7b037fbf885491528df48a914afcb61ee9ddb36e86b72f31914c0bb32f68b3567d0280b105276f1e69fd213d623d664e25ac9f25b83b7a7492c11d3c9bb8abe567b17909e7ab3c3c31583d29df4bdc6c6bfd497952432f38a380c8391ae7bef742fea9bf81afe4ab552adef70195cef732b1a87e25b1a50a42997a2da0f5c0a1a50a943ebccdb19986b18d43ce1c8db24d74e410ade5101def97702f343aba4237779c17221b54f5d39ed0341da4387c4f1149d371cca68bd20e429bd72cb667d955bcd8f21660c3f7a6b6b044244d70f7113892fd09674e62fd8baf934c60793135ab6d7499fe7e8800fea35c6ce1457e949c94f8957ce88dd54c1eb6382136e555e68bfbf5b21c2166c7610c787e98974d43a2366c46ad59b214a274c2f3718ff157e703ebb79192f406739fd22630be1f126dadb1484699166d59fa8203c585044fe0db83690597f5122e4338586a57471f4adf6608baa944cc1c98ec766ba3756f20805fa7076d3cafc9635e76c850e6151042f76b11bccb3b676825d2ede67ec1914344ec332148105d46159553cb1175bb0e082ec65a793f361ec0970bab6595c2dbb3733ba79afbfafc2525e22f8301a10f375b3360a3476c176abc1c76120cef5ea096b33914e224b365047dfa55aafe345debec69ea95fa5f31060efcaadf240514f1d5b247ca774a51c4701fb335e48e6ca20e884086a0ede3bf5b1511be983568974f1dfdfef1c07560c4d24549c04e44f5678f5656778a1b22ed312cdbd072818f277e8bdcc917e1971d4feef60b7fab272ac628ee4c72063bc716b14f994b3279b44a890660570a4682def932d65807e4120b4137f624fdcf7faaeb9d2273782ea347182d13fef465061225cf00dccccd1567136f6b109f2b46eb815600c21df320b1b1d9b83011f3da1a4312d866a9cc65eb76e0083083e0f17693b71afe911df5de583f1472f4a63105faecdff21231a5df001f8d2b1fece5efbb5de394815f296cc2e387316a6390923d7244051c79c1053347ee89172d4afe00e44b8a1336de612d2d47ff0def4b2e75e2d780ed02deedcf7eb3faa3048b2d41b1395dfe75a48a9b277e2e1dcad9837b487578d1d61704c8169f29786874225ca3c7a89fc09ed8a39f65f886c18b17c39e719c4f8d23a53f8c7e4c90cd71db93aaa9749d61013c70d138cd4fb8d3b0e7d6fa20ce6bfb2926a5b8ed107ab0b4ba34a4eca7f14668e5910eefcfd27839f1558dae6cf431d4f49d9953ce8c1f4c074a98c8f3f10f39295fbd1ec0a156bc8f89a6e05910f7f0cc3d18b6af81fa082b8188cf8c1e861c3fdd826c4d3b81d1e33961187258590b512725787e22f4d4bfb89f59da55d69955adb4ba9f720678e8ef3f2ff40bfb8591bf24695ecc445388781020e27ce1f30e4595a20721a216cd7c6b9bb8770c494a79d4a50101a0af94d939bd3b1bdbba32d2be47cb2f5cf7d4b5e49a41b3e13df7ae6329891706f504505bb7bbbbb2f5e5eeb0608cee4510a1bab01826fa82e2698cc4c122efe794f9d32b5c801b45687e50fe4c11e3534632301832b7f08ca27f092977512a1482b222a650cda287d9f4d166de31e95e6f9817580b92f8ba3e48089f0b1ef7038e32800a96037a25677ab614f4bfea6535ba4e34a6bbdfc140e81f1f22bb55c1dca7d8a539ae22eaf4784f4e653f51fc24b449c00f67c9ac6c6612aecebddbe28d03af50e0bc05c56d99a2f3376b3e4e34347c257df0d94366892d19a0f050632edf6f002ce21b19439358f7b02b35475aa64f8a506cd616c256f1c6b76292896c6cdb9256dda646d0a6742c230fd4df57f46848a6dec1d24241593845b62654d24a3418f612e1b5c13371edd3a3b0f8c89dedb6efeee3875692c84d4e49aef7079e11d85458219e8294a51d18883aeef0c0867c12aca885ff3190a922e94249e655ea54197ad50afff0b75a591f4dc6407c4748b234bb21680c5b48ffae1da4143e8210973973b0bf2170d1ed6b4f50ccf1e654b958923af0c3e7f6d64ba5d2db2c9a671da4fb278f5649bbadba49d8a3f50df9e3bc8dde69546acb9f3552b818e5d7192ed54e989b7744d8e8c7f56942434ccaddddc4c53f31a752aae60d07429fd6a34a303aba329ef8d250af3956e9df11e7fefe9d63ca22985a9640def1065c725e1b4047e61ab79d5debd4872bfaf383a194b2fd83f8010987f4b89f17a4b495c59201227b0431a9ac528ff091b24baee84388a819ebabf36286b11a2008d8cea1950a40867645dc04304395e9c05162f8c8cfbeb46f1e3670061d90fe3b817dad186cecf733c886698d56921f0329afa01c6f4de3a1e999ca168a9083af7fdeb2deff9db167fb464cf688d7f560d4e2d4c02bcaf50e0a845f63e1f233a3b3713b9691dabc59066d43531bbe0ded2ad0ff31e959af14f8fb23275d6af6f01e0390b19640046a158c344968754b182faa2391cefd35562242c0efdf31392f87956de582cd14eba162b0e277ba92df798f6580924dba28ba220d107aa6da856ec3f98589ac2fae63ef9ee7ab3706af67df6f6a95d651af886cbc36d423c5e198cac5926364d3a3a8a2be878029667f5fbe951d9f48543b3047d8bb9eda7adf14289c168458062f7b850bce663f7ef4cbf11855de6576d99a3c594c12c5593339878f43c2d56e33374fb8f29ddf8f5ee6caba560d48a4290bb69896c4d8f63b9b22578d8bd80e7ff28a112c9a54d99f2c9cc1c35b6fe80fbf770da913ef90b40cf54d70e800ff967bcf31553368cbffe75f33cd30676eacedd724940b779b10fd9800e5d99c19fb3086e88127889d829b14b99394b32bfdff7ec293e152a0dad538dcaa3ef0e1a95cf0a3420c888ed0db4856f0aa7b0c047bf770f3d45dbecb5acdb8c46bc7106719c3e864dab83da240dee3249be330790f6b05ac60661c191a6043a9c1b27cf15bbb63645c116c4a10882bf757c7f75d2b72eb36e38d5a0de9a9b090e7368f86565eafd710b2ca2045808a51c6698d4565412b635567c35da44c99aebd19e05ab64040d4c9cf0dc288c17657c1a31ab165b241a0c7008f8ae6cf70c99bb9716b4f15814f584ce2cdac8c0d235f6102e90dc203c7c4429c8195134cd7d49009a906d2b4e4687118e1aa8e750bc275636a0df8bf333478cd305d25dc0bffd42728714914393a786a7f2da26807a4acebaf177953903a05811169bf3b6b7775e8b5277c83b01ab5874f725df276145ef55b2f5f39920be0db57791020efc4155093ef31ca77555f7cc84b8766f08e60d3195ee02cf66fc6eb2b90c277129369ffbf5909c4c1c29a56dbdbaf9929418794eecd5da15d3f63b20bc0f527be7f2f3abe1e3aa71008d2d0330801db9e2a162a4299e124e361817f98af429996b4fa9ded45ce474e07c9781072e39b0fe5c36f0ea7fdbb7b1c01b90e2220a50d3f2534809713b04e41577154b48121a4d17883478681fa49c48a40e82bc2b0ec2aff34dbf7e550f75db90c61397e78dccb65aab4d660f2c8085f2087b7bd65848a6fe37fbb3fae7851caaae9785739bb11148063b0707e2f39335211ae196a2466f4ec07ceb15e5aea515f57065a069c81246fd89d9f25931be5260de2c310b6dbd3932b3d051b1b48a3bab983b8c963a6e6060213f30ac057556aa57e6231a11803e81374747f6568cab3b2309c214822f16e636e923b2ffaecfa424cc2d474a9a5da90f7654ced6af86fde0e6d8dd3a231851a1830f16896cde127e378883c290aeae59ec1d259cc5de4cd5f2e7226d397c22da1c9df93cfde07081658914f5faa44c0fb070530ddbd8b326f0acf25afd8a2ab7d9425aaf5f15f4d5306038bb9aba1c5a714bc8e213eaf1585768214aa7c4ec6545c0ed3b92ecb412c15d025f63bf569323c0897a603d59d97ee522884e568b790d30066a185814a2cdce6c075d28ca54e21b8b408d8b139c4fc43c6d0840177a6eba19b8dc0c214067774c23bad8bcd2ab3f9d8d81e94e547699423f0342dd8c1cffff0c548ddd12e980edfad1c73cbd9cd2d5f35340b0417be770db4015c2718a79cf4d92e50b4e3b4e709aeb81dc25e665af51f19016dbf8bf6dbc08b18d253556c7935015617f81c7148b6182529cf5f552a091a9f577ab2075249e61294fdddb507f7c7efc11d969485a1435eb228435088f1d9a094a44d84924d268fa881601ce72d93ac836383e6fb6878537c1d841ad528c3f02a4702bf3688f69b9598791dca84f6a5772c348049b35659b8045f8e8f72521e4cdc5cc7eef275dc8252bfda19d629f90973689cec25ec72bffa4cb78e12f9ce8da6eb0bfebc19a8280a4952065eb2e925b9620071f3b8ce66831df63ae30af2260b1dc92036e1dfdd70835aa79b10e65c369e24a39065051dfc19d9eb2807b3dbcedc817330be4c266d8b1997770a0c6bf875b1caf98893015f28c669f4739624365a13185e13468bb9f29c7649531d95d0193362258d94338dc31fb2d816aadec378cf8aa22d25ed9a6743d646842b27ee48eef939dbb91018c63b1b5461f2cca5f3331d353bc4627e4c77f04c57c23ae95be1d89c199b334fdff5b2251ba9b4a6d0d3bf4dd5aaca9d2e8cd7c8e12e5db00f6bfe1633dc7812c16c6daadffe25e078e3302a6bf88607044c6d9f6b7905af4f194481a80afa49cc7cc1428baf8ce563e7b3f5837ebaa264b1f9cee8206a28eb34e4f9b9274281a91acefe62ee19c6f24f0dff1816d45d2f67543d6dec4e3d2bdb201788dd6ade818c21fa8b3b8a4b14fb817c288ba40b12f761a32b7c610ff550f3a924382ee2cafd3802a87202d3a3ee77796ae5e5da40ef2dc1852f45a1608bea37445be68beb8c8572edbbec1bf984aa817ffa428a87a685918811fae4c45fcea1aaadfc33fc891421dcec81d0b593582a41b773280df8dd3922e7a09bcab2b735afe80e18a52d28dae16a0bed1e9f847e56eefdd2f60dfd77cb58fc1988040bacba6e10d98dfc5bce2ce6dac20ecec6af0e0d0fca9b15085dd5b627c20609eda0ec4c85063332a755e48f55c4df915d5d7e28a0636b77adac9f77cf8e48a389d3791abe54970d7b6e5dfc62ae1b863d848d20d1e68881d196d8004f885c519e564c2637c56a7dc29197fbb3ac73c3b1d486ae3f684b64bfedbdd5ecabb071a42076e1259353ec847e02e91aeec0d578caf6d0b1a78f7a413a64b8cd609c3bdee34aa2417959457a83ff659b11caea35f4a148d4e7f052094f6d2a36cc6dcdd35fbaae026b3c153dc6bc5b7bddcca684f9a35a5bcddbec1badcda47cd6a325946dbdce6b50f514fc9b1e8e1b46c30be7cd2199bc78c5feb108d4c69afbdd94dca5345e2fec8912e2a361f1c45c46c2dc9a02e20fe6fbf458dcca4316647a7a89dae11bb195955487b2943d7868e9d91f0e2e3569c772d9291800620011fa80e86b19f12a96a52e27502eb693b6aaeef2a271413f0707fcc99aa19721c54773aa9c4f35b10783a667a536e22a9a2ddbe71547f522d5db0cf389fa1d1e7a8776ca3815b7e343b84e0bc459f04bdb4772c8d1e330f1013954643813347f959265b9b0462f88183d92068099cad012971ada931484617f04a2718249c60bf1a75fc1ae4e918135e0a3d12589b848c3846000ce85d07de5c294e8b5434a1ed34311a6446dcfd6e0e2264cde4e387bdecb78d1863c719f75ae79077276c37fe94093c4fcd8765b18692970401dba904852ce7dafdaf7b0c4402aee22ad49f4fb2e4e613fc844ef5e097ea2bfde37b76a6b89ddaeada35c4689d53f420ef0bf1cd39ad2f72375a5cf30f4a59f75ee6574ce3d5b77959febd15476f8522a1654b74489e4c98f6ca2d81931678fdc2f558245e0a4ca5abff34d83e9eef9c9318b9e6633f36f83a590a10e60dcacb023afcfe264ce7e0ee6f7cbada303abf291d5cca972ac5059d398e79c3a9c1c6c181f2c445141871e98e26cc20aea11c9109dc43c5104b771bd9f3d4e878ba0c2bf792000299c41a563b8beb30de13afbc605a23c3c664f9b0926784fb59b251799eaf5fad5878330b75c15abbc428152578e1c59d2772face4aca549827e7bf9169a46848214173d5a69876913a7b4fdd15c4d52a5c27379fc8799b499f5af785bc71046a1b54e7a394ee1f4e1566d05ce411e1be0f75cd59989721c59de5917504b7d3782f138a1eba81507f9f122fc1629152d7351cd67a27aff09927a9410f331690c21117449f29631cdf7a68752d85907c1d6e9c8973063b7eae520cf89439634b57ec500e2bd1c97350a45b3d54706ffb77f3c102f1e31c54ce466fdbdee0fb72b3efb1099b76a5924b8b99c7ea4f2ba8fd0a18795d2957602e504f12172fb108645f3617adfeddac32d193e36526e3ed537be89cb0330e101506aaca6940e9f101b62c3f7a247a831566f790a37b70328c12cdbd393f03dc384bef8770afc43e271a348e09bd67339e9d8509d2e63c896dfe40ac97a8a54d6ca79297bb6853d7584025f4160eaebf7c5671b0145d45b7a972e4c698e80d59db2b201501289edf6b6ae77a1d56520edfb2ff65dbc98388902ed27d7e4ef5f1e4e39dcd0994f859262ed820547dfd724a7c31bf6cab7d6c2d618f3a6156b0778ff80e914ba5a88a5f86d271e9c370a27205280dde1d8751311e516404d2d0427fe5770bb740b0ebc8c6d1ea326efd5a9116a2663a93564c9b25016dffff034871582629daba750ba57c9baf5f0f92a623c4409eb626b9e32b8370392e373267ef5a9077ce83e56842a83028f6508b9a1b900aa27cc597c63f0b3abb81abe8f728f220137afaff4c97fcbbf383c28444f1edba35d997c41999735caa7e2502fcd9d57e21ca7aa0a29ab874375171eb1b5d505181dad2622914bf145f2b6e44ba36bd5fce7bcea0276ad79b38909cccc4875919945422ee4601f7afa7066dc9c5c08827672fbf0b92632f7d9ed4a49be3f40239707aa82b542cf86bbaa56f1f065e084be0e41fd21c0f26fbfd154329391bb5baa8d5594d382a3bdd07ff18515ac69f660406d73c66fc7525f36445efc3e5edc4e321454f7f25966de88eb84a4397d2946b2ec016aeee83e8ebadbdef5a178ec0a63690434fbbd33b1c82f71031b81ec2bd2bfaa14e7ee96580de9684f7d8d44d31d6f81c237ee1b150b360609bd1d7e977e553138af73ae25081e318d568d76f8496533eed207457af485f74495af4194d0d71e7f177b1978b3b18576b68ed5a37dff9d84f3a28cd6ddcef2adfc9ddf80148359abb723d5d0901067c25da9af3675a86ba357dc5e38da1a3149355d9c4c71f73222ea6b7e725686d5a2a5b3c1243f0468860c8d640242fb00ef2d47ffa6d154e09216866878b979d0e4e7cbae1df10c835891234809664ec7dc7c48629713af9762cbee07e85bdd9f31786a5b9053888bb9c90ad846f988c4e5b836292a932488670e41827db7511d14b7bf5d13263ba94a8459a805ddcce417e67d7a0b4586fc726c22c8d1a43e4cac8f8babf0811c4208809dbb48a0dbf617209ee3f28c98da32ecb8c66df54edad47c13716e402ee056ec602a33fe41b2d126555f1732093ebd19993ac1770201c0d3180040b7d49bdcd3bcfdd0204cb75c90fa43f0fe0e626586a5f77d4b885af88045d9d5da6cfcc14e5c140034469df1c92cc664e1f47e7611edac74d891edd006112aae30cf0b56b665c61d384d40d2e7d397ee142ed15959a4b2ed83b2e0f2ed705181c213c8df20b4dda564600a32b1df4bbf491106a0194bda06b929e6808c3ca17cf32734a07e5f3e8c0332c69a6878e0b429dd987d7e8be1e7eee0f26a16940c1685899cb5b37d047bff59c7a5440c00008eef0229cb230b2730678240b2f4e3688aae55561fdbd7844a5bcbf62f7cc4e6487393a6fad649b36691f2bd997e5a9dd481ebff13ae29e42437bf32efb1fb3e6e0893206cf47586ecee8038d59a75f4c41b4c052e889a1f179b2e8d3fa3c4eb27d6dd577d94694c3ce31b653a390d19311d8a694bf5839a0cdd468aef94f1dbd08856fa1473af4f979e1df9f7c7be25840cd8733c8a2a9542928b6846e33625ff8fd3fed898496f30fba8cc3209b3e39aa33da809d892997e03138dc7342c459cf2871817dfc1711184cf11779895ec146e3975f4946345b7841f5d7b946607f780689ddea5b12fe16bea5ba80b1b392165db6a879ba915772cb5e06b99c555ac1e99457816f1a27df5284c6d2dcb4b8cc2b1fd95624790b65c7937452e863a2b65a81fb3e11c2574192ec7f34a7cf4d8e6573650f5fb168d8e319a4d3486055b61a4a575d3f4d9eadce10dac30d6193a5a53ffd9fcfacbe86c92e0b2d6da28543f3cc4d76c87426ceeef721b8f21aaa29dbfc5456834198f9f94e1eaa82b4e3cfb0d3fb0aca919b115eea48b951bfb9b133d809fa44a73faa736098eb4af38a7f749cd6d849f9695dbd48ac5d29e30618bce388e97bf542b1d9220d37386f6087fde8dd2bedd731f353129523b426e9b7aad77852d4acfab237ceea8121832e6961ea21b0366baa93289204a40d8e02dacbe5598863f8f9014a054f739920bc715bc1bc3eaaa597e31db045dd66bdc7aefbb73f104aea70dafca460b72454dad56f31bb56a9b2b62151abbc03dc412a48ce888ad4ae03c036cca494a95d79c6df88bf78de597312feee3569d3bb2a2fb25f764cd9573f58cd3a61b19d24852b202570c3e85d31adbf78292e42a3cbae6bddd2a64e6c469f6f9c420aacf905aea1e7370abb311adeebd3e1f4f40ae5153cb5a9dfa8ba665dda6402772472bb6a8121b1bf02745f921ee9c2d500d51dd4d179b5f23b5235035b4b85b73f55911c97c190f60cdaf7fe524ea0a154d28fb7e0bec88ae5ef00776943d15328c038f033a26527af8d0aa2bbbe976b2f39b0fd1ae3bf3ca77694b3f5c44cc37d4199847851a2a61c6edeba8d8ad6f042f9c31132151efe318c063f5428355884d832e2e6adcd59d0e7aa3e6357ea1b0bcf9d80dce93cb82832047ed385a3850c7a5242ea1eae3d2dc7f1aae2245de9ee187a71de7d3798c5060dc0ce464a28119a326214f1f9882e36fa770a19cdbca36a23ed33f1a45ece974f971943f55c3d615a1860d76b3f0abe2ee6e2035b9c7555bc41b703274e69bb8924a3eadb7bef5cc9905235a2beb8269f6e0bf67d6f40d8ea1d83f753a98c37a226ae501443cf106de7cd8071749b2d2928756ecb1a4f1ef26cbc8db670c9f5b0e3e7eaad7b1325b2d654465d80fd8b73143d883819f783818083e7cc011d4778e2882a93ba3b1985e5544b558ec99482439775735d2c1e80cf596a9d44cf1d4bd44503e109d9b1110d3d658f48fbbcfec6285fbc02e7551766f7a2f14e4dda3bbc03587247ffcf7b2deb950c7114d6bfec2977e4986577ab79081e9566dd49da99d9a16507975948c50dcfcbe76a2789aeccb9b660ddf8277491e4222d61f56710ef50d9e2ee8b8732365d5e913660530d18c3f8c9e7ecb003fb94764e6f8cb39ce67b0f77bbe5469758d64e1d2d33b4d9e5363a577ea7461466ff8e86ec36f83761523edad41fab79003b2aafebdab79d85947a82ef41b573d59a445dad63e4f91aad633905fd75646574dff1af6d937931f0e486dfa7fae98aa6fa60bcab321ace4e7bb8c980a42c829da952d2a6f622e8d853dbd5e283fd49570e6d21b565f74fc18aaebdeade5595cb427f079d0187feb1b50ad061b40682500d30f4ec8b14d64b029bf06af183a177f4cacd20c96091170e7a8a72136486cac53f7c48a800260b7dfe16a005edecc230e7f34e70a093e98dc8b0394292a1a21cf2c5388c3923981ef8d2c52def3a80e318506a966cd77ecb01792ba1720dcf64ece338e4c2d75260d0db17f30a3a49f406e96f0250ee31a0776631b5bafbd5368503be26b74d5c08255e0dcdc3aef71ddb9276ff7912b3a48e840cf73b296d86f3e05","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
