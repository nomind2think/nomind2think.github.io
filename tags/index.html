<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1aca911721a2e56ccb9440ade340310a9f1333446b8ce9bed25266bd40ebc539ff44a04e13e28900ac312a2e3c4a070c9967320de3f619367d390bef51806571814e3dcdf09667cefea6dc05ef0c1f3dc898e3a141a542812efc91b3b54684399eaf4160dd551efb202fc413141b6848ddc13a7a29053455202a03e04c59ed7aac5ff8b25a1084a69b1ed8b4e79443c0af19359bf923a543bcc648956c44a2f7bd657d7350613578f915c5f144dbb885dd6916c696356969609c92725ed89e41e5c2cdceaf946a7670f5f7a587ed93b9d36ef0ea988bcc79c2a0e617772b9db947d8336ad0c6267746e836da23432b432a3970333a8def3d1a65ced69c9f063a260ad7fa530a5c25aa7f51395dd3899900d6b68727870196a624e0e5aeb61aabc4640071e432eae1ff12fb425a99e5c4165f8d434f434699092314766539ac2ceee5abe7608daffaad6b3d3835d86aea2b0d92bb0f00d1987f289b4a5f96e25de86c00085c9ec69f3dd64c5e1adf237d6a81768b1349c4ba4667fd8230b41164da1bbbcef6f42e73e955a33db198cbb78f7b64c5afa1c71d00be04552448b98ae6686a5a4c10333e31264806a91ff9924e353ff7a85a6edd867ffc71ea6b5d4a51f573b0ed9cce9f065a5659ba822786360c365c6c70cb7257d70e5e22530c743bc1643b993d951a11c08d3ed57ea18fbab91d8b19c3446168a5d70aea206fee93b210d8b198f88cffe4bc5fe8eac48d2d49b0b6cc1084c7bd40b72782c7e6146f4849ec34d2fa4f25ec17be5922b30e08dea0a94b1c90d0625afb5ff5fc9408c2a9a7a349c2bc4874c09c785dd99a4db3d5c6a32a967074d2cf21d0fd45c723c75fea183f00d2c50d42b4d450d536eb934dbd656d517cd2495ff57c6d2c62b1cc14e1e42e09fd793d1f9ee61188cc8b580034897fe39a375fbaf784525df0897f068c5a5c7fdb382ba7c94a4f0b117d1dbcd833eebe9df57dc1bb80029667b0c8af97ce4eb567347a7d9f6bd8b87dc6fb8f8f07100bb90e9418ac84d25f92309caee96802f78eeea02ca486f45cd9b54103aab9bae4ab9876719f6b910b369721369caf805e62a9c77e888d780f317d10dfe8aa37f10580d4ea0415ceef00f6805374d8e2d01add989facf59a27e1bdfaf407530af09ec3c482a19f64bf3983a2a5357731ce398de9f7ddf764591faebc98c21b450f6f7824b59977c48d2b49ac4afdd2279ee51b4b4bc989ff4b1baae48a151eb455fce5c7e4c0a86dae894864ace51813a0d957af72af0307c9212c787703eed13ca5418b3d711a2a87eeb1d0afe26a03459d2b4689ac112ce7c3d535127bba80dc603eeb854e2764f827790d9755ea399204d51bb91b269c7fe61b8b99a88c309cd69ec143db7125c8e0c569c482c440a64f50d09391096ebb5a23fcb2c0c5a848da9c0c5815d00d2462739645454a87867fae0df39895342846fbfb3ac1726badd72884492d0bcd5251bbd06612fa72cbe97cb1fc66d65536dd6dd31d8f7a317655484fd9d01858496d879f31862b8760bebdba271fa9eed54cca86627ce0b2331e1d7076f6cc065792240d36847ae3451cdd9005f775d38adc79db492bd309a569657aa67943d56dcf21beb8eec4c1b1cf646a09a112ea062117229197c9ca88fae067f648813b465d62f1f15719a3a06bcd27009a357dee5a7cf5e6be6104e10a444da0ebc72d5fe7e9735ec8e5d8ed902b882662300ec92218f3dd8180219026e9aaed15bacc9246609ed810494b61e2c5e7ef9d00712f379c9c5d9a758f778dd5cb240732c88d7e5554da84acf77ed3e7dd3fbdf036c0cb28ccb6be11fa58659e5ec06ce57b2368565d39b78d607c6350c3b6f7778e36f4b809ad1077949a4f7144a072b969dd7d4b0325e59d906fd70c74fbb7e209ffefadf50148db6551eec6d7f41e4af32a9c0cdf5e245d0616ba7f060b0e629957e84c969affd0db0d7364e362d62c38b1694aa79971a4e4886d9a360778a940db4cb9354006682fff11701aac63289e6a823567e8e78dc3c236652ee7d85f20c433d0098244579de5e0930f6a47f1b2e2a364746780d08ad31127582317db75a67c5592266dbba50971fa9ef60f3e73123894c284eafef3612293c439ba0920748e8f029b54135937c8eebab0b0d5a94b376012aba89b4cc875bf7331430a294b7246f50a82f4c254c23b4cbba0994d86af3844582ee3fd12c8ed9e56a8c0125d83f763dda80e2d5bddcffa99aa7db495ae7a28aedf221c47e4f422dff013ade7b033f0e49c5ce170debb59fc17bda995dbb82abfe78dcbbd594a9746a9f54f2b761b210271a4ad3f7eb3ef4795a714ffdde18a1301e5b9c9e5381641386d5475af4fc1d04b3d30a76bd2443669f7ca6d7d5f2fc2ef0e13837c0ebad4e286a3f7b13054780868c8bc92139cfbb6a1b1bb150e59b230d97854e5454c26b87f322407bea6d1e8bab1b4276821ffe13010bc1463df03e7937c235a9d96ce10988dadd1062288ce31821d7e3af0888efaf9f8a9ccc6778282d0064dbda36c8340e18ac0ef84f5ff5eef15dee3534a36fb3bcf7c0aa59f81f298db79330a7789f7a0d828f356ebb31285b7ee7b8b69f5370c09b135c975cb39107567e0f4ad46aa4a6604a5669ac9bd273e56777117dbdcd5980135581de66a8df028799f9fc590d578446b58ab44fcf98d63eca3e096b1ae6127b9935d3490ed02b5eaa4b77df7e30ff8bf16bb2916bc46c472d774631b8cf9aaf75deed6713c784dc3446f6f191defa6ae79c3b9bda1ffa858d52b2e6a354140d2bb0210922ea57908f223420334539d26d063a399dd5fc404fae15ec6967dd33b9c62c66bb6a40f5f44c6861d7d839e22ff5f6cd2f57ff016f36ca3d5f55ef5f5642e052c80bc26e0274761224e531f0a3e7474bafd25b442c5aa71d1d0772d567d22d7de0ecdebef5ce5438da003c5b691192399bd9e4510b06271fc7384ada93bf740873c5863bb298f234f2c1899c8ba5b19584d8e09c2dc59976846fa20abf6be5b9b50ebc65cfe46f42d38f51ebeac4a7605626daa8e07309c1ac9a18168375ea0744903a4171ef9d980e9f826171ed427b0763658421cb1229f7f05513ead15c276131077827af72e57ab43c81f94fbd7ddb0030662687ceb7dab36c6473a3868bb222cb12142459e38fd437425d5687b821a8715ebadcadf723f25d9ef1adfe8760ff100f8ea8ceb6cb9ef4f600014b94ae6e8a472264517eed02eede9b577f25ee1701dec065f7bd6ec0e4eaae96eb54f84e1d5cd6d20bfd9dbb50d983987f7aec450acf4803689256f59d83c6e47ae8844974042eca18d558cd6bbc8009b4d98014fe94a54e2bf977b20ee8438142c874422d5f0945ace0800a7cb11b9dc83b5577a719b148c721f0a49254211efc5afd13cea5ebd55da5751c599613518c527b72e2ec5ec7bb8a5f4435a0bc3a78b0293d3e39786d39ecadf6ac22de1d60c6b3fc7d536cd6a0286d5ab028c30b7076ff90a9e97c15ca5aa1fc8345737ff34c4b55a8295cec5bd635087d35476f2c06662f462b32d1637882eab8432a77e2fd30975c070d653f11495d201db8d3ffd954565d6cb2cdd9cae1d312540180b2362f81f947c9768b4e483ad79e25209d920bec98cb188968e61bd9338d7f0396e1dbb1a4ea4384cdec06a89cd59a516d79b8e41d9818643411471a35eb98d7d5748dc722582af7b787a52d2b25de6a65e7e7f51bb5047d97796785ab80be2ee23c301ae62cc18815f1406cbb433397f24e66e6080506b924eaaffa24c95dc8f28a5da1ce0f4f29f64bdb2682d8219da2b37dc8c558dc183b07451bd66356c2083dbb8deff395a341a0fe35979f56b639c5e99539c675d2b56465fbc364615a4e242e5a2c1744efca4a650aafd2256414beeb310706c3d564b36eaa90c5467a3211dc535d018baae886f863eee6a7dbabb7521d9b6815dcf6dd5e83f13d3597e8826e23b7fb0767c925c02ec87996efeb7fa7e4c3f8a7b19584e2061a579180c6be8b9d54e19c05e8ed9da6fa365fed47cc0010f846f1561b092448bb73bebb504641d9f4d9b4684eaaa4bcc9c9dcb6385275f2674b8543847dc5d8974594b5411b3e9ebee54871ae95c7e40a6139e60bf10c8273d736c484e99606b59fcad48f3cbc7b5e72fc108ff171adea0bb1cb1871e5fee0f70091856ae6eec2322e0ef9358df5a4188ab13295a0cd100ac311a0a669ca4baa3585e0e58a0d5ed6fa796dd406df79bc04159cbd15a5e7b29d2c840ce972fbd952bc77a57b2836db6d8bbfbe104ef0234b45ff620426b2006ef7f648c6752e4e119eb4bb1fbf50e3a5474e3d492dc65331e6306cf633409b883ca2268868c075245f03f3c8af7b12bca25124a172ee5f48fa408043a62102ea7300df1ee711892c077bd3eefd565ecbe5e0c7a06a4d796a2c3267f512b387b997be7f652eb40963f20020b7bd64405eb14a5c3d49cd2daa699fbc2b8ea6ccfaa5e91c01def426c799663fd91a4e7384770de4693cbaae13b60b9807999ca9b40e04d09313e9eb29edf67bf1dfa729dfa11bc73d84c651d84d4e7f0815d362180a0c9df911a73a884b5cf7de1c7d43c7632f9cf2ebab186e287e01d4691aae3bd04daceada501d82b52c37b07150ed244aab33dd2f7fc147569073a3c332184297e6b6444272a0ef504f24f4a85a3d3c527e7a70d58c4b50585e6adde78d50f1b1fd3de50b1ce50ca7872bef2ba5edfaed89b7ffcbef87d5bee5e0d33090a22892d1ce3a26029f0d0dfd9f6f6213bdda3988fcee15bb6cde8111bb76c7ec440de75d58b992e6e684315ca34d4c3891365589fc3a945ceb12f0f675a010f7061247d9346fc295a9f68cf1e7d81f9f8b05835147d7ab8bf6e3131bb1fea4c377a7189183cba157f8d20fe8feebd1160609f15abfd5d8deb4d9612f71839c6cfc4f462b3181083d3841f443834015f29b5a037312424e35b46035edc1bc4d3cba2eaad13daeb5accf7fea79e35ba4cfb1334d693d9c6524dda71d02e469c0fdbf9340a945de1b2314bb85b1dbf789e9558acd9479ca03ff5fee239e94914b7ec7e373d45ea919aecb52a72fe05d2dbfc55d97edf57f558e18ff5304ab3873d5a55eb060844df035ccd3c246cb63e037b1fa1083d756c3f6e54289b2235f7c79339cbddb47c588bc87ce6ad4781e1df78a1418b43d42f276ff66951abf9552071e190046af1cfc1a40675cc8220509f743ba3b672dc88e9bdceecce5f342cbf93733ebc9e6a0d84744c2546d321b3db2c1715cf24bb17c562dcfb79543570ed4c2f8d17bdbd6ad3e40f2437b0b08492cd87e5283833dc3743da4d5719561c23aa4faf59c89cf98e71d4fad1585ee29426db9ef86e65ad71c28c71a6e844586607058727502f12e514dd4d2ea44274bedab5c1d577559357cbb2104c8d7e9813121df4e21f3cd7d447166f259241c5832e390f2f423d5727284e3d5058806642ab5e86ff83c6ec8f83d140bbea1bf40a018e69b7d7100a4f07d93857999e7a45562ed963f60f41dc95e27f325423705b2348848529fe3136de3f69be2a2147f5b7366d93de92f3329afb2612250677d3cf82fe25c504ebd1d04a9243e4dcc4408ed8a23b0eac6fb6fc4eb243d8a6e19bc2ff552a7f111ab6f63eb115d9a981a9602922f81a86022dd8fc4525c6e7996902b89c34970dca8e372dd61c06b8eeb5b07cf64601ef190cd9b2d5339119ec282e8854518a47e886f1292eaa01f29b4b10365a8aedd9deb4eee23055843856e679dc36caca62b119af08247d8f2e46c07168fe9b247a369333cdb5da2c3381fce3c224db0b64bcaf35879b26524580db1f3735acaa1e219b06866f60da9de6888f433be67c7891f362283ee539a3c9ac06f34968e55e11ff87700401b4e9fd620ff3c8f08ca085fb1c9d771b250a943169cc8e1d3133f3affdaf1493c6a177cb1bdc883721b365ed26554d033b8e4593f774012ad928c4c8c7d0b4003b08202afd6a38b23bd14e7f1a5bf3b51ce882d088242c2f1468b11498bdd4c91bcf1624dfa6a84794d08564feb3e69426e7eb8c57cc1ae4b051443d5e36c1fc48565e4be515f8aead9a6429e6e19368d0a4d3443b7462373ea9cbe499c71fbef986a4c208c7f66dece32fb97cf5dac71a9f3b4b927650c683fbc94c2c231d3627c1c6b339f54f8039f53fb050a30ed62fc3a74b490c19ab5a9cf95a15a6926dc6833c3cd9cdfc691d03ab1772100657e8db258eff057930e60c6614253d0999774468437647c3c9644fbdeb9586afb45ad4213f34e8ba57d68a7c575d998969debb1c7133a062932b9e5d2d9e047ccc208144f5bfe67108fcf5151d0032dc9e7ceaf7ad133899859b56d71262a9167c0f27126a20740f5a441a4fd756310881458ecce3013f2f01ec7bf3f86a98db55c683a114df37cecd87935573b192b7c494c389382e348d77ceba2395dd6ee09f83ca386750807dda52e3acb2a3ddabd6661e3b05b451d14fe78232cb790e88aa8b36a860d12e9303afcb2b93905e221a866acad9b171b6ed75c6c4de0ffdfee52bbae4eb2014b5eec57cdfc08cddbae76c5c11afb3f754dd06dc0109f1dc539544e9e3194f499e27f2590d52e0b15014371721622e78a22f6426b933aec2b9977339bdadaa7ce93638d4ad11d2a88e690d2c6cffe10d78d5270c1523361e8f932b629751cc74b4cab4e91da3e5e4588684ae7bf73a10dcee75c0c182633459a0cddfd6d130961a88d6071ff93e8e07854da4744c4834a95e9742d102cf2e3d69d0f13132d94b665960b56588ed2421b208e92d9c7eb27dfd7d2d71648eeabf6b03682fce27b03ba6b824ab8a0a9454e2589ce71d5300709d5c95738b010e77cf8493311f7dcb73cb11401822c90d1ca55436195f129a4392b751b11b24ec49e0fa84b0685532e41e36f2d1d90b87167c76d676e871686a868745b9c58f62c1c4b2cf761ada95fc5217eb1ebf68b3276d180b9b05ab725d964a68b55be8e12f0dbb71505714fd9dbf6a9fb5813a67881d2adb88c2b0cc4aa7102fa7aa53895c90f4ebfb7c75f5067943d1b47e028b3b2bb43ac1d4e8a9ee9d5be17074f2e0255538926ceb7d1dab52dbdc7cb731a480097c945cdb05e3fa5f99bb060ab6cc9d521d506541947e4cef60263060e944a01d5ff61e39768b7c2ee6a4bc43e4d619bc6354d0d7141961e8df543b9fb65aab1aa99305dd713df6615416c2fb3fce2b8ecc516f6cf10f16be06b9d89734042cd68480bb561ad3c0c27345a4f10e546e511f45b9f1f296554153f8de27f0de803756646bf3888f2cdb75f5f19668403d00eec2239d1b67c15669efc80d78b5ea39bcc36747f17e8b7d0a2a3668376bfcfcbcb47d91269619f8df44c366c76a6eefaf3363234e18c0ce668e54f2ea18b7f4c08050605fa0682ba462591c55eb45498272d134e5df8d5ac220013cb9e5c38d762ff576a0f5d4e3f946451f93a97cf61c4c454655ba366a03908647de06e40e77b3b82ce6ca3e7f9906957853ca3a21c25d0e40777dbceb8cbec5027cbb4628a7b4af564cae1933cd59bb1fe702cc42bc9ae64b84e28ad87feacc9f232a6b25d865e0310cb89e58f3d4102227822c4079efbed22d16f6b61cff25715c64e51f0902c95e6d3066c9401d302291b15928868a8bf6cb05a6a037b670936c3edaa5bc0178828b3a086f7e19617d2d418e6961f40c7dd02a0e8994d96f7f7e8fecb3ca80935384daccf518fa466e9412a29f23b2a7f536b8d28f4fcb427d9dbd98681a15a5004db737f3e0e205f2ef4f15b387281beede49e16e88b5628439a7e0d39a84aed3c00c125505fa7bec2fde3fdddf69c403575c58b13fd26e47b8525f662b50a94c9069ccb5bd3f55fc48692e4cc5c9562d8d8e45b45eb849ffd42fc0f5571f2fc65afd202a3f5cacc4d09a2e719cface2a44c6c94b97aaf6cd6e08f216004b544c9c06c710a873f8ced7351c0c3ebb59658e8b672a0837d19dbc7bb9de9be22a19ef6e0670b4455f34be17a3f861db702febe7f1223d353e6ba05290e22ba71ac9b59eb287b98eccc2423766a1cae0ba187615963b2d8eae6d6386c413e8fe98cc1261e312effaa8cc7f3873cffc0124cdd93fdaf81e0c140a45726ec9bd9cd8b54c26a13267a4eee0664c3e4970f06e19612ce278273b788236c498e84ff4410cb8ad62e081a36d1ea7155f810ad7e3c1fad5f1131e9b89390c621505405cc69c8e625e1bbaf265309cb77877e85ef5a4c7e898dfed607f86d8dcc669744933e3ba36f44205b353426e698d606c2b81c5f5307ad9991118626f25d8e723ba5290b7aae72f366295d0415938f6cc84aa0d2eb5efe620524abad27fd7c73f0b6808542e7ecee0ca0f84cae895f7ca272b1248ec40fffa0652ab4e75a634cef7631f71a5a1965f391140790ca4d591ab20669dc6c993e5fe61b05723c9579d8c59b0a3f0b5fcea5179d533fd32458df127ca0ba4c69f00df9999f0eacca605f7aa60c58e66f7ca4781dc7a03d0936929790fcc5f9bf9424e18a3da7eaa913563c062f18bb9d131c1c3164989e6620e36be9e8c21c563ffa13beff86b5761f622d18a5006cdcef36e562c9bde20dc20ae60ffc8c056cc3ff13e17669391dc0ac5547972d3436485fe34594604346560e790c16d2a0cd463613f3471e00714defac8f7dc9f9935480b91ee1d7bcf9baa56ac5140fd057a42a03c051482a81ac4eabb01382d0125ca5478f73cf316e1f4397753f4f66e8e13bb7ed122ab554cca3b8175d6c13cee167b1eb44f07316000f9bcebb4673185d15219971d22561e1e3f5095998fd708ef2c90f5e76dad6945b30ab8474579a67ac8e5ca659b46bd6d8fc13b29e86d2d173e1a23bd1e32ddb53e2da2269e800661d41338a71366b85a2f1e11d2d11e091c643d6fb0129836e60311d79c43e9ed34a60a09f45d1d42aab244a5dc89c16b87cbf4f6b6403b66c49134ea4883afcbd681e995e8c38d04c55c2495808e4a39c73fa75a1cdc5a54781c1a8bf666f28ac7f7fadb05ba82de251da41c4741fa8c2e5f8b09c3487235bbd9f5ec43c2c8c09095294a6d204ac63de65c4dc0fbfdaa03f50b613170499eac488399cac9993541eafc3e3127622c190c91a7df57a71e781b16937f0a487c3495f553fc0dd004caca8065d2a45f389fcb84cf7e6be57dd13a2a3f888ca8347a5424789d47239bd19619ab324e0d7c01b042a851d0bea93774f22bdda39a7adc50a8791e37442201b834ef81b82a55f88a2a9f73f695a6882d213a8ef2e37d604dfab87f1a2df2c5bbef34f8cceb3e80e9442ac9c84823e64fc1df1b62be7ba1010760471b4ac1d5b8818b8429fd2946e9ea2664d0789d4362d24be089def26ce0914e43a523023f84033d1685fa2546c0f8e184bc0007e0276bb1acccee01f18bbd7c9f251489badc9afa727edc342582de2f8d3997241f22401865dc2d640c421795a20ece2dfee8b007b8ebde7a07857d5051d98d6b1f9819be34a8b31bb8d2010b63a0be668fee07fa8302ef764794672c883b8d209489a51dcaaa338dcd3336ce0cdd7e6b9f8e3e2cde324139568264aac6064dd2ea831643106b2d2345a4b5ca74fe880cbc5502b0cac04a6df925f2ca04a0c1aed1132132af8f471fc996ad1a74e9df850557574177987f79e9d89c7fde3bee8af83d6d1ab10ffdddc1a1bfb8dd8c02bf5070e88cf2df79c0556e3c3426887bfcfeaa07e8e790493b1f2c724d110821b017916543f298a492c02c3cdb14189946df8b964ba4e47e95f09148e3434621d6d73d9f63010f23b8a24ab852ff0dd6fbaaa9c34db68943d0a483a2d63009713902abd1441c996ca868bcf382383e6b547f942e63f432779f2a5d1bb0bed1fbba38f28a0769e983fc575823dac9a75c6dad834beaee4df01dcd44ebabdac679fe745412431fa0fb897859a68183c345023e212719a55d1cd18c6b39efe2bb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
