<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fd37110cfc9dfc2fc3b9ca97b75a30901a592362715a436891dcaddb3be9a26df5bdd7091268d07fc9b3171c6371928e89f0650ae00992f42ffab93ccc95177f6d468d560f0491958661dc7577f4debc0db052a2df41dcb6f7bbcaf562490e9d57d25301f2dce6d12ecdb7d840959531b528cfdb4db2be80075591abfdf0ba4dd9cc317a6d5064d1c14457a15d217b96b66f2e900dee22fb7483d7515008d6ce7cc77f9b784899b8a2219071c2ec811007d6a7eca8b4c37aa8de492f37a5864b3c2c72176d421bf5f8378bbe9a4baf9e3a85a5e8d0b38e0527fda0588237cecbab7a42b37e77ee428c7f626ec94bec3c7c5eb98ab1d3bec2f29ad0cc4bb701339ab815899b423f5901f1a9dd807c7190711d5db3fcba96e96a044a849355315490a477dc459096b96520bfa4e09de37cb6ca75a8bf0cbc8f249a896a419eb2c64c8b478b71a4a277cb511c3d50030dfa9dc568d5ed314ef93648cb353ec0d2762c49bcf0a6fdf60323d2aed816000eed348d9f7ff2d8ff9fc13eb65b59029dbaa5033e11a5040a08ceec4af55f31487b57af448a820e87a66929848727dd15a222ef4ed760890037a17ecb03c3ba588e1d3d6f7237974f13aded1d2ea7eef011512e17df905461194afde67efbae7dab1d1ac311a8ec3a6a9fd17696a5f5451b23448ca63edcb879c06fa044ad5b89e9931e3f5a484cf0197b0480911b8b25c8f7a9a9ce5fdf72ee8e26122992c3f2f08f79a0ada7dffda2c7a0ea576236fd54da6e5c4dcd1d0df403bb272b0f8f48fd6cf68854b059d48c0e4cf5dd4873f21433d05fdb6ff52613ddbde16963fafcecdf5d8e6488d5d42111f4616f108bc6187852fee4afa38d55bab92eef35d51db26a976474620226f5da1843d764a3241813752460f5b3c482239f7cc9ecd4cc872ba54e44116235d32a7aca97efe4fd87a6e768bdb4b59b798a8def48fa73d1796484fcdf1a75302a01f5fc968ff6162755722ff82f3b0a8c46933bf3af624254340b910697999d1c7f070ff4206b121f26125d99ab8aec216a2253955ad290476842acfd0c38c2eb0812bc6d87d8e6bf0420810af312f52a6a18b01d4ec96446077fefb73e075e5c7178dab42f93b13416e309d38c6340548daa2e1f2559e7cef10d5818fad481ef117100e223ab237551b9837c9ffac3026cbbaee8f97afe9c3ce8c34a4134548d77f49109a4fcf5a84a7969f0cfa08fb98c929c6dcb1d9d1b1047886228bb8147db3a8121172460548f3d48f6b59b580a9c37de7b9bed1a34c51eee2350dbd8c0711979c25f55277c61239a0cba309fc21eaa05c624389a331c361dd82e0aac9d90da03259aca7743841716ceac7f416f0d99bea367efd661c0edee770a3c1c8f832cb451e0071c130d14292aacdc822b0ce02db25820c489c913f6050d34264968fec4b3309305c0f919be03e1d6f5f222207060475dcd0332a06ebf60c62299dc32b022da8421f94c5ae98a6e3a9b088fe4f16843e16a4b498fd5563e68fab93e4badf2fcdd191a3db42b8c5c9a9ba9c05abe9bb5e66158e189e0db43546a1fce0685e4be6eee0dad549ba285ca23bc9ff570943a1f1c339c30fb4359a5af56a7f40e3feb5896a550a5d4daffb71dcc80c14934aedc792dee05c64cf8f3c3c11912962ba251fa5694870783fb994346c270162a128807ec0c39929ede759ce5bd1a95995775ac87be70151fa3072cfcb0ebaa091614b244aad8d88cbc777ca2b492de3e2d453ef6b18527b190c61500e78f6fbb8b30b54e783ea3b8296bdcc62f1ff08216d35f4724e8125ea190a53b13df0924ae2ebb1cb16e7d720951b76ae67426ee1054caf57111674681d267d43c57249ea3a0e6fc5c3c18531863cd87df78a68cfe829fc35a2e433c1e2b22c403f0369a55c3d7ce90cd4ada6f39195b6befb77e928e13ed975f746c4d59e314b91604e8d1a3d01cab31d33dee16c04dfb3cf0fb3ec0bfe95296c884986a65a84911e48bb854a0377316a2b5f7b860fbdb112c69399332b42cf826c619473f3a96656d1f317f48b6883c2f100a7667f6b8d11abcd952ed1f53690a00ed85b051888168d0649bea7fe25576a9f98d24f4f209e3e5cb189d3c65b23eac387d6444fb6139877a98fe551b404b9f3ff528fcf88b479c6384b21fb2838f8986370bb498d70f561545a473d156b3a674fa93ac964c6c20cdf3e0e60dcd9bcd16497b8d7f9a6a0119dec85f6ea7c5243c2dec184dbd0c087d7d8d496aa2d90261c21febe418272cef0b43cf2f61a30fdd90863745b7dd7b941651210c03c9ae0ec717a69ca6e58b8b7a0e23a43f8c23773eb854fe80fd2854800052a32964c7bf65862beffbee42c18186635c29633fa8e3414a0bfbbd8831c616eab2fdbc5e2f9d24f30245cdeee175f2df875621cbf783958f22aba775f2d2bd396082af421bbfc1bdd7d93e68bd15410bda956d2312db4b16ca26b1bbf6592975780af0c4b85567de1fb09e12e987bf5dfacb30946f2c9ba0c439ca2bf29ff860d2eaec81a5187a14254ec00018244dcbb2fd331e7e6590b4113a3f28e913cb066e32d71653c5c7219dce23f3bb1709114bd94adebd724a257fd02f6a53ca94a3b02c6e4dad86d67e058ffac01945f8b088c3719d84957ffb31e7b8e82b2d31bcb4f7074697adb87d63eb3792870b4961c0c6c97dd317fc8939198222535026efb95abaf098b1936642e1734fbe9cac91b5aa2d6592abadf8a738c80e1669406528e5d2c15203bca559f7a21734b240adfa200c6b596f440ef90d93fe1abb05cfbeb9d6eafd598beda5bc65c0d120af8aaebca4eb9436bbe2f40f2e6446feada4d70b86977f075dce84b39f6468b67bf34e1292f5399178d219732794460319e2f0476420898168b9dbde33bbf75c1fb6d26b3909adde0878b1af9cf5dd348ca924767fd170d5664029ac418f85edbceb7b31d0389ab736955c579e547aeeeaa54e038a3298be3831aa547b2647b8f0b71c2c4ba89d087ad5456d5070afd61724f67d59e62a7897e81f68e710136d48190de5639bc12d1dceaddb65bd7dc1046249eb7c55183af26c636fdff89e4e73b320613252db4908e651a695003de2a9138c398427406b9de0728e1e845a29eb7bd4cb08481c0ccff320ed0c1fc7c449ed37de2de40e2e7e521bee04f959baee50d777bb4b11704140657b406e2e16d5478dc97a566d22e871a2ad84b2766d63ac90ae75d6c9194c5fd11fecd65044b66d9e517e2b4469ccadb7db17afac37a2659b9832619eef1838f214a27482578a034e94ede3503ca9690138077f2b408489819b90ab8e6e2888b8a0341edc6b77cd68f12eb57b9ba11617973b55dd5e6731868712597a6575cb813cce860cb8f1f52966d0aaa619b7b6b8df0b1a6a7ae499a1b71a15a68471cf9ba9603d0a62de61cf6277a858fcd566f3c0d2c30ec96d2735a2cc8922e7e08d9aa3c36afe9fff6db243bd3f16e6aa0fdce336a95ff7c0efb2b822d346c5fc5228796d233470a62a3bd6878274ea03e02d2ece5827694e975edc0295dcd22364a4f1eb35b4728bce5e8f106d431143af5b4238eef6a0722483ed9632d91351566a70f24bab4606bcbbff20e1d3942c24289288f02f92bc0a15a5d32a86048d6111909ae25c7c7d6cbe84550fbce6be8b9f38f8f54149e176ad39f59c3411af207366c073a88ee1ff3e25604159ef3179e24e32e5fe0bdacc6495c4f7e494f16d52b2ffd66eda7e19104227cc22c129570da2c4dccfe1575aae4630e529c98cfd5e03ce351dc7f5047c829ebbf777427d9951efb59412c83e1d4cc5fc1318d1043a7e7d2c0b2198dafdbd93d549f1dd574eb3cf9e9a0800f39734201292d96551e3b518e2d75e7f475021643354bc0d13a9b086a64c9b90829c1b3e41127937452c4005b4b7f3b32f1fbf1764010e8f6aa6d0a935ded3121a9b50ae6f0ca669e32c23885f4472bfcebe2c0a8fb40dfff625b078f763cb33d8a734eecf9612752bb86743dc21c83f1bb77e5a7d3cc20258fc9943b8483a815c003228172f0b29adda990747dd12620d84a94aec281c5c4e50286c0232388e44fa0188709691c8ae587dcae5a94da72afb5419d3b9ca047744fddfcfcb3c57858f8b0002766dbb3533a66b913fb74886596994f714c1099c209e358b33ede4d006f2f938e1eb8838253adceabb7f96a9bc5e63cb8d7559a78db64c6ceb4bd1fe175b8be8cd643289cff050a24985654c2b4738462e7ad95d554bf070b52ffb322c6bca7138b3c524f05176269c2d6afd1d483c0f68b68d5b26c9ea8841e9bca5df4f94d8a196699c6e976cfb806a1fbcfe25bbafb21c5eef2dc22835d2ca78e13d9163aa168447230e87e2fae51e37c300ada72b0fdd1686fd0f89a1de2a72ddb5c1b91bce0f7ed08b10f96585b2ac6c8963acd0dcf3871ca77e320ca100109b6831b05231bebb39de063dc565cfbae00ce594bac135b100d5a83f456918cb157f4f1803da35c143de5e1af1998dca5288974fe394fa402752180b7422566c188ca82c81921a01952038a2b7ad821381e01b89bddd2f0215fada9205c93fd9d25762fe7dbab5aa08cd7b75c8853b1c81011707a7f5af5226181e7804adeb55bbbadcb0d2b11891207ffbda127415b313f0bbfb0145934dc33534818e63bd36ff8d1d1c1fcd400992952264c2ad66133b3f01beae702bbca13e88d450b0d16594d075b56d0dcd01132a9553bd30d79ac1216b828b278923771e3c5009313019353894f93827aa2e40c8afb5ff8042264072dd1708a78617d2c165a66bec185994cc7fd99fdfac6bcd7880c0f26937d0547f53b715405d2a1c835130b4c563b1b7a582d26fe604ca3b810b8496dd64deb143ebf3a957154e02698bc27e200109c15026887d667b97f49ee105e450c1600bd019e1fd57a82830c4f10a41f413b7baec89c3080f66abc72e1bd4189da4815df8a5dbe5adb70ff26979b4c78a432f856b3ba2ab63457d790ea47392538c0093d2f8eb254b1a66ac9eaf813749cf4598bf461cec4febe031a4b12b1e796c9c4d48a91a871a5c254be0fd99839e89cf1fd892b373e7c0084d33151aaa5fe4226d8beb48448aa36ea8a5fb7e1d566c0ffa6b5d13c2c2de09e83bade58bc61bab57abf3c75496fd9217fa4e2931aaeb6a0084365b2af8fec9a819c6bff24fc476166e6c7bcb004b2cb8b28bbab31048d3f04e96acf656b3c4ff67d990c59b3016d36dcc098564559b3e7f720243762326da0ee8207d4f03e7449c5cbbb49fb44d83ccf9316849c88a021c2189bda731d002d7069e567a0bc1387deaaf0eb6c2d518ac72531b7fae6d7be5be332620899671f42b02369d6856fe1ba78f24fd13aac9c96aa436060a11df3414628312358a108cc558f4edc737ea508ffe9c2f4b592a4772ee72d8eba2e142249f1915c81f0259269b3e38f3e2e8382960b753202e0b16260f604b130c9b4f5fdea6301b064e69333c42e5bc3e2f5e3c788a0eda12c37b3f38c21993b1920b71b32c29c4ce9017f3b4123e9fb872d7679a4ebae8ef0210e6b4f11e2d7eaa1f1ea8e34f49fac3315f923ef53331d88213ca5e5a6957596692321a1b251bd5cf2a3d8d105667ad64938155b862329b031dbf4d89a79106e67fb79fbf2f7c5bc1d8b5a4010714b9435cd32cef98311b86e7089a630c6ec0805593925020b567a47ef178ee8f9e53db2d46895f21b5a90ac365bb6199c65f4f08fae4a60dd5a2b82989762b034382f63cfa05466411eb42939e2d5aa255fa0450d4f34c55f56c1a699312187c9c87dc7fcfc4b0e2485e664a6bf58e718994ec4a4374019b12cc2ac096aa2ff9d8366e2d585d1e6c9f4da1b1ea27a166422bca24cd39a3c787d08dae87a8c41350ada8b5756583067f9be5c754723d05bf1ebfc500e5b7b7272c7529ea3297624e70621f9cc7f7c07e5fab8a65d58025a0b39d19e2340ae0e636ee00183312ce07b6a43fd15e3e033f8a77e561d52f154ce27d0caca29a844f9749ca49f9f666c363d5477a99a3f5328a721b6306d6bb2ac513fd1ce361c852c340710adf33b3a8f42b52228b01f7fd9252c72557c902aab5eb501333b164edb24e319f964ad7c123515e453795743f1865edbd058c62f55a5acb5a9513b19fbc83a933321155cfc096a6729e369b25b33a4747ea50f6f18939e61677a898f770952e25e9a7cfafd44c6e92169fab1e37d4124a6c49681747ab1484f7580c85a7e20a870c675b2623d303c46d7d2bba54286d4903940108349c33061a324faf80dc942902c6077a014b72e402220494fbf9cd0c93b9b308af3ce6a9e043c7776e119bbab5b60d6cc2a4f9573bc41ca31f0c9399797db9ee542032e73a407b7b6393800e16fc3fdf497a6ab1818a1065852f2ebf4bd83c21e4eb40d8e844c91812b84d3476aa24a116045ed651e3d09c85e3bb361d384f086297d22aeee83e2cecbd720a78dd2e02978e79e83eadfe978f1c7e255585638605b057a9df0e33df90690b108c2bc67315c8226d64cc10928b1dbedd410fea5627b2822ef98466c218609f6329a8a87d9f362e86a074f5f761100ccab1f876d9957d9b28b691fd63f7d07c8a492bbe6aea7c9119609cdd195997f6946cf044866b038e4702058323025d7e4eb32e4e65d58b13cab84a69fa35ad555ccf311944c241b942dfb8a2974ac702520794d023fbf50b0b77965254febba40c8a929e92a16bba99262e904fd007ba4e70f5d483ab47bf6ed9ca438c890a52655ee14b5e6e4069ca1daa8eb3c95b054f19a18fd5fa17e887f39255470ea7aacc6575bd7a64234795596f6e130f4190f8b868ec4d674357e99faa487379ab6bd88ba6149efaab056a9364405010d9b2a81613bc4844cc338fc47fdb1c533f9898c52a2181a2ce1e6e4137a8d0b45185b0c5adf836e2bb24bff49b3f13fe1a0e03b693fa8bfee58c49f34b05460e3868e39d8f732cdea9c8106c9ebc6df7010a04e223743c3f1dd59b82a422cb9b22b8278e22403456bcacf6b80a582dc92ff7349eab5ce60018b875666601c117250afff9c53a4f293a215e9a2a1e320758ff143dae95522733ff741cd20eea6de95e220e0f1b2be89d8d29b6d2bd144e863d6cd7ffd5b55456b5067f52b3b0c78a53923fbde1f571faf69a9a8d60f9d02df2cd559ff18a5415cbd11e53304b1bfa1d4fc60695667f2857a1b3ef8156a50d1c867a3f10daa524e16be530206982b2ea4f4fce2a748ff8c3c0f1b1a75fc6aee81973269a1f01616c57ef2607a6203f8406493c72e848ee3edece40f314936e776c8da78b9109edf73c6a7b5cad82cd527e26edc66ea7e42cbb89be9e7d3bad784a8fb6980abac7ed43d9ed9c991ff69c7a115dad575f350f0ccea5267ab9bfce65253d30d11feb168d99a9a7fd727e8a55b4d18f41a3740fbf8cfbc1b19f4464fa2bec4d528926fb1ee862a05d17c7f70b9bad24d07853638ac27e3328ab1e2be7236d543a5b5b0cf4b465dd8ca2847fc035aa204bb7e1c2bc8b0f7f92ae6c4af0e88bef5b0b756fe1f9924e8a3e4577bce02c9c18eb9e77495222bfabb6e26e8b546b7a0b4d80566e7f514b4dff06d5a35ed701ec88348c53796e66844b65efe91ce469e39180866d446def91946780208ad29f0b936cff87c8c736447eff78fc05a0a09258a55575e753ccb662466ff43128bd8b16003e29effba804d23ac53c5cfa3259b61cee980a5dc4aebf725ec2386bccf306a3997efff53a027fe86f52afce81a3b616ae5c40f71413dfd77c3035070473dd8cbaa0f9bad5684cf40e1f4f009ddda9dec5699e83a6118caf71e160bff138ce536d7e2e01f853c31b109602bafd19fe8e462c9310e20491a676a917315594ed065a6c4ae7f3bd8b06da4022de8f41a90487baea7fae907c4655e5a547d003a19b1bfcdbb0e3967a3cb3ed06b8477d3d3aed92375db54f958f4a8bc54d42318ca8154ffb01fe684ef1bea58e84a5754bf58ddb07fdf7128848a00ae6b62cfeb39d31787d9d5210f223426ad2a8e9beae9c543f7b5a6b1d6f3097a564a9beb6622b934d330830a71117ba7ea5fefdf059eb087f170812431abfebd863068baa1935ca97d203fdc8578ff05bd1b5ee318304f127f1bb2edadcecec36b9dd8a26ff7e8b0a1efd3f94b1421279054ec975afdb96a4c518af6029346d76e840aaaeb923863ed81ac63205be8642c93c1260de78bd1a23710ac3b734fb4dcec27cb98b92ebb21c0a52f7d20839c395649b03c29452727b142b163430500d570f9179a059dca62117cec97a7155dd1ffaa7b602bcc0e8c6b333c1f564625ed409af9cef84dd5ae610a4214d7590d184d1b46cfa101c18e9d6f4bee9b9715dc54e3cc1f912e832d06bed0831aba55cfdd5a83eba07888de4f1c7fc3cfcb9bf8e8d470a5f756d67aab67b2a6c7a957a08b4c806ed1f6eca4e73f7d58737eab1c4f6f3563928289438f59d59d6e49dadf8834c0065e6186fd8c07a01acfa184819142d3b8c548c9f63cc1d3c7f6dcb44a409a6d5ca7b1d8d12445eb249e14b0adccf70e4ba5cdb12fc2ff0353726d2c0fc35549d6a148e394972f3687d8fc956f314e940c40812e84604263f44e08b86054a95bcdc731fa28e9676aaa5365f22b863b20e37e928be09eb11ca68012d562761a7f0fbc4397fefe763a30c2608e4cca981b42350b08d25fc473201d4e1dbbb8bada7ff9af2e5698d4d402ce6ade72c76a6bf4334a4c3eb3cd6c75df070c40764c039298cb49d790e3d0e4a97baf3f45070a696785efb073e8f198909f9e960a8b3957fd8c27a60ddc33e591bfc184b82acf980105e30c1b0180baf4b31aa5de652595c4a79a74cc668cf954fcf38fa3e6653ce2062f46f75c77d64138120a9d26c1a8ecdd5a1d51ab918d6ebd438436df3348c0d02c370ef0fc35606e9e639a7c5a5e32d7e54a540c1403edc80d121092f7c10f6a110b4e76bf6d2f759894320298974ef1b2e01cc1db0da49465d48718f7ceffaeaff2f699269881ae328742c867aee28b8805ff8a29cb26b05e662983264e8ad83772d255a657d8dda1c473ee8bdde2ab2ca30ebbae4629d3c926af516e4ff7a799dcb15394760688aa43f4dd9959e6af76027da181949c980852678584ebf281c38a1d738443e71f0952284e8c47b653a68da08ede5e26bed927cdf479730eabf9ca53c595092ae2d48d120385e331c9a44d48fce552d869fdaf424cab1fe1f3fd0ca5d1aec1ea68bffa6b07c9f9f5ca738c1202a62774af0dd5bd44aafe9c998919eaf4048918b49d4d91836eed1c91f0f2dde37e4da5b7e8dc6badd75550c5312350fd2574f62698f222dd1301af9ef7c2fc6da4c6427fa798c171d245c6e5daaf99257cc8d273f8afa9ab2abb951260be2c3f4e8b5417b45c5135366277dee0f7b0dd0d849a73fad181f7ba8b797ee4048554a117154d9cca4e26899636d9ea5efa43d99c5fffd679fa2b8aa082c0de6a23d818c42ddba48cc29f016bcbfc0b6e30eca608c6cca7c39bbd3731e401d89adf8e60e7df673a6733e843f77d46135f8d4449cc6fac3a33d9cec6fa728ca2034a3e3865e01b3ed78c4f91b4807eeaea6279a37332d4ddd37346b65a41e0c03f6056a2659b4ff2390705d500a15f2e1f28c285062a0b069272734c3a9566be734907efba12c84076aa17a8dbba6885b6ab88dafd1d374ef5e2d57d3b0e493b438b07c565db04778ab5b1ddbd1b302573444be5044a6a9d6f7d933c586dda0a6a29ce7d32681de397e5083035740e709370420011777366f791b149e9139e38f29aabd8a0afec588eb72d9c126dde9a98e81e49c2507b2548f1aad6ccc2726436878232263e142b62a209eaa185185be4932778b84c23c683d12f38727bdf756e270608ae3e0d60a76879a9aaeda609d9019ad91cb19e8d2246574d06487e9a3e0890af2e8d8f74d699a3e42686bf9c31ce51cbc244b459895575f960126570bd875e558f48c7e47385776b13e7b0ebc2d21a21696d577f2947ea48add1f9d1e626c1a6de01b4afa55bf9e8bb62f69833c19b0173c36a5271f8a591c95ff8e13841958028cb6100e6152f94807a8e826e009f4990678beddecf8c5f5eb612b5bfed6975544abf0fd350e81545abd1bcd41976b88545fcd0014a40832d897077a3fb7612c9f5e8d38c943071b80ca1f61452b3b22c13f4c98d8963952684fbb5f10761a9c19cacde7eeb918443b9611ff1a9b930e5f08f422c86d92141123fa665522fa0a2f4873f451acc27c497456ad2b2ecf7e2ae8f095d9dcdf97e6db536980b563e2a31078362a6c075c688223ec879da4b1bc75d95344264b2d1f97b95c8c732a37f89c7f629ad88a830ff07a2ee5f0d4e48a6106a54f55e8e61d9cea3b339d328e92cb245f2039e8461ea958aed008d1807e07ee85ee4acff626c7cfabc393f3576ae54a6fae7558cf12f84b6144f4a02c586185ccbcc5b75fa5329d0d163f3b8db486774f2b6fdbfab317801b57462e4377dbef9284524f3c218799240301424b6b09cbe0c24d9188f85e3102861f371ad1f92f1e25a08e767428ae3c5507a12c5ce4d9eab50a001973db5467097fa2671dc3975b742832cf5676b9e71731f9a0b908445b55e2db74e73c46b32dcce27c1479450144554f76d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
