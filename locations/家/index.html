<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b80ce5bc9c7c61455efb4c8700e4170aad1231a90d9cf730cc66b075fd6275359c41b1017fb96d7907e1e7d7dfecca250f19201093b759450f53ce140bba4af5f6902dfef80b49ab7ed0f55ef1623d2b985f019a2d0c476c7954573134d9783e5aa4c56e899e8831a7af042ff034b7eeba276dc54c5fd87f54d4462621e2b4a1cfd95266bbcb2e505c1ae9ae18134eed7d1d6c2bb08089db88117e800d96c834c87729d296b8ab411e44b95ea227769b1ec3ca1fee7b447faac48e0fc99953ba94565b2b3556c7cdad98933f2d3ae51571797e9b9235d36bcaec86320ae36981852075dfb672fa8b00599f390cbb47ef0ab6e7d82bf97f11df6cc0d95d327f3e28b50dbaca873479309ce3b7ce276d709ec202dcd30a0691646c302d07278005317c3052a406e9f59c08f248daef05a2ae1eea346c0856464e1faece7a5f202b329232f42f7a4bcb3618cc6545187b0eb5088eee54d5f5100c950e758ae52a7b66488af153610ac0888d463ba04cba9c2147d3b9fa6367f67764b0b71d4f0af30ab4b5a9005e2b76d7052f4b4e25e2d8ad50472648abf5eb2acda733ba266962deae588730920e151b5f102ac9bc43316472f0fb939de305f01466c1d3427eca13b1644f2e159f6c9fefc1e57d83bdf3af3017e4205d09b34c16223796b2d5a511fdb442cec65efb0e5becb33c6994afdfec8a3d1d8ee12c4f8a2d42fc1e166425359588ea5c35e4f5c65810768f74e8a150a5c6b9e031d2a9870f42574762d738e3e188bcc3977218fbf3c1278b42ae3c2d2dabead62d458385708162969a32344fe56f7da2260304b8f22b715b1382d08f70f32d28ff6202a7f0d9ed7d5893c89bd12f990d5d927b795a5247eae2180aec5b79a4d218f376e881bcb37ec2dd9320dd7d78d3256e5bddb8bca052d36c6f53d95473e4d4155944fefc2efeb405d2d56f1f54c19d66f0d704a44e77046a6f5def3754c1c07a01fc258b97e8f032bb64d5c8612b3ef28bb37da902904245af1e4b48a92b99f69e734e790d94daa3dae4478ab7e35f049a8c6e5354fcce5a970eeeb726810788e14d06ede808a0d7f21bedb714fd50506e8b8a3d61508f8618011d0c0650b8a2dc967b775fa0a189d9887fac7edb4706ed5e74eda873b2974caaf0a797d8b966e68da89565964543601ded5bccc51ba2d2260f08dd72dad977da799ace26d3fcd19e2767db56e06fe3f8accfba8e1bd5286e05d30a7b42f1dea2bea851dccabe65fde29336c7ce3828b16df54870e7b3dc9866742fc38639bb20c80cb41a69b105eef3d11b3a017b9713354f37c658fe09e96bd3ee37f97f0f651d8b7d7038b8056208000a41989141e9fcd60c180fff5dd8847a2d7c35a09a5844ad836e20a70d153063e1afa21d6b82de37b206c4752f214d4e5044c5d57b26b358706866d11b763e2cccf1c2bc3f702f3ca2a4bde882fab7ad15b5a42cd69b54c63ff1974ee62323399334d18ddb6d9fbfcd13bf81932cd9346b400bc4de12af55a71b5afdf3bd07da1b9a3876d7a30c52ea001f9d16f475909c78ea013d5f360806804cd8d20231cfb49574ee5084dd72cc3bed68e35dfcab2e5eee2bc0a7dff2ec4b509d7b2527114be2daf7d24fde0ca73d6e5a6ce4ed56ce29092e68cbe4ba6d91be4da842c450fd78cb2565a897fe6427635b8507117ee2ac559340bb66681a625454d910766de271a5f538c0c0c49cf19159bb7a853d17aa526ecea9e4423e7296f450b93116220356823b8f98751e619b7bd970276a511282e01ad29a625d32ab23f92ea8371af1d9f6831880d8246d10d54940d21ef4a05affe869cb2df876a828b8bb9769f580e108da3adb43fde1234297aa99360d5acc05af8a3504e2d03744dcab1d7c1c8904ee0b6a6ce97eb63d1071e45f311e6403c876017a61ded5fccfe1f38c99a2b805252f1cf086bd347a0d81d0fbafdf8072e1ed7ef07d90e456c163df38e2ab9e689ff1bd78baee3b65b8fb3b3cdb4f1ac84a31a764dae1b93d9617d24199055aeb6622ff42336381d0f2f402f0103075d89004a569eb89e9fa974058e5ad2b42f96433a85f91f636dab20fadba91f57a639dd145975d04c626ecc3664e0218d0f7923b03a85ab9af2c181b03bbf3f078e7add54f7e9ac785d8362883f83e5ea5f475d43ca20f55d2fff1f4b7c16fb8b3996ea2dfcd8db55fa6dd9e0559b6d052d14bcbe2051923ad734b121fbd46a15b39749371e0028b9c06f321c1ec0880a981b8fdc5bd25c49873131b6efd24b575a80159a2857d100de6c5eee175e5268edada33fa0056f12a6713505417e1bbc5b0801bcc02e6047e31059ed6ea71562b5b9b2db303d171f385953da371e1c5647d78f8f1ec6422606ad6e8e35805595b8ecb57fa7364bc66c491e8f955315e6a566d514bbfa24b810d5c91e816c7b47652468624fb2b9848f63d574c4a63742da887f5aa17b497214680467e0a1e152b68a0a9c895426bd132e346252bf673aeca57c04e016a780e728df03f7f3b53ce558bd5373f4b399426dabee4c293ecff22b90d5d2d9870e2cda4a9095ff7b8163ebad78a4c72e7b540a068c736b728920d771d5b05b2ad6b01631b7588fa55103f4d06b7af9264000c92898ccf3e027770c6ac02199a8380a19964a6fbc6ed5a94ad1963848788928bc191201779a7df77bf3078e2a19ebac2d821e74d02fc5781ccfe3caa79f7e7c8ca0a7c3d8dc1e2c4ff2c215c1abd1469f6975f8d6b6309b57af606f400c507f6acd0c4cfb6a54941d049db7b3266ac2d11b1325e3f6792dc2d30bd82f72df573c8a8b8a974a09e6ca59620caf1f79c4571860efb37927cc29fcac115e3614cc2e375cc70880f84cc5ebd1255a356d30e40427d738da937a1532fcdfdc26a11d6a3f4490935bcbf1435e6f5d03799e6bfcacef35b9a3476c3623c75075f7fa9d2e05510425291e6822a7878311a13789459a17d1e5a9ff6fa04fcbdd9cf1cd884e1ff23266964db593b0d5b15d5c798bb0b80e9ab16bba049bf6b0e0b5a277f1ca37ee44d3db00519d67682a321637b33853ca56aebdf11616ba8a82877e32b14893680422bbb8dc6048c5f6dab03afc043e332f7f3d548b314fe660f52cf903fa37f4b2d8e0d6ec373bdaf43dab3a17c5a21bee131af2f166dbce33f7889a6e0fa5ad7b15fa8206dd88a70162abbe0bc712a880b9ab0db4a9ef55bca24a0eb548495adfc6caf76abbd136ef9f9e93a4b3982629e3bbe4ba31ae0d0dc158d7188bee1095caec4abd4d80f96ee3deca664e6e91c052758d1ccfbcdc7147f4ad5727b97521ee0714b6c5c0516078b4343329e6a8269fb794394db801a33c9cfad7d4208e2974a4a7796cad5938cc2ede36c0e1ec15077a7487fa3ceb5663bca0c116d141e1b4c5f35e67fe7a8f6a7bba080006ddc8e4cc63cda8088b06793178311629e83d77b1b22706348367c570062a979517f5bcdc752ce5707abbcf7129c288b4ebf03d0f5d73ba6aa6d69b8582f1cdfd2a51b7b110d0dc4c9a6da8149d332def69959d1de9e16000eb2e4cac251daa38079d9fe9cbb180c7d84257858313933d29ce385eb9af662fd044ec3ba8c5f4816b87007b0f30f1d68d72886fde5323fc4f8b646fbf1e13acb98a07884212930ae9dd5bea1b798f7d88930cd8bae5c08f60db23c04057f6faa65fc4556742511113061ac70f4de62f595e523168a79b563a0643c94dc1e079d496dd09963e1c51aba2179c76f6c13096580089bf52a47450de48b7c6ab10ff09283257b1b063841311f0aa294800edc21bcb6e9ea136fdd556e740018cffcdf6a9ad542d1bbd987857cbcb386d3b49d87d2a0dd25432f9a8b6dcce251279e23f2999d7b912b8c06399e743eb7961ab3c69395da2431faa6ae93a343b023d5d39c024c5a976d687997b77f42bdb1a012f4f8df8fc5269945ff0e31cd0b8a69a7992eeefe5a70a0bb037b25a503ecf7218de5039fc7cec3733e600fef4650bb70f1d03b6a6536f63ed7f59372b68172b4c3037c8b2284e655f7b81ef07a35961946ec3bf3727fd1576749dbadc538737e2c4232a98103525a63cc20099a397f5ac540a646ed97c5b45d88bf6857622cbbbc7cbfb07736c2daa7c11ec9ee8bad845e5a059b19368900a2474e8cc42999d22cee631f7e15c6b1fc71958ff3cc63c842055861b420685153f77c96b966315cd133d74c02da73cac5d339d36a641fb449e51f905bf5f497b900f2d172e8a811e309eba3d038f625ddb00a1dd5255d10cdd94097ac9f891fe06bc6f57cb021e552b2fa122c8249c127ff02cb23cf0619859391b37281465b95d1d3bdbb005530d18a02836981cc9027b91ead25c963e58a796b0597bf61e83f05d442a28107ac80ec9b9e6824c49275deda6aa8c4b75de8a46c80a8c922effd8a0f621acc0282fa0c0cd436230d4651d42b41cafeaeda2b7c65e2ca2e836d49162b0620feeb9cde9d081c470b8fd9265cd90b49fb9809bca3381dd643f345fe92e85f7102e5814ba1b980e45986288f116108fd9525134dc3b367d70abb8f2d199f38e9c93626eec79e1299b00ad574294f6cb79b0c8a102d870e5972e619b0c3861f3aba5eec448ff292da618d7fcb246060f45efa81c8a4096d73b72616a175fb2c4710231ebd21a91ca9f94557a5ca19d65479eaa6c80f10233994addbda914cad1386739134ed253f723130db66dd37713f985b5a0ccf7ab861f04085671725ae2dcf14cb49cce43eb6b75f3ac90f5a0c1bbd97e7ce80cc1d9123c739f6290ef3765f34604d9d17534682a34c0b6c6462a65638a2bda5a111ed11a3db970992f50be3702f83a911cdc018373d6f7e85c85f49c3c2be963f31c39c56914811ab5a5c84fc40d595c17e81b6eae9f1ccb0eb0e2ed84a109b8c9ff69b9a8b46ed23401ca2e9826d5104bf9e334247a474f63b69d302821aba89efa0d6e363abee63b4054145fb8dc90ea6a0dfd6e7b7f761a3c1a1932912ef88fb3598e073d561f8449fc25c0bdfbe786c2b41ce86b4fba08b0d47bb39bd68ad50d71c8907f779758dcc4ec93669669cc56bddad9bdb0b541773d40ce1484cb6c70ebb77a4aa99e63c41b07e5d0c3ebe55e20c10cb46195160414def9c7c10cc9dde1eb9f285819333426727e9f57c515cefe9851b29796a028f10bc017bce6d51b7f48e2b467e976f58f9a321d448a936314ff9b3f606bf77bcebe6213f3a43f6acc93fee2e41b3e5e17d55eb4bfd8862d0bc5c7ac5dbc89c07eaa109ff0d65766774fbc523a3b1a44c012a22c263b9f5be51e5391069bb73f980204246a945459349286d6f80b91ddb7d131589b4e7172c0d93efb85fadb7d738584b384ed774304dfe1a8c472a6587ede75c32d36086784fb4bc39abd2b78b039bc4c8c51aeacc4d1474fc50334aade06f8a94b02c4a7015bf16467a4d93b4e6cd10558e06524e9edbaf647da8d8552b7363946c33df520239166551dd3d719af5f71c0d5e5c9d4a7eb3ef8c1b9bfbf3e9125daf6f33696d78f47c77a1f0ae826dbedcdacec798adf00aa42ae666ee854420a682fc88204e2d35fa52202185d7c4dd6f77b990678ce10882c3bd66f96d4d8900bf72647b57cbfcfeb38cde44a8009256e8ae65f42382ad06464a38f97094bbbefb821475f9380536cc3e670c2651b49cb93e138156f90a698bf8b8bec9e49b62e7c2fb3264db7703e3f9818e67e2fbb85f4a545a93d2162dbde8ed84729c4b493ad7f1f7313b10ea498f5a735c9522e7677ec98f92b77f9289e436a1c24b68f972bf6940a4ca0933d940201a91b540eedfb8250680fc23178c59bad7abaec0a87976b26221e674f5b00d98a239b9cb261c4fc1c57e88b44e32479146797fb5646eba6c8513cd4853d80307ab164f2d0be820d923200cdc42f652bc53f668b952ae7abe7db9cf7fb0309a5bd55d3b5829c7bf99483d135fffa198bfb7f10f006563c9c8b2f39882a40ccebd2c86a38bb9b64d3fe95f82dcf2c461949960c59973f974726fbd83c207e77deb474ae97f779d81b594eece3b29caa2fc66af66ed81529ea4f8a6f491bc2ddd1314bf460ea620c550f844b52d720c3383abf1e33200b70cc0a13088e76c99858451c8a515c458cb7effd92685c84d8e8f0e0fe013efcddb2fd2892599a25dd3a7945c7c92594b5f94728019744081baeb22fc3948543ce839949e2798a5a184175ac33872d26e52170bbe0603850004489bb669a9adede90f9db27bb280653267b95570b9e334d07d7c1502e284a88e5e7f69b926689e3c87d7d4b3b117aa255cb1c19ca5c60c2c81b41022a2fe43698bba351b61065c4a76260f7e22d896a484d36220a98c2ce79075109235b9fcec3cb179599e4031984dccc7af98fd32b638a44bf5298fd9cfeb7c2a751ad9afaf98b3982aefc0e304274cf75441d3fe3e6aecd5f3d87efc89bd16478472fbc5e0445e9e62263e70bddc11fda0ab68540269e2b96a6c05792b38f6e0b962a9046fce1ca024d4798ab897ffb32b4eec3b63d50c0cab0b1d568e237e57a190bc07a252803e5f71bf050765240d6c8c024ee4e15b4e26c48ebf45a983347b428f743c9a02970591b1c206952c369d60c7c0b748c7138cd4bf16d1a07d106e9d8a5d8102b5df6267d7b572caf67321a254abade7d124775454cd348b7a8f1ff1219ad791a8fcbfe5fe212550d1161b751893e768476b7e4bee9552b3c1e7dd9c9c6a7185c7d623e893399076398e440076e38c782a77ff40d599f78e51283a8591a1c8f25590e63115e4e9c90f87b1409042c11eafbb5d3bf7e005a60416984dff4a99cf80712d51161fd4dc27e5bd9d2f88a92eddc4e36641843b225ebbc7d2c7cdfec2fe5ec00e01d8fb8e7c85dc9be4ca88bd1cc4ccb87e91b3f0fdcb2a9b497677ad7428b48f8e875d4a46cb89623646251083a682348c0c94a1767f2f6bfd975ece4977ad46b06d4ada520134111a01078101537306178af0924c87c6fa8231d9f10de6e319142548cc81d23c209794c52b132ce1782c32017faa040b1a25ad4e2389a8ef457a69a4837d8c090e20502de2c3e82bb03c15886e50f214a143bf8d2a584ce5d3073c6520a86deaa5db80dc8904a1c74b90e1119fe44fe97e41fe92124b6ffe1a9a045d6f12f1a4a870081f342c46ac442543df976a6ec84ae154436a912c4b76eb535b54d96d1f7bf4bbbc240cf65bdbc690b43b609d156ed436bf4ef7ec3711f39aba52c6c523701551341c600c440148f29075675e60d76e3a371859c78181238eb087cd31e24863cd34c3002cf52eb58c5c7b88efb0b5552e0fb721995b4ad96543c96ade4ef3e5cc13ad48d8f6f5e4aca9313d7a30570940ac7cccf2f4d70ea4f2e46adff16f6a3ccb71fc7828440dcd6839cbc7d80cb73eee9ca010a2555c386b1ff07ce5fb8ef305095810667a55f18fbfe31fdc36b8c33dee3d60c3e815ea439d12353f06f668c1559a9eb63f24d071d955df86abe60d8daaf4a78e78d168fa8dfda45a87711ff1c94f536871b681bcaa9fbb7124a654a5c25ebce9b8f32471072924c4be042b6529a9b1fb705e9dc42b78e14a670b4d0b4f317200e6e95eac22552b059b9c2a905eb57ee4ce2f41db9eafd94ac32c4c2acd0bfa87f17c932fa94173bc1c11db3ebee79f2de70aaf0006fb731ff6456fda01e7783cff122f82366df874ef2ea265bfba84f3bc7a1508389adb1e3369173aba4fa9615a7ab8915d666c970321ec541d033abedd40e9deb61cedb25e97a2a44a2c800013acfd9ddad3cc11baf78dd58a01f9c301aaaf7189b336233616988ccdbc6174d8c1df68915e4a32c8498a50c60608773a10939b87b72f51916b7947fc3c8156ab3b922d2a7f86ef5cf099d7762614d5edd41f58d28900441a96342d9adc6ef23be08e2414a70f6a4db82ef6c3b2fbb786811833c6dc0b663744dde3284f652e9de016944a6a1e180c1cfee4dd834e3694d74d8f725902ee44f0424c30755d31d798fd18ed6d8aff0915791a4d519ddccfc95f4901f067c99e462c8fc003959d8c253784dde368c9d4e6610487279e8b206ecb0f2230af2f6df98c8968b4e7f931441ddee86bd430a3f7bb462ac804daef41f7e5824910f2677be97afb93f4e5c087be3dfb4f9883efd254898116968825f3bc40f5fa47a867479312ff95e1fc0f73e52aaab3ab36c44a86d9c9e2635c6a373d6a0555edd803702023bcd71ef00bd541d4349a525cf3f72e72cb5791820c44cf67b152a959601f1951fc5d45d545f001c2fb558a9e41a18a8151aed39125de1a344a3ebd51aa3131cc3bae977b4ae1bbcf1bc1f2641bdfa4b58e1af98bf66b447b48a827237175970929d9fcf0e9d9f298edaf027d75405edf887dbcb7386a7fd1dfdcb413236f7bc21d4239b743815753b92f6214f694b2226023313c304d3801260a12d2d6c7bc4be8bc843116db47d459d4c6650b45b3bfc007125b47e342f0e25e0577b9cd6a2a091b495f69dc4ef0972d62b12324c93be04be14cb476c59d2c6644baae859f598bebe857d090e1a51704764f874cf0e961e6bc6c86efcfaff1106783378920452dc5029a6f76214768758c142df6f0be4a553ff4227f3985e78f9e5ca097493d2daa33daab4202aa406f8f777f7b6a1020e3527e7210cba6e9ba4672e9c0c57a723e01d534a41ae9209687994b013c1c888347c0ad8408cd87781bdeca92018be8f50d334fceca91c42b31a85b1e00f2fbe60b7e98cf39dcd25cc763af3860ddb484457677df0479c1b073dce8886ab2986411b192e20e2c2478e2b5379f369cfe78e558821617f8b82e2b13e5f3090b1c8634fea0beb0562d59454a1dcfbbc9941db62343748e6c95737a7ef9d20ab40f422287b59987dd673c66e579c0a1c42fcb6ef6991d92ac434fbf4b7e49c640d37dcf41f5ba572fc3a137e1df919c2a1d81e77526c5c09f089383524bf2b19cf8205e06ef6b9e6f8bd62947b21b1b181712b6ca04640bc136d2a4652495247ce6779cfd42ebed2d77242e046163f28c4fe82edfaff8e0b2e5fef6ba511d9373375804544b96289f6ccd4633310ca2b970816fbb80fef13f1f238abd6928e9d60f26e7c6cafd5fb00717517a017f21342a2cc36ccc22b26c710e36166efeae853009f62c9f26e0fbf0d1743e1657d9e40aa6dc84e715162a56f67f542e31afcce3f38fe653e8720a005795052531c9034761b91a4f72dd252f89e24ff198267153d853b2d41ce227315938759ccd250e68f0c37944c210178989045d53fac4fc3a8b08051203ff2b2a8943c4737758968f0adaab481c2f1259ebc900ef9339cb407b6b01cec52bb409918a8e4feb3051aeeb7ae648bf0b271dbd7f554d4dbdfe0b40c5d20c06cae538f1c9aeec8eb84e4ba2df0cd16842027d91c836b3103f6aa88745d96dc1aa201376b7c50abb7bd9e93b6a9725c32422b8976fe97951193b161eef7f2bff3234d0c15400734c67a1337d3b626378482c14638635651fdb94db3e1af9dde205f532dd1a787ca662f084e1a8efa70e749a25e5558a76a01bfbdd9d8196bba2dcb44ab1b0b62e2e534bfb79fa79ff160ea11cd0ad5d414e63433023ed17a4cbb4e9ec0679cccd2c9a137d15c640563ea28223dc630163cbac63f0821de52f7b6a7efb2803c994a328903595973edd8cd1fbafe4c42d7d0af8022be5f75fdd01fb719733abd404f66b27e5d1e5f6e832cc2deb6d1445aa3a089f7bd9daa9427d3f415bf0fa5d96676e1d250b395d4b9f1e104fc4433221e6121b2151fe51845c8e72e821426bc5d7733b4dc0c2dde2a75983c075a0da059452ce6d970f4c99616bbd4e78468d2793de94c793e3884818b4140ce1512465fe284288131217051fa064b213048c725e3da018c645486efc45c2bab4cdd6b1cc6358f915519d95b0fc32f518a940c0addd87ea94e3138f69de7c9882dd60780c2a4587a5b85e228cac6e0773dfc15721b7f7f56be2b55c7ffec0c71ce37181d74a37ce6d2d15af5a1ba2ca3d113e7c6af980c8b8e56e7bfe44d942fafe78056e3e6eb3e028610470b479890f023409a39a55223a8ea1a9ceaa3cbc3fc3c42cf9c16997d6350a73f62fc82f086da8d27ed4d6c2a6e5b64185f864915871aefe140eee39f346945b9a7f6a83ed8a376003e120f4f2bf6c510d57e7f308b4556cf5f883f124c291d67a2931d44f8251df2a8880e5a35dcf3fe03964812afdb9d9ec6aff510d0ddb135710ce45838b5b92271c3ee484aed7cf267cf7cf91e955457a23700a55985d99b92576abd160a6d2b84538592f9638b0764ed4ef30be417fdcdd0fdcc03f7ad00a39450ebea98922510c15e8c876ad77e93db0900badac81e76be3f6508d93a6fca9e0cc5a4d87a95e8ad73dbcd67223f9c83b58bb20c8f602af8b0cf3b8b2040e41b1add59dadb593546383726cd999cffe0bf7e2fb169dd7fe50804c1df654f182aa1147988e461f79016bba6537a06202351776d7766d7b1bd750054a998a7d4755b52f22da6200493a289b9730d9c5e616e93205a9c6d6d07bce10880b7d1eebe4ddf1cb915d18bb643ef1b5a1c7776c83881ce8f01edebb2a48cab2463d71cde794595e362ba780fa6c4d6f696a9d54d5a91ea9963407e6a013a255f00d0664ea493d85ccb2b10ee93cbf29fc15ca2f689bb979f8ddfede1b6ab7c8688c9f2baf821854db8564d7789daaf7078b462cb77ebd33c35f4c1bd051c99560f7d5d65dc883763b8d32a08e217106415c8dc8f0f39ed33c52b20f8ebd2d17cb53dff5247acac855e664c373f3a53a79770e33ab1e119fd95ebd0fff1dfa64e8aff266c7426559f6f52587f89d78349f50fe61132367168cdc93fd4ba0cda1ac197f488985c0d3c7223b981e2476f63849b504e8f815599e45a8bd9703581145eb66a033cc5222b7c84e85b138a86840d4c1a054661eb84f36a6dbdc4a63b9a9ff27fa226ab211baed8649388ac4ef107ec8296d08ba6ffb84de26e405c6b49fefef260ef0efc9ad771ecae3c5a89cf752439b67d3afd39386edc2ec6aef93e0d5d0a7143a789f79a9873b7354d15b35dcf479e9dd3637cae0602507318b3ce886f6bfa713f8f7998ac4ad95ffeb0eeef8a57cccd8663e6b7a166140070f972c1375b7cbe04412fb328cc50ffa694a7eb1d8b1876ed70efa78a8e38bfc43308a21ad2db50b459678980109e394c147a068423cf7e469d7e51d917a73f3b9f32e0dd07100872376d668cb32bd0ed8de00cb8eca225b56071fe577ac8d836c31afa68f97045b65811dc0b7c0c70f32fdd57b79046907f960d5168ebd438a6822c78fc4428fe80576e5e6ac91bcc51e33f42c2cb19291272a0daab4b9f918da766de0fe74fdab94551884c3947e983bde3a079153ccbd676168ca515353797eb944825c223da40406dc63c27170a0b095b84baab7578bff1141766fea9b11d8d4d30009eaaa9e81ae740952800c42e780846dbd586d195718f0626ca43e944e061e1ebbf280745246464347f43c72a123c1f6c963140254dcc96701485707a9fafa111c7f0c1a9d728e2364dd866bd4796289dc27b4d0ee88a37b0ac06575237c65af478c94f1524b7cd432e1c5cfe9bfd1fe33947aa65471f60e89ceaef7dbe90257664164f165dde4cdad507a54c436d1a311071bab6a8cb2a25be4d308f3fb704f3506d98d31ea7b7a33e71dccf48b4a4a15493eedec2faaa71c3bb8e5a81b570f3d8189f90209b291fc852fd666b8d5946c3ed05f4d65b5a6521be3df9aa2f3447874d0f9bc6ddb9233305f330e0d512e07c7ec6dbaefeca821bc3be192331d9bbb1a15557a084867babe7d852515d2c33d176081ee2e74f51c294ca85fd103e9f209d4c24f5b9883e6e04970b924ec73f6b041d1c70f9de2b54d1faea4e647b88083af09b7fb35ed08ad57f4cbf96b1deb9bcfd3407b660da58e6b5751f3b6239ce95c184ec4dabb738510524cb5789818598329cc61e333e185cb8977a8a0f310252c5ba2716925aaf011117da5531054220399028390d63c0e868addccd841739dc5d598ce2b1cc7edfe4b2c4b70a7187a95d0aa11226cdfde5b5bf363500da9294f7439a5e4ea05f8a5afd818064d33a69830066ce2af3ba663127acba5e1da461df78d9124d8434e0a5b82f3950f6ee29a16084a1d0c5fc4e3f9515e0f76502dbfe7f6b633a09ad4530d3a7dc91be51ecd3a5df4a956547fd6231319d9d2cdd249c0df754c5d55f53ce8725c7e2c048a14f6bf413b069c137e711e0a78134d6eae792bf63ea1a3c9f09309819770055335c85f3acbc79d2442c0010d20b47ae6cf5b539f62f4fd48c82534a7c5616dd974d42e77055f38d6a087641aed4ad47fb14094846efc712a47114e03cbab6ba6c98a4ab3fc7aa1b0133fbedd1b13ec1d1486d23956ed19b6fb04e8bf496e67dcd2af8a77cb3a6436509dfd50dc6d07d6bd93671b40dc1a74ff3831849bfa5862f4b47ae37998d4bd946913544d1082aa7ef0ae78586c9d8d2e4ee82f085e5f56deddeeaf4bfe2a41dd3e7f59a1e4d01df193c8b2c15d770fcf4e2dfafaba4640000dccbe9593c20d0b865482ffa8bbcdc79a5ebc5fbc18d91dee05986a222a9ffefa7de52004ca28e68e89946dc7b02452d255b3bb40b4849a4d95c5c619ba4bfaa3c17ac580dd0280c07e589207f46c98cc53f6575e9ea42b642ee37b2b0a26db0546db2cbdf4ca3b4f40c09ede52e3db12a66f9d1687ef004ec8d339d904aded32ae5d34bc05b983e7accd31fc408a26dcf912e4df45f2dcb2bfc78526fe8bbf1cb2dc900a6e5e8865aa15bb84181f921e060bf90053f51894f183431b06c211518bcff64a88ed3a58ba5bd9fe46a5f0bd957a60044bd588c8c7c1d78a192811c27ba75ff7ec3b118eb386378ea6e224f1aa8d8670b236f990a3f196cf63335d376891d6cda49cf10f9fb45eada3e28701857075248de11b65e31dff81d10ba5e2615fc2c1198fe922ccc29e78fcaabcc92e03fa6051bf38df7028bd1fdc151f2ad8188e4bbe64a3e3c6368aacc0a8bb15d43a28eca5147505ce29921b31d4a8a5eff6f8c9879b58c83606f8e61eededd733bf41c4a7ddb43db892dc0aa7db3e78c04689e00acd000e50af90d42060fba500f0639110e4ad1938a466e5909b80a0713da294fc429eb73870c985956a59d5f2bb1afde4891b503f468ddab125402a14e118b051715613280200cc843c428cff769fcd1a25afd9d083e3a709e52a366fe1fd51afb320e74bb4c5763b3decefe30255c94585df9435ce231391f1ea19b63ac1220569dd456a4fb0906687d7828b2002ab4427ec8ee1566f2bad3d9b56cd0d20008e8a4df8e957bbef1ac0495a178255d34a81a5a281040842786ef250a6228a6eca8afd6a1b047f0949f531d7816a2ae1dd94ef14737b0e58e310641c4692a65736df41abfb78b51e019452a9d1edaecb5146d13ef320d68ef52ad9bd771aa4ebba314e2b0dd58cd4539bdda654c3b77dffb5854d3cf1d693bdaac7877006627fec5bf12aafbed3ed97c16b8aa5f9162cbbe79174a4b93e0813a91ccf6d20de222d45c0be76f78074c36ffd11a64ff3472527e632abb66bd98b1432aceaeaddaa7d5c0c01f025d303f819c533189f441242d523f9459354007c576f88f58c7bd3d864ddcaa26271f1acd47a9e34f44c7687162d37f41224274f29866e721fe19fdaf0bb3961e5fa6d1cd894e36c79adc535434e06eac7f6fd418541749ba24678ae87e9609d86cc7950cec1db0422fa522a571d2211ee92eddf22dd1259ae3c70cdb2e774ec92aafb5efaf541c4d0dc3de741797a0bb88eb2d07d93113bcb70dad241d3259607a583fc2da88e2e5ae5ba5de27e5ec0e6705e71d42d6dbf6471e1ab8407993ee9373a2b08b85221ca6f720ade21628fb5d122a3a8dbb88246a6230a9379ce1ca4b95644890073da345825c790f641e939bf8fa0d742b3efbc640d7382def482ff92a431aaa953c5386f921f4eb1c141fd76d6bc63c01a228738bd1c31e6a93acf77c332b16b7fdcb088ec2022e680e96c52a09e9201fd2a36f6e342611f75efbb9eae3d62d74113fe24f9f5c7aa61793712055c5e02c1ab86c99729b2d9a35e11bcfeb9abfcbaeabf2d2f743d1efa6097b2100246e3c8f28ade78ae47ba72a5b2702c00384c2ec9180b85df1715ae418de276775ff764e9304c273991cab0f0659b5a9db9d254d76ac0c0680c1e201a50ad663e1731cba9156ce5a828683661f69c6a153a3b55eac99f7eb1a79a67a67290f14924b8e71bfde19d5c852752fb51c83dce32c43550123955ce6d4268f3e4d9a9f5e613067b57d6150c657e78b44a4c9f48b743828da7e6a8e6298f57e2f3486b49094d5fcf2ccf3e722d1fe5fdac8888ecb90e066ede6001cb2db86757002c6dd1f105ee56733421b294efa80f0801dab67df1fef04a2539bb3f4d667230bf7d80ca3e05a49393f9bf18c52753efc1d82b8481bb12a35cb7b9549ec6b701bba4bc4f1ec7371fbbc23b0af8ccea91932db2dc45623cda391765ca1fdfabd15d00f7dfd067c0f2a6740171519388f87711b873812590c666f24650072871089f2bd8a16257501b77468e07bb0a513aa0921dcad944a5be59ec05cf9905fab6c1222f7c902116def18f672b745de2422671e8b1ccd85a9b2abfeba01a4213097d8f4af693865ff11af1833dd17bef6e6fa805a8a9572b75e458f86d6d59390d7a6921f07eaac3328ee1a7f81537856b30928278a66418e798e64d247b61b88bc1424e6678d73f7b43b1f72e2c8e6ef6ce4ffe5470866646447f227d23a87f0b52244e238d422c49fdd9d4e7b2a16fdeefb5333f9f474a3e6b7ee53b914d4fb1058c942b8bbc3bf8b05a4b50915defa1e9221741210874c9449778293311fa2991caaafe652ef9191ec25f3abbec46a95c55f8e9a1ed34aae004d8e75b4de68a6e0087da4111996579da59df506eb5489cb5e08ca0983928f134fd9c63ed41a1f3b0c972cf1e1e0ab1b5dbee4787b17329cbdf26eca84380eb6c06f15594b0f8f2629a744c80843d610fd9f2816cf602e692003abe9ea929b50ab0f9ad1a22877c677d0a33f4a157f2933c5d39b5a462a8627796329681f29ea2088a1487e956d43acbd78256f84de7de53a4e43c7f7012199048ca661872375b509fb3307496445941b2d4fa3083fd7b55ad95f0e1123a1690a79cdac71c546b91454f6627a044aaa79f552eba4c177f60916237611d84bc35a56dc779c0c3390706a3c6e6ad7ad602283a5b74da8f21a4b761a7cd192424f36958093786611cd9d2698c39a7e5ee63a2f65d2715aa49686025e8fc77989411b172d8aedbd4096edd5f438c9f1b40a54b31d3ca6d89aea8a025e83570f377d16fc1949f5c4c23fe480f933332b5620fb6e295c6dd91ba7dcc0273ef3b63e30684869cec903393ae2e952e4631da643e6553eece177c8954a3d334ff6552aca7c4a24dc3c1a64386d5bfea8b3ac6433043ae16258586e8f0e37810540f620a372a46902ca3f95ded4d486cb7b09af6c2f36e83028c2b568856beae645b4e09ddbd8e561207f63444bfad8564b6e4ed400e6c51b7627d05ccab64818f91c0daf8cfc3c943b335e43d72ae4dc9e79826b3ee5b3bf91839cc7519afc7e596158451c8c9016c9fbea6855b147d2d49ea5d999c0defd8b604382f8de12bca3c59f98f719e80c8bcaf37408303d1253c7da3ac5a6c53036528025c41ba55f9c6d8df8fa05e5009e4e8d52471b5119ba1e77100871cf97c7a57c9ef0dbcb061d70e7345ed7342c8d503904d055a4dd09b43f08d947d95db0da541b9c417e57248e72e72e0745d8c6d4a6e2fdf8eca7abd372ecddc75f9f2fb15bbbf7b5c9d32ba09aa15b1c218c74e36b6481cba0c7ee9ecc71c61713bddead4827e5e2620c0a82737865b60fdc45fcedeb243894a2abe1b5999b380cf98ad67b8a19b7eedc93a76e41899959d2474443390fd0b317bcd9a7d9a210ccce0497a6f21097ee90b93dbe4afcac8ba99e830a30d99bb4f8447bd0cbbe5f6df3c3d003f36c13faac0e6dbb7de9e4d4fd46317bf7d938905108da2ecd6b673640916924b5d53cecde6849ec7112b9e4a874ec70968112c270425727d618de956af3b7410da2b290dc4140e933fb8067742e229d043a181016f39e231495610e33175f15a61702251116bdba8151ba40a83d8f6640a7ac58e28bb5f0812fe0a4ef6e8cb48c04b1b7778c0da6ae42df3d5c1c69bdde8c9785f9cda2d258a1c60eaa299d7b046f8bba369566ce8ff95fa35b22a425d2e1625db2eb0154b5c54271c32cd90e059bbcb94df785aea5e26bc278fe7af8a93e884bf33e86e9a07fba9d4cdbb4dc099b8a20733d14a72ac28411b0d1de691119b28c7a1a165da8274a6dae7e9410c5544450bc0022632854a9c0dc17972aea347b76d88ee68c319738ee074d3507640526f64f7f55d2c157ab9959743aa110a0753513e3e4a06f41cb4f5c14183416142428b16a522ba8f995093b3c3f3c4185a5f4180856263b62c189d7a79ebe12e5e32712a14f342d00a6da7e3ac645bf3e5dd215bc196704e68118e78424ecf476e5dd9c39e6e1d715b3fcf466c3b5cfa55770b961e5811049320fd140d70160e455010455ac12c99974481af42c913e9b29fd5859ea6ff4dba424518ce4822f6ac487b246a5b40e322603c87203f892991ac1a7cec4a8659b4b16c79776aaa2ecd5aaddb7fde271feb9aa5e3207d2def972b4845448a00538820d74cddef544ab99cafed4339a41e0931e086f13e57cfcbd3dcf6ce39cbbce687ecb21eb30db05b2cb2d95d4efec0f565eb6ee7c4a0049086f90809c36ab08ae6b10391382bbe12ecd6212a685be15c806229de8474cf3974beb24c64","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
