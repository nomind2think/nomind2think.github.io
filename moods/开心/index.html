<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13fe179dbd7dd94e98f21a67063d9e2992107095c2c13699c54c1072568dcf4b18775701b2dbc958945ab65a68c409785d4bbbcc191c6547101b2a2df35be9247e9d86e63f4995290724662f0416964db113eab9a6e7f66484ae4120c3d5b0200a0f5756cb39c7f2b36eda6a1ee3c3bd5a0c99a3d3ab0888a2c7a09a44efc7d7233b77e085b461f5a343e10911d654b0812307a913b528e286279daa7432cd0700008cff4c637cdc5450580d8e0c49d335250542eed2bdf4dd7cd687e79c7bff7e5329c916fe5b9b71c543d4dbcdd77e5b3b7e371bd8e3b353583f42930b0afcaaf59b49a5b6d1bc4da5943a67b2d645b9e39fead995bc1f3b3cba9ed078250e0568618587ddfc27fe2bc7e1d4b44bd897d1874ad5452d710af6beb549d7ad808051de1625844d2258ab43d7af7ec959e8fbab916de541f449293346e3abba9227943e4e0073ac5b27c791bf60020c42ea9f2691e37af4c4ec1aaf3015d915909ef4b0339b081987eb92996a5932b53d45d394e682b2c4e1c647cb7f2624f223d941d39ff1441a0d0ddb7c8db2d6de9eca74b36f6e41fd065cd16f618c01b8ad44199a5836e822b4794b8c2269fa7fb08047e8f187e07d8d7488caa83c58f2837bb0094d9bbfb1808c83d9e559f3c01d9b212cd630b0d5d9c3472b49e9da93110e786272c991aed0b9fbdc59a58e6ac34d57de77a0cb1b0ac9d0a1bdbf4ba7e123181ba9c33ed6f7a75beb880d82a5bdc0ea7b6d2a8b1a7491885f38009eb009704b1f8161e56503061eabba626e806abf6b2c441643bead667cd5ed568bc0864e1fc0ada30b36b068036025beb45be9c9df499cc3c65ad116804eb0366493b08a62b01b1b7dbe05b76dded43682c54510d66811bfc72bac2f3d942cdbc1a4310cbe67a4c738a61284d4f1531203b642452cb64df0db981cf1987dec99a878d6e8f5598c89d410bd8b326b997e637f40e14a2b8fdfc848da5221817582d84e58724ec7003d76445906a644aaf35cf15f489eb916b697084387a36b5e5e6d1c935ff56fdbb571c879bcc9e866f6178663e5a69769e3acc0f31875bac8ec0246899df63b724aa06a59676401a3f76ab60d708009b83cc52d089d60097cb7a72715b30c8bb4f7f6a9bc488ffac63bedc6a5d297222dd29eb80649a274f7e9000d19e347f7f2caad0b0aee94b92945a9662c929c813ba3005439ac59f11cd3dd2c8a5292b9dd1413e273690ce26ae61235f9b29e1af5e2153478dbc746ff3540ef1c469ac587a290d7b1d8b90a90aa3faf3261a318e36fa515328cdfd2512be62c44696a3120ce83fcd4c263e1dc26b2fcb97091dda52679b3e5c5d7e37e7cab1e3d25449db9b984cbc189c70196164e3a8dd8f3980c36eb0b59c50116f1d7ea20a66b60770e10a307d6e69cb23cdf716332f1e9e1f3e3c9b10491c07a81e2fa998fcace354c9d339c0b2c58a745e4311821999bba675d155e47424eee1256396a8035916aa2a6d047f9b268734eba00d3a0971a8739307cc0a5baabd3b8cd846a96b20ea4d4962af442cbe83812d88308e1c31843910c103c4da228d3386dac66c811500b6c82500297a47bb9464c096863077afbc6826a8ff33b5e9f9dc0f4f0920aa743e1f4e698771cc06d441d96bf94753227d6cf230344cc2add4d8f29f99c42416bfa87246f1c9de1ac4ae4ec6ea8ab6ae1323725d0faf2a6834f1bfb6e06dad61fc40b5d031714c7c4f43197aadbe8e9cdf32cd9e3a884b6a80a7422abc43122b5de4be8213bf575b136fa63a97f54523864998fd31e5184eee4a67fd20e8fcba366cb03a60a251c7f1ca3fc2b676792b5d9b4fa8bdaf4942bff5608d8d66acb78879dca7b33679a3d5d2c245f8899047afa01dda26eaa85e9e0ebc5f1cb959efb6f91ed12eef8e52d4cb22b8ad3532b9647136012bb4bd3a8b4267ab1fcb6ec960f378d4c89f46756d2500493e0fd684a3e0a5fceae4b877b2ccc11fe107ae26efbbff526209fada8f9da7cda72b0ad8223fd017b99c9a1d1d68b8e4d9db7f9e029d732a3fd1c0565f36f11e7f24b7d3733785aef70939b49f8ea0e3438c322d7f5cfffecb141ceb524f70ea7d7bce7bef239ff4589c3a5a563fa4fcb0c8b8635775f8f6dc0292c5c6b6caa6265bdfbfd942ba330e67b625bb0cbce01f6255361438c06395aa9b0780f97cc2f51d904812a0d98f6e8bd22e6f5baa48d2768104cb5cb75bde9ba72126f9084bd5f5a9c095be93335a44008008a5c9c75d383270b066a61dd87af7e278a05002d599b2f0ef8e1288e10683cdc7b46af2a6f74589de0194869b610929b2f687a414ab08c1b9672ac71fce9775ffdb58deaa37f4b2789330dda7c8b41b5addc2fc5a742e82372d798f47a87ba17b0bfc5c76d0c4b910616313210d68358f719a48c52bf11a526e42a2a0cf6edb6a4247ecc4e328c49f47626c7bc8e83f6e2b2fdadf2968287ec7911d4a20d6b13f395feb4dbb3b6e98a89726b1d27fcaa8a551ac5284196e951515a0f41200dad10e3c2d3a6632c3f0d2eecad244e5a516380b692d8137d0da01f7efce075b8ab13c26b4ff8ffae6a02022525b2fc67b4140422261f6ccdc97447415cb4588128efd084fe5a9fefde9ee749385a0bf1a82a0589efe6fa5ef2e03f925eae62089a71ca8a357e6ec67efa8382ae5bc9a53da9720cf3667df1990273e4a412f6a4d1ab4b273adf7161c86746168f25480147729b1a9bfd2fb0a44d68241e6a55f8e8636228f59db3dafe34cd7beda776c0bfa264ac52ece68562d3f340a3d2df57a7a8bc6e7b1a0630371fbdda2518cba0d1b252e03eaa497a877d173f9485b87b1e13bb7df804698b066a7d5e0190ce115a827bb997763ca94e0d77257d3936ae0766862158564a4189e11a56ab1097f687dc0dfdef4d58d9c6743c09caecac38a8909fedda077bbd464daa5be09d849897a03bf9251d4fc0e7576d671d632ca1f1f529ab4a901f075d2177ced8496c494b917319f6cf8e880549f881f19c90eafab7284bf721a18ea2cf9bc4c1acbbe0127ffa8a03f3d578644988c6d7b5c1cf1fbd9f0505715c660442e3121822cbcfea75d015c7a3d09a54f89822f00115ec0202c4f4b97836082f3ffeab1f9dd49b349293f02a8c6285a4228e1efb2bb002ae486310fd210f87606c3ba2e596f40779a8fca686fa662aafb0a12fe823219c81385d5c601e184b84863c0d8d90928b5455cb05d0dbdb2ff63100ece14f772f16ff2bdb6c57c13e39b8eca3a041767240b830d1948f3f28e3d4e9fd9542a5d3d75096c49af1be42dfadeb0b0b7d0d82054f2d4a0e971ad5eb7565c42fc11860aac91f5ee42ff4f70f9c18840576c91cf64d8f4587ad657f9cabae7fdc89108bef5607a61d0e4d817e45b69cff8a014b15eefb873f3cae02addf3583313b42bf7f6bfd28756be9125d3c3f034a72686e57aa6674de224766bcf873680f44bdfbc56a677954c3a79d2e691038d6edad79fad464fd2122106f126275165dfdbacc71403e33fd88bee01ba1ed3e64a9418338cecb2eb5743a81e1fd9bf033d754030b2a5d51305d00b19a50d2b2f0c3eb9c566130b16428801d0f2f676ce474155e15775bf0a959127e6370ab8726f585a53339428d6d024fc67fc2006b15dffb5b6a9807cf6cc927348955aa65530f9804041e9a8485eb210454b0500b2c246e37d9aefaa3da09952db52616ba2c07ffd768ca9e219f6e7fcf4b74dc8b80035180546d83ef399db5aacd5dc182fc906e01ed8ff1b64893e14b7ecfdc0d58b2cfb2064ba365c20f167519153822d7d039dc12e81a3ce961d03a11f874d6f146c86de12e5af1a31f61f61ddd381e75d8951dde1fed783d737333d050961081950f8bcc318f24bff0c4dd11be0d112f83f563dc64e9b71214de03935a75b1af35a496f8ea4faad8625bbfee161261fb4d4bdc59c9954441297da2f7966bd83910e791a4c36cafdb8e9d414071ce170a9aab23b0427e5b07d44747c666bcddbf625a901f6edb00fcd8b88ef129913093437d4b28f5227190ef02209061f3073910580bd9723d0eb10e59c3f4ce6be905b5a3f357f68fb975d422ee8c89a4ea34140e3736a8b572f993b38cd7aeafef136dcbccbaffb17bc9667a611c9bac944cdda5abe5aff9e3743c2fd814da0ecc99b36c277982dbdc3f8f8294ca52329d624d7e2224135f975b7c99ec5e9d600519e924605ad0025a28260c40295b54e04ad4fe51da0c226a116c1a8d1044e42595e512d10fd0f2b537ee457b1c90154d9245937c304606b85431da5922ffed49f44799ba8f5002157aaec8fbc750d664cb91754d79a63ac16e6f67d9bd2f6954ad5c91d9af2daf250f3effad2dd7585550ce64de758cb5a2e58f72670c8d309b39820c44d10b89aaade3654916f07c5d0fd6435ce3f7d1a5d170b1796c3c87b62b2e9ffa9b2f9a03a90147b0742aea289dd33bcb649c7f88ed54370cbbeab722bc469b5ec17aaa34d3a1396cad6ec4beba7916c5b2a5fed98229efad17cc2b4a8efdebeefdb965875a1fb0e65805b98be31befb8daf8e160136828f7784d276e505d4bf3c941d5283dc4912cbd8bb0aa6fc07802e2b2b73413ac4e511a151acd678b8a3e667c1488090422f9ad23fa2f6df3499296196e1f05ef51c368fbaf8ea100eed7e2e9970d2e29a99505383045c94e49ef8c93abc2759815659b5af395a352962deb755e7dd5b23a0fb4c38cffd86adadcfc6d8c399979a0fa62bd9032c31854bbce62d040006a6aeb5275b4dcb1af24ad910cf15c929c596cf39aaee2600036276820731a09110379aaf41824e801b34003c520d5fc5944c3be321c477b615ff9db3355998bb30be602ace9ef6ed35619ed5417b246e7c1bd428cd089639b287de1ead4b63705c3e658d226748e49bda81cb3d8916d57dc62bbb6504ec471ec9eb50e9d0e3737a1d404062c363a1fead4bdb7a2b4fa30cc2d3ed9f240877d7cc588bd417c1d410425eb6772d7147c158344012e2e2204383ca77a869731512bda8718d0518e61327301ff6fe995a7621ac9acb12a4ddea587e572a38ad3ef1937c861d7689f4d7cddca42cfe5a42d49a6fd62d0bc54e3f4ca2d61e166547ad80dd0e4b1e4be49acdf9c27925780aa5365b9932f58f793735cdfa483cf2148945bd756ec8f80979921d70f4ab7036f2bf6f57ca7a62ad10b2eebaff6f19bf4ee70ddbde459083db39a56825c1d60a0f14e413e03be39c7cc562ca070ef9408f0cd4b4e961d8208b27b21043b1ba45dbd48d40b33aa82f13b35514e91d3ef88c2c42b927cd964b70b873aad323e7862825523791c613a48ffb632f9784a76d495737fd5253988bbb79ed3f33461b7c90a29230744cbd81b3b66685b8f535216d09741d3cbae820aa18c341c8c67f8c5693cf6e8a1670c016915178e39797fe93e06825dd17a79e9494375efedaa3136993a14202b891a6bb47a6d8a3872ec9f8aa9dac30398be9090f2b3d5e09dc14e260a0ddd78adabd6a85f89cb34d45d590dc8b660d0faac3415c8473923cf0012a76fc4eaaa53d65705250c72fa3b15775ec09adbc412b1cbdcaebc293fb3b4f61e48914e61b5ee6a98e2687c4f1c31cdc3f5620dc893cfd516832d4881ac3e6d91e0c94797e8d611ce85f8ca3634b316a57d5024cdb8c9706de8e37b76a8fdf3b6f9f25af6486a2e75066677f1b1cf6fe5f3bc646d248189550002274be5f5e3c07f204efccf125c03874b8d0cc1fbdd1ddaa4783cd29ff11f8a7961bd5c87301df303ccbff6145832b7fee3e23078c10ae7193e99cfb5ceb92102448e1d0a58ab1b1bfd4fff8d1d9d64be1daef02042e17ceeb154cbd9d8967d329ec94b0539764483b16b25ea7326e418cbda776e15da80dc1cfc11c7ccbbb9559703fd3ed38ecae1e7119a7a0b3847159e746613a2880023b3e2783b47e64e141e27cfe7148b427e71351888b53866d6f6b8e9b51c56390101a4af73a8331c27cc9f90ea652ee1d31f304b9bb70fb215f5aa32841e3eb63a0f734928114b3856ed73918d13996d7ce92cea5876c6a157f6600233154b35882152254588bf0b93473f910e376931cfdf9e3e6002da9145e6af3baf02193500737cf0d95d96fff919a215942edaa48cff87f4314cbaeed2a9d065d0f941e3e1dfcdcecfa750133f4aebb3bbd01fd537f022cb5425c2b2a8e875ee7e09903d8bb9a44a8dd173536386a53d70866a95021f0347ae49fd3ee7538498033a098846d3fc6c8b210272734f955c8e1b36bfb15362e5d9ee0704f80dfac70e0b802e24d6adbd18718a578a26ad83100ba94d5d36c28440f713c8efe125248d1dcbba034a7d0588e8878b6367db66a2a757c37ba84059b0f668408f60b475e9b13f518f6892f9036ad39386d773d8cd9c38e4bb07c3b1cec54d125bc4854ae2d8f6cea5165916dca57f8bf90937bbbc2edd3b78039d7db5ea0d98f868360478dcbb10f2ca56c5a3dcb204dd7ec7f5566ec2f2035570455ad2732c66c0ecee2ecd3b4f711e4f7ac3550bb805428dac7049c0b9f614fe4f6014d7b21e33786cf700c7b0fbc2358919cba3fe9f2528a93151e31dc1517f854178f88357c2bfe7d16f7f21c877820558829028ccb2ff9c7ddd27e29d087f98129ad13aa64379491446b215520dde8e0085307941c7afee9b5e8cfffe72776ca5216d25320a7224c86d57c9a1c8f23b28a174f7e3a2a02f76d16e457ae7c55461a3c7b35ec9fa110f82c66f6b76ee1e7c4f3d8c2a596693d21ba7e21434b1a3ab3713160dc0f4147cbec63450078b55d324c806750eeb0d0d7fe4ada6d6e78ff6768f135da39ee3cee440984a50ed7239b984e1ffcb42a4ec509388994c02dffab6de24fd64eedc61b7fb64e1fe3f18116bb521f63c42d73d66870552c1cd580e2f71c7b0e0d6d97c9239d75ab4cec25fb1b58b28136d8140905626223791eae612c5bf0218bc931f1f64e0f3596660a22d8e4784e7b524c8553b0be763d4bd156a2105141a223e7ff2777dd632a75c52c434dbfce38e24f4b4f183e3cc112fd2adb302481578e35d3d9e108309202f4e9757d4f7bf91eb1e420443d56154be8f7366a3a9e19df5cc74d64fe010b03ea39ff4986eb724893f6407a81673ef6b673d0a2843dc24955f1e2b5671f7a174d18af94f1dc8493a80a801a54217769c6fc3bf765c2fdb002ad30fd9fcc2ceefe01e5340dcec7da8878d4accf2ef90223236f2b9d1023a735ae0d3ebb51fe62a65f46a2ac3dd221fe5f9d16adb65906de852ce86d5d9bffba20874643a2ffe33f117de350c531e42c41df1ccfbb558a5d8993c6edf70210c37497f1bfc79834f36cd362288f2212b5ab84c97f9938a3b11d236faef1ac061fe6b82cf7a64f9c9dd351d5c66e912c920370e654efb13a2f50cda402e5a4f2addd7d8e4168a5a8c975e5213b8a79c61a88f05cf2b79f6a221a54826bb029cb0471a96ed6653507941c14f39dfa50d63aa22058cdb79863d129bf2e0629ccb25d75bf549c17d9748505b0aee926e4f3be1c12f9e2f18d392c97043d6c59efbec62f766d5330028ec47b262a024d597bdb371f2b4e553f6f2d414a2a13c2ce34bc8cb879ac6f091fd75e920eeb3530f3b748f029f03ce7fef308380ab0d719082e351f878b10bfe04c92c07ce701835dbd5e915b9e52379713390ae69edd2be431ef957b66db93feb02a771c91af34a4ea35814841482b4a1b5175b797743caf19ba657522750e1ef95181dc558762b4f3d8e7ba4bd63db25595a2311ff1218affaec46e87a19c65e0006983a826e830cda9c00f3d9bc63896329eea3f4a411a38727ea2adae8572ad6fa9929c40573628d2c0ce0171f502c1e4d175dc323aea84aa4d14713e791b9a280db5e612e840723416c9133ec49f67255fa4ce234997e242188c4f39a261b981b52c220a45bdc8e9010aac21af340d876e6cf7a6fce1929e0d84b9c128ea57fd4d74ef8714ea0506ea53c4cd4a3e4916e2719d9c3dd36df4add729941b79b4b87df1a2ccca750aac4f0228dba407e38d4fbb8dca2c5adc1e586c29c774e73f3bcebaa20e21d61eba81e3666c627d24b457fa27001255a1ca7ebe3c3597dbc8715b6f837a74afb08ae19c05776d7cd0d22263204a3cb4a40255c664fe4241726d2ccd753bbdbdfa9bad10e94c3d4cd23bd55502a3bbc5933b9004153bc9aac192073591760afc3f57c938db81f1604a88fad316603d28a64db59ae1b75d417f70fc9e0de98f55fb22f178d6176136d8e19e1b3e8eff37beb00b41ac4481a6aac98460bb658e43b572e0fb2b38bb7fb86849bda4251d4cb28948f793d29dbf931af450c1db72b968778afc92c0d3e3267f4ccfa419db95c919d1f7c9b3ec93f817280d7bc8868b334df2ee79c72d392e9bbd06be1b083fbd78f5c26f1ed92c94ee5bd35e762bc381d0ad46445a26b164accfd36653ae0b88f20f3fe566573a5fd51e8597bfd6bd8ba7c40d832ca5643fe62183aab2a77cc3c52abceb6139672bbe1a3f9f89b8fe0b7df6915ddaf3cc2150bfe94a2eb2149ecbd2269f00f8c6bb79a113f2fb569aa02c812c512f886426c794f99a85c21002fccffcca0c29c9fad4465e062cc406b0b0f39407b4e853b78a7d5f9ef340973b6a20e8906ffd1b2bc9d11dcba14203a67fa2ff9c5b233f326777834d13663f5d7e2e6776ff94bfed5048a0cd4dc66c2c9edcdaed03bee31ff072f856fe1ae57eb8bd13293e085579a3b0f70d95c10c1a93b28241467baefa15a84c75810e77c9a407b9e5b4ed0aca3681cb13ecfb4a51dafc1a0562eace5dadff9a57c95ee9245226d7c5d6a233cf33f6c404a9e025afe710a50b69fd6f913996fd5719f95343303bc4af018faf80b60bf1b7d683009e76023f929ed3244af6251e9a334859f059d6c70b48a3aa1131cb7e4e1216caa8e6c5576dec8025727ab41e0ca666d9084bd22fb516ee89fa1333e46a8004036bfe88c9918b3b08536f29a0cb913b2dc9315960a24ca79c7166e8cd7311b7e7427087311b0834f2afab1c78a13df26a37675151c4d6e3e704c6261ef3bfb8e14f2843fc57fdd061b7b67f9866096cfcd39a489435244d4add40fd987b0d123c5683cad1899896a4d28b30844686e9083321e7cbdca382064aac8ce525d9ad61fe39f78f40fadda8045bb8335efed894268fe49d710ec119ac14edbe6117cb14936140ba9aed09bc44dce84537aa64458eba25ec9074a62dfc2aee07a319940fac252b838ee5dde0afe26cabe7ba50c9254689d31b0bb870448941c13eaa2c21dd698515b1c3908a9e23c99b559617a6627e93d64a4f4e3396d6407daa07cbbd58224705b83f90570dfdcfee8756d0cddca315ebcdc69514ecec7d3622d95f52c02c79dc8ea9a84856f0b2045118616bb1f1400fc4f5a19c181d05c96abc2d8f3f75c565381c15a673a8cbd68f770b7a3ef0cb2c5f9b0af584ed6329aea263a44f32cbda089cd82453c9388a8c12113b6a06360b53abf99a8782952584f8eedcdd2873561892bb96f75a75af52a58b22895ab8a2f8f9682c4ddc8280d0ffaa49994e74be64614f510802d205185fa9ff9bd273d136869826515eb9dae5aadec7734efc3665162ae6ebe7bf6937542eefbbba03a0a4c7753d3e33e4206e8bd8ee4833464ce6e7457d572cd230fd9c8993bed8be542bd8e838a3d93fd2c1e4b2405246a1abff37c97a32442cacf01e4253fa534ec96302a5507ad9fa0185589f92e3606cf6aba0180c3624a5649ef3bd663f8e04b9229f6178a2569775aba49891aecb8779e669f5871c34e6da293292e3446bb5e4fba87a5ed85f4b8f22bb97f1192dae913a81e4f856abeae9e291d792693a55f69b80c2149889a130f831ca9a426719622f689a0fa83aec46b8e85fac0b59f635bd422488cd74619d096b0631d5e1343a8261b3bc79d95fd8dddf332719a4ee435e3b417684492ee541cbd3835f4801068bb202d1350f561dde264ebca08281ce961d132f71237ef97caca0c0890649c78d91069fe7dc09eb4edd4f1dfdc7c871fda1c394fd693a3cfb50b47e2772815d6d985927c8b9f54b6b132f65adcb247ef1124ca68972c04512f49a0f5da471dbef0f7ac899164f7a3e1e2cefaab573619f2b5ace1f825e5a66221fca098388bc7722f2fd658c6a45d24ef31a282adf37428047fb0a59701c7a03ed6ab57a63b092f0f99363bab175b265489cbe1e901af4ed7b9d31710410e7aac1a7703f0c3f3a4a639183e63698db58b2a12253e3b3b354f50fb8f46c8b319c72d64e33df19b8ba40b2400bee855a8a861fb9de7449d86e8605d1735e9423e76c16dd67e70fc4e30b2563e18f6dbb401c385acadd383d0aa2efbe3b4dbbaea844d753674774745061b63e85c8103eae08d0b84ef9511bbd036d6467708c78f942888528bd0e9afca2bb009d488d910f3b41a2b13e63493d61432b8a389daee264d204c09ea0d7b32ac828d24771eab8e302144ed30f049ad154ddae167f01e717f6ab6b7e293c674d89b76f9d43b6438dd90083d664cb7301f6e669a91bb5bb2552816d160bca1bf87c6fcededa3563fee11dfd41578fd6fb4c6ed8732f35062e10ad137f3a8c35ae2bf51974ad337d304245911a935b50cecbfdb9ea9102f004d2435d4dcd852696e7df0bcc7366ba847cd6cac4458f0a1d8155114c051d0f970ea21f61e7bf2075dcfa0b09ed85dbf7fc9c028b0d73420c1e32de13c19c6b9cb2407d9d578c54e2a0fcb661e6ba0b7782911f138a20be5ef3caf04badec9efee0bae2fd337dc9263bbe9a20a9830c4eb6d0ae52a172286e164f03fc837fa9b0f09077487c1ede4ce075a344b35a7eb6de9cacf743d6f4bdd851c4054eae9fff1c200d8d314a67dd408af4430f705766a954ebb69de853c1c0310daee700aca9397276dd6d1394a0085a0f980a98d748ef64f9114defe6af84ce0ffe254d57559a8d1425bcc774f6c6fbe1e8b0bd62fca44b0033c97f403ce9138f1181c38d7efcce0298c7ec3864d710474ce2882269d95409f0cb77d0145a24339a9974e066c53dc67ca93810b3e3ed105aba9e0a2f72448f368e532a204a08cbbee55fe07a513441552d37969a247dd1164dda53d6b5437730bbfc249e3aa01a810fa50b6d86f7070ff7aa6b489d045a9e9229809466bc9d06cc4cf0a1fa9d5c74e7a7eef851714b090dbb113c0d8ea5125741562ae2b3c944d444dafdac9a6ea76c8295c1bbd809cb83aa9661eae45d5c7c564c78846bd6fbec9f2131be83f4d8663bdfbc8ffa7925b607947cd2cf6ab2d570cbfa0091800effcc292b418865bdd12dd28593f250fb2029ab35693947fd855e80f998ab5971270556293a037d616648c07a4a6421125680b2458e5e388a2fdb243285b8519e403230431828f2e74435a2021ee17f86ce1e5152ab0532defbfa28b5bf3f3f06b7b17ab0e9ffd8becfbbeda57736f8e397408cd1bf4c010d7ca0071232b8f23f5d1931e3a6fded8d598e137fdbbc88b0ef8197c3dbc13510aa21991676bcb1d75332154b32c8acdf7eae26de559cd427ddd972e2c6eb5a3eef214374204e7559accbd0227a34aa3c0122fc92e9e16d5b8761ff8dadd46fbad5a1254806f240360b164b8620881cc0f87ebe66c492798f9ea74eb7d4861b97a76992ddb6f0f6c02c92e85eb77810144ff35fd2f19f1e5e7a3c8c981dd71adc2eee4591519da7ffb0b4f5ab2446cdb30faca693f5642dc46094bf9c578a9c0f95b9622b8f6be44255a1e456321a52e9be15d4ff806e793b4452dc3d97eee08b8f42f78b90bb88fc6da50b3c198328d70b40098f54ff5bc2bb533b85f386bb6fa6e5ab9035df2efac759a5eb6bf5ea13aeb442cdc2dbc2eebb4431537fbd57822a6c09c115fac5e0cfcc9ced8ee07818abae7f7597c1afc837dffc953954a5d56e98112e7ec18b15f4de0ed300eb2c9a010819a2d34007f5ca69d1ca5bc97d55f799b5b053cd29045bd2c94b708b0c4664f6e5e76aff888413d298af817669c27c95d223addeead1a13b197bd73318c45169f89569368f343c0eddefa615c1cac7c34f251b0e51163689d1f1f1cb9807ae9cafc1b9d5dbe206dec07152acda28e65c757baa20fed6e3fbeab5ff7fde26afdb550da6a1e26fd5e2b9bde69af8002f8b7945c18278558e21419e89d44e5c7168e8ccb8e33bde409c6dc5051b156fbdc44aed939087789d90638f3750fca18cb112b029d7fb56a7a726266f69e6658b00d218a7f86b7bef941e0bdf14e4fd68ab0ce74c300ab464991ca353741092e6bbb63028d2369592f3561708bb014a0d203c0a68494f46cc826a6204d235eab78b1e008442e33339b2a82e321ac8d3af171ac623f1966c9d46367484501d4dcaea77bb11ff15ea55a683de450aa4a6a086a5d780a751015d1902fea6a422d5ffbe886bb3b57281f55cf3803a29892a6b3c38bf1171ff6ae492cd519a0988956cba3240ae1fce623e993ba45376c4e948613affc46542646e83fff8b8986c4246a9e72a2d68b5883d4a2cac81e06a744be00fad7b657755a9667ce1ae4afb131d2ea9c6c9864edb2e8c1d56bc4aa94e23419ab06948c4d0cdeb14d7e2a3813d7e82bb6ca8f83af9a225c6a92b553feda17a6412860f7bc7c58bac557cd4f3324a0c98c99ccd4fc305503188b0512f1e55c969446ae14e292097b2957ea3dd586dacc400065b85a9d21c18f5bff5eee0148cb3cd1474be658dbaa63b9dc557abe329aed75b61173817b61c4ccdb384c80407eb6e1ee9d9feee1c957bb67bfb3a1f6bedd6162439787951f34219d4adf1e98f3d0a7a3c7a8599ee200ddd32b030b44b303fccd84175a4f0fc403cfea577414e2747a57a62b24b9a8614391122f5dab3bb25f5a49b2472f00ed5942550b2d19aec592fe9a944ee710b0874e3aa0f5ac80bd68921aec492590d2a779adcefac5ef929d9ab50541676e95b87c1c2ef9673dd3d560daa2cafe710e0300db56387d852161ccb29ee679d906ade581536d3e3ee7290825fa3ebb5d6dd16fbff767ffa7e42de75d7f725906063e3a2d2439464e8ca880b2db390c68dbe2e12cc41ecd03a51f7b7129a831bb12779a575f697201e1f26eb2e85e4987757031c22b96246d32b9772f5cc57cce6a4c80d1f0cdee4d396f6bc39869998baf2f5ba4731ab70af4ee87606cf5f1855bf11ac0b4b533d247b9ac96e6579126fb817c67507d741ce32aa154d3739da1fb728b1fd3fd4c0708a0bed95279eac2256ad142a8a969920ef6a6fade89f6d23232bf3506e6f512605efdd766607a71d3ed07017ca604b99eab3885be2f6c384c848ddc9f0fe823851bbbf1d34547ea5969257aaf548b8437d8e3dfa021d0d96dd6fc20e90c10e534f25af9171cb78c1468462d679cfc821f714d35f1af546b8037157c9931209d48325594f38083f9837d0df85b60e87cea32a9a3a133d219c20a6e725202b171299a5564dcafee27e73379e17cb1d59433b5b10bdd028653582b3bfbeb642f3789a9d46a2bc18ebbef06c3c3dde1001efeead04a3adcb0943bd664be826ff99177bbd80f7371a23771334f4d032b9d1d29f8f2e9ffb2e6cfb5b1d70d4fab454dcf56618261357a9f7aedce8112905ecb4e100b4d9ed6613f8b49b6c381d2bff6728a125a03849f5f5aac855b53aebc3943c65bc13ed21b8970411f69d5fbb3e064685b114b16858e522348392f6398deb321874f267ebbde8aa7c92f45ba12aecbbab0a20b98cecd29e763c7cb46807bfa58d0225760d1b40ce2f2fbfacde13f3c96ecce13dac084a9939b453333c377932ee84e06f94a835c0f96b46825f0422dfbab45b1d7f98e8fede2e8c1646d4905f5ac576d674790d150d601aa573eb4ac228ae4d43f3361a4501eae685c70412ad0948693954b936326fd823f716977a40c62d82231cb1458c87bb7f9120d4c25a6738e686f68b68c8239aedd7b9a78dc6882c6baa7cf45c87ca077fbd81ba00ace7d8ace992a2823631a6f557c1009e6da50c55bb6019c85a3084232dd861eda5b0e48c84c86b728c11ecb7db870b9e30b7e29d3c11560159d146b5668ccd9ddd63d8fe08a07895fe48bf1955f29a4a25893dc6470d9e97e0b0668c92aaf236c90421f345c821959e859089656f2be21d86a79618263f82362c9870d927e47f7e4aad28a451195cfc54a1b12b18609e3bea4f6990c1db4bdc3dbe9fbe789c00bb585016e1eb270bf164822c029b0eaea5be9420b3289d02bdb642f2917035ad542e3609be09966c38ce0299922c38cd6b1f7be2779022004b7732a72191c196e465d36fa8a78bd3010866d57c4565d2da300216415848e2ea859dc046f3d0292b191decb490bcc06957cd2cbfe28e7af606418f1cb4581b87c7e1ea87a89744ca3ce0f318f5ac1a38a6aee344e7517e864951893b96054035a6f24fada41fa8bb79a2813e09a44c4ea7d53a420e027d32c981538efa5212f6fd8d0fe6d6a6b5493525cb2d7ac39593664fba382b01f341756075f719a4e9e99c3a26a4bc6a329bc6c93162025579193ca2f652a16f210a8bc3c1ad8237f668472fbca047c1d8af0e40ea1e272d04d52fc3247972eb0b4e481859e5dec4955e25b7aa70b8b83c28b3dd8696785990788eb24ff03ec35411691a01787bae984ba9a681420b90f045329650b72abbf3d97cf8a1e600e2dc27191ce86438b8fb0d30ccb3163e727bf779ff7974daf5fb4f6bba0e19ad0263bde6fd656afd1856924f43a1910269b5d1396cd6615cad444f8679b4dc15389c43fbc73d64f1518e504d5eff55df255172579918eef5cfed2a63a3a385612d8367712ded263692a5d44b0b1a15e482c2dbab75edf97bc7c62e934cab6ef661d390ea60df19b9e48ce5a129e41e37cd3934a05689dd56b547eb4b968409f76a792a77fa6f4f98bd1a5ca7acee6999e584dfee065a6275be735f7a55874b74a9c7af2b24068c1a518eb3aec57ace501df197a9204060f7003d6d73c2f30cda62fff5332ed5ccd45da5e62d31fab7a84c04957ff7afb43409fd3f6344e6966ccfdd195d5c578c40666bdcb2702889f599f3edcde837c6b6b8018d7c54a6c2183dc7bfdd734c03e0c1acbf8c8a875dc698645b3010cf7db3e3c2eac80de92ab7643576a135fa7767c9bcba665e1c4c05efc7518a68fb3b4d5a0236661324a462f9b956591eb3f10ed7e70fefbadc5e160856f3e4f8eea3b9e7cb163dcaf2e2b98948c23a6563b1ecb1de02ba74080084ab8916b1f718f158c5896e19cee84859fe9e1339f5161dc10beefce5bfe3a90cc6d8f627e32b9f7e7209481e936ce06aa1b93a75051bcde0a025afc6dfbfc0ebad2f20295179a423418d6ef67b34dc66d7e49a935802928ac4759aeaa3627e8d5b33a7d111a0c40d46fb0c23751bef7e10d3199519efd4d63eb77fe010b69f21ac7ce97f28399303c60bc42e53da72c192406363c4b2a971cd382e705f77447b34605c30e55304fc73327085628fd70a76837d8dd6b7b5d13e9093336a9ea957bd319c1fd9e46344da0f333d60f399e759a74d781296dcf9940084da1424961ec1dc83411d38c09ad5eab63873c3081dc017d3d6f07cff146da2495f51e4b4be924065c6a85437b74927fce323a5a80c188fcb20352b233e527737caa94938227438e1d228f0b5631df6a3b848646cf6edc0f6b3131e934ccf2e9b0cd0dfe4534181a4548e769d921cee83e7cc4d37c555807fc690fa4160b919e174d2852b56db5e8dc34f36dec8ca2309ec602d44735cbaa4f7d744d6dc1af9948da849ccfb4f313199251aba9218b82b6e4168ed57f6c9eb2225583bc5c7649a2aa6d5992a11c94a772757d6d35a873fa67a1df8aee05760e8e6f70e9e633d04904871f2fa076fc7d980a2d21509ee9f937455856cbb50b53e1fcb1c0b5564f7d27b593ccdbcafcfc8cb58bfe74490ce30596ee94d6459464982f6d0d4a5ecd886894c2a70e940b6fea76de1701b692c4c2535a2b8bc6df9d441028b8e0861b5853a23cfc36826d0e5402a8ff67b5d37e833c625a5ace50a515b61269da8144e9a86f86","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
