<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0d8ac30fe584ddb4ed14554b818eab7c663a887489589d2f95b6bd5c847060c43e16a5f9f7711edb60a91d4ab1fa699982ade56d77b4b68f485a2c8e8cae3c42a9e24ba557cdd56aedefe06fb2b96e72327cb8761cbacf9d10620e904c98912b2d82c0fc76fc989045b14febda3a88d1f579cf6d929559c81d4217f0ed111e3e633a66817f3752dd6305322e25bfe7d6f95560f8c0e0788bd9136079af3f0f766cbbd69bf9c0f68f0edfbe51848c1a6d6c519f892c064058fcd7f15705079b8966c87b1e16dcac135d4ac915c1d22b6afb67f1410af8f99a89d9238b4b2e951f780af35d057c0aee2b2a4445074cdbf99711d1908c873bf9210434b3412669fd379f91890f56f20c64d896ca0c2844a6a270a3e98f10333f668a744bd7a2f2b6dbd25c5b65f392955e871ef15d242a181754c82d814c7eb0827eb064a16b17a27a9056ee24b3244f00c266cf334af190c17210a936258e9e0caf87e9585ec36b0f2ca54da3f3557a5bde5e928af3088a526b6a9fe57bad504bb47adfdbc8a80d9f59e4fad0f5bd683210593c5dc7a0324ce5741db5cfa2af4d00b2f587b588844abe78dce0efd063ece236c8b29b77a44ebac56728f7ab841f04329cdf3b1c44d3f90c8b4b7dfae5a13f02e21dedcc0a425d440035ac487124d5fb8eb1dcdf399b982333b9c1f66d0a137b14d14241dd9c7c82c7726a36ff6f375b56175ffaedd3f7630a7f4cb57c1c073422a200437ac8817cfab3601adfa059d64e8be1ec226c6a09f13c3b464656a392ec9bf5ef7cfe855e4037b77b7314606d199203f8f9e0861bcdd91e3e8d89276d0fecfe902b48c1fa583b3c6f9001798ea4af949e161728bd9d6682b525f8b36b51feec9a68e41bf34e915bec06048facfec4bc52b29c9270ab184ded0541213ee9bfbe8f61c6e0f1232951b8563d3210253bcd6b1b5fece2f3d3dc0500298befc5297fccb277087659d58e8d3b5e29db1ca31c30b39f720492ef2da612d40ee955f50ea618c14093e03de3d83c8c0adf601fe9a96690e405f6265702b0013f1720070fdc7d2aa41e26e3ff3975904f664e20a833bb5615fdaaabd57ca7646e052ad140d33cd378ff3d98e9e77f9f6138950987f792d7699d57bf80006eca5516085f9d7cc861c181185c84486082c257bc8482f331d49152dad60abc0fae90d1a1e92e4c5deda7d9976b4e94dbf7bb59b37af61a21554b534bf21ea6edbbb65d6377f65fc7b4a08ea2e8d9e9aaa6a834795c5bebd446b0081659770f275a7409a2c551721004113d24e0ddc3bf9a0b4a65ef679c6ddce5bd4cff41f17c00af76ae50784f0afa5851bd7574e4b6db36a3214ffb6e097814baf894272e99b1fe4df1ee8e9dc0650603a5f3a8c598af103c3f346dedda3597353406a0413e3e3ccb996e99d4cf778c40ec451890627749fed65bdcd8507b28e40e9bd5ab6dd0fe4f46f1807cb5ebd60fc489e75304a4188eb7b5a1fd6a911f5a9946d2b08137421271d62f73a1f43abdbff19f3ac5f034c8bd7d225004d35c53dc265c6086ce25a25eacba7309553466fdb958e5f337165aa4e6da37918fc805df176d35e911bf8be42683c147920cb433a200214e9e2f7f1d6f5e8b682441ee575f3e0978699f0dd6d065842e3c83d7e4669751dff2fad2fec5bba339dce36780d6e1f01bf5c727c577c206a1108d617a22a6351f71a4964c97ba8a67541089f5264b63472176899ed00f2a880978c325f9655168106010c2ae6c0b62e850bd3f478fbd8dc3e791a98aeb46a3690b16c5b5bd62d589b5f4ccfa51791ed57c9c7fee916f662290c691fb651b58f5faddb854b5829298408b0714cf0a0390de02e6b7b51b9018949b6810ee9d910c336402fb8abc99a720d5428e85e21f8c4d99bac409ef585e9cf81a33433f26f737cbe81c6f59d51aa7508928eef5194b2c1be72bce377257d483920fb1b6603a0d357964171f69d160c4b5edcb795231be3fb294ef1c081b58f38ef0dbafbc1f167e9a696abb345a8cb211c2c30b8e20d85db469145247807ddf59c24802507143ab7a489e97960e72f5b8fab172dabadf164c1bbf7d3241e9196e64b638fe232b796e1f0c98b72270166bb41fa7daf4431eda5bc7dcc809661f9bd785c6bd5ada8fae626b32f26f5e0e64e8192425012f3f55abb77499aba0d5105d756ab7aeb30601c1ed157a2678a6c1cfde3a4c889f49269b5c579f816f93ea60466c0d0f6219124371686bf8708345a7de13eec02ad73fa54c380766151655feb9970a2c735676421cb847005d2f75a2c9badbd51d047187dbc38de727cb0e50dc8d0b835e5247cb7764a4038938da2da530dbe5236b3cc47abb87576741fb531a2f6d8e7d2c1c17ca35007e92851fb0dbeb2ed3d2ca7d2e0723a7810dea04d4c9b9ac742979807831f7b1e04bfc1cc146d4e16c3bc45cfaef9bd858432f683d5cf7909923ece782b05f8d11e072ca7615246ff511d65a49055fa89a60000f2a4deeab0637178a57b19229d75187c7b3fe64e4c652dd04a3eb4bd4355c3cbaa495e70007d318f411d55e3a0544ccd79157095cc65f714157d48a0862f49f066518900687ed72053ead3ee3094a45140179d6c9bc74e27a0241b34577b25729beef35bc11894a106bf070263c0125698f622d12162b51803d457d9b657bbbf5b7a0b5adf712e63be9e0f2024b565807ab7e01ab5908b050230b538818ee7a2db80a77800d0eac5ba26abe967d256c487b2131d2620257d3487cf705be40bb7d3d2525a9bdcf59fc8bebf0869764ebfc34e22f6bd15ab4c47e4c6a599ad18ef810c7ce1fbf900e26ccff6f61fd8308c3d130d01439eadbd7b83956094acc1700848e8cae38e799f732df1c327c97d1d02a964d4f80efc39c3471e1496afb3f21b3a435c907e185c8bc5d62d151667795a7860cf886caad6b23781b579602c99e1fb2cb3b601470b1b2e1f2378ef803e8433daeb6d45d18e7155f04a7d6c460c70fc7c08d0cedaf2656909af5714800fa6a061bba7d0077c4b87e0e248973dd6d395309aa0ca2df6e2ba9e998fc71927fb98f7ade10819429b6e3f6366dee10a273e6f021059fab0e7f5e0498af0093bbfb73a9a25f2b30c5a0c315171608aee0c760b40fb2f82eaffe0df3df54fc94463dca8367506af297c2a04c57ac318dfe85afb949fe045a61f78a72002a21408c555b8787a4ab3fd7ac6c8d739cdf9a04e5fd53b3b68740380e653d136caa11af264390abcf5edf5b7eb43f3e6c2b639c5d8695abb94b55308a91a018666f830078de63d86014be337fb60b34bc745f3c115b9518a8bcd723767ad536626771a931adb0e2113db5e179fa0f39ad37cd57d5d842021ca8deb15897c3ccaf05f7cfd7e1b1db5d5d1277a037108b6860bea6c47f8a210db139bdabc62ce98ecbd7978eda6714d640c164f8272dff9cf8ea34fe98cfa4cad312b4595a0ce24b566e697b79f74f52aa751d9d85abfac656ad5976a62388ea966a1dea4246863dee8f9fc0d89f3b2df99fda9067dc7ebf910d6bd95ac5143586651059ae805a8fb3fb8e6995718544a8257c4c640b72f31e1afec538f2cd6325c5c7af5253b1a910c8accad9a07c6e287260117a8ac26160d139a103639ea5c55068a620eb5f643a8eec57f6e78b4db48c1dd48769904ebf6409175493473c22b397264a11bb0c20e1891bf6e44b413d1e3f270cf75871401c438cbb1060f27328e53aeda21dca1097d1969fb50325482cf35fcb1e1999d00527c3fd080a0fdbe608f4862369e2996a886ea5fd109766a485b67bdc44b5d33b6c871c8578cdc9de815a5674205d9a43a172e3e2761a392f3cc6e533d829e1eaf900a2ca07c6034280878008079d8d90d82723d5cad3e4aa25a5b2c33f8753dd15a4e057c2211ce35d590cb67de9b32a484074b4f6561acf5052e4be3866c281ca9e4a4ed8201d23d249459e19823cf21ab7beb24d3d00f37a4aa58a2d8ddda67d317afddf287f9effcdc562da4e0fe02be9a748bf74809b428d06b1fb3d0607dca09eb9bc5f8906d4f1c63d349175c0eb266ac8efa0b34e4ea8c755444e72cfb5edc9fb4f5365ab6a2e3f19a351157118e6e6e31e64dc6c4a2bd409229eb2f35a41c3ef7c592abea74ff2713c49e65b862b89fa2a8388bbaf5bc6d0b5df9bbdfde5ffbd9a8f7f1d5e0c67082f7b9b915c86a976dab601825f76e963b504146a9d3257ccc45871d5bee61c5d44c167a5351bb6f618ae9c66581c98cd0386137bd52b1fb9cd37a698d912293233995ae2f9773464352e358075be36429d07f98ea88cb20e54392950925a824fe694487f780ec20a10838be7f34aea25368a9c59a3fc9fcf9bac71a90b32cfea30c357e82a8b80841812ae4c5d60bdad12faaa5a1a13647bedc6e13a076674762dda2f47d2e2ba315d96c25560dfdf1350a9b1b6bd37a1a2be1d6fa88173708fbf4e58117a40b8b8985b4383af03064e6eb9a62b1b67425f72c8dc07542a3c048b763ff8233152e6dd1530076f7007e4e9e205775a027fbf0af6e917218b6009a099abd08e79c5e186d720aafc2ad8650d2f7e9d65c06d0709c3ee8fec3d7a56c785e705d203c046287d2ffa13abf4eac0c02fea428fa522efa269ca1861a4cb797fbd35732a01c808c31a55ec814a7c069da179ccf67b1bb9893c01dee173a19bd3941b581ecc31365d9cadcb777f825dbcccda5acc2ab644468f39bda93f501887f72ec2c2db7075c5b71212715bf71a21f02013dd104ca5fb1a9c12f65e14cf4bcdb80e6a53ad4c03567e3e665a06be3c5e5465e659d6ddd2b227cb1c2d251ac7c13f36d6e6d23f50f6cde192f0ab2c9331e4b9c806fb6fe382e2cb5a58607e170a926a64752e3ba871b9e3dcff962c9358dee1e39f02ff63b1f8feccc2adce5cf027b3dd3f49362120ffbe8012d2da63386df6057958ceb02de1ae94d2e105767d133ee590a02ac2e6765e0575e13667d54a6f5a40f232bece5a336e86c6b6e2672e54f0a1d0f0b459c2a169ce14afb2ab346b20ccc8864ba7c332a335297f1cac60287393702754ab791aba634194b06da61cc2d9260481a62339e4f2aa847188381272b53209e5b30ac4e70c1ec95cb59e7f24541376d2db14139f0831c590ea496ea5fc9eacb5c339b54ebd04035565547e205d81f7ded88deedea5f5ad9288c05a7ed7042bfcd07af7e8ff26bc2a680d9dced659d5fdd27b464642f5a32a02c01dbaba7aa86c717fae14de34a9ceb3114ad43ecb13d3ddaf899fc63ac2acb56f73f0ddcce42d20785f7d87309c633ee77bfab41822ebaaa19f185b7ed26b87b9d5eb68be60df9a7bd0e1e4ee501e0f45c7b05006f93ec9d6bb290bed9103168e2dd105c4f2819699548bf7344689154bdbaa722c40f4466dfd5c766ec154916d53584db76544fd325101ad601e8f9da937c86792fcf35a1eeb9e18ec4be0ed9b395a056efc7253e6a6f12981b187a858d690a279f242fbd58f1dacd069d21b9e181c9b19c22ec3cbd7f68a662a31dd512db03b3674d889f7ebd3aa802e75b63b60f33fd58ca6ff6872bc1779bad03b801d25f25c7af08b901083d8b34b8db728772209e81823193919ccd46363f576a58b35cbf13708cdf0786edcfc492ceeaf664c7a375eb0f99a26bf9d8706ffa28d4bafacaa595e4cb77b5912e7cdb507cd545f0fe5284ccb493ee2b4c0e4c3ddc45100a9aa36fb276a56d9a3520bad4d8ca713154e7238f0916a2ba7ca32ce6e9f71840394eed9ef5a1e604935e20d96ca940431ed0a3dedd34a4a0113bd3f0c9b1204b61ab727b317974723a359629b2da6b251200059f2eb232620b315e5921f3f7ab407ea0578b9f57665f2649d1bd2296b82966d7fbfb9d8d3984295a5de88d564bde1319c162eacfd1eff7194d0c09eff343ff2169d4ac9652ea0dd2b9d26e1563ced30ccad1b637d4683c3d16f7a8924a6114867c3b7ebcca4651b78ca8726e00366dd1e6fb2b45485a71bfcbe497eeaa2939c53b239241c01e385025af960df0387a9f26b124ba8d4088e761c7eb23edc7f3a34e867315d06bc573d217ad6bc6d5314a66fd356c7fbdc7e08a842c212c79041e6d051c8bce613f8af7ef7cf2645e440e6ef681d2e3a672be8fd000c1305e5c14e284e0c33e6ac6724779325ad4fc43366297f1dae393adde4b354d5c6ab89b41d92b075adc54b424f912b66f242f272821f3bab9899f2591ae408e8e9a5c1588c7785ae9c8c48bc78d61ab5e46831f5efe6893bbef7b43a0420528149771575bff836663521685c0bce910bcbff421396eec22395887dc0bdefe4656d27dd07e0b396b2a4247a37addaec22e582580f217133fd272c53e0d83e76354c83a064966c124948fd6a102b53388ac6b5f89298cdfe11d7915015f404f3e968dd485edc39d65313371a562aeaac5a63fac7646116529ba1b2cd7379bb9553ca0eb1505813d401637ba03e919551a7c0060e395d8390cec38f161d99efcf81920cbdf59964b273d1271e52c2622716c1ca02ad0ffa5c3e8c90254da5b05b8be6d0785420bfd44f704ffe581e3ba64f776c784a60f448745e2166a96c6816fdec7e137cbbaa41fde6adb2ec4e7d107fce509007aab3143b08f75cbd0eb03147e9aced0f55d2d67ef108f95857eb1d0e47c56063950f9bc91701c7ab9441cef2f8431441f78b710a577a69fa9abf236425f853c4ef6f9cab6438d43d67c8ccf8ab85b74796901514ca54649154136bf4054e6f568e397448f61b6975d8fe07d8eef4564efe5a669e96502c740408fa7b9305756523e4532782cbde116f518f4f7a7b0ee3007e1b07bc8e6d35373531d51ecfe3839fe0bab74db5564876189c3a0dfa69011dd80975abf56d60e20f8305ff8082bede93585b5e414a32358b39595ac87f80e7985f95ef69ac043349be7f65f76a2ad82241da8ff3708670964446b1a8c2e8320698d825964dbf8943ce0f2d14f31c0be6264a0e17abe5d870d13daa2f24cd48034abfb19f5088a9cbe76a89be946823cc04f60194529506c31879fa93a54952e21062253783834c22d0b28e629dd49b161ae8b5e0a7defa079197e0a6c38656063ed6f80fbe7f3f49065a995ce37506b63cf6e012170c125ef0efaa9bb984e4edcdca8ae02d5093b6d1d6a895bf24f19b6819629bb7304ab06f0bf2259ad9e77c8044f3fe0dc4d550ca69bf5ba25d998239440541798abf98e5f9ce39d91df90174840d58b3f2ad6402bc39cf23fc1bb64e29437d9daf30c24e5e25af78f9cc1152a7b6c18a9795ba0648666cc2296fd374a2e470591addd0e1cb6f92d20b154e5e99c3cc1c44af1241c4aa553f8f0d4083bfc4bf43ae9e934dc747e7fa8366fe177877af79a01ef06ef9a68e10cd39a546c83a32ce4019466bcfcab9cc9ea3322e624ae3b1a22b92d37887ae827285d6466ef6545bc647e205348b6b034d1dbd8c88f945dee977630024a7c66e53b155be322bb37b63f9c4223b88fae046a2bf293de8074e9637189e3279571c420a1e08f9e4d9ad62bf238a3f66dd05e816857fb9ca2a999b36efc8b841300bf4d17fddf61e570f0dee4e08bc9fd24ae38baa912d60fd588a2fb369531e07089d963a6c39145385183efe40f80f452643776607eda5a5aaa271748b0013039e005e3cad2efd9f34f982b9658a82e08dac1ea42798758519b46ae30d61c8d3814d33a44007473f53274cd21ab7018831944d86997ae3e2b837077a51fdc09156d37d80516a0079972e2285bee143fc08423ff2881f4943db4089b8e3be1636a6dbdaf53a3e970a174a77b4e83d6d3cc1222d7f5a14984405f6c3da8007304819ac399be1db65b69446cf9497ed88f7b147e8b87122d7041c5991c838ab04505e3408202d20fbff07f3808e05b380128e7ad1cd5a3896d333289cedbcb5698cbd424287ba57be9a9616c56feec179dbb75c5f808343a818bf462845111e003cac036b9b03f595d17c5e2a4ba6ad73d690ce2b4f2916543bc24025b600db19041231d56c612c07ed979dbd58f89f47e569b20a0e7175c02c142a39a885a1a36060c428cc01346723bf44681c35e12fe3847d779ba02e58e409a133b9e49839ef5ee32b821f13118466f1df2ac3e0af72d41ef764b5e9811ba55ae4d80152c403507fbe8269835742e5e191460bc995e7b4e9e75d2d0bc7360eff20006aa2812629c0379a4c2b68ce58b8393a7fe385ecb3bb1c49524a733b13f13a818e1cd7c642869f39150d8afc7adb299dbb834747d6c5400cc4095835a545f21d0d69191f240afb30fbc359e236134b27660591e660bf2aec91a8a2080258323b568fa35809f9570a679327ea6d19ff511eec15db1a4ee5fe7091c78dc78755e255a327467c032859b708957784f9d11854ac0233ab92e7627d6bbdb8dc60d3112fb87985944ec4fb5db6da31db69ae9a324de194ef7078845a60840cf0145e796b7a3905b15a943b98898cf9e7c7ce978081ee1d8d6cb26c6465460079f3afcbd67ee77810a87955e35e8b0aadcf09bc1298f650cb1cfa6db225d2cfdfed14c8d4690c5895f1a9745f61e53842bac5efaed1feab1853c94436d42c33f981c438cb80ff061768e8e039087ae74f5c16ebe4006761dc30471645df42297cea87dc36f91b44070398177c9befe49e15c8f4c8a3582a0368bf21c3054f83c27187bf593545ab36618af01ba1da267b6e6633b61c70128e05852c7db78d25889c5f97ad401828ebdb8ed1e7836a8313dc5a4ab563b11b0b4eaf84d9e08857178f1ed2e7db2e3967ad7112925e2f4b93a9b8ef8657008d79e90557c677e804810ca3afaa4b3ab99244af8c1cd62078f223a759e3ed3a10b45bd06daa75194df7b56960467ddeef4c4c8fdc43f4e46467d3219e07327bd742e328155cea343eb12b2bc30c53792a9d07faaaa997d76fea497184f47e43188a56478dbd7efcdd8f9e22a4a58494fa02031ed7b6e4f01d6a195f1cbd150860e3549b19272685b2d2d37c538e18e8040238de4e72b5cd157df4d3ddc3aa751c2b7298c8665ce3ba853e3a8e29bfc3891696fa98eaf12c699631293282dfe3a558e7153df69ee9e9203c99811cd40da6b366f0c9d0a3eb37f6cdfeb218336c204f4d3c4e52939f8aeb83ba4045ab86ca7ed57569ff2aee01638d56bbc952aef023e7ed06c5b1ae8969fdaddea2d55ac24359b397212423835ddae8dfac1ef6cf85ae076102e2b9eb578afa850f189a20254a18b07dbc780c5d1900f52cb19012ebc30b17e25a323ffe40c477edf7b7242fd98b236d4ee3d13b6d225677cd5ff385ecd62c3e129e0eea8e287b8c6998b63e2255d980b20a61efcee3a2c4072e25e4e61f84d349934cbc9716538a364d2f959f9cac1969327d5b802d4961ffbc07c821ad75015f04e94471e550077795caa2a5eef1553d9b160ba9d451c6cd22ca964cb100bc978714761afafa011171805b3eb3c5f5003c894bf8f274ba5561eae049d63483dee1401b7219ff666379e8613171eeedcc7ea97981f3d2e872346192ce3a15857028697c0e0d984d1e15e5a5a56c7b60a99d2ab62940c143a6903bedc1626144fa108d90f7237a8974ff28501f40dce83fa46a1c14724b7d5d8aac8149e08dc54db9c2631965e7e16a29546d3745c21785cc95039245be2dee24c6f4c9519771b2e459c330707a8b2da9029447605ff2ae685f57abd664ffa9e5f27c14dd51450c5e9036e1f6399b968c23585886e8c2875914bedc86d974124eb4d2f08e9909ccb6923e5ae71bfb4db1df7383978bac5b53dbc35c6a20e1b21fa58d9cc472185a4bcfce32937065f39a5c02ba18fbf36b908916922569b5a40db49d0d249690c6733d5c1f84d16fd0ee8a5c3e90d2f7e6a6a42e3e510d723bf0954f5a00eea25917f8da7e531f74938887a8c97d0010ce8ebfdc380b58233b623f07b75d495b5c7e4719182b60940da7bbf0bcc102ffb76c19425499d83ad1c686eb330cb7eea8f886350de1095bcf8c8bf459f57ff280b803a0010e989bbaf3a30fdb8847ce1c483581ca977799e102496f1b4f934b9cb205ca507ac9721d545bb8e13992b2abdaa80984058ff1a4adef9ccd8437742683902864d185da89f5e86d1604aa1121b6bf3cc9b9fbfec2237d42ada091cf738c95607492659385cb11e2e8516439d5dd65ffd1cc5d08264201c796555abfff19b5f9082fa9d71ae5bf6142247fd9c65ea532b0752e1d052cb553f1d5b93ccd74519086b4aabdc9319e9c14b6ddf158c46a69f04906150de82d527d0fe3090de1bda55c7b694a0cc6bb08f4a232a9c627e3abe9d0a444fff4525601f5b0d02ceb85e9b15f572281b35fdaf5188e86bc3f8b141ac58626caf863ecf54e0b0470f634b9ec83934a1542d11e5b343a1b8c05227140d008cb59bdac8c90e752048949be8a78f57fcf482a1e61bc9968ee5972bf05e23985657dcc82373f0bdc09c60d822d83509db614fbe39b84d7171ec312db5dc9bef1c6a32142b994d9b3c2a996a44d706cf44422d6d1ce6f1ff1258118bd8cd83f10896b5b9d9ffa0d2717db822f3bf9b45166730d849b74d457aaa36e1fa970fec9144d618c7c74bcc6fc676d0adb05a507b3abb85eefee83e6215c4b45ac6955e04e02c9c0c4ff9a9884328a95e5476becbbb0f463a410cd8dab1db38c3d06681f43f209101462b7a68f6a56c9fe73b22b8d89cbaadeba87c932f7b86f92c2029ac3f0be3458c392334cfcc931d16c11800af01fb346950024b61922adc6b19f2417e8450b18f1b23baf75c2bdc81b37d0980d068fa07bb85f7a70edf89f7abfefccba52a18d931e99f04139464e5e15e1472244d538769dc0c4ff77262da7cc365cd9332a290b038ef8cf3db9750bdbb599c730f067ad1ea08b9457096660f5a9c55b67246b6898a61fd1a4b747a664bdac373ded07bb79810430644dcbdc1979ca97139b6f200a69371ecfa70f38dd835513964e92a96d725be304bb09674f4d622aaa41ad4983d101ca331ec3db7245e0933fae87ccd0eb39cafe2a39e811a9e2b1ada8595519ebcea570811a5e0fd9b970c4a7a60eadb6dba447df706573a11c4e8cc778d4227d3b5aea8d49cae7e6eda6e283cfec6213ba559612d73a6b94aae730e6e6b01fb00470c8ca3d8594b4b9813bb81db88d1cf1eae1bcc1848b622d7869a07a747837545009277a9d75c0c6253e79321017374a1663d5fbdb05e6a7b87e7afb2cac37d96bb3486bf6f1d6502357c95198e3e426a565a6f415915e1127445ead91f2a4338cf27dda669584f86846481e57a497a445c1ade3189ef721292d6a23cccf8e68fdbae0f0121abff0f3ee7cc49a6a1108fc02b3cc64fc03888796add554359f89e504227297d4dbc9875d8edba2d8a6d64a3ca50adbb3e4ce0e3d773bdfef55af747a9246fa54d6ee8de59eab2a3f98801232fa29baa8116cccd0cf132595998dc59134257459ecddc0e4f35c90e337d77efde29a9836a70353bf271746511f14bfe0d7daa084a312b1117f02c0410e6e6810f0532d2e62fc0d4de43cf87124ae129920239ed09583831fb466d15b1ecbd5952d85c345272293b8a00fb09ad8a4d6370e7b95bb38e30c18bfd3ef7939690f2f96285ea53c1451920482bf9154b67b63ec635141c36d626e9be1cd047dc49a99e42d2b8ccc8ef9b3355f96f7e3d008c4f547c9334a0a4cdbd759bfae81e9eb16b57437c2fb84c98311f23172500e7d17c3a5a4f97531f397c69b5f8a498762f9e092362a403954fa6effc1d72df946cb71416b45215e1ce9227639696ff1d612c6c7ccafdc0aeed22e67fbde71e328ef44f410885410b5363e7134a15071d19376a1a755dbd29257a2a18496549e7ebb1bbde7d1aae08d3ba6f34265c2204bb09329a0af8d738e0011eda27d6ce2e43f358d849633f5b5f43ee240d8b4193eb2926d2a44c368027d0afcd65763d9d74da95dfad186a4c541fdae1d068efa706562e0ed396a519d94ebd616a775dc79e327d44d19897adc1ecff6a230843d2797fb63616aafca0f216368b1e200f01ca195cf5457739e5fa0df8352314af52caf81ce2bbbfb2e1ba94b7b6c2c8e95066ef6c1eb532b2dd93f5ddd195bcb06538036c46248bcde957b9c29511d7f1da5c180732b7cce337f5d5228be2985743d2e69fe1dfbb1ea23062f69edb4c4e597694a3a426402027b2279085f7151bd45969b1dd2128b2f0bc5483d9d752ddf87252b7c5bc6025b1bb36d54d48eea831a8d822b89a78237e01e78e7114847ba537a7c07c3ef5843b597850894f4e4409b129b2586033105761995dfd90585f06937488d791a5fb4e2726f890a06edc38ea0187d4cdbf4fac3777f8af","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
