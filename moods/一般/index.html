<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"046e5f622def3d7514d0a23e770f4a5b94935d90a26f6287cfd3d9f93c65b8debf39168402945986cc2748692300bdcc4fb6c098a58c5f57e8cdb4ef9d979832e68560a95a80ceae03b2d28a56f68d9fb83afb508e15b6209e701d9b3dca93c3d10cbd33060a86a5161d4f1f1a953aa5834af6247f298d0e4d4e00ba9ea4c911673c94bdb5019f9db7c6da709ed1851a504ec4da4303ac79217fa62073e4f1d82821c8e64f2de5b8eb0e14f0c5cfba1f1839f43186981dddc9a1904fb6ed3c70b842ed745f38ec6259e5348c7b069a06ba15258dc7c5b11afad84dd618b9cb240fa0827be48a93ac794713b66068aafbe9462f2dbff830a92efac20c0462a1a15f4584ad31eee5f60607ea9095faf19e1c778e9405fc8489b4d2a036da15e67fb27924c403115ae392020ea762c927f0b6796272ed242386d7a9b77f29c3920433aeae8c4db2556ecb1597107129970c7eccba9c694697acba29dfba82bddc5af24d86aff7fa0533190757a4056a64ace671af18c8ea895b5c120b2923e3d7ad20ed2ff0b99adfca6010881f722dc5bcdd5705c29ff41ae305144471916233ce0b5c655704187664da71be07c885242227b3fa6d6c2676f116ab778986161ecf7de45caa8a5527ab2c07a49fe6610ffb91c4bfdbffdbea22f5a9ea67dcd972ca1bfb09b13f7b11dcd1b11e5273f1ed1c134dea201cf08bd8f3a7bbea3c6d1681a13e752435822727397c24755a5492caa7ff30f71e98ee1bbbea11f4fb9440b7ea421592e27dec9aedcb91dac3e6a19fdc213d7291e0331c7b5cc6527005982084b306d5a541bf6fee33987501d6df10b6358b5e5494a915992eb3944d241f1ee265208e26fba085f8ee51a59125be24fe22012b0f1da3f1494a71b6f08dedede9cc22c8f7ed045d86c6b642c9fe6dc3b283649566a22dc5b090f986d0af24c800ddec467f0e580d026a5e4885eb5d4319d2ff5f59c0a2d03c5566d804fe0a6c125bc9ee3e81afe1cfaa31a35c79ca4350dfd1afe42199629bf33f47a2b3b2cfe3f4a3c18ba831232c1e18a3ef92723f08df9ce17ca807e91b7a180340784eb9e6c03be9b10a2dd15907344b0a7444aee25b89901d5498e8f5c9b8a8c2a37a9b3006719c60a1f0f4949050db1de893ad4a99f59c88ee03c305e21ce8fb4b849fa80f6a23ccf91ec1a92daa28b114cf0cf704be45cd8655a612324c643442ca127d66deaebc015ae1404be4242fdf03761e078346d05359509f4aca55c44fa5259ed07b18b706460d1b5d770ad9d72baba3f163e27f931040d6d8a8ea71e03887b66112f4c86d3d694158e9aa72576ca3c25348e8e3d14dd3513e1c872fd191f65326718a7c1fcfcf4c3aca3ac7f727da74d6f006d39416a4c99cf2a8cf51882ba5215c26b0deb9afa1aeb324b4a27d7f2e123736393b92a39f452c2d991ddffc5e448bf0484ae85a0276b03e0a3c574c1da7b14515dab7c388d233a379f5f89e79437cf04e9c67e909e9c44c780fedd4128c669c1ee50957c8ba9a0ad2fc5b17676fda3d63e1007e80fad47f39426092d12b70d42a85eeaa5a9750090b2b7b77e519216877916551258c748464ee448eccd1c6937ed9bae5ed7fc7ab8a120aff00d92e5d698dc5a4c0ea73795a65fa87090f89251823ec16cc89924cf27bcb33df2bdff9f12664ad342a0eb5c4380fd6003cf5ab972d9c1bc3dfa80391d3903c47efe13036bb208bc9ddc74aa997fb70c3951360e7645833bac069fc1530f22a65372dcce5a2f4fb221655eda013850a77dc245792bab7efcedecb039d47f04120c0fd5e4e4405e063096ec71345f5eeee079d82980e7dee327f34ed1eba06eed7fa99a0e57a59d3dfc193f687832e83359b3fc79ea71ec35ef475ee91ca045ad4e431ef9585355bd28cc8d8a285a5ae4b5320364a1cc46a6a11d130537048e2bb25cad511c237edb0736201920c312b30a2189bb6fbf936e219174fc80798b748b204631024e6ef4882cab31bd36d959f4d52f54aaa7bbd66135459ec0fe53665c73b29b274171604cfc5081d1928d65c1e9aebc85b43c69bc12a8f23f828045dff0cf1263f35586ee74481314fb11a6316f39c002f8a3bdf8ce3d76405ef247e8118cf9358eca02b5ef81d051b18722a5798f758df07237ab7cb5245bbf70aab682da53c4bbbcd3e7769705fd60f7b7a8b793941b137d751119b20eef781973e90d174403586a5659716a6265c2ded355469f5a62bf6328cdce7e21f6a58330687c08c87e98eb8a1375927c8967ce4fbb2a4fe6bea03994d31be0cd3208768077d576202b9c35a04a99211dbfd95879a56a27300ef6aa30b8f9ad103a55be74ae75bf5d54ff4a858a394d65c2ce9ea70e59ab4ccb44f57825c6c80fe640c9b5273dea947ea05faafe901a4236ef09a115f507c90145bdbcc9d3e9f93a942b3c0f5322f56c4bf8d7e03d86de8a5e7e94a75b64bfaa45f0aaad7412d96ecf079fe7e6a390c19f5f96c4668d18e29d779659fb14523f066fc84fe65196f18bb0993d3d36224f27e379317220aae44b913bef401b3eb21edf749fe38df59cd2573456c15e864c480fa59709c033206f62c323dd3033cc8d1e3793e391399f585387b8f98c3813cfbdfa0b1dec2c5a628997fac9f202390847c9a6ff9d7d63eb3decf029ef2a67ab5b6046122e3e10c362ba9f6961f6534ff686793970ca9053fb3fc6102329ce227d510fa164c8b5a717bd6ad3edd0f8a039fb58e627d60bb1bca5583c07ed89c361e1f555b4f6f794e5c4888b5f0ba17bc4c3ee981a006f412be22b0982e8153689462ab7589fc9c677d8668493f717cfcc1097b87ce6e60b11b0d80b8336eed07dbd5723aed0e2b1807129b86b0eafcbc1221ce00a3622bbbebf2b07db2bbf892144d9959ed0e74a5ceb1e31d5b4880728f8853e3e1e17464e403d9948dfe39e2677d30a487c0607713d64fefbc94fe121e80b17a5ae09d6822cab5c93cae686aeb1ad856a86cb7e29a7866d93ed8a45dbb055ac887bca3934d6e5ff5f0c237efdd5b41589a17e2d2831084e1fff4ca388de6ea6e42b1501b9d1cc04849a51191d3c91fdb819cda53876a80119485fda8cbe98c1b3c3b3e93c33283c7f21bc1da512e5e11a9eb5a9ab593db8df0a7bd254903555959e34ba5300d0b1164b19b5524f3559ca01da788fcf2cb8681910148f8f3567a9a74aec84ef57c0dbf05468ce86ecd1a1d2f6fa73c8e13fed4986518d6eef4d12b65780fbb902a1d20e144da82d2071a39e21f07879af96026a75704cfd2e92d63d0c7db9a0fc514e955ad06706660fec6381993766e250089706219fceaac6f309991702db212720c3c49f00f2c64864927b2fb9a818590ae2387ba2cbd72669958d6771fc7be63f976fd475efc788654f07bfacef9d74b5a177d4a004a5c74225393b7bc9301aca23a6951540d23a5da87df9bc0f629f9ec6412dadfde738314d10e4dbd2ecb4a5c28effd1fe61cf52eb8ceca4ca1f32fdaa3dfd38311d42a43ff21e55d3260031f5210674ea5bc867197b755f781434809ce824eb9f00a45b50e271d03cb8bc62fb5f0edb09a4ada8213855c6c05a41f762ba91a1fbdc74e9d6170fd79db3d6555b37a24cd95e56490623daad3d9ee710b03b8498391cf432240413faecc1c340d0f84ae58c3301819ca186151da367d1b1358711a31f70509f55785eb0546cb5282a8ea0c9d2bceaf4ace549703a504d1e1c1e86ef96ac458f9b90ff2a4d6465fd26e232371357714612393780bb2385df77b3ee8c4aa1e4c0c8cf9cfb3b578b5e4e6987b3beb0b7c7468d9d8bc886b3bc045b812a6b162d3ca30b401846c61eb393efacc9a17878900978fb5f9f5f75e2b514f908a62ed14b598071f5f741ce3356f91918e7f29e8be91980dcd502e418f2349d388356e057b10e8de65869cc9373d3c731443311880183e28241fe487fa94fc93127366a3548f1c3fb3fc475cb0264f26bf075fbf2c4ccb2bd7347ce5bfc83d1836606172346589038a67cbe45a5dad61e926861241ae6f20e61017b2a05c30b2cfe5d9f6db26f53c5eadcb0739173029f20ae7d4850c6f6c584154b2dd84e9e7637d3737e2ffc7861f99b8f8d64146c4d3f536b738149aa56f97eefca10cec5a3d60552479b41ed9055b470117747ace5ce8f1d0ba51cb098839d670f9b7b769a2f950feb7ab02c2cac711c5a39120054e05c5287dfd7e55f62ac694b6f41326240a9a4f463871bc8ddc9f8bba53b447d1ee7eb5e1131d4e8099649978369bfc8bd7964920decb52e7fb8a823b39f3b2ba40a763506da0a0c1ef61fb7b72ca47685bd25ee43c78d026843a1953a16cd2c031522e910ad5891d16cc736afaddb85b67662cc6fab3515cad7b58867d04b1bc0701d1b0d681aedb5e9747e7842d7350312fc5f43f7113978a0f921e90b838355ba23a62a62be5822c1cd79f8607da5253eda3bfd53e28d3ee32d351218ef093a96350864daa0772e5377e855464a1d80ced28379f077ddc2fb89b70c5dc2dcca77d633fb3d0a5897998aebb76d73c25b53ba8a88cb7a7e0f6b9d8a307c937c6c207d3bc72c4d2599de8017d38f427a2d5f759e398c109dac1032c2bd0b80d48e5a5d224b5a8694fb0c7dc32b07b0bc3bb31ea8270f83a6b05b366a29885db1077c3a0c40b76db77a69e714a0b1407b4379ad39314b3aae14258129287d635cdc789e133a3a1acc190073417991d4beaf90518c086373809ae069b80c89bbafaad725bf1e10a911114bb50bb96d972b3f19be6eb80603f215ac5b7148bd520a2b20143ddd3a6943e98cfebeac57106268ff6d969e52810510703d24863a30a9b2e0d2a3027f1c12ebd856e6ffaad974aa37cf365d3da586aecc05782b6b8a2d75a3a7315a9a7b2239e5af06391b385fbc27e0877386d44cabff686b6c38561eaa5bb02e9d93f744c6b3563d858f9a528d4b05dd7f2cb3a6584ec3ce596a3b58aea8c62dc09f6f5b522e9647bea625c8fda4e69d9754a966faaa433b0f4a62c5e5dbd06fd418bd626954882241274c54594f2206d51a76daa674fd361674b409622f70a74d8560e936db2799bc516787d02eae1510751fc8a3c6578f74383ff28f58e0c8067b0086f7c6d00c1c1daab81f1289e2c0bdf8a46b7075cde51883094033a468281408c019f147e81af384c014c3c3123ba0ec8bcf565f5d4e12d9163c5a49d81dd80b3199769fac2e842af0a3217aa4236f3522c133e9ac6acff82928aa75ea0b9e1c5197a81a8cf37976a613e45f2f300f0e893a16d4d2f58c2a40117401ebaa37ec8cb2f511857bd47b382ef8f98d1b4f110ba18121d72979a4f17b72aecba36dce29605525767d7f06d66cdfeea1fb7364a1c2823368adc926dcc6ba329c9924ea49d35a8061fbd03338e02e5b1ededb6f7344b9f58a3d599bb7198024c769b7c39a2b97526270fc085b3ad3bcc5805a55d2716d8d936bff2fb646558d4e86a94344ed6c755c8590b494ab43237d3521f4c59dd5c748f4222fc597e52f51e7e798f05404d42a81d92372adc80a2fdecdfc70fae756c3f42c3e07522ebd869e1c5c4f7409d6ed81f33a0f542fece3799cd4085d92b7c26ec49d699479913372325bcefb04f570aa68d003ab316444880a91be13151e8de3399067eb3803c12a40488a983fc375d1895ef2f96e585b1177f002012324445c2c8714e6618f8b5f53c2dcff8db0ec4173e1036eea221d7e67730461934daf70c37cbbfe5b172af32e1f17997485c612d256dbd3aeba2ae1886b80fed0e4a4b8cd8da8a3378b6c301301383ec28e54bb03a33723008141eb6c0176059a3a23fbda5ee6b7368e5660499fe684f969532ef93caca7266caa8da20a64a7f9db2009d85efe5c019ba035ed171f9801f03c5454a1901384617d6fa065323966e0fd194debf2265e2603fde7f18fd9bce31904371ab387ee82834c90f22c35deb43c8ee37513cfa8c7da13afa7b070f1301342accdf97b025e1fa2d432e00c5df1b3f4d6ab5b1a551737d0140dba94c5ec6d8ccf0895a3a1f1480e3f556f00d072bcc7b39e394706713f75be05ca5a3575bfd744444e32436100650e3df64a81fdf0991be11f9af5b66f4d42fe4c1ae83e339d93c6e83d72291052f08dca8dde13219cbc1a022ac69d5c653bc2eafe44775f6c40cf3a64d42dc0b2211773ccf6d68118716d7bded26415b3aac3c18ff310e66866bc54c8ae8e39612f44919ec90a97fffd77776599eb0b81d9fcdb6ae918535d699b3e11208827e34c2be6574ee48189dbb67a1b45e7344cfeb397bf092f378a886e26780069d6dd22e0d9e894a9793e028c205614743152d9a66ba8fbd248832b37177039b987ad4afc79a103a4f8342189ed26eac721b7bc2362836750e6ccf0374a2b266b30e7514498a20b982c59c594b85aa0cc22915802258daf0ecc6bf91d8731e1bd92064a36af917c50a83f0b9e5e32c9a1a6e5b4dccecac10535619467ec9426d5c9700c1649688bf10fe36e0f69402b7df901692b3aac846bc53de26daebbac257e4c28469effcbe0a5032342fa47c8e7ef7e0a91ab2ddf7d6cd94a1e1493c8488c34680b3faa15621848c02ed71a3f21c64063023aa317a8a0854e24db8bb3983463374bef9af5bd493610f9a4c21dc489b280e20d9e683acb46b8965c54874d3a6c4c13e4788e7e9d768f84c6b4e5918331576decf1a2165da8d16ee00eab09f226f24a17ac46b927d10534d7379614124657cf1de8346e6d5d24f8af95d99418ec8f8f0d659bac87b061333caf433273fd1379f4b138e1512f3fa17951527d825cb767f7fa8005aded1f8cb810c724b618b5278673be4dd3a2d6451c450a6b739f85c3d33f6755b964c68f0b339238af082081fdfda0a2eef58cae8a43f2ecd1ef9e8afd78f63b5b2735ae1cdd6aab9700ff931914465866bb8e134c97de80b893722ac6cfe23602bc464fd47e94f8b1d54d9d6c68d8886c20ab04c4a7e2a7b90e5c6efe49c94a63f2bf068d756af37e51b02f1335affb830e12eab830e8a188803e4ac1d6078b2915437b3008966891dbc8b8aa36c3e5413ca0815b7058f27010ddcb8c361d769f7a11731a8240b2b5e84156fdbed236391af35cf58a93ff9d2fedd6562cf41da9aa6fdee5a850d23d45f63b48d5855dd6e74983fd513a8fa8c7835cff668b1aa0e192b8392aaca36ff23e09f523b3b1752e44c0f47189e59223d05b51b5e66d990852047f9fd840e9699c066bc184ed2088f21cf8189d94cbef646222f6ca9fe957953520f11e7dd65a84ced7f72c2aec0b9732f7a70f7818fb912bb1eaf0749f1bccf69d5e8480d3580784177e5c059d3b612c6271335138a82f055543ff76624200bcf028478e1c3662424374e49be1b45755e6fa4fa830ee6c1b6798e572080a7041e0ad3ce2ac5fdc90cf3a440e478e623fd042b1a539160ff8a0e99d5123414010e9cc75d1da90de32fe984b929aebcd52569b9772932ff7fb30b1a77da133a066194837e6b3eb230f41fce64a0255924d1838d945e5d278a02b6655bbe9c449241290a95dcbc8412e7aac977970b6e4ec22d9171628b0cae796940f285b68d994aa5b01f99dd0bc541ee5ba1a099f85e2ddfb38a701f7c135fb99ca81344330cba65a0bb9f116c16a7a591e1409fd46f7561711b974476e6cd66e7cab4fafb3897e6ad1083bc5c381311bb7603070118f941f690cee1abae01d17867710dc33f724e84edbd1814271ea2f2c610a34fd89c9bbf7c4ebdad628c7f2942e45cd1c3194f2eca1b5b6a2c4ab215433247aa33838b2c5333f6187be20c2d07e9b9f9716514613daa84b9cdadd0c3d1ad123e298806e0c2b7b0ca05541f48f066ecf517ab5f26ad655dce425a73e7af5ec81da88cfc072af64ff67965f7b2e1da060491a2128d0516fcd388e4e1fa89326afc8dcb87d5fe687afe2669eadb812adaed6b0136d386f306a64dc9a619cc0bcca16a204e8025c22fd7680d449b67bfc6f6e4b4e7dac2c6faeab55ed5c87af6037f8e83c0a09102bfed9d2b39b43ff9ee528eb2bae24b4bb3ddfb21f65ac096b47bb165d0000f84716933adbab93dfc2539903524e9e5142a33cdb0d61f7c7d8a60cfc82092d56d8d6e7b36b2db603273a2173d005f2dbdbdbc52bc575f6bb62bd663180e8f4e64db9a556a49ca06e856821e3d91313893898499d410339691c808e4bf55978178b4d9c9894f46d219376cad79c130b40fa86572bf7d88f1cd88cb52633925a2ecec2e2acbc39852d4f473a882570345296eaef1c6877e5124b1dc1f7347a80d57afda1215b432ec9ca0706ca64bd38e6bfc36f705ccafd6b5f453cca28c1957f3f4fe94e149b9901dae2016fdb9aaec94cdc9dc363291ce81ff92bd499c4e19976b70d5f1062ae5e0d3228c1bb7287356b3bd742a1dfea3eb878214a55c8cc29b93534a594f7a91876c53923253a2e9dda16e55316dcda57e4a162ceb464c7134a4a40e33787de930fe49e60aba45ef9024138699254113b8282294392656387528bb32c1564c86177e616097e9b1eb19f28b016644824d3b6678e4f842215eb970bfcb37b4d62330229f62f15cd5bfa6e16279c6d5cdc0969f1f4b805e5d42fbd135a33f35ed637132236462c5ccd205e8b80dc4a6d3c2569149efb13534b716bace868f841e06bca970d9710f3eb4c3cedb8144f6d9dad93dd13bc51575ae4be5791987b7a2ff7b578dd4b7fb358775d7456b9e598079b1e2fd46c2c33561450cb78aae6c1561435bac4d3310511a6fbdb038b586d30224d8c694f308ab0013b6510e683801eb3882efc7c9caad4835a91307f438ba289024f0d9025b7cae7b62d5c906f598db0c1a4619bab7da426a7a6905e12adabe2672ad5c3e49f5575bc77e17166f231a3d387d378cac87bf4c6b2c358a1528f0cbead1b6b760174efb8fc0529831b1255a7febc3d9181bd21521a87aa859c4011096797d217d39deca2e430476972504419ce699c82514b8351c911114912a89d47b693016e22824b76c443719ad9530e0ebb6c30f81172c9b1c253fc7c486fd2775841f09edbe3509578c95869e9734f261ceeb1f21cb8651ae818b5cb02a36787baa75ea0b66eeb5002a6cb05ae0b8607e868a2ac59690a5a928fcca1a6cc384d092d704c2e3ece02490d93b120b325856e671b01cc50a68a803cf9f7746d340c9fb1613375d2f8041d5d66f4b4b92e5389aece911f7f69da9be9491203aeb17684277880ce953b416c055d19874c2a9bb33adb8214381b7943d3dc65ca4232ad0e20495afb09c8366dfb351b3ca471023d5bfe637cc4f1bc0b8df7ab90e5d6e9ca4a09dcc44ddf81f500d323f45bda3664bc921540894e68a232d748043818c79cd2d4fda0273308dbe996c55d1c8b93e4478b3f65d84bc691db8d1087afa297eda775af3239e94e19de424d24a8057765c1724af05188062693657e68e3467867b41b12e25035124c9fd59a4fea68b4d1c2ab880a295ab037a7760f8faf42e80cf0caa2f92da5429b646b3011fb50d32b5e526d4030d1a3f4c7a1290e64f8860fd74d6f4e75085df3eb0402c94e094c8558e576680494b61059d54e6b4a74e4316957547afcd4a8fe322355af0ca88f56323ffc2cd93244d182795a5e3a9e914a5bcca1019c15227a611bcf0f16562277c652479dcd73a4fbf6613a75ce5f283329d2345f9f4438b920c4f0680da7cf53487c0e4ed4e91dd32075ca64fda4a77c67a2df74bd9fcb3ffcdb33cf9bf269d3bfd72de7db3e1a6a20480cc5cf50136c0057fd7b32381a0eb3c257d9719f20a0652a8bac5e9d602fa3faa70576595cf013caa6f12b40b65181cae933f9b084ab4595ed5192178f2c4551cf0fe188c04b27f27a8ddb4325908240024f7362a92f5fee6a8eab220c302c2c08630ab172faba2cde21642ad3bed1b17602e3ccf76d6df9909b8ee57d7dc0c5ab7b7cf9f7dbe576313294d496511ad1a0ad4326c082d23ca8752cbadda482822edaec3e78f318310b2d01ac91d85fca5a30ac6b33f00b2cbd7d1b3f204cf2b2bd4e4823e61a1740fca2f9544012542e0115b6a5345d69211d818d26dcc1e3dc8471716bc4ed2cc7ac3c9271546f0e8b3ed5381a4c0f636d71d40d36f61746e097c4ee5f6f8b0449bc670c68b4cea9d908e6af6799f95d9c5e4bceb6e79441c11c61c0ba7da531ede1e7a7e3bc5e2a4aa4ad40847dbc3d6af0d45d421dee96a53383bacf154eb6448bb72cb15fe20bf9dea8a32da30f5cbf20c103f2874f4b01d9bd706d64bf0e41fd3301465b6e5e7dbce9817ef5e1252962ffaaeb50f381efac75ec5650dbd7500ae63d5744a77f856794ea66f7cbd00a20eeae3f8dc98154c0a39eb5413cc002f8cd45d4fb406fb443a069d9c25be870208244b9f6e23ce92f277965760fe06696b6945eea6e09f769a5d61664aa2a781b53e461e68610ab06a5082aa9812ba5f5c51511211d74e981be93fbd112ab910a50257bd26578b732b4ebec3de92986da1011372f72e2bb557a7cb34b2e92732412d33e617ef58d72e3f8f957bf5a6839776403d20cde09480574fd34b32271547d13da81bc87f94803e373ab92af8070e606dbc28ed41509bb7bc3663de656fa97c235a3c02f4a9457296a98dddced1ca4be52394f76d2c25cdbc109043378172f62178ec7be02b8d0d51e26509f594e534bc0248ac9c024a1724a6a00f02075f2ca119899728499136a6cf013446f1bc546afa6a0492f3a79dd118b37ba9b810d5ac1cf3fc4bf7fbb9c67f150f64b1b3413ce3b5fddcd1229e5fd86e03180e1ea1a7e46ca1b11ccb43b9ae487d29a85707d2b83545a1035640eedd196669b02c11932853d098e6c74751a4137448aa81dc99a3387651e746e2b2b26adc03e044a8785f3c800a7c43df15f682673eff9a10254da2cf35e20041611e687d386d88f25760ae58c4cca3a758733f20678b362a4b82e5ceec808c3953a4ba66f28a0f19ee287dc7e6a88c3ada17042733469d04da9f4645a167f2ff066dc5acc5addb6af096d47ca39793fc4ae13c4d86b53d3338dc0c0efc335da5243d70effc2d9a3040946a0df9f2d910ba54896e0011ac7a2747cfc83ddcdfdc1339773faf3c7810a11ddefc9d4e3e629a2d083cc8f5e545d9671a96461562bf29723cafc65321be40a4a9c16c0a506ca92431c934eaa1582324ccd70a2fd9661ff73f7025c97e3ffc0c32eef2e8601fa08df8c661345e8203ee998a96c4d491565da7a75b353aae98f91415e7107e03a94ed72f9c9a2bd142b445953c8f4a4bdd6a9c1c913184a6ff1e67eb8071bdc01383320417f7e7d0b9ae8db87caf30ef5d1f6826fef7c108a27f78fd16b5e577f9a07b9fa7c19f9c1c6d39bc10c07d1b5d71198ffbbe67c57b497b5b3934002f94e3de566aad4078b480867e32549ec950b47dd6c94181b02fca8fe21dd80b869f7d6924a7cf3660fd602ae92d552e5994b3d7bfacd3488d01332deda8dc8c1324443119caeba54a59005019dcab79021d758567fdea9c73b7827c1b0c50adb867ad494ff89092905c7e2a90a581b083b857cce427342bf54552ed5d1f965d90bc9aa991e32e16654fd98305dc9b9fd260303086688732ed1d2c421a5216b221ae760694b0e98024d0de20642bcd894118568cb9dd0b9265d80707136bb54bb9dc3bc778ddca0399be451a4c56b1d0745cf018b912c51e083ed53ba2a2587016944e2293d28c53e322f39960ba7e78f6f60bebd5cf49c9646abd384226c986bcd12221730f65bb1b1f23f5843a6f5a80d7a0632ef23688b3a09dfcb4a3b1a46bd0115944480c0e5ebf22820a814f133b4bfea49c945fbc84b415255e363159df01d261e1ba012dc5572d84d7d81f8a2a719030301e88c83d52795c9a4104735e09ac614ec6dd68967e81385fe61af8ab2cf6c65b274e0f5e4a49070666e9b19ff07f66df46bf43f15d5d31f229eb324b0d9d8d05a87a5df8dd0d548baed2b5479406f89ee7dd2cf6b24b1e8e93a966be562fae47dcbfcd602a9c5cfd685966a3e9c1a0d6e3e0357038f0428a8a45256163eed37c6007a79c5f2b3b0e5a5254a6fc77843aed1e65521e6caebf28eb9f35409ae0d6f427ae7e8832a29b44dc","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
