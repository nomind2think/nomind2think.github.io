<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b90f602ad344a3eb801359b9fb61ae5640a0191c88a38184c7d6585f34182c51f3b40ec37e4464209e7742e32ca4c198475fefd1bcb7388233e66e3e39e5085d690fb891d5caaed21da90d9a956900667fda013efb79763a026c9fffbcff0455a3df27111e9cd9fea92ed8e8046af625787b72887d55fbb5e6714e836d166857126effee5d772ce3cc6ad6a97b8a91a9a866e37a18416459d76525fc763c0ead151000de286e2d6660b9491b01ffe1d7d1478b9c5f57ab1f90f8f9a09eee23063e0f6a60f50a49977df605ab920832a266b23562cb7925c09cbdb0cb958e2983e0a266183fc7b34abdfa74aadb9d1943f6b000a9d243f7ed48945b343fd432172a3d17cc0669412b070586b98a058996c51bafa29b7e1eee6bd21b8809469f432acec79de20a616d76dc72c46de3728ae0d32105d95e51c4e82d74332f69dc51e8d3113b4fd528a284be3fb2d73621c32e6ca9ba5498e082e8d6139d23a307b682a2448724114b93cd4c2e8556b0d159f4ab3e199d8fea303de0aa32d20b8b815676a93e5c8033ca1bbb398c88c2d35971b837fb73855d49faaf3ab9546553d03684dea8cbc52acbb11f43ffaa75bc1fb0400b01516917bd45bef30906382a362b380ce065175484ed1715bc184ebfe665c8fb2cf57e8fe54da23dd59b64f549d4f3d6c64b23654066af8ebc5c0448caa63ee6e664e16b0a46ffa55dc02797548da4470575b30086dd7f2e5e61299bb3d44839c644a473142285dee4d247e9e8fc441d3405020b83b345d842a767d25e6bd06b0dbf8c146f316d315d741556fb675937de19c6dd913e532ff07b1f711698c73fa23306dcc76bfa0c684c6233cd8b8f0aae920190f88fecf455923d4e64593fa122da4a85c9e18d58ff91b2b56064163f810df2b82bc12e83b80eff8f17e46c7bc7ccfea069f4172a6dfabd15db3327daa1da46c771e15326a44d8664b4fe224a5af762df80eea9a6bff706c099763cbef078fc8a6ca23ea336bad3027d870812935c91fe636e8eb4f95fa2d84a101c4c8cc8469e3191460b2d25e5e2c602321622c4382a2ccb15bc723f0623cff08ed3a6fbf13acfc95e4c840d69dc34ffa245bc6906a8d2903af2d8efd9bb0308d8fba41ac2a02b066eead687673ad47dc471dce8d3099e0a97e5a93d2c0b214fc0e4f5c496dde4bf78e60809e569bb7060c6f2ff7bfc63f06706ab68a86a16bee79f7b11ed5fd256e864018ac4d57892c9c29c9b84acc1cca7f63f4915825bf5f62d9c8ff4d518a607d69abe059118d89f02700ea569e66329bbdc4637c789d6fe151e15b42239dc4bb95859d6b07547027ebdeb3de8f43da975cc5252dcaae860ad15b98f164ff90a758f9ddf11b5fd587841f77da2cc37332b5d81782a9c55067a7e67c233d50773ac32278738c0ac513cdb0096d23d847f2bb636c10a43ccd92daad224a715367ee5cc65c1c0297bfb3af329394f743445023fee5243a08efb7d3bd3079809cb7fbd96c502b8b8cde88342372bda70ad453b1832d92bdd6a2fd0c000c9592f2966727552fe52386750d8bcffd8c97de2dbee3ca5d441b10c22e10509363cb65c00e5911b9d8e717589dfa64c196a41594a02afc7a62bafe9fe3b1c5f6dfe6b6c18ebd94d62544f85ab079e1ddb770274ebdc7287510815019824411ebe1e05648403f7e521a2f83580bbf330814cf5b96965105d9179fda1fbe8960a42439f13dcbe99420cb7e1c69ad825cf3eaaacab7d8b71d9e83c2ad622b8063f0b8c4c2ec83a2a1eb2849146b29d4122f7197970f331c0003fcfd52899cd7cf397ba10010d6cfcbd5e83eec5e4209e97dfa6703de580ea342a895821033282fb15c0277a83308e566bf712408cdf92660d643f2f49e77e4e4e1a09e44104b15117699f0f05b582afabb22b9b964ab82056b1813e750d918f2ca535e72c637f44cef15e84baf77f0d840fa08c6cb5c7ac974e36a8c11baddfa847557d75738f1c2c399851d076677759567d9172c39ae19a427a3eda2af0f4c557a722798284d8c46dfd22a5f7ec9cef55d9c8cab6c86aee364fc33af467cc1c462d684ef09db55959c8eff60afbefe884af1632b9d509b1adafbda536dbeb93b980389562b8594ae8ac841798b5fdf854f8226787d89ab8a0bf43abf532fdbb532883c0a75f3a52769f477ec3d87408f7e2592ea6b62378a088e9a4980457537e617efb87e273f34878f59a30beb0bc6da3559929de6e54ebb28b02c76c873a9126fe5e4b3496e2bd7bd83f2a9a505779c067e4d47fd71cdcfd1535033d5fd2e9634bcfe4735a0f64ad9e07e6d77fa083b4ab9dbe724e63a7489f5d4460b2d1a904835ca7c4837a217fea78c828a7d8acc9521bd4ead3b36f784ca44313ec524e3816d956fc96e8adb06c545a97a31fc71b8fa3e91c4585e6e7720fe41adbaa3f87a456c442849f17dba45f6d3221b08ef5918bd2fe52d96a8b5bfe155682ce93724e2bdff1f1f17c0d51d07233bdc33eb938a410257ac3791d5b2185ba8eb82ebd273c734530696f5514a42eccd2fdd542a8d4deabf9e1fdaa489b66427eb58e25b109ff1f7c8f317c1a6b71ad6f447e5a78d4c7daf2ccb90b9cddb00f9971cefdec815d43c4bba69264eb48f21bb7c8e84e4c5e0f359c1eaaeec19bcc7be1d61f6226924b9a889cc4d1a000fdd281d8d2cfff0c3a6b8dd9b1b337f6edd5933861ffc3c5cbdffb4ed59b6a254fb0bde2b440fd0635c2fced5d5fd171b5ed2ca0e4401eadc99cab89d165273b3c5466ac927118bc912e9eef9594c928285857b252d9b2da911b489863e88d3fd55aa8a818e3344bec4f4d9001303f7562ca23f16cae1e08753a1c513e1b28938aef705aecf1e1eaec00d047a26b8812b2935ccaeb1a7519d3d61e55ceb2ee8d4def9e89cc6e6dfc2827064935c7e9014ca91c661e0facb75dc4d74ca0b2f27b4b24dcee47b91b3d012d5cbe5b1c36bd7c65d98c7706433cb784e65d188ad07b246b0d08b6a7847dc92d804e3fdf2c48841277bdd2e7380d742c4c5262a249aceee66d540fbe7ecb389f6bfb9d4eb02743ea997afe457118f86f8b1a8d058cf3ac6a413ba7d0d0243e238b01c220111f85c8a90961e0d1816af8a7216548cfea6120eefcb9687d3d1f278ea919cca0d0f253321b9e19a848bc9f53cca72917a836541e03b63a39a7a68d92e5ad1d6ad194fa9b21512d5077064789d242d5a65b5db748b82d7259cff3484496b0ba0256c783f8c33a88a0eb566154a1a6628c4ce9cdf61e4419e8f19c5df8a3792dee754e9876c731a7758675f0f3e57b5f997f66a3da30298e25a23bfaf6177acb6750efae3004df68463452fed83f87fd1e5a069f3f64930271bb8730788024215f03969d8d469587d5b8c8754f3c6e52e20efad86f2cae47b0f374501c7ef88a46a774fce49d2e612e3c602b1f93fb3a3cfdde034105cfa299bee06ed21dc0ac38cc22d74f6bcec4c2241d1d4b35b325a2936b4de233a980fccb47e62830a75eb1d71735db04d5527d9b770c733fb292e819df782a14dd0abf4cef1447237b309489395ac57fc2b755df74c48bc1744faaaad0949b2ae22d265dd2db46a66d4b782698eaaace9274855c9fd7e283821129b077742b0fe5cc9108a26b782fe84a9b216612857e37decb0865daf5798ef163abf9a11895238bebfb63f3ce3652673b8ac7452c746096eef4ac863114962bc242c140da632263338f06d69cec23eaea8fd3825ca22ae9e72ca553259060d4308fee5b302bb4c124be4e7be1fcb87bcf2f82126e1039486152a7bab5462294cb0c3d3f2551b3bfb91a55e9549885ec2e4ccae280f8e4ddc25d4a4ccd114bbaa187f56e54d6ece28909170179e9ada1d452a084e066d4ea4e2a1e86f1def1492d3f14d3eb13fd0bef353d4acab97774edad7201ca7e35138aa5566ac874a057b27364fbc23a5dbe5f704fd173a38d22287268ed842b1799e19b1d77696a2452fb0d3eeb4da0909d1929552a2d157d9165cc745967054ced6cc9948dd712542dc4cf37978cef7cd2210996de8d96c1397bfbccd74c77cd308c2b61c499ed0679bfc45ee23e53efb533a3709fb41a956fefe453cccd7f8aa0020ba861054dd721b8ae349f6f67d71dccd224536d69cc461ca940c1ccc5a6d06ac0e308f8bb5bad8ec8c34fb010ae86f3780baf2036f7b471185d018a92dbfcccad69a1bf4b6d1c59c971d73c2d12bf091276abd9518151812a72908ee3108a00821f06423a8c9608e5133f0d38db34f90f991e29225b90db350a8872d08b9c46c5cd6ef19ff75524f4dd00ed3e54b89aefd98eb643564cec957c718d4cc21b0cad8947da61eaf3ecf9b66b65bc47076b2a1bbabf1ef8963dbb6b02121758a943bb3447131bf86ab8ad9b68f1555a6f713196a5bc0568846673b8b79c15ccd129b3871e94afa48a21f9de0cfac9358731256ef31b9ed2055d2da26a4c7c7bf3e959d804284bc8d45c77ac01602d4d7f896aedbc52409b429cce4cbf490fd72bbcfcaa88a73ce5cbfec33f6e2310d6fd9f2945d3790ea29ae1223ce19d13db2823d803d481978756f4a4974a176741c8f0cfc4292cbbb5039cdc7161c41cbcf79b67a25a56e287206ed44e7c5f33b23f69bbd09aae705fd921c968bc0a6f33c1644001344ae33973330fcc73289024aca677c0cca19f433dc7cc1125e0053916da5752aae6f00da9f3998a03d3d5bd2d711a7a6ff8625488b6abd0778c3289f2968c95c51cffa9b62db802aafdac9e5f68fe63b71597e361a30d69c3c9c7df883aa9f94c738e8831b439f511b69c5bf9628c6b14bbe5661db01257168877c59cc1e9dbe26cbf8ef8cd941d5fcb6b78c6d6e852e1802667b2e3dbd44e3fef690efdd401c671a0098b6e60b1dead299912c9ab0e58e7b69aeb34d461a7e06705891599800da5719a46ca82d7b965be275729ecba12e3908d4fa59e632c39d97cd22af7ce975820653c62c99f23c95ae4765aa54c9e464bd6911bb6cfd6e923eba809e728255be68f3cf33f4ba92841ca92e2e61e461e3f8ec04372bc8b8af087c53851eea336335175e9a3e646ac29c393b1df88c8361ef5efc3a076dd90148e8fe4c004a7de0dbae7ca6481021342fc0be46040ecce8e29a70a4a721b637e4750993cb445f22773dec5ca476d413f58dafdbea0b2176cadb5ade1ae21f171b6da6b45d3e01fbcb86123f8fed74068e82f76e04234a9b3791636d7d69513d85b309105356932d7fc5a205d94daafa866554b49c0d9201584c2184b367225ff91c608da17e6336960974274dee95bdc84ab87e31ae71eba716dde276afd84ec1253aff3438c724559250b61362fa6d1ec16206b5d05a4c07a73b861d990fde653b22063e4448c051fca4226ba88c4c6e476e65153dab60b236db07388025e5ba7207642284d5593ca6670d1bb1612828b98dc6a7fb9bf40c510b1918b7d7cb26cfe3baffb4739b905815bbce7f85ad8a53e82b83889b4a022d82c8c0f5ebfe9866af286b86757fb87fa170f26d4b051f5f0bf9bb30ca1ea2dc85a1fda55fa8ac1a28401963b28b0735ed582dc0f84c86efa486452f75627ed220340fe0c0b8b21aa1a3908e149618941cfd778e2a0fd6711d33669fa5d11ee55286e0107543215f3bffa7714c12b47fafe8e9e58c1b556d99e861ca2a8072604d477f4ee8b15a0add14e24280c2154d0a5a2eb6893a5ddea94d895c8dda35c8dd61eeb0fbe7c9915d05c771bca9144445e494c57baf51a6fd5abf361f91f925a9246e4dec0d7742eab961c701f2a22253417ade2f7bc454ce2fcbb967560314c2b9b20af7f997b6b26e89961c04a3e80228f80acc916f819bc9bcc6f7faa086152f51b2deadc0276bafb27f9bc59a053e98acc9e9c22f7639b6baeb1c128940ddef889acb469199dc65628d668c3650d3684117a7c491fba0922db994c5dc2d98633a3af787437bfa38fc825dd16ead5889f9ec43b757638afe7e8423b741a0aa53344eec4e5dd18557fc2efd8f1f79ff563705712bbed634418b2fc08e0b677ddca51d041591e4ef505b5349ddd573cb1cc9df244abeb0ecca5daf606c844e65f5e73b0c40db13a4af8ce74b4818f66b47d8576c1c00cd0936c0318d19f59d4618b4d6caacd9d81640f6e3e46f05f3df85aee8d3361be3040206d8df2ea7b10a3721300697404418d68d12f185b81aa4706747985a300f4f4f90b73b35fb8868c8adabbb3aec75ecfa5bda35ddc0fe0a9479ba9b64efbdfa994434145d74525f7a5c4a0c5023985a81866b47262b150946e4f720f851e7adfc78dc207fddfc07089df00281f0b999a8aefd3b28c023a69c5a7ae0ad31c84c7869f795ecd50c525517fc416d309b47105325dadde9c285b60fe12a295dc45f5b5ee6faf1211f978e9b918e6d16197edec4a3e4fcdbf04d8b8913e38a0fa2303c43eca638122dffe3f9d7646970a51f887a42a76489b15296770e6702d938afa8095151a2caa65bd4878a2a7b9400faab1e679c4c0d8898bdc1a0c8e7c243ffb20afeb36839c0cdfd281c927ddcd37f3ff65c67f338c75b283360e218740eecc5dde852d0301a54dc7b9eaccd79f5cdeffd9eee93157ab2cc16c0deaad9c54823e75803b3d9dbed1e84cd817a1e79795542b6ac5ef77226501efafc67e1c082fc923f19f1a97c04839dfc51fc1d5484259f4f3ed842ead6d8434d5b01e2e5dd5c0f09d8da92d9d34e0a67ffb27302edf1d376e5b099240efae074ac93170b4f39b3bb082fad26741217bd35384677eec3763b219f837968699c3b267a038315abe5dd4b33f3a5feaea1fa63046e8b646c5169eebdbe04dd0c9a0b3bb68d10ce128968b7a9e3a3fefea43b5d1d1ebab708a66b27adf4e4c55a994e18cffb914163b4c52d40dd5d5b445e663d0eed8b459bb73126581f1369a1c4872d2c8c13669c3497899ec867ce46e9d094446644d1059f9e173aa3c35a35205a3d1a43f0bd255fa41619b1975e1b1aa6bc11d4b480f232161ee8bb53a5469608cc64228f1e3b1e224e8fea3f489fef30f5fb7091c96ba3818917768530d9f8266658abe3b3bd6160b48804f201b605f866993d137d1c68c8ffe11c187fb9ee50d177337bc1d838fb8d8dda69a8674db81d4b9ef9cd6e256bc718088d781b0a97df8240b33c3384840e65ed82ab291b55569ce90c054bee30d752532ffc4ed68a966399752c87d84faa8dd439e48e07505c10c3c2b7e516be4d887a8ecb69840b575ed1a1cb6a1468b2f7ad06ad96c801a512d16313f1751fd522d84dc8b7a686087f2279e1166dea34718992a85a64bd263c7315ed48958ebc6dfe6352eb83fb7ee221471b3449aa0f026003f783ec17d496fd9d6339ce5b7e8268746742454a46392e363bf07970ae3806c1963b9fd494757a68b58d1b04247bb7f1509b374a5e417eb159cabe2e1e2ea6c5a117e6bb5554c9f911c3e22683cb33e1e3ad613191980585508b3173aceb8189bb66f7e56bf138be0fe886e61622daad5df28fa3e1c7ed70a84472cb7e53b215f5191608031463844caa1b8c1f94c79ed4bb423814abaf0e58313195d1e6a7fda767a699be39d9c4aad506606d0ab2518b04b9af1fc2a85194676d7423ff2338f673018d45e0a45cba3ed232625d99dd95cbc0077ce6fb7512fc5b687e3824ef5fddec01a41ba90108e5a56fabc6fffabf2a3d53395d3f60628eeae3f28d6e4b1866e070ce288ecf24f2886dc3aaf2a5ad3e3e3dd15325861a1678ad30476351f4584a93c2db8b3864b141876d5e1ca19e792057aedda5d5d070f4dfc45dd47ddd12bf48298f6634804e98d8b28a705d0cc6479241753f2d6de5d6549e7fcc979d5d0ab6658a9e35258d2c82407764871180f3893774fff52db06a07910a74a1ca0cc00a140bee95cf37b4f88c4e3604fd4c57f508b0ceb1c5a7eed5e4b1926311bacb30e76543e72e59e1ec38564a4a29fb8c3213a49fc58283c50ab6a996a7921e8a5686d578467afb185b18c254c4f1dd2da0403392ff477dff852b60f60755275f30625dc568d4eec60bee2651621d85642fe74fed59891ebd07c30963838b33cafe8f2356d3a09d68d52379dc7783536c38f3b7faf39ec87419337b7f6bf550df7d5141f86bcf2bf61d7b764c0d5b55e3f1b936a0f7e223177573fb26f89466541dd8b7a42ae8fa0bc17a14d7f8ee9cdb28c577bae85771997dc00c69c18edc63ac73a84dcbbe52159b5499b1563490a24fb96c26d98aad25d660772e130d9b0f878ca0db32d4fe06485c68dc3e7f6022b40d9254079275f0c3447c08e6cf33195ce85a0eb6ff7a37dada4ab18a8f57dbc8816ed0e09a075e11985aca2648d4529ea3535ec994223f8a5ff9e8860f488bb6b10680fea6b8811ef9de029191eebd67f18f6633919a2edd22afbf664a7ca5f4dccb9c5443c0308ef03dfc82817caec46d5f98f86d17b85e4ee05471c43b32eebd2da6946aebc0d542aae8f77640a45a08521c96870bec767b9fef54e76994bb127a0eb51d913d8430f41afa8244bb66de4d3763e260c5fdabb1bc45a592c0ed1a494ab133808977c1d541f0e588c918d0648e783f082a67efa46eef056a0f201bb16e3ae6a96a5870b67f6102a6b14b2d77f4e9920865c90566c668454ea4cf1b4ce65b3f9c42a935622abf84b38613d1f79563a1f9a95fd90e70997871a37e5bda0882e5c901f6a0189678f66e80700f3e866f9fd6b9d48639f9df0f193179984b2c1def0c9f84e1b32b9f1cb744c958007956df985eae9bf3d0a3c8ecd031217aa7d9c31bde2ca3b3b295b7c7af30a9288c298a98c175143c7a7912b922f6ecdd9d385755ed48755430f8819f76b23442b1fba000826da0c1ef74d006346ff9e63ff27d14d1303ad3d0d668fc14d840b3512c36e540076cb278bea4f916dfa21c1b04ea26195122e9dc7e426a4b7f5c13c77cfc4368a077f024d0cc4b6e8704600013e168e45aab0e865fee8808c3be496e5f24b87e41d03ae24fa61a1f864f2930b6364e34f2fd64d212ad94b2a42bbe055e0516f8bac94d5dd27c58c125375fe1b60ffee3de4f3628e2c5f985f1c24b57dafb3d2cff097ac7de076588c73732e6e03b1232e11ce3ad1f8e653bd584d0abdc5352b13a45c2d5ede8433bc748fb27dc89356b304cd2dfe6f927f26a7d13f0cb22c3a9e6ba1d9b579b7a5601a629fe5160563313ff379f1c4a9d3b9bd40488797dbf26bb5f44831fbd9ec479e5b153d688de908a47d90c51f1cf9240bd8ee0a794c8f3d6db4a68ac86daabe2210ddc7982f0aa6888cf0fef5d94413af818e160626c0aa033854136a98f6d0eba8896a1c889b53dcde91d847e47e06074f6e44b4febe45d9e07e5ecd09adb0d143f4490c0d3c300276b47f19e6f207da23db484b340cf8d431120774152110973a2caa54bdc90e35c9d7f93ef55dcf46ce06d5c6c5d354516b269a4be45e308b22b409d1840d4b9f4044ca13464bfddfcfaeac0bb275d74a3e45fd7670f8bee72b082379abe7d97adcb7714949240cbab596cf0d8e1f1192db3b7b8dc95b0a38d060fc10368cc86bd317983731e377b887e4cdd9d1b2df619f62343a2174bd3b1119ee5770cdd9cede7985d55b325ffc0d4ed9c0a06f134a767fe03cd80476b663a232ca2957908e3549cf1947deb3c7e511f332ddc46165b6022924a62cd9e7bc36e0bfb64c609464b984b21857464260d72","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
