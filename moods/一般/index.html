<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f726ef42c1b2c72c90b47cbf520b340673f3ba8ab50d7d24cd125482d01ac860bb90a3373fc0855f54aa90912cb9d5fb57bc66485c7d28da9ab3624be1709aa9eace693a0a28cb42bd78c70afa9f8cea901a4d149ed8a9b4c3138d46399279e256d1876c16c48ef06e0ace474da06aef7eed3092794021742c3055fb8f4b1060dca3eecde4fbedda57dccdee95c9553b5e134ea7d069b7711ae6c81f4c9a4db794646089f47a5df9651068691904f5dd7f44bc9c1cc0d647462733e51dd6b7463625d8820e20368f1efa65bdf044f12c688fa8b6e6292b19cc5f010aa4bc4927afd89380feaeb9b7588514f6e7d1eab43691d5c4c0c7e2952aedbd5047531244b840586e58e07e2b9643603779e45f74b2b95045e832b7f59b2cd2fe6e3bd103fba3b3e1758710084d6d58741e6dc3d20743b56b829786436392665ca28780e1c1126041e2d2752a47b6f0df01bdfc4cf99b519f05fee3e04269c22e0dbfa494c15ee0b5ffadf55427dc49712357c482996abf946a20bad9721953d7db16d5ee06a74b8082ba9f4b6a62c17e2f9056aee66b35703528b222005e3161e9f913e65ddbcdba30e4b68a712f228de68fd1792a158ce0476f1e92d6932b414da1c2b944e300ce991b157189ca226479462315f71b5b368cb586d39d52460d1768ea2dacdc27c4e8a7cd83d2bfccaa2cfc177d20eeec6462fb4877d78de3b500145c138677d3c315eb5dc49ee5e65723934e0ec7ba0e40e2833c7e9baf27b13e542a5d8487861c28c73644fc6cb4ecf84561ec7e6bb1f1810af4b10603bb954b734c5296e7a8078e8e314a9bf32ee94793621e31947cd004d51505aff97c077ecfeb4e9b873164e0ee86aceca410ad5a601de315764c102e33f65b2fe2206a00ab479d72dc1d3ad690776f59913941ba316a802d123256460fd8288baa4130d4a20e0d2cae69b6d5ac5b26fc7e70872472a4e2491adc698e4f09ef27772ae9697c0df5db1efbf8ae3a3c4e508011dc246fa685e2285acde77bbd44958e5c2e5e61ca406d3eea1db37095a4ef6a2158fb667454d2b700a810482cef7ee77590d581ce7afc22c5daae2db8557f662f556baa37791c9fd02d8ba69ea0a220d396aa0bf960739304d5d2694520582e92d23c66fc8c2dc0ce6d42583bd0624e3e07f7ad2837d51499ab1db75f6b3a3a8346dd8881240903d9bd1000a8fcd42688d3b5f489330a8c46cbfba24b177edc4f6d6634ac3709bd442dc8b90a0f8a1b5b4f4db2fd3f43b46fa324b8e3a7d8282ea3f01ca651c54c251b6fe096476fc1328014e9b2a1934ac77caeecb6c58ad458a502a4b6c19574291c5b138fe50ebb1e5655e6bce16a6e6f17ba4add23287af29cfde70fd93912bdd215d077c1c2d8471073e85d62374b72e39703227a8ca1d50a8045072a6738fe71e685deb2d74e0025b14ff74aad8c89c61f98685f4dc1ad46af68b78c5f770042fab5c576bc3f0bbb8bd8510f3a71b811c80f594bda2cd25809f66a177436eeb86ff4b924a9ecd724b518db70c60af3e710dbaca4b14a975b0742a65c5b8d9ac2c23278dc81374ef35fe7f91df67e90106ea8832e85caa23384818ec2ea69f50b78d0d7ddc1b637a853cf6e390329bce6e492c3e05d8fed59c4c2ea6785b10e9972fe77c5fb16b97817a2dd10de4d314c3490fbe9b8d919c93721b9e4effd9dc2e741a4f8ac2cb76eb7266e7e108127217958541f406439c6611cd57691c6737e34dc3cec852749b7b05234ddbb95a5dc79517838c59e4b5697e7bd8b91687b1b8c9050d2d1ca185ab4d36c19754cd8444a92e28554ea9af8776384c0a78ae4e06c01c0251217f85f6d33a13dc8cb06e8eb58fc80c25d1bf3beccd6c9bf5c917ff9e7539c3fc0ffca4e148125ebee3b1272b69b2645ce6e21ddf9b49ead029cc9a97805307120eef4be5039524d17de19f58973a955884de7c492b19b333936aee937c952f8699a6110a8ba5561174a81fb3565e3ee042fb74a413e27c8bddf8f7a2171735b874fc56362c77796d77eab6402d2bbba97f57bad71a2163d6b60b92b2767d7266fcce2478ca95b0cc8ca28778f18097c90396497e263f6be07329eaf028004d6eb156201b140b1cddfee711fe2bc19e7c44ce630507cc7ffba133cb549247d81ec23ec7df00ca47376baa2a038395005ac37e8accb49f4ceb9e2f579292fa9ec9a35b71bee885858f92d5c1bad1e10a502efba354cca52c579e902ac9cf24b18cf77ea458b90d6e322dfd4a0cfde3de68382b728390f8275e01c39f678e6f171ed50b78b5ca867bc7e2a6d35e42e5c21a9a70b6573903cb69e5d5990c11a90caf6930f8a3a2b875339add6588ebbb813ca8375c3db5adce71afb24ea5481a19aca9be8c08acebe495be34a807afe9ad342451e2ff56b14f866f2cb377e25573d923d4691c233f19f908555bb957603d26a66087b09ce5bfdf0a2af912d8e23631688811a234d473e3fc9422ad3df96bc77058dbc0934cc6c2d8ad3dc4cc5376f0a33b58fd7e778971aec6efcc32cad4d81d8c41a0301bac26d5d3109efec93169f36e1dfe2d673bbb9342e454296669c816eb910607500b5cf603a555a0046ac17398de8af296c089a097a6193f47cf5163129ea8349c18e5ad459a869c470eaf7beebfb0322cde067232320f81debe074ce0b5f150f240584cc201a896908b6abd562e71d3987600894032a89f45342219e8aafa1eb054132c81edc843d0cba804051b956faa8b0c1be84049dd80128e9c69bc0af4de98cc5a0958cc989bc091ab1c082ef6ff03ed1c8433b45523b4f1216e8351b0867a568703a741ca0543725e32347732450fea74f21f93eb817030dde0f26e18c389d309cd58c5699fb09622fba61dfe379c558e57c86bd22efda889ccf44bf9a31fcf928496d7d959968e0c57d8c3cbd5870f3209ac809cba9cd587096cd7aeea0002cf33860315f3b3595ce22c25f35bb220ddb3c9cbb72653c160568d5adda73f7d297cda020cce323e1bfe3911e5998bb4ea892c2e7175e1ae8702a8a188ab24da3faccbd8a68284e7c6d8ba77993f6c3dc18d27648c4e7a3466836864f610fd2984e7589a7f3d835570b06a072b08c67e559adc52e590e28b32c75350dbbf03a7ee0347ce75dc08500463dd860e9b55de3a85c3ef3382970d9013bec9f7e8a5fc2fa2b7bb0586fbeb5b000d488a64e2c1c6561dcdef3c47711814b3ab8b18c262a320391f3c6bfc5cc90c6f0d2bf183001eccf7adf5f0a084b025effb43a1ec1fa9df4220c4e7adeb395958e7eaa080c2bf46bead6d9dd61bed2fe385fdd9f849d87b78aaf701587839c8d8e08488862e4f4b4da9a2d599e942e1ea9a3f78873c511b2c3e58e9fd747c30705172eefea3e7f1e5aa9da82c315ab3991beb622d0f7fcab288d04a8b5a522cf18438b4b2b37ee14dc54a06b15376c835a290a01f08860b3982d697fde9e3f8bfa2d8872394fca62e027be0e0bd35d533831bbec6c845598f6bd6ae0b262866cb445157bc0876566d6e7b11a64a777e80b1429525131674f13c4dc86eef1d62571a41d1cba807ee8ab8ed765941940bfd30dac8e73ba8d74cb4829851b3480fe4de006786ecc96a46bbc730eb5508ec8a365c42e0d1166e3f1be1d6b434660303b38989835fecfcdf66f7a357d534bdca78d7d5a4ee9fb51085e6bc2cce94554caac1efc3a821615e36a7f848ed363afe2cf8718185e867ffabfdfc41f22176971a599ed2bef9610030e0dda618cdfe4aff16d25a436813e63888d9f39ae1bdd51acf6845e4cd3a3eb2a5ef27c6c34943e0f7094d37b08b8a0c72e6627e8d100671e6c67f48171a12b03aaaf4b3bbced74ca65743a28e26558df87cf32ff00616312bb240f59423fa86e2455962453ea4ed54613354e8e52c37627660a071b9afc5be3dccc85a5aeb995588df76ba43ba0390dbc3aadfda5a5a0d95c412168941f2490499a2dd01af972089f2da373f5084da51e270ca1954451631f6aec663f2142658dea25c21c440ac203acbcb586d33723a3535ec2af59b6bd9db89c775aa01636baae74ea2b65c4fcab0592661f52ead29b086af4e755f752625abc8cbc2fb53ae3720c90fdace1b41fab65811f3e568dab6faf7e7b6c1d80a1e1a2d6162390e778a1c79beb6f551384e712acf16ffb6b234249b9b7565e96be3399e0fed37b8d4694ddc46eac26e89ab087a93bf5da9b81b421f874053062cbb2dd2b09c1ada6d28138d9f9499987231e802a3796e94c211829a7ba81beae09b837e801e21f558dbaf5e5fb7f84194d6bf96561f71d686456e39ba16097520ac7437efb0de676fd2d22663da3f5aa6ec010dc9f107943abab6bc5a15a014840057bad3383fa0588ad8b1cf36e60c82a5fc2fe5c208c7e357cdea9875f74595a89b4756f2c425fd194bc27c7cdea04f2de93cce7f3ecbcbfe0007665df1b6dbba8c106387f7e0151dc2bb79e95f93ebd90759c0de28468e6098d6d7833d4490a319d3d87a84713765f506b419b1375d1ce3de63bbf2679f7bf9bb97fd2f112a3a8085b94264dce5614b68b33c4dd7bd1694dc2c975f7323ebe6ad3c77700d6c6eef91368a537eec971fc539e8a6fdc52e5d9ea56603b51904b2212f8c762aba887256a90cfcad09a55e4dfd6f53e723d65e757a044021776987db777e27b6b47a4d91b27e6b38490a3a34cb4949b7367308c434864397826874a36fc52cd763c70dad8a5942b92286a9b038cadbfbf189919531b46d41ba55182056e3a048980ecb46dc2e8d0f7204573b846ec311aecb65c8f27e784fbb2831aa9c3d303a94da1123d0a54e186ca8486c0d949e1863ca3a4d373bfb3d5e4033f9b3f7bb392ccdfa72f72c279a271aab246911db671f2183321eda1419190216951d820f58750a3a7413f1f608507fe98625fa39737b75e9a36cd01f6dcff349b222a9bd8c9d3915abe1a4a0c1c3e1e7b9d1a10bb7e46dc75ea997cc23d713b9056e31fad6b4e5a330420121b78aec1afcb733ed78108da2a3e948f4e84aecf3af893be6e08d88d28ad30fd1ef397025a6a88f94ee0ab44bad776db1bc4849728522845882284da3adea0e703d3947e6625c6ffea87f10b777c4c0acc1c4ea96a90c858c98486d2375d9a0ad6bcfd355e542b47c4a8d8b9028c8dc932719d7e74ea9ed666ea7308fd8b5d8ff3d38b9f3924b26b6a4e3cb8f699d18d21ba6bb67fe7f96ffa4686b9d384a29ac71065a5049395fdb81194601ed8c42fcd10728660aaee3bc57dc77f54b606ac02e67bf3cc119b8d7c925eefc37fe521b04552255078fe9f86e7fe7da86d44ca5b3544489a09bff7a6463be0e557752c8d65d7499dde009900f9eecc03f3ba3c8721432936fec94d0b9d2b440c0dbfbeb93c3e15a82f02c96520da6f42c72940b36ec39050c9e9df38c9a6c02860937e8ba561fecfba1a0d987ab33fe722fa26e30526e71789d0c7289630d953314565970c3ae661181b20e03e0b1f7c8b7a12ffe2b24098f80a23320fd4ea47a0fb8485f78406f03c47889d29e3261d573a6136bb818523d4088266e2d752ae22fdef98250225fc6ee9332af8c3f30992a2ddd5b482f31ac5abf1a858acc462b6725b2755fa804c1246df245017faf51e63560d7dd7dd82022d40864d97ea979a56e0457a1a1aa69b939b7151ea0a217622c9b7b0f6a0da9263ef18dab2b147eea51e60bd0b369faf8bbae2838ac91ad68f4d4e13cb8ab823696dd44c5e7a3423337e55a5360d586756fe22e6c533f408a9823e00592ad62d3b36e3eb4f5bd2649456d81797d9437d6122a75470108930b2a7588508a8eb15565d989f91da1fb75c4b4250e615808eb3658383b079b294b92a1e3bfdfa843084a41e03cf0d50def169c649a2c61d8d3a50b74d1c7e0cf0dfd3a4c72ff6d67546c364890de35f9a62cee55f3fab1a9503c7a3a4dd8fd99d65e956a25b539ab207713cd98171e2d6fbdb7f31acb07f6019d629a30899b143c3b486e7afc21fe5f4477fa6e866ccd60da08867f4b7101a7570472848764db14cd4b82328932753bb2baffbf94c308c7263727b721e928c9ae4df34dfc58f5ae99b7f6198f53c25a92a898e491c3dad1575d417501df7330f25502167927454a59948a0f769f768eb1bb777d4fb494f4c5b8ede10e42ed4b05afd9dcaf598aeb79b0a3d868499cc42b55e7b58412f2d5a686e95be718588870c73a59701ced665fd1623a8437829f88ac65bda89f283c40a32534e1386f37cff6714a14db23f87f75b0400e6986abceae49b8cb72e190c052e892447c7243c4c535a6994253e21ca59ee1fb569a045deabe015f7d38d361911d9dfab54f821b0cd27191051e653411f67569176bd47a26b5a90310f11081c4e8df97847684bef9f21854c5b5614c2ff850dd93ba1c30e55524c9b1b0e573fae2af83e82b0a8224fc7c01713e98f1bb5e57fc1ee6d10344b9fc4f72380b3de41769f04fd11c4056c6c7ff503de180f6557d0a9fc03b0109c55e36192d79ce40b735aa6fefce2530bb2aee7ad1f92c8afd2896d41d4ac9ef9c165569bc89da2fe307fce92c1c6e4f1be851c79f2365ff3549ddafe8250c12a7fa4b69b1d9057105497d6a03aa2e94b4785d36573ad3ac243831de25198425b515449035d31ec94652856a00cad36f2a0e9ff9e857de0e112500b7e6e55948166afff1e5b4df61359f1158874f03f70d0cfc41d1024437d6173ff7640e18215327d24f6b6a6f8a3d3c33c3ce912844bb2fc2a6c881eb0d6d5ea6adc2872097e053abb10b54abcc647365781ad924156095c9cd43e85cb90b5e39168e06c35cee95bdc741fdee096d5c3597c4153db5af6082cdee2fe93af4e9d3ce90674caa834ea74a502e5d2d3024b6550ab206ffbca7c195f8ddf76c69c757a320791db14089a55d24bae003507b54515856e650f77eabb5d9e952e90717fa5b229e2423b8d5e39542eb108f55f923a15d3df784c20d800c3dd09290a24e9390da2bb9a1c6f73f0884ef6b0b9d3381c843c2c1c645d3ba4a111a10f431db9b14eeaf769ec34c55fa760a1b3f0d9b38b8e692e665b05b8144759929c87f024aafd20925d53aabc54fed2aedbc7568be39ee891655b784a385715f83084e48125d2f1a9e83d21b9a39d0e6c255a9164076fd2e9097fbf02da93f807a74a8bdca7c66369799f9feb6295d527a6a4190c580c5cd48ce0385924f11dd13725af707016adfc86ca938c42a4346ea102c6bf64bfaae571061cdd431e261e39852ce1bdd755d1522af18d48441c8c2d4d9031bdc66feba7d0c69815cb49bff0e0505cb3d13d6287959730eadeb3ff0017cb431a711d962230be55b9ff13af41797e216d06793de2e6c191d3321c6e0f41af76bf9cf9d377180fe6f87098209938e427dcec8dde74d59bb07170bdc149cbc730904a726665fff65ffffb21b9d59e24de2e5420299c3c8942868f0a79844e11bf79e4598df98f93634539c174b0c380d2ce32ca2532d99657a1a374264b6ef6682342e59326158cdd9ee0b8cb1af34d2111a41784d9703eff03a37d82bd6aa33d822bfbec31071b3d8c80fa62f9823ba32bbb27507d959ba4728586b37c6ff9a29b8ffc4bcd02d108c10a5cb6a5938a38a556af7402daebc4d30a272be3c8d56323a760690cbb198971a778586d66d6c980d329e95a3381e5416f8edc5608d0112e80760e2a12b575fdad68a8227dd9729dc7e5b9527d0c96c892b4fff8a02c495de13bbfd2703e11d42ccafd1415f87392af46c96aba915a1f4319a54a326370c092abef35a1800a6896b55e5eca4d543adbc0e0b1ccab0a8fb95d52d34b6a9b86f45542cff440d266a005e129ac0a213e7585ff5529d7c33956280e80f69720373fd1b633584a2cd34b09c19b92adb87961dfdcac6c7bc371b8ee15684e3f0d75b316c7f3f76bd613213b2c60e7520f57d51232523850267017c744d25af4e2daa0a1c32ece37be24f3506943de587a78d079ddff7f7b460140d9420e353f5774f940082fa7e8996a436a9fdaac7b1766729d20928bfba2a902b66b42ce3a935e43c381e1ffbbe6a9c2b2686fcf7c668dbaa483a50ef84c0982bb6f99feb88633ca652c7de61e125299e087afb98b18e523a87cfa6b79e4ed8fbfb1230456a806c8c8c2d0a34c1df3cb912f01926c62dc664c0f53ec3e649148e28429f0ad32946d752ab95136ad3e56783db427c12a80091e7d8d6ebbe451f654516185cee652e9fbc663793cb1401d7976c2f50ece236d04e1b19d29fadde76283093f29bbc81045e0fe58309e92c919eb54ef91fdef76a6406d45cdeaf7d69fa18191ffd569652298bd857e02d3c6c002003192986cc5efed9ce3dd13c4e89213d7f2850f491dad294ceb37c4f903aac3eba9435a90fd25905bc10a1907260a753fb05691952037e47681619ecfb7dbf6443614871e92d9452990da3ca6702e97b7b0e5e73bbfe9b3008e4de3eae53df1deff368cf29af033ba3bb3cb8d44a2680f9fe0f90e219543f4800cde2649db0298e5cf7c88a627b2dd9e3926ec6229ad147fab9c67f388050632afd35d6bb4079179caf0afdd80e4e431ef3490d88c2e534c2ade99cd0320497886d7aab177ed0cc4cb22b917d3be690b8d1456cba279e5a8722714d1b178fe05015253165e457d056c514eade2da79f65a421ad0682e1ae82590ec51069673d1f639aac9ef76027ef11a57db9c2732a0834d197d0c8fa4034e628120c12493c5feab590aafba3272f3249fa4e50b9a8c83df6ec91af3e3bd7c5cfdb96ae3a540615d18d465d38709c90a1b42c3ae97d18360a3d82d046b4f7cea980eccf197ff686754c4f6131c483c912f0aa609bd885b7028310768a126ce0a1c2d67f81cba802e9dc221c52870bf73061f11cc7d8fcabca04b030164b01bbadcd83c39c530e4c6f2c7c7f2913f951a7425babd8a41fc23b71a44bf2f3cb527794bcfac425edb96bd99433fca6cd384f410bbd091504eb64a0f6953ed6cabb86e94fdae6115de98c5d58e41ded20ba64bd542598a067c15f17de8b4e1a2487508dbfe55be8652f6206588a5427a8f96d434e1a7d38366f64a4c6a3858d1565975159f4988d031cff42b26936a0f8729d87231eab6732f13f7c13f461fab575be0c4d5d2a01dd6578c89710606403bc7fb5fea980a839b2aab1227e5eb976fdf140102d8561b2e3717193ca84b23161411e3556b40fd14dd4394b225459c922ae0aad20c8f9cbb259ab5ff0ffa5a65601f9882fa6d9a18a980b3c60ce4b5febec0597bdf2cdece6fa17a421c2da1d21be84c7ff8e4d466c0a06a82bd19b81a08adf0a70bdbf5d90a212574cf26f7d8e88b80c8fb751faf41db14a0a2991b33365c25d00aed3af25cd22d2903de1164411a6c6b451c6be69ceed9ade8ee7472e6515395684d091a992cb549f0ebfc2c22f72e69671869646f765961ac894e9302b3f9aa6f3e9cd34bce43d106dfcd98a4e11478f1301b6d0bccf337038fbf28501fb365803e535b466de1a512ee6ab05cf40f51a8668b1d0d9dea97ffafaa2c61cff1dd32b817950f73169cd3a011e5c67bc9d7194f842a1f471caccc0805d743ea8e981ba1c075a1da4ea1a1ccf73031e0767846445eebe06a95ab41da24e1e4a250e4f03e85cd855e896a383c31c41fff462aeee7323391a5a979b43bd5503506748d93d225c0f3097c5591a57dacee4ce8012a4b9bd0f4e3d1637cc9529d63839ca9bb59166bd4e5e6e3d7a75bb122d245679f9cde8a06716c132a1b447d59b6f61bf81297e6722a94a1dee4915467ef39d28bef68f693a4bc9c01669113dec7552dcf41322114d169cafee7cf1170aef32ce9dec38cebfe13c1de64a8261b24082e8c098e798c00c5a1026edff429a2c5fe1d2d9bcefcf67b686c03bd65fc2afc786b46d928a2d604386fd9fb82e0604e372daff4d86e8881eeac0d00ab45672f685c83d89911bd5ee69f0bd65ca7e1542d01c43fbb6a64839808cdbfa3961f6c3b0acab32cf8441c22fe6c7a766afc00908dc011bf0422e6ff37923d6453b25714ddba4bcbb6cb4ecaee21723d43037db0d5d6be6164ca5b4b95894f4afb34bcc336954a4980aeb7219180cbf9fba340f66db6402b17a302618451c8f77ce5cf72f4ea752024d39414d485362130ec43e99efa65c62c343ce957e57ccfd593c462b64063abb86062c1c77a8f2b6803ce2e73f1fbaa5acae8b73e43420b94a40592e12c0e9ab140171b9f4d656cb5c69ad99ae51e5c62e405d6987b9fc4cbddde901cb60fb5645a013676147d1084c0cbb88144aa0e970ca284baa70e29b562573cffd5683290f039bbd2404c3fa9ca3d5828131fbeac3082c6d119f03173c95fc4b6870b36d6e43364f2cced4efff87d2b09c8ce40485fb0e321d048df8949223c4f944b2c56e53dc0c9a0e84ca03bc668f9757602db7e5392874e0c8b77698e24862ebfac593073cb215f61d7f9885da65eea90d53907d6042493962707bbad0cb62dc4289336c7bfca13292305af52996ac41623359e6f6be6406c549cd156c1e73ca310473af194540c606db4034b1b4179697d666ec4320896e2362dfa36baa19e9d03059bae69467be30be0aa04721be5a0cb9110dde1a17b7325f2e5dc38d48cfac57f6f023bc99e873edf29a7f18a296780bf187572de565e56c1eb7b2f856b3cef1f26d487995715734f524086c16b41d736ce2f7879b5e3a3270732ae6862f7c3d428b0c0cc066fd42d129c65256575060312213dc33c4ade1a8f59b9ca4aca71e79b77b61ed5e3b1267c883ebfba49dcf95df726b5b95599094b73356c442da214f684a8d183cffe59d8b4cdea57b9c0250de5dcd462b5efba712d884c9b58ba012e10df979685f7a9442b3f55b244bb8632caa50fdf40f675b26bf72678926168a0d240a730a5ed5c98dac41c2b71cac91514dadd06f99a41d879c375b7827d2d02e6b7ecc5b2ce571480c5d3185777321f95cbecde46f21bc0ae04ce65d60b3ee0d3d4a576beffd8714675aec3fa76a9aab1f35b7aeb3eb677af2aa6a1e412c1732dc36a89b82c228fd993bd04caaa87a4a8d8b6902b095ce104e2aa4b5d0885f0aff7d649b5a29c2e70a3d6b71225a87e0e611b0c1d601619824cb87f41cee82f829e3002740537b136037c9c256e684e2707e6a472fba65dc5d73ffa1c617bd306baa42e6e92f5d57bf9d410041ab49bd7040e97c5c8dba8cd2d1f1f98de8c111d2ab9ed429663722ca5b2126872b3c43339f46788274766c889eb2f4f437960dcadeb2e866fad79e9b6cc923aa428a0fe27a65f7834d4ea1d7809cb628c3ac8dbacb322322c15763a8b6a57577a9ade41708ec8a3207d1126f83f9f0f9f8698dc82d646c20432a21f46e67c0afdb49a2fd63b8c2da41331028d63c89f3a8aeaaf755267db8e15edfd9f59dc9cfa20058cfbf7231efb122d56773617b2b572edccdb8ffc27bafd99578f55ebab03f4d1cb766fbf6971d38e98561675281430cfa65bef0d66d9451b866950dc94d1d0059f64ac4dd9b5e851a2a878b2ca735a1822c7df0d3b297e62fbec7d229f2003138a7339db3f9a27f6b1e03dfa8101a8d50c2ddb2cceb10e2c73937b91514475e5fed40983709f865407a7f2f1d8712f8381a9a8e22cc8147204b7cfa6bc0c9d23bf02d26ebbd2ec1746066150863f50510eda49c6da633ac4e4ac17d3410d0581d4eee7bf48049fac206de6ab0b78b53ce94f055f41bde414a0896fcc3027a3a549e117e195c3f34df09b5883c9e33614c84b6ca27fccfd1214e58c636cf58744b77f5a0e42a5a5676da84184d8937d697aa37c2bf581fe4b51efa4888c966d9215adb3647fef82036812260db43f6de120e4b42114991eca0fd011ed62d0f3a1ca8736501931d0ed93c2dca2ea2a71a1ed5b7b2378099be398bf37aab381bd98e7270b4a539cf1d1feed22880399062ac5f72e000a93b785e0de62fc28cfd2ba75aa68fa7b65ccadc5ead87db68fccf6db883fe43aee7477ba4483e37d803445c2bf98dbba340f0d54337f1b25d46e627e235bf61561d4e1a71eeaff506fe41a0d15d18b4f68db70a861a4a364ab11e5815b8c7a9fbd1273cff0ecc14e528ff2129164e1f6f30","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
