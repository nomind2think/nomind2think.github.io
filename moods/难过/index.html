<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bbf5eceb8b9f158f0fca38e5c7ef3c7c220108d638e69d6ba787fee8169dfcd260bd6fb226cbab2d6abe8ccac978080976e27a68345dce8eca6f8418b2fe75f1c8d2db93ab85228f6585d2a53406195b5751d54d49d9203b6a67336b1e81bb54a082355b0ff484e1a9a743f1da2a6e95004173ab44afbff6fa23c227ad1526ad1a304dc164257be0c98b4bc38d080f612aaf90e759d2d5650821d6bd7fa349dca5cc1bf4de2f2c97cae35f8ed6f7484217be1ccb24810b6cdb8e85ebb9406af208ba770bf6a841e18cb25d5d59a9e7dce44a710085d6c26fcfed3878000b8ab27ed484db96269866a9979131ca9241c75d71fe67cafe9733b4e0581ab2cf877e3347a764fc9c397043c00111fbae5fef78e398a2e4cf3151597d6a552c25b1e588ef56d08bf37ef00023f6dd346066cbf295fe5117ceda9d06623cdbb995da3fcf14675031a93cb89e8ed317a2326ef46f9e2959ca45d7b2718c4b912205a4c3b59863d3a17160d9297c0facfe781f7aea8bf53d653c7f448d60e51dbb26e1870e3eb3ec2b5ff9526913ff0020d003cf303a41e4103280054d8a5eb1175950cc04ae59d003c48c30a799e5b7441545fb4041bec0c3284faf605c4f17b9d18dadc99ddf79279f4d4d4589d6f6b25e5e8f924a5682e9779fcc5bcabb26cb99bfd75a63bb5738b2693c33293d8774d6bfe60ebc7793ae354ea33b2440679c514cfc3c683d4104413e7b3bd06ecfa563c74e6908434df67dd5b9c032f5be396e507c14fe06e4f264eb1cdaf48e5b102ffbbef9af0cb2f1d90f14319ee4b94ca4733fdf1a161a705a8280b4dfeffd32281de36c615261a3db56ca1b4c24484d8160a00621511d08b4ecc0dffeace4e73b50581814534c2d0de8f847934571b731f1418100753f4df3482c4f1a4f04dbd8cba9148f3c8b4741fa975361bdb0f2d0e787403e07874f80d93ba30f9a793ff219124b59b30a3883d4ebb941a5190a51c58493012297c55936ef5a2afead41e84351a0e61d34a5ce073515e7c363b0f8d744ba94d847dc2094ed05d433ff37aa59254d8bebab0ee2926a1787a1367b4437a80a24ef9cc1389e29e3e3eb18fed148b1cb3d1de45b7312797b1e04eb594711608121c94dddd530e197e4d8533fd85dd3d373d279d93932d4291316b550f90d60d94dc14fb5276c7cf6eed21a620484e123f4428030f1614ff4426099067ce2a3edf14c8f94b36e9cc8ed39b507859624493de7787e56afa909c0252f2aab530c55d3eb3475a331e645e08cd3cdd1134542afdae6da26f948a1d021d5b4e77c8be5007bd17cf83c6fe0d3a998b082ead1fbd47a7157840cd5df7b407cbf35086c5a7ab5f1a8a2c8f8141b1f7fda5da915ce8ccd7959f5d47657fb1951d20d4e8a9cd9a7fa822f50616b87c4cb9bde35a7e7ddad752bd2ec5be7541c638f3218df0ef993a4484d71a92c49fc42854043464a309f50383313bca4da6f5afed943446ac234328f02bfd4df27c33da38ee45071b9dbbab7603f3c15b9603ceb05d969683dc534b1ec74eab703b9f23329418e6df652d40d6df461a8bcdc0bb95f5047a0b76d6f8427db1ad0656bc8f4f37c6194bce5f36c784b0139fe3da8207e5279a9b5602149231844201c4313abcdccc26fc6029f28f5936dd84a7849713440e61263beebc6b6f6a7947036438a73cf2a7f2f4d25e37168a434a9e7c3989e27e6d8a8c2dc7358614a956cad3424ad27b3effe8b7bd7d0fd9b5f7a2f73ad7ec3cccac9df5c1822aeaf6073afff6157dd044b33904c4974f55c6d5ae29f1c4e17499f0faca8ec67c3e7abb91daf9568e9077e04355e26bea659ca1d29ec8155a8473ef79e5ad05a4b23e7eb3216e615e2af0c6cab96e4806c7cf5527279d77c7d4c6697fb2b727d28de3e4d5bf4c13a8cdec0aee90b6aeb1e6d3acfa2999b727a72cee0b4d91d1f25b4dce8b12855247e4e5c02345e427a870fa8909fe22f1122eee215fba4f0e69c81bb219b852f2a7c1a5d3547d45866aa65e33200bed1da2c26cf9a9363e38cc08a46fee147720ae8967cc330606193ee5d2145771c420db7808898463247244e787a9ce8cae0b20db0cc762e332af7609b87c1de5bd86ba9216d68b3c2af03e885d4c2fed54f06b1469f4ea6f690dc3a85235cecd5d346fc8776a5c13ba21a077b81886ea7ca6a2df9ef138cc67659950ed193dcf2fcf1aa18c80913ab433593faa6b265394b7c0128f61af8c88beed9877441f37584b6a57e3d2f281cab2370d297af8109b543a46774ca1a7301b3c196de4b2729d13f2f9dae089d07c054051221d4fd1da2ca713a90b47c431cb23abaa860625bb10ab127f61ba3a0de62dd82a83390e930a023c7ebb318ff1e7a9d01983abb50e3a5e5c955e97783ca79eeb44e93027e92ce423198512b0b8db50a4bd721b6feee983418b6d03e41484c2770c5bcd5cc0ec6ead60ce9b2148ea897cfe8111f43a0b099d9c3bfec54f862259f2409d6dee0c7caa82085818a1158327615184fd7608f1a2f8f90fc24d8efb73eb9411f85bfcedcda34eedc91741870e070ecad03bddc3abab461325dd7e26084b85fac34f7ff4063904bf1d020ae58f30331cc4b4af2bcb23371f18fe367dec95013cd90b3f0e711febf3ca493a173a84fdfa73372736cc4b1f6f88cd192c5d98e0e161de11d4785312a537d744c2d9fbd0858a0c3bfe96675b276aea4c7118d07d983e59c5a48a6125458a2d0221437f1e67b025820f08725b300743758f1cc2fca8440ec551fb0f1dd62b9b603493c7846eebdcc3b1cc946d1a975b0f5e010b2bdd561f87681c44a5360aa5e7a40a770445739e32c9e96fa9f9eed385a0b9c7d534534e78e646aacbf888676a5978503844f7d210b011eb6f305fb75ce2ca88dcf368508f8e5d16fffd8fa473a6223e090d9895f7718a8ea7fe22a39eb13dde7121122a0080358d08901b8b52d07e19e8a37a77bf7d57c0cd833d518e1446a5d79654413ab3def2f9cf6f9724690c404dd06fd28912f72f569928dc649deb6ca8879a7cce82bd00becc58a07045afd20ef5a9110be9bffd0fa3e8457c75d70af2b3b92d8f3fc80d23eb5a1ce8c7c8d24aa2b62f97b9894cc46f0a23780e28c8ab3e4b10a4121bf5a2739b5b96f92fff42fc4031613eee12e09d79f00625ea55d273502957191ce66bf8213f8a36858a1a829455694fa3019c5ac473783e1be2272bb6a2a57877ca146c7f73f11142b7b32a57c09c95179866852574e3603dd24cf0069d63af59d7cd3146818e08481e11c278372590c5d66815ce6e37a133da029405f1c5373b0b8dd0d5cc0bf035a5f84143dd3d861368708c9d4613f440c86a8d1172cc4983c41c7cf32d67d650858c9dd113a7548741b7101c46c0c54e2f28c0b9c2377104402af627a32e408a91145f72c13f56780b2447f593fef85af74ff55c092a21fae2632141b850f98a46ba9779e195e95d57d73f1f2ddb4ac0f4bbd304def047db083b74e8e77cc69325413f70c846d5aa044192302ff41d494fa95e2b86a37ff3ae129f5a417e0332c02c78ce276015129ebe8809bfcd8a92b32eea72a028a2377eeba0d21b14c4649c9e731fe5f84b5796a45fc821f4dc7226e6c382af938e3f7843d15c3cd12cff562eb12c886832c6c91f28adeed602995f6caf642db767e137a9ccd134c9cf592bdf4e1d21207540ec9e24aa299bb34f132e654c199d9d1665e811ddd621ba28feeee8c827e2e344b6c84f5c3a9b437800bec693ff14f0c343cfe263cc6f57297114d2e833e431135fd84c7ff5facd54540e0c4c2990f3dc85ae6582870b732b5bec84cfbedc481c032a00d8a6fa36b0dfd3bf0eab9fa99a633d13b87b91e9aaea3d18bcea6eebf89c2c1b127d0abd00f6e7b82a6dcb9bde1a469453e664b299fdb02a0884278fbdfbed4463176ac7aee1c9830818b080d51575ee4eeee2e5160ef82c15413da119d6e365b19d9fde25ca3041c8e4e57d6b8f293097b6e31660fb6777d75b2100ea5bbf2ac2fa5310004711964c1e5d4afe4cf36be07eb0bd87a38ac7c0c6aef57fe42dc0fa59e84bf96e781fd9597f1110d5e2db24431b548dc497b3b985802b4593cb6b666c0042c9c99cbe0e2b3c5190e53566a933752fdc4c3ba8b054438fdb6883d77870c63acda802ea51189ed85b5be96b87b33153c1459747cbb603184413581a88390263b90baff68596cce616f6824d4e74710747059b1a02a4bfc9cf1d347082b5aa4f76543512913ba0f947856f2fe5beed15df3397a3d00c5b3746b097a541c33a3477266917f2609ad43ef77643287c030780f5ed672a1548a52620e10e635b6bc19d5f469578738fae64603d7a30d8e8a931acde10dbb325bb639a723eb3451e7a034dc2282bf308c3a731c6108740439bfaa140f2af34290e9a51df7391e27f5a2406c2d51df6c7ad3b5447288add6f4f08eae93c636f1bd4c6f65e36ff722a949991695ac8124b0fad53e6ec23cfe3f1c84223dc3f50fab933a8079320e0ef941af261e46a2ceed19c6e97a5f73b8104f6c997b4fcb15841cda291256e52789988bd7dea276d31ef03be6a8537d880732481db471b7c72883cfa9403c40763daf94071d487139201132dc5da2ad9e15b837ae33d10ef9fa8db146178f5dd0aefb6b3894578f93fc54209b862afaa5fa2e79ea3e0ec67c57d66daa9e075b7139de32ddc3e185366819f0ec365a0f398a9f9bb00b4c3f77de7981f229c0a7e549cd44a6702476b62512b5c85183e37e16b623e85cafc66f7bc7fb9884ce6bb25aa137e081db08271727a520133eeed6ccf1365d95f323e9011bcd5979c8842cfe6ae7653cb2e203b5de6385516c05d663cf5da221a89a3288530cdbed5e083f6fb213a04d67e458fdd6fc8979a7b6d41240dcc6edf67162aeee8cf65f84ec780cd847d139a2516867843a85ee3315e0ee8944b830951d973ada15f5e5b076b9487754db26c9705c810168b3e7103f3e3197b2ad75ddd9479e84d8cfb66511b9774549d3ee53cba405ff02f69d0727ecefbc58aa7884741515327f7113e219b09091631807c6a3a391172a1fda26355b485b14ed688e259e19cf479249acb10483a24e65f94784d0d73dac3971e64805b430845b43175a32f3644f092a18c30bdb71e31ea7d0d7b137560e1090f71cc6576b1e36e5a88208e265b80575e00f4a52c0980e7e2ad55da1a108de3d8fd5aed12976b9b25c1638706d4b3b2b3ee957aa0a5ff692b8435cbd9cd4b6a8229c13088c6ca8f6da70057f285bfbbb629ae6f22725ba621fe5d0c1fb325f1be2bc10829a42be380d7fe9051157986337a10cf5d9014cd05fb7dfc1080a76157e061da74d5b121ad03650f794fb2af595c3fc4f1d5b59437d2c18eb43f190cc9ae5775fbd31946f8c4372088c8d16fa94710732fb556c51ea69169882c95fbf6cd5eb28deacd1e17961dd16abba518178d79ff3b55b3fee27dec63dfb98f6a03cc8b833feea1aa1852e532ead368333119478ee0aaab7761a6f1cf852ce9273395a65acce6b9f2e64fe5bca8ea0422ad46ee1076a990fe410a62741c414a224fa9ee76c8f1b0a7cf0cb0d6ad8fcfb529e657b6fd9039cc257c581de62ea21c72dfaea9aff493a5d2108dffa78812221bda469ddb9bcba001fa67afde3f50d8dd519f2398605620b8f6f04f00030f96c23c9803e16aaa26245b147616e87a7771d287a64067890f6e01a135a92c2aefaa366cbc1f584719f9208c22ddafd880be30ed4bbeb4786b86e751917152a94feb6cc80fe67da7ae2c6f2a5fded12ad3198b813038f966781e0763434cfa13dbbe77d7a946ebedad03e6f5d9bce79f3f614d95dbfd2e2860e41cff5c20a4cd6489068f879e0af3d446d49e22307ba2d46cbe75f395c3b5da130ffd0e1745143fbeec85471bdb0f78039cbd51bc69d72df87e9df40b9151c123eb5ab5c522f9859b5199f7284ceb5e08a52f9966f6b2626f412032403a3cb4c849c71ae5dc1257cbd11012409a40d3cfb0d4c24ec395088f7d04e24ec4eb91dcda41df10a7cff15834939b74946a663b0d800867b483091f99e2deace7a8ce9afb6e1247a0c20968c374782979548fa8a38731e12b602d017d6dd1a4a2dc434c34f6f3c8029cad4db19919cee2452c7b2490e2bb448e594488da37efc190ed0dbbb3646ff0a30da65595c856a68eeb19162eb63336d374158eacd6aa87d1d6d589399089dc90c0fbd25b5f55d7d7f469bf858ec93cc912482235f0e6b44e8d82447a5ebbae758c5f9693aaaaaded009bb5917c86ac121b9e7930049723625ab66def70017ae3e3b6699ca71a8302c34b80fda077b1f4c6b576c5def663769a64235bb38ecdb733491ec3bda09d368e11461121d01acc1faf5a7a995d15c06deb5d903cded02298b727f4917c1eec2bb369221eddd73335231702a5cd9ffa16eb0c705828f585dc719eb002a28c1b33376b543e2c537995a7cd948d48a6bb0a8f53d5b28eb658650b3f82bd3e0183e265184f9104891a4e64828f0b8ba6a057105c207c04c6eacfc6ea2f831b374b5fdb489579b7f0ccda44268cc01150787304b0325827b9314e4a39e62e3d699bc6b1d2ca8c4d7dccc73e15fca4a45b1c6b1ea7a881482929809a949cca29c8143cc74f1da6353cbd34e38ca1be87d172520b16f2783bf24d24efab52e95110931312518e88fd90a9a5f4fc43f309e10a95cadf3774189887758f25c70ed8d29d703bbfa8cdf28ffc22ad7f70b3c857b075cea935dfcf4f4b65b79a051a6a0d25e04d2394951d217a4d4fa5190bb8c98c793470c4768657f122b80c12fac80880bde41ac044c0cb528a0b7d19f055eb77c7fa4c094fe91a98e05187289542135a24cc551be676b7b8ae64733334355357f8bab47c669cee405cf20bdbc397902c5118f6edeb234a89d3975a37be073849cd73056bbdf7c31f879bd2aeec7738bc22442137303e7bd2b433d5fb9895c0c1cb229148e380b5846e30872b766cb9132a41b8b588b28f1a2a927493fee639d7079a95191d7adb8fd59b76ddf4a9f09532542fab80021160200a3c200f650fb24bb8902deccdca481b47f2f8ad810261d0a3dc92741fc11e1f1a075e074ae4d21ba92e36255102936a9d8c60525a579f8526cd47b028ded7a37c97ba2e371e882046d319a7362e60fd5caf82df8c43b2900c97a9401fb4fe34f617488ff20dc9677c6e9ef4180ebdaa31ee8540542ace06812c88736851152b6df99154bbf656cc1ae2902be08b48d6e30403fef49d9551ccd1eeb375da6e0245deb35524e702897811c7d692b65ab716420c380f7df0e701cc7e4459fcd5745c1687628019b34ac559b36aad08b9c157fefe9a6dd3d7259cf8f12170e7f6862330a701d3e8aa5eb44bb6d700e2a19e3dd75749c2d3e9b6b36a5f3128d583a7ceff785fe42ba9873fa04f79254b74eb7243562f9ddfec33a6622d890ee829ddb3361c744559d955bd4e9a61ecbbc0b46f59d564ec72846b016cc5457083b2476193b7176c58bec05ee8121d3aac4fc1a99b4e01c7dd05e48fc438274b27a0062a8cb389f34793d9ee77b7bd024ae2a65b868c45d90fdec89e3c91b3c648d6ba76190b71ca6f9b50dc4d94876dbeaa83a6be5dd4023b546a4a1ff66630a4bdb7c71d0bfa53ccd734f0df1a34ccda4867c7a234943e78d5fec37e2410419390eab73df5d26a5e222bbd6679fdaf654fb4c1ea0311fc66b8d04ca8ba75f9cf76fc44660bc6dc78278fdbd558b1ce599a3c8f854db690f5b9e6d56b6183382a156eae0132e7a516a94b76eca5a9850d7f1e18297b185692e5eac965fb414942f1a1840dc2647dabc2f761fd0edf88c916bbbba313c247987beb1f6cb8c5751d672f93e114dc325a6c8227c517eaddaf9a494c198e3bbc26dbee95645acd44dff0e14329d123f551c23bd64eafebf9c0ba90eb36602fbdbd2f91426b96846a29575284f95a5523d2f8e2184f2c21282da2837bcf41b782ee72888f22686fd0c4c6472647828711232cc526ab45ff3cc2965e22c1bf66ffdcec8ca38b3d38771aa2f7b199814a2dc76ab6c7ef83c1a9a495dd857591ab0d7b33f5606a1763bd88c144964d00f627506d9da7bd80bf27664713cf45f2fc174c8888481a006c26afe9e4d4fb05cba4279ea70c97374b0f1728fe9b013ec5d562394b8967a162c2eb8bec35b8cc20bb37e14a7c40275481183f23abedb1abe7d5a0dafe160dde537dff99b37e0eaf998f4f782d531cf27fe8cc50b1e90ae68c0f343f67ab0fecaa50d75b8fe7e529b9aa31ddfc3c4ba8bd06e90accdbf69f2007bd0cbf48616c560f3e264be207206d2c493523179071c4cc3cfcbfaf274add44c182294af7ea3a277a4ac4d3fcc3b4b6fa77cff58d485df3b59f898624f1656dfeb8282ebfa5ad3062e43ab6b3c2e7bb1434b61d9b97f8ae6689ba78a8e0d9499344b579b11d7d28a1a18032f83008b74063b8ed131b42a8b507b579f50c3800ebafc298e5316d53dab7ecd502da624b42f6354462eff049e19f48e0f45b5d4785bd73b5a540cf98f711552ca4521a38e35d9294d159316ba8a55b8b092442fdc6baad7cc6d27e63ab05cf1289f3a921f696565aa92fc8d2e6dd386910407ee7d06ce571e24d408ade70f0e57e3c42180d525df5132ae961e08a02e0848ab96f526631e01fdc4ecdb55197c867873b046b43ea07010896cd7106ea9ad8e6c2007e563dd5977e20bea40a9a4f9af92086363cd5022e6b917f589e66f6f98f3d9b8ff14584b21d36398292199190dd42bfd49e18a79252d749b8525c7ee84a1d1f454354e116e7b3c1965c00114061913581f9d7f7e15fc493e56b2e8af1e9705d66f1337f5331ae21732240fdb6a417dc843b42802176d521883de70619d4df41ba0b94c97e79e36b32da5ca409a9550a0605b18285f9068fd0fdcc07ac61ee60b126ed83343ac3f961405857ce5952cd0700010a7930d142902447a08698bd017203c9cf31c5c2b4ff2e6cd3f83bd80fad05920dcb4f11235f5fcea98b551369526d0c971d8a7dd15eca4a7dc2468f555ebf15479d6b523fcc649714a9ae2823147f58849928350605abce12f30596a82e12c17039bc2b65c83fee79ab5c95c0def223dd04a1799c3cba19a9b5758621b2b4f9e70f31e98c6460ac90631d36b2ce5fd7319f5fcb0757a212fc0d69f6198b4f370cbe764f795a8778f4de2fc20c9ebe6bf748d6584b7c96faf3cb353eff93e45c636a3c6aea7054d00b6feaa06ea194dc11a1d7ce06108f8574dc59f7019d48a8e80e3bb9a23c531b0fe6a7c910e76d85cb688519c7e8ded38ee135a6a963832f73bd8173c6ff2d6f3f4f2658a029ef21a40f5d302ca61f110f76fc3a42ce49cdae06368b663605d56486dcf729b2eb0251aa554c0f0124c7c1c1be06f2dfd9601a94f20d647b545005a91e53aca076f82d05db4abbe4077bc7de80348f4f8c278bd2e6e234da3ede465b3931e2b5bd7b8cb5b52765fa94f9638107f1f0b2b78fe8709f84f92152750066aea3f637c1c2971a570d22794715bb25069a3585852d37e948ab96b237cb57e3df564c17f0b308a98561bcebd12927913feec8ced7e2737f888cafe38d70b69e69ac6d471ce8418d482d3e73b5131b80237da17d1aa6c1d301f33c97b24130c03d6d8537e232fe19884389cd46446d10071724eab1afb35e7d59b5e57b67db116cec5f48178420c15743e71d46ea71e39f037a9d378446e9901951e71a71d030e530322d7d4d29da04f164eacf7a5562b24efe7ff3d9cb8c519c49f352da0de214e051eb12a88c0f750a2bc17985c3b2e059b4f3431d90c11243fc942dd48761b36069cc78b9a553cfe33b58f751672354a5ef2738df040e4b3d062a6561bba6089b5bf1c68d41cffd75a02100c6384795ffd47331fac881dc4197bd95e00d976a8ce27b585dc79a705811188154896ba5aeb607d2c03ddbcae69c01f5a1b0eedf124b1401682a3fb80c6d89ff8c3cf4aa5cba9d9ee39f7171125cb073f69a6ced41f497e7cdf3149acbf1a193cf1453f8b2034beb64ab22aad27bcf0d518aa346c2b494492ac0060b1fa2dba47bc8e79e061ddc09fb5d6c19a45bdc1cd99f23e02f36ce7878418abceb3174bbe3bcb8fca40b6cc4447b72fde9db3e62a1375b8c6a6f12eb93e00736f0710bab09ae34fb2724fd685f3a149843d2d35b755315f8ecb41b0212703726479d0b3a25650b49106b4498ad0b58df4e9772ea8d7aa1fbd577c32d5eb22df6f8cfba398b7bff258dbfdd00b4d06b1a9fd85fa04fdf2ccdafebbf9f7cb16abeeb0b85b58fbff07ac9f270ad93126f5719954009653269243c11d44f7a32a6e25ae2cb579aed54f187f3e38864355c4bccbf141239910eb9bf0c79a98490443703cbcc89269c3949578a2b0d39db604abf06d4bd16020348f4994cf8c8d1e7705eb89c2ac0b993fac0a51b916a8453d645673307bcf47e35c97fc9950798aec2d746d3b9caeb891bcfeeef28022b41b5be8f1278cb40d318dac171d61b66e3314441858f8337fc070e0496d084d069c4b88c1717a8bf92a0a2a2e27753074cb7b1bcd1ba80516d5537055ad779689363f7a23325976ad71b8d4ee8c540cc75b8440eb7082caef6aca1b370e6b2282df88e8ae45ee1ba3de5917ecda9c76c107b8fb18a3b54074ae0faba3b60cf64557e88b16f85542c638dbca630d2000f8199ca9d5aaeb38a4240c3450762fe0e92d3c9f7ddeaba360f837192a56b6ac987659d182677af71b19b1ab2481599499d39d37886195af63c8b686a7fb8eb3f591e1ca5c76971b515217017b3c567b6dc1322cb233b637265e116e6f3749de81218d7cf31feedb95c08089e299ce2114d218e200a46c5fb3240929b841df39bf0e6d37675b246c5feffa0ac49cc231ebd897e54e2b2a295c697bdcca222b8c832c250c0f33e605b22f148471ada757dea2fadec3e8e02206b33465d8d6c0e794a1b482ccf6047fd0e1d5ec947e87121fa78cbbdc59a4a29ee3eccfcb3ea52fb6682b226098cf2ecdbb5497a4bfc0a78c2adcb70297d2bb0044742d914bf0f0b0a94a163fbb4dc882b3a6a9ff936f128fe847164b6e4e4db59562dfba4a3a449af904a7a41312e8a6110762748dd200b64efdbf896b6c7a23322e4994ec697028d183d2dac07ae35a7fbef90983445b7483cad6070149dcb9d8cfb8dbadda8a12468e0914751204e6e9c74410e9c9f37b059ffa01d25f32ba55f33838939029bda226ac3798b4187e26ba876f11eb47a8463c525e232c9b7973d6d56e207ba0ee5b9b43eca097aab840ccac0a364b585e058c6be0bde2d0e7dc0b7ffe25a84cc7b7fc87c5b2b2e2a753d57d2089717181cfe183559c7222561791892fe0f076ee876807d8873fca7b785aa40d68161907356054e77931b848bfbe147bf636ed844f400811195375e43ceaeecd1f86254004718b2357f5145fcc6894766b249d811a95936efb071a9585b69b6bf220b290ca66c8461e69542b532872e18173b23311d7fc1c70cd2f7ad6536a5d3aeecb42d47ba14f4cc8cd5164261e9d703c3ef706ff2746589e3d469c6c0f786fa93b4b5e1261224485293642a5248f2b3d20621e49444ec493650ee6c0e1c5f9af8e2072b8a9b88da0bdf2fd77662da6afc7b699f962f32bd81fc875800fae0bf511847359d62a947aa155fefd1f8c52046a98f43adfe3b9a352281b4e67c6fa7282d684e8922b09210b032eb4fda698772039e8d7a2a0f25b3a822d081a24cbb1330097053d0b293030e1892e47d842a347e2bbe161a2a4883ff17625b040e5caedbeb2e089dbf39e27bca8d13b7ecea2ba37e7af84e0a8135ef289faff2cc4c19ec1cf597fa081bf35a00a20e352761bf9fecde8dace6a489288168875b4f8afa47ad40401328f72be4b2357bbb5871348d2f1602d878678731fb1dfaf6b645f40729218e04903919056dc511245f50853524631baa46b49c835708428c964c1d9f3c504118b47b75724539cb6959ad03baeeb39d0a40e155a96bf546366d6df78a9f7e7ec3b28699fcf4ee7bbaf5310db15d53307ae3b56870be62fbc85671a67e00a27e66761e052a2000aa7194dfb5dee11f511d1cb75ce14e0493542e8a0c659234ef563e8550a715957edd1020766ef2191375f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
