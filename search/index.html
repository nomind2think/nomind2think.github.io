<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70ae25a4ea7d82a55681d8a2a98aae1ae512f7b66438b1edfca4443c7dc0c9dac74254dd0bb3387f07a0632cee7056a13c50e0fb00b053a58ffe887729f15519566a3394a1cd2b2dd3c91b387140b67b908a2fbbd07adaca894e20feaf0d61e260ff758f5b514653c4de3eaf0fee46861ce967fff54baea492f6acac172eeb64608f3b18469e336ec6d2484f7d29d6b0c59b469608906c8b78f4ec31962d4fdf749e3f58d96e4f564c7a9b3834f924a28c62567faef57e047e5e5958e967e06b099846dd4441d42b5bb6748eea646c3eec1b4c3993e05015d9e9be1a436b6997a186bcfd15309128f0bbeb7d024f7483afd747280ef6a1ca5c41c0c81f03d96020fe72c82823683bcac9dc9fa3a4bb22516fddcc3b1a4622758cec6bba3e168ceda330e4539b72892da09cde3f509f700974bd29e6c152b55bbd1cf568e1e0be43a5bbd60cb7ea7cc511c1050c0b4ae94aaeb4ff4f2186bfa85b50be011aec7f9918f5c3c61431454cd956d18ab69468e3c5f46eb7597a09ed5623d69f793be4d4fce25852c6ab85f4c9ceafd671065218854c53aca9a9c3e98030705912b503c2672e4b5a5a34af53d9f9d79adaa880e3524894ef61f8e01830bfe854845a586cf6b88f1724e64fcb52f7ba54abfd3769aa6c9adc3b9b8d7c8e0e457970f2c636c6e70e0a62597d8d40191dd75b093a68f72c3c51820a7448ed7532cb9b9ed3591efdf9e31b737929da6ae4107bfe0fc13ccbd1351808079be43fdea06123b13c61298250799e433f8d208b04265a5100fcd8060a1ae186e278e41f1982a79fb61064d1970514f1163cf9d8b4d329cd2864a8d904c0f1a0e23cd37b673a25a037a6c54709ab25b12a92faec7a5217ae998669bde438d5d02b08e77ff21cb59c0bb187d04671dc5dea9d94eb3b1a080718d084471173100dec1c1b05d67f1d254ca1afdcd6162749ec0b4916179797fab6e6ca8d0314bca59f7ae955f084938d693b3ab104dee747abca09f70f125691e80a1d94c859ebaa6b07a87259faf53759ea3d6af4242e6e0ae57293afee3cbb972ccbaf75e599b935b26c00e1318f7a6b32a45985e356fc1fe857e1c6652f389af096e7a04a22b74e74d1bad222880e6acabb8ff065f9897f7f6d88c9d33c836716c18a1d757c6514b5f075d8b49a9a9b01efe079e067a0dd189ad17a42bad51c57dedd8a0deb322aff6f4ebed5d1e9906e50f83f49290f4c40a8591ee8995bd88c7f25d144c9da2c5e778586599f35d1690f42930fe7d320caa895346f4a66a67838c535a78b694f5ebe220c15069ec100bf6886a1ba4f2bdfd7a0df14f91b6079ede4dc4a3a65b4d252c899b2fdf3aa06573891474c90353812b27a2dae012049c89f780932dabd3e24a644ad784930ccbae26a47e76cee9d3c726709c18cd2939fbb44d91971b86419d7d154585e8d5936fe26eebb98f57dc44a11c51ea167fdb0632e5d7fdb029dc55e45bd42b59885a29812967b32982ed85b8d74d5c6b50b51372a5919d6dd47a0d0efef66f04e6719dcc6c7165525a4e3321338a4ef1adb620bddac33e16a8f24cfb57638c8fe7fed607728b370c8f57ebb41c709f31e3e822523843d7f29cb6a9e7323081590af510280efa1a2cc2bfb67c046baf039c4e93154a1c2151598797c15db4cdc0d08582c4744e817a88feecfb60b1ef790b59deb8542e7811cbfbaf27f23c6a07a35da999f1b5a18bb6780b447c90ecf6d961e89858d60f08000659cd52d22d72666aba52646b0dbc75aae70647dc349912b7c94c4f5682caa900d95b5c2a4c68344f312360bd31cbaba82c75d9ffae7ce5d64b6310c862dd434f4c16036c4adf503946cf0602cf2f0026c3904369c4df99b692f4ef1680f61c4443a6af1ccd2bff000e253ebc207261060011ab3de4701936f699c09156686a366b86bc1d90d424311297482b51b0681b8e2e370a0a83ab8719d07137a5f879d7eb033052cfc2ec41312c46c010e8563f00c851ed4161b9dba38354c38c36e32179a8eb6b4725dd5bd656f388e8570e24797f01b6df7481bedb312500e99c7afb63f03ba0fae37da5e2cf639273928da1b17ba83e3bc58143361474c8b09fb5236112ba3d5a8df43045597fa0a2871cfa57f2326e6bd70d5637d0c51288179a364395500e785755be19c2d391058c059e76ce1c502293fd9ceb85e47bd3f03c00a45d99163d5aa22a4a7c020e276697b1dc6e410ae98c66f7e27e91ff83c8c42084a446a4d9aa12dc09c07e93ffff4fed647ae128d3af18bb0ac986108040f0b307d23be1a3bbfb70664286d42bd54d83e83de2c02b49b2bc94ee264e8253ecd2578ebcf93232c9e8e9bc18cd2b0f06d563742ca29e5567908ace8aa8045ca6e83a7cd48d6e6e49ab85be2edb1217580bdacc06a087807f97df4eab93db61c499d96257cfd662187ac95a24eadf1dbcef51c94b2edba3b15bc9e4a1e59de6c7708d82fb4126a189d76c0269fe6de5a004882693cdde01573e4d95c05cc438f0df4ba3080b157e52674eac3cd23a12fb153a2adef64caf572ab7ccf685cddbd79be13c78aed7d4fac6f62a9fe004590dcdce40bc8e35f225ca725249c438216a035442adf09ea2b882c0e625e105b2fa69e5453f6ff977d7c7e3d74cf488d7cd33a3384d7fa65c4c149ad36b1a3f3dabe7bfa1246a80acfd8ed5926c4b28f8f9b3df87eb825edfa7c5dddd2ecba1e9837ebb10a563641433efbd4a8c31e3e4c53db150ccdf49db126e591d33a91ca2bc213808bcd55890af53e9413ca9a4f42deaea806c4b04e2a4c460e4cc6ecfb3daac6851df8204fd3e8566675cb9e35f8d5af6bf5176838e629e4e630e038981e4e239165ee10b4e29c8174b938339f911efcafb436f36ebf60dac6ede736ec14420dd5280dd41e6f3984a834faa469edc8133a8dfe1492dbfdb8c224ddacd1752b21299173f9d4506db15db2bc6adac18d97bc2c047261c7b7fc3f1ed163fa03155fa0e544f13ec80bb19b894bf2529e767a461f8fe3b0e5a04d355c92b25d5855ceeb3b79b8fc4a9707c18783cd16e1b8f95daab888012d2b8b6e7d2218a7f9ce8bcc9cce7d183eff5f04b81420b04abbee906533b35d44b09a7c6335694a191b8608c9673fdce827663fe7bd8af8bf19a859bf19043545260fd246c16e5b04b84f3b9348f3afe70e2adfce6df525d081eb6a675ac2289329c5c594723720197a473058602f6ec91a03422bf48f74dfdfcd6611c002a9728627a2ddc5f5f28d6c67a599ae992d7b457e3f60b623616dbfe5781fb2558af04f3a99d174e2121b94fea1062fe381d98da1660e54023dc42b915664fda961932ca535f7f2a7d987a777d9a22e46c8f4bc4758b9d5882df66f626910c7e13deaf657bf57ad69858a1bb61080d52b34918abab8ccd432a61e0de7e98d540376937e66f408f594fdc7538465d4d8e9fdd5711e85c0533953eeb1bf74f7d34a8564d0227afa9b85797e1968ce375b8417095ea39ae790053be26e976e4ea25c1e583a81f5f22cdc7dc6308329d9f891044fe32e7b8298fbe6a99257300829a4468ea325bd930dfb71c317c0374840e63bc8a7df4f5df9a66f98e48bf9ee0bfa0ccf278faac8c12e78b0af699009cc675ed31e938d62847fbaf1dc111abdc53ae9f2d1ca9d362b06c363a9319d3dad1ea46dcf7ede1839bbc312ac3f0a03e3462202174d94ce6b8bb3780af3afb958a378dee5bd40293f144d1bcefd0dc602cb6e3d2b829527c2e919431a4c300187fde1ae2cb65790380977103c409bc5a0d313aa7eb6f617530a39138c1857d4db155a54773ff27b5156dce68756fe099ee72f6680d95f7a7a1a94a95f67347903ef7cd43ea3d8ed415702364dcf5e789606f8a9772b2e6d4cc02f3ea53918e0300a8197de5807a3824c9193a6490950be48415e6a9b6e977306e6417717eb8a9fa6611d1eda6943c56e1d0f014fb6b7bbfa7b17f52b4ca2215f710ba01e5ec94e55c3727a27fa9060e14bdba62f82b22acccadf64042b3a644834e643dd1133bb6dab879a6d9e5f980968d297c1256aa12937a5746e395a52f40275090c9adc52c8df79dec02dbf16e3913d790f3b280c2f4936649a5920ecbc3af2d73a69c9bfd1bf7ab54ead5d1694078fc29d8c403244758d2d370e72c03afd5556e52ff95860f435044d88c2412d6d2440f3154840ae6f7a81c73eca93e32ef8f862d71b2fb37ed7b2c7cc487a6d512f09ab62da917c99a23fd81fe0dd4f78bf1682fab901085be6d6af57d33b253bc02d25a62dad54d226f3a633fd6cecc626c538690ba5d50b8d4ce72aa7a6c13f6e6f25d04dc3e3e3e48a6ff5b8d519456d6acd2fdd448fe18e46e7a9e91735afadc8549436505967c94c0d5f568ac8ee652852d6a076aee49ee335f2d54fa1988e78e3f0b4c01356bf53f8daa2204585119c68ef44552b3a7d705272311ee9338001542ca9e450b4da13d9c415b1ef15dc0d0a60ad74d44984fa9dd73c5991d699a8a85f3d65fd49327bea77eb36b1a423495549310b89444b5e5d838ba776893b864bd65eaceb3af67763bc6ab9d927372a4e1e3b0dfcc31470539f866e5d7460f2dc9167d94b2002615eed02cef8cb494432db8dcd1b7658e8992ba91a796a58605b87aef1094dcb4a5ae39065291fe8bdae0ee3a908a311ab17eafceb9a7d0ecbe14aa6547a8b2903c736d63b6fa61bdd76e282a8cd45ddb10722f70a9d089366b5cf670558edba32a6d8d112c7994da985510184f61b14952c228844741d5c5aa5569f5ec85c097a7e133619b4e7a9e16cc0a772eb58fcef88e70f54d931cb488079ed8be00696e73de10555c8329d234f9e979ee340babca004f2e02ab07141312e0e191c1f32b9f4776570b241a4ed986b8c3d4c5bf00d5d388a495f8c826d62a99a06c132c714f3e0f85c52c0993d83f33e6068d095ff298e2438f018e969d300412cce01af3912790c6987ffa8087aea6125e88265cfb2849acb8fc65dc1364178ec9d8ae07e5d38a2bee047262e2ae48deaebf7cd5d7f7e693aa95fcc8c4912f8554756921c6b3c7cbaaaca2a1223149126438a02777fb69ef4a88a7208a133676c60976aae93fbf9f05c1e896e638b03f3ffe03a164dc4a8ca9860573e77f15bb5e23635965bd5cb07a59c10a18fa7ec85bf083ab5c1fa4fa001395edbdfae205ea54bae13730366a6f06b0a12f61d7cec8b6d196a0973d1e28ee2f0b290752fc06d32cbf42ee8aae1c88fe3795c13402e4046c34d644332e314c00ec1eb9cf4a3f2835388b91571c7dc089360c99ca5672034a1d19ff689fc3fd5120a294f1b92472b28877a98430f26d635a94a7d86fd27966d3304f05f68240b258f428e9643b2b0ba0361c105ba16bf739d5dd921423c40f98f53c3c472edbd9bdc27eab6a50c87a1fdf6c783d5a88768807ffe996bea38f9c3141b7e0c1983e4739ac287cc7e30d4428de7e67ddb3397084bdb7014ccf6f6a86254869d1a51639325fe8e685f4d73aa6a1222b409c0cfc4dc9152f07cc44b8d34e8da519eaa86b08995c32654ffe148f9aa8ed7c1da62289d3bd961d40578016c9abf000ab3fd38f4610fed03fa53aa3c164304ef0a0bdf47838dc8d0cf08fe9582b6630ba8523c9c8f8430e843d5fd939eced5c0a2a0e597281c3df5dda7ac3a6057634323e956a766121f2c3d3b1fe71b242f29aeef8677eb97ba71495567acbec1de8b5e352ddfe82ac11831f862246244eb5649ba7173dac2160d045afa24c6ac83187a300d2e9fe706425803486fc02e78dc33e95eedec4f0222a59869f16850d5fea49ffce88d33da6d325a19c87b0f51d34008d13c87ba5727e9785c5cd0e4d85be269cf70ed60be9d575e3aee194e11422b6958ba65cdf24f5b760855a9beb46afa7b9fa3a173741c9df8a4c7da77a0980162088be2927825c45839a10e0bb2fb203410dd9417fdc039c99bd9632c3a8638b9a29365ea6c18849453a54d0ae7f13b1d1ecf4f216ae64edd25c92b6f87ec1550b8ce259b3ec8b0673cd91569cdad55fb9fbdb3056d2cb940fd62a48a164bbb42dce24903020ef1b06ff44b5127cf689e3948fa8df31646feff74d49e8d426bdff4ff7812efab3518cef72d326824f55e492fac2eecdccfcb5af0d9e069bfa1e33efddc097e794bb67b9a910e85c18c6478649d17d4372a958dcda12e509459723b94482ddd521cb1fdeb9c8ce27a866311161dfdf5af7068e739610d004b991e792f960bfc96edb1c5a22614540b08ee1fb342b75604a81eb430a4b6b30a625fb7e79156a0a740c344d0a82291af47b3c2b41a0338aa609eb895486a158b14a55d45709e29daef12f7d6271da70d90430d54f5b30cb6c6812134fb76338128673df586c149b4f603a9e48fdc4ebf9d58981fd26a79b58d457739480d4ee92786259189d5c1fbafa7ca258eb608d8da0545450823126caf343273db8b4e8e2132571423eafebfb2f44f49e05e5a9e87bd475c33ca277758e3d7174e3cc913c5b0b026c6ef817b0bb7aab4d02edb5e17ba5e2065bbd91a1f1860c8cbf969641c68cd86a7378e31a92d8707ce9d14459659451156637d92aac7fd03e8548ef7bb89b8b07c5859e2da308987b28beb698086b8579d7622d6f56807f4264245369e41347e24e374fac4119595c65c893cef2c0c0ab94df2c10644dd6edad8271dc43d81fd1a5bdc79fa094a76cb2edc1d483dc8c111f347d99e2c2ea79a39422c85d19cf959c6df505436b1cde8c0570c9bd4cca07e831b7d3f062870f3137eaf6aa486b7b0c4496b5454088ad7caca6a0be85854774846405a3d659cecec16f1ad3de593b812d89b979e09377093884cae4d3502d21d8f5036527b0d9663791bd432f3e477001a82b3380939732621a170253a927c43980bcc4cff88ddf1ce82a80bcaf05bbad9050a59c5ab3efffd1d6307a5e5a7fddaa44fe58fb76cc5e12f67dbcbced5d5f6e754314ed065f2e71b66fcc5843b28ce4707a9052e043c065c9dd1f2b420940b6de92ed110e2e1b04594a8fec6cf37b442501a2a75d155f680d4ca58656af5e6a360a9977376e01de785076a1c0b624d47adeab32e2040d81408f485da261a0c47ed3f261e1f2f6e8b9fbf58999faf2302ed3a62d042a23e4a39d0fa2b3be08bcfdd95a9cbcf83890725ee47265ae49ec180ec52cd275113df24ad43aa9d0f4c796463a4e9ee99b3ba2e0e8c9607b3074aaeb40a5c6ba638272bcd4a3512256ae0672043956afe56e090d6bc3b08e4765858487ff54721c99924b4146ba1f322b90376f07d135a4e5f4794a60e24788ff024be271c8ea5803e5fd98b66c46a0a3a4d75a0a55513cc103de0abc74c32ecda13dd4fd30f24f72b533d9466e0f410a789187859b20014ff222ff4cb193eb4e607c8e4881a785f45d7066f38699bc23507d5cf6ea04e8483091af1ad36871f2e35857a77f40fa28c63d40f29ca2081c9c3432e0234120a7ff1e92294d69c8de856f9ac49dc741c809ce07d2ca999e45d3028efb604b901313bb6a712d917960c93bb61e4faf75a52ab568a5244c787bcefa13295282371480fbc878fa0dc4ce280e93f1e66d9b2b12e534a5b48f95043a81e4d4800590bf344029a84e7edb6a4e4e7ecfffa110dc16ef98f7f4cd1f5596c89ca1770ee213a93b0fe89485c1f398b5e26f0ec43cf3c8e6d359fa37add8d4da0bba86b572528c2069f1b2a615df5f4d695beadad9c5442b9bf8dd9f5dd105261c625c72447578787f5f78c78d544997964965e36289d47e62ab7fb586ef56070556c91ef7d76b59ed3ddbad4248c4b3681cd08408c6a6be9e5774ad69b895eafced0d92a1a4a8daa09d56d4c619243e6478e528d77b4b6bb16f7f79e1a656c3a61c8d30190952bc4226f544574f17454554bfa123530aeb1d3aea08f72ecc84be072a4e30e96cd640e4ca8857410bf4c4befa9e06acce6a8b276aecfb6d19eda401f28a815884b40c62fd535501576e64798edd1987b0e9b3a9e5db9719903befef13c0c56db9e4690772cc1d270ffec823f8f4efa24a00efd28b36468fa771371876bee52240a7738c1c1a4bfffddc21648123e0b08281ac96af978a2be08d6386519d8797dd2392c16840e2dd8b9778ad110da5bb330f5070d905209d1a56574d7a9fed7e768c181a7599574ad1daabde534db036dd625d88a81ef9a3589398acf70b991614dec68b41dc2a15716a5f2128e64f28bcb99794155e2a6be7d17a690bcbe7fca8b0a9496496faacdeef9b59def45a6bd8e57ff237d5196ae6aeff8ed0a0ba54f7ea5dc3825b9c64a618ab8afc491a2ca87daf3e97a8e9b3068fef90a97bf484b23512fb6d411dee915ea8ac92e6f299bdfa5780cf9ec6fb7cb6bb245b109f8aac57ffb056d916f8a4ccfb5dbe7374562198622af93bb5fcdffad0c65cc6586164c055582f8dd86a6a21c66f60a3b3fdc6cb520ec4a38653b7fbbbe77a8ae7a067e7fcab1a1d07dc285f9983e293bc3f0d512240d25cc675a6b647700371711acc2e02cae68d651256e1a0600382699455da8010814f5231a6dc3acd10dd0aa6a4c8f80efdb4928e32425dc7cfe087a396b31ef9c4c5c145bac1d8aea8d643ba53bb83f6a9bee8082ebe82ec5272c2977a83d7ca860b530ef2691be668af6f956939922b045228f3735be3852559fe51c679e833514e71e512f0c04c68a35981c5e62b8add855a3a3d01c6f6468937e408f3b51c9f0d7b5204f984ee9b92a4715e30daca5ded18f7fd44f487e9c269f985a7b82b8f7d15c8e686b2cd6683c90f04bca7cc4f37bc085c8e9a898d133ae19c958dd6d86151883352b4d19bc8c0f08f7190877daa12788762bc65c7d8e422956796b767082a9fe9b29afe6828a95ea9ad2de6f08d3236db193032fae18b31baf747b9845a8dee644a879db60d1ce6b2454dbd0f96fc64c0d8751a2cc532ff3d1d8392be8c98f7a7c5ebd67c9fefcc0c24107addb6c360cdeddaf76351c364a0a869460d0250cc71cd8f994bfea8227f68a29ea111fd8d07d18cc6ed182166b90f366d497dc30e1289230e9ef912799102b36f37320c0fe66dc25be769d89ac74428ec1f8008fb1c743044736eba60b416a0466b373f5a2d82a2c06011c9e0b3bebf4af4ac5228f6257b7ca00e7fbc4ef1610dd87328d1c5aece30853929985fe2339de189b8a09b2ab1928f6df08a31f84c3b9bc6ec7b0be0e8a4513ee6c1e86c9f44d20958dde2fe6f2d03a3e5065266bf291ce8ccde08029f5e212c74da68828079bb981c68719618055719cad34e2222933e14d77931d32b3c5acfa999034a555ed179c23e4179fff087674d0cfb008869b59151705a38b26b72afd0763c791332dcb019187bafa4cce6170b0c1f5b5c2ffbd7c3e904d736bd8de395b37e35b89f5cd71849c2c579ac578ae0ae8472be66cf7565de3906d8d89913b90d09e9bb3e9d8551d5535f8bed83b6a81932ead03208872bc62879b8832f64480aadab72d5d4edc8f0636770e5d25e3b63d7a00423fe6f898f89874c4b807e83f087161b86204d95899dac7327538d3004aa09380288a08dccd40d3540ffca2f2bcd6a6ce02581a3c22fcbb948f0dea99eb844b8588aed1285c748ed9d069f1155ee26a611d3b87b4c73eba2b52d667961f89a732ad8da69c7f4316512bd7dbfe9c2ba3657ba75960d13f4bfa674e971b0cb527929d96f2f5aeb42476796cf3aa30b6b53f05a654450716c1b1dc2ddaad0a38d752c7208d16884544d95df4504afe84750d5563781dc3e6639279cde9be8d609bbf51cfd44fb45bdb64eaa1d7166c383b3a3865269e1d2d45b514f9d173b42e88e33bebd3c858b641b2de909d24cc79b4ebe4635335fa763f6119641fd96b519b55573e96dc47027747ca1ebdc63f28a8b82a625e47ec68f626233c2ad810fa1eecffcba7cfe901426b7f35821e76398d44ac3bf6b666a766e400383ecf6de889bbb096f275a323630d5b3b53a69ec62f34e0ecab3126981e3e547118857e22947c2be7b31e7e05847e0c47474337d012b83d40a65465d17b0bed9dcbf7575e8ce0e5dc163efc1a3bfd52e76a772da2bc2b8340054a07bb2e234bcbbdbc10ce894a7e262f55ecc0fe570066d8547528c1e133f65eee07ad03161f5029e95abdd18951e988297734ace6f8aff87d152d00f999e28dfb39191a9a351d3dd45563c35aa91a89ad80263f931a5fb82a173b69fecdea01998fa4dee3cd46d56957eaedb1da94a60dc019b7b2c79f1d1a802681e5946bad313830c7347f7ecc6e0bb745358909d03a6db207551d5f7c7d9f3abef43ac5e91317e2fe7736e580868d4ae374f4d784ace99844bd8860825cca57610e5652633e13e3ca426d71bbb28d4b4b32c856331fa06fe07bc08b07c32c33822d7e7ccff33a5c8bc6c56097f109a582e81f1e8958e898497cac7e28f970ba5e32786ce8596cfb8161fa9002881d9bc8141f7b56d3fac29c69d5e4603c7361173093920242416a56097cf5dc8961995bbd813c18f4a2a161a0044e5d6b3b8cc36cd3ebaa8a2dc5167d2fa714e57611ac8d1c1239e6719f176cbabafe14b2f357ad237c58c05eff6b90fa1951ce8f1e09a410c986d41324cd29e46e5da75a0a56836dcc0cb7a1cf418d8522028fd50384cf8a8d9dce09f321a6683ef7307a88dee0d3a95a7ce5df18c4eee733390b3f256b75b9cdca8c0c49e0b1739b3fd9804d9418c7d9ebd9ca2425ef9b43bccd4dac4fa23b6d7e017637ae048f6945fe527cb76a0a7f1f3434f033620c502522d0b6d761adb1af9e6e0148a259e6d17790b62352f8939e10ff8ecd32dda228aa69ae4505acb4eacc57c624cd1eee0557418b29504a1a56a9b201f02ed647da3d8b528f53d4fae4384840b22fc4d612e3325fe7d2c4d7d01953979f9a64496496eb8cb0c4f369d010c81c9f33c088f551f4e31157a238f9080aba153f62a0c11b9444622ddea3dc72368d67b0dce3bbdf06201e2b2b0af4e9febdc6d635f219e69d2140ffeecb2804640a64dca52595b95fc7e57ae0f53a426a03df16f1e7aea8c562b51ef948b064ade29d87e66c288e25ac396ace081d6033f46ebe05410e51ad52c96a2cd4a24377fab4dad40f861b5b6f0c243126d74e8b7c73a6198f2919dafb683dad4d05efd06fdbdb3bdeb22f4fcd6962795a9bd746","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
