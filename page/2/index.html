<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a66dea9c2257ba2569625ac0891e8b51692f2381bf3c01f0d70f0e2a2bbb22958d61e713d161c71960b2e8af6a0fadce8b8a6544cadbe4a02d9b3d94fcb8467c3636992eb36007270fec0271c683a6e8c7f9116e856cb870b456d92ad5f4c6001653f3c76f5c4ce45f1ec1eb3c43bdaf1f132d29160770cd501631a0bc5ca6e298454da2cb29dfe75aa6e4209b3350c416b5cf960c8a1ac165aa3f8e4997fd193e76f37761d85333dc20dda834a3923f490e54cbd6d8209bd3fcd1a72ecc1b108232a562f4a2d1e3ea0ae833c8756f52039e86031e3a586549ee7a6b4c9b3e529b6f7bf4cde2ba781c2874bd13f4d639f4020a6195cfff69fd4c8a7938d2d528c9c8ab26f02f8209cec48eb8b89139d53cefa63a72b292686d75551cf0c74fa6ca308ee03af1a4ba83b0a004d001d448ddefac0bc07c7d1a278bd27c8ea223094b0dc750cd98b70e7f2374b8460e40db1b0904424c32fca157acf26e8706b4c2fe2a5915fab4711404951311bed173978e485a98401b5eb0e7ea4427760e408600eeb15663335a4f0a9fc36bbb373bafc9763d790d22e4f2f5bfe819f6e0f2af24fb879d71615937c467c5069c706b78c4a0c410c99b73930daa9760d105d1d9420387ce48045de0989d0dc45432a76e8815baed66ed14df459bab960a4d4452528aae87a14e4ed44f99906576e12b80edfe3be452bb95097418f2884560a22c9666fe39c63e304f5cb26e5228db01622076a6217176d810dc388bcd39840ac7c573bbbbd62fe57d066204575356d516d289164db16c799813f17283de74809dd6a227bd56993f9752779f4b57883080e672e5bcd649f352810d041d298387d5baf8d3d8d7135bca09c6eff32e23aafbf6e4704c526405019935f67de5b9d61b454744459c19c880b2f724b3bc712c3eb87c465421fdd5432a5989e8cc88874bc570621e28da5c5f6f54602a4aaa8556ec1de4d4d85f6840a9f23514dee0bc439b7d365c6bb9bd07249f13073aa782901e3d9d10e8c73c03f9233f052698797b149b9e95259b74fcfb4b3491527c5e0e2121fad3c2a6f4b4ca4b8bf371eee66cb9911e172fadae692a31a66e648f815e0e9a27aff3f973bed59b87c4ce8ab30d5516925450ec17ce4c754b6afe4af0cb78cb79ef983df537f8cd1989553299b18bbad3fa3b0f005a44e588b21b62a3bcc7a70cbec8c7414ba67919a92ac5072b91d87efc247b3c5926d18b49c632e88a18db2dfd412ef3d2b01d7efe5a438aa19a521ceed609a0c899d74f73499f02ddfb0504e67c0193f6f521d3301f193adde826f83a8a5b13b1598a245f6f591883b8fd952423a4f7bb50a05cd24d56f75c2254fcfb887bd3f96910daf202c16e98ddcaba0f03268f1cfc0235a1bd65bbc56a751442b8900b1a28a5a267be345d69dce6d4f399c832c1e78995af6c5d2d9a347bcb6eaf30237c592097df644b2007f76c5db0b25281a02fe3b6d94834911e8fc39386fd84d6a058cbd7f742b5d49717dbf52fa65b6aa79235a656747f219d57c75078e0519f95f07d98e072440e47d13fa4c4a4b8ec1436f2311885d2fa67f8471c1a5f30cfda38f92447acdc5ea873946228e29bbc06244097efa6f5529edc4bd5824ede5a1caf3d31d1cbe0c2985fa6ce60b6367e7c2a649c413ecca1816a0ed21b1693da1c536e465393702131a7c848c2ae30cac42d39e3c44d4e2b813747e3642a1002aabd7859ef16e23c230c20dfb87e7063e993f837ef5a809804ca4f88aecd03cfcbf08fdee047dc5c080d70ac8fc1156ba4b6bbeb1b042dbe790f33639d90535b633d8e32e8c0fee268c767263c6fa273d0767ad06664ef743569ad355223e4faddfc98f7bd1c4e9ddbf94fec65637d14f4c739f07a5bcc7486f3a45f6df921a71bb1d5a78ddc25f8c99969e0bb50dfe64d2a79cd808500ad080cc362fe7ecf175288a67e335936304cc083411de251510273577aef3b2a447797c99dedded2e36f1acbcacc3e635bd45acfe9435795374e40cc3fdd490efd3c99f37645fd731aa06aafc5dbd3d0d86c054496a1ca2c93b14704d99eba009704311fea1692561d660639ce06e08eaec8a4c7397053f0e7853636c6f66e3d1ac9b0bb882664cda97c392efc777851066c5d3654a988f6deb8c471462aaeab0764610a318538f75ee0c3df5b6adf2bccf60f184b2dfd4d23ac0df21d61a13cc87ba4bbeb1032ee3383752f774cfb01f49304c8802ee991a36e3e3bc0b60546d6f9d04fb2dcb706036a7827938809d290e1ba65e4e84b52ecdbfb55ebbbfca16213699648ab1cb5b862f7aee06fbb34767166919bf9b4f89f5f6ae821adffb1eee49bd1322d4beec71ecd016c25ebfc1d10dd11526c61153257d03e836735ca8af14810e0fec458179eaaf25de3b9f58b8ea3e9c6323c091501b93245ec993f3b80172af2deaff7cd530dc0be4f5069fe6a5bbe92498f869067a8d5b76fe1e95de699c152a91de0167334c0ad88a29c0635e58b568709eae51ccaa9e938966a3d74806f6211cac817e12dc3757005dffb02d16649bac3c1f8c2411624e238dd6c78658f74c2a3d5cf87986cc04e4fefe0b1d49d6e71ba10c4353104926e2b7f16881048e5116b39a70fca21b51afecf39005acead21e1e70b9ad2f35c4e0af311c57b479e3a8074779d57c8414c656f4f07e2710d15e961d67826d788d606d14b959a84ed708961f872d548eb6d3dcbb51536d4f45b933dc8d8a546f43d7c89bcee6c1f8e1f11e0839e11e7fee957905d67383d3f8d6df343194a16e27da8f90ebc7f46a2cabee6bdaae7ea9a7e9e3780578a1ceb0eb35b321cddcafefe8cf98bccb0784c9a42cafc323696e64e20df0b1d7dab56429f8269eb5b2f6500a80951d566fadd0abe387ad15bfbe01b1afc36771f77d8d637be8b8a200ce63d16e6f13c3305d406cb1624f0eac2b13a8ec131b3dd97f343457553c3a80f558ea80f44ddc0845228c48e14bdcffd19f48ed741886d061d5a1c0bdc0c4c9cb27d58820ef426d9634d8e97fd7d0b844332f3316813414dc9e19a557b523c879973a3f87daedd56c48e6a7be6ab66db3df4995e61f9b240459e74b64eed80423efa67042c62f832f5f22ffa9277f4010ad5ae697dcbbd3ef2faaeb290db1cb48f99b816fd49d1c748bd20ccf3bde604f2f8d635c5659b3e0c9bce819825edc64481a63cb4d908e4210e162730d6ac3141808c3e48bea3f9f12f9f7efeb118dc626ebfdbec13a773bfd7ed20d8a4c9255408168e3ccdc03135c3edd234e3d7c25b03daf0159ba7eccc7505f7443d0d50207a3897db5bb2a9d66206697b2aaba1badced53d985c910303d498ca9797522aae242d73390dbdf3d21daf4969c468aa831d055f7d0704bf759b239df15cdae54ea72e5d6692c7263717bec6782fec29a022935c0625a14e64bbd39a86e2bb6ea32602fe135aec711887e2af5c53cd55854a8844e1180b4852d50ae690a6688c7203793bdb1cfb4169a903ea73791eae127b3cf1d4f5b50e78c04b81c6763b22fcc148d7d8e957d419f7d2684a45ac016503030b773141596d4afa538ecf567ae5b3f12f2d5ee36111996d23bb6992824840f2a2ae520ffbd13d1cc9a1b5e7f5ee50f541d94f72a40c3265469d0781936ace42b062af88d3e236b1c93124cb12d687bfc5fd1ceba79706101dbe05bc549a2699818054ddea842d7eef97a80d9ea0ea13956a19fdbb651e4adc612db731446bb17843183b88848c682d26b48fb9ef17f38eb2064b0377ac751158f2e0e35047db854f53acf6769fd0a97e15805fd8b891f892581238aab7ea12fd5ed16915f0099e4e8e7a1875dd4652a65bee561bcf61e50858c488beb375702b10bd2362b29a29cebeb9ab2ec42a5ff6b9e311d8a44dc9da68c80ad5a06ba5768452200ee69dceb33373d90a338c3a12402681b852f3252548f2490a3f95db97d389876382da6aae383652b59e9dbfeeef3789c197ee40d7bb99a0a6bd1c2a767be0d58f4227092209c1b28208f4cf4bfe4f1139d387168b99525650a5605b6fc60223b52ffa5127a5225809c40973ce2ab28d1eb46ad9d32a5260502a782e7fc00f92aa83e4020cd8ca032e59aaf4d384e2dd66706be50f5e157650c37d5c72cb0af56a1a998e14b53dc3c4357f4fd2bbcafb3c51b6236e12718929bdd57e9d28ac02758ebf25203ecc17db0b74a05b3ac68190dd581a061e9c62222d34247155ca0a7890b81729bb11ccb6f1273d4a52a29e807b13fd5542f508b382715728d341eacab15c623694ebf14f0e272cbc199c4cec973bedfe791c285a3e5b01ef74dc560b5f1cf6b759684f86b2849bb549239052aea8f36c76ab3f2fa94156cc3c97a27ad940da806dddd9aad0801a46da4ccfdc1d2de87ea15259d80212a2f0dfb36e6ed3004b4e08a52323164a81cc5399b44083610ba3c3afb6aceef5afdfd94720ac57cbab209dcbd7b9cdf434c0d8bea38f03fe2071b1d6eca82cc6ba34de681e887af0131c033757bb780f00c9aec0e72988c73ae90b10f910a01ac96ecfa44bf1fe736cc0737d460c40f6fe131ce1f4733ee39720943345025d796b8fafdb2dff3af04f660790de51bdb262207418689d7c598da83ec16f231c3caa3c2c71f63c6af56a55e11e548d87dbe3709b33582d3621499977ded44c657ad8badc4ea976078bbb31669251a59621769ec3e440219dfe3af86a479f55823dfcce8e47f96a603ae12a74773a8cefeeb89adf1786bf39aceed7f7c107f42b083544f49b1173e0a4cec7428faf5adb4295544874aef9ae3c10b068cf3445f66e2ab2771d4711f3ab6fc428c4b69d80d636ce2dc3d2462d0f4c451634cc4ae492d1cfc9fb407d3ac6f8ddffac70fd4fe28217aaf6604134777e9aaf501e18c88099a5017afe9bd5425dc04f254c6aef453a35bc1d1bfb630abc31c12e599645dd3814da911c7336e03931cf4c48b226990dabbb83c4aceadc331e263b853b71e6a2ab6bf76a48541acf054ce09cadc2832eb5dfb67cbf7322b556a446ff6000e875dc1e53232193b5d2c7ade8c844016733d2741f13d696da481fbe146fc927192fa44d60adad805b3029348d5a0b263fec5c1fcd0cd706c111709c2aef322b5f6bda56c06cc949ae7843554aa9ade4ede2be61466b3fe94bf8f4c82e5981c6988de8484b61ac01e7b5adee65f5604221ef3e1b127b13386f5ee663318f9793f5d7a181707568b6545d57e14ada183f00d13a3fee215addf41dc16f8a8bef1f1f43e85b257d844449ed791bf251ea2f67a9eace39c1413e27f91406182db3f6ecc1241f01f7d0049129cb6c6e7c48bbf1d987fc3d84110238be05405a58a8894a244b964506b1070301e78bc24dcd0d18a9dc7c4f50bbd357ee2ecd9e9af21b3cd0c709b498d59cc25bc455d0db4ac9ef285bae891402795559e663a1faff48ec4b048cf7af2e1576d8248516958b5447b2490847aa5987db65d70d27ee47a9a86b8b992e0f8ee2b4a0b3d8e0beac9a25cc11a302f2a196008f553ca5fec163d7bcff3d03384f9ac5660e28f8e1e53c73d165252dcf230cc1aed08fa1de02673069d48577e81193f794cff95733165e8e23d4c1ddee28f7d0b6cdd15948cd804cc6ff68584bda99e0440355af30001f6bdb4f4d4303fb733a8b2b2983a292e275c7c38fd2b107f9220e9884da3e63948138c2ec505d19519513135dba043ba69956633adfbe2de9c2ee0a103250fdebb922cbead74bc5222e7124e7e6a30f114d9437f7b1534900a526866e44fdc0d280a95bb9749ba5fb1a1caf53c6cf727b2087bb95872f83d454cdcce2e6bb33eb9b7a244f609ff48aec3183a84f1a3a47767f37d5518903e40ff3b8ff4dacc6c2017499fc62c285969bab269cc861bcaedf3b7d27ad3d298f44b30e37fcb5315d490098dbed2982a8e53f9e6b153618549fa54f462713d2f340a3a92a031e7e1bfb8c08b36c10020e024d05cacc0b2527a656ac1572177c25863968e87c83ba0807292c9875cad9bc22737ec2b6047e72422142640668d2fa5494da4792a276a84e6f35ef096260bf22712dc3833b31ac3bc0dcc06e9ceab6236dfbc9ad5cd8e1784a928f63fbdaa3f007f586e86a6580a18e2d3ee604e8531c6d69894aa4404cbe2e0d7d5d2048dde096b6ee9a8209d417b28e65be2bd9051d9c8ff69264333b20b9fa40010e972257ac20009561a7684dfd7778a168590752cbed328977828b796eab00a7c8483c8d69fe91a785dcd08d78f3f4f6536f646661a7b299078faf69715427b5938f2028d1aec956518859709e4d19fcd444c8af256326c3da34c722564fad66803d5dc548746c1eb041ae7cc8d4b44161f0a598d15ddef7fb7ea26c3d20f8e5b1c79b14315692dceb2c8dbc1d3f0c5ffed4090bd64f70b2857f11fa6adc1d2f5f4f02e0a103b53a982125b566cc81d93bc8b5373bf1c5daf22f4d9b4d1d953b8f4fc7692f7dbc919f5624c63d2aa2a6af7c8bf75c0543a29fa74058b593b269cc40af23d486028a58c7b2d563b2d1988ae1d3d3eb15e0b099f96cc14012d88834d859d10044dacb3a5fc84c8a9a45834dde194a41e1610529fb799dff16256f1c140f60649176fb03b0b98c66e408d7f6363130079242a16a2f14357e2a091ab4640ddd06d0549f17407b4c384584405549538561d1c208092d11e38492bab5f1b1e06f429b246088a2fec49ff7aca6b60e17984a5b3161b9e9f7fccd82ad847f5b6d6323591ea6f4f90008e20e55fb0f3e504922523b0f3352d40d8dbd3ee69298a933df8239e0108bb849c180f358090cea975686a3d6cce80e0f851a718df3b30f7010161cd3cc9374083299aa8eadfe349fc30a360ff641b432915504e190f74cacc98eecd36a19228832dc66396fbdeac2fe3e8d2e51e71712257a2bdf459f6f73e70ecca67848f8ba3fd719d2ff938acec61eb8e8535b2d91a9bbfd1946ee63471b1efa461d94f0ea0ab4980baf0f2a4a6ab5e225ecd8997b94bc5eca2c3618b6e8fbfab5f74295fdc2abe5d19fa6ae2b377e755137f1635e7cf37c1180b6caef8bada1b026b8abff99ab1fef8bfb33d6ccc6162e9860953e8a19a66e634774acd24c8d0610ce7bd47674e5b55d10090c89670f9a9761cc4c6a7febf52b501314394dd42008e5ddbde59ba49eb8bba6b06e134df6bd31f0293af5a49cc99e9f936c97c73e09822709311f311c57e2955e783cd537893c766431cd720bdcf67517c1be4d6c46da1c97dc1dd5c94406cea2c2fa52af8b339561e8f2e1e84cfac181863e108256fc2c4e2a1d58acb05bf0cb77d085df24df74837f5e4444aa78f8bd49162bdd8676bc689fd9ebd5d6d4b5c8b2141299ff3fb2b34db5a807b074d602e95c4838d5de482b3b7413326e77ba52f0a8002b59352663577cb2fe0da4427700328a020ee6fb90fd7ae74cefe553d96a215791961757a36b0c155c358eccb3120c56f5f12360e3aaef3e16feb56d8823f14dfb1c6ee4872259154faf31b28f375a526b5b36ad2430b28896bdb8343fced3fbc3fbd4b6ac009b191f5e6de4330282a711fbabde3bfc59f872bdb6b8e8141f6f048fab2a3f3fed52435b3f35151fe6fcce7bdc178c5e95aae544bfec2ee8f24092b1de371cd1ede9f1338d8d2e96c3f81c6c4e3a73693ceb648358c969b56dc55e227f8f0e652222520cc7ae480190e28804dbfcb1cecc243942e6ffe198861bdbe78b15543aece53f55cc881c7234b6bf9361ac4a09228e18c8325b878853e7a44545c69410e2145cf9fd8b90b06cc9967b334f3b2ae1539e92cc8037a540a1573a13022c7c224b5b89c1f28bbf4ce85099d08e27c4dcc6e20e4279a8920598919d9b50011739ca8fb5f31c19ee98342363b826c6e98fc64a928b376d5ce85c9656cf71fcedb0144b8fb337e006435efbbaadab3b2e6c85aa03b3cfddc7323d7554d88f95a54ce8241e68726e5a071d9bc9a70fb8932f16bb6b68beb9fa2b123bd4e5d8a5e996cec88c5532cb35231b97cfe66d3687222a9802e70266a000fab903a2cea1fca1decd1e07e10d74e0fb99fc3620c1ed00c9d09ec644c9372ca561f1f8bcc89787aa6cdf4ded475e02ed341ee34c8c0d3925e1aae046ee36f0db523ce729f7e4cb0fd24ef9981488130e12215653f972e20388a26eaf63cc222ca1f717d24c25623866a5a573622f9159be09a9505b608ec0346767dc4a57da6c1e0a73b7b091d58abc37ee7b2e90d545a11382b8016d2b26dc3a19076441a65584533bc2122069775ae7f84bede1665765c9910885761a5d5c3c5b580cc4efc49f001691c7fd9751c31371dee0898bb6ed226b2c9ae15a5977af18e1fc2eed1a0b5fb1e9cd8155218e59c6c71e93dd55136fa130d5fce3db8833e9cd53daef828b6f58b1af4e66ea4a41add9d398ba7dae61a33f79eda034cd5bad30c26c7fb4e875a7234fdc03d4efa3ee27bc76ef89af1a8e8255638cdb244792899acb57283c268c2dc3eba77be92a85041cc4883612ceb64aca26786703d3cd8d97f592924cd98c6f3f38e7af026acc06c45e0757ebdbf810dc2a88612b8cadef79b51cf1d1507d1a08544a107f83bd714ae7130496a84ecf9c8c128dee901fa30cb40b1bc93bf1237138ce969224a59029a049894d5a84bc8307ffd7275dc8215ac6044d2906d8a4d72fb452ad258dad9eb3e1b0d7f1e0459f783be6bb29ed6db190ab4b64bd31a5966a29e6c17f0014561ce558aa6702c1ebb7db4f2447ce8885283961e181a2031485a4feaef6b3a3e010eb59155ad623067ea834e85ba7ef2485e56524482846aab42683baa0dc753f9f966cbf11a425fae10d0cc7bb8a29194cf7b7d26453e3971c2687ffdf116018e05fe1e3a52f78ae568965f34cba7f807c9d85cd0943c43f7bd252dde63dcf7d8133ae6c670a7a2e81b9818fa5bb1dd380b0dac338ecb7e6583a4e937a28cbf88f813b159f57f1c8c819a8f77a04ff3898ef53f9af8fa2cbd95e0ec964349258e6d14e69f39baf95d1afad5fc4778654ce683229b742ecaf33837d872e6f9fa86b80ba6adf1aab2b2e36bfaf2ce45d03827bc6be2d8566428b69dea72c7dfdc805538888dd03e5a7c015065b643f1a8e57a72937a4053ac210430e5fd91a169d5622f685bc725b8a4ab4ea13ebeb36cc8fc1c5dcfa479e4843835c01efeb4dc3f02a7745c583d74e3b704aafc28edd13253a390da2087fc0bef54a892d87c0c9ac6f88d38b0c9c2907f222b9f3ecce48cb6f9a10d79c3d6b5d0c40e1262e2dcd0f6a488775dfed8ad692965046db73289300790f1d13fd491b518ca6c5f2d4b0b4fda846934fb0502edd30b8b8c99759671d2c1ae1d0af85c796a82f9f67dadcb948d83b90c788f8a5f575a8764aa6201bb35ad7141177391c3179aa8f7c9b0416c0c97b6206c0dc58074ad7cdce346d689bf05859cb962c49e40a5e21039fb9e4bb8ec0750c6fcef367128637d9a626dd97cb3f8bc44ede0f1ad946a9a010c810c5bf2021e7f8949462cb99d52fd4a3b28ca0092d236a8164e9215c9f04ea9b7325518be048ab6d3ca83238fdbf8d6ebe3a8cb0fe1990cd6fdd3f801806d3c03312c67540ce0eff86d4ec84d002f7136ca88990408271b336113d886c498c10f6c1a2cfecd9dce54f202d5a74359ae97ccfe73f76552721667000ac2d1ac74505744369e9416cc6454a0ac33d9d8ce3b9eb6e6597e2150da38d145d0921184b20f7b0f238415be4a570d496185360172064f3bb5bbc7d8c8fab02f01c42e16ba70310050728eb5ae6d4ad078a675d5ed421582ca22464d0a935e6a8cb53cb7785f0360b0ee980490317252aa1f7d0e145bd6cabf21f10f7ed34884a0bb6653459f1e3a1ed790b3435d2043cc108ad65d629bf7f7796c349c6c380d21c97e26623035d75bdbb214b90ac7c38fa21bca1a34559b0583c23ff695d9438632a24f8ea305f5fcf2642e9712efdf7334e2a7d615ab1a053a01538b815f16542d4129b108e4fb5ab1b958232c483beb378af73e1eb661a9f9c5fbb1dd618455526105553a605c477ba6b2f7138f40ddf6e600aa918a5b0ea2c4e240045a2db7e5d2ed51f924cefb4eb5160bfc497c91b50f306599c8bbd1608b41917c1cc2490861a978005ec9bfb3bb060e1d48e89b378ac0a7d031773ebe88d584395994ced9aa2c35677763f5122e61e14ae0dfbbea5833424719148f3ca522e6e5fa0df23ddc02138ba939c5d1b3ce8e696e3a1da4e439d429af5e7868a15ff80da0bd49f97b1cddc93932d03ad74b6eec329700c83d3887d6102d93eaf2ba28cf8b610a2a5cf8904f8fea03852092fd2ce41669ffc79be336f7cc2eefcd79e42fb1124bed3c6807e55096998c0dcfd0cd91780cb8e136f05b2355db867803f2ef41280a9dbdf590ade5e9cc755e1d2f5cd61a14e82f0edab408235448e7f6b6ffebb52a372d099fec05da2b4b1ed787ad6b213ca004909baabc0c275e11db61f6fd61e9fa43e32848ea7f625a11557a3ade105a7f4f2d005e7ffebb4b7006fee7fe4797809919c2b0b1150c9fabe09f1722681c22b1d0bf2c3ada6f3127fdcc4dee054a28a1c93f2a9b1e20a7b139d8d9d808ea73f1667cf456725a33c6060d44666e782bf91e213ffe6f084c42fb7787f93378915e3c6d0054b8769118285e344c5f92246d3232ad76dd00c8c290accaed0cc636a3a32fb33207128dc63b0e517bf046376d39caaa34df68f3438579630091c1e3936064fdb6f64a2e36a92509e75590ad0796bf1e50756c04a137bff4c564e47729521f4273cd71dc6e4f5b86fa29de4264110d889196b77210d73be7b2968aafb6f0c74c4c930aaaaf802c55aff2bd59132a0199b9a0ecea2fdffb69ee8337b4af3f1d53a41709ab02e88240dfa95e618d9e22d9866f8967eb38b3a54f25e95d7b1d156cb6d35adda5e533a465021e4a2f3b756aa0cb7ff7741f0ddd9a5036535e34172d6a9369b95fdb2cc9d2d904a79ce0178ce32c8c7f17f904c714ebd7b5687ed2a82389af391a2d5d4781013173d2d9d0c3eb42346da96becf469474941bb091414ca02867bcd273c1fe67aa7f1f16bb74788dbce722760ce44f9c787a9c428c328d91502f5f676ef41413aef1e611e01e0b018d4fe4bbdc08bfc29fd616f2dd9c3109ad8727a1fdaf5fcd2fe8201d6944e35c8779480dc487cadbc8609f46313bab2ef8d19e08594711e51345243e366d64728ea4e25fd3991275cef9a07847c7711db48775c19343cd5bb576f48b40add02b9a5333567a48ccc8046c5dc327e87ae69a5985343d19b8bec5c9048ef29c75835d68d6d9a119cb4debe30ece52e5fa93d27c671c6923c89c65be7f34eac74f64ab3fc45410257dee2aac6bc8f1ef8c8b7d9630f26679a8aca6af397be78311e4a2ea8e8bf9a0221f7e4e086ed5d9945379bd881e8da5055bdd3206c4f340680a8f88f4d7d58e601a93f6fd54639902b93a26cbfaa1b04217bceab5911694f919604e3b23085e1336ac9aca37e7c1a4f3d6c8f791644c4a5972b156534a4e3e612a9a167a8acc9365cdbd02500909a4c8654497ae1fe4ee380c3e6c68a10c78372f3cece8b7ff1d3dc113333dcc485327385c451d0b5c81aa224e1008d970ada3a6ab64a847ed9713d7d3cd7d0c9be0edef6c7558ad17227cd155148a76ba9ec77a1bcb39257627a101be9facf76bba45844085c2ba60b1702e3e7d2e3304df2e6cf8666e4f0836163999b7ce556b702263189cf80bd27592c6d9ba8baa6132dd174250b154c3fb68ac434d8872a404203a10f5867996e08ebb01716f3207dc8e381af43d0c260a3804b37eb86457638f66908d64ad8c63dd002cf0163780e9082648fa070eea94faf0972d56eace5695c0ff1014ba240992148abb44209c2a92c019fe7ab2b3bc46629eb52aec32ce0cd56d713d299e27d975f62271dd255d434041d84342dd2935f8d3e922fb1fd71bd74420d73b2eb1a874bdd979d4ea2c38331e6db93129bc2667084ba3bc103ea10f529bc06ff00216f93c522d6abc2c0c51b6307906562f2ba70e9914aec949d720d634d75bdf6ff8e366080d5e067b3c8957c9a6acd686d8c94512f84c90a54e7599ef5914820ccf7a5cbd2adf1dbee08ecba4aa62f339c3050fd009a43b3891082e13f2b12bddca490e29553f687a9a6d5caa1f7e89eb5b84b7a2f1c9121988430180a55e9d5da34f5753c618e64e89125af0c9d17881823e21af67b951d4a14512482e9119a073cfc5b15488077e2734e33dee14ad9a48aac7be6fafa3939883670401660689f3eefe3b2d3e4425ad71094b8c2f9c170b2141b6b67fd6a624932b8716a12391cadf7253e46f62db2f620de223da1b34504802acbc1197e46671b38f87db4945928fb42d36b6252a879ec478df687777e712680534db022af9707b1be051b986ee395521e1933ee7a3ea72655d2af5519fdb4d6bb05ce3033154ec70ff7b09bb98dacc7be09f1d6c4809c530a6a803bcc3b42e34609845a352b52322b24fb78e8500eccb3a7b19cd04ee524e8ba10f125f21355574d6104423524f8969fa1f7d18df0714885bf029f1b113c275333bfeed2a3536be45c517405d3bdabd56a335f6971b2a4c918a77d65162890dc79f1ef71373b285b39c1c5575211c7224310d623d4b88e3ab5df0997335063e7c9f8684df5f50497698c58b499f0dbc086a242a5294db4d7b66615ccd29a8b515d61168ee8ebebff197d79011294beba6c686f0f7fc5dd5c93d66fbb0000828cbc57e5a48baa62ae1e61f5ce94eef5c3f019d4fc202538c1e5f6a9c8f8768b6655761b852566228db495c7784e1aa2df7f9936164e635fd475848a16cd5344026ff28768345a8e3ccd77784181d270c1f6570781b3c711b50a65381a7e18d0e3d47633b354f334003cccb227fda9f5223422e093f713a07164fe405f0bdc10bde9d63c2cd88f4e03141799dc672280778406389e5996d10eacb4af072c0d3c52ee6d27b004582a443f69f7079ad251219312e2d24f40503f222f358a5a7f3b3fbdbd027fa208db8013f51ae04d4160fdfe4fc4814e98a7756586b19baf4e37b1e13ee8d5c266802c7eb0bccabdd26fd82fa6d13922eb8dbf4dd506866abd2a37f5589ef788ef4005c44d354d17e114522a92ad52afb8e18361bfd472a9c608fafa49c27f4da52594a1bbee49b3dd8df5a8c080c1e5c468b9b89a4b20deaf8c57657c118e0f412cc72e12d136aebda0303afc8cfb1c294eaa28ea8fd83a80a6f3a0f14a9638f899676e61f1859988df639bb57eb1571293178dc3e526b7173fbc31c92c84d7e600c4bd152e58884bc027ff429b5dd01b231b3a16e2890f0f058eb62089945df080cfc0aa6cc3af63c728af626de13908cfca91db42b6dd75445e52e8ae51e44a6df2f69743a3534a6221bdf22b17fa928ca9d31a64c6132429835bdec5c57a4bf77a3bbd26eeead27acae6fa8b799a19482af21782de19a8d58a347929298eba7ae3941bdd61443e38efa89738a9d0566217889e6478b80e1b362a86f4e2e607c7bd99b0adb5d0be310a1de7b7b391fd13a0d94f35bdb1a964f34f5b448d8ebc91f209a4a14fc43bd3ce571cbea1eeccee963add6459edb76eace562ee32b8db96438b433ecb1815a1dd0ac63429571bd3fd039dd1aa5e53f4edfc703e83444946cf62e3068a9de17625b2fb36f0b15df10559f3bd11a6ce20b915426a93812c730d16a39a3e2be2865d62ad3678648d829875777e3960210ec3ba51c37cb28f9118b51819155d4c4b225c5874c84247595bf19312081f8e9c2e44e89f93374fef7558287037997ec8769a8e501c4bcbbf0bf7793461f2cfc9685e30234fbe558f798beb48627fdc2b2278c057bd6ff2771d57c9f98dcfca304b3402a3b4549878a8dd9c277f8558c62395151a73892b34c1ba23af46eb7d30fc64a4b3a8eacc01d8d3109520d22dab1087f017c86523ac6a800eecc96fd043dc9b4ecd74b25fb13aa5da4c898f7099d6f0c3919522cb705b420c1d7746bfa3cf9e649e0ef1ce860eca269b1094ab36866f59416d1d36b7006219ebde05d22acbb0a7c4955a68ba77cb035b289f539a24a9f2f33265cc00fa6cbd0be5e505744f6941bbba474aa35ad3d448907dee3e6509415e1e26deb1cb206a82058da386cd8c011a830162eeb044c45bfed0d16b3772bf5c1dc4269ce455e20562ead494c1fb0c318d763ec64baa529efd7a24d76b3f3ae7e59cb1d7b80974738489b77bc831ec3a3d594f37c02dd3dd35f06a38c513a4898d09a7324ee61aad77685b099945e3c7da4b330b504dc47a25380fd6ef5e3331c2f23868a67cfb96bc0d160f7dda77da8bcbd94771c6c2699fc57a78769ff24313b0d76db0ea4cd5602fb74aa80f1b703eff8eab7c1eb965106c7de957717adb1dccf92df7e3c018e2549ebca045b99a2e9e674a8195bbcad0c0ee458ebe6cf45c970bcb67a87a72b1d8d0f084a518d4b03ead226c9c17360c73e82d09989f8baf628ebd72ba61601b2303c4e97fd745a06257052d441d4dcf16601d9fd89fa4e0eee52dd2831e4710064b816e28b8367391fa97b482159779c673de4bded03f850df925e07999194cf872b8da4a2c6be8858ce2394274b1b496d75439e629eb96d456b14d971d5c804c72e863eac27210c85ec618779ed4ce457186af6d578be95c70fabe75aec421faa4e98143d98f1ece99aa3062157bac486b5b17627b2fd3c6b481c896901ae13903a988d289d2aa2140032a1465648c82d973c9912ea56e1ee99395c7d4b4f3d928701a7d467340a6a408419ce8f1693842c28ea7f8c1b441e5a135b2556846dcba24710e2c39418976824d52820b5e51908293814bac88ddc0fc5fd63907369deddbc3ddcaa8e4b66afc1ba38f2e33926a1f854c0453c94b0e04f86d3a5ac9a83da28a1cb116135f026d2fa22e336ffafebbb126ab556c8411268fdff8ca91f890eb07d1ce1400018fcadbae5f20b4c075ca18a45a251a26e024a4f4b1bdba7fdb42522977abf0b2de5943876337e3e1aef3adaa3410c7b861b95aec4ef0a0699d66f4fe41fb8ad505a9c8f95ca26d079fe440e01808369c894043346c91b9ae7261ac254e401cbffd7a2a2d7add2429049ee2102485e6bd708cef6fd3412ea3ed6389f45e869492b9ecd482e563a06ebc1bcca1812b0c609d40432f1f1ded312c1a9ca5bb05ff96f879fd9ee8112f2775bccb1d899fdc6a5b80e186e5e573a2541067c6c9246b996d2e4517359fe0a18f89bc612eff58ce7360f9f0f48eb1914176fb6dd4cdd6d60b4fad326674f9e105c011c66125b81331c1e189291723e7caa1a68fdc73a380cedacbd426954aad354dbc0234aaec75b8acb5e2b114e17f47c954b41d4f8e42b5c8e2dea517bbf0dcce81c5733dd1c94acc3266c393c176c4931262495cc42aa228e877fa72b9734d9399c9e1094858219babd5d14e1065389b88e997979a12af12e689cadbcdab4b84851c7cb8a2da58107215f842c09bbecfb17498e8643f9011a23d0119de591bdedb47dc8a16276a06c8487904acb6232e7099b6c30fbbe81eabd7e257048e09e9a2ba8621817d831451717a9f0011db62831ed3220e675167d7de2b9d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
