<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51a177f801d249593a6bbf31e09fda75ce3ca386d703c9841b08621fc07ef6ad40ff935b456512210a7c0be3103713c72ff9d03dde2714b6f3f155f9558c4704f484e64fa1fcf1049410d46ef2439af5539bfc95de1df95f41e3b0649e5cb82572da7c79cecf30987415636605314895ef628e3d0f4a12fb39882cd7aa6f243b3c340d8df903f0772c3be1647c87c39c617bf1853dc527d76ceff5821b9dfd882440fbfa008dbf5130ee250b845e4a509fded2cc72bc3c84b72b5fe0f64310d428e178112ad78f5749896db5aa6514ea1c6db84c4baf88e4a86d132d8dc92625242c4c81a7e2b10fe246f30c6b632e34e2552ad99436d197b7c0e3e440c20d67cd1ae0700fa530879ca19f1e549579f9bd33723e8eeec09650928bb093345d5f9cb8004b74632328ad9f4e95c545be8bd24a123aaa25c59de20d9539ac097c87c1dd9593b47399aeab2092d7c03d843bcfc3151d6b22425fa60c2d51f2c026a600e244842512ac5c35520660431c62fafd057c4bd5f52a202bcd3b2371fe7970932bdcca413665e4bc6331396625da01941a854f0f237f9e440587bc1d69252395b6927b16ab118776c81cd6fc55afbaf9beb70e67eaac867ae81f031d73d91f9c0e0e6ce66c3652bef432b7e4aac4ed772cf7fc8d7f1e1a0b0569abf99c61d758c54033827a41ceaa09c952d3bede7e85c8444a7d149277278a40dcd09a13a194b1d1fedd2e5f7e03420f1b8ba2b9c13e08ab33d0a2bafa30ac9369c9291e7e920901bda8abc06acc62c1b980748c9a4f24c7c82b4470a4f4f158e353a7806bf4fe446a156e45a5c70f028c67a177d8f8da529c98a8789f34cc085a970a1076dda509bbc30707701d891f93f34b0dd0416ea221fb6d5312fc6b52dc70125e812ebdd9304a4c0b40a3db7e776670bb332c9958073d8c041e0b5302b99583d5c1f8e20dab9f8f0fa3e478f9486a4bc647be2cca68d9c3b4772e34b77f6284e3f149238d2a2eafefc2d66ac729169067a5bb309216dfed2ae7baa77caeff8fc3cbe83e67135cef847041650d066f7bec0d2ddda30120f3ea1f5689b5b0c9c0ab87283445844b18f5046394bc3c66d35cd1e18af5ebbbf57b78b251c7d3fc6e3f0af0cfd8e6ad45bea1fb0e1eda47d7647d1afca44dcfa828ba7746051508399cbd3b003d728d11fbfff30dadaa25aa1c4f5e1fc510748173b17ce607f9a0a0cec9f0b9038776d8c9c3f889d608fc7347138e0e095b9603d7634a94c3048f04bc2338486e93357f047b77ff2b128456d0e8752873544016fd137aa118818d08280d095c98861528e3e51665b1851b287ab667ac2c570f71ae47782d81612442d24d646f4fae167d4ff8f78edf5ba64ce70513fa16580303b53cf3491d2010a3dda4dd73db16f96febe77b7c071eeb054ddf07ea6da2da10ae3aaf9add6921a059bb96987718720ee0237d8309d59c06f45b20305217297db33f31e69b1a98eb2d56da99b53ac7c003f807ba575809527f5ebcb4066c2ae4e57026e45a6ec43aa4da8dba0420b9488a4ccd9fb8195edb0496301835fc8528c273b79cb198653396f6f7e0902cd27edea35cdb8b087ab714a2d40623b20df7cdb56efa9f45436390778a5826cf4f99437f56fac2a7b45363bfe2c52d80dfd83463826808c0dc321f9c516f908339385b53684d73db2a973f0bf7be0c8bd81ba63845e788d81b556de8dae28e91f1a4648a5b424cd9472563aad630e7439bb2917c7ab759840c5c10e7801b408f7b53311f7fc27fa46628bfb347040d3cabe9c575e21048a606036849f5d28ab8f652aae66b1300f8802116c0f48d3ce5409920525cf6a6f3c9ef675dbd376040a5ef2026b122bcdc448ed155217395d4c2150e90c1b35f77dd9e997100557f5eccdb3880f97f67c5acc01f96e794edaba64b43ce65ab3bd8e8d700c5e581a4dc9a898538130d536433e3c79b68807fba5953bde3690dec70dba7518221fb58e7c2abdc56dee4be051c3f0bd2377430a3be67070f10ba3b0ccb28153246651977fdfc192be863090846e37c60d76be379aceeb67340f72171e17e1ae0d1e721e3db1d55235fd106844564fd46aef775e255c345f5957453ef7bd8a60a72afd3af3e9eea84ef5d156d273d6cdef8faf2c28b47657bf42adbf4fa61c92dc909e590a894456edb3c8a1030e8630956f775106b0d3f573961d840129e58197c61bf7f6a84f02cd8a58b2583f604bc7c3271dc8f3821436d0388b96567a6c4d46e0caed35728764576df21bf3bd7a40a2f97e9cd313fe868138b783cbf3f7d5f1464699e5eafea7471b6af87c3a53d852643ffaae741b4144f4573547335e1e8e10f1d9ee5e3ff5fbb6f91fe3b937623098bead52a077a4d5c7812d793c91c6321465857a09a189c2712da3f0ef90e8497c9d8f3a60baa8edf099a1cf8ad8dd8ef8d4dda9a39a0ef70ac75df10f1f2a73888903674db9686e1a44bad315591bc9bafab3aa6b01265cbc4fb4ea70322d269a48f1edf6aab2c539b10f41dfecba5df682b4f1eff333834b5ed890e8bd1bbe5d1ae2150406ca916da5c88601c043ee476bc46f8f0b5bf35522ac83219af3b6d5f616d90a375bc49aee7cbc5d89f5f6f12a3da1af4bfe4efc1ade3a9b08af86f0201f2985058fb9ee3fea9cc7ecb6ac675a004e8b52b3dceb9b3490d24f7d7676f87aa7a928c699ddd36ab410494e43c7ea4e1625e66f6715c0fddccf2a82be1aa8f0da131495c7e6d3f8bb174f25f2069bb096869f7f8dbd36c576e09784e2a30d99f27985810026c0f75ecfbfc0fb5733301da025d0f0113db2885546b5d19af9bad33b75368e4228465cccc54112603954676eb64b2675f4582626f51cb636b506a7a18960b2b86889204fb5df899286535fc435159f2fb8cf3aeaeb2549867ccbe3c4eddf254269d5f686044e03c73c6df8c7c7ca1b39930014ec63eb1677a2372a145b1d2561f169d30d563c19d2f179fb94cf7822a56b69400942677599a55fddc1296db0d35aeb49026fcac633ce5d584a7bdd1a56c2fb888a44d74ea3056d698c3807433398100e2a9dd307a457129305cff392dc7c9fe3295ba9a946133896471678843523061eb9180122c8d082a826d2e3486d43cddb9cd64403c88e909afaf04dab12d5a56cde72a534f4c75a7110f6b656f1cea83ab5c279cb7f4be12db0736a69b5e0bb7d8bcb5a1c87c1f61ff1248f8476ffbcc669f715d05ffc9789e39215ff738cafde65609b171e9710eb9709f8e27a8a3c52e9476768edd9e66ddeda6a362096211693f73f3133dd22166a72da23f77b57ff120c0cfd8a98c8bde8357f07dbd98baa4d4963b4e0f57fe44d1c9bc1fba0ecc5064489eb675404530a115746a24e4bb39e771cff154a911ff07a2298a1d54b8725aa404bc5b764675b4b917092068a4f45ac54d232a54bda56a9976abe657c51ca8eab77d68bb365df179021875a2fee2f5a0982df40d85bb7cbd107b29f8ef4cac1b371eba03da042a05ea7219b9c208c566fe0788842e593f860e5c13ad9993490c540908c48e889650fa8d8272f25848d56d305a3ff842331fca324db951baf8e438da2b74d5029744183fbbd409d4b2b655baec217feab3f28f0346bd25f6702b034f162b83b5a5ca7d0058ffbf5238117dec90e0688b221d560beebb6fc126533dc0384d3f2a8bbb4d84b55b7e1ff9b8b4a147ce9efadabdfbf05ceca1c521655ebe6130f4821334a4fc97536efef129618ecca12b6ed4b5ab887bc7744d6299d6afe437e557d6fa75723ed3bf509e354591737f53b042c874b8fb5b0ca087712de5fbadd2d3508e9fce5b1600f678c8d87ec22c5feff0188183f78543b44034488de6d60e1f4eeb7425774262e3a57d470068b15d026e8939cb4dc25f1845bcb874391ac363902ffae7ae4054d02c58b803e33226632a5caa932f9531b85c38314b07574770dabe739c3c42d5ff1e54caf4fe44a5bcd62ada83219f5d869ea7a3877e0e452eebcb65a76c3d666167ea99853a47c14ba1218ac31111aa83e7b08d9947f5ff5a2522236e4ec8c1768c9781426b8b20131fc7d1eb35b96c021048432863ef773d56fc8c2ad9d8cfee49ee385e1ff8a7b078d4b0056d2f9d45b8cc65f34accae4374fdb6a5330019ef33b1bbdc23145496373dd73896d33b83312c83b3dc8f89fd675e020f998099e0dc61d8b7026fbd2aa442cc30267cbab6f010d84cf6212b55cd7dba215dc72e60cd911d5f9b00dcdfc94497ca9f4650d382e0d30dfd1ccb06dfcd76b085b68b5b5c2f9260549f10afa0aedab5f2d44392dba8ef9ccbf11fd93f56b22a179d92ca8d7273343be2d2133d0faae979c9499c86d47b1786554e7937c695d750fb9975e3203ab1400d0474326423d97d64a93dcf8a5d8263315b757619968f080950f9ea230a86c22c7e1d2e539884d00330ff0adcd84bd9971e59347751c842fa3e0e29c628abeaa91eaa32c71a8f7b7b380157415eaddcb1f994fada9d12e7743e9a250fb69a4ab132ee6623ace899041277142da4faee7164d838dd26e9550bb82e8c04939c2e4cc957db7bfc0acc9c6e955e86f5d34f45ec83ea8c11472ea76eb77b910ea48aebc3d54f33a734e891bc901e25691062bfe11a1398a0bfb7b67484bf9aeac80152c9e75f3be50cb45f4a5fcf60f8707e12bc4750beab15c2e5ef906142e3a619fd2357636888a163581a85191788e1a44064cc547218798efb82352bddd0a73dae47b2bbef64fbb8c180e3448bb63b9a721f7ebfc19844d64d5bdc81d98ad47451d22bc17db5003382199dd375e665764bc7bba6dfadc28f21b120c992f299c1593189c8a4373afcafeb2567019cde50ada4803f8dc123e3ec0a9e33ccb37f4e1b763ea05a5b05b1978679ec6e73f562d16a53803dd56c0596b271cc5405073cc2220ffb545fb842a447163d6c89544b02feb48424dff0fc6eb5f80e6c4c6bd1aa91e64a73871026c04c191917be8933e549a56e3794665e9336e35639da431b8c2c16db15860ea917251a9b99592e2e4b82a9bf43f5130502938290c5690aaad18861374ee5c8e60ccedf28af6983d9aff591cd65fb5bbf4b24eb6e71ab9dd7a9ff9fb942fb0944621b2beae88e1ea082f96d96fcf8b069ec993951999b215395cb14eef70fb86288d34e3cfabb4b855ee35072ccb32b94d20c119e06874b76aa5c8c295c9a7ddf6763e880e4104cb05f57aeb202cf81d7b1d2dc798336bc56a31511cd9ebb75be23791440395f396b21b448a2a0f7ce5debef79eefe4d634000cdebb2fbe80bd6e2874c3fd78041f09fbd29dbaa1115b051cb40eb84d5606ecff44cc3d68763c5c0479eda9a31540e24e967c5b95028eaafb4440b1a601865882804888e025694c6fa6e3d6f9d3d2f45d5421d459c8884b5e3187dedec96671a43947c9b1b71b36af6fdb7f60f5a776adea2956013cb6394267fa11b590b2326453fa92c3822fdd9a91499b133fe2974e0b869f907437575a1e2caebbfed8ba2dcce6e94c6b36e11f51a8dcfdfc70bce133014dc736031039ef19b3eb92758c9e1ab276668f24b696e261fd439583e7fb6020389b654e48abc270ac157b9427af636b20e9d42bd2b1aa5a4d06d326799d44b009c2054100a361c63f029790bffca6a509165d867b8d9ae306fa40bcb0be16d05d5ae1ee0cf31ffa228d05256fa080efbc15d60cf73b83d3d211824a6a65477d62f268f020755522064a6edbd1eb7c3c6076582025fdf663ca5f569ee9e9b68cc9019c9d70bf53b8f1add3e38ac0b695029cf946e9a5d6a618ed75b06e05ec42be606b79205a381a69472b101abc38c370ff27250558f3d31d91463c5e86aa08fc2a43f9f6d3da70049f6bc34037f5b614220cf522a1a06728c730331ae9b2631a22bf3eb5d6cc5c93e6b2b47fd9ee4e93cb5415553558bb75b8223544d1e373a235665f433ff06d83b2b0eb7ca5e9d9940240bfe66ae4a7e0b4d5c413918ac89bc7b87b0b2818abb0a90259f0df13e6692c5993bdf67d5c32e9a0252aa72fc3f7f03384bfe89285ade0ce73a2cd501f4596b1071c95ab019de6ddc81a80f761358d9055629da06e3db0b6b56234e9ae779bfd63123d892fc50189be68abe30f63ac5c825a2e2f04cf4cc185daba2225acf0478baea17f66c83a29b75c2135596b32077a37ee2bc9cf62d5734781e6504ff37c408f4e8fb77c91b7e3d9d59ff66d3fb0ad7c41fb0e690440e6df67bf1418035797eeac136fcc2aa141eb6b466909f4ddb4b5dc7b79c9a3897bd7ffdedf34a038518f34afdb72ce300f1708501108ea85524cb3efae46bed30d5c948ae3042516af8d9e6dedbb82db0c71b4ef555400d65c5c44175d1bfdf8048bdb257c0cbfbb960c82bd34e8144edaf06214432a9b72b4b4e6b808277a610a2d0c5ec2afa7abe86e8f17ecaeb716e6e74c72d462e7c7b61cd0286895fc69ea3724f914e231de3744699f90f34f97ba9f8a5561d3ff19af68257427b6a58e21877a73da9513d207f2fb3be7f96e699b40d226d9290f88ebce3d388f5f5e9c15b2b55e2feea7dcf5637a7b976d9da2bcbfb821d4d6a4957ac0fad9a9b162217b519f1272a1a050879a736137035694997055293cfde29e08bbcb8264a03d420db658e9166bd340cbdc4c48b48da7bb1c249e72b3dee8a2a155381a97f4e6deb6519adf37b04ed314891bcbb77273f470c89dc9044e939e0f0d732f770fa4ae8399ecadc680032d7746a471889c4eeaa4843a3fb8fd53d950d4efc807d8f30bdf735bce65fcfb99fbde70242ee2f3bf29e6b6fc9e6db1687cf44e274fffa7ff4a0995bdacb6f21220879e7d4f8fae641e80421c2f0cb09ba31a705ed58ba1a1a4bf34a6ce26cda95aa86b727cabd736ee70955ef2cdbf06ebd34caaba6db46fa5f880a7762adbaa180bef3a888f3d1f7c607d1a749e767e6d7c6d0e6808ae5f1dc3943b315801e0d1d8d3526e4d74391079bb163bd0f9be7a68ddb4efdfb311fd1b0fff3e82a9c9a346b7e3b28830fa5e82c72235514bbedf90f94ba0ba52ce8ee1e9e8413697b047dd4ad587e9ce7736413ca92da18ccae810a42e8908cd59cdfecd4ec7e7ab3080986fe7a7f085ad621f38b948810a9ce45164c19d1a48607366336ac9f8a50ca9de7fd83644f902a134f76fff2736eecdb0782617d275433758e31b6f3d03e205f1ee52c0711cdddca00a22759b101345b11ab0f87e22049df5433b1b4bb7838876b673917ca750979a5c60e8a06fc791c75195c8a6d59ec6ac7cd91ae1cbf53fd7fdf7893bd94b1fc59299fc0bd2da0c21d51e5476323b208eaae137ff196b5f65d85e656a5e201070f1dbf92174c4db938d4d1c722e3d67649b1f6ef5b54e1740942ae087c5660ee68fb9bf61c3ff7a2bb25693edeee6050dc7ebd89fbd75ec26320d495554b31b283ec88640593ea5e05cc297bb86f392e9fba60754f39be74abd39b02b66134eeca69214b28c4825c85517e8c1954b51b68d39e4709284763145826c1d8631e2f335e07a4285d86a9297bf4fc0ac8a6927828e9bca8f0abe7f35bc9bde106c78ef94373be3ac4da920c3947f947575462d8e335739b2b387e0b0ae7c147ff7662aaeb323927d4d2a87cb338bf629a7cc8afe26addf08ff98fbc393546dc073a61370f78443ee85f3f8ad4f1a23c862cd40743d06302c9cb9bca0fbdd615f91cafc31f335df3d7dd6a41b712c7048535f982a8aec12c81e35df56974728657f900b1064cc0b04c653f6db12faf998caa0cb5c9c30a1ce25d1fb62e84aa7d2359808f2a9ca7e43220fa7ef4cd7ef1cc01f62900a4c8b13c099ea4154bc28cd304e9b506c06f17e4933cfe23cb8f5ee2676551bc230917c121d3738810b067de3c1da60892919aa09648c082e3c4662cafdd6f4634b2db84f13972ed59e07562a09ff1f116b4169ddd94d876f505a9d6b3bbeb54d17760840a3674a89de011d8bdf21f046e5f093ab748e527e195093063a7366b42ac24342c2a35548ceb855019b63c3614958ecd97de0155df9903ee11005569586d34d55b0dc3de8e9852a830961a32dc71590489c6858b95127602ea3ac06e2996e19eae3e9fd0c714e9f7088079b192d9778413dc86b15f089a08d9ad2fed0a73f67961b1fc616f9c6fd08baaee9bdce2e764d638968178f6301c392e9b1861b54d07ff3ce8126b79a751832ea9cf270a28f582fa6756d264862d56909cda902608b3cdfee517e369143484f735c87590f19763ee9f97f925e6654aef304dbf19203766e305729e3d7f5b72990b1015211d7da4e54117ba366e7a68ebfeb7f2cf272909c5baed827e6a99411ed74736e20e53655f7a3d27734f55ae0c65ab3ab86fec982a3a03be01d3f1845c11dc01a0e5f03f58ea3d86e7e10fb28a31f741d672576fbefd8f188b455c9d590311585fb92a5f52e2be804b7d3028b0bc8e555aa4ffe87cab2b6a69221601fc78d0e22c90f4e3d57817d002deded5a9c2334ca1d11b0a3ec28b4c5f8eea384adc0a5573dc1f35bb14e35d32f8929ab04b014782778aba20997c07aadba34f781c02c9f2686b4524f2b4bd387e4aba172beb006a78c65bba237b3dcfbfaa92d2b22d319c502fa048a7c862b35c4597c41aaa1b53cc8b2c3329605f113fff0d9c8e5f1b4172e5db6129537448cb14d4d0f67f239c1636c4071a747fe1bf72dc96cfc4dde4734000f46822dd55938a2dde6eeef612f8e9dbc43d5594f79861092d99727bef5f2b2e5a1d0dfbfb7c74016fe5e47f225b26d2d81136a0cfea9b039e3b525561a7cca5184c57a2558191b51b7527b19d4d1ffa50ccac8987a3575c0c2ca9b776e9a008c09be58645f9a6a1620dac805862cbdd1a52704a947c710a62061b031018e9d588d4c50e09c586898167e06f7c2bb85af259a9ee330f22aea71d9d9bc1148d621bd1b03d776ddb300db06ba3c4042da8fda1813c5a841b63121e931a4d7acfdfa39d08ee1474665ae2f3c892cf87a9816ac6ebbcd617047cc5575764c4821105d4a3d9b908a86fd21f3152fe11b72ec93f4d8fa7d10df537c5e7e7b9cace8a742c4bbda59713bb89f0bb7e922b1fed7068b0282b8c55754f9e4906836b385372460489deafbc75cbd6182793887559d4e3aad7fc617978f0661655dbf40f086f8ebf656b60a5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
