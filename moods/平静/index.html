<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d797b489e677e5b28638284c6a4c11ad34c67790de0edcb6ffc289e39c8bce7347b9cb188998285779c1e06e9fc49204210fa60ad55606a68f07bdd7de8e3524cef6eaeaf542b0d33f7c4d7ba485c5e649c17d566c627ef374d70866d8b5d3c04ab2f9032974724ec6e299c04ee1d54d78ac1e21967caa61d0f7adec3b540db90edd417940be95be52e444d00bd2ebcab3cc0fa028a4411b84043e919bdbb7c00db3472dbcde09434046b2cb57b70107b8e837d095d749f9f5c52c57c46b47f31a6d15df6d9da5255008adcccfcbbb5e4fedb8aa69184d7efe3c3911e105c51d95d927af136654fe891b5e9d7ca27c8a224d69f3963dc1324bcfae9b4d3378f1c9cca591ea84045db5545a1abd9431f5ba8115f65ce662d96b2995ea75fa4b9f744925bc6777f4d24284ebee9a3e38ed51df82e2d1dbf3c42c2250dfef3e632276b08a114b89a4af2398275bad0d2236f7932b6a8212105211c00c54c832308b7b8961ccd59226e1c17196136abc3215d2782444ffe4f1104935f7c58a613bb05a7ac3aa260da58e43857a36a734f45fec937b88b81461925c3473851c0afb0da0cd78e39bf827bb38740f2521e4c6a8daed71655ff9d086bed2dd813bcc0d4d93c9a66b63d874f22feffe29c17ca7b3337bec6c4d814748a2de9a43d749a1c00b8f9150294eb06fc68caefc8fee7cf1b96cdf402a4d44d280a40873547f77362f1789762edff35e461effdf4c321819ebea2d45071aec2f5a221ecf4deb0808ec9adefc5c11baf29d9936eb8e23171ac5e5091d0baf8fbd3bb5e78acfc1260b375b03967a195afeee583d18c43b690fc7abce3fe5c8094742e3347346efd895ac9ca21a48ea971c928956c26cd25399802948015e9183f46a72af2c9304fce81b72b5bad53641fc5ea846fa8198be54b38205c0e370dbe9edf16a068c72a764c2987ab94241d1bd2e033220de448252c4d1bb5b22164c326081a91e9fce1c53015a27d9b1165ef672f435673d81abcc3e4370f6dd282ee3dc18f1d0967ebebbdcb0a8816f0dc3ac9b64ba49b4a7ebde2ac674a3169dc5d5387c456141e8927b001bc51d5dad946f84c4085e475e78005fec8917b08e09551ae91a24488a87ef6a56b9ce093f2b94d632f1a4437420ea5f85e7f65c978c58e88cbe43d0e8fb3e90ee08d85cfc6171084df254c56bca8975d902a517b509a99a5c3792f642f27df5098b6d6a5537c0630bd1599262358beced901e2f7610e842d131b90cad10f96222479b1df3a748d6061cf3fb480e0dbb0824e827c7bce2bbaeb9cd3d3afdc5953e3b85ffcee2fca7b23cb73d3fca9352addb73293727c1a518d517df2077354a46413bf2e31c8351769b27a4db73ce2417dd3a0c1fc5204ef7604d7c6e7286686d7ed687cfad731f065183d39214f464078fd929155df7a58e1c2a0b3d708fd72011ca1cc986ddcb4fb2eabb12a581f9832c02dddfbf11394b6cbebb8ea1cd34b0b289970d95cb9a790833f2c5abcefe880f475ddcbe558d717dc2e0394937ec83df19679ac5c60ee493f4752f3db488c9987992ef72eb991d0e1aba2aa2260d71f2ec9e1ba7184d6e532a0271596cc54619ab57eabb54dff862c478f0e787260e6cc11f638982ffba5b382c5dfe5493f849626d9cbde25530fa635c05ff287594b65d2ea26d7f161a8410f94257c6f199bb4bfa145bee0fe5bd668dd661e06e59c94d11cc147c6e37cb1ba34977f9732fbe868f7ad15142250cbbfa362203514c7fea773877edf47574a933e9b35759fb67d237a36790138fa5030fbad25058c3af986521d6098a9ec653ff1c39d7a7019e36b367b17b87f83ceabb0211cdea6c6415b7d8f4b46e7e60a7d90bc2b7bbf63bafeba09fd95f63e11815835f017b58fa4c0b7d781d064263233a6015396d350c3af354cccf63c40eb7a8bf1392ab5dd4004e04c5bc1ceeaaa3575f14c9bac5ead43c3ff6d9916ecfb997c6a0622c481dc65beba244f77b331850d2fe20e9e13edb979a6277b77bc9863f26dfab29c603c5ee086d35ae5ac1bd2c1c3d898b7758649d912a4efc79ecd56c4b545c569e86fcee4cd7099d2c5e58611ab5664eaa5d7cc57345dbbb6951f36e0c46d9bfe4767584f861321ae1ba1270a1ce41e68f19a57f620cf39ee66c9160f0da77450a2799c828a94061fe29c099f3011e0f62266d798bdbeb8ee62067182f8e7c5497fd557e8d154c62bf27eeaeba7dd6c1f0d6cd3a6a645aa7917628975d5d6a15bda9984542f6b26333117b9528bee13bea1b93c3281e389f35895886f6e0daed8a9cd54d97e794e25553b2bb3de6984b0928db3a7f8b51bef1856fb727fc0ac285e770b952a04d4b60725ccf798da28a4f34df0d791013e29756a1ec8d1ecf7cac35f2f79c8160f4050c73f6a63a2a3aaeb7ca0048cc43c52de7ddfc527e74c2740eefbf0e7b915397b9017e902577c57ceda2eb994ccc4f971729a89db269b1bb10c1fbd8be107f44dbd7443d8e602303e0d6cc46e0282da060a691f0aa13cef7f1e55ca254c364b16432fa6fcddd8f16443fbed2e402a1a0b65d35f8b7e68e6cc91c302de2941ba06526db85d0783ae224349da84f2db314b65ffed1c5e75103f6cb405083da12b08e988797f549d167d3149ffb9041f2826dbe13617dbfe6b095caf4e5a58a64ed273fe7bdb0fc6c853733d0890c6a0d550c1943f2511aae15c575f5b685113dd60521c783f34753d0ca0d9595a3b7593180e07e96fdb6d5d356914a74ab92644c090cc306c2045d2c7a2ac2079fc842afee017a5605eeaa58b3127e527a22cc2bd33af47e8c08bfd78f3d702ae09754400b32a535d64186386f8397caedf2ff03f0a1efa44c8900f266536de629995b18613540dd913db9b6c06bfc4a88b91070d4444321a591991b92562b17017d596bef3fdf8f675c73ffd2a93ded465785998684bab015f71263669f53fad97052ff6a4ae8aae7f3bec562a1bf0ae0c3da9622a30111c9d4f4427e47604492982443566d0b673d351a184492988be1ca538340017fa2f90f3c334885c2d1ee4e699c1cf4943a6784ff2b302dbc83129173859bf31d0be7ddda8e22fb6477c74cb350bce39d2b5358fcd7aa5028c9db93cea98dae7b6353ed921ac9ad338500d170fcc55346d4e327e2897ed1ba5e385de31770c8fdda33d36fd9462997b59f4d4da4aa7ff4b2d27c71e882bea28de4083275c0e7b76e2c00842ec149cbb10bb6d73d5fdcbbfd0bff170c3c30cc4f01cf5f3f993fd0627261ed59cc63aea7332f2ef616e0b0c1de3a1c7e994221c713253cc06f93d8e047226fba9771a2c68c6be37778927eb73c4152f76f412238dd26b35e6ce4d33c983a13d8e8c9c75273020f4df482289408b3a6e7e81b3869e4f06a7f9c1eb5ba83bfa1b4a8fdd76a9e27e1ee519bd800fb149e9341030528097bfe440aa8d9c369ce954ca05a61b76f27cbb88e9d3bf182c77215400f11a9d2b82220a90a162a39f83e9731a442509e6ec0076c34ead6287c2505f3874f56c2c0de551cdb94b88dc80dcf53f504fae1b0d2bb3ef865dcb23f0d7d72be44959f2e878addc4881d21593dfb9b1b8388e5df9308bb89f814a7ecc8dafe5e838a5068702ca862827f1045554c67eada8cab6fe51723c3fd8488c506b9b240305428291af2b334a25b3a837dcc336484adc95cc3b504632c51ac586d19be4d2375db2d1cc7b9589e9116b0ed9de9adda8021e0a9226702d1664870656b49fff32f1cdb7ac8b0da6b76a147e26e82abb5af8be7b89f5b7da6875e4e0fdac8f75f3f207667ac5665b5773bccb02e216f810101e8661c03fbad830a7359641595691fef13e806c959437e62ec02812c58b99f15fe8fffa606bb64f92143a18a22454b7111e8ac9b002373e2ef64bfd08a7236404d737ff40206f650c58eac5dad636c18aee505becf9ffa251fdc4bd5d01b1b6b404de2dc0203d89e550b1045627faaaaf00d3caf3168603b3dd03300382ab19c371b337494c85142329ab28989706d0897d1932d39d12aabced55b42dce6c8aebfe9cf32b8ea1a2e7e650815cfb8f463e55579d63eac897cb7f7f3e9da93f6589b5a259257cd4ffda9c054c9469a3b82340c6411ef028f0253dfc8debd2e0ecb1783eab3ae051478edf70a2211f2807c15e82da6e2d8b6f6607ec85d7df1e1598ce7a19d176c626b15ce427e25560bb2a0e551b3a8e2dd828396ae07e737d4b8fa063b9a2cb53bfab690f5475e3bbc995d3c910b5d24c295c6c2db9cac8ee88fa791872a05e87217f238c7b2767a0a75a5e6d6a631fabc3b7630fbe252d30b49dd9d168d611e633d6cdaa94e06a494daf9855933ee9a32d7b926cf7d91c818c4c75f32404d450c1b17d0ad4b6f9fa3a4a5d9a559db482e34a6f247f49d827111d92155df40421a8f9b9d239ca0f7f3997b7379f2a913c8f45844af4fadccea34d5e2b08bf1d18f75cb68581a84994bfb024edc0b2ab7ad18e0781f0f57a237a62f965192f17786a8503b1e94560ffb12e49845b13ad8ef5536c0de79392e4019f79079024cbc29f12b57954e526d57dad1cfc7b10951436d76fca63b33f489b31eb858836336b257c34acb225249c06ba6d07b4cf4313efa0cabeb3a1d9daa2e5aebfe9a541f10996c7629e24a6f3862b7090f1ea700a47cea4dbfd01ecf14cc9ef360cf881c9ebcc68ec65c581c492068ca3dcb85b943e62bc1c2d283bf6647a397ad359fa336f0fbfce312ff8d053f000ad3f94bd368fff68a8f3c4f699f15ae7e412ead1f53bf4ce8cb2d9aff8de935bbd63f12edc9976a164e001d0cc6630334fedccf2c6a1e55096265a72d9455a341962d3271c37d29f50f456e64d1ac1780d13d261bf97e7af966ba433379044778100df0676399a08a56e863f334fa45d4be63c9afa405bbeae19d26fc70efcdcc5db8c2c06162fc1e76083cfb71a1abc9330342f14be3a8a4a1a72db513eb562a2c9217bfcfb0741be627add3428ebd3fdb5bc4699106f61306bc615118c586a0f66faf6bc9fd85dd693506c84e14548cc9cf65589ee1e0ffa90cf4e6cbb1ae39149590953876a24911270723dc3929cf7ab4fc943da222bb5b636317b68269f3410013bc6ab44d423320840bf9bac02ef824b7b84cd53712bf3daaf55056434d86cb60645a6f63c72e4eaed10f2dbe82229c79e476729c31293c30b421ca30f9f71ee479eaea11939181887b85820c3adaebe798e6d911a614c3a6860264ed7f81fbc65f0c1a1d3a88077dc1a0552de0e2400e96d13a59821c4d57ad37851092b352ccca79c39af2cc9bcb8a3e49bcb466cd7428557770d3d69c66b2cbfe831b97ec3e847df47c3639da57bfa4c1c704d3dc0d590efc87069ac3841bd77ffeb189ea83a0a819241d5aa2f23dc82412f62319ef00ea17bb52e0a89fa8d0b4fbf6b2e08fcefd134b6ce1aa3028d83c461a9f0b201418e61ce1b27059ad98cedef9b55be68ecf818ba2cdfc4923040f7b5209b5a7f373f8a9b6b2c027bb1008bb6b702a0161d46fbdcdd22346167a30355d616591e42f5433f5dcf2b2fddbe2aac69e5e4039949f884110b5078ca1b228b6eb17dbc8a1bfa93f66d28a8294c7cd21e5d0786b38808c40d39598f8e1f9d4cb5bfbd09e8d846b3af063b9dcd48af4e2d3300af4494e0b0b0e94eb7a128e17497113432c63d9154dde5b26bae0f9eed682ccf44de3ed7ea75dedb8b34a8be207b5ea22ae29c033dfea0af54f90c56748e24cbff592590c46c4cf5e80ffae2f57f528b198a2b387b9318c832aaaf100f155dd0b449f9845a7bea97f9eac82b461d4f7d3961476cb8022d1027f2f3e3e15e1488a42417e1390c80c4df2b275b84fa3db18a58d0343a699f640d381236e7fe6b577568e10a9423bfd0d77f0983819714a6511fc71a2dbcd09a7874c70323a919c47ae220e3549ff34838ef2fe3bf24789c324eae5665b02a26cdc19bfbf361c17151b7cccf57f93aabc1217960679fed9c7b61e0d368daaa4cf11046f6c1853b22f044ac6bd7108e0e5f95943b22be834730432ff3b1b7f0f758dbe366a91c0b4bc50fc41788685ab7ea7dc26abab304ed4825d28956ded854070b81135776c489412510b2cd91bae7902ede9011e317d7cf36b784a599fb767abf9d0b8aabdf0d820ef0843c05c26880c2158d237cc72cfd3cf6116aae109a0ae32a67fd1ab6012e020fde91db0cf2157c368527227364d35ae206f399e90bcb488a0eba7d1319e132ab09c3d4f7aac9da93e3685b8d031d54e715907d75034859951c356847930aa4e22dbe6d3257bb7409348683feafa356b364468b989f4460d6196b06b3b6eeae3a02f831688f7b202ea9d2f0aa6ffc0236b6bc8b52ec131e934a4797deb7fde61358cb3b80181746e9e5c0ae3631f129a7e34e75bd334efda5c69036ae2f5cd548270ce8da59bc5fe0c327e2462c4ffdd0bd98a2ad3501c942c5db3292433f59cce879fc2428c639696a08b52f291fdc84b7396b5ed19aecaea849a478f96edf784ced176ae6d6aea96a0100fb5db8ce70f778672dde9ebdf442e11c554941addbabe0cf222e5b04b57a626c1b21df59106a057b313908f67289cd5af75379385b6533461cb520f2019edcf94a9f81b89b34f43a53b9810c3374108ff6345980404fe94b144e23f9fc55262f96f2b4da5008cc324ad7e0236efb5686fc737c5c9cd93416a6e7d8f3df5a5c3f1bd9c0012fe76a80bc8a04e6e7f66445be2cf072bf57f67679ca242e5239fb048b4343bce03fe80db7df6c96153d19414758a21567e6938655ffda71dee62c31d1d1bfbaa82bd0043cb544d224ae33b8f3b798b00596636cbd0d4c75ba8ccc82ae690c0683cd78f8fb06d3b8a6680a2cc658fe0758e23493be5a0d6a3db8dbf06b1a3acc9a748dc57f2c48380d1f27138a6e1e348e786d0481d24cf0cde15e1be58bfca2bcd91ec5c68574942c93f970f9e07b537e8fd49f16c1073700fe903fb75a0ae43e71cc8e8a5330d8cb1ddc8e19000997ccc45b19cd34a7dfb75aa182d88362a1cacbb2736c822e245fc7d3c96654b1b75ab8927da75b3124bdef1a18f8a2ac3ce72674b79f1ac889dc07eae0487fffa2fdb42b648332126d0be4084c8f60b10140b373996a4dce57e37d6411187bbeb39ca488ac7a021816cb8c525a9d480df35c15f504661ef13508f8231a0e01029b3ee6ffb14656fdd62cd5e9f96f38f524264a3a42a77f7a7057feaa2006d0f7c346469c6fb6ba02a5a8fa3c5048a78d8b7a290590de8a03ea8c674dbb8dc175c3281c8a7b58f7f303110f0623228b7d93cfc4070aa27c3f6b7b35e7c7f777bbc1da657adb099ae3a6f3aa4a24d1ebceeccc2cd050c1b174afd1375e3d6a0562d21f47292b2cd7baf9c944ca86d0d9de80320be5b28e9facf00047f8aef7accabb19091966d789dcef9c4e7e0fd175cd748ac2bf223266ebd93b07f952aa62271ce332caea8fe405905f15c4e146d68efd6c750023e9ee1cc1c1c4e1ca2b507ab54265b182ce56c40cbbc72c4c680997919aacfae4c62a6204911f5a9fd64e5a8f52f139cf7911f3e31ee800f96c3a5ac0bc776d1ceaea5ed76ff3d55170e2e08a7726b0266e3d90f8b74f1135b6c6495582de8092cd198479ac1e58b40de0279b5a7671326110afdfec580c556b63a5ca06b617eaa55e7189c158613ba95b1cbe511b7b903156e3758a59916933e952634810a1f345b9c5c17951392adfcca837735b0c9fec4323faa484e390edf95539128156c894c70439a0de1cbb7c02bf60aa7771dc66a16f5c68e874a626dd266e9d0de288b5e46a0f9c64716d6284fd0330dbc2756da2cd4c75aee4f4adefd463c45e4499f4a237546d71a5a73b9d8904c9373900252785fd7e227e51306a150d2c83a7c153b34968090d828ee00c86623b1f7781df2b6d1fab2ccc7f3fc42a904f392c759d6ac616e7677702964920f288feef5c95c7903a9d548eb8058d0fdff41effa48554b6fe8c3d5c778b0ee1add481387e683d7865643b93eada671ab105360caae1ccc0afa5c2dc1624b05f5a4be7de87ed0f54ef81f23cc3954f781f1478169195b430163e56ea439e51156731971b9ce21450b9b93dafb4ed31d3e76d34366feb69238655e656d45e575cc10b8eaf76b4c48267a386bf124024fa9d75a073dba92fa5e463d57dabc509abde7b5e2aff6fc2337669b1f9618de7e1b4aa2ff482a1c5b00186ec10a50f953c69c5cca71bde2ef0089db1a9234f6cfde484f5c461c26e03c8b17d4dc12e6e4859e937b12c6d513be380c730b640a96ffa9fa4e80ff8e470f22e769cf4d8d2685bb45a094ee8e6b6e91f115a2b9f7c982e4e4599a071abcf7e09c0714eee1e30edc59526eebba60dcf9eb8196f106e9622100219fb8282ffcdb064e5facf72680aef0e96a58b004398214b4a99295ddddcd7649749c20fc01a374d6f7d5a15f603a2248774362803adbae251c548f227cc28f0c2c891486ff1721718c214f7ab4609374d1faf26033adf1dae7e15c2e922387a39705fe02c359d1ab9263c7c35bdd8f2f72ffe3cdf4cd39a04ed1fbdb715cf4612d2e88e60061ee3ba74251c78380061536cfad140af5751a70f2adacbfe9f56e8dec5a50e5d2825f84d70e6966f3d374e5b3a800c2082c3279aa00c5c8cf8c8279748d59c8ce9db69559f7bf9905892641d2cb2f3cc4d3abfb44a5631bc06768b6440fc2f95558f82fcd42bcd763cd68da7a716e6e02ad32ef934bf67c3a01ed9f37d7c02755b60550ce9a8c138415ba721e500594962963aa731bd8a857898514587ea8ec02c83ab8ad732d09246301320bd74b56c48a662e04bfbb9a1071085bef076df970d21aef749a90bf1498e0a01e92a070041690c39166a5872335326508b420e6da3a8ba9828f89be2b04a551f173d84df6219e42736b10e448132cdceca82761e8bf942c09dd0b9f13b777de4a633213b5f0dfa8dd28c8eac7ed5d85d7929a8aac0396f025e5d2acd635a40fa4e985aa324d36c1f1cbb385119ef4f83b5360a5ca1ebdc168341a62de44c02a5397ac0fc42520c7cbb4bb33de6563d5ac40ffde8466ef6eb1beb14c06516c983eeb505d856947a66530d3e077459efb512b75662ff178db6cb398f021668ad1d9ba98382c6a78c6d2ae2ec174853f31d2cc02d8db3a076712c3596fa98c40d334b8e3e92008efc05795ca72d40a0d1ac78bf1e18e9df1f9b9e263549db60c2769285b3a33e6478afce773f1e5b0f061d605a90646b00c5bbc2a26b88447a22c500b168a26032e838bcdc4a5dc2289c0b3c566733f853d4b529ba0ea6d4378361b29bc9c9dae89ef2f6895afbf28b0fd419439c60edce2a125d1ee9f574c78c73a909a15ff12192f44279b3aeaab635d759a5a2624e45ff990d786f9200557114833b730ea6a0f508719fb25fa91a54ac4c2943257914e00b9f793027b498aa6b51c7ff77608016b47be26f47a25580218893d4e1964eb214ae0c1b4efbcecff4fb68df432ad4a2b053ec64e01f3e168232a1ed2abf6b70d0130dac503ce7280f491c248134e8319a6ca029d7b66c4475d8c10c189658efd09dbb2714417a8f9d7e2a16d4da0e31eb7c1d0367067178845e38e7608d21c0de872f13a839ec8ffbf0bb3df2f7fff07a16b2548bb827471be42931080c09b9d1e8951e78311f1a0b0715a1b505bc1f7c2f07ad2783769e464d9e2afcedf6e86342e23939110f613a0a4b276717b666e47b24c30d1d308d7c6bc0d0150d7c1ef82f471b6c1ef571f40787b956d732a000b437b372c57a7ccebf805007ad20320c1ee72db8ecba6ad19097f15d7bdb8697a856e2525219bd520e278e5704d863eee42980c2ca7bb32a1e65429aa4a2c1efdf8aa303367d9b5f3811d1db739458fdf95de0273b455425640459802e7dc15e62faa54c9f66fad0b4ec1b47d01830ffe610c288ced8ef8408785e11e053d2d65141fac4c07f2952c1e11fd1e543e9f5044167f68501483536c6d16e47f72d6b14e617c1226dbdbab0b20a170d63eddff485907db1a6f26211677c217dbcd868053f46b6581e0ee1f054a3c2b7c9575fc432db992d1a38beea1e6bc45bb50c45f9093605fa3ba818bc058ee2cc8d35ef9ff049e87cdf58e3c0dfda68be59fbc4a7a6fe9d81ed6cff36e42ca58dbeb8baa03037520d5fbb9642403e4b8095076be6a24397d38b4214f251abfe28019b3fb52ca74e1688d65745df0d101176ba7b54ffb98faa96beeaa14ccdc3340b9502f11c2b65ee39d75726b43e07d246e8aada624d75341a856ae4cdb0eda6a5d3897293ce044ca4c97fde8e59d21bfe92d1105121c09e8971e6643b44cec7fab701b9626cb1d3727c6b6de077fd1387e5725d87f5693380be07e682fd752dbfc278cb381aaeea47f92efd0e1bcfd3b9e17bb5b63cf99427d8943d4de259cd2dce802cff6dcf410aeb83b7d9d9800582dbd17344c6f385dfa86281cce3d99daa2b6a2ecc8f6defb2d7a076a44efb06357099a6cd8f604803abecbf1046c36c847fde9f55d58590fa0a81a813baad3b64a45e7524e3379221cbf02c817f32b86ae93ecc958b63704b504306036f7b5ba7c75c3ad814293c8bec344e32772a3e1f4a233af7203868ced344c425fbdde8e68a78e266ba9633d217d4d06dd072ca14fe8644696b61600457c0928471ef5662150c34ca0b399036a77c6e2c5f96b1b09571048f827efafebc8229da5f25fddbd3d9a2c7984b500f516a25519e0e3628eb11526859ff2fd05dcb00f138e4cf94b0604cd97ff03af6513eb200f07682c076d035a1407f3c69cd910e23f9f0cc837188742405a4d3698ca0978ab6f8726aa33194f5fe78f6b5cf9da1de3118959bb4c055d18377e664e013bd86c5a70ba815496bd0f982ffde6fe100f0242e3fef6af5bc006e7833be607af84b9577d207d35e6ccf37d590ae414adb1453e3d75f5741e30231cd527f7a02476f029102b3bc7cfe1788bc690ae742e37d0ce94d0ded79bb8ec41bdb43ffe8bd3f159566f6305dc4e06cafa2a972d4c0e9831437d8d6d6cef2ae36ea81fe8c932610a880b51d67c5025e21835945242250d40bbf3649918b1bbbc9f459f2dcd571ee2f5a7114511683716d263a97744b4f9a743135163d7ceccd815ec4a15d9602ef5c58ff40c336ca952b0f2f745158883aca88f19860638d9d8d5c82c6207d5289051bfb4301c20350916fa317cd20c7b62bd057e295b9e32513d3fdab464c2d5188e64d19e434f9910515e3063895f787a8580867573dbe021a5eb61ec6b45aa2e25cebd674070a145f12df7a219c0271e0173f43360b19e3b47efcbb0668568daf42e59e7120a369c63b507527c18b73f5e9e1ba5d1914326b4c9abcb897733481a6256c700e11b9ea09f238c4a85ff4347fd93a3074f742ab978d6e451e225f94b5d449e478aba6567a2040353ffd144db2336b9d61cd8e282df7c42dd92ed737fd96455cf24c999487be06e07480084e3266ff248e842bc02f8786e6615b8132d7c43e176e89689f52a23dfa8fe19934af08b3490c8f8ac05c36e688ef47b1ac3153bde284c2be9576494af410c26623fbfca99de77639718ff14d38d8e8eebf3dd0f6a57bd58ac86f0aa9fc839aa876ecac7e18b7a6ec93622c69ddc5170f957639870bf032b0c5d36dbbfd92bdb64416192732e7ea272871e332aa8503ca649093b9e7bb93a68b9d96dd97abc1894615fbd1a500ab32e9e0b87c4ef046edbc57821b4705328c49ba0ff84de303c675d84d71e8f7c413e295c667bd82c70bc10dc7231946b82217ff87c8dcc511bd753039494beba0386c30310e2764dd08d9fab7d9059887c920f4ab0422f5e894605d0643ecfa63e29cc6a5f3adfbf2929fd33b91d13aead5aa7ae7d2df85133a2cc3557bc7237b9e8f28e878de3f683b2baca2ef15eb9b91758576c79ca28f7f1b233a2ddd0a4429739da379ff53b85927ba026424000c5622f3e876aee03c70ff51a70e45dcfcbd3f10de107508718849eaa3401f3c4423e41ba41bbc4d73dafb86cc38a33442d822408d5bdc12a12d1f20646acfd9d132143b2d426f64decfa52adc850d5cf8934783393e08a713d1fa10708ceebc4cb0bec65c6e3ea4e704efe4df2f132a9d06826e289a53f591fc79287fda3fec0a741a82816fa69daea7007b056a50e0b6f6abc8cc0350c5f401913d31edb67a3b492dbe484f939b49366590c2d572152bc9aa89da9b46047dd052f8842ccb3e2a633c41f82816adf07ebcb07af01463e62ff16ece904b614bcd8aa9645e7d4f96c5529bac9638541cb53e09f098a58a10594486a3216b8f99aa1054332c0f43627fa7d667ad6cdf290169130223f174e2edd3e5117c7dfbcd3f9d0a908d8d3285a13cf2b95c137b1203acc98858b95514d377c412f280c85d7c24f9fb6f7805d1fe7ac0766f570aff454b5c717d43278fe1df9f9dc8159a2b7094bd7309fee2e0e845ad1eb739cc550dff7f83243f594a6cb037696bf9858750d74330fdb6b68c698d793afcaa1d449c7a35a355bebd3916260efe1592611c88e93d5c3f69729dbe2392a34fd3708b2e9bbe7fd0e3d08b135a139b7456686ec4c8bfff2b9673f4fa33e346e3c67a6e5f4be71df0292c621e8e912b0763c33e0afa1666e76abcc29a0305efac611884af59178ff041dabdcc19173c8faa951e149bf1fc8409314c5ea56cf9edf3a299ded92f27033fa64946b33b61f5db55e81ecf1131fda5805dc2429aea66f5bb181324c3ea06d209267fa56fdbdc3b24bc2b92cf8726878bcb662a9d426c8f3df7fc5a3bda317ea002823dc015ea32cadf2be04286abec5a08829d3f4cad29395fe50fba9fd148aa61f8ff805c3542b1e08529dc0497c7a31aefec4f1d5c2f756608c70689c6cf24a5e86b17c312ac9849281dc1924bf73437d687cad0eae4035f8d42ce8915759379096a50db6811fc2ef80badaa26914615a1304207ca21434d946f04332e3030eb77c7915808d17138c27cc06aa295191c1f3afd7f640a50b792ec248e281895a03b7ee68e0c522d02f85c1417ae924bd0d9c3e307d5956cdab9b0ef97c6f7ffd3090d0d549f568c0334dae9ecfb841214b4741501042f6639faad6b32ae0157cc91eef4e0cdc8affd18e30172878769f91e97629d14aa6d4951a3e42890bef2c7aa40f4d8658004ed652b64dafeb89aaf0855dd7ee48a78600bf6808387b5a481da456bc278388da4e3bb92bee8c48a4717e4b2e21e0fdee3e727b1fa62aa6e918494e40bacdb28284d03685d434b2fb6d801b9b67ee81415008714d0db6d05642030dc2148d8186771cd669cebd83fee8f7d58b13acf9754a273be45f84e4aa7455f7c5304f7e7600ec3041349b519c78cb11372f300616b6ba9f5231b95e03bfa87418456d6f298ce086164e63d0731e9db1d4d626fe1dac4d81ddd5749eed2bbbc931d04cd10cfe3f010f58349e0ea80bec17556950e9fbb56e20b1f112a5e8a296bca4a58091ff3a50087c34fed6853efe4aa4c51dd58d003d7a94922ea56b20dc1c007abf63a112a63bd5b52769f235f0dbc28175fc259866ab36761683babe9224f5786d5f509d6faa3a3b7a86d385d04a3439edc353d2ca415b033f8d48da1ae42035f743c8e35198b603a43eb75ac9ce7f8f22522d97bd520c2487db3ecc559a11f6a21eea7de6036f75942213ca408308b6c2d6d2929b9e1a0e0e41e9fb4aad0b083db47c6ef0945f2d8380611c22749482286b3eb06c6635a8dda38d688e0fc17d2fc520fe4c915e228b4e85c16bf27efa9d08ae4dafca84b8d27073fff3ab89fce6affb3299f922ee2bf76d66e647bb6a452f8fa1981a90f23af83e73ac313055d41bfcaff8c68f688cd7b5901c39ecdf439c879cbdb7f45185b5e329c2e269742f2865b209c95c1d6c1c2ae32c87738afea50873a39ef99a108c611f7b9c85d4ca45529bce625e62690f2ee427615b49775407aadaf91226343ee6a76d385e5a68f408b165283d2be953dc89a507c583cac852482d0cb4f4e4ac9da9ffaa06fd41d563b18b80c0fa3cb0df6a6d8addd380a175a30f3fa7fd5c8bad9fb389f9fca3a6aa7dac1131d7bf2d73bdbc46dad2b7dd50b210c4b0ca42881ed76d6b6b92c5842b7a96819d8cc95e9230c4f2037e78ee59b49f6c4f8b2f0d79585f0244c821552a0243d42f1e90c3ee318234c75589e7d13da536394a1e030bf968eb1e0f8f47e5c5508db303d5202baf22ace235cc147a41c7c5ba2c8b501a124955feb7ba47b6a3b97f7831ddd6f58f4057e7eff670ec56903258a1caf4640d4a37e314f667bc64c29a357f9213b4095657080ffe081af9a9dcfee8a0b6b0fcd887a3d3f940a5ca84f9b47e9d836e39a7b38aef1b6bf92137aced9b7e393447040c7b4c56e301e4315c2ec7ad6485d5844ac7928970ac8bb8cc023153768d2b21442cffd79bc56bbb654b42663ff60dd9789e021a13d397a6a5519c4887c8299799d05247b1d9ed03519be4055ee7e28be238162830c7f53997cdd56bd9459e8ffbbc9cf8565da051f9befa5e481785597bbf10fe3a33627b1f48db19fa7d96c0c54f419772cdeb95a1865c3cb1fbc64c8d7c50917bc39d3d578cd89626e0b87b68e714cdbf329b30b4fb6ee29b780f0ec7abf061aedbe969c592bb2d68720f35e30fb9b06577a653a72ee0c924d88298ff54e16f7eaaa2b6ad9fb94b84fe0427ad5cd2bbb31deed2ad01f68b4161841fa70fc9a65cb18bd18299ee701aa9e1d4ce4a9b51591d3f4bf0a341f2d83f5088ace1c0935ff268347846674c7f9239da484aeca5056a41d3ffcc8bb98d23aa67557c6691b7f62d169acca447033bdd797e63b2fd7c04b4cf1eb7eed40418b267a238a6c2e01deaeeb3cd8a5bbb3f65fbe11ea944b1b69cf13d46e7fd909e670e9122f4ab8e30a1130ac0ee6f7040c1bba885fff90d08306b74e6d195912fda352ce27265efe7b7aae2e74605940483ff2b81d17b63688c9f782589e0568e0b5c68f12b2553f9554b13342b14c596c8db9086f21b07b4227fb45f85ffd17f6c93406dd389a2e9cbbd30450d7b0c0aea049a3fec2600340e542512f12cb779101c1166ab600aa99b788d74bd2d12bc996fc8e74083ef34e8aba6394a07a8f1dd84f92667c06c509ad5d1c1abb46c65e4f563349f8b7c507e0114a46b568cc50f4efae6b874c55ca7de8445dd995b6ef92ce291aeaf05603e0647e9b138f2729ac109bf1d71adf2e524d58e125f2a9f60f30c47a9e5b4e74edd4d2d1496779ed27ff42c3662257c2b719e7bbf1adc0d5f36f74436a5fa9dedca6e9c70c9a9da57d391f514d7d608ba2c966c9763d6a03f7191f6f9e454ec1f11a8cd07ba6460f0496c3eca7289c57be6d0be138f40abbe0e5a8e805df253c5574874420cb523b79dd1fa2cc7497279341e0735349e9001c973d33bf0edbe5c35fa1fd4766df0dd20d6e5400a9a9ca95f3e92ca68697bac8a4c35495d13c203ed990366f49003617ed9c50b15a7d6b3de88716828bc1f73afe68d6cddb258a091f7531c98c808c4ee99a34d126a7e1e6f83532471770d3cd93cabbdf5cf4b480a61f5057973140706e65fb7ef42d8f2f62963ecca6bad5eab4b20978d3f74d55cd5743717d6157a06d764b06c3993cd13ba29eb8fa25f95f30d27f433be91453d27d9a06cb950a85c01118feea8ac2ea6175fc9e02b04a693b9ba25a634be627196e3476b88bfca50a1286d2b2e2a0de928d38823d1f1d2f97a22aec8358205890c4d566321bbf123422d189771cf754eef8b1ec855bd7b6ab9049d025dc3006ff7d61728eb933deae10b9f76a82c849b86ae95965fe59968c9f9745c28a3eb0ccca01bb6cc34245ad50c86480c002d724524916beff5d019cd0da24e3e45dcfc1a8b27551703ee5b2878a3695e63d7f44e3556530d396b8c2b1d4654b075f63a6b5b1ae8f0b1ca964be01a3318b9ca4ea6a2845cabb92fe07299eea555de98df88733469e9c1967f3edbc687688820e7d975e255d80811a34006451cad0c11d9d5ec7a7e7577a59039068fb436063392d7a0371e63a682046ba0435b40816ee000dbb7fb6839aedb1970dfd764841a0051c1f8e91b33313225e6d02ec9d7433829df8eb1b2d3a565873917a48ccd043548ed32d3f9312d50292a092fc70d0aca1d0318a684f0a7ee445e9db7650717b06836e7b4cb6b170f56fd21f005d3763337b043995de1057fc2eec39b27bfca26358d395d8af025587a4377156ec1c66e648c5a3542f358506e2506d6113df658da33703592ebcfa21832caa94c373665941157e66275d900606b14f0c6f66fc6e455ab2f9b21cb9050f4eb06859a714e928041c5230174d16c177360215129e06b43c37dd55ec3441d1c5b093cf0e461cf9bffe6a053ed0a094ea85e29059bafbd76280d9c6c3cec9982c6cb6fd1af75c34d0c694efc5c42e326ae0a61d7ca6d5a20eeeb7279fa103fa2438a31d245474726e25db28aa8a3c2edcbfe409747697c783630bcca442481d9a39b66d3b8c8a75aeb2d0f5a63e14a096692f0423f0eecd2df4b5982800ec8f057bbd42a8972b0cc38f3ed1ddfa00f109ee08e8ab2fcc52c76ef2877cd85ff4748e04988df9a89cc11562db385079e7f889877a00d82bad8840cc212f342b436fbd64b333188cd2a1fb1c93cf7d5907ebb4ac15ef10acda859ba44f5f654bd11f5d3da52c925b140e791836042f18cf11821ea994b64a6c87f0a36ff1bc0c45cc25ade464088164d7ac9cd543ee1e6eb86f5b121f377a8cbff8b802983830e638ec49ac79a48fe81ada179f394f584734ad973bc93641be35bbbae623c6e9056d2282a3a2c6be11cf5bfa8da203ebb8243622c3cc6d63edcb0ef1ddf02ae17858a16fec4badacf53f2fef53b9189d366f4c567c9e6a860ca96f187346560a055ae4571f608715a56129e39c91c6c35b157713512877cfa200819dac2731400628a99f8674756c6e5fd5d8d46ff8ffd5b9681ad171417c5e0269d07f7623abe1dfe8cff1ad2a35caae3d7d520695a61c99b7800cac3b35704904fd502b49457d6fdcf649bf61d721d362fc71fce7cefb5681d9faf8494d8e7dc41e334cf39afb621d30c8fb80024493e06f218c2aac37ecca529ca69785d44743e5aebf1ca520d57334041dbb33175a4f028e2d172a123e7b4a9cf32908245ada82b4286632222e9854dace7b9555766995292f6ad7fa5f3bcabf6270ba4e1b9e1f913026959cb9f94210f49a7512362c8e8629e756a8379a18d2e4d7804dae7c8e23e0c90340f664bc8ac0892fc6eb435db28ef30621ee6e24a044b5bf31753a3f08bf13a059f756bf08e02c7dd5fed50d98051b657c4784e4b549cc4961eeae328a4c27a225c20d1c70d30dff865e99f582bdbf7bc2d08ca04303304e5c2b8a4c481662a0bb6dc0fd885c57bc5fa15878144a4805843d996c27b1dd0af495107532cd3f016c97244fe51f42b117c3b0033185157d5e52fbcab14e162f943d4a178681974aa19f349aeb81da0ff039a331600fd8157e1faa8a7074570dafc8b51a866203fb271fb886043ba38703b8f226d71393c0081b0c0830c5ae59e231a978176d5f163d5565af262c7e1843e7a5ae5a37a5406324da4c5e36e1d9a9fa2acd06333efda0d08b91d89322e7ef7728d824bd0aa621847ede7b4eb40b5888b1929dac4ab0f3034c6a5988546b878a76c0be86710195107d79a5424bb7b84c7157b7137573025068d163ee3cbcc247ed741e215997ee711625db5366895e3afe4aa2e30b0ada6d19a5f7ce3a500a9a0f7ccfc27194e62b83ab6e2bcd301387883507b818db9c0cee35108b00c293164a8e9d4599008f787c15eebbfdc447ad04d9e0c8259810dba43c0b3c16bc5490b71fd94d2536019e3fb4f5229247556750d685d5d361bb3422abff250f0c68e4ef4bb241c85009c5e570cf6e2703bd649ab9f90817bed83edce51ad74cfd49a02d93a719dc2532f6594ec143ec7d23b0856cb0f7915541b7caf94ab8763eed68c0d678dd97ea2712c2e78472028ea2c1a1574e3c791ffbb68fe2f6853f9bbe0b7b1262ffa4349a89a82e2b6f4c0eca215ee3bda36ca1dc0dbb1be01db2d7b5558ade5f6cdcc95de9de97ab73c84eed3fdedac6a3f5bd7fe0bbb76fddca85edc8e4917cedfd26fd78527126317075f8655114fccad70aa589fd77c1ac470a0ba732d3da569c872be2e592883394029eb59343257543ee67fa3a7206de93561e43a5bd5d50c7a0ff5205c3aff3c2ab67416f4a054087d61fc6b8901c0fe3c34b6075653d6c4b68077581f08b6f4098873ecec461f5d898cf5ca5d9080abfdfb7163ae6357e549df6e16ce4c85ecce1ad288e50c540834f6e08a9f56753be816adaa29478851e70bfbc7395e6d5eeba661c8b72c95f26f10cb86d19573edca805e8954f067f133c5b6bf89e05497124f7d8a8c999f87084ce2540286c969696126b678b7fad8847b76166c732cdcb379e205b5a893e8617d64bc1c77f2d734d7b75a2017b22e44d4d6dffccf3daff14792183afcff010848bd553278dba3bc35790ce815e713ccea8a0116ab033bd02189281fd6488101ed80dfe4129d1023bbfc481c032aa76515045b44b7a72a4cc07e28cb7c1b18f8ffaf07ed69ec6ed9aaf43fd8c1300a729e7fbb3c51592ad430e8785aea844a0f0e54eb9b8e425b5dcdf1a253bff8d421bca15ff6ef976c65d45e0af34bf9e2410cbdc2d0c48cdcb56b83403e4ac7c02beb08bd9bb6f702d323932f5f7983954d83c8f368506c8708739173b7ce362758fc126c2fba024a8bdc99a6b43a32e4330d02e06a7f60bc74343f97c036da507d1dbab6d721eed82622da07cc1a988efbddc030ea5ae7d5957a14006617cfa6b818065bcf96af1e4779cd4af909e1d15e70ba7a377dc4755965530cadd1bb681d5c45f77005920554f7fae7c7f1933682ce43dff50d1dcb46166db1feaba2b15ac8ec382b57e92151b629762a6812c1200499366ac43b50959d8645125d2c247d4c1b762a749a6f2a084db893a7f617876b15dcf61ad135885fc8ee201359d0c12718a91f7892477247b562596318f97a6da2fdbe99f8da0a34fe1f3238cde8fce8e98aafea10652c54141ddf1043585c2dfe4954e31a1fd5f848699d1c281c5257d01d091ba98fc2c8e22906eaa88e696a830a3bccdada7281d6021f9f023e8954dd8fcd805150a7eee5c9198ac195e71b3cd8dd9edb6d524382a40ca1c4c8465eaf2f411fa94ccbf5af09e6b38ae5dedc2661e656f67536097d7ffd0cd55f5aab77176953d980944a39f1c869824d5207372a39f64309cb3e3dbe4d7092f58067f39df0f59b75a29596c838e4a6dccd9c832c4b03800b8bceda469ec35ad62acbf06364a9d6bab7d17bd6430c9d4433eaf2e6e7c79240cb34307f6ec5c48fd805c66e6a586193d8dc389701d2cf80d1cc42584704cb229f620955f5092a09fe36591cb3fc1d96375e86948fe875e9d94e6b6637a9fc4feb9dd7c4bf1ab640f4020810a459b2e0963076d1b8fbb7d3768e8e136d5369b2296696050a9f94698c1fbcea2fbf6293374a0235c691197a308a576687d8fa4c158e0785a84564151a293e5bfaa60296821841f85f9bbd1daafc0e33781f32e82f1be816e8dead3439b3bfd353b5f283029a35c1f49966e44a4894049c066164d737403ea074b55d4a475b8776d61f383e2c0d6aaab52bd08b9d44ba6160aae63eeae0f2c44f0aa7b1fae471112122e96932b0b3a689c0560edd3412d5496a9bb14d81c85cff9550dc1d37e308184039fe4c1da9cee152b5012c49af05f5d486d2ffd0f010fcebcc1079f641dde18e5e8c9ee5a0f57887031eef9d265b06e1e3d55ccbac4f5f7cf19851b79b989d5c48ad192dd30247bf4853a26f895f67fc1784dc753eb36df69ded7eabbb59bd5b3346b02dc70c7d87a3f84c47ee5001a201e75e724befb865f6a600af8caafacca8b14d3adadc86a9493a65055911fb79715e1ddeb00d005f1bcd27abd1dfd2c890f2dbc0c677701ba440109b82fdbc957408783b192214b44c2d029223346c1aaddd918e64884faadb1271b22b6fc7c8d53326e1b1ada52fb3b734c0da9f87829455a19513faf6c6e384e0edfaf92cf750b14d28ff0eb5f42cf1b34c15c21f25c70bfeb81c30103bd656cf1bef5b64bbb2b2261efd87a7d6202ac66b11ed2c4bf84677f86ad5aa4992e44ebb998c3cd2f497df8ef65e8d8497fee2e8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
