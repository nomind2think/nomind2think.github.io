<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf2a8727baff306cae17e557f819b3bc542f9104e791d642cdd72830534f6363ad2190b9a36bf06adcd42dbd3350faed41d9ae81b00e133c48a75347fd620443abc5fc4a32ee4c3740124ea59eee19f0f9572ed9694cdbce456dfe15bc2d5882042f762ecc41beb259b91f8ffd056f7d79f4c87460d79e34975895c8d7c1d5519461241a2044470f5ad93bed041bb29a5f5d948423072dd18d002d64b78b23a3b4540437315a101797a2a8be23f34130fc66bd72f0ea9a4aefabe44f557637272d10ab1bcea9f9e8a4182e3e6a10e729ec2de4c60c1c748f9cf4411929b603195101fed2ea3f40028bf1a03e86106c053cf0221e94936b522483643df354453e364ec1cfc2574e2e91139b4ffae8458298e0bbd66fbf50102933666a63e136077538c40c6a5788b60efd2311b0d9253a6f01958d85081a81db1b9818a00d812b9c47ee1fec4c5225b29ddc08f7aac7a2ab7958683e4884b4217a78e49002ebc9b10974672edf5a6f23d2dd9ba1e4832525c5a0ed2b192906a81aeb43d18159ec4927fae51cdebfc1e04a86751819f3ea72027acbd4788784e2ef32d1eaa1d875ec602f3c60d70f3e9ad127e5fc5d88117990faf9ec5a2db40980ef41fb21fd93a4d7812ab9e09409dd41a4f94f156f46fc9e74d0364d2e0c9905436b8dd18109cd1b149495f96fc732e892839c5f10f53c41fc84426b9255eb9a09da289ba39eabcbc31b34a229a4b0ebedb79a6baab128ca9df054e555b135296d1b905724b3aecf00956d2379e8d85d6a18481cfb010c6306b90424c1342a110b929e168d92bc6e0a6245a8f16de8866dd854ef1ab7a67ed1ca0cd7f389171b0d8e365c8c299f5015140a9c00aa8c34aec1090e3f0654cff02499e3fee61c0b174228f30049d8901b8e202c6a5ecb6b0388081419f462044e8ee62149f3f0de36083b3016876070ff12d5dbbc5810bd2c3b0f64f10c0dec5c316b3acf5c35b72bda17e6168fac7722d7537a1d91c12889b3f66a36b7ae94eaa3ead97c1af8301e3297266e69b975ae6b095c204672ec1df1c3e76f263b7bfd1822c6654e52d109fab7ec6a16e0e9367ce768654b838ce94fb45a97b6dbf1b9a4d5aad0866dbc588c98c7df37acf7cd02d10cfce4521397d05b47920ebcb35743375bf6e936e3bba2b3db57e014ea787874acd2d17e45fe6d7f391518af3c4eeee9ab496b944a0d2be133770c4d19612d15ea74519db490db2e2de08bd4e79338f993c4582b46f511868fcdf1c53043d0a6251284a993515b1d45b395ffeaa4fe0d61910af74eba3864c3f25d9bddd999d9a107dcf6237c8e3ed20a2d784fd89a9d798b5d88ca91b50e60c1f1294f214e7b87a76e009a3e502a7d6b488d87eea18d545050bf1a3054e13df8a9fa033598793d9a50d9c063394ee4fc73d2730347bcb363c99115d5e108a87e32393bfa3326cc4916b9253238860b6082196d7eccfed36b6f152f2a03dd18789dd8f3ee21aa8300f6e99ca7036323ea9dce5be58816d66f8abc9cdf0a786a363dde30d5d311504bb267a545da2f886ebcb1e848e0300d92151d1b161f4b21d9c878a69e867bd68fa4dc28cf96d80d6e1e6c507e4866f29047a47436d5cc00af1811443e59f7acf34ac2422883bfd4e47eb02f8e0d56e402f4293ec476a05affd82fb01fa5045ae431b765aa0990b45f3b4d5ec4e7a0741a449777eed08ccbbe10e20dc413bb1c2ef2925d57bb30431f9b91fdaf92e58c637560e01455212cd84c6f4531de434b72b1f4543194ddb381addce5829a9be159df036073c729741d197f02931981ea7802ec5e72e4a7c138ba5f791be74f7282483accf207160ad9ed60a71ea11124a3a0c8dd00b790eb59947bee8fc839ee9d0fd2999f552a7f8cd7b2d60fc536fba66785ddcd92ba980bee764a76791d58d603b82f918ed97c6f10f72241acd7b4587ae1fd09de1c4b8ac9559b59fc3294c3a74e041011ee7946bd37a0ae549bb315d8c2f8f13756916288d37cb836a84936f7a05faf60526a8f08e9d8d7baf15077755bb73c07b763b2e4630aee01e870af628221a8f25078349802fd4a3437cff73e203318ab34a2b7a4d03adce448ce0a5d87b1d7a65770d63e70b784eb92a394abb3edda34d5383dfff3bc5690011ffa33fd4ce2e453f5c95a8d1d36c8bf84cc0a57127141ec4b4dd0193b1b07ce62646dd5714c89e920c266c6adb40f668a7a114a3d5092be4add9192f9b5c69e6adb5cb73e6a0d3d91ffaf364fc14c188951acd015f7bed4afac7d192a94b44ccce7ff666f2e1dfbe94814a0be342e80b4d32468cc2bbf1b21a6edebc69678455e154f996d82c647f27fe800ae0c10ac75005615da6a8cde73f65cab1d89f2b46bb29748c2ef1b875ab5bec2ee72cd7276659d20903152bc6b81dbed7e75536ab6b00828f2b1c4b68cb210f4482c26a05c32289a7cff180aa0f56e77c7b6e48483f840142f30aa682ba9cc4b82200aaae2b59740888e0bb3b3d0eba9048d6bfdc319883d31d528a7de53ed39a829a6e93fd7a1fdf09fcf1c41c23e36c5e0d79fbbefd74a7715ae29b252d5886cdf78fe89bf27e1bb3ba6531bd32873ae522e298475efc5152652738abc841b6cdabb70729808fe14da2ab7b4971ea0bb59755e6ce54e7f6bd45f4bee5cb9ea4b012486ab298650ddd58a5929348db5e6becbf55cdc417f94c037d529bbf38975cede1e7cd5cca4da8ea6740ca14abb16ace3be04bbb44c60b0c362f830fc4d8cc53e78d53f239959196acd9d2ffb06400ec2fcf688f8b8c43d46dd39b5b665538d8f18ddc1ea9665e531aa075c08349fbc2d220bb8dd0d206722e80c6eabfd71aaffa2e33531c0ffb145f30a74e41110b3daad7db26747713e68887463c62fe5da2e568933849d794c88406563cd1bf44f9c8e7dc9e0aaa001ed180c81624be06388bffbab1e3a679a2062c622b6522f541cd884593d7dccd78a05f99991f66497d229369e4b8b8b39397c76bb3913afad312c2a1b25947e95eb430128b39cee3ea4186b645b85adad02c4ac77e619770cb05cc99dd0e2778209b6c70dcca7dd1ab71e1e663b11a2cd5ec71609bced236dc6ed383b4c6fdd1035162450f854f5bbe12b19c68b69f41894abf361619f6441f6624658c820210e9f714329704bda493ed6613353a80e8c924b03c9aa8183039d5323289b29982516808e48cfba7fc8c8cafdcf6170b50b5db117bb0bd313f16831efd5ed5d79d99ec7364c95a42a755764997d8ede73ef4aa97aa36f9c427636a2f58ceda81ed2eafc646b5f6fb694708f21dcc7cd66f4429a653a78cba5d20f4b0ec09f2ee4eb515593b4b094c1ed7b310fc6a92e32e0d7972951ac53e77d24cc83cea7c652d62da33659e4488d5e3081df7369452268926980d454b053d5a9495839b73146f3894e99ffd8cd1da4b5350baa06c29181e832db81ef64044f58f201c02670a6fc92582753fd0197c0710fc7b33af54acfadfb2941c3dd0926b96a25bea47c3fa4ae82c2a521b69544a9bf551127502efbf0d87ee3113e10eefcd67c5fbd3a342c994d948d43092800e77aecaabb71d096ba77700e42345938082a14d56db7cc22745714abbb0954d2a70149c05d8b8df569aab1dfca4c002f83d35ed225f8e9284b8d5bb02602db67d29c66f3b05c9fbeb8738087f63e382afad8b4f94eb93005e580d578be2a3aeb3904ad7df584dfb15314f6efa8a1da81a3344551301520931342fd6ade1466d940ec5f2d5301416d603bd267901a95512c8d2c3681dac29eafbc92dfe3a73699d34a7fc27160768b0ce01c9053c376af38e3b1fe10e5e8b69435378044f2451d518139a7c3474a511187653cc770792e6c5577c5712a9cf020e385357f4b56ef04cba0177aebfcfe47cc9c603d8ab4f1e5e504711a9c81ef0da7fa90dc03812b1d7a41b20a59f2ebd8f71b975797055a3c93b77a8d1a12ca45aa887f2f74edcfc4052b640d4606172bd5ea688d6456840ed37d8ca1e4d3530843e7114b9c646f9f9e8fe38c0daf174243ccd42550b8b631b416aa93e2fdcf74f61f390a95cd11d05a951acbb4671b31c5a77caea0bda989fbbeb839ba41b7fb69d551afd8dd1b1a1bac782c51c400d8a8a921b671f3c4823c31002c5d83885cbf0fbffd90f175c1a192b55dd4fde6b187070ccb92095dab1dfa618dfcf4567423c556db41e5d14ac44567717653298c67f93e77ef408b2edfd971b8cccff1086cfadf911136c8864a3a69f853d49d3e47437e1cb9b04526c220c8ab74c5a83709ee3e94b6c5774fd39ef4cd59947c64002bc80a57c225490d673f8dc9a411339507fd3c041dcba4b9f7899b6b205ca17bedbdb787d0755bebe58e7e40dfedc519201bad12e9ac73767ab1510b0e6860a74c74f2c27fa7253ff9814be25639a2451a32640ac96d392c2045b8819d5de29ef0283229afc73cadb9309c785946dda5e9f6b00ad58650d51345ee3383934bcf40424bfa3fa5199ccdfb1523bc4e604b05c014c051c0b29383eeec1f14cae162caef0b4f87ad966e0242c72db74f0af85b0de8000e62799e3af40a0e50e2727c3c962486d03057b4bd57a212dcc3496e6cb3af2b062d0c2fd3edb3d852581774dc63822cff1b90a9cd34ea02e83545076baf968e2da39db36cfbfdb41e6c9d968d6db4d4de56fde35a3e36f370d41e5f9f6e3e8b3cdcbddc0b354ca31defc4866c9bf7f91a347b44bca308e950a884550bc78caba49a93e818619bcbe7179d43d26aaae5aa4ec0ca3cce8ae989dd49669caeb6e97517eb3c0672ba8b43d5aeebf4868168a7e81153bad621201de0f3e4f5297599ddc3f8134f6cedf089df7ae2185a47671dc6aeaffa0bdfabc2775fa0f28010ea215fe079cc51636d8a96cdc9bc44bbf5471d8747c65e24e0c4faa603a1d32c363a72557a49e7706d052a76be841ede2fba8709d8dfb40c5620df3c914b718aba712b5578cfbdcdafca318f2b134feda133602fa3100733f4d151b8c312e883ca5a46f74d4730c2d06923886a8e1d93c169b7e398d500c307c841d725fe1dccde8882f3598d3e3bdeedadccb96e45f6e923c43a060390e0b0948b0c800dc971c339a4f8dcfdf3b56130b9e700e10eaeed9edf3f2fc2419e8db8199a57cbc66d494497e082a1462774d77f6c9c0c12b8cf21b62886bd274ae222f0f8a82083d0ca736c25ab361a1b7eb804cce5a539f311c027124e546a61755ae3a00006ba024abe99602c73729ccc5a810ab2f9ae4a01438425be4ae63c1ccbc9ddf9a2f22cae960b1d1709396e4b767c61f3b6311928d1248d13732c08b43c285ac3eb33d2df3287432d2de852b8a78be9083925a655f042b1e42bb9d1e9a80144720d6ff7c5b14acbe243c59da4ea8f444cf80b05576768795393c3f199a2f3c6ff4c7efcce228c8a1259b2f3018308cbe35f603a6d411c1c2e3bb1520e073b7c6625d7ec7590e7d921bc5ada7895a8e087342ed09b752a77914c4dbb07c235212e773c1f8b402e9449ca4962da30a00682f4ed925ac791f0ec94a3cbd6113a2ca1be94c9db28e14b4ccd75472734609a77190cd735eec64314123d113f49c405672e4ac6731a4e72ae467f2e35b5db577a75775fa454292b5e602a7ec52d3ef8072fda47be16b72221cadd2e7acf9b756d970d07e61c9c31499bc9af57a9ad22a3b0bca74eaa734e9066f6d670f35e44e13298cf8df1e8aaba895e47495f20a00d57a645a494e761cfc482a3fd7faeaf830dceffec2d5dc019235ef25ca4c739a17556148e5ecb7590f91a892c59956ace60c1aef82e32615203ccc47592d7e50513a0b114777c1c79b1b3137f6a9f0065a5d7f95cf991c9a2b1d0ca43106227bfc02a1ec83a920ee813e96031c4fb02994956b99e6f88068909a0a28a5f2604098671981b8948a9581bf93f303cd4f744e832639cced9229808298efbd7c29d6a1d5a24f73acadc55dc1cb36ab08aa33016bb8ad49d8535232038eed993669361cf034a34d15bfb84760e05d70045bb0e1dbd22287c5d01b67c520a36105332bd2557a3daeeb1a666757d30a24aa34db24f893a0a327539782f37667c65f8b7d91fe23d7fa201a3e4be9207897ed26467eea9db4a3c528587ae17f91e2989cee9a73e5cbafdbd41faf509412682eab03e36583af71307c4ccd37ba9b6109ffe87056117e97830b4902b73afbba8d77974a29c42a7dc7691783659767777d7247cd8c1e5e071263756bf21fb2ee4e32e2ba5800d62012554007791663bafa8c4524d49bd98866bcbeb0c353ce215382823d89d63dff2b58d3f88dd5aef29abd5a1670c0c58df6fba7b408364ffb38aa79554dbb8ebc4e1a312441ac95d6e639d85c9634ec7f7fa641890a2f65ac0780045e9420527d8bec9c6796bf81dbc7f840b777a1be2efaacdb8855fcbbf660daa81c21066444c5da8d5eeb5bf29d70c3d791c227d6b1b93d675ca816b4df60dca3602837bbe3035d7efa78438f3d277de89464385a875d18e02f72330e5d546e65d40322775015f1f0b1dee444d642a1e57bee45a5b6c54e28c699715516d8fa0da3739e35ab8e7451dd64d579f17ab378a9677e9e6854f3cb0ae92090bb25ae633b09af2ccf201842bb6eca46f8daccf460a33e79e00af4fdfdf873123f3af922d5b25209055869b1aa076b4bb534719ee9fb97d648f0076cd66d57659a6fa83816e2634b7cc44b7da8bf2013a79cafd3a127b438775fa89f29dbd62709330f9340dd126d32b9ef02a465e9a4e94521495d06a7c7c01e1104dd1a671bfffd5310fd43263a7d2d58e0f627abe5af5594532c342e0c01a1957a2c35d6c200457aab46db93f3b3a22191adeb3127b5eb8243d0f964cb7408fb80788a1e26cdedb6def7dd52c032df93f7510b54e15f63cf445d682700a662482ac5c0250f42228f1d96411ebefe7d9fb7f932ddc48ba2d44f43401f18fffb8f26dc895a9bfc9d43d9cab8ed40cc6aaab5a4e626454b33459bf03a83edee6e2a56a15d28c9d70fb355e92bbd0de500bdfec602a027054a1d867f2600a151af989e1c1ba5d1467bc5b73a3a657801489e029a2b3523df387dfcc1020a0422ac3ebd86659a465ae0b71d1149ea5726197052dc71f6e196a31500193e139af068fdd9ddefd14d7be0522182631bd3de39206bf2f69855940142754e2890801ad5dbee2c9608b3d143be939c297c3d4765701a382a58547d9a2254ea9308438819c66d6c6e6525ca8c64c4830c423de83db34b08c69b116b6b00733ff506eaf5a6867611de6607aefee8e24a895997032d118c05bb80b20e83b220b70fdac1892b1d756cc70fbec73db3a27ad133b29220c241cc36c0832c3cc80263841d165d642efce20e8dfdb2778aab19d05f334b2f61212431f6fa286635fbe50052a90dbbb7e1769c9316cacce604f0bd566c9931a607d75d848521fc888197804e80d2911744a9cb788525a5c933631a50eed919dbfc438f341c20108718ad5a4f0650d6a850618fac4979ca0c7c9a90a1ffb723bd9655a2703c30c0d9640228bca5f523e35815ea8426a155d8eb0004f919d707be610d3b0f6042e5317653aca1ea554b25b1539bb5ce485514434b5fc88af34bbf8450a390f4f030079772a04151190f82b45a6c0c62c216e557181cb53047bc16add13d53839fae4292d41b241380db01e092d6932aa65dacc390885f930f60cd70e310e5b008e5c8bcfa4f6a14aa7bc98b6a2cd480eddedcc2dd2cbba14e40cdcd4a57eb3669b3f8ebea051c39cd96fdf612b5d91613604d0dc215e14dafe28158e320f7b52df96f36eb769e39baa70db6889853050ded5f2aee0e10590cd30b585c12241fe0f5116dd741d29c71f05287a692a08f66304feb8fb6368488256944c0445bd8ebf8229f80f6d4873eb0fb82fee8dbfee7a48c7ff5b62d65129da988c84aba0006c679b61fb650475f696467ab19f12691795277093ed5373d87c1a3b7f315abf28f07b547296639cfcb5f2b52ff36d4ae9bb455352e615dd4a1f10d56e351b1cb402365a9ab965fc5015e04c1e1c616e99cd9343aeb3535ba61ef4e3e4c8dcbc3c6c428c790f484df58474ea0cfe99844dc3a06a95748fff1cffa18be36b42776903a15a3e07c706d121e9fb825281910279715c43bac225d349335b3f4ee7fa38ab35f2c596dbca4168661bbfa89cb072f45d4006b1bcfa96fa670a9c2ae17f4cd6308e944c353151399d1f2ce94a95e8f21882e4e0ffdb1d9e0dfb077a862265f99f7ead787dd608d6cb1b791a29a8dec0723c3331471743c3419cd8b3952d9e930ff0a159f41c1df4351f8dbec8637afe7493a48c42a6ea6b5f5e15a855eea097835422eeec654a90a51e97595de42617fae13b63855ac2f2ba9350c38a11ca57f4c8720626a398059e096cd617048a2dfd7b99b7f9c210b709a6f80cd9958ffe97115356c56292e8dd32b27610f9cfa5b18ea76a945f48b1c462b28410dc48bcfd5fee2b18e0362d56cae75c306b8d436fdf7b0774d3aff444ce42b4ecd2f9c4797e2e128461b11c2c2d9b088ae970e33a7b78dedd0656e7d3c7dc07b77418d07aaaa2a846facda8f35916d03c03fc2978a53d40b24e30377fe01fe86512199aad8c74711747144a88f085a6fd0bfbae6ef94a1524824449379b7da5ebfce618efd57ed9bdacdfd4a2a21b185114a969fd1db3ff38bb6e617a720cdc7f9b74931d98e4f3a847d746486f92d40e2a68dbd56afb40b2910662c1b50be5a9606f58bce8e7d132bcadef3bf41a59e133142b659cacf015da06734d26ba81d43b287c9dfafd7e422ec4b2718a3c23b60d9dac9a9bbd94a6459a8ed6427e34c85ccdbcf22bd75d6376884210a285e0811b3de3cca548819d8d841a8ca8a8162ffa1d56d52eab36eb472cca2c71e1bafcfc21afde5b830d43ac9643107173cfe6ad2e4aea9e91a0122330c64acab55f17a559a1e521317fc6a4efc8a5dc1a6e9326593b3716763a8b6b3d2e9d818b2d1b7cc925a5733391dc9d57b4d1bee31c804dd349906959d1a982ba5402a5457556ee55993bb8f2ee82d7842943b8b556012048a8b7c50eea8a6d3627b524a0fcc50ce419b6b8f47a8bff5be6d7cecc129976a9935537a3b905cd9bace5d33578e000540915cbe5f3d34636f868d08ce76d31a84009ef98a81dc8f56a3033591c89627908dfc362dfcaa13d995fa73c54dcb41cdf1625b0d89e81353022e5f9f0ae3e6d71f5b15d66650e06921925bcf5072438ac7982f55199bb56af2ad328ca03b71fe00afd1a568d4c15edf85c1db14e8e5c1c3b2a76a68856487f5ea4e1dcac515d1549c868df0724e99d4e0e95fbdb7885c1a203151fbb0e3d98113f4a096148413c39f2795f250b5523acace24ef354adca61c8a4a79a49d87587ae71d2e4ba82b622f8715f9da198a4e670d3e2932b85d8cd4c9d5e652e17e087eef5f78659b9d0e5aaa04963b7e64f0ec1a8f06f82830d67a38ca9363b811b8e6b26ac6ebb76bbc09c43991b0dfed382e1ecfa72d62fe6dce0afcf00f4db851b543b5bd49363baa4bc89567978bc814747fbd1434502df92449e28508c5226d4293e8415979f004ba4b5bf1e4f435736c7cfea1919ea25289bdd78beac47946b205afb35cac1aea4b74c6e0a583b791a7f66c3654c3eece6b824d911443a5be1856ba1223dc1e6eb6460f38eb11cfab55c0582cf7ef3f5e07a452952a9ceae4ac8d71f2ed63cae263a817324f2c93ed8f412df8c13a82a7dfb0ede7345664efabc527e456d534814f6be092b516dc22b95918615ea37724f4cb107547cb87fb518d2e893ff24e18ae494897e5a99654c7798efc5b3368c169995fc7989a3eba1ca705ae312a87d24930cfbfaa11e08858deab94871c587d60ef0bf1142e1852bcba27d88c1b48aad9c1355f38c82896eb1bdf588c7d5a601e7dcca420a33ae38f53c63f7112016ee890171486236cb7b842c425ac714d642c9e9ad0908bb65bff053d418c1b2a41218ea7d73cacf6db9d0f38b7b256b6142cfa328a65985f8bb1d87fd17fdef8a196fd7700519374495b945e804cf6ac028133201f827fcac5a6f754713584487319958f57b0dc6ae97e0776beafa6a47fb118c5fe92276302b2c233b59c8544e60477530ff85e38c5204034413879124a7d7e9bb7a5c43f4c85f8aa243da7b377f7364487e7d7c3c66b62b3578092d3b6c3d50fa4b1a150411cbd0d8fa1b8ee41f005f13d637668922206bc6622b650d7dc25db188b74ded03bdd9b823810e031fc67b6348fdb26fc6457af35b735488f9bd0f4581ada8fdb7c79ef7fa288587cf3377f51f37b5b183861863cf5fb1973a20ad3a8ad103d030060b7fcc3f331827603b146ae883d77675d6437d95863d2feae48a24f699fe3813e03df9eba83d8edf0c020c91c601619204b352ccc2a960513b178d6d0596b444734c2167d01834731454828c7dffbb06b71d62cc0e114c92411b0cbf14921b55b7adaa208b35f560cd8d81373db96c33f2c79e36ed1c699d915e9f412e3c0f42362ba4b973723581aa86b5ab5b44d3153e7a28d2eec402412ae73b741d27277a91eb2f18bf22b1391483ec","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
