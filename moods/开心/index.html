<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"512f4d712ba916ed861606dd8811248b3d75e13e5b73803053975c4ad4f9f7ef7e3ce3c45b07754a17fd5ec1fae14edba6ac3949ba451eec0d63a5e7fb657fc26867bb53bb5cc436c3228b82f80ada674a0d18ffdb705da355426d70441d1085fc12dd740141b021edabf66b34bda6d393c69491aa664db5fddd912ef3f6c074d5cc7940d8a724face1e0c024c38cecb026b0a5f7787dca52b24c1e37b2e3757b67e9efacfbdb52f8d85006f4456ee37b8e3368fa1c77ed5e1c6014526a2dbeabe565203c3107e169cef4eec868f7dd1a1b67d8669a2c75d9d44e4d2035a6a499c890dce312af92292a25c67480bde34a614b3223f8a7cd6ff01d7b1be7a72b36a1c854773ed5453b918f56f9c86afe247c4ef4e20561e94876ed48ddc2e651ee830a6ee08068bc4ba14ea46f14a70496f381abf1871d1032590defb548a6cdd12cdbb6fb51a908dc8fc8d37247cabcb4596187747ab45a6fab40bde2dd7f54b60abedf373184c816d552f67cd41e13a82ac9b45cbe2d4aeba60ceddd5431d2e242dec96ae168eeb6e412b95923696478f19925769ac1dd858401a8f79d81ebcd9f4ef5445654ba9fc5cd4428a1f72222805b85e9b440f0f762d1e83a12220887a41503c7a367488498054073f0b5235a1d5bb0180f051bab12ce3088ec20c8e2cad2b4cd2d430bb51bc5276e98b234b010ef218688d596257f72945f3917d133f626b4bb2ef5503ee505434293341bd1022aa75acd51774675ef1aeabba7c8a92dd1db56e60b56f254e858f670d921a6d183c10efea247c9d63fa6aef7b003afbbcda8ffd2aa65824f2a9402a1e07429787b3c2d7bc4b5f04008b04e6872bf13ff8c3bcba0b5e9afb7a1e8cb3b87ca968c88f018e7cb86033dd63c9f0888e2021f08a9493ca95352c987418bc501ffd5da33c6ee150fbe90662d7eaefb310bc888637b78052bc2a73f56afb457491a34d30a4cf64249dafb2b864ad4f5308dfd71072244632d977e08fdb8433e377696c72fb1a74ad36fbc83ee565a940c9fefc0845a99f8526ec6c851e2de2088d0cce590f77504fab9fb792f93fba1fb48956a1baa8237b9c4f22cc8853a9357d5174962f5c7f88d900d4808c7d1315e7b3829ac4facf7e725fa860851191cf3da989ec582873dd68fbd4a977d6ceb65d42c3b178d44609ccb919e43c8e65a60a98718500ebfda5c8451a7d9875acb346347e71f20791f1817f61c1714b8e7b38c2f4930080b9050640d9e6775cd7d6f91214910f0f93f69f2acaa117af9a6d2adc199b07afee358359e2d89869a6eaa2dbb1feeadfe1fb6d95b0b8c9c29e863d1f2eb290940613ceed8731b760f0d3d39b8c3e486af7e4ce8b23d20739abc9e6ce3e2364acfa1b4fb3ab0a5e30f1559ad1170795ee5a63a50404faa7f82e04ca87f295abd4d721bcb0853fa1eec77a9a03878d8d49eae90595e5b2928b1304df5d92d0d9932b6649d3eef41351a03aff2e188cdbc5727e5bffb098dd40d72ca598a4b314bc943f0310b755d751bbe85d448019b2b9709280e16726301ec94c3dd3ef9cec789d17727e79efd1f784ab989411f04274f7b5d57e14f5a3dbd42b4e71b251ab3f98002142bed80e6bf73785475ce536008f91b9fa3cd43809dbec954f5458efccdb887681985c639ddf3f4f780c1d44d7292741ef79a305c9a90662906376d51a93ea44718f3c73dc900f015db351f8f6771e80778e096b6f229bfa8fe822897118f1399da4d36b774dd4cd86c993eb45f4398718e1fd84e81c51e54135f238906c64bd6c504b9f6fa55e274ddbed6862245373b014f28b62649e6126304eaccda5a92feac565d1659ec3ef03dec693386407bc4e2c5a0db3556fb3b8e7be020cab0ce9f47b848f00b29fd6dbe250822dfedd5cc555d03b43d9bf5305ec700de343164e7f3d745992ed544927537b162b917d005a32f8d637dcb9cb4d1bdb29f5f4b928214342e7eea9035078de65a07c55da95fff2a3a1e338b45b5765669eaf0764d9e06eb3ac0c47344ebccec15b2fe5b106941e28157abacee88388510c9a041865cf79056886c0ea9ea375af6a664c4391d0239c8700a0c5c3b4d3ff8cd4f8662b8ad3520b5e933acf2a29f8473fe566c63f379dcb01561994640d7fabdbe3515cdf7d3104bc0d5af74707a6ea303adb54f46db565e13d3a5381b6607d739d2429692adba773fd15251ef854e6eb0fe69ea6bba56b84d13a4638e966646ea6bb129eee51e2b57866d438c68e0bb34d30c3bb85c82b492027b2392542fe61445797c51d890e5cf72e251fa1780f9d3594647683830ffcda196e11fe2ef46cd586d5bf73a7d2eb1f6c15e283833bc7dd973b2b75b5549732db53e383c7467932a116cee4737e57c9b9e790531d3c0387750b71c8ca7755c08b8ed825aba01f41e8245550e8127b64e6edb7c90693ad3d178a4a1139371ffeb65488325668656f0793b6071c0c5807beb28e42763447630b5837dfdde7f78bd9fd5c5f854ab7f98dc538970291460d027a0fe7d78d1d34cf30b80248918ffdd1a255f9df8ea71eaca1c7dd16fb9629376f0b15b3c8cb734de01f0e2a2f9d4049856e757c8cc19c0fd87d50840bf86f9e4d522aac0fa746e6a742fd52431f99e00527386a5b80376af084e8b951d8e7da30b91835f8571c6e209fcc2b5874d641c683a36981c75252481796b92bcf523ee2978f32fdd7a4dcd68ba6f9865896562223fae6cf917a1b87d85647562f89a2426dd7f1f5953714919fdba5d5595ebe005b7875f9aa3a1fac8731013b134d70d414dde5c0b8b7d75aeef4d30607d6c01612d1896ef9080a9391670920e2224e21fe4aabadbaf7e8a783549ed44aff58835c29aa5ef2f585883c1a58bc84278a53b4fc803b3665ffde737a13a93dc6e26272eabe86d5bfc44a7557b3d23b81924748b316a2f819f1026ffe2305f02549dedd1e29f87c7f0660636630002227664aeeb8c64ef0cc12e6d27ac8c4e85e7f55a8ce7b085a758e594e2f66b307f5d73abc32029829dc548e53251206f419e9aa75288ea266a86b17317e8823287e88fb3d6b4442bb2bfc4ba32b9c25f62821fff1598e35b4d5adefc1ee0adf1b346290b1b197941aab648dfc5e77427154e116b6fadb90c4694867d0845736390c9511ce042e694c26357a98a0de4de29353d0fa8d0e1cec1ab40c95189209f663a5b0828b2b202df609b01ddb1aa9b0b75c42ec33ed065e52ded3a1feae5ef4eb2adb4bbf1dd3c0505ebc0683f9891d038653797e4660347ddfb08ae3da1c7e81f545147e606bf37afe539ed4ee3a9c06b3c69cbbbe3288992bb48862349a193e3d8f6a804685d6884659cec2e97648cee2a278fa46a341309e0c57685889f2560df862af38abbca0517ffdbf20bcea790b683732ec9574d8ecb7c617c604ac14faf646b1e815e9ce66745c0810306d0281e49a0f138fd645b3c81596fd8d182bbc802122c8932c056a91d1bd4dbbac861e34d33f93732779c82d88be835d10afcb2103e192a3183030f727e6c44eed069423ba68b698e1c79115648df37e5dc9a65374e97004135bc97b705af5ca617a1d605b46160921735fd55cc0d9cb18271a2c4e62adf2a7173bcaf96d849e698eacad083b3b56c55801beb41d93f8a5b2ee52fdbc5137bc86bccc7e0190e50a189a57ab61dfc821e8d1a0f70fd764f1c7cfab30c033f1cb74672e03ca56a80a6620c958d9cf0dfd536adfc537663fc43b9be69aace89ef35c5efb6aa2d5fd0d92b7059a6a03e20680ac43e12f8b3cee5e117a5f7212453c0727720190cd4db48a4d7a96584d073feb5a1ef9ef9ccb1d2e9af7dd707189405bf184eac92abbb0a25abf9f2a9c60ca9c34216bf646c2a5b659be72a7be52e8ee6c7c89e73a910cbfa3ba796e7e927dc0abc43aaa3d8b40aa5384e545d38a6745dd3068d929201d5c9bb9372fbb47545ab4e5c0464272e7caa3cea42d4543cf2af0e4b0d4aebb94e6cab9df062ca5edd02e5e78b06a65919174689d84b5a0b4c8ab8b322e0d6ef43a663b65da0f09b28349e280f0297fd10d23109ee0001d3ffee80b68c8cbe3d2e85281d591c7b623fe48784e858bb3ff47fc1cf5c117d7c0b8a9680888584c442d509691f7da6f85770e1ef49e8e9bb75457e0d71d435065922b12c522707dda3b1d9c2efd0a63d7200d03d527149b580bfb299eb065c3ed4b2a0e0ee5b84859ff4185524f2e283cca18d72a6b88f39a4539eb9cccff754d9c92b97a227861990d2ec5c60a4f4c35edf2198a941fa392c02747200b305f4fcdd26d4c427c41489a7e2a441e47e5b1b7d3607d56f8bd324a79d0e4561a3ab50be97952c0aaf541d36bea58e90773ad68a151f069644f1f7cb50e4c2e119bab3cf945fe6ec016d27fc4c200bbd2b446db2694bef8ef547785ea1fcad466c1ab130d84b9c4cd2f38c1c54277d1cc2951c1777a3dd3d488fb160b0b0c4866e0cca0bfc417cf0a3fa9dcd3a412f4ccb57c51ec7e8445a741d4d5eff5e40c3487090fc4463bbf3266e68c6154008c90a352edcba54811224db725b909ab657ad91c269ab992ca13e04c7f34c9efdc524dc4e156c0d26637d0ac3d9b46b37ccfb17e845b2549bb9a2274dcf66ce99fa4b61722bf3922e28b4973e3badffd7c4ea7aeae422722c26ab3746d243128e8c45127703bb8674b497c435ee04e0d1c2a6f290add1ac4355a09097f5c9862901fc19922f312c97bbe937f88f1b29f5b1a9321fcdf5a05c42d6351280e2ccfdc7bc50e0c1bf87b70f266d6f5bc36aa79d7a89463ed9ab2703411973b82d0f2d1c1a1cb59232222c5dbedebbde93583b049ca0ceb26fe35df5f0db232fb279e0314fcd51e399c615cb616ec607e52c8340135327d22964838bcce7988de717bb2e0d512b32459458c395eb61d731c49827ff7276a65ae9d5e30aba7e35b71f6b698b16b87bab662a3e0e56c216d5f15799c502b1a46c6794467403a00e1449cb1e7d9381e10668a88ca621dc44f887298cdd6c18811f753345e843929b350b5ce6c5e5d05a8d78690634222b39d85271dd0afafdef31e56a821a6d6bdaf773a9f12f5b8bbda7375ff6c55fe880c4de76ae597b123563f78f186515903a35cf44e808f3ed7e12f8cd4e39ba5a3272ad1de30503b024b3638295184b2419e8618bc5c5cbfbd6e8841693df0fbacd7b920d008ce514fa8efc5557d394c13d9854aae7b8b3571ddecaabd29b2e9bb527f6d777ac0a12a2a344b0ddcd0c678f576fa11b8253b6fd36f3c39927b9e61c00397614a123a4d4f124c95b539e6cf25168df5730ffce8766faed3b6c5f712229de1c8a02297bb93eeb3ca64b45ac3e09115a81c413921f4c8c78e41bb852d202cbbd6c5cebc9cbbb0f706572859c25aecc1fc6c8e2a5738e2fa49094f263ad35033858f7eb1db309e5544c4f5ddc793e7b70c4eb2d565b0c89f6ec44a391ce0f4d07bde4240440d15d88f527571bc3e16885838695cb24b24a0d7b740194b7710a4b48cfe182a0d53e4b5405de25773fe03aa42dbfa8156c419cc508b4fa0497e8f57349b572015e96014dc7734e4c6396c50a4ea35b54ec13347a2c61faca61ce9f42f9331ddb449407b7f422694e0c1ffa17c32cc2cbf5101a63f409fac04c11cd531b57c90cafe036f1cba33acb445700260034bd60871821f8843c25f17055b5649a0056fc3bf361dfdb74c0f6e5326672f70ef1faa77490c9931298225063abc3da3b5a77d1447fc0cb70f2369ebaf127daba5f24a259bba18cb57041547400542116cbb7489fcbfb0bae8e5b78f34696471b410a2fbbbde11b109153ec9b64440d4e13162003f745d71ea1e3f38d01ca943affc791861037dc65cead22f1eea41ae0cfbe001863f52ea76cdb7c2858a30fb7f3f1c172397857a66932662588c919c27782952eee170f9381f79952c2d2c4b1f5022a42fd50aaafdd8e99fa8e98c1723e37aadffbd9418cd46c303b5ea10e7d0bd3a10a7616902ac9c967c19d079fc1dfec8807219e10f37f99c997f45343dc1594872a3809f2d91cc37a3986bc582b862242dbc9eb828e0928a21f83274427cfef718d710c26d64c4ed7f65f77626cddef1d342b8ba3c600899a14b229cfaa0b0e73bdf864dddcd8102bf42cc7c0f17fe6f2c579161b6fc85f6e98a7816f2bfbb0254935641152749a775466257a203dac885d04fea0d0940af100cb3b9200e0212dd6f6d121002239dfe0f73ce5f0726ac7f4292b485490f00d595ad4ce6403dc39da0d5fa4e4789139aceaad1324e5f62dc6be3aa7ef44508577900e357358d3462cda95f993c15c90909983f363b54ff713b1ae553f154a1ed9745334827bed8feb7d8c01a3c48081d53c181be018c153c0359fa46035be6726fd518bc2435b68e34dc57a6bee2f2fd45e53214bc91f7d5d5ee77ec82e1467e1d6402e693791af95c47dcbf003ca455a1a5f2425936dc8b71583729efe56cb3bae00da1041b813de6db5b181a70ff870029222c3389a081b5c2e6c344702849fc2985407db0dfb33bfec420ddca86364c5b40a82c3be643d96f8e557752e0579aa98bf63a5a3977b74b7d8b09d48892b4cc0fea9c5896a0b838a4206b5dc39fceb8217eac9e22175cd290ddee6281575af4aa78bd647b14d796bc99b3b55b5de8bb174504848e06d734fc3d10d96846ec6078c987e484adc399b03a93f373970884c98797310c427b639d11fd90168a33f8d43ef1de0b44318fb70f39ddd39040a42a723a8ee8077e61a7994201dbc027a0fc818a53319210eeecec07ac11bc18d95c73db3d36054c536cef7ebc628a1204bf2c923e96f7a519c6aadb5eb47ec2c6e376ef74f21950a6b47fcfd9178f4f5fb02edda1067d0ed1da7d4c76dc976a5a4503c9d3298546431ca8c202a3487faeacfad94159a447eeba641f4a3ca099826d71318fe2e0520410281b6f366848e87a4fbfb48b2d7a084550ede6d093f39a934999f30d72a22b9d58dc868fa5b9f076d5599b7b18b88bad88da88ce7b69cb8d32d77c7ac42702a5327073980bbd1c34ae2fb3c6148a2ce2004c7660399fdf73d57867250d2f790157baada9c4e861cfc76647e75db3887b13b7fc26b44d48dc6bdd2037a0a9c14952996849b93fe366d35a8b793c4a486575ba1d50898934d5fa6f850f23039ba5c1bef0d1c6738ff3f3fb23608d16a05abcf88bf3438204a733fae3688b6b9b95a0a0de52359cb93d5d17b7aebb5b1cdfb6b46f2bdcd4b91f364f7d7fa3a217604c3b35671647822928ea1b6feb376656b71d5ff24b1ab2189a20de2490b9b17b538f0759b8be339de2cd29f361ce92df8dc2d32444b66e5165a2c8a651474787acd5a0b91c231ce687512ff5b52ec3ea5acec17e3ee7a130109b2275855819dad0ed851e5d04a4d58278fce3e33c95e29fe56fd355a5a0a61c00c1e41b77e74d546a0a9cf62c1afff59a696cc438277744d79c5b3fdc7e57ff9a8f98844ba7edc1c3a1a8799d4e7cebfa8abe7357cfedd44ddb6a093beca9937b9fee2aea72bbcca4b1b65c4a80f8b0ef36955e894fad0dace39a2eeb86167682b9e94c120f383ae369f67b95f5369e9b085f6bdfc8bdf8ad88f6f6c873ad338234eb96a446b63ede8b8df9dbf55751551763f17851dcbe840b2280e1de6e8d48da754e76a280a1f69f386e4ecf41a62bcad2e58bf094926bcdd66946948c005a7c9250eef7f771ae2d698913cf6d81ab871a3d0ef5ea8c707acbe13c462d760942f23d23b039013a3a60d339e28e55ca5d99d1790ec30fbfee99bc8a0966f7bda972bd9f96aaabdc03285d290bf21d9078950fd04e5a2cd995be2507d40824963348d3f8144d5a2614468b48a647852829d1a602fa6d689dc43a2217f7415c86db8aaace9c7e43392c08d7cda482c5f5a1f8fcb8521ebadd82b88369818c9b5c2b3fa94c97311057381d05dc650275f372a9721f571b4faefe8c6779564897efb3e11bb67be9ea9d62f484ba087af8cbc2ba24b59e4168a2e7adbcab3bff982c69b532e63a8b8b5612e83e59b9c06471b0500c5e0aab2f0243ca92aced011b0ff2d57c9b7b91b921694e7d19c150a5ce0bef8622a0beed7e158dbaea03ab18b304192b51157dae133c5cb8e6772d2be62262ab78b2d1b39fc81bfcbf2f4ea8aa286633b5657c893f7890b320dfc62381f8a7a1410bdb13d1226cf63897d21a1717ddb2f58e6b7c380b7bc6d0d421dd75fde0202e9a803f9a6de191e33865fad2f6c950df4cc0c704018db74e5ccff49390bf46d7ff360b4cfac7a97be0e0fd9085f2516ed1c8c313faec9f48ec54a7a6587fca76bb23f3fcbaa25cfa53bd1f115c689bd71cc21919ffef31ae2ee1440eefec43bddfb296021e3146fe9574f9b827fc4dffe53882f2237af155ced3351c0ea87153dd2f07ad9d9801ee3b004bb5f47fe633470042f17d72daa67e2d93a0620fced7fefafe5fb27bb12db2a060cb42e68a7f72bb3b083de48730233e674a51d0c4639503c7105cb06448f136fcac632d13ec996d82a233a439baf85a8659a4ffda01f9446005800df2d0945973d54c662c7b92856de14ee80f93df34842ce47861f93bc859a225f68ed8e0e480677000472e26f10defff0f268503608db6359a2c52c12b0e40a90b9c8cfbe573af58bf7e55f021b8cbeb923894f352117af8759ce4709e21121fa10897cf2306851bc12521db482d90086a9c048b595601150a13cac085da6e9a25bd133a747f1c6f051d44f5e8d1e228a220dd3b4a627ef684b589931fd63cbc34c0deba9ee95d6e4ebdfb739256a63ca586e3e46317a983adbeaba95986301b522f11ca49cc2e0f3a3233fde49be414cd3d4f7f08545e3470378f0724ce174e5a1f4e8ebc69faa36b32d4dde2be8c71f16d3c3384f0bda8c5f2ad7d1b913d13f2fc4e75bb035ce7b962fbbdc07743a2d17f79458fb953d853372e23613b3677083e9a2a885b554e68d9842dcde518ba1e8105409bda0ccd7c694679c4fcc186fee07bfab3139904435dc53cfff3048a40ed139476edd9a8dec7d2bb6354eccec4f2ae0a10df98ce9d64d7c8af98d81f9b592c4622a1dece5fe8652fdbea3101e7267c0e3b9c749fff24abc59c7945617db39d057151a29b3695d35afcb8986e4d34773d6a732fe88810cc220a5802666a0f6e1c410a2b4d6e0982ddbb191d3bca98f90262a27485ba61f6d96ab124718c5438e5c4b070a45d34190fbbc5f78971125ef6601e45e5840568f68d578616dec8f7a751b58058ce86b8eb8656ef1447201bae862b0999a858d1be759dadfb8d680cfe0eb5bcb7f13af288e52ffcf61dab0b9cf79e9687ce74f5ef62af72194a131b397c6a8f5a894c7c6c51c140c195c374e8fec4a4b4834543af35682f85775a9b3dbaca4291aa2bf85602891971d81044e2080ed83c4b0f56ee20885cd6308e6b323081473bf589971ee5613658207b143e93982d0dd0715f112dea2e10d11048bcb9e10a4ad2e2dde4d67beee3a00b12b7e183fa5fd3af60c6193514af49c2eef303cba89eac687a3323fe72bf325a959ea6236693a03f5ae95d5df4c5baea71372fea00841c5d3608dd0d11cb7b03d488b7f1a3975032bab35a0f394259fe77ae218efc8b2c34c5a08e8c00d9fb7735feadc954093b727acbb3de6a8d19d434f103edcc92ca6393cc6627dcf0b7425db8830bf5f2fe11d141d39a78bf42b57dd547960b0ef2ea4624c4581ee69ec5bf1d00f380c1b2faa4177618c34c7dc795f172c600e9aadaa9347b870d78183a834c77e631d4a513abbbcb10ae3fa63175c49d6451c327b92b247b9c185c9a3941243169f733ba6d2fb129369a96c436ab8db043bcaf443dc684707130d0faa1aadf2b125e89ef8fb7c0f890f140b3306c6c757c393ed6eaae6ee75161e631cc9de4ee3468c83a21968af4f3ad55ab9df890296a519e29a2040b8ceddb4fd8c299cb7bf7a632686b5a0faf0c1ccfd730db5c92b0a813aa7a4a6a7521275202efde57435357fe94700f4ed5e95fd0e9f47885aa258e07a98bacc66fa02d4ec207df943cb19dc5186c12eb4c058509071e50b2c1d707ca6d2386234842130a79849dccaba80b9c152fca3c723f8e7ed94344079cbc87a38a8813fdf49388ad56c77da88ee065c4742715633838274234a9ac8191b1881943982526917d0845af3ac990014f9ce2edda63928ac73c084cf624ce8980fd6064147fcedd690c821d31d31d4d432669c45d5f444ae297148a1d143230a0bf1ad4bd17b0ef0f94c4f2c614454d69e9dc58f61cef1ecbd6f6db058f42fd72838d39ea057f89024c200867a605f24ba91d46572979a8b26e2258f4c75b6930742cd7228d4861d3ad1baf784cc47e64eb3c7b549ceebdda334f3ecda70957a9009f4c42826d112c4de2cfe8571ecb8b8a90129e65a0300edb774c6079201c6d7407b5a652fd355e8068d5227bf74513221c8fc65da3858009af9d39d41014d826e46057ccd9ca49cde99a261bfb25ee67d97fc1795210e2d404363666ed796e12376cb6c162831b5df9ee13182451392aa91fa9f0b0816e9a5e46952d5df6baed7774ee8a4fa0dfdc7ba3256b5931b8cfc8d7a45eb7cda0473d87205361825c37cd75e2023973e9323574b35f0f959a93f3effa6df2eda9fb79cc5826a808be1cfb2e6937785032ee571afe7f8d5bb3e5184f32d848bc2af698329e73b341ee2a1ed375cfe73ee687c22e732a82dc564194d24b97c1ce0844cf5a072aaec328d261e20b91a7a2bc1768f9204e48731e51a4e54b2771f4b6ae5eca637e71113c4d7acfee8909a914a0de01cc969600300c9739e78cf65a456b44f7bc6550bdba4a50484bbb96a37eb4838f2742bce86a3aea40e190ef8aca4dc6378a296f98da705b2667d9dd05a4a2b6a08555d2af3df844a41180951fdbbf2b9b931537909b2e4057b5f14822688171a19378118aa9eab3c28252ec14faac390af03091428a67db60b14fbda9071b89302cf4fbccffdfc3c752156bea9c2720ca050a2fa3fabee9dc68fe56ce391459c314d36d8e23a24932abb519cc27582e5e1d9167f03d69cf9ab0e144f446ce5c53b37f1af659bb66a0a6c9aa8c27ca32d848166b17e21c57494616f9f2c3f38864c64e34daa9bf6583e7d15464b9b6391fe3984660f0c00c15ed5fdfa09f2edbe401cc4160e5a65fc9fba0dbcb3c9d25948db96018e2751d1becd264b34e4f41f9078a6d31d97d13073e6169b7fff7c7823c1e5414f89ae58ad1ca28fd4f987540445cfe3d0f9e7a3f6285c37b254929d45ae308331034d2cb56fd0f66eb65fe9eeef7ae28d91298bc17b402ab4a3a32ea7ee573e1decb0d13842af8a79ab9a86b99de697751d9a7986b7a4cae89d7a7c298c479b58b4da1e495bd80a0fdcb8d81ba11668da6967a5ef6b0898e8bdd30fd14b73c65175a1a66bc2e451369c6e4dc5effb6499693a62901efc9f0c3c525defcfe4c09e7da4a82316e917970b725a47e7866c5373d221ec9062cd9ed61b2445783b611237cd7063ec8d20e1032731341aa1f3bbf3b4aff0951963eec5a0e0c7c906e6f172b3adb0229b0c134b53c0d2c2acedf72f1b4cd3105074f6fcadac390423f54910f5d8c828b1b37c1fc3d26b0378b13dab8d6ab42692cb446f793e5872555ff8cf0f443d6fa0b734e57d1ab2e30918be7daca04b12c9d9e1df60b48abaefe5b75b0d189c2a0600e0fcb1b2484d3b8d92b8c84a96861403f08ebbe519ff4682275ede6a9a3bbebd889aade7b0ace6cbba5b506cd1219552eba934698eb06f2ed3f4c3d8cba63123ce91df057a0a90717d96a2f20af8f3916039139d8bf71dd782d4ecf3b5e123ed6bd07bc49add3f9b525c665eb34cce4b3aa8b045343ef3e80dcc0ea8123a6c7229dc3dd7133b997b6973eaed806f1aa4ac4b09cd75e6d1c6fdc2b8331b8e4a2648f521dfce269157751e1ae0b198899c2436984469d9b5b70b5007e4fddb5b74da7a3bf62965eb30052b424f79515f59af3777a432922dbea93afac8ce797abd22035fb708e13011e60eb68ff6733e0b1a4ef01f217e33f26b1f70ab079fc116aeffcdc610c1093442eb8f412461735966162f923042de9e0d8cdd2f6e579c3fa2e74c77b61095acf37cc673bee0ea6f82dd99480fd570567509e83bec2d55ebecdb1b924cd9be0bd9c8b2e38ec4e070060f71d27866b75ba6860cdd709307b3429d8cf64fdb9192cbe85c516bc73b3fabe3c93261225b24f056611d71579f3c9f13800c3926cc51951e19c5c68b20a3a56a4a460f46fdabfe998a124b8134511bb72fd1e18d111b98ea41cc3528bc54c7f9b852edbd7a455e4f316d2111b738f83fef762a25e63bd3a91bcd8a504aa142e37084cf40d9380f4d755c997fa75d52bcc01f22042731e9c358e54c7902006edb5840a35f7b11c887c143a52e5928c01950e122ecea196422c3ff96a53b826da8f2fd8b65de913a548b0d60d1a7eec43638643fe0232a98c6878546d40f1aa2d10c9059d166bd107a5e0ceb6d1fceeaf16bf32d20d8f310e5775ae166ab60a64d0764971fb3ff8dff867dc3623e680b8aaf64ddbd9aae8873ee2660ae972a0a5e423956f83589c25d262d2e93a118b93334c6fd49e76e8ec39812e2eb1d625a0ab957602a4a54439f70d0026a542d8f84a7e9acb32f373b18fe300b84069c356f18b5e4bdd9bcebe8c3ab425ca9e4128119fd4a572e0fe88dd94be091c5adf57b7260a8eaf9816cbb366651c792f0457244bdd1ac8e14bed427974541e01a4187963e10ce605609f1b058d914e2130650d5cf6362c8fbc0fb9f11c9add8182cad304c8a958f516151744ef759714f8a80a1d15da22091c6450c2f2fa38536212a5b22a31198a67b2ecb2201ee79703d97ad19d4c9749b7d20d6951abe7a2d83df7e7b6dc90a1e894ce469d3fd460222faf46cf5ebd496b4dba81d8d83cd8eb6c5abd667b0ec46f4a51f105ee6eba4f537d8210bf1a47c38b2e0779d8e84fa0cf9b2ad1ff7f6e5cbfefc94760b3590e254bae0a6247c919e31f53b342e7a69263363acfd4cbcb04f26153df03532ddc36ea9b65f210194a2320a576db16678c077ef0af9768b31d3a85fcd706445bcc01526c3dd56d21e7c231da27f60dfd61209a354580b2896568e45f2e5c7519187bf3daaa37ed203235af018817a560f29efb0675aa3cc22f1d72acc66f43a877730c76bba28573788c64ec590d24fdc2d8fda3aa05b54fde3c2994ef31431893933c8ad6a1ae78726c45ad4bdff7ab23b261d2638b771e46407323dcf7bc5547f9883315e0e174d4a78cecf95c354cf414e133f0190d701ebc3af5ba2e9bdc359a8a477bd27e3b10a6d0b160b80882fdcc6520ebbd489abe3dfb344eea2a465aa6e5e321b895eed456dac325bc57e4b03f687681e7e27bc9b21cc3b6ec104b9a602ad286d13b1b83a8e7a0ff0dd4e5b2469dffa0f22b46df472b845788a8975c9d69f587f133c288224c2a155ab69aacdc0945a475f59af34e8a720e6cde571c7182e75914f2b96be0545d61a078e23a8f079e9c7761210a28b11eea7ddd534de5a3c0953e8ffd747d0700a46504e2cf814f900f14980ce1f7319056dbc645daac279c13949f543197f9a116a78cd91e08dfe35ca552da0ee42087f67567cd6ee78af7bbc411be9b92a8f7a330dc5fc601dd963dcfee7930d5e0b00089c707a3f4d223e98ea5292d09e675dba7f12789ad160d4c6727dc86c6591d5dd2100c1be666f94ef57f482a05bfd629ce998bfdea7d9c4156a78e4f00932cfbc344ae1dba7f0e8e179c87d405968293e4e955af488bfe53c072ee9ec5410c585048152ba1c44949392a32a216cd29b1eed8e0902454ff591857d8ea6f48d4f0145307973a09c38ea06d993fba97a8ed6847c55a563d95e7ab17e0552726f376d98c2fd73ee6dd21bd30f758355c565ebe08e42cfb2fe7ae72d10387f14990560c186241a1a27d10520a9736a50c85bb9314de83abcf4dc3e358a4c671f1483578fc94a47ac1307274718cfa2a88b74446d551ae013763514de2b2e287b689e42a9be28c06304d69ef7dfb0a01899f1ddcf46f53a5a4985a9bc7297af84214208f3134675ac236035975b25f0ba7b9c68f9aac0f259b23a4c8b27a2ca1b8980655fb33c2b639c4aa042193ab927a58a2156687aeb03866f8fd58314c345204e227aef222fb25f18e2bce8ebe1a5cce625f532df831b710d8bbd128ed7bdf8eb4b9215021f8f50dcd82a8f7c13b247f571639340bd701e410134a3f1aad0ff95358d7af9e4c591f5d37bdf4d80a254814d890d7c7c30aa9f3163d9ccf1555e871a79bbc687e8c61625a4b07da1df947049e0e62c2bd647c8f4bc7f81ae4d4392e784f6d0837653a386dcacbd3324be857ebbc6930c306e0f5fd7cf5c0d7b1b384f56b9920232d4ff96776a382b5b7d93d4d2e8976e8ea6bfeab3662d2a6039de58ff0d9f83cca59e489ea35a58a8b57b8f2db9986a6d2ee069e946dc654c284b62dc9fd3c95291a5f2b459b06c1640a29f2d98101e63ca655710012d94149fd0454587555b8cebca9964566077bf3fcabbb0bd732c5a1f2f71bd867e7d4cff5cabc69482c98aae14a68217d49437184d3f08f5d364bcae9c8eb5ac3021accd2b8563ef82e3500f033d7e191d130ee3b57dd21eedc07d1b2a48d06ea9fd808729dd0525e322d93a9da2bbf6943efff3a4376833a12787e80ce3a1967a0b8e7481a82feb2da0a804c53f35d31c46386cf4a1113f4473ea4ee9f517a57eb7a790f1a16ada3981f9735574c6ea6b0c610525bd69437fa1bd1671bc67d800d9cb1dfdec92b6d32089f04c59a0dc8a7d9f105446475813b6c5b86372156d4feff28db7104be3375619a717f4bf9cb30613a285875c0b1433e7b9bb1b97909a4181d6e65345db378450f10b102b248767472cb853cede0f45bdeadb027513bb4e2cd5f6233eac5b29b6a2c3899e4eaa60624350ee4db9c1efe21ad29290e7036017dbb98262e56afd24f53c5783d8af3cd07b3450180e5e713e433f5ad42e815a55a5e9637668c69bc126470d9c2a960006cbb2281cea77f6055451efc68d4db80d897e18af2fa457664b7b62a021269687ecde49c9bfb5dbdb97fc6535c46b51c60162f958e4fd80ca79bb48c09712e4d23e25d32ca37385663c5ade28cf23b10d22f897cd2077e351568e1d0dff6a7977bf91c245280a701f833c56f0872b17063a0f42daea5210dc94da753b3e58055e2d017748187f3ed15a3b9d82c542f0e31f4b8af51884e680f116b1d4ccbbdfae26a3729d266d6e934a1381c7dbe43032a703c004e700bc24ac7e0bedefd88434ce748cab186f2df5c07e0be931a17888cddc9ff0ef492fe32df041ee0d6186465b85369b2b5b462fba2a655e6a9ad6d22fb6bacf821ca22a83129cfa0d585553f826003b71acae0aacb20136408da491c04a238dfedfc86e8d59bb6482dc49bb975cfbf581fcc17744baa90caf862e77d745badca5cde6d23e31db05a210917e9a1609212c35ce0553a36e20991422ebaecba2c42ce146bd47920b081ca1fdf0782761eede102d589cf8709b7f3193e4f66556d6d2157a0ee19146dacfe8b72d123d6b96484d7b5cc65f7972fdcbf90513b20de5e4715b2efa5c35ff8dd3cc41cba88c8bccd79c0808e1cca8db96ef949578b97c42d0c89c1e57b409c98c241644dc84d69a6d71cbac735fde5a601aa48e617719e52ade1eb4c4b0dd1821247139c1f514b8e6671f203fb47f12eb39f2b386905698aed7ba3a7226a857727315679c52238d64d5af37fd5347e9bc6b6a76fb80016347561285344aff895c9c1d129e910b50720d9cd6b4b14db3f5107da39b4e0c2d146742e8af97c7e68338c421572ef27157a2280da4f1192c1c167b6b5454ac39cb6961ad8f995e44f9f7a5f65997ed6bcf3be15becdd26be8d1fe939fa7b81e0f085fdd82318ec007461e71e11409b5b7c23ff5e35c607d9cc0b65f04d7fde371b16fed086fe8d89d6e2332f52403f7eb85d61d8c12d44d07efcc0145296b5ccf10ccf7db65a322","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
