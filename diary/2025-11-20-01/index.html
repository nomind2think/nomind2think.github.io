<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09a820998b3f4787b082b5eb0c00b635e05136113fb8314d324317f5d255833a68c49f45af4c699c69efc5eb1398826119f10974789520d51ef82ca2b4eeb6374822685b7c8dfb7eaa7ff73c4a04dbfb4b3539e1cc44154c665fe8b4b90fe2f57bba4176bbd0b6a099c7412d8329c2152a1b738a8d781640778f2109ded8d5c5420dc9b38588dd3672cb65d7938db502005f8932128066e1ce481ffbb9f04adcd16a706c856f954bf00a8e47bccab5818d2b97c660d28a85bb3400b9036d01b4cb2a5a3c17c175ba6fb1760aef7030f88677bf5666b29283b5052850018da384e8303a741cc9ccb79f193cc772e7ba90eef16ef4fe0b0601a7f28d268d29df8fcf9cdd0eafaf5c94aeccf4ea9342c4869c5d461c294d9b4381dbfd8f62491e080a295f5d6363e3c44ff80f5e9b4d50de613a55e3df2668819a3018537c5f6ec0f3615984f3f4a1b3df6c1d5d15ff325e944826575cd210ab1e8a523e69f7a9d9a2709ce3d9cf26f32ad9c0332e5f94f78dd8a4f899f026d475cb019ac92e6e324a7503c54ce708c0ac3ab8a388a8010bb6f9f18acc475af0728c91767a2b60bf58974755a9a5c5a005d4b4985f7c22e6ed9f8f35fcaf7f726a0593f21b3e6d16d6b3313b4986c56da8735ea8f430a1b619f6ed5d8606ab6537aa269218f5b735a59b7e1f474a906341ab2719bc274f09abf267326703f9c09371e0409e75d197b1c9ea272895ecd6aaba786417155cb7bc4626b38006a305babc5de2c1188254ea2ca863e5a5c2bd847ea50a2dfe74226e1030063824bcab868bea9194866d924ff79db1a9b20218fc890a40ffdd7e8708e3e0e8f596ff9a2a5abc23ff5dfe6b75e3060ac6aa85c84b54b7e83b57c141ec9e9c48878b9192f65d6909f547eaa03a04cf06e947fcbc42e0063d8ccd762750999329dc7cf299ac5290ecb9c3e8e294b2a5f62668a102b38dd4070670b15a8237186cdf2ab506cced8c90c6aad43876f53516bc455b3ec64ba580d4b17e0cf647e6108adf06da9b0930966d15915c22c2f28c74f92be23a74283084a76a8a64f0219500c90d371f2c8a8801d566855ec5da1349ab25d08a7527884b2f2f8a710a9bdfd57d454b7377901f5cb6aace2607a15e011643878c4c1d138819ab28ee14f671c9a97e4daec3551489a5ea4f3a46a668d44d6019099d2781915458b461a4fe2466c8d92b529a4ab922eae683356e97f6b5e5feceb7aa204eb8ca366f5d4c005f5edb08112458c2842924325bea4a45785d21462c465ecade9cf7da770592b81879988c17b4df9401098f8a5a4640d0082dcb19c04378801ea5cd227a93adb50f8bbcc383f028317fe8f547103be78ed8f6d90010f56ca27abaabb39430877518cba67df2ea0904699d91d4b358cb21d717e31b1b2a5077826755b7fa3dd07b21fa250ef6ab9f11ec37408a981fb53b5a23386fa3fae766c66004337d38dbfe6897153c97ec3415e9b6296d459a36ac9b86a971f07530cfd386cc58ca1130f4256c5bc313f4feb4505e71cba617df5c07a693fdd0594135d175c9e3c7aada9a841456c40fa446afa09c01eaf4ade8e71bd6566b8d741d737d0dc5be1b1c00419e5f3bd444bc96540dbdfe27849504f10efba7d9b8464cab0856e820972f9c98ee146eb92d89676f3467aa4ab715086b0f0085eda4bba0cd43743733dbb21a69c447d864fa7099745e10b6264130c603e29093c82ac7234572a39936ee283e844bb61d8f4990c93a6be9ee1f6b94251f0b2d90ca84c285924e21e0f116a56aa0eb9a62396eb631cb1fab9c4ec24ab30fd2f5e2afeea898a17f84e693f667e2cdb94c70ac9bc739b93be15c0689822893916d6fee8e60978472872ad0ae33fb3e0249da35e1986b2df53d6c9b93cdfc559fe46de737a2f8aa91c01c24de21fe7a4e4cad1b8c13b3ede0562168e96fd3e636fef1e94f4d07ab580f825f6d4d531d811ca12aeb7484488f8203188151456f4ed446c3ffbda1cf425571a339b0341485d450baf101e42fd68cca95555502ea2b96dad5f35460ceff066b5ecbd8fcb97d617ce02369d16d396c56f00453bbe4753c4775fc06709fc8284e34352d60500f79bd426354e2101ac2f410e1db60a79e775fb7afead15f42d759207152ab7ee14620b68896e49b7cd88eb1cd082a2cae611f8daa8321c9e0f08aa8d71af9e85145e6fc01712eb001b5857030ed61ffe83a9b8332965d9eb0816fa002964286c10730bf560890f73917ed411cba8eb058a8d1326bcfc51ecf544f629da4c4b23c2e14ed3c022ac21d4425d6bd085c2cc4a639d767e636b5a5cc086eac032ebbd49dc2b865acacd5fbea626eccf78dca2940240ba6d2bdea194886f35e4161c9d7829023e3c2c1d100f4b66c009f7be6f63ebbc99bc9f92a452900c7b5a8092298eb8fa1ff0f2a2544514fbc64362a9492bc585e259b627126cbefa86309ee985b003955450571d389123d643367ee9e4f918c383f1f2d79c1e9d4ef8ccdb78b2edb717e6940550750aebb657735ae535ea00dd17dbcca5e968535083ce148be8705373f5e193beffca1a4f30b8d245488b2d498ed5ede224e5afc0ee98b01123d8f323915a20ea6a48f01e7ef164d038656a0a811987b382996fdcdedec2f8fd4a0dcd7f2499025ae6a573ccb04acde3ef428402db1637a6aebd630cf1a82cadc4e4a5f22106ff6c60dc210561d9d8160f7cb567981cc9dcd875e7cf6b7cd5647005d552c3a4a20e2d884ad3294be25515c97df2d4f731d8ecb14ce77349ea8faceecd871074a40b373b2dec796c6b311468e5a118b0ee0d28b066c2b0c861de65bca0e0f638a8f5fe2a0d224f89500f0799a1343aea3107c9745fc3ca32ef7cd448eacde33894f55243991711e78168bd6b2f546f49e3ac55ca5fe56227c83f2f6e41c0813c318efa50105fc391fe3d65331f11bcbf4fc1bc3e72fe2ebb9dcf353a02b73ec1aa4d4692f8062bdf082e6a2f9fc29649247cf03d1a01151f419c995a54e120589fd4375c53259965e09c4001917d9a0ff78d3b0e031793ebe947614ecb58d8c68c03f88d901bb340c9a22d1b625a5f434ce68bf0d47e5e296c59cf0ca75da214056e89dca3334e76e206344d57a1fb61cfbb728bca6bb4a601685f585c622deea6d788576b016d8e660bd8bf11866476fcfa74f0ffad2178753583643e277e87de560689a07ef1ac2d61b146af8e6fa23db49281d0b098fb0d84211842b0aaeb4f39fd557ebc919b5ea7ed86b0565d759535eb9a9d24763494cfd28b874867e4846019368e6476ac29d3d9e0bbccdf8c6a31bc1437348af650cfbc67f0252ac268acf07114d89dd90be5c073884cd34825d3057929df82021e28d4e797ebaf0f926c775a90ba25cd9f99744e013c0480402025b8618e151aea9f7b2908c02c30b1892f96533d8516a47d1db5534614e9ba0ea752d039cf3b6eb51689ffdb66e1b45ce3b9c7e0008fce14e631f0dcbb0603fbb0b220282d7220d9400cf34cbd6cbee915651a37ba98d5635213b142d2912f97d5337365ddca8ce15c7a0b129afebcb37eab4af44305111df08328502f34b668ef9f4c5c36c106f967e06eb397e0ffa9e29a6814cec33ef030ffb007570461957efe1b3cadc51b17d4971f6ab9a1649be7dd2c594891c07c2ab05b0286e1389030d109844917aa9769dfd1b1ceee05feafcb25b77822f4274f7ac0a4076f9d923b3740a2017681fdbc638081b169a3c79a46d52483046a969438f78422c752cfdd583c3b5b7d639541ddc1596fd1f795d918f47e353fbe5ba77a7f4334d887cd51f9938a0f34c0e013d8d9c4e59ebdf873d350a9d68ac36d59bb169a01edc5f487563288d2768a370bdb462cdddb4969fe3e1cef8462c104d7ae60885360404f7753409896c66781b2a71604b86ec22bb6635feda17d4e211dd1b827eb0abcbbc4b64354d4f3823a9698a88d724c3d74d0fc6b8431769b9ee005322a5f1658b84223024d026d1b8fa7d80a2e72f58073d42c77f7ce0604be5180d4196412146ddca999eba976a45db907f9c91a4b28a1a9a528df68d6ee74acabda106d2014d2cb0ac2bf8c54ddf24ea66ee9952f967718acea7815f25213a5988b27f506f21bf5969f07daf32474b503099c95afb8ac6c08d37f44e34dddac83abe0314bff3c2b3b22b7afe3f68c15ac7ffb41160a8a27320ca1fde68d47b7f36275ef0e6acec473ed8573a1193d6763d6b496d64f5704b2f0ce961271d01bf445ba5f251e01d94c54bdb8b111241466d0662e1f313c244f9dc55595d3a53bd5cda6d576828d332d2451721c2c78ff595449122c6aa4c0068aeec2ea5c0bc0f93071ea82dd1d72a79a52dc6c5fb659e74ffde0f30c21a7940861c84a3d6d00cffe09765ddc09db392ab5c95751312650a353320ded96d297f5eba7c46f4098034e2555104eced1c5af9998ca4e2ef3206064bb66d172dc9dc41f51239137af281bc745cc001fda380720e5ea70a96d2d912a7e70615f159e540bb725273704337fa2366568e4135f4bf8a28f6f82cac043b6e13b6a7466d8bbefb3c394f5bee6adf83119757ed935c985e66ef32b23d713e639ad47920058232ea41e7a5f4cce3ca80f1973f88d3dba8bba4fb8d17fb44e1ecd6bbad04dbc539ac6ce1d74c5898c2bc9c5691390feda241aee82a5de226505851b0819e1ed2365ac25fab1c36ed0292fcaddd3ddfece7d3096b1244a0e819760e10057414d36913a10cb3d078bd0773229754611374271f5752d200a95d3f9f37377f3c20a1724b3acc5fd20b89fb2318888ebef2e83c231064cb16c4be59e61241180949c6d5c37d7042a9c4eca6058a561b6da18de709907cd665c2d09776762a07d6223408edbb58275979aceec1e8125581743a4ed750e8c7b61cddbf1d03e456dcad36c60d1d258a7971b228ebc18c03b7a38a7c1f906c99bd6a236ac724ebc01663f61856d98788a8b7c8043752d98ea372d1967c418d591bcbabac0368cf096ce71a28d216bd57c23286381068cfb9e9744c89cf5a321f69ae76b497812a5dd6d5ef9d2d0868d77c23ca7cfeb69ac5fde94cc66ce82ee3eaa053546c46928cc007df4c1967aca1b5a7731dee55d9e70c4d94c9b0b13080c0bc665fa3f20ef9cbae23d95ab91a3cf73705eb0d3bf81aa51337f84b65e65720b52bed90e628c85141d623a64fb91b3ba97876f799df26ac5a789f1d81dc77966bb1d0398c6e85e76564af853e55e3856fadbdd67e31e3675c0b72dd6785115083d4108f32a99ca181f55b0fe9ae28dbb3d3c625c9a08d53d6a2993e9322088ce8c34dd4066f3b9654866cef490bd9d51fd96ea764edfbec07a69db1f80de389e716d44e7bae9d12e1bab0f82cf0440b31d4a6d305c56f58b6f139e3e229eb2bd8dcbe74c328a3bb6e0322c21fd7ca30df9c77a65b58febfd8f954cedaf27a611fdbcfd776f8fee15b1225837050a40314a80bd24993c4e4f67cb18a47450c641c7676fd8cd91d7feb92ed7876e0679609c2bc41976b42d5d8a98e849139149efabb8d83789617828ad23e2f9e85c0cbb735c6f2953fb236a005c5174a60b634176e9ee81599a675c0e6f63ff5f91a7013218c55c0024d367ecbe883584262203e95c6700c3f682cfa2fdb8f6a7fe10869839e2c23ce1a202d0d1bd6b2a250ee1e2e9998eee24c0059a21347f1b654160cb641336a65d5430165d138b303f3ea8a3068e967273693e3dde38ef304a420ca22b3c1867084dadbc4519a226bd71cb5fd7a1d8122b7d811b197aeb27f024755e44f27298682e51d33f418914898f9d7e73cf33adc6de9d054dcfbc22e97fa030f07bf6e769a7639ed1024a63aa7e5cc29590c27a606bcce4f6c015e32cd37cbe49a53fe90a211a0cc8bf9959ed3c57e2e0d24bd0d06b7497da5796eff414afec6eb617d527947990cb5621ff45c5c94c38c2be414d29f87b78d4c5b63a780a27f9e5a2f5c7b145fce59ed98b31cf9bad005f5efce9c16d0b68a7a162863fbc6617e250c476419edb96cf4804949896fedf11ef095e0b92ec4d2cfc0f524f408fa730ffe379f1d2a88d9555e8f8c52986faea79f07137b221eee4dc315f5ed8b68f35a4bc1f547a644b832a85bd1d2921516e6c1834ac4df5fbe610950de2251b53350cc390f88e003ecdd967882e3a7c4da5feaa32224bf982de969923588c73f3c8bf4d5af33ee01a8200ebc898cec506e1b45215966bb2a2846721f7ac4d2af1fca947f30617de2d317f79c2f3b7fd3fd2b17ed2bfab6d206647617fe00d109e201fb910d120ad1cc600b731f3bfdb1f7d873c7fe3d6d80fd3e6cef842dd78cefa60979874e88cba5d2e0b62f3b83e1e3a218a08714e4992e6532c1a61958ee7fd9383f43d07f469174d1c4f9be45ebc178ffd43113964fb7f63e964d57c8d4a3db91685dbcc4340ede83391c7f60fd4fcc20ca175be317c8b5cb456d4f4d9d8e8257dbdcd332313678f2bf4a65fe136b85c086a754ec546c4ce9127ebc5d4641709d4fa4bbf925e91c69a400280ea34e8ff27373408bd504ebb138cbf3783e7bc346bed45dadd5e2db546ffaa720ca45f6054e93a3370f024e105cfdb2ec77013747c21a3edf924a24e892a466ae2714dce48f3df743f9a3ff4b2a3c29354f70c5c6a19e046609cc261596ec3880aeee4e190145d5141bca26de25d89aca6398895131c44782eff3d3e5dbed286e582674de7ad3d97651d81a22160d8d7afe1500f38a05f0e47992cadceab2008e22086d480dde8d5d92ae4caec79108b598218b5bda74ec5b7e68fbd8fd68a6dd2aa05952feeb7acf8df3f341c63146acf3e6fd0c16c2dff5e217985fda5f03766a1999201b4d298fb1a0dedb84291a482f0f6dfcf5d12cc0165702824fc75da2a5fb9b7c58e3f705390747d4cff16614f0d2d70581b976d1e00ffb2f673aa8bf1aedd35c5a7171322380cd7c462a71a81b67e229316abc79cef355527dbb75b351465911a13f14a3bc33a59bdab0f80ab6ee073f24519c2588dc52540bb9a39ec018979da4e6627a153b9a7dd248879f107566ccad62a2094385e5c98f8e19d31c0204a3fc670e4ac1409e103fa2e84757cb361352f4b615777022267c927e4b3586a7f6a409e53dc55dbb9a88280ad16743e643f60784491b2218550e2c4b7187c1c0cf8ef9db0f8e156d6d619b1d4dac7df59eb40d6dfe7834858e0dc4b58544cc07defe943886a9d4c609b3b7fd2f9c3e6d0c868ebfaee7fabd487c7115e55240b6a29f76bf6ec4fc72dd9ce04ab31d2735ec9060d5fc994dc4bed1e0722e5bcf9a159eaa0d3e869a61a8c7ad782b634ef974fd4d811d4e4472647bca407e97bcf054d8830a5a14565cb6c4173a64eaff6c20090782f9c8375c80f7031fb6c319c828ab5238836313610e2230b99b8e9d22fa8b729325306df084e806f8dcedf31f651e968a6bf0ab67b86a4209456b81c77e59b1f28e4b92f7d75d0e77fb25b2765e40ba4408842b71117f7b9d2d7e134aa4af73f3141a8d462b2c6afe1a231623162e22e5e94b37d2c1b2958f60a1fe4e44204a34f99df1a447c0a1ea6bd55309ace02e9a7ce4839f3ac1047a4363b5fe2bcd8db1641ab4086a692aed2a8ecce374ac9c6f5186784fdff8bb4abc04595cbaf2e0dda91eada65e495f4e2df95d3207ad224581026990459a6727f3e7751069a99035d9f6e32cd7d8cb599b943f0fd51e218ae113fd947846ce0c2bf71961802b799690246866d63d7b252752dac3d33dd96691557e36c13f680596f5c5d0f5c4ba0ca9e2542b4947e595c5f2187cdfa7583823478f30d439df40ac56ec8a49e0904bac3d897042513ab7888c31d2e85e58f2685602b946e703d0f70b9abf51b7ee2435a885dc3b6e881f603c40635ce8c0d27fd069709b02e604f27930140a2ee582e9c4b9102f762ead0481f7178078372854260da57a98c0807654b73ecce5b16397135f4b4dd2aaceb7626ecfa499229e3112784c1e7dd932e3026adee4e4d586c57f1944f60763ee26d1e05670c3f78b73b6759d03fb2acbae0b973c4bb9872668993e64b2957cc65b670b7609545d06a1794b8c554e2a4457748f02c410954f36903b8958e5d82773940705da47d3a875b7f7d22b97099a27bd37b4956a67f050369900e4132cb7e5a222d1678c8b7b20bd313c8205a7c44b8c4bf09c9aaa90afac9a14bd6356d55f39a30b27036638045e760d076eb4ad81f48236a26bc762479baa76ca45053fe5bc9d840737382cbbcddd3c7d85f40c8d903634e81a1c39739f79a789190f292c67d6666d4bb50f007e16d1714fca9b8be71fa0d0c7c68cc877be02f830d29f1ac0f00e52cea904054872200aa54fddcb2453c0f7520c5d8ff29469e9049f46ca70bb7ea41aa0bae2ac63419f01b72d09001436fbfb0401194a124c8180094e8ea842323e1dc50760d1f3a8bf3ddbb6b5a876a1d703bb3a4fc9ac1f88003772326839aa966ab6235de217cb4f467d9eda4a64d1cba6e738fd662d285a01aae8746c45456ba58ebb5e82e82fd99491146812585d9a5a74a51886e3fcad74bb9e8f9c14b7f425b3dea994122851731256caa77378ce56d4239dafac739f80e2fd285a865594e3dbd095e3c60a6386051399d857709d84e7b4c3a9f20b700cdaafaae0f47524654d01422dd8bad5e238f79a80a9305de1d2334b3b53f8addc5f5967fcc6a59e20c6ae7256fe144a0942b5326569d9ae9b99a0024b5ed11a83ff8e8efb5e2a7c1a7ac999aad9474fca5482a4e04e4f9fd838f0bec73bd91fa7d163fe0032a99a0e8933b46709a3ecd496f7979ce370172870f1f608865a536e552bc0847d9bb775d9dda5ca84e845b164a046c511b4a317046f4601b6f96444fb3a7470fe28e5fc7e33dfac7bf52caac0af652814813e62e20dd71f7374d01731e02fce7aca1c18aeeb364d05528f9fa79043285ef38dbebc577cec2fdf2e8da6b8c84cc5656cf12d752e4f0c202c383a563a668b779807ae6a99b184cfe3456a5d246a4366eb66c7477b1b89164a0acaa15ac4ef216d9dc2867ca4dfc875321510fd1f394b34eafcdb3a7458147162d15e0d23a2ced1d89590395618dd4eced98a0c15e9e539bcb4f9bd877690a785e2876d208d1763eedc195da065e383a9ab9d0d2a07a28f761bdbf89967c3b8f60f971e4e5cb7311c2f0f9514599e59b76379f3088848ad5a9e7a02781dec4c11ca0dfc1184695116e4ee96cce65ea2cc3cad232aca3c29b4acb3b3ed687cfb1be3c63141b1e8898bf4137f8a893a9bb8d5d2301882102d6f189ad9f45816adceec4342ed3b00bee90d90264fe4b6ba282fd89ef94703b6bd450df6f702298c777fa5dc5b6c8696604217b5b264ccb783394572fdb7e15dd6ab4e2efc446c5f0fc45964fc8a62d393847a8073c7af442c8c41fc19dc3a5bf0629309faa8819113b1e2db7664f337c9f654b0894eda98654a743dc17d33480879ff834974725a22e29b047a1f2006c71b704a00b81f6e8ed619c783a2d51589983d9b250a75e5a98814fa03fba205812d6ee9c678cb97cecfedd1fad79d566917a7f8888334b318a18533b5e31be4b556713f50b008aedc91373e95c245cfe9f8ce4749aa7af4c0e8f0c2aa047a6b82b311c859b20646a1ab28059def15f1984cda47c8bea319e2c7f26ee3bb54e8fd8a25d9c7fc958f2105b47fe6c2d69b74b7b714c81fd13ccf76482ff558b736eff09cfb93370309c577d5646eb254e77773e6b49cd9a272e7cfecfa8d65a185e2214df1c9915de3f2600537495e0d3b33cb23ec5a19dc6b7aa1f0be77d82235c0134df5e15ab0dfd4720abf75dc1aaaf9c6756b8189020d08120d868a679104b62fd93b141f5e310d5bf2f2f809dd837142db8438509ed44c9ca6a4ed27a460ae3304ab84f56546d5e0f938a0b26aaa8e7d5e7a6504626ad336c45b9504585f6a00370868478505e2d070c84d3102a1249174f6ed03463f41b149cebb8860040204351bb73807f6e449c827e4eb2cb1a3f8037eb7bef63ef2d649a6fb41f976ef943f3fa85a48a5ce6934875904257c9e01d4a81397e0cfd07ef1c50c4d0570ff0c685288c23fd139c532e98a5281149601cf65d92f3b5eb629445564af75cf5e55965ec7c288b5009e8317d22cacfde54a57c6f6b59b341d210b321be8e06f7d1fa848421a55cdb388231cb93451537a60ad543f393efafd16b2149be3e73467031cae33413e1249aeccd9205c15ae28011ecd7f14a555f212cce25356b05f6597e0bd906a2b1539550cea86f6d66a5719c90ce7dd2f279b93966eb3c9c8d753e3ec512fab01c630e7169659c9bbbe5aaab1451f6a1ab03f3bb15948f53fc0958ca088a8d34caa79324ac523cc6729c4da1b7de68be498272a267736dd9658328e9b5537cf29696232ab2830cc9a2410ba44ac453897e5f4a8162ba254352cce4f635b1143a26d933e612a8396fb91312a10ec299287e68709d8b993d852ccefacf7b4d27df2c49108c51bea8d0c76315ba11de4f79e42aecf1a4048b8b9c3c9f21c5d05ed990fc7b96498c61ba88a1de6b29db330ba39cf00e74464700bc68cb644bca534cd6a281f15bb6674ce62a5d2620de63c4bf1007f108d6978111e510f2ed353020af971b3a0cf6aedb543ae38c282342d2ffac44d49d6ac08be5cfe85abd8cc65aba12866d4e6309d829eaf517709983844eed8907eef42f5ac8f3f624bbeeeced2d89524ef95d3de03a65299e805fba3b35ecab8122804abf0ce616e13f4b0ffb4a2e27d6bd2f04b822c070d55ff99b3201d5c9a8f8f2454be51bc3805a939e18de16b52584410990925bd530e86983763c307125aa5cdf21409c92a05d859c30a4d34c1287b729d075bba4facde4b6cd6c60e53955841d25d07a6fbab66d0502511e56488739c6e050744e6247fd6a958c5186a5e08071256b32db51bde20bdbd264aa0c45b59578738b9147c618a7873aad6c97a6540f4d3c60af7660516a531d8b6cd3e92ea79d578328c8448d061c9e00a669d8bc3a2991813300aeb84b3f0c83673d169a0bfe8e8150b1c4493a72a53d0ace915873749e6c556a91e2d2420303aae1f1dae6cc28cfd9d72c386f7051b4c8d5e0073ce957a3b9e643b019ad575f0dc9038678893f15dd40dac6cd4d617fa4a92911bd22db8c6b342f3418fc43c209787e0dc9e17d423c4240df628a660b9cc93c3e2df1cd3e63a7095f34e6e98cbea9b90658377461413e22a66b28363171c5d6e2313700c2873926abbdefb3e06002c3ad59c2fda472cfe0d0880829b0f2b14ebb12c8678eba08e5246b9f62a719e47e8f465dd661d68f24ed7d0d2705e5b2a22cb0782c3a437b5e98da20d915903013637ba47e911484286aee031bfac04949d471e8de8b5ca28a307539174041ee01a0e7744400e9545f66b46c5a2f89ad9253f96525aeb493d0d813791277b0e040f61237431bd5ecc7b30a48a52726af6e42bbcc57b10521ffd7c8e859fe8089eeea30f3d1886aa84824fafeb8d828244a72aca91aa7588db3e370437e2a119acd6baaffbca6ff91017088eb2b62be4a27f17b5e189f0774526ad22a458a24e79dc8e8e47bea95f6791705550c66013e0b621a90546a5b4e9402d723916a2bb75537316d0055144966b7e3e10c86a543848bcb4c49e635df1f4cabf00e488b4096de12be9e6b7284f87e32894c1392e070e99c54fdd395ea22aa61a720080fa928263aa78bb496604b7ccbb5f92f536e38189537801a98b47752ee5d295a63e551ca6f1c673a73a3c278daabbc08b8e8c59a99e5411c34ef1a726f0eccf425d8f00a8d03510280f59b45abae5fccfd2a496c91a7126011b259bf96f2e80781bd46a4e4579e904cb900644dccc1a9b8d409326fc887307406b9cdbe04da5c6d32fa0b6ecddd936a5b3ccff0f4e7f40ef29407e7dec06875abb2e17e4c9bf7ea9064a8a69fc548cdcefdcde8d64f5d1d983a9d0c70dd30136ea2cac51aff44cea6ea0f4f16c36084866ac739f97a59f79519d0d5341b807b8838a8f9ecd6d3ff41b481e84c3fada3ad0cf01693e3d1dfdcf0504330526e360f8effa929d46771e6f873e7f4bd17c155627f21aaa3b3077d9283cf9fa2054b737e563d8cae9a36451ac19186ab220fb50d7e8d2c26594abc1e416b51ba12eb7ea709350d307a591ea4e23ad71d17ba859e564c64982f35955cf5017111f2c92472f0dfe3f642128a74d3a824bcd9836247c3ee0b2080317b491dcdd9b202761c24146b8f9ea5c97101a9b736206de7947c39ce45401838e9a89e2afe6d80e7ec2edd4a60936fbe84bca7ffeecb513214ecb12d61fed0318e48c9adf3861c0b5a652ad6514347dc341b9360510ac18ac84d078cd8ae580dd6f02abe9e0a5082b184be96c2792a27730c064523a336de8c06d025a0c667acc05cb065c2d078f20ed1cedb59a92e14923532f272190119e4a51006bbedba9672eb8e0c42fca87be3b2b14ee717a3d48911ba09a71d5a27018317f79c0840fff1aceba013a8f46dbafda328c6b2b0a0885b9e5b07e1b188a788cda9a76ccf34d45c20e8af0d050d02b1dae5b46d44f060ae17e2f8780223d3922f8bfbd3d56e4499de84eb2d798ecf1b4b4661d0a535a97e0f6c8de274e2e510d0c58883fac53c8964979ce01e5949677fbdfcc56e8c8fb88c76f7c74c36b5f70ed2341deccc7da32dd84a1018a98ac3e468a0da626055476ea24fa748aef7ad9404aa1b09b6d7254c4eaa508d82467a59b9d8dc718d7c5e03e5bd2b9b05e51cbc9680ee8e8ecb4009511d04de076eac77d865a30faccefa5948c3dd40d0097fc1ae9d2840737d36dfa5012619b44cb14b88965ed637160d60b344aacc048a5debb878b3041cf6b78649f6efde2f889d1d84d5bf11314aaeaf8a80e76cead129e23738d2333c5239864297141cd32cf02dac676bed35957a668e4d3f2a217f4a0888a9843280ca1863ba18509685d9d8b401c60230e4fc66d961baab013388f7bd0d8d96ad646d88216b90cd5357f51ea116ee0e86e4eadd77577334c82b5cf56d6c71b195ff9e28955297b4e0293eae9f016c9355e37272818b688e7c50b830536c4544f66dbb2a6076ee6d80b3f00b8fe2c10ae91442e141412aa66ade2481d0cceceb6012be7e4422c91f9520a305c995525eb8e6ba1a9d75bc217348b81970fb7527893e0c9f715fe1c37cbc719951a8a8aef3815f61754bba7bf120488d9f15426e312b418866d95629392f3e8afca3097df03eccafc7097c85249822598b609ae5d12b64d21e06c030a2232f515becb68f5c778c8120b792a9ace4609f0ed6a155eb8802f0b4a0e7f137232792732b0a331fc7d03217d9e17ada151c2acd7a1e307bf1e7220923490dde6e95be7051b08f6566da878f312c10d855f579a1ef87c826a3c7cd7d78d87fb1803ede45c6c49096d154f28ae0477ada127a4134ee463d6390189bbada787aa78a5dca6a1e9132693894dc68bb36160cb20f78bac40e6040a870522e2e0ac8c03231dba2b10d80d3cb2b23aadf0dcb91e870742bb45123f53f8f9b39eafa966cab63c7b3ddd137b44e529b4e8deffa782dd42933631e35314530a2aa82d29963114e6d7006c18846a51310c43fc479406fec9ed8f75c0afdff007aa1baf9f40f0ce805e6d43ba1c395b05848f0c7d6bc5c0db2497f237cd95f74e488514503093fbb31fbf9474ab34d0da1b9ac44ea83454700bcf840e6616c082f5530e49c98d767472754dcd0ff9b1a093c73c30ae7640730f38a2686167cacee87822940344a0af1f1504617c6cf1d95d08ecf4fe915a3139d1ea5ab6e57899869fd9d25e8013fd62ae8e4522fb331a5c8ea088fc4b045bc70aa4ceebded98476e3baeefcb89de53f5b426c63bf3fa7f42a33e24dd5aa1cbd34a25582dd6779dc70f116e8a8298a62c2f21336cb73ed7ca5eb26c250c04cc82634c4f4f0d84965ad6787757e5a7a4f964c7b952f63c1c844022e59e370708e23105cf6a07c55841d59dd93d89ed63de324d49aadf5229b13f971dca7b74fe13da7f1d0bf09bb92302d090f283907d18e9faece89e4721b80d7955dc1748f1165a5871cdbfa708b499a2ab8703990840bf304760043875c93726dac48426810418944ad0f9b22a25fd695e7c87c4326d3e8f73a97403efab56133643db6eaf81437a66dcf6ddc9601ead3ce7af6070b719c3e73c56231ea77d30098b3b0cd51732d40310209febc35aa0e20b8d6355c51c990149a157fe72cd91b48c65989391e13f7ecc2699871a69c1333670bf138f6a578e85fb4b32db2c4362998cb162c842537f33982ad4a25edba71e40adf915168f9b85973be8da48457d2fa9ebbc6068578b99ff60a71c7babcaf40a03a616ec27c2f46abecc6446a43df6bbcea4ba671b7cd76339de99c000fd282f256313c262290a67b573ac9d9bef5c437ee34e75e0b3b84894614da81b098124f996c5275a14d33f88595e904270b189c1e7d269a94f666a9fbd2e59384f5fb5fdb1237765402bf0a800b38e5d14e2689005f6d8441fcb79b87a0bd9f33d2917b4662332d35006121cc525ef154d94e5f4a201856cf79fd7587b0a87714b5cb88a782b5f485ea7e34c3664ddfffe9d3430f0b19a5c7ef81dd4db84bfd0ee8509fc5d43cd340e8b6564feee28d6fbd3c5355aa58290a032d523c7c0ae3aab50fce050779c1e873536a0f5788f43c0b2273b84ade44dbaff194f04a96b26b7042d161e606696024bd99e44fed5f72962dd8cf91a31acc7c4229006eeb563523d8afad1a10e8a17e0121f16dc80762ec71b9902d2936a51971e7fe1dde000877fa8180d2db80d548d489a6e036aa80ad619dcbb5906d61eee7fa5de24586361af10f06d4d1f2301587601180236bb8c7dc22cda944a15270763a1c867c241e2bbd85d00662e12ea6517d02c7f89267607c34527d32d8fdca55e0b84697d465a8cdab4336119593ce5b8917cb050ef9d991916781ef5b6956289d4675fd30f9e35676dc66ae805c799f9811d1eb3af9dae9832680df069247bdbabc6281a2b8d051a7c467a8fa103caa5fb65f047efc13c4e9b48de06cf5ea37069b75487bae7ffd54d4de342b9f9dabcc8308c98be17f5e3d3f0549d0955cf1da55b3261c5c02c4657cb7c565fdb7a199dcde3c367b9437ce197a9f7ae03863f95d69687db3c0d2cc9effe8799a3fc1f8fee59023ffd6a5dcf272cde20827e5c8d8f7367268964d493bb26b91cc08cd2aba1dda8eef2be9585a54f4194c50eb24ed660dcb00fa6ecac69f91383927d0831645d6be3e0f0a1eb73e30f04bab22c22bc6b6e2f13c921eb39c0ef9b06228c3864724514fe5941707bf6436c060c41a743281ba99fa5fdf3d840834c6457f4c1ff805e37bffe16b10824d3ee7551b0186045899e6b21b795b1eab4001c7ac36df7fe5b91cb7aaa633f3ee3a3ef9e23a9c521fd079e329250e302beccf73431aaeab20ba29ab610cc22a45ec3dc42d753c61a7f0fe24a615595afac8cafe5f1e250665dced4d03922296fd0cad5278e1a007309ac782a6a71d2751289f4d4816c1fd835a3b1bce271a373bdbdc0a7161f2b03ab76a97b995526aa75ed0f4754870dc6fef6aec7a695e398a85198e81e4d58be74c77467ca96b8eacb12b81234115770751c870ad240ebe1aba1cfed5f33c1b9576990a03b08d1fa56aee7d66e7120f58519abc163561f10f041745adb6afa28a40c2951d3920352ba272561eb8cd07fd126828dfada500ac4a34cce60a2ae92d1f9237cf37c5f8d43325dbf02ba8480e07461067c0a467223f3935ebc5e89197ec8edde57b0eb19e50f1f5257da68560a35b511e4b6da42be50a931c6b7be60fddaa22ddc2918afa5215430316c085891bcc0bbefd7c9c6d8c349d1617ea14d993610518537c5232a60aef4edd6363490be4c7a9a0be6b266114b00f00289de13885b122235ebb9d274104a01193380c79cd5285fd9e9124c63850fc989d96182652d5a118fbbae5c50a7a9e367b541fee52128d5e33b2bdbd01c7a6e886552f0b5b2b9098e2a9981a64a8b8d795c903cbbda86fec491042c216d3e4e5e97ae301e6718e9bac29adc506068c7f6479678a371688b83c3b326341cef8eaad75370b0ba4113711f5975eab825b129bd7eceab5ca5de2db3e33599bbaf6b7ae4c4e7e7c9a7fdef55decf3ce9e2fa9cf7b965160f10c78e4d52e027aabd189044312cf6fc872a036e0c7306b868a7b0a1e6d9f92757ed6c960151b57ee4fd26107f6a4d8d83d4437e25635be4309d6aaf2469926266899a14e86734f6b9bc943d27a6443de1f447443cafeb6d72f2bb9540cf5756b0f766a4361cbcfc4cb35dbebc1b9458d85581253ab784194cd5added51b184ade904a402dbbd903475f7b4b41df3e12228875b7e0c758d75abba34a09dd95b63bbacb9c9549f22f60bbd47fee9663e25d94a728a4684959756302fa1841d475dccc44f54ea4fb4ada589f904fbd96c5436191698f21f556f98caa903bbb9f7066c08a9b0b810ffe3f33278927d47e93c626dee56f2b7788fab3e9430d31714f3737cb001cad6991c62fd104554f743a5eac958a3877492","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
