<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"685a11980f4de32de79776183d48e9e97b7c99b14bae5917c979e25c8f2b56f17cf89ee169029a49515de267291f36d32bc1a5c65f7a146291cbcc0f3affd9212e07a97dcd3758a1b25bb007ca2a4161c1b54ad27aa97d758178c67658cbbe159799d4642afea8c8e59d59b7887c7ce220d168e0acc5d27bd685cae7211b97563e5f7268836024bc8528edc8ee8d9fc4528aad84846264131f8917703eaac9a9f224d856dfb2d32c94de2e56d3a4cfb4f90844d2868405110120533b4bd025bc0144e4af5fa13a9e1cf572ec7717cd39b86fb7d2732d533b422ac5481d1346ede13953e5c502f522c8606db733f93a83625ac3c068ba4a46971f7a5c732d189e4796d5bf061c2fd10db6a5a1f7a0906fca6e9ef857267624dd81f897516f8cd1f0a20a1ca3ba3f38ec069f56315977f4681848504be41fe15fe162951a88cb806925920d522e5f35eb4a763ca0e8c04c1f668531bc9416e540edd501e6e96c9179b9a8a1f0bb935b7bfa7a5d2e413d7461d57f8bf932ac8c0b6c7eccaab17b8850e06d98cfe6b354d85cae4e4ebf1248f00315409a8766903989df1e4ca3260473bcaeeb76ffc9c1d1506e39bcfa7fb08bd0def63a7ed197ebc5e551472a49f2b35f225c51455ba718cdcb9c1fbe45b7e91f319dc2ea421d570901d945022e44aef4a8795ebf8e5f93701846a3906341addcd0681c88793f5799f23b95027e04a3f97b9f47fddc7737e57434d4bed205b1dbb5f35d45ba8a90e6f9925302dd43b2315a3f65400911994fb43529f0080d55c6be3bd3b12c910e8b5dc2cda26fd8e737fecff0ac9f01aa16d7ab3f8ae599df5c6da560d70bff8539ce0b61a7643c8e2f9e381808fe154eed4905722b4aaffa9512f15d15ef70bd8de14eab8772cd8ebd3f6ac423aeb81319a7b7543f0e28f685f83557d6358b0f5f1f1f3ac3e2067293b2511307a8cd474b82406bb429662d6a7836d01d8bf995736c09175e36e5c8995fa649bbb25b634a542513dc91e015481a87d5c6bc9837e3a8150823959aa76d98a4d8de6ee13a6f4b3a7e969c446593f0058c7b212c35a6a4d09466a58022a2bd13a30a2045935f6644bffc22411a612502ee312b08a51cc2e980ea5db9b9679a9f8198325bc2d2d063d2fe70af5e034fdfdfc7a16c258c0f06c197281534735c3fd9c93c64058692b70f818e6b920c063f0d4e7b1e733d58c5420808d6aba2499825a71f533a7a0d4a45affcee2a163a558d576f5bdb9f5f8929c486a037d9d9cf8a8ad05c215da40b358632a188c21fe8c9feb69375664be4b8774c033ca3cfa602f37f9cea368da58d86918813795f8fab487fa84f97da17a93b0469602b1182c64d45d09de6df0dab170804e954cc397b6657a3a5571f3a28c071268690be2c559b1bee55220b9de91ae381e5bf55dc4e1065b1d6c0588e5a02f13aeb82e36ede09403e8ee11fe4f4f0e32d59da881578b3b88136ee5890b06fb9b712414e9fd5b8730b03a176b096eebe53dc938aaaeac661309f29c1db60b9a2fb6bc302b1a1bae7d7112b3bb5e783870eabcf25f8d222e1b49287bb8466636a9a29ff24aa9b48295d120b185202d0d84182c987b945efbde464a2069f1c4db17dfe635389a0b934f7cea1de3a13e77ba88d502ca0df145b136960d7e7fb089d88ebd18c90cd74d43ad6daaf8b12756b4e8e57a6842edda0e7ba1a81695a7da3f0f261d6ef6a71332f4ed177d9e290b1e7232535a0ff332d3cd6327257d9a3c986b5e181268d514757ec7bfa25d8c23b9b4e1a2bbb4060e222f78b38724e35b68ee437942bc46ede35e230fe08478e0aa395245f5ffc11308dc0bb32c3799f50de8f6c47eb5f2dd1ac39cd3f72db2de4a6d0fb967a6053762559301f997c0639bff1e4325b31d67c493ccd33fdb2c98c6f62b857670646e67585c08d08fdba13b03130a2133b37737f3f2f7105f1750f51fc340b270cd7a3ca24f9f1b92d47032e1310ae1fabbca3244c62c3cdf692e644f9b37cb3b615df697addbc0e72e50f98dbd6238022e8ff387abc129d422bb1aab94de647a70a224df51147ea70a9a70edc26de22c64a523a0737f863913f94c6b36b2b4b4d2d5dadd95b4693513c74f3a8990780d1946d80a309859c40d425b5ec6f5343d8556faa58704d9051b3413f63039a5b06cbf6e7768ec013b05aafdc4fcaac5bf3aad1412037604ae81214c26f055377f5d2fd7a1d1693b7cf8c4a177d403b321472e9ce55665a0df324f2e2bfd40b2ff87e0878c8a0afb8208ecbf07fb6e7d50cd50d7af8f9eeccfa2725b05b728f90eabdb44a4429b67969f5d28c218125c6436817564e429e80b56035a209306f81037e3754cfacb60dcda7274c79729e36ac758cbe6a19bd9f516df728d421fc91d0bf9d2c2ad085d10a5d6e3993aef2b908489fbf4d32067956c26a137c36db50ca2f3d4a73dd149bd8008c5ca70e0cb1bd79b518ea76ee581692b4e8ae2e3e82ad8612db1008bcd23dfd9a0752614ba3a4899bec027100cc1c6b2d23a4a5411b418829bd4b613e01c7e0df515762e48a1695980c1cd348d9909357a2884f1fa6d7e95d70b5216a7d247edf0ad47c4a247ea49f0825708250597bf3155a41fc280cb3ca938fb5f2b0fda93316bd683ebb49a30834a078a879c69a1167249e9e6effae92731a7543f16b58d4dc015b277823f13c68782422137e2209e203a11811004aa7e3eaa7cbe8e8b2df667c2a5bb6699d741ef6c2aff80166fb9785c79e16b730bdc8fc026bae649dd2d8f31877cbaa1377cceb83c54e011d3b87c7296ca655302f726ef56b4e9b6a4e928b3dd4e56509335107ebc0a9c2c12646ec74ecf26559efdb34c352b134798195fc1083c3f5bebeb7b5d2255f9ec1a7ef80e33c32a54d1a58f0d36f42357db98e6e4749015d3f20d5cc799e5df616b7792a8dcdbeba1d89d5931e33275470031e22e883a360a894d0b0d06452722bff0cda96eb44d85ad7e514d92aadaf9c7a9abc7606ed4a8f080ea479d53452c2f786ee096b9cebd8f3fd2e5de166af3770a0bacbe7fa1c2cbff4867f695f78eefc78d91ee9b4dff8b6160efdcde14af713d0754e36b16f3ffb2ad71e15146ad250d64f15305e083c5aa746dedb62352943c11871857c5b4f3ef00ef8081b46661869ea5124bf7a728547bd855f1c1c8607c11085337943e353abcef0902c60eee50729a8b4b9e1ca53c51080474500f077cfc8cd25b8b41854ae0e2057ae04cb013c7df06a269fff3be261da03cc11553829b37bc3a339c6aae653401091c018caeb9558745a624891b6c8fd6bebad34d5966faba143371401e9f3dfe3d8b57db9abf09dac6fe20594681724d46522e9375f2b3ddd98bbeac50d948848113df34ee7fa2a952852361452ad383af6b8d520580ece3f70877197bfafa2dafc66436daea2cf3f03f6d516d39ba5e7947c1d0c17ccca3406e637a903eeabc049661958e3302b171a7ecb118145bf9ccc374acf17b7a110cbe329eec251a81c515c5fe81a7894f2bd4dcc84e38b9fca11815ce75ec491d073705caf97ee3a6af265d86108dad3650d7e6f1e56d0abb0ccc9265689faaa9965f2e3e48eb7a91e435bdc2bd47a4d294f65f6494a70d87e728054b5a49648abb97ce97c0529f013b6f6d471e90ca4f275680cfbd2399f38d667e0056f4b28b0fc2109991302162f229760232b2d6d272b60266298bf717aeb1ed916c5c96c77f822cc9157146a7bc5313c6001e71d223e0772ac1bb41fe9261f87eca80bd1c35aa3197e8d7410812c3d06fe10aec933fd40f6e379162b9317d4e045ad3d772647a49e7ffd6e6fcdc7b5715cee6227474e59c194b985d8f7a77bf56f300cfd51d39c901506ee3a2d1edefbdc4d9f9bceba7f2c34f1db6c3ac6f90c48c1246b56e297e9ef456722bff1c368c03071ab2fad68d255bc9da0799e471be41a74825d2d0bc54a5f6c07876d18374684c666f6c28472e012580ad03e06fc71be11a7fd9ae512431928edbd007e4465973adf25d69457f0604c60a1281077cd082fbf4693ea048f1ebb75913b0a374dea49a5ed9d946b15d4edea4be7cf44708689e06f155419694eff0ae2a89d0b524aee1013171ac4b364da3fe63d29d8824d27d38f75e26886914d9f8a9395dc27cc1c8199a7b93227941866d26f8208f2dbbf7cc1f9257b7f373463b3f481a30eedbe6b69d657ef8a2c93e42cc140ca11ed14088561a400b9eb921f9d19ddb59948410cd54ef62ad2ef6d898384905c46a38afad4312521d78e1a647d0d76c8af7748077c9806efaf1e0fba6da5d3fa077659a56349ee2397c4eb7da89bd36fc16e4e0a4e7cb156017fef0d35047ca5794687ecd98a3bf8489c8bac4665025d2786df12473cd654f7aefee230c7fecbafe8f4d624b38f1b0288abd97d6636140fd4aa84d632d0944091d9b95a29e894ab1f6c0690b092b5f3ae776ff4c9385e8aeadb41e236cb6b374a3b94fa588485f363e075cd29ddab60af4636104d4a4d6d3d046270a45de4bbe77873da0e6659a1617d21d8bbd2548ef1fbf9b6ab6b50b906b7fb2ac66eb7184afd129600fd1ccdebe30360c4d0d679df4b0a4e70a83ea192859fd0e3848e803ab128ab1e6e4d5ed9aae37deb96704ba45bddb65829abe63eca3664c2f2cab849fdca2207b048d78c0de3deb3f457849c3bcc53bce387a56b867215976223f88f201b743991349edf92b39c03eddf3fe2e244e9fc84e482fedcbeea22a7ccbc453592fcff68a0c1d121f13bcf77cd2f4aacf57a21f1da48ede59a8e5eea309e0b281ae72dfe751d91f43415cdab2be3fe6064946419d914b10ef7d967513c3e6fd19b4c69860cc2d29a39eeb5372941994ceea149a0d843fa6fbe5e5f9cf4c38496882888029ad31170fd99eb6657736ab8d3ab649c13e2a4ce89895a12241aa7eb0315c782eaaa2a74bcf42a3e4fa5150af5132f348c79c64c9f85e93184dda703696ca84e44955e30ebeb2db5f4028ca66f0c10bdb4fd105a2ed901bbc6c2342db4957c165d97a1d260d5daaba0427954a8a35b26a63f87d5d9689c7c9bc57c5d9e85d0c51024eab6a966b728d4591b33b62c4f88b39aaa73263e60584f8431611a03ad8c0e4279f1cc6c5a366776809ec402588f010d5cfbd6fa5f35d603f8638f10827a6f544543014476ab19e091cc40b7a08266d03a9a31040da72a025cc29e1c5f8851fdcafbede5b7bbc74ec18cb164a66253d1e9e4566a918be182a43169585d82a15095c553d4fc6d3f8bdf08ef7ee6397d04a7afbbc6cb6235467a2606029014cf602e8d55a93c1a329c3fa04043b5b902e47732af8656a91d9ded5e4300344c82edffe8ae09b27675cf46b10bad637004b51f68c8b914bad04d5e83a6576445b96f1a39b38cb90b71cf30e7f92234b6e9f054b16d3191dc1d09150179157fff5c62d2f4cdee5b5a46a83a27463c3be468a7159b9cf6fa55574320d4203161c2ed46d5587635e15250f06f2471cbd6c559a81b473999d7d536672e8859615924d53ef9de340bc198156c66cc2067bbd2a82789de96d1f4ef6930a142da08d5a27df65157bccdcb80b5ce4f5331bada6157e3bae9313830bd4ff90a92a31b0c5bbacf530a19c6763872dee5e59d6f353fbbcb3cb30c196b1c6c8d71c9daf0c80862f6e525fe1df9c478711800cf55f5b795f3266e96bea50cc54073296d0692d969dfc2f6b8f7d5be043e3c22122dbc79a8548e219b83992bc603e68bee557206dbd00c8d845ceb39746290602ce721d830adb1c1dd8ba4a1d959cf4b8b153b27d48e0498b3abffb99ec58158bd8149888aeec8ef37408b75991f74a1dcdad65aee80dce5b0957ff9cead404e54b30ee75d6ea87fec7cb3cf8beddae9dfca71a00ee180ed0a59c0a6089ab9e91ccff412db488344db07c4608aa49bd9a74b2989b51c5bf5c6b34b7c822368aa36c17c3fefd600c46517c9cee0d228079f154af5c2ff002e14b1073a3ebe137ccc7cded2aceadd1455e7b8832fd2fd8ce431ed0bde4762e990c6e6711983de290bb0c96f846c5e39926eabc32074316c581a97c7ccacdc57b28303795689dd1d017e817148259079dd740fb3244dc55ab81b7691f45e6f09d9c2d167d9d1bb9b39b1a5f2082dd1221a9950b04f3abca56de05b0b116a6ec2472b65fb01efbf846a6f6e0ddb0889b03e8fec5a847525920410876b93a344de41dad066434708dcd6f11f13407b95f700f6159713c5acbc604ce40a278abb73268357babd3289960c736c2811b55dcdcd9aa6d06c155bb205ad281c228d6e74561882154431bc229b5198785122ccedc320d410e3b76b6a8ee93bd58ed27b52db743b62e23320ee0483b448e2df7bfbd2b77aea8eb24419efc4f521be493c707f9c06bec229c12c28da1fa56579fe353e66aaa2938a951827eb5737373176aad65c2880ad9e44b5312c99146f190ef0b489c9f0f4f47dfc492b92970884ad8b6c5c19335eca505415d5bcebffa2d322c80658e8095f033b8fe027254a84eee6eda4161ea0011765351a71d28b285daabc998dc11819f898b94e7a6ca07f181f2e847e7f8f2dbf32c23ed3bac075518145b03af60c7b52bb74350ab686f84552f441956441883f5d8c1f1b9eca76ffaeb0b36c3a6e8739e544898917ef10dbc3b503c4fe5e3b3be1de309033fc39a8c105c2f1c485ba466a15be0b67ce78b363d5a7eb115cb2b75519812d6ad190ac9779707e5cb2cf7e41fd656326a29f90175154ccdb09a6bc3dcd66183f24e37d53efa3fba03c5c7c92be586639888ebe28fe95dfc71f68524e8f145d55522bff79b6f27ec90e4432abd935e3e5f4c0b2dba00aa22b33182b0ecb4642634760f407f17b19d5bd28fb495d0e572d63c082946c6a2e45c7cbf1c2108a18c7a619d93ef0c7bf910de4d1b812a705a295870aefef89f54cf406d5a4517bbadc77d2febe49888eadec137818f4bc9a853b847a39b970033f797216ab6418c2efeb9d0b0a231f98fed00006ca574d30799acdc119f1aaa92c2ab1e18645ccd8fa2b9c207491d55026e046c30176f81463b7357e04163f2b568d2a2a1cebe002169461130c38eea37f3cb0b02d9b3980a8e1d0f4afdd480eab5fd182d060d0a8236854ed9b039edbd63ca6ed3005e5d2771bb310227550e22b772730ef9f32d50d1138d65e239a64f489bac064d3bcd7363a083f7b702b3963d76663e385218dd5b389471be6a725847bec2fdc71d8a5f320e19f5cc0dbfc334edfbd130aba5d7e412c8638838891ffa90233e985aee6399f178e7c9e5bdf4da18c35c9fb92d53d4e6cafdc2589acc0b3a43d054887c3eb3225ed0554a875ca34e4e8f1104c6bd743048a564bf4d30147e2484e5e86862d936cdf268cfbbf7288dd0acbc8b55ffc2dc8128d94c67065d51eac28cd8cf75a1188b8311257436204ae417a4cda798afb8628f86dd4317578e1f2b8844cc270c00dce8bbc3e5141083a23425fe4b9cf78cecea188982bfce13cd2707ed8c68ea9cb67466be2d9f7c66d4666f9c73b112e560cda7bb99d59416addecd638fc5bb2914d981665995dff3639e3e3798de1f43d80ecf0083c79be62499ae229681642fee0757a7cf036522212cc8a2b62607fdea001c35680219707624ed027b44ecddce8dd890cb62ba06a94b09429bc35346088ad63317924c700cab318c8e158edbd8146f5b0be43de05e8eaae65a09a0eda8eaa1015a21b0f09bd2fa7d9b675085f19e0603c71b2067648c5e2f7d70419516797a869e0c540c8cbfe267f5cea9f8493ed0ea724d2672dcbadeca073e2633c312016438b0c7e3fe998bd2ad5b9a5297d3ea5fc8be1d8c286b16a0ee71109967d7d245731db46ad6203eef1cc4707ca64023b06b99f98f23af683a3db72b650115ea4e94d5f60cce01b8252cf8e6498b3215cd266798f75da00efc7bd466116aae68257e48531765f12f09033f67d3515266ad13914f15974bdc6c9a6a9bc0a79e0a4776e622cf6cdf0b9289c103c9bb8243feb573e51356fa238b1bb2eef8b10a7ce8a019ff5e232fdb1077adc974e2d4fd83526eccc72bd8f532e0eac20d3bf2378e0e254bb3674b9d7b67a09a712ff013b1198de003546e05d8e4a57310a739137f3ae3c9ddf99a090c01ebdd4bcc7579b66aa4ebaca467271d008d72ce9377390fa4d71e0ff4ec29e52c701037161e90dee3286407c3a75eea8d0c5deb5c112268617d70777cc40f0d390ef7eddf8a6f4ce4976df557f9e4cd3344360da7bdcd4fb1a4a080bed6222701b9ccef0eaac1cbf3d79d6790ff4516fa6d9c0b9abe745b3aa93274a6b3fbddcee50ebbd338e121831a21af6803975e3ac166d0a6bc5025354a6e759e37da7b83444e425153e6b17897291b475e39d58983c743b8e2060b72e84d36ed001aa92d7a89921f3d39a7f3334739f4942843acd1861cd5d252927bcc40d2a99217c4a572666b5f9de20e267777fb7c2bc53a16f30069e06726f23f481308aa9b3102df9e1ef6de910e5483377a6c64934749a97e86d071ffd1659a2c5b4a022e2e2cd64cd5441f727aab2c4582644adee849370ae7e1039468b3009926e22d2f9525d0f5b1f731d8f3377c49e8367d6b020e6d9faaa4c0a8514cf1480140130bf14b046a5f25abfd99b8dffc5431665b8f7fc1e65310771173d14887ae2a04058851f1e4f573674300c2496d97db1755cb37eaafe35716ea91568c2b34db1d8e765794ef2da07b7847650304cb01b243661056cd9685c11e9d4863b9132a5c4cb42f64b1675f282bc403b5f7b2eb5ff60c407b9cd80fb9fe3cbf4235033ff131045475ad28d749478f7929ef4d881a3560875a2c8a3611f95604b762b1916e35cf9a5cd39bc11e674b591f1ea5552371dd1a32c86fe1dc4412aca62b0bb55b08f19f8ef7050e219ccf0459de34b763c2e25f7f54204b64c23417e76901d839c6c91262f392d4503fa7e20ea445343ea16125af5b9acb271c5325433909185f04c98d3a4cf286e66375b1dc800babe4b29dc408f91c0333dc85f5dc24fb409a1ff0ca6e300f2db4e3d978e4403dc0d992a59f3501764f47b82625418752618d519b9a175eb9f169280b267b6670b11e098a760539cdcb347f9720151f32e709e14b773984c626cc882868a1334a66a6201172823b00f7cec4a4e37e01b4dc9e928a64083e6bedebcdb70e6bb4bf470cd040cff35179f83a3665fec5c2bf17c30a3b0b230c10ba638f397bb45372a651d6e97a84ab617146d4657e015c5b2a2531d755881569488aca4898cd6d3a4f9452741e653e3175f5cf353453e92d6b8e1c5b1c5ac2864c96c4a8dabb363d82f5e8ebacb8cd74d549cea4d4a8f7fe466950f7f9298398ad37806bd5f7bb0ad9b990caada80ab1a490d8f91877eae3d3b1c74488bd4593564716d965d6420c39cc055552450aae0f4471b622b8f0c6981c4da484c5bb4624d13a65af103fb70a5d860f6181d273dfb5c7b75a763d1ed5b1373db3201ae49f0c3ab44570ba02ee17527982cd1b20c0c12e4c467cda8eff92730ed581c2adde2ac8b95977fd8b87732dde7ab7e0aad05e477c70cb86fa8a850b8308f9f784bdfb8600fa6192767360970d352f12ad6a76c8b334574c015feedc539c8a6ddeeedc5570b525a12ece04ab773fede2b3e7737466a7e43d30d24df830ac6b5735d72d6f10931b14334dd613b9e3573c0927a39a79c15c731cf1f4d4af0786428a9b9387d1a99cbfb5cb2966a2a8e9657344bd78fd0e26c2b630ca73e7ebc6071bcdc8dc154d53bce466a7e880b635fa839db3660326862bd7ad358de7a71332bbcbfd2d6164718327a200a00d961c3f1f0406270095ce3e6959db0f6a12ea55a9132658ef81680a705400d87c05233ae0c47b6deb6fbe5873b5364d548dda04e734b1d64c8e5a584e761933d018ee85f885b7f334f72ce6c317a4ae383858be929b37569532788adf5f6e43431ff0b43578b1750e92f417ee6ddb5b67eb758783826d9b0e1c628362459ef23ecd62a993beeda815a1afe47cf3b32bb5064ee242bf4189c3966724d6f2bda9f2bc0dcaa6b18cd7a25df053d7273059ad19ae36b6ccac41d06d6c04ea399361634225d4d4c8a0e05584fe6f7c0ea080066f6a67c59bf86137b630306cde666a7043e7555ad01f1118f7384b297d3a9bb6db184ff07ff720973be3d4d25294a166772ecd7f3c928df879340a9e345400c62fa957f8b37fdf423d8eb54dfb0d7017a54126e8d5882efbecf430c1ff11d4435c16cb3c62f58c4845e83324f163272291b53565c0b9cc54de05be41fa7e81212df1a7bcacc2e0d22ac6def3043dc00fdbba6f39c40a1dc2db326acaf992f4d91a5e5b286a17dadd8601b31a39a548f5f641fe3a52208a7d52b2f68666df03dfe79b0e9ab71b3619c0618aa1903f0d40841fea13cdb03d3563a9dd41471bff385a4bd3fbc02015c5f5f477b66d47db2534892e7a8f3ed82a91ef4036878a175031f8a70dd5354f934b30db2ddcef6f816e2d4d092e18fb0623fd0798b0f6f782db0966b933a13f8766df8a1285dbdbe4917a52e0bd4244eb2bc1233651ab3f552d5f1ed4d963c7cd20ca894d6b765908a559fb50e22b599825da9a79e3fa7e38c321d924b5459e9a09b5805faa4b8fa86fd0b81b970ef240b8ecabef6bee5818c3882c247cc7ad5fadd806af5365b68455cd360f3d1f50c64ad4b25e8aa9af23480603c97f83eea85be93c33286bd172502b4ef880fe1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
