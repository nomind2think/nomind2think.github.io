<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eda0a52a10ff6dd69aafd4a484a9b95c47ef1104233bfc3429962ce0af21526f65c18df9d0e6e00ebc6a55120c441f244c0b74bcea4592481211c2611a827ab2db23b87cbc4d57d4c9ef2401bea5b0f709fbf3c9fc41babbb04320f8dca211fa603d3ae368fca2d4bb225462ad639084fcbe47e5009503f3992660a9ebe09b3a7333bc3a210f29a570db2e10efe91f43ff98104c6a082c6186db3a09d76aa46588fd0960687f22fbd56d8f1be4ff2d2219f69ec91102f152cfeb085b9de3016ae078c59debbac0c9a81a442e5572a625aeae4a4b97bd41402fd322244e68083e49ff843ed75585bd5ad562216120dba0f386fe523cbdd2a05b6daacc4ddd168c3700922cd82d66c836d1a51e8b59f105ecf1425522938230abb378676b9251a87d8e6ae1fc950c094880b7aa07376f26a5409409aa4d32c77f83f1e53bfaef585a9c68d4c18b3f14c6ce4f0ea6b7f010cabbb2271dfda61d565c973dc8f008faf92adad6ee6e3f2b326b9b79e119f8c32ec05d0f6ac78da564b3d03c55c803c566d82c5d99c16e1282273459e0010fabe3c95bb1c64b11ab811ed6df44f377c715ebd376b83f24cc9956de246ac357e078496ea3a0400b96c3409f816507441f1e9e19d0cb3f13b0f561319c817ac71325093afeaac18da7e1fc7ef80d01f6a67499093699e6fea02c283b48513007bd656e18491f4c28efc7b5a5a97ea197b3b98656127080895496550e17d1367a6f4fe6ddaaa56d92ab84e2fff1387ac7a250a9084788acef958a25e52e9daaec1ff5cd4ee3ffcdb957b2bb8e6b052c6b1e6000565b18f6a1b568af4acf04bdb1cfff256c3f2bdad7907ed1c900953304dc9a9a1a309fc8d96306ce1cbee6e796bd05cfbbfea91559a823028978cc972f581581c613433bdbeecf180adf8989ab8c862da0b36968b642fc103e903fd39335ae0fd0e21567b5bf7fdcfb90737882e9f5974b71f324450d935d1eb3945cfcef2b43741cf5494d77c3b2087ef044c860acef71d209e48fca795d748d76af87eda5334ce2c27415e283e51ddc1a71e7a16d8eb0eb32e348e2a9883678ba5173c3da6a7ebd6ec997c1d224dfd02f85a492eb00d19f68a495c82d7a980debd02a656ca5ec8c195a6d9fa3681bad498fe4fb3478f3bb67ae62cd7849f8963df79e52f0dcbe57d2c3675b94b977261455e1b0236565b276550da49944369265036953640ea7216fdcacc31b3820010a21f6d1bd8bd3e13f30c8f3589a6fb1546ff94ff748d09528861aa2915ed335a93a4d0f8060efe1a3df4e1168ab0d162d3c4f6440bdf9eb131eab5af37a4fabdca305df6965df2deb9c7f967a69ef65e4e42586972334619a4bc7e60f7a0daa08c59a2c2550b1efd58f05f6f94f5a4db06db4359312fb023a1267b2ef59d7e59d695734860533b52a6483c6a17059cbe6e83512ce62ae75cd1ae89a101513c32ae69ef19f5b7d7811851cdcf4b4873237577ab13acd9ed20f75fab29868978b48c41f33c62cbd2f1ae656e7fe638c0a6762045d302548477aafcc553f7fca33679dce1cdbbf8beb4f36060ac5046dd0d04addb8905dc9c2c19d940e6c517d88534c010fb41616551a104945ec1b24f8b8c06dc91605db7292c3b917d1e0357359f718def05e9778c7947c11eecd7431a1e4c683bca28706ae3bdcf80ff9a24d49cd7710b7d30770239ad31a39877e119df923469183f74c017e29375c80850beb4d9531ad30bad7492eabd3531279850bab93871d39bd80222cf8997cc7b1b32c1cd4dd01a61086079f02b78f74ea4862ee8464a32c868375ed6211ade29baa3ea2fd277ceddd581727402b458bce9f964d67e3da33607bbf16c7374424c22951e4cdec4eaaaf04e025ea85d1214703380c08ec8a98d04a5888e78ebdef2a86e3ab7dd7f6bff640621fcf8528eff13ac9efd7ae154468e13425f4924f1d7e19f2010614a7b8f33dd06ddb8f69f3eba4bb08232f2d9a87495602d9f2612ccd600ede5cdaa6ff6e8d80225997c30515f66dc02bff8d3451f41f4f9e15f21509d0a8f263d48986671656e4caa6c58c57a0915103cf160769fddd4700afc651ae7f653069b16937a36e59f86e5cd328d46ae03c9439118274a128bff63384dc4ed9a43e230e6425117322d2c9b242bb53504ba6a1e33e3e8cb8aff33d273656fc52f66a35029c47d11658a64eeb6dc8e52397d89170f83b645dccee9ae726df067a0c3c8659ce402296ae81dc799ea1c2b57372c6c5c1c83a22cdfcc636e445a33d434297fd69a9a9b16ce7a70d11e77984632c1367d4d2852317216a944e38c7c967a2553b042669b3f196e7a27ae4a1d6080d21ab3da745abbd5199fe19f76154c087a7b13819c1e8ebd0856f4e07a0fa21437f277144a34c17cc53d2c0676609971b66af8fe9c2e3f2cccaaa6f3003bec1fec92ae74fb32aacfdb074acb92c4bdeabe8ebe24fe1d2a3cb6aac6ebeb6ff7b0aa4d43244e8e05b12b4ccc286e960f6dae419f825a8b5ffbc404d71a0acf581cc4a5547014b5b584e0d1d1217bbb3684501744949c6bcfa745f66c13fb64d7bfc49cfac5a0642d85595e8552a418a10eda524a8d0c9de1379e51af5123645fbe8578b90185f14de9fab86793987ff3534142682860a67d93e7dfb0aa0177dbf6689ff73b2d56b4cfcc94e2d50f6454188cee7b2d5e9d58fa86ddbdc212a26a3f0ba61f9f5ba686552ea0e6202d81ebc73af7f148ab65574c872463c02f6e4a09767213d7bf85606fb85a8fed5c95bb8f8a5e0819ea66afd871d6cd4f35ca67147262cb2fe86ea6702154282874dbbd23dc942d52aae5ccb02879254b41796ac21969acee65439e424a2e017605f0b8f072293cb26537aa78e7f0918b21ba2fe39db1e13e19a755c66472f643e0c652abdec4bddde63a07ce96a75490eb4331f9ab659f8155ec6ba12cb241be40412415f5be1f2725c4906073fd54a1968e18ef941754b056a5c0118df72a65382e699b5b2f9bb16acc5e72c59dc743a9264f7c858f27bcd9a0cc098a9cf25149ce86b235dd7663921f6904c279e8fb93e8a6fda9fc03dd1794a5efa69e7b787d4d6fe13c433fbb59535cfaafd69565bd8a140478ffaecd409d1048a98c6c4b86ff17db8b4e1b0378271241678fffd8633de4fa309f7338aa6a75109b77efc89f83c11fe96648b21d9965a8423854413d6197f69f151335988716614910e0130d908567e61c5371309de5cb70c659141499bc622b2f9e2c14ddaf130f291a78b9c5242e2822de901df13c66bdcee4274d03db0cbb892bf26112d10e0ee2ebdd53b2fae42c58f04a22d7c588b2a7cb4d1cc513c0def2972985b618641e6f84c0aa9f31432310a76b53ab67fecbfac8ed685009b097bb03e25a1f8c417a2fa3d05335689e87a429b1d0d12316996f438253646a7cd6e622531b1969886f06609b778d170c5ff426056a174f7d337e7ffc6525094c8fda11147e3bba0026ba7b206b7a09f7a94f2e865117de9519720041438d482c41f9c6bf85acaa1f02d7449a60b855b538fe48d5e1f9e5cfc5f0ae6c11c4ca019fc23bb0313a3d9f1dc54a6d72b2c3c7f07bde5b571da2f834d7bc5554fb1129803f4cc6ffe077ab641e3670c6e0fd0dffaebefdc4b4c796ea7776ced2a4237d80a4f0c7e151626eb8bbdb374b410e616f108a45cf67081c2e5a56bce10a074bad9421353dfcaa571abb3c2c9b8e16d76d8e9fc23fedf175114b8b671e1106d2ef39bafde2c022b3d3a7a8dd8a17f578e43e753fe5feca267301578fdc08896a56e65c9fa5d27d0353069b884e154e51d40371ddd836b0284d27a808dfbb98f08437f2541531179d6a82362e3bb74648deb5066557a6c3670e057929873bda5fbd2da59d53fa4a1be4a5a629013ba818ccc4849abe0b5e3bc176b9d9a951493ad8d21c239190122f49eea4786f2a79ac5304e5dfa70b1bab2a84358909a7e13087dbd7f163c16157955d53807ac8d77da67e494647b30deac19e83841c392425312d3b4c8ccea22e3ce06d40d89c98b96b0bbbb49168b6f86b8684f249b2da1d4b810ad93f2d1e3ee2ebac7bbd697d97dc851e9d92aef8603952c8ab022a2700bd74d7062e0a149d1ca2115daf9c3cc92d75a1546ab252a0178758e3747890cf43048ea38ebc28a92d83dc96b31e1281af5aa47992240574dd964ba4eb2ea0c896fc6d63e14417bd9655babc827800ff3b0049e9b5db5bcc63a444cd212d4169a17006225a06ab8d80b965253f670ec9f80afd300a93a2fda6c7790ba08c182ba598e66751e064b2b73fe2b7dc726e7bdf2bda5e90693de0a323803faa84a1110fdf8842b0330e6bffd543536aaf204ac6f5ba016820b313cf1876a62d92ea519a62335eead0c60e339b643ba5193b03243c370975f0e2b64ec30eadee89e66085659feb623c8672d04945c56ff6d5f0bf8f696f585012f6b0b7ced90c559bf17d2dd8dc4013fa33b0d38790ef0dc93e8c41a6de22e9f27e102061da820f638a7e31c4987f39b082e3ec9e5afeb14b4d63730199fa4c561ae35d17a3150d2e5b284700e92e47fb9317e01f3cfb5d2ad21f0521b376f71e9f9f555528b6d0e88e81652eced3da7569619dba5857267f5675823c289329c2e3456cd68f033296d08bbfc7ef51763557cb8d7e605bb767cf096820bc6634958e39268e9bb7ed44b1af39ab8ee5e01d6f41946b50d9f57271a1906ce438ddd9bd373d198ab025d27639df9db3f30d02e65ebd74bbaba755fcb16e78b5237a174fcd5a5a7445cd4f392fdad68db5148d17c39a06f00e0b95d42940bdc3b7981b6edc7eeaa7cfd096a0524a500210edc0f7a9ff8fff125981127b1a7582d04930906a8141673ca3913d5a40009f1c897833cd2c3855e0c91948d640e4c18361d9519eca1f9c3f07c0e7e0bbf1c5200507003aa7dd89eac721d684ff792713c34e4296a61346e6e90eab7c5c176c4e8ff28a6ed357bcfa4a8e83b625c4709b25c1a1ac66f0c4f331387c13ed470a95b5ac78b5068a6ea8cf2b3e568760643f4fe4e8fb2e1320aae471afbc7f5ad5e914e5bd0028f31b1c1a0a1234b98ae7406ae4ba00502be57bb82350be0a902a13e7502fd773fe6d08d07f4cb5d02be4a82fd7aaa45863463e387330e276a232580cbcf330ac3c0ed2f0711dfd622459c3fd9ed4a0b2e2677d6445c1d5c5a0d84dfe4f60263baee188d6d94ab0585b90b568100e49a43d429bb3bfe03fe97af28f504b086efdb4ab6ab5ac5f8365c46e2769e1b0d333d0e3a970bba3143dde143324fba11df27e4287cccb284f9ad9b648c74fc7206d9783a22c0fc9bb9d1175280b5fc208191ff85468a7597c5ed8f4dc0fd806a21b4dc18914e88438bcdda7bec289f1fee2a12ab7bdf8545a38d16259c88f84cae35a2ab46d0096a6d6d735bc349796b66ddb83eca748711474e1c3ac3a9425045e680652a01f1714bdf3d35187099599188da617c193085e1dcec6d8f14ed67ac16793188c261090ba035c56d1ae44892ee2924ef9359b912471b203ac0a2a5d42f180d1f386c969245bc537ac1e1051e9c2d1a8516012db1245bd1955463636f7b2df2fae9b1cab8e8374c4fd12d2dca7a2fab55945eafe322b88aff522887fa81569c08bb83bee1ec9c20fe700eccc3c8dd18c4478c23f2358017e07297f0a92637d2b43e5cddf3d2ccb310051b8a42634aa6def3ff88eefbb6c7d12308cd0a6a6f9b7dbaa621f211e826b6a5f9bc271a51dd60d7200ff8420fb07efb2fccb1976140cff2331acacbb5426c81cc2dac660c604870a032187f61c449bcb108a20969f62340e287029619f2ea2da188508227918e99ba36b6ab6251c3412e90dd16570bc720a106775d280cbc15e95f9cca169f695324001fad8752fb0f89f3b860f8b2924687df8457e27f4e2caf667e72ebc8e1413fb9208f02d2a62cd79a3e64e71d9fb3b97599968873c8de11865e6e1cde17218cb128860e719a61a24aeb73b1d8d91205e88d1e286bab01f8f959eaf0687d2404972921a936eef383a0253ca5bd3b8b9f1c90c6dfcf5bdccfa4984b5c977ba55230bbed68f1c2233faa34466b91f4c40cfa15ae675fd34bc75a197a3e22d65eb3ef116ebe05017a461bc8dfc850601c129b10a0d7f5f0eb52ca74e18c7069b5a1cc69a0c031a21a6d738b16cb5b938120cf2b884cd3db2375ac41cd5ad858df16f0d765832edc4143be686d3b3cd41b3257bf734242600fb72ed659b9a9dd5e7ed2df722081a5fb770e88868141fdd22f135c7f070a05f6873b295e2fad23c42f70a3fc9ec5fa65efbbceeb489f3b74e753a1d77214ad35841a35a23b5ae3d98bb934b7565edaf084254d8d6a471e37e1c994b3661b5395bbe72fe5b31bc78d0480bfabc350d2089477e3d65fb769bccb367fa2106f5869609186c6226e6698f35f0b5b90741a6057cb50f78aadc4e8f04444683ac9049cf574f5eea696b4a4c718ebe6d60dfc098fd54f142855627d449db8c9d90c1a478410d4ad483981476925ea52003590110d268c231bb59996cd936e0cbbc81f0101301dd52cbd3da06def3531ce45d9c662a45c778ab1c54dac065eb48572ec1b20e8791127bfae9813978a63473c61a7461378f4b82677f2fce407e15141f1b2c8a5a7e26f1606dbd058753c8fbc7a7c2b1f7f2ebde985885a2a78ecbdc82d1ac841f6e274b1597d4e1585d3df618cd655b774447fba556a759e89abd3ca587daca124536fc54ac82a31daedc21453ed91526ab5e398a46af85ca22c72356e1bca7cce022bbfd6178b613e60edaeed2a178e8159994b5f72489f6e5da2315fca5f1b5131ddbc1c7f9e2cff2f2d1c35b31bb91ee9930c0e41dd470d1013f04fa259a34bff4be73860d25d2455ab94bc599037814c49c9dfcdfbb2416e86a0195a42ba3be5483e387b9357a86c3c9c230acd74b9fb0d9d34a52cdb05d75c105796ab6c636290e840476905d3eba850727645de3a200ef8fee0defc68a29d60f8064ccca70dcc4f9ceb94156bfa4ec72888cc7846ac29a68bec70eacab6ecb4de9f1a777c255fce0130cc71b824857bfb2d9efef10dc78ce25b51de447d36c6e351c06f1039e500111526cb5961abede93506814e4be252360c46929ed4e0176e0ffbc3c2e51c239c080b549cbade29befb0a67f11250b56766f39857f93399d85630b397367f6a162e4c21547e926398e13ad7b0a37ec8cde5ea961b0d6b431b05b683c7639d0f53c59e4b449e29105901f0735d8de609633ff684a6e8b972d6c60407eb4409b5534a4c555bd6f3c1282abd98930e985bfbf0b091b535228b1615fdd7bea81407aebb5a490316c8573f752df3c721cad8131d152efd7baa69e54a553a6b9c3ed6f833617e1e49fd5bab04b355c378f9a68decc88ae515971f092de0117613b6c84e177b0111b072d4edef42b98baaeefcdfb77f56529935c1c3524c135dc82b963d8671325d1e50db95acc3f0eab8959461d604280efb59b30c486a305720f97bb2bae0cf6b7e4663827e67157e01dad06568c59d89a53a19acc9094c6b76c1d6b3d0067daa5174f8dff6669bf0e00ef8be8453179b94e94f8802921bdd1a50965e1e0425bb482646ebd53ca15ba92971298550cc0359a83d97e75c90eeb5ceaafe57fa013a12cb4c8f392c212da9ff5cf9f47045a92c8e47dc7c88b592c38f034c7fbb9d733833288618e1f3a3c4179df125f2d7c7de49810c099dfa728adba40b7a052082b13a4d5b9d5c63fafa917d624be583b1fcc31580d262fe76d56ac27d5e7e9e0314838d7f70ff0c182fc74b96f9820eaad5ecae15f139a836eda58c6b98b8d669311d25aa3a59976c585b59c8a5336bc65ab13bb6c2d7352fd3e811a42ec43519a10cf216cd96ea970619b4a607407e44241192712a63283e989d3d7acc1682ea06614aa690130698ed429c15cab66633f231180c957b58daff6b2daf077ab6508714fdac97468018d127c7234d7c46286e37058344e1288632262e99a4b3d07367e3618bb165f32b0aa6e99dfac1f5e12c752b39b68842b5fab37b2882ffd2c5cff330de0c2598226c90aa52008d3ccca0a81443deffcffa5d62abdfb9cf870d04f268327693d0a7971518134764f437fb43e6595556eca78d6ef0475b79b624c35d1806741b1a19eacaef2449551aaed00746fe259978382e8f270ae6bd16458c4ab579748006e300c74bd567cc90188c844f1406932676292a4e1b4f48ed8c4225531c654cc48e302ab577bb396ac7e545f803b9f09fc0d45fc918d03150187f8312e2ce80d53b0bff6cb1bd5f9ea76df67b1d6084ea2a89d2054237adf38ba0f665bf170d3f93daaced4a083e26fc108efa882ef0e15e911f8f0be2d409713ffa67c11e8197ceb90321cefa4233aa2be60418fa6438cd7b0f0b55c0540ea760cd5cb9dad2cd1a7680bd8b4a9abbdea45ce1eba3479660b033574ae3cc36649e634cc5196ac1d6afc1135e1c0dd3053d1c4307a50607f091ea1cd5eee6cd5214a36d1e9dea2fcaf06d5e3fa5df830e96e581d1eeffeebfb8ce428d5cdc9c0abfbaa94e9f8bda52abb76a6e57dbf620812549cb579e14ed59eb8afe9cbaff68c9ce134a08577f059aa7508b7257eef3a5f0ca4439b7871ebedc9d29aaf55de2c7d0a657d76b7b0fed0c58a14fd6ca239a9efe34929ddddd2ec8ccacd887c8b18e037fe279d52d7860137c188dc74defeeb6a319c3ebbc50330e2b2764d5925186d13079ea76d05c8a2d1b09e54b9e42a5d632b2322b3e4073af6c5d3c64a419fbc5299040b360865507003201a06870707256f478690f916cf9254e92242c5476fcd2f141e6b6c1328df204fa60886fc5bcdf30dbe24561cc6d884e6d89771062f4d5fcd68aa4dbd92ad7eab84b6ade09","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
