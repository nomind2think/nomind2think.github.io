<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3643d9f5985a51d9a85bdac019320b0f09b0a015aa989bbc7ae549c6b3de8fdecf4bce4de079a65a28d85545d1bc21c4b517aff7939c5572c1e63780bc0e7fd770718a455241c6e76ec983fa77d0fbba6dd5e927efabb5cd6ee893343d91e4ef05f15032998f80615a8f9f9b8e773aa4382f35cc6513b15deb51dbf1633517c3fd7fbd525ab9f078b3bf3f1ede9be0bdcb0420d494cbd28548a85f9f26b5e62c9b9da61a69bc45d68bf1382694474132653d528e8622d6f74a3f836d7e8b818ed9753bc1d11d8cb9b67b78bb6c2b44c6fb6ad0076c8cefebdd78ea3b61fa1daf78e1751b43f5ff009492d2169c90f84cb3df2eb93690a6921e8bdf676c04e407a31c07763ced2da2f0230e4b71c01965a7710520d7d2dbc43c033d3efa22327e52fd767109d3702c0e023c9d6c34b1ed481ed3db393add0034a9c776e7f346b5d2fdee314217a184003a5da62e837ffb41a9a3ce48421e647390d0c1350b441820d1095cac2722d63c61cc09b996196a4898f1a06fa58c2ecb922729d0a09c07bd7fea31d92275cf2d4a93c57a03cc0fe50bfee83b5109d873970b9bb7b41022837f516aa338453cf43846160f91fc1647e97d0341bfbfc69899c92e585beefaa7c3086cee24a32319da916b62a02e1ece190511e981242d68584a0543207dbbb8a6e520901d70fa361397276e9f94d40c31221bd38a8a8575a44fb6482238e6735972aaf5573ce5b14e9cfad1fe7d458509bcaeb9591c2e5c45ecdfa44b7ea39dd0e46a47246e08f4c6a2547e07560a80920bf82c4f4b06eff623bea91067eeb367136ea2a73ee0e915b708f97f99f17b511f4be2f69f5b01fda5e089ae84b67fe060e9b465be30f4aab68f270d71bf19c8f9641bce68f645094b83814635b1cc7f1726a876cf0471cd3f4def5386c5a39db25740a942db16e8e0591771dd1070d81c6b43cfd78a4de20bf607435b3ec91721d1c2e472ca98134940c2e10f9ae4325025c146f5b1c9a4f383a3aa1bb759b0bab2e6c8a9ed46491061c91c80a6fa6c2eb13c444afd1a2821e87994d74f1f025819e4e789526f4b70f3b354105da8e2d7942a0994d527e1fac386ba5439761756fa1a8229a5765dfa05f502f9fbbeb065cee23faff6448f43807dae9ee41b3d74cb79bb908a19a4fd401c429040fa2694fa84cafe057f26bdc9dcacbfe39c938beac4f2a57f6e054bcaa46afa8ca2a897f8065cd935824d2dc423b4d5d9e23b96538da0e78968344195ca82e1179c0589a6b31e40bc8b333683da7c7277f350337cb78991a27c5789c10ec6cb2c9a490cbdc96c707c30e9bddd976d49f8a44b32d059a89f12f103bb14a0596c663fbd07c8285d18bf2de9aa142c8952f5b3fcb2a369dc9ab3f7a6b5f27d4549d245aa3e35de0082c4f120c487d60fadeb10808a1eb59caf0bd8718c6b67b7e1410dec36889a01e24682de69a2a12745f7310777f466fa4054a4422f4342b718497fc725fd4b2f30406c805bb1817c3410f733932798e9c66d3e0c7791e7916cfbbf90fa54ac05ac12bf2cfe4c8c6c7a165adae4fa04cae68ad80ad14db131043b81a8a01d9b6f5d1adc8a900173542b87c24c42ae3747416f674b2b5a99f152aca97dc6dd18bc08de06761975838be58fbbdd6b5f528cd4dee67305a3212f5ed21fa9c88595dfa99ff39fc187cf2cf1084c38a72e8e122e00d3e3202d6d2f75d67db5c6fa865521a72827b2177b3bad0f66f442e28f6d580916ad2bbd846e240a43e761235fbb5fef91a6b84dc96431d7d5cc74784d7a6c0d3ec9b5f669f4be23adb75b03fd1f4ae8bdb854145cc98a674138655db2678438d31dd22e529c6d6eb8207e72cbc5097b36da27739726ddae37ced33f80283c4e2f5027f78aa1e80d449ecdee73349a1a056e93de69203541563b72bf8d1a0018e4fc2efb1427490e371d1d6c82a0eca146b32072f42ebbe2f6f6f08a46244b8216e4f78b9140971803472da1cca8779a7e81a13a68cbb913716aba78a23240ec8342e7895999f0bf748085860ea5673d8f163cad5c7b58ed2dbcc5bc55437c462cf9d7847314c994cb48517e156855a00b4b92f4603607e2b46a7902444775cce88c361c4c981a7ec61d61e128d2e0d734d89964e1c0d72b696349f18ac0f15801bd63bd6feb26f32bbb672b571ca2425412dff37491fb5f23ddbd713185eb6d796a319cdea3e8738ab4650f852389d2acb9180c795581e28a058d4b9fe4a94999a1631de577c6e36109aa8d8c50f50fd02561c9e1e234c5f53ad8183817b577cb4260d0d89ef593db24638ab1a6219924632cdac3d433f5a448e769537ee62a11d90ed3b5bcbba92b98c620aa7143fed5344b090954d69e869915358e72727d68a6a3124619b26debf5ecdc7a11c965eae2aeb43b4a4c79a5c05817569a0ed92c8f0d341db9cb423b83cd964b206c8ef6f6991d820de70ebab2e02bf8b1d9e743d9bd7d2ca121090e32718b658e169a70a284691ec4b31d9c1a2ef8da1dd9b48ec48e17eee1ee6d19ee814a8fbad6941104e9eb96d2c99a1500fb41d9cedd0abe96e3836a706f6de776ae1f87e836f8568f2949574da98eec1675d446028d2f791f72eff770e014024092a26b28d74dab5795d907f7ed84a20586df47ecb5dc9382ec7895fc17b486992d483b8b5bb653eaa18faabf1ea4459e208824546b4d1f928bbad462747a38ca97f3b6e5e210fbffa1e19c27802ce0878ac5317f66f8ae0210147e0a0e3233085da25d568bdf11bee21ca6b318a3469d9162873752963d3cb21af84d0aacc0f7085c45f55b7d0a408a245c689c5c9a8ad67fa2c22d79e5f63aeaa4c4dc2eb75f3276371962205be5c375f197bf6c6ead753e81f9a437113e2bee61fb20d4695fbaa833cf4028003dc687ed57040b0312e847736c9fc413cf0956525b6ebd32f05197c8eee78df8b90add0a8ba39bcb3f9496328ccfd9208ad6f5f3eecc10c0fe77cfd94c9b85fb6f24ef18045000a6497536ba2360e7cc7dd3b2e90825ecc63726d1a01a18562a39eab9823144baa8c905f7bc153ac80a2ecae8c7ca971405fbeaa15b4bd9e87c00bdc5fe4df03c1068ce6ae0ea7c1a17bd2f8d71a7ca54891af99e71f7d6ddd7f58d8e263fce186e72b07f00d2d1ff301644f385f0f10168e0cd4919dd5fed57cf051ce446252437c6462e8dfaa402e5471c7aef8d4f584a490cb5ea25e5e661fa3da905d1cdf76f6552aaec4a7824c3e120c85ce951922e0c6dfe7cb4a22cba3b8edf992e52d788599bd7c307c8a39ab62e337096de89b8779e957c064abf91d55c4c8e61e2af1d754745dcf85627ce33ac3db900b73872852c1f24abb7f9bfd93389cbd609b6a871f05059a02d0d7356b0a52c8409465f705bc2688238d79b5cf75c481721aa6b6ec4213a4030a8eeea0a5a8dd331e148ec7ff554a0e6df0b6468600f7dd2752a3e54f3f0f2d6dc6b6b86efc986e22775a7e556b74222fa6494c9e4abab96d598115734521a507c197b1525a3824501fd3a5a73cf1d93e9e02ab7cc41c3282ce4925eadf2dbd4fe64d0ed8ef7751b721c561f740a0382b24495387c706eb9f595216633899c7ccccc9d7cb43e4a73dc6aba0a037639f47992915170642c57634bd9e9621cd1db7b9790c18f8c4ab24517c7a841f1d449036ba1d7c275bd8087b6c6d9dec8cde1d197e6d8f625e8e3069cac9cbad345a3491b88a310f61258365d8d9149bf81cf627d60b9ea8fa6357edf37a703d4113bc96e6a94efa8b176437f9dbfbd886c16f1939ff7bc301726be4a68197adeb520d848c21812bcc82ae1bd887e3678941fbb47006b229f79bfb5474bcade4582fb270585bb232c4d832a0ef7388dc2a33639876b682fab3ea2c32d39bd61d4ddd591f1b60a1c26d655c83e135711e8eab1756acbf9b4365b3c79f74d30621a82db6312753c3a23c40a2e24279e98dc285ba850c600a53a17d66fc18bed65c8e48272819f5c5a8de7e78ab8d3caf7b97e531d6ee9ef14bce29280b4cbfbf085976ab6d8a5befa99f3fc4aa40c8c5889ff086c7e722a4fdc23c9fbcc4e7b8ecb8bbd5bc97553ea8185af85cdf57d9ec893c4410828bbd1486f6727ac286b5e55422fa4946c7d845478edde72fc666bd4dee8b74dcfbc15dcbe4c2b41cf02f097941732039b47acfcff9483e5c93c44047c8305b1eb8b623ccf3db9738d8631a4d6a4f1468b344c1fa1f4c8cc14fb04fa01e5858071bb74f15f11aa9ab061ee317b00b74be9a943c4ad28607fd6f822e8b0442ef06739c913d500700b51cf1c092830d21da781bda63aa30d9346d6e929b8853ca9b5c7b181eaf4236401a3d1f7c2f977a51484c3d274773de27035af6ec179d00d739735f0df3be412a7043198cfcfd5a7bf731427197f4d5e6e53dacd1bd3a03aac7bd287941c28a611b16f0b8590cab383d897266ede10a086cdc45db7cce0d8d1ad60b9aa0bcb6fb664e98623e261467eee6bdafc55d501831ff976b88865291bfde80c0d8e1cec762ea9845aece256db8cb6167fb6f6dce61cadcc28a86c009f4974644999f99f69647837d64328d0d2bb781901f62a62c9cf382951aba2b97fa7da68342d9dbe04a99e985b8b24ab637818035534c36b0e55d0beeb2c972f1d1fb520df8f9409618c4f2be1f95a7d13460444519e39527ee1ee890bb8e89a7a0e2ff2cc281d211d477b1cebc95f6c7305b71e2cc72937c3d22b6508b8ff08eb0adf5f4ba9c7e9a690d3120cf63fb3d346ea4158f0f7ab307d1936851d6dd3309e7dac751e94d4ee9ade6230438bfb400dec7bf458d65953ddbd4f74951a87eb42089a24bfd221d22a26b78b1dee6f75943ae19af226a9e52ed926a80816e1e5babefea222cd75e200a423245565986aa6a7e7abac9af551347ba633a9ab1ea2e1fec5ff03e29da83285bbd28586bb69619b61c4e9d90159c9bf274dfcb07297679b4e350239d882da852b1ad7fe84055f617e7f20876aa491bfc384a4f351be5b6278fc1e8de6d02ddd1422635d437a0cf4223e2180355080576c281f5781460d08588a44f6d2442154d107e8f35c5898237ea7132bcc67cf7d68282a29e23298dc6524f36847e40d68c8f523cd78077a5e8d58bfd7aec9514d6fa5ff02580c4255654c2ba077d12c33f87f915e82ff0051a0aa955a0e2f3e62b7e747cb0be2dde38422d66d5326fa76e90c98c9cf798f0f04b532417fdf6838b720570385e5a1c686b94b03dd49c049f4bc211f9a4104c743a89d03e43ad6a227de372d176fc070215f6f1ee603b9956e5d9c850c0432553a921ab2a60441278c19864f90f7c595906e0938eb402de7365223079316b71542063e6833d30580171adba09f1446e6ff8c07c54ca2356481a3a0c201d9d30bf529e40f1d2cfc278e19a43bef38d0858f9724dfa21cc2171457226c7bb5d1389406cd4641fcf49bee534833249d5d6365a027add7921d46324c176ebe98431c5957032ad825bb50aa55ee747552020d65a79d0fa8236dc4245de3fe7cc9074336c85e87efb55fbca8757973af2f92b177bb6a93e04afbf56f845606a01c44ad1246de8b57f0fa367a7a29bad33fb54717db20131e9270b5156bf7c991ba0dc9844d5a5530a215f3a553ed31bec56f58ed5a8ae7143739b5b485ffcea11e085f936dac9bb78fa4c1f66897430ac22cfed87499844b4b426d0981835a99d0c4218a3fd6003212fad1256d86f2554f7a79dd1b4048454a01dc5f8490d5b1b943d83e0cdc0f2c7b9b11dad85ef77f8f256bfcd86ab5ba9d279883a8623f9c83af8ef08f95cfdd19833591e202682e4a67fff2551151b84dfe7b3f4c411f47eac79f272b8bf277ad189619db1652005d781abc55567d2e43036c36456c411584d3f748dd8651df82ac47a48ee7bd413b953add51a033d91e10ab7d9082cc12df550b96186750022a9155f86be28976010eb30cd5588ce9352303aa1ab54ea1e76ed9a685528290d444da6c797062d7c89b62631a62cab571a15e84a1252e2e58ba3a22f528cf9cad94d022ef77b0ddd335b3a24465d2ce1e4e63b00db7be22884c19bef2dd7946d89689358a995158d8f28eba4dea538ac9703dd116cf6e5c010f146131ef64a6372109d844eaad7a9f9b61811091881b74754c8d4d70ce38ce81ab87f9614847feb90ab771f671f45e4104990cf0cdeeca22c2308c1f4c35a89b34ead2526ca5ab031a924a4cc96f9b153e871c02d522a84aaef417de563aa3ceff17d88dd00001c20083c911aba67b6df661b33e2bbe55ca547bb40a630008fa56240de9f13464a76f6a7251155fb8e06a1de033dfe9d1ccc528234017be75630b34c6bfe993847cd1e3f500be9b531b9f0c9b782d977184c1c8a9231e2903215502c5929844c28c5e926d9229841e05f9924ca2b07785fea76ed31d0210c2758a8e980ec539995734dafc0e1e91a2e85853b50d12326355596d4ee216b5b36aabcf73471d7b66d5aed80c3f9d47502e5e52687d9922b640a28cdf86bddfff388bd6950c3aab5d33e9d22976fcecfeaa3381f5ba9045eb939a5ef1e87dcf84ae64eea94282221dec67323e1f9bc3f1bd3804a5fefc4a13686baeece097bf3dfc5b6a92a5ec79e04f2752a90382b28f3531b37b47a7c2908dfd574f55b0fcb1d5b888e1558dcef163d757eeb9123b3d8279736142b6a01e95cfda7d2c9d690299771fa77299c86c8543c9f87a0c49860d3065b34bdc58321ba170c7d044667a229da7032e77acdca05cbd48625b8a19da3cdb9d29e0257350300b6e51c3b237d120a3d3c2bb61f9daf7a31772c3023a9a3a499d3a4e243f0bcc9f85eeb8daa30beecfac1623dce45b74de599233dd3802f3683eb558b2a8ba875ab06074db79d0d17b761407785064199a4d3474399da089ff118f0e391ded6b829f29d31797c405181108ea15e7968f67e53a8337867edcac40a7c3fc1233ab24ff6beaf18330ebda72bf01d051d19a8b42af33da591230e9da35c9a9e0c31bbc64c1f6d3460159003740f384e1e8fe486b36806595a601645d3c17ba668bf99625785882d63ef12e27f67dac4188cc9821bab720370a011f7aed0c59c2aa73a3e15cf058f29d6bbd491a6f80e950b0e828db03aac191f63b2f09682d6f686f406fad0c0b0e39c19e429db2dda4dd8ab09b0a1e4a5aeb00b92d3b1fc26dba25e1ebb5fa000f744393d1deb4887a92b41d77eaba6c69dd45d083de112d1dd508e5b17b48cff4e3aebda93a7d2e4b93a984cbfec4da1b3fdea36d31ffbb1a497b2c9574261d5d294a0357d89b5184a0cf12e74d2ec8db89a07a8b1ead07734c92f186825f4105bd8b4a62a3f198c427f1016cf6a4e96c858deb55bbe365cb3a26458d9c9ba3c7c469c025c98b02edf00ced0076ddb1ab8ed91f517f21425b6edd5261ff0984a6b6fddbd46869ab4e55241a52733838ca50c985e0ce3003c1d73f783ed8f8cd92fb1937301c08d4ee66426fb89f35d8264ea3ca5a785d876820223405ae8d130801ae25ff8b7f9e2a6502640a93a5fee230b8444e2a77ed52ef1badb308752d25091d89afafbf7c6c84533b99b41689f7599f053b6d0ffbdb9d1e5252528970c36be84b15b8a1d258a5bd40d0497db976e3bc2403208f3b942db4086043407440be8df0a9ff3cad3acc9022ac12cf672a19df9f11b6f18b481f90403323128c4173e37e58b3a682b66c035ea1ca4c3c07fce22338d4536282d4690e1c9989d7d2d08f16d312ce6ef73ab1c5db17b1e1300a0b943ca9bed1f5c05d944d7954b51bc55b5facb1b7c85b7b89a96d04864e0de60bd0a961e8bb09c8160e03da1233c7cfc079310d746695d13ee29efb31f36bd6562e72e88c6f9e61668901373b0f4818ba6dce550975a85879c0835112e194998bb3e056487d6e20dcb7522acd5f84205582ea46c3bd0eb0da6a138df3159742d90881d978338d2aeac937f0028fee58a35cd726ae7680d0cc1b745cec6d15f9ddbb8d71c513a199c19e918a49d0ecec828f29dde7be720865da9c1a12d9ac12006b29477f8f5d61ad5199074b4e3b6a95fb4b85e7a48525e64c40d53e14e9517979e7fd68e3c62d8351b5909e76e0fdc3b75ee7706c8848f0d053605f7d5855df5ec9aba206354ff00418075c817f7b258b817098e6bc8df551d37a0153d61018b6f9b096b19e31cbc58716e4a7a138ea940c6eef770058e0af99b4da212c4c5cd3a629efa6946f5e589de38bbda70746d4cf9e556e9043886a486c123779f47a35aec4739c06ed6f66a8dc66030302a6dd10b291ceeea80b593750aef9731e4d72a284c3506fd83c4ca47f8aba451a551c707799ce9ab4c1704b8397a017994f5647e617dd8b7db5e8a3671e195fab857f500d99d3637524fbe8b6c8e845d14801cb40964f086dcdfef3bdc0bd5dee491370c64947b4e498998b43947055ddc9d496907d4050a2956321fb959bcf12834e2884dc097e2a90ec6129507d77f5d46ad577f7b53d0ef9a35aafacb39cc04f71cca0561b8638bf9b340718ffa55e15ce8cfa35ad0f7e53cef813fa5f3fcf2b4487096cb771af1194908aad8763b13300150d40aafd36e27a9e3f425b3e8cf7e457d98358ae7ce15106148ce4a59efc415068d0e8e63d646624a995afe285052cba0f86f93f2be656fb5cc022e070931192f21d7d2345fd68b5d06833021b54334627d5ee9b595733d053798e336aa8f599a13dc0bb882f3fbf150acbe93509fdf3dce89c047e70e20f5c28f555b4ed21c79e1cd537dd3248712242dfa98ba95135bd5fa1ac887e37b5d679d33d991335cd01aaa8b71ced63ea54731cea42d7def2345a1667dfc090a4b4a8e2ffcabba373139a4c0d1dd8cc2c8386426d6967a9f4cbac5f85d4b545da42e789bfdac8d62dbb60fef8278d7810324c3f398c70824cc4dadb609766818d5196e368386d9295c8ebff8fe014d73f32c4f573f60608a0ccc22831bf93c438f41e601e5ee03104c61420efcaf2a057673891b08b86adb316ece2423522fa602f86ba7f86e38f0c7c4ffe3f39ee2ee82f7e8715c47e5bab7a264859443f263b6e72cfac0ad68d9069d9b5d1592bcaaa19ad0872e47e5994f8f547bd3d34d3352cf91b5af4ba190a356c9519087a32d695aa8073c34dfea41e2fbda9eee01fffcb811d549b7bf7ce7a3be8a0822426fea703d17a60bd446c3392111e8afcbc222be824dcfecb0f080a16aa9b423a11d34bd0da85b58dd6ac9884f81a708fa8e2a0a45d7c1c450d4c019349dcd1c9b0744657c7190800f7480f84c6ef82ee726d936a983e1b992b388061839d94de761f23e643261bf5cc9ed10aa4892ee737f0c8adee4caf4483c5489026aa43ebafa3f034411d81bf2e3b56d875b18c8108aa9d8001f6d2dfdef4613194d8b54de17c713dd416d4a7880b2af813bb5ecc1394d58746b7e33b836c0da6c176bf3b2acb71fd8a3c8d3960bcda0c095ef2ed1ad3f949ac3737bd841d78241ab6d02eb4edee9874ccca076d0b4c30c76de15694a3ccdc1ccce22a106122717272de4db5ec0b13662ae57eb0f58c45a6304c4ca0fd6997d361f06664ff4408e1f3b4785e1fff4ecd6cc003983015d92e68446a65499a9bf155a4a5cdbd971be5f30ead55899c8f151682f0f9907c66823db5925ce8e62126eb7ca1f4e044d0aee944e22935b88bdeaef1eb64f2c4aed2c66371d5aa7ef1c725c1c030de6b3db98d6f46beb67e71bd5012c911da797ebf5e965a4d9b0717af90c6d0527500683e3fb3c1a52db8687d624dded9bcae9dbb15e849b3c36626dc28a058089d266465e04d9e471ff36d8bffef1d7176818d5b4b3a3368332152f82a4695f0bc73e730520c711813e6b8c1ab5348eac114b7b4ef30f20de9e6d13a21638f84d85363b1099ac8cf819923381b1595408bb766e7bf1a928733f48a0978621067d96645f0bd93f58c403620f8bef020e348c9560798cf1a057856e63b9307f94b19b465dd4de6382052da04d94b56d5dce327c913c32e08156620e43c781cc9b3e096dc01a200e6e3ebc6698fced91ae475e09fa50cdaedcfc18ddfc964eccfcee8d89b278821badd745ff79a15e210a138072da2de3f7b27b3ec87e45ff35eb99dc6d38e772fac0d72df77fc46619198e6283e99929955baafe717efd308eb4be92837d106674778a3b28c27c1152f720f8771046c563e437b37ffc4d1963a0efcff4213c8a71cff54f8240ef8d4d67b1ba49d95eb1af249c76cc15a7c1cc0466fb946f51be94783a9861c622a3138f7fd915543a2bd04b9546a0eebe14a248424d089a827b671f2d924dc209c5198961b556528caaee5d103c1ef101f6ea1092370b37a15da0d22e709471f94becc6acec3dad61996737a600edb5344af5d3569b15641087d42c37831537a485f911af274ca69b64e8ab617d6ce1d137eecf85f51581b60d2299bc72d08a02da3e7bfde9b4cd243261a878118e8fda3fa7facf5f4527fa17de026af2dd0b7110d5fe7668b9c4a9e0034f5abe3ee051dae03d1deabf1eaed6231d29296e3fba99e4eca6bf9e032db14cb23972399de7e4ea1b29feff4aaef4c143ce1df6421f099b4c6e4bd206c0d0dfa75c38934701e0142e150e6f2ebfe0ba048a62ec6d33c4b524603ef35a94e6a9f4afbb43b74e75333fdead9a2c208a6ca046787e3d7f2eea770ade59d30f828e2bd5842db560cb23a2259f6e9a70cd66266bc673c42ea7cf36da5eb95","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
