<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d63069b1c5f67d4a8d9e498e0b14d0aea831037fcd900a02373b2864327f9e20904e2366b6bdbd5db2111ca5a29ee133c5b562bfa72845e30f16a8dd635c6fce9867d196aa1faf50cf3ced34b5377c5d839f32796e751e4cb6e714562e06d04d8ab73c2a16c6128686b2caf69c59341e42d077cf156ac34da9d3aaa1c277d6652b88ee958ad2ccb177d4960ba8706ea16ba60da8c542c85516697ec107d0d9e0f738dd3579fc25f470c166ca1bb404949e9161afdc163ed53a67f413376aef8e825816f64c12c1e40532a81562f1710b3fddf0982002acb67a28c32a113186832a3bb5c75aed3d0a37db4e2ee3b1806ea5eb6007452e1b37bad17eba017341daed8c1e7b0b321e0e0aae84263a4f6dbed03863610ecd3f403ed3c2db2aff7f8aff8272a1eb8fb27afde682ed51fce89f56dd12cca2a48d7aa3fc39336883c18765312edbffef826b391ea26a711bad82e1c2c078ce223b33c8a6accd6affbfbbfb8efff6e6127ed583f8cd9d4c3143d4bea87667a20eb36d71aa2848d0d81fc465cbf691f60747021a9ea44857c86927e385cb6853bd6065f3d13b0193e672cdfa02f18738df8578a00000097c6afb97ec06f038c86e781b5426693a19d89987ea2641a3822d3ef9f6278c27645d6c00d14e343c3568fd6a03aaf17c226a8c8c869f79ad3ac699f53c695c4bf4af0dbf83229a643eca01043a44194653f42777a8dc67d72aae2bde66419c384c8942ca2a63f9496a0b38fb7b49329ff8f372e15e3ca8208b0869dfb5a91f05015538db6c66627fad6901263c5a8c989358fce66ac23cb30828113c63b466bc1d0b9e4043dab0a2340cab0b0b797afbf67cf4520b44bd3a6ec2db184d5aa001827fda38cf3008bd00de56a6fed64f88a96b175cb406b58ee9a88a330e512aa049bf76eafb3ddc6360bb47f34919683a0935ac51258ef3f3335e1db7f7a803bcb4327134eb5c6d06dda5ca348b8370b0335ad5a73c38206a9135b2f164c3a54a7c6653f3527cc179123e5869d342a06ae1a5fecb7d149eb9d48bcdd81c63ab81782731cefc643778edd8e01ad7b67c22e4a025962afc21906f1d7c5fe4742f6cd4a347bfdb564fc53c2b09d9e56bd994ef48e829a88ea878e78176f52710bcca3817d5d572f522727fa57342040b0beae412e9796c4157f37c0417452cd40eca11bb021304e9fdb487a9aa160496ad496e58c1317ec36628e16a41713bb2920cbe268a28ecdf2aa288cfdb02672089dd2ecd764cd319a4467eb992d7dc46bf5ad981453fe1f2d23182e16c79aef04862caf1c368fac72c970665b5727e09270c4f89cb3b821753605de7115d11a66b32cd86adf75550f1277733f66c4305af6a8fdead6c6ddd28125cafefe4723841655a89d5cc516c973f0d9d3828a9ee1da8b68930232b8d6d9c0079148aac5eab79fd4debd06339b912d73c2a94cca4f0e7b49846a0129d590e76d0f030d47f4a8493d0bd6f60b00931a1be018926d5ec39c1db434825c7b3ae3fb32cfb200e760fe8f82557a1b3f1d3874b8c8108655353448d0cc7e745214c7507562af2dbba8c116ba038de6b111408dca516aef60a53a26cd98120691c0f8998e33b609f7f7e064eee2867fa3331f049bfd21467f2a5dc4681757a8912abad7b2bc4832b832f67e97710538c4ad61c85321482dcf3ed65b8887aa2e1e73f10da8d78448a3bb74c090adbe75ad56b36767fd77136261d48c3e856c5693ad37cc3f07d48e0428aeda8f0429873a6f3e8d7fbe3befd25b24a7ec28fc828c7a1f00b90cefc5f7cdaef66e4e2b3adb40f9e978febc9e0923e7eae8dff0deef660a6e2c0dfcbdd3c8d6cc1b1e2db53983c7792989646122e14fa527f4c14eeed4096786a6350861a71ab53aa157dd046610e1f86aa739c95e21e6c365982a605bb7d5837f29c28c6aef199900d18895cf434171e03742e3a141c3356362f6a38f2356e783cdf3f89170a584a3ba84028686b56f7d281ae2d3fdaae28b0d949e6982f761bb307dcc883f8e509d6a2a93f13ae339aa6921bf9468efcc0bea8eda1bd53794af34603c6f332ae231155eede4ad0d02ea3dd884ffc9377e0b729593794319c7bd7f5b0a10804858801194861d89ea1adb44733a8c36d3aa56aa40cd7786510747a10e890c6abc19716ec3543fd4392fa31a7ce2c82f3071548ede67d6d971278301a2c8109018880a89ecc36e485235c0c8a993473b8503a6f4f70039e3d8c2e206b50cc1df3e6e31f55d307331f0514eecd0a2f51da59780802de65465c4f17301bef18458ceea47e02bf692381507be87271e7a048407fbc42ff6e2ff655a4643adee8f7507cf17a94c4b8cd91e4590d20d3b38df1bef50ea33e7394d21714d33bb721dec9a204014398f32eb9f54e1e485cd50562bff1ee712c2cf4ceacff99915d00a2024c362241bdfa4ccf3da39b03487470fdf7d39ecad0b3af19651d9fe01118e1c961c2eb63bafb3250b6b79fe9445c82252910f687bfd422750d6bae0d8909f5d29e54fb6d54e7266d9b575033a781269d91170c1e4a4e6cb971f68c61d73c778dbcfb692f64845940823d63063d15d51983ed36c908c79080562b561dd51f26ead616ae725bddf2494efc5600c8ac1056392f6034e12171167299f011047b01cfdc528a6c91069093c2f0a70f3a0c4e756e3c711806b33830a68192f9572bcf1b12ae764947f7de42ffcd5895cb073429421813838c3f40360a312cec852ac2f0a59c0465b2b3ba63d5f54e62490cf44ad9156e39da5f3a68a849fdbf1d62f321f7cc9a543bfd193feb0a850db8bf960498b88832e44201da35e220388cac8cf6e3dd5a6db0945fbe55bedd672bcc901e491e7a874b003612d51e72b4f21b4bfdd7f47d4ade97b8dd6ab137c674c27000f8c6d4402aeceae33e0ca461c483b21cdb32614821d7d4e64f46e693de85fe490219cb50fe0ed9eb7e95d800e23c3020edff2e7d89ed1d87cc934e1a59e4aee73a5025b577aca2634ff1418eda34c533b1a5283483919659efb7070c186dcfb2648466f4ceea200c916d96331361a2c03f24160685f3361b76b240094c1dc3d2a5f239b36622c145fde291780c830f2c97664ef24d266e6fa994700b71eef0cad4735bf9714ca741a4479900ca374d36f8f7893f932dccc2ef88394ff0d2130f38998e0691a68ecd70f0fda0defef118e58f3abd0ec61e23bea9b5243d1693c2c3b6adefba83abf8fa595f63da059a298f8463c21e457dd570a7b75745d858f5c24cfe93ebd2321c56e2d93d34498490ded648ca2241231483f8c6c20f2a6261b69180f2a4d6009ff5147312a72abb294d4c35eb02bd75f03f59bff8a3bcd576090446e5fad45b29814aa36a9c19e07898d04a71161e92763adea47ac788830bac38998499a92f91d1b4331232ebf4db9d57372b20042ed5b663d90c7b7bb23f0fe74110c1ff61c09a8c238b1fd837e2f47154e696f50173e2a7558b95c89e6d426652cd56b269387691a595b9c324c5f993c0b388f4b77b6979795c0e1de03e908a2c911bb2729e83df1dfb319098ab31807f409ef6a7866cd507ad1bc233e1f7afdfe699a714b76148b69eeaf1306d7dac38631c33d69f12d875a4895a1b33762ff8d0de7d85956fd2d776f628abc7d5c820151cbe5ab91f66f525c292f03c1eeed55b070f38675045ba2b543f2c5fb73b745dc1357c6a72d02c1c877c7866c5d4ee879720593da1e699dcbaee03b903506a7c3a3e4e4d38a7ff98d7514de2513bf51a2c68129feb961449cb47daec4cb6b1798f3f9bf7716291f82f407f7f71f94b4db7ad2a055f545509e0af7eb66cef7cdf8cb9e5775b70e945c16615da3b61df9ca3c490d861cc1a52dbef171b03e7f64d9ff5aacaf5d9163fbf081ff40489d32d417c96f23f0931e0fdc78cc2c376b42daddd4c9265dd212939621af4f9086ee4d00639b77107a97115df4e12625ac594f28907beb6eac8b05188939c6d26a602e687cd4b26ff9beea8bdf611eb10c0deb2ba7ad80c9d0ee74c3b6249605cf0c71300455a0d28010f1b121c71daef3cf2e5daf83cda3c2aab9a6233e529fdc8f4c09b3b79a4ab6f196616fb8fe09176842d0d444a2d76b4362beb8e1173d982139cadb8d480cd0d6aa446df9778d7cb85f87544c6b2ce5d21cfc22e64a1896cadfc161b42f56a75aa88694af8782017654d344b8a7d8176ec64758d945046baa0f098ef61a616fd1d53f7b921463247afb63e10484ad4645223ae5e3724e9387bd4a9176faf6cb9bc128be562b0162c0db137377fa095c7c93bb9be36b300a2d5fa973eea1a556197295316904014756d20be26d5ff95a0c53283d138b141d3bccc9c8314a18928a82901b775661c3ad7465e57eff292fee78b8a998f69b2e049d87bcae558c02c8cf218e01cf0d3394467b0d6823e36866de57b20fcfc7b180902268ca020fac337379174ec2a236bb7c93e6cd79aeabef26ad638db49ae7faea4799a4751d07c257fbde50c73db035e05f16fa87d1f7d06e36415cc54c31711615a7ee22386fa3bccf87c1a2154748598bc3b7d818ce80bebda2378c148e67b15162bb264c8f5112cf6befe12980753313447a362e5075b9cab9f77ad6f0481e2cc5ca4825f068e0805a98322778f2737a822cc1920eb0417a63f6e434429277b43cd0fdba295e3f30cb8282d02018098f501ad3bc99c05e4a70dfd390c5352b6139efd31f3572e8aac0aca2f13ef2790e9519650467161ccd9ed6205c0ca451d36ed118b8cc76ac0331e7eefe3319ae0e02443e0f91a4a80fba87d0c5a9c240aec1929dec45386cee817a89a6c62c2fb66c93a0809933056578098f032d66a43b081aa7aebca7a92f95a29134f65e1c0810c6e5633503c8d99dc801fd177a2256aa19959e707d08f1f25281b7f2cda3252b4c9ae6a5b36aba526fe263c626dd5c75e6ba44729e35099125f9ce121ef31d533a9a95c2ea76b01a87244cf0dbb74d559f219f9669d877bb17bdea56e2c80e9c2aab22b7caba68df2d2d55b82b141cda37fa5f509d33749bb915fc3c1f11837471c996cb4696b849c5ad297aeffd850998cec3114e94b8a97b2ae06adaf51d68b8fba0472d1411626489f261b9d7b7129b48a3f0742b58bce77db81313d625b8532578f7e209b126699817449f252b71d3dad8a7ae3612f82c89023e7559d6aa9f2b0f3d1f26f8ec5515d3c8fe9a393f444a8392ff2479679b090329a23e589be786233e9df52bcb2eabe1419ca9c37a159f4dbd4a237b60c38c16cdd8120154e238b2e4c23c3bb7daee09277ab6d31c166221f2dd3c99c25e29d32815b9337fec052ac45357e56d11037e27dcfab037e0635b0543d65121bc77257723ca6365bbccb81636feb84a21f790a823c9030911f131a97c3424a7e64b777a20d03ca75db1077a171e377a6a409b65e2c66b69069823dd8472ec8b95b61760e4d937db10bdcbc23a34ef7bf9e530d7a10a625528b240ac5116b121f38034349f43ffe268b736d5f044a4f2cc61dffe6c0c64608e1f8e05c7e7b42a351ea89b9e58910a3ed671d3fd0d009d965298e8debbc27c4ca9bcf9d0fb5bf4e8449a89bd40b1b812056bf484b0d007c4efa120c03a50bdabf8746a32c493a132a2ddc3a96fbbce1d96456f8786ef18d0257a2e035c58338cdbc9f3843a9c3125a129bfa5b6efd6402ff69d8a459b51cae85538bd1ae11533a0107e4cd6036cfc394f8c705ad664500e15d438eef380662a33c885e1698ded2156d347458e8143944a786b045d7169dbc92de5a8642119497d8bf559d857093512fc1a11ff3ac94ff9250c6f44a581f8819f09f525e27ce1ae2f12d4fa30d83af42ea8482d7d473eaf7c10e85cc7cbd7e95212f5b248f554c7e305f3f17a68d06c3ae6f46b4b03f70f6ac34694359a003884f2b34fa93c4c97d6be081e3e952506622222c2eae584770ab196a4f6a1fa3dc32c574e57eef1b15bf1943b0336512cb655eec25557319baa0b0460e7d1cf6fa6d11f158c68b9d24eb41df10cbf5ba91212cd3bc4dc39c917360568b3de0b2c3fc8c473b80e6eb14b2afa1068763580092c8af33ec1d464a124360ed72d2fb66d8566d50fc977b074059b3c5454a4cca84bd46197587d6e9d612fa88a6544a2cf72f125d1438e395a132fc29903593cd1f725dd4a0653302e61af7cf0c3642a4e817273b9b224ed5ac50f3f98e9872f04a04e1aa03c55226ba24b0f581f48a1f80929c6f78779edaebfeae235c0966c9c2920c5743a3e707546884bfa74f09b1ecafce1e4c7fd7445a22fb10d50e0d1af8c1ad616734ed24329aa81de8cd884294fb1315f9bf7963c71fed94e10ffab11d4e6332817e569952922ec4284364df6bf841ba29583f382194d92365e66d6b4b48f6cd486bc37dd3843f18fc6140355e654f7b0cf9a822f189ed78800b6b34d709be9f3456bf57ad9a1459d2971c143ab136481ccb1b9a28e0ef46d020b22ae50bd569f002afca6cd929a9cf3418b72840bf5a1dd7cbd477c0d0df760185ec484ff618091ba864bb704b9bc545ad4f4ccaaf0290ef62499a0ab3d859df1aecc5cc6f894a78504af1d992a577d8b8b01a563659c6b1997e580c689779db2b254c7a65d7d2c57315b329179305f2f4b99dd412ed2434ae6e1aac82f905eadec3df5495eefb64f147c266be6309b1c0e9ca3d8c3caeb24f4aca114ed40edae0c2962e18f60bf8785297923fb6ccb2fac6113a7ea2c16bb7d4b4713d1052097177da7f713c31e6c85b501a4fd0efe7d94a94fa8d1b1a1921501bb1b75997ad13985fecfb38f8d7277ad047bee1e393e51de4d0363404d312dd4e6d813bc497b1aabebf1bf26236a8cb80a7c3a4ee58c7001cf722f45b07f3e8a6835b2ba4f818ca96ca2a641d160a989c6156fe4f6b04c117551d55e28a45912ec2b3d12468595315a6f2ac23a10569cae6162949ce82073bc15cf051335c8883677cdcd2cf1dc848ed6df30955080067d1feb03ffde34ee5ee17734ace12822f620ca0e10ccbfb13d5058b55f30a1098ce0d2fe4cfa98e355b48bd49b60d313f40e3c629723b426a30545870612fd3d03556f32ed0216e21d5fb894a0f84030a4a13bc588791855859beaa06e09ad0b3c801d5c67729f7a32f0a2471fc34e1bdf0c4538997b80e07a94dbcef15e9e656914e881b238e049e61b4e928995f03a955d90832b57cdd5f733412eace7ddb5f23a18226867f986cf6ba4be2cd716f3322418b53a79879d07b7038297e0999908e1cb284989435d445f30f59e983d38de15f7941e15d6557e9ceb5bab170f576e65b51a22e92ceaedb06c7883624acbf1b7a1fec1b5c3f1047b662523c44d9b28e2d4ec581c42489f5258b80448f22a8b135a4a6b75c7174d289ded52927c19cb041128398a0231a1d465bf2fe8c8c9b49d2946e30f1d5956e1f53253481bd59a76f5c716d51c0f9d958c4a83074008cb12c954b7ad092fe9782240cfe0b128b891ea72b3bfee38730393f10755b76a909c599c5bfe6b37c63a815ffe3794bb16f4583b87be8f2acafd5d901183ff3ec6967a51898595159c67721c86fdb0c39f3f448cc7657024db8ab890f31dfcfbac3e29ccb4411e67975d7f796791b1ef7f23f57c3fb9c2c374e94619ad96ddf6f189ad18dac740b6e54410435ad03eaf77761054374a5044d99e178a7e3ce2c5c763ad973d60c8654e700ecda3cce7e6206a6925a74cf688f824112d8ae4248237c73bea1abeb1c01f2601855f2479c073cf6169c2801bd11dd6b16eb77886532f1d1065cd2f4d32fe01af85a8caeb0d9f12053e5c56f2f7b0aad08d5a359556a7069e3c53d299c2eb6b2e646209d6d34942ea1e04a971d21ee80fcf1eb334af4da2f7760b09bce01a48cbdb90704309361793f4bd7e845d6084044c27f3467b17688ddd0fb0df335e940134523a735096711b8e31af0df0033379c1116f1f5f3269499c91700e431640ca27a54134848f028ee5578414cb97a489d50f7a8638ee50714f772bad0512804e39a9379b8c4a77b8ddd618baedba671dd7cee94a02759da568fc243011a3c08bd54531e35b72830051939a8ce36e78e88ac148b76657b02bb4dc41d9f061988a6643d275617851de14671e278accb6785ae771a6cf92d27fe010de809a8f1fdc3b410b81715fbb1b787b26634d3ccd11319a8a339c3773ec38a63d6dc1fbae32aa91ab794b05b45f425a2aea171ca192167d3c23c2087d10fcce61bf0694273babe375cd902468c66e5ce5680c59244d37a2515fb0eeaf3056260cc5bf6068ff20b78fa8410aa4d4326b96c96a11b9b2a79874279963181ecd9e1f213be2a97f8248997addce2531004a08469cf8bda12c103eee38fafc4ff31ffa70464f18df6d75ff5cb1393520a9cffec1080ce93371b71856d91295f34608714683ea78e3f14fc72e87feafb362504e443b39917cbeb0f77a4587421acf80bdcab3bec76c372eb5ef4100653d701f23d2317d6608c1f7beb2ca80df644843e01d1f9785fb985d4a21684b87642c7611714f78c923e16576c55a736d215b9df32fd38220a80392bc1bc571225226bc3afacca993cfd53b8d2d635020bf4ec3c99c45f28907ee7cf83befc4073a3e7c6973843f23cc24a3d60a3239a3c14da8d7af6f0492c7b3b662da2acc4bd5c94cd059bf2a93ec1e562175aeee783118d7f07015eb886443cfac86447450536ddd21c0a6b7030550555d95c5601d9e8fa1d2acb9fe8b2753366dc587d3674bed9680448234b6888b8364e5d767b6d228c2db633c830cb3dc5f25259cee3fa4c18af0a36d985fae8813f09e70240c3c43ba7ae29693d5b9df2a02a4861d02a3967595d3957631470759ffd869d67a89fee30b95ba575ded1e9b6a8f150f0eb8b09562956cbe818c6b633f5a9f67bd3fe7fdc863f0634c78a0f3d059a1f6f04d37620fae8cdb3f1bce50ff3819d7bef84b96b0b60443822d7a2b932c7017d035c5e57f27d73927647d7affaea9dc588c14f8beede5a5e97ff04f10b65d72a1b1ee058c3a30cf4b855b72fa7a89421cc463c82c38bf8eef08a5bdc7688bbc6d5bf2317a482809becf16cdebdd776a9f1e7a458c2c2658884b0270e528a8fe29b45bd9d9f56cfa175c96e9fcda0f4a44115eeaad62dbfa20a311ee8b3bed955eb9a5ffb459ad9166152ab96a920680e3f4409d4d0a826855d512b0877709d353a758c1471acec16b751e30b7b6578595064382720b8633428bc32024717859faaaea93d4cc8011fe13d46c0c45198be638aa6ee4efa7e71edea0e5b76cc05f94d65e5f4c355a69e0eb991d009c44e1fcc7ba22d16f43e9ba32ed41f2c8cafae0b92a8cfd061ac5f9957ca239649e52548e37f73f964fbadfd37826915c60cd99eb98dc9e154cb02684d0837a54c55e7755765be030a5e815130a44b5e0cfa16a0d6298300e1225f82b66e0424a81a11a69bbfccaf0d6c68ddde0a26b0a160205c2c1e26f3f87ebb85f12eb87c0ba02cd97bda7ca1ae5d28a89684e47c4a1f8988669c24f053c3bc9b904f59f38955434b2900e1041bfd3874af5381a49fb59888cdde20a80d7e466b964be50fb3edd455abfb7ea3a90c0d71bc5c5e45db938861b98b4f1b6ce99e629df2df5d56f61dd59738c89e05e03ec919ca95569448f0fbc4615057e43dd9e92f36b3d00c31beb70bc63f5d24b6f1beddd0f3bd57fdcfd9ae7988a9372c55103f7891ecfcaf6307a6694da11a2c610b8e23d850d0d9acad029677c0fa80e554a53a4cd661cf8574ca3445daf6644467d344382a87c1e347f3e811af1cf90f9f0b1f3a93eecf2306aaf7157e1093d999e874c527ea4474c5e56cc9c1c47117949267a993f30d84713518281b245b560f1266483bcd594d59588fc0022a1daca7a23a01bcad47b653a24dd66e98cd43118e05ac16ec951e8014faf4d1c2df4931930067a39e4e79fbdc9c8483d8c0f55877622844c14b68cfe4ab8d1c50b676f9f08015263990867bbdcbc0867f76d55311dbabd2d8bb148c4325f73c33bcf52e8b10a295f93e53a7da3642d158b07d7fe948b481b97e7329a89629113ea3163ae044b967a05a70555e0544e31b75aad2360b29195d99bc99104bab8e8b6f3aa5e21849d1d28af495b202da22416a636bb1e1e29bae1a94e76cb53b0ca72cee2d31e19765e1b05e1c23378e1661c4e950516e773f157475a9a6a5ffc7ea3fe790b16880feb47d7ea22933f052eecf3fc9945808ae5852fa503862de7eda2f414da13103cee570043a44357440a3cce57bce1165830a566ea49c1d9542cb1c8c45509c2b821810ca0a86b202f77f7b49dde5faae889dce218924578e33b69dc1f75ac867272aecf6c40262cae69ddfc5a92842116e574f731fbdeda78949fbfbe67404075aad9d67749225913761e7e17d98ca3d4cbafb8eede043e8de8fefbe1e5128974b2584f8eef5fc7f8ec5e1c502838ef50f69e561d6e23f5ad8802584f3bcb12153c9604356e01ebc1067c9c060b362047ad451141ebf42e84a42a73b66336360386f7b74d50d3e4b6a794c043531317e4fec3a822f92b9f4b5289d53fe27f2b1c88dd3ae23376afdd98748cc53a937a2d7972b084d23bcb19de669e9a67e5064915a466f9865793569cc02b7c790b5d320a0fa6426502746b1a818cd4d5a33f3975b5d97af043925c17f5b68f60d7a211ef8b7d24ccac77498991344941e698c884d7417b5e193765b9b42bdd9c412cb8d5eb7576a4bddc8be0975fc970c33b11c97830fb79226b5107db69024d2284f47147","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
