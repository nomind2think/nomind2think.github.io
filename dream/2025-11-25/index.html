<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4972a6d69529dc060ebaba176979b8c62881f3adcb005d9cbe4070d00fc2e5ecb25bf5c046040d248960a0c4b40dda30c40345cc004505b697a0cacf626d13693a80eae06f6fa8420771242b18fab133c54eb26998d6742942123b636572d652708135992dc4b8ebce3cffe4e967f17417cbe60dcb8e63f1cf055091218f29146417cab634cdc7c85d4ca4620783bddadfa9e3cc02a3949fdf0ff455461ecd77763930a45268ca6af04078d58365189bc112a35fd587dbd63333cad50f856ea1c5818f1d35063a1f283fdd17540bc055499449f017454fbe0157b15300b771ecd1fff46dcec6b7d7622247e8288cc50fae5a3ae12e4dc72e9d00fae63b50ba9c126ec84097a5bf552b27846aeab8d66e016da944d6626f965a10f33e4f3ebed63360097a354ea65058d3cfcfd455745c1d172d22fa13bbecbff4f22fbab60e8b703dcc518054a9b909ef2d71a4f129d3cbc5c866ed4a765cc152f80761f3958c2a437efed4362a09be78aad7431ac3ec9187e868694c81c95d1cf75fd7e6f37f5773cf54f344d9825dd466a1e27fb81da6e888eb6cdaa2d5c8a0d7eb81788aac3dac8a082a2544b696dced95aba0a06afc5fc4856e9f34c5f5ef4596fcedc32c86b3acf2783add07b06158e1711b8e4a85edddecc35d45e0f3318a15d90a7a2e153d3d1f33406fdebe46b30a6d3c09ae81c070d87b32b980f5c73396596798a9cd59bf35f3c2552ae2b34a13ccc2f3cf7b94718c401238e07257a215f7eaf59779e55da442d03bd5ddf99a8ca63a92e3a8dc8b74a066374b89b8ce8bbe9210f5eb5641ccce47624eef16e4d2aaf702fc8d7c7e4b4c690a27df5765aaa547a3989018a0880b37a1800b80a88704ee93a2074e96453bea9071cf2eee0e3d19d8fa61a23199b2030d5f7239a02cf897903dff4c234fb161da19c57c4667f1efc52285e47ba668eccb38abd6540ae7d274afd840e39c19415c7498f0ee1f86864b6d830a11b7b125e4aca6d62c397b980144c4570acf6adfded28f18ab0b753dcf31355c5d6700c19f75f8fc02b9810f35d462079854c49a910bd3918038397480937707f1fc3416e706fbb88e18d98c6ccbf37215b44d01a0cf197a5549a67179b618060bd607d40dc7404c9381c6a7732497a0b1db5c78b6bf47f69abb2fe92bd29bf88a233fa8a1469864d1a2824e7a9a479affddfad9b235b1e7627aafebffac01bae3317d70a4b928d3c5b740b85a851212dc23d6e5bd8069561b07398e2fb7fd0684251f0128bad8cf53e3453b478be3b58a1bc36b40df1f19cf48b75b96b5c35482bd7f85303e26e1c96ea0739512caf978ee033e19bdb0cbe65a70d58f680ada64c7af49a12f2912edb7391e7bc9a04a6768c9ea39852b5ea79b599dbf83f23ed346a1aa961b2f512ae6a463ef52d95739a7b0014edd76c6337d0d8a70e2de8282db83bfff4170bc07a25df60d36b8481d6b96a3949a05a521c32545725c49e67b1fc64893ddaef8b8c7c117030e0bbeed306622f3abbc1fa0b088484795d87ee656f9aca08c423ebeca475b8bbfb1bc03b02124de1f242d5d1702166d5bf64169461952060ad1caa6dfcd4e76054e519c39e1972be0e3d63d0f93ffe6560ea008f7d17a419fa9a07e68d6f22bebf1afbc6280d9d8e8114aa05200f7bff74a38519592b663c4cb465e366a43827113ddcff5c3633673a245faeb107be161ca4b81264ff75ec228560d651eff4633e948c8b5485978d46651f9226c5f3bf9034821be3e63d30cbd46dc2bf8128373de792874eb0d82a32265c89a5b923757dbd9b13b4cf0547707e4038723f562303181468f7ca7419b4e5b7d53bab3f61e282a497cc51f54463425bd9c45f7303befd1c95be3c61d5662ee138ec6515ce345420cdeda428f41cdb8c57b53097d33140729ea337901ab04cf6935fbd5602ed307fc1f819d087f60c29c3eada9a2a28bb4d31f9f7593dc36568ce72bdc00d08cd137864b0819a19ddab9780d0c31a8f5b0f6ff5591890a012c09f6d31b78f738e651b99b73b91318ba1881ddbafeb48ab2fa93ea7522a34b41f33fbc45dff09ff20f401118b08f5a8c6d3caf7e2cf01e7e5cfff225fe02f5c252da16881b3e321224bed40c6ca24e15a4d333fae01af438306c906cbaa9198bc0f6abb2c5896a9546bab780a0d7953d9aefbc9441f84cfa7d8fb8efb8097c0cb82f3a32094fbed294f995b2751a72fac95a083d905b36fff6ddfc403955e69ea6e1ece095d7759d80b8f369a63c95620993d17afdd2d5b0d5a9d87d21c4ccb44a3818df814c9cb5b5de11c17af5f6a0cf49fc25405a2322996057a4ad95e066a091aee16e98e0e82bc0ab290b0603a64f736885eb7f48b51277e37a0809fbf46e29c4faddd38ece0a7d1ff472b817ab0d5775112f1d0bf76c6f7908ad74a121e9c7a4017a24f0d5b306def09a5f781479365fb47302d5b2436fad3ed50e9e32d3d1a8b5b87ad61712c99e7f78e988525eb1bea9748caddf11bf946b5540063fe428d0e3a0d3beba627cec63a306a0cbf6bf70dc432fd7650eae55248cbb325b62e8925e8e60b4449aaa6205d9da71971e4abdf59cb565fa3d5adb6920c88dfb297d15d91e64a23155fa23d14cc01cfd41e69918205313e998ffae89718bc81cca40c660633cb96d0be16ae3c1baa075d2dd386f4f2a32fb95bfd0fb06cb960b67f1355637b45ae64720899817619e690b97e52680e436cc78e83a069346906489280f38a7c3a7e9e0c258b90e48de13aa688c6dcdb1ed5567ae659f7c4607000ef977bfc6c2129f0ba1a273b1ccdff6a1bb015a1ee60f133731cad152042336aab88e5372bf7fc10041bc656f88b74bceb4da56dc68e6ebe20f97170664e4ee9ba3dce6c0fe2f592baf23cb92b2a14b392fdda8406cd5ad076376c273ced6c3f9f5b3a0714bf40dc476583bf4a87d9c231e14b91fee4f83d2c1fcf03691dc82707df300ee211e0aff32b6867212525206f1996c0173f677e03cc2a3422ebfc9e2e9ea3fee85011f80fd404c78711235a4d7ef5a4eb66a0cc2ade18bbd36c2548b896698e5061ec9739413f3ba29ce3a7d1420ade420c48140c2f75bdcaacefb162d8902a232a27913aa42e890dff5e65ef40e041167cf64c413d12b7a94dad201ad3c273ad881c9409974a8ce1bd1860756e65be3d8fb43ab810df54f6251f50cf0a11495f56ef91d40946a17221e28991d3553c50d325c77875b94894f227023d99f0499dda384a91e37b52d6c32cd5dd74b8f0d345d06eb9e43f057bcc6e9d9882211ba7161e03aea15faddcfa8c94d884fa2c8462c300aa8e0b30386a4e67cd0fc910c170a874a02207185322297007ee202fa47ff5c4ecd32a6ac6704e3b999fcc30964d9665c8238f5738a564c96f7ef909f2e799da73f5b3142d0101f5f1a8ebb0dbb6590ddb2c8aae1a2df31aca8e7980f1dc85479fa64febe286dfdc758dccd0f2226807e764bcc69c14926fcba7dd07335a979e89fe341b85b8989bee55bc5e55f592998306f7a62c2c774ae342c26d3bf9f3de605038192aeb3f2da7d57c6adc2de3553944d3ea87b2e00a913d0e1b5faa917759891e6ab7bb20b22aa058521041711f11973e9b71b63e20012d46db27bece5306cce55769df1b5cc335de33f66f00a529fd2f0b8e3c50a5c5b333926a73d795d9373075942b28b5cb47bcd3886d7123b32c5fd27adb9a5389f95cbda29eb4097cb5272ed3e99bf4bdd97d6bd34fb0ea7b93fde3310721940802ccf2ee4789a6690893fd5da88d0f511e0d1253cf9cec8b4df3625a94bb8334494939497c05bd09ee1ae8b528996e3c7b9942117732ba2eac5403fa7e216a55ccc383c1935fb9883f795869e4a4052d078e393c34625b2b93ab9e85c3eeb72603dbd41f4f75b5e85feb67187a04de193583226930aef76822a0ce3181b60e07300ffe8f813169beb1960e9485c45e09534562a9fa2287e8f5c40c3e57b88b8343bf6089e5c04e8b62b6c81f99e0d36601dd9500e1aa39950b8e06599d35409fc7380feb88194f70b4de45ff39ddce00476382e8af01494931afa6e7846109a5a34d537e0a4fa2a3e9435265de15ac5f021a82b48ebfa0529616f1f0953be058c7b6889e9ef4b21a2ef0e7815b2bc2b17b403c13ae092dae47d38a0d6e4e009e5e951a6fe6bfdcff1407e791f55ef3c8fafc233031a2f833cc07e0e116e70fcccd4076743d87953baa89380e1b154ef40fc0e4a0b4f0b48e8662ab662a34ce2b3c51d901bf60b384225c23d7f516f1999b69d04960bf2d32938cc43f5dff118b2467f4c56844ed966bc2d16157ead85c96ce1737f8536abe0958b91735cfd6d40bd7cc68796a569a0510def3f4e8ca6e39f6ba378cae6a4fd12fa422a0d86ba37b329585e35f7295d87ed22574c1bfe07260c857bf775ccfa57a77f4685e9abfe3a09781b8361937af1aac825d37a45a312ce93f57f59b192997c0bf97bfa9a48a89eb4b5d4fd603e2b9597d530cc79195284f13c78d12d897eb076cf2ed9b51e005b756490362947b1a02d8f31e349cdb67cd26f2c0bee83a4f8548c2008b7ddddd8d7a293685b8596886d488b646135b885e087db3662e88aa4e1516372959896234223c7433269b8c0490119530de907d0d1237a8a50f232914aa822d8b2f72e84da365453180a2aa296a25bd855c0b8e256b109f3026e51d3427c24d3e45f423b71f752fc9be4c6731ac56031de47e3bcb94e0c8828d28220578e878488b88784786c9714040b20fb1d3813bd1d5b9130a208e89d40e466b8c325954cdd1131cb6357909d7fff8f6683bdf8a3b5c8925fb3c539f41a6e6ff1550f6fd4fe99c9972c7b930ccc7de564a19aea5ea16fff5b3893b8055d815e0dadbe9c78bd4587c8fa01e9a7776ffa80ece614b3eb01e467bfa2f5b1e7195ed8eb64d0d8c4146c658bb86c3c732e5eee74cac5a154d447fda41f3cf5f2c035335326910a9e41230952655b023c170e168369428a0efb901e0b4cac76e8b46aea6231c829f65ce1758c7e680644cc80bc71fe23b902366ccae952bf256329c51debc823ae657e9bb884f403e22534557f019b500c7ada6b3beb9fd20d712e62f3f01df04825016ad0f2d8d8a8635fd5af1d9ad020d80b3cff75a24912e91a4c47694bd0833c6ca27afd43502d1fa119a23236976abd20436c66c03c4b9540417c7ee0f695b49dc6a6630bb2d641e088353ee417106550e62bd597864158ddc36becaf6f102618bb8599f1d766f71379f8bd1ce8b9bc8f985d8c1b9d8f1814c53fb6db29294c5349a35aaf856f99a18abd97d12a2ce994bd1bdf840237871756f2b8b674f20ddd6df09da358f05bbac62cc2a6604dfaaf97431cc233c867b0e351b6388d9ce216571c32660315b1738a19968c6a14f747f910f247d17dc5f9cfcbd9c972cc230f16c4122a87cacc5ae4792167ed2577b19e3b6454001308fc87833ff7244b2b75c57279041bbdc124bfa41112df59fc3a6bdc72f6984c26531ed1c4be01062548223f0db923c5892f2fba7674ccce8b76191624c6073ff98b372c8a48f79a861eef889bab450977d02420c12a7d480b82dfd620e20ba230b054bda6497e142c708e422d1463bd96b1949183044c35e490f29bd08be8f8411951fcb608240aa9d69f355c731e4b3d587a1cf9ac3513f31caa1609f7da52e499f138c2f20c322118aee274cf1284b3e3cecc7f1cf7de4e1edbcd335245c293434186e2c6a02a4d3455080ef28125eaa1a75bd6a281341f609b7feade1b201a4e1bc69cbfb41ee3fbc3b7fe8dfe9db5c17b0950786de511be8f99e62ba1c0670336ec8f423d2dca4a3ffe7d056f8c17e4b05019aa03a60d4d7ae8a0c64837d581e6a03aa27f7beded2fee91d91310a71f6f6bcab96831c088e729970d301feeaf1197e64cfb604cd8395fdf8c7df4013a9e06740f09eca142622f56345a4402652df547b10a764caae798f60e56c0fd76c7cdf383a42f725caedbccc12e975efc31d89725b86f34f977579662e55a805b20b7aaeb0a97eeff18fc05df65098cc913ab16f6bac3dd377dae8441f6ec84164183a3693889d80e60e687af3b175c86ee2aa11d9b23e8e3a6515e0a6be754214e5c4d5576ecc660150adff0e392ab16c5bcbe05a0e91d0e6ec64f1ffc5db5f8dbc4047cc43261dce0a186d659ae001c136e9f2193c47e3b5b612d2c8b89b53762dfed825bb8b7957f5a9a6e10ab21639b8553e9ecb10d52ebc89963235a19ec802a72fe9a1e96e796e066e067336b6d39787a141d797dee72c07e82fdb943fa243bcfe53727e3ef0bce9313955d97299c30ed2a2453fe31946d7367c741579472224ed5ded2a10c84c4bb84a4151c7e64e7e553beaa55d798845a12eb0b03222321acf107fe86bf48f62cab6ce6b9adc93d4f1852717ad88913ee59e91b24779f4f0d2eb312d965d5e981a2515a585cfe25f79e164f1827f42d985313faf296531885c32fe95ea58a4789aa3228bf3b8b645770fb065534d5bd0b4adca644811c6533b855f6058231e93fdcce48204700cc1ead1385da45a2dc3142601792f9cbdbd1db4fa9d6b0c615c46132244fd7c3a85e1c9cd29ba922bfef2645fdbe3f7050711c43f91ae182d0387ee1b8b982ef372c2345fcf23245c45bbf2399242f1f64e682e94a8915fac03d62eef2ca8c2a9809cb080f2d5e6c1193a7cbecf85e6a563f1cdbd66ab587bfc58b18de83cc7887cdc29983b1e35b45b1ca15e638fcdace4728296adeab3c21c2d0caad398592f11ac7c8e1c5f2c7ee0c1a3c956e4135b3962fb05804f1b61bc905ebea278bb1342a2911dd747b1127bd73076bd49761bca45021dc4c063a32f8d347c5be5e418f5431289c97b344158518c49e7832c0eb253726e20a74a58b667afb550c05492544c9a836d0e310cd1a52302802921de49c9b6f426f6a598a8e51193d0c4f8ec2ea93f9bfda137a13e51e1fcb93e37e82d4af9876f8f9159fb45f241490a6ae380d5ca32ce2dcd3a4384ae315d32119cb6308758b132bf4681bc7bc544e05ba39995402d7afbc4383cf47c6ae0b82b9b0bfdc1f6023131ef964da74374bda2628f9187ff02e6f41b08be515d53a24d68db0e710516c52c9959a623fc2a38dae65fc3aebb07d5323f66a0d9fd5a96cb6078799cc897273c6bf8716ecbb2eccef01f79999c365652577f3a16c39c4836b569cb10603ab732f607029ce18dfc4b181f4f51c1f658a58171bc51f0f1fb0857c1af3cdf12c6247c23f36d30acf0f62380e97e1fadb541d9dc7e15cb1cb8d9bec89808005e3483bd2f8ef1fe5a583fb65cb2da9decb1fa60adaadb6c9eacb21788089ab11c1de9d4f7cd7cd90028c400e4c733bc671c0dea3ce19934a1f3d7f1f95d308a28c56374a590df6a79d01361a66caf23b6e9416e0e06d16b36e19acf445177b1a8dc7715b9df580035209f7e0024b93e5dbd26d04b5e793a03f7a2f6269e2c3acd0dba4f03da3631deacd7e18fa648cf0cde01fbbd35862eb41b9ccd55da75eb2506c8be6aefb5b9d4d059451c14775483e1665809a4df9b8eaa70b6ad3bf51e92bde30bd98bf5307122a1291af386a3d11f8405faa5e65324b6549a08f5697f4da2dea7271e00b778cf8e7d730247996c36e9b7492c291cb25a5b3ec366d3636b15763ee945282a70ef038186b3ee7f807ab449ec35b94fda0b07a0c9d998e628bd1ac581b7d28affcf3ac7982abd30c8e8ef93b94e29e1bf872c28e13bae1c42ec424994b5377a5c9858ccdf33212976a3cf9f39ae326135f5fd356b5b81ea02c0c5d506477a7d1f1a2ef062e4bf101f22aa4b990a3fd6043927ba3cccc2b01539a7dde276c63fb1f7a2a2cfb3d890964b01bc027ce11c6088001e42c54d7f917a95ac550677adf351ac10fc4ab0363e9657bf8a0ff92404ce375c936d6e1afa412e75fcd135f7e27f46fa59e254eb18690b11796962ad4e09eea07216143669e1d8cf373603b6a00fbf4862106b293c8ec67ea48e87fb8521ceeb8794eafb220ab3c92889363e836178e49fbc0d78810274a3b088a030ee229533bf52c4f3fb7751675ac1375179b305d12778ada82717f624e007461c91c06c3c6b6c1e0b626648ebcb787cb4f2c46d0c0518920ab6d615ebec66e95cb72fadbfdb72c0d2f0f7dbee1803698d2bd364be963362662ed72a8a2a7e06741d22ee010499e2f7389ab101a9582bb2c07e7fef101545c494e6f3d871e394c6b28145b1ef4e6d3d24b205e893746147e3a826721bab0ef69f31425ad2f7480ee72dc96ff4f227705c6ea9b77582ba3c2b26046d3f67b92260c56f4f396d831f5ff7c2905c3a69034ec1496007711abbf1a3f88b2c96892240480c5eda2335c7c1246a1791f43ac286c949cf2457bc942b52364d400ac152a813d002d946ade665d4932b439147c76a63b7f51043a791dc932dbc9261afa3198addddf94d547d861b16255940568c31ce0537f09e7f09f1d39c4d132765b43796842e9198e5daacaf0ee2539b347cb2187504d4ed83a097ab531feadf59e40f41446f87f7bc6b78d6335b74e983affa82e9441b6e6ee53639e6398bf960462d308b1dafe5269890890c129f07d97313ad4ce3579a1cf979ae256656776b5a298dcf5b8b6ad8f1f49144dfb2beb49dbd2c5b4ad7fd5779356ccff9da2d26ebf91fdedf3f5d149b321882fd65419338db32a3542bb654dac87b3022fed82ea69eb44ebccac367510f57026034d3211596ff50e5d1ed55f02a0f22bd11cb4b8f08983ae86c75d3709f42b882150d7a2e63a639316d8e1f2895898ae1d988546294822d213359a9287c060530a686632ea6addcd9eb9b51fe959d13b7e349e01a8398c4bc138095092af81486309d239f324f1231c64b510ef3cd5739858737dbb35c68673661b97461c0d5825366e171fda7616e75db697f2c1392b66a2eb1b86bc1b996db37cea40901c98a8824447b7ef89580aad0927c9391033f149a549422dc5cac0d2680e6a7cb7742507624194d11f5061a9a701147b9a4b57fbf8651c043b6326edc2744093320c99a250b3684328d79d25133dd2cabd62a0711d3db59f6aa3d700178ed9347c83f91190ad362cbbb8fd48d624f1b38f4279fefc2e3137e894484fc94f4afc0cdf05a8124d0973f550815038bf16c5fd2b5e9b2ed756fffbad167edb896a99b8c0516658e2ca8a980ef886293eb7b6be875c6debf2235cd315057e1ad9ddc203537c2fc86adfc6e1f570d4bc12fc546c6a7b1dcdb7e00193768f2c2e6fd78ef903d09ff73a3cda39621c2c5b82f196cf4e12f24b26ec39c80ccefe3118b558530586198b1be7d94d49f947b74dd5c4b282dec78951b26986e6df9933241d84a572b2e5c4df26f72a5afbe24f0efb4cdf4c7908d1bf999eae4b20bacca01487d49cc0968dc461aadba57615feb376cca2a7e119408bf6c35e8711a1b3a6185901b2ddfe20eeaf42ccd38b245d859ef7a990885508b1b999216ff80f790f90f0deccce625e876084aa1ed6618a5510a8d7e1b99341be66f8b14326b49dcc4a4b16e3a4926847bef5b7f674113efa354340c903a35e141666355e4e091be1e6513cede76874600d487635b8052b4d6f8c27dd3870b607e83c3fca997a4b966289257a7f952419413b0229fbbc42fea592829b08b10b158e56b1d7800003a6aff0dc244c668f3d0c57037cc00df93c20c7813287326bcbb11e496294e1c0eb1b0f12881d1d15d19cc4e6b06b177e04ad3d8206ddcb38debbda5f8bdfa89588ea3bebef195685c0ce020b34ee736cb452b9af59694af99e6ae4cc0882e2a0feeacc042f2f5ed4ba648784342b5d5922aa8652c06b56c9c0d1efce08da5c46b137969bc99e83a3861b1068ace091662e8356370fcae9b375f944e61a86e4b3be524ae6f5e3206831d14e7586070e1d63c136fbb61e8340fb0fc989545a2df53e4f7aafbcefc5e567e519d38516751b29e9f613f56492d90ea1b91fe0aebd2ce5b2d773c34151bae2c3a843ff63dcfc5fba9f2e2e5416c94e7e1187f8dd2d1c0490bfef63163c9e7c1ee769f33c62780ca6a8beac1e358c8533cacd3df8d844ef5ecdfdef07073246871a33dbe6b6180df49ed7f20b98bc6320748a9889af3bcc80b82a6b3737812fe4017878d0f0ea7c085826a6bd65aa5c7cade08a0c12455a4a654074c62ce5697ae38e8488df7458fdaed0cdac96c7a6e828bea9e71dee3fe686e9f410ceea9c7c870646dc0ef2ed4965b0650c9a861ad234aff6d0718a691d229cd58ad7cb6e7c10d59d68d1858d3410725808f7d769f3ecb0982ff14998d99dec8fa24b0632967fe40ce0304b75518b68512e205ed14d789b4895d0323033dd53fe154eac8c04cc88a27c56c9fd4ad9ccbda087e6372652d4843747cd0a1e5fe910353af2d69490bc93de98575b80ac7d7bc070581e437cedaf872ebba63611e97c093df6a1342c007668bb4e37998c980710bd92f4bb7d349631a65ac6df7dd744a4035dd794b824d4c7f3357c9f426e2dae55f4b9cb3c2e1d031c175c370453af79c7bb9298175bca9c00caeeb9f7c9efdc098996b40df81438d90dbec0c53c44eb47146f1ab4c71419b0bf8e4a91ad508323e947b9bb72608c48265c7e921a3fb0721ca2e081862fdde99aa016cd32bde9d0ea9f86630e7e3ec9c51958c76e1898bc8a65437792ca225106a10bcaab3f39b2ab200a6f5e135e9178cd5030c155f8f581ae0ca4ea07824fe756da5432fede59f2d3595b36bce7558ead9f0e1e748e7de7342e441699724c5d420f03df29b86d11f62b5eb8258a10dd505b6ce3e77951e25e4265be6d64550ae6f75e2c1667043cc65c4cce257eb0a9be1df96346f5841a0f4c99ea8f1dc31b736ecb0132b4f258335f0fe48b176371f4f01ffbfdae4607de90f4da084f4455c367fdafe41dc47536c6f7fb697f77216b36eba896eaf3a671bde952b9fe7306aa04ccc056524bb11602baf3ed01de10be4ecd7adf93b218dc2208d33a721e2cd268320a4fa3d56a781fe4a701053c52575e09bd7245b281e68f76aaa1a99ef12621b4ce92eafeb718ec2185e0c740001f7213dc2ec0813247a714486597c5cac4fb7ce366e207f3a7c70f07c47db252eedb73b72b99608256bc27124c69bdf9f8305148d8258fd0d40547ef88a9398800c5eeb165d80b5daa7f5a3bc573348f704b3d78c8a5a6c7b5d9e1c86a73d7ca74f4627ba03e3ca077c8bfb771e736e62e82dff3774d4a2edf01b643ebc59180d3c7e71a567f9bd40d88cb8c31c073984009b8c9f503617913f2dfa1a96fea66b2e2c3e2f783e5e42d3d8c7a3e069bd0f05681c2f7d50cf55040bcf9a6d224fc732527afb000c8a93a2d238d8adda26f44afa807f3a13e23f212380945aeccdf368c8f62a4b3cbe75a49b4fd56fe110b3c1b8af434a61e86267ae9c19bb64ac85afbc21b76de6ae011ce8bf506c49fae18db26385b8e2a34996e4e4666bfb95672605bb82a013aab118b9183e3564198b52cc554c486fa18111f8a50c68a5326f409c73261335299c3e629d4441936e2395df0beed7bb0913860b1116566e0369a8ac773cf9c08bb223c478c2f20430f4b44bf69bb67d52db929cf672ce35f0f7854220fc3b98e353b1b04f7b781e374555d26ace581bd67400ca8376f1f6fb4a7eddee784202d5d805150a225bb4887cc18f21f0784650c3182ae4de302db3c191352b942c5e987780659664d6787d7ab3c15affe8a3d3b57defcbbf18a30c7508e21e46d8318b590fa20e3ce85dcf9be32b88fdb0b683ad06bfa246b241611a5af1c8d296753775cf742cfb1f43a48561f5e2b027708ef242ad0d9eb823fe051da2e50d6fee3f36bcb349f2e4856675c05d3dd6b612d4b6c9a21f27328bbf06e72617dbef2b03e88553fda87c77bedbde40c33c3ccf51e8418d2f985ef7aa04c94eaeac9723fb1dda31ae72304c29aed944b9f725a8635747ecfd109ec05650b837ba71af8d3976f3d648a2c73bacb5752611ceb30304cdea880a522a8a2b0f9ab94e270e138ac73fa0fadc6106fad726746edd3997415511a2a985e65538bc76b4d5ece8721feb5a6b57b68a7320749c986c213dfc762ff3d46abbc0c9af807b8292c7ee47163606b54ee21a6a8d31e900d375fe1eca3c3911c44e95076f7b697a1b67d9f549373c1672671465c01cd3d328cf296822824c154db667e1e89166506f51939393a079a388e6d22c0236653a53f8405a58a0e2a55a6277b332fa81bec48f864b5522b756ef974b8f23d473cf9d954b13a3c10efa9237b6ad5dd204983fb5f4d3c1a344ca801805a8a3fd893945751433426aeed39b3e5f0432044094c68e9bb6b22fc469a7a8ce7957958a6fa24227ce464c0ebfe2af2f4dc14ebfbbe04b76afd2cb3ffa776c3277c051f72e1d14f043f4ef6c19615d309991279406f3fc9f122bc56a5d30a62ee0d6e18dcd5e3a74d81409268002fa1a05b58c36d32ca9f7e381157df7b07637848d13e0aca661e5a9f8b32dc287d9ae4377f90a5a3ea3b6659d1cdec603535ae8d22ab896cd6a3276b3925c6cf6bf2430e1b5a2e7eaf717278dde185f79e3e1e657422580d1204bf59b223e5df371c1d209dcc4b15bddaba4c02657c9587196373ca3e7c67174f23f86c697f73cc04361ce69685b0be80a272f7afd540eb30c5575a9f574155b277ce339b52bc8ce0eee325be8e132c2bbdb67d9fd53feb623a75210182d554431e085d81b7ca8df82b4a0424a32fe0f9ea951a0cd97660be71ab9301a6c437f7017b86e19413c2eb7c6a3b374972d4c130b51d38f4635e814823c4b5aafe4b90e792fbdebd902e2f2a852975ff39d1b512c33e5578e0b953248a3185ed465f98ed6fbfbafc39fa612933c1b7b5150c8b9a185296e20532950affe8c7550717472151b80c413e6ea85f3a41784846b13bc5a3ce78b801e5af5f22e0e6ff8361eb8165f9d15592e5ed9cff2d239601c68e11d1d93504c25efa0dd8efd24d5914f038279bd50a59d0784a27a8951133af71295b85d76ff34d7fa552e2aa51e8214dcd73725af34c1b3c3129944b18f004093a2e70746eb36a04d0ab2f07ea79b34d2696aaf1cc3738c868c5fe3559069acfa28c3570b6e846f6c39bbf02a88fc85cf4f30f147d645e37a366f83674601e792d95db8c367775af5238b6b853341196e0fd74f3892595d220a564b5c7d7d5ae4174b40609141b4ebf1cc234f65a815b32e5d9f24cfd370939520924a6b1e37b92aa3a02aebbac37cbdf64fa9e85930d6a0aae74e27d01dd52c468fc636acf86436a1812b66fd426ee483eddabfd3c2d428158048fe420b1a3650b82b3496ca1214f8cf8421e2df1f6e6f74ed87d309cb00db7c90614864e352b9418faac1db67533334187ce87957f2ac861114d49386cfbb9bc375c56971030816f219609c788b70af1344558c229d4d8b64ff0ca39123f11d62aa83ecbe02ad848b4acea19991d5ba868f9f1e307e939b3088ee3486aef0cb53f5b5ccd71b667e64c83515778a47b498281f5164bb4cb1bb575ed42c1af63ccd0b7d10842cb641ec2f9409ea9297dfb40b9031c7d1156be25b1ecd39eeef981b4c544730e125c79a7788aebd6e809ccec89e0e982d97cceeadcd542c1fec328508dcf7267b79be9a5b543a815ff402d3be42323f4665762d426f273996a3931a1f20d12baf302f57793286200761e260b48d06fc8d7093ac2ff4fadec80ae73ff4b7fc7dc8c502f8907a4d87ebe8236086a1a586a6c7e03eaa55f5ba724b5fb3dbce8f9786730c12369749e7051da803d0be45801d7d50f2aed1f9f7e2d0e136bc21d00cb76b7127863fbe9f037b8b4a366628fec55b3bcb737b98ab67750cdb53139504b0bd4897974f3d517766a620fcf9443e518b439237aa2647f3f31cdeacb2e1da32666e02808f0df92eba82eaeec127ed9829e29a5d3f51d1193c86ad7c5927c806ebae571c74c6ba768550c02fdee5939ab225d520e26da784c649d4da3f91a7d7a6c35684b0a78298a0639c6b89641b2fac1f9eec7019bf1c32c315bd18895b290633f5d19a25a1f6bef4bc7a9e154d78a2818e021cbe22f6d8b056959a83b62094ded8a319c0fe2a8ba4cf30cb4eb9b90774e29add9089f4b78129ed34f700839b6e5ae81ca8f72246ea0704b54e2edf38008776520ad38ae638bddfa83dfc1d1d621d93136e647012c59f6a74f814df196612c72c7e13fb8468ffcaa5c6518bb207493afeda9d7817ac538ca469c536005cd7654584504652ab5261f20198fd1365d021ff82dd7e0c6460e95ab22ac7ad897f0ba6cf8ec3794dce74b97061ddb5206ee34c1546e19d5d5c27a4d99ee1afb53647130c2b003626d38e4a5af5cbd20d10b1dc0397cafe44e1d1737f151485a375b38a190cac2ae33c18ecc4f4bb43154d3909477dd6307d74f7ab2f6bcc3aee2ea05d4a63e0130d35b8ddb84ae12f43ce7d2b7979335488063ec2691c3469f6196c6b55a64d99a2d0975efb26611b3b46a9dbc6ca40807a07789c4822cfa31d864487d3b26d202fd6c1ab5ca46a29c48a259d7d0665c8bd8759ec0e2d7777217d979e3341da59c35b1505feca2a2d420f00a372047b2a5869641f9333221e4f9497ef6487ae4b8a56b76055ada5e61af7eec9e7e2c2f9f9ba70a5d3087d81c7ea8d9a485454745dd497542578e81b08b51b2e7d99652f10cda3ab5f7b8bbf36d457aa532dced83f11daf56415840d5a329e382e111572c68464764d7959aa0ef381dba04936122312165563e36f21986c5935e1c4d60367d17ad51da38e75b4afd35f7601d62ca5775865217f709042aa2137629405855551ee2457626290fc3c702fb49767da11bd9b029e2d8bed321c4191bda20c35a26462e7a3f3e84b5dd6b17f2a31e00e9a98df81cc5ad20c842e042a8784bf1ce6ff4c707bf1634962472bcf013f2af309e304ace8e9d072d30767dbcff07d6850b8ab5d0577b158d316b24f8b01411473f6b99f2fb1ec650fddacb1cb74dc3087a88c10fae997f3c160cc4c9936675fab7a4c03587b1d8a7dd4a3f7e6cc60133cf32c0d1e41f23a5aeb9d5422e8309360a738bfd894331ba4848679c198c75a90cdd55805dbadd5d4e2a779e8ceec0cae761ff1ff01c9ce38708e5df0a2cba2120bd16f8fd67c00c9d28496949c728e04ab89842caec01205d0f125ff261e2d740469159f8b8287243f965aa589ceeb1e1b980e69626c660d792dfce40da49e36b4b833dd2c5d36e79eb98143c2ace1b0f392f05c9fa0a80aec3a9f31a6c2c774d5d8c2e42fcf2518f37f3fe7b02dec27ac9b1a802917432ec35b592c9c5275e0ce58dd48071ff7d81e8e4d21fd1ea3550296d31be7e171d6d6d1179e07fa2e80c2f3fcfc06552616f06dda680bd714cd14d290631abbc9c72f7338b3bda293e06b30a800ed4ef13f42f484d9803de3537a33348596596e2fc6ec39330708cda8312dfdff5d7c117430be8a625794bf562727071edbad9d98418afed5efbea2448ea5f16a1aaa824bfb42f86285d5983434d74c8fcd0c70e24d08a68285f1decf3420acc9dc53c2f389b1f8fe233aafa70c21ab6f4fb981a505f56057e48d824bd426238c6c9e5d11dbcbdb986e9c7ce595bb93e1f951163eeed62447d501d7b9e860eee07bcec681979324830660cad9074d16dde0d3b268f6ccd5abf64c5fbd754aede5b0ee6c61553c34822a2c765b4dfb7f96a04bb517c881e2906593b364aec6f7270206b1da9a1f9cac7509335a67a4e9511a81a914f3949cf790725d552d79142435a434dc60751bebdaeecba5f6de887c0ed58276ee6726879fcb1cc8d71be7bc2c40da9a70e671c20e670779a947dacba891f7414f5c1a3682a36d23840f4ce691ba193c88daad1743b3830830e01d3eec13e75534308fa612276e3c8a712b8eb042126584af7eef7e5aec31e66066dc7346f03a440187516a77540e9b9668bf8c2ab267e8ee892fdfff6bec785a4c843fffbf7395bcce5bccd1807bd8c3623399aed00f636fe2e13b4d354de9fe89ac92063d2c5ec0f74d90d3ba7f2daca4712a5de5ed5a5950aa226ae1532b0564dd6fee89ae44647beeba6d1bae41d7b6f5b24fb3a754a8ee471eb99ae1aa6172157d2c038ea97cc518d1a241a3923850e7de8ab9b4fcaf89fd7fd669424c50786aada28f7ed9ea62d2aefbfaa01aa88ca041b1b67768c92cb9c972e543c6e9a4b547142066287c287550e8afac877ed0a4441eea8c4aa74f5c35c353b9ff565e4369f100e31a991878ac52f69f53c8d024d19f83a5bd31b1b0ad902eb60533bca7828bbd98c13db6a495fad854b0e0245a4e0c6298e73c3539c95e92bb4403343b0b1dc1eb03c859f4878594ed58b1e9d3daafcfec658e5598bcfed9ab5c6268a6ceb3f7460dc48193db0b1fa90fc1d94c40c0e7c1f5cbc7883842e7bf4284526a03f44f22040c4f424e6a81e3a3c2741efd563ee5d40c6c2c740dde1a1566fbb055f86ce1d7e35368e5b019105ac38c8293caf66e3df62b1603f16252743f118d974a2ae7ed1004555e97871983e7b46e34dd6489651c7f57cf6e689831e4fdcd7303aae329da4e2096d53f54ae39654d7c8b6b6c904b5a189dd0ecd60d027d709e79ba4eae21e72ee6897e63ff73948c4f463a436b004748fd2dac57b644f3fbca22b2f1a728afad2e593a0fc612180383a8ce578f2b372b77323147bbe3e36582098207a4058776e43f625e2eb10f7abd449ffa3aa23787ab41820892dfa9dfbd7f5ba73112becb00a1f3de69ec200cec4b57f4343599b473517690db297b02c8e42936708a6126e45b439461cbe0ca6ba2393b1421e542d1f294a965f968735b03d3bbe70ef205cb3a146254930ad685ed2948ef763753e004ec58a33f7f2f3e2b497904b72f4ba3d60f7f0cf4b06ad0d9b2d556b8460ff750e6aea1c6ca76b4dde17cfe7161629fcceb4b6c892b7009e758c74ee798c2820b56c3f5b85ba1dca1127162452a6d258f957096b524fa143e0b9dd31c7f19e4de9eea17bb38a8912b682ec8c95bfcc60e50d1c75dbec230a062ef98eed9c8e1edc901ae28905d53d54cf058fd91e80a7ba7e15af8416b415552bba3d39c33c468d7600ee516f01a5a72fee4a3ce014362d44d9192b535501b1408245812a41404272fffc1017efd70eec47503b5906c5fec58e652886a36cf380354040c5a51dca58d2e9b8b6873d8f142192ef51edac98c79cca0ef3f24a8b852dfd014a3e5ea11d0a2b0732e1c06c3d66b40ffbb0b7bcfabedcf1582a5feb6f71ff8db7167c31694c3f0bb9992a7810e945ba74b4e69390ccb7d3c21ce7ceb2761e16d27b53ac62738c6d90e805b8f12b93884367a4a5597d77db0fc4a640b2c9aa2572829d192f913a1fc17c7e5eceb6706ec5f2094fd13e08d3f41bb80dd7d6762bff3e82e67b5edea7a04e28d540475085f74a004587dab838a28f48830d8b726cbc29e6145135352053bd8cb5937ae7ee4de97e459b2da782dfd516549b6e0210d0711b520c251c32d367b54ab55ca9387579f08e8c454f5071bc1c99159d24727e067d500be9c3a5e86d05f4aadbec04239d27a95d7c726217f92dfa222c876cc7f5810c39061c3473c6e96c03550ed727005b34445ead62046180e93fcdfbff16f7e94dbb31c1c1f0abd326d44307b59337dac8cc4d2b3388b3a70d2cde79bcb5366ec8add77c07ed956b8e40f37d2778bfa8f46a9217ad6693ba936","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
