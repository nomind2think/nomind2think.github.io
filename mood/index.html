<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9814046b19c07bcaffe3e5719cb5bc7fe04a73f07486a0b08c8e16097a580ae55526d134f0c7149e79a6ba408b54edb7427f6854dc8a976de96a6388264661cdb0f0a160892cd916047fb52442767484e44ee102acad769b498ae7ba46c83edce39b25b754ac36f4c82fc87a39c89bfc59ef4da4d313b073d4e066399a8436b3762aeba1c783a333ab15377618dfc82c0cb66053569e3c0733191f2e5261bd79d7c74f0f1d0e12ebc4f2e6861cdc59ba2c43e3c0e8c8e182049209a2bf9c30d2b0fc287d138715fe59e19ab8be167287ca70f174e8dc04d54479899d1a6024703eed153f261bd5a8a63ff404516874032867b4453640a1153067b1fbd1fd92daea638e07922abc9acc0ceba5aa4b0679aa314d427df3788a52c5ef173db1c5ce341cde5ce2df843d04b6a5b346d1eac13b17f59de19de208a64ecf34cada46a4ef9293ff4dcf6b3bc0ba9ec5a8f25339e224e839ee942666326c0665b035a4077c3e8dc7e2d8f93055da4a1246cf5ddd03d2abe461f3aafa7b06ce9fec2fe3287352366023511b32491ec1d6fcfc486a4bf94fcf54c03c8acae2409fef59ad7b8b131f16b341b9f3d63ae5f8e16589681b2395e521ab0e4adb2af3c50b3678185473ca9c1fc201af6b654bba48c73d3118d7f15e2e207866f3528b0df89f3a4b43e156990c49b59580d045517fb09d9fd91e2251cf639455e30dbbacf6ff41fa34879e5d5784004b8d300c41aafcbfb1ce7c1136d971d129e3ed49d0e59d67d64b35d2a1257f83334f5f20c7814fab571be0acc9b0a8b1269a4f8c968b3e9d89f99f7c04abbf7714ccbd76775f3dacbcf46c3daab247835160f8e076360585e4b9de27472771bfad1ad4db7cd6f531f4a2f2bb9e3ebd3b906c58bc565994aebb19df2900d1e6feef26278df4550fb43b77151976b4749d81918b159bb2c8756be6cd8acaa0bb732683456bbd6423206489e32e6af7c887ec6b61d1515df77770e519e54c25c84e1cba17abf7d886f3c4d982a63710eb8d0a2dbfc7635c1e4e19d7614126b2f62ac5934b35fbf411ec03d198f78b6e7d2708a3ddb5809c140a3247d70eb54a98dbe88806b3765b53e21039129ac174ae7b2c81761197bf450dc19dc5526d1a15514f3f5faf150eb209dbbe56cd7053af69f48f2663ba3c22fd5405eadae2d7819cf1eaed431af439bc2325da1583ae3c43d7a8fa0f28c485deb2fe57198c24beddda311adb1aebbafaac0f6c8963c72588ba1cecf93244c5d1011a0fd5087c1daa31d940a8bb0fbc7a569ebd7f378b5805bcf277ece49548c6ef2eac63f59d3f9df4088e6afbca74028f4131a7961b4d60a90c386f0e756a18904152d8c472f6f4dfee236e381191f64db6c091004c59223395924fab48b03b1e46657a2e6b4c2d530f863f9f546e7b06ae8dccdab9d42b0f2255eb3c74f4051351c41fe996ea265c4ea287f550dc34d2f2cc954004c63dc0a8de1307e280288dc2766a7c6ed971845d0f20c1612ed71267ba8534ebcfccc11b06f1d5b0b2125694d0197804937ad975088061569aee883edfa413ea9440bde2e9038bdf796d17f480c06eb06811e6a3dda5b0d7d4df47dcdd323df001ab27d65f33085dc2ac39dda6643a557664bac7b3901121fd871bc90a6c3e2f1a2b36102357a42010c8b4ae85d7ad0de4181bfa69578284d3ff39afffb15e80d8fbbe813c9b4cf78248df724a4765cad83627d186c8ca06015dd337be95b16225059ae655f3f5548ec362b5214e8d44a8270412c5f299c8526bb3a0b49da4fadd866516f709858658c8296ead210abfe633a727062d107b66cc89689be5c64e3fb357a52d184b793420f9cb52c0c0e3c21f12e5c7526a3ce192b930fff3ccb3275a21b069111fbde668afa2162982ac1cdaa031d73235f6fd22da8710a0e6c8df8d5bb746b4e6c3e990839324fb6ef04fad5c3ee1246530f923da94a6d866c7e5ec62f80ac31b43b366367ee2daf81ae2b82b08368b3a8f0938cee00ddf4bcc627073891bfc26166a4e96a4bde820aa9e7ee3aa702733b34ea72b24c98334777a516a7dec807ca2547aa57cc139b519473b8fae6929e45c19c23c96e79b368167af1a718df4541789cd2771f1d804545f94dd4796c7a5c166a416cd8f4b639b74b83d8e3ee0ed58bc60601a12afd057e26676627c0c9c31e5725aa17338a2291d30e2431c8329477c811f5eb716465c273acd199e2f8db441b2dded698a2c1ec207c795d949f1058c15f3bb8dd51f5372f3be6540447070504e857d381ced5c3c865a84464d0ca5218aaee21044f71503b473185a2e7b58512db13612080ad73e0693dda104f240a63d5fcf3284cc47abbe91dabb616405bd9780d932dd33036b939fbc59e400ddd88537dfed2549a2fe242c5663c818ec4e4a0858cb8d55e413b68cf7beb88b6804f90ffae2226541164e0c52358f9d811bcffcffa2f42e7030e506ccb7852b04539972d5c655819ffb51aad7862cfcee0ec2855115cd4f2f904c5e38dbfa2ebdec8a9c0249346734bc076e5c453b0e24305e1821584bb44799cecfccdc64172da97a7e827e787de9a4a2f542b5688585850ea078ec69b20496a956e3b5d090dd93d335a1fb86a12a46a792fa379b69a997279c39659ef2ac729e33edc49ef73796af3e4aaaf728fc7aaeb7e0d25715136cb246ccd21ef98255a6293e890abb2d513d3ae98c1b8c40732430cd0fbe27f64347925e536f51f811e37d575aac92c30fce667715654906c8ce08c4accf806d7ff36a87ecc24dfdb169bd40188481eed8c3903fe85c92636999e8ccae46739a09628a76857c7e101a54df059ca54d862de7ff959c99454c3ef1d4c531c19e514d0cfb96b02d0ca1bac5166685061c3e88a31711b6cb6fbb466bfa4114833a185c0db560ee88aa0d73cd41772cac3b1a46283b74807a1b5fd5c194ea2493f7171d7509eb5c1caaaf45ef7690185f042cb7644db1f8ad4df472556d2799d2597f6cf1b9ffb0c467a5ad2c62fdab95f2aaafe1cc5e199a7adb399a8058c361ec266dd777c01c5e1fdcb077e2863a9a5812faf240b4e703f8d20701873f91bd6e2fa924e4c7e22252d494af4c647a5d3a1bcf72f234b23a47e867f84da121549d4e48efe6b17294b0369eb956365287bd2ba08871f8e2956fd7ad13cee385b9780f27974bc4180f236ddb53dfa0baffee7fba24b26b59ad9d4ddeb2c91a27f243a5e0f22c0d7839782bc8c2c7c93f539fea63c42b3df9fd089001c94ef068dc90e7f2229027bd16b1b2851b3741ba8f200e54f12c3d0808873acba7306d7931960902e828b272ac99225e29a34e44627a9584f5058095f113de4b58d469525faf418b62020e7ca8787361a0136a0e236c2a5a503b7cc79dd3a197b669942877cba3246a7c579f01ea429a144f96b956d5fde1a8ea1a3fe07d483781962f3a583ca6da311f5558520e74978c364c3eebd27cceeffa78c8d0ff877b5718a16817a7be1daaaa47601ab70dd9146790d7950ebf722c07d735b103c9e7837161ca6ffc18b57a9c227662ab96220a2bc62048da76ef36d9d32a756d90200489e4f083c4ff4612dc1a7115948aa1d563e8d181120a3a18ffe2c8df679058e5be03f72c71a3412a8a4ccc0857750a49edd669d40c235b20e333bc49dcef2adcfdf01bee363c52a214c6f39e2a7ec05c55de86eaa7184a17e18e57ad2e09c962f9ec12857b870f2a07fb7d09df06c4bd511c8438c8d433d78317a437032b407c03f0220b1f9c177f9942078e437c72951e11ef68eebf941b784932c74f741f851512b7b6788f2fd5a7d72b97bcfc0cc3c484cd7993b5140380862851be5adfa43946e8a53636d0c34c64c23ec4a06c024c0921cdc84d2b105e57d7c267267dae171246d71645626c835abeb5e4c7d7446afc1cf5325c118515d522a82459cf5e20dbc5c0f4b0d9b7730e86da3db3a48fe4066dc368ab96a5cd3950ddfb5632ef07f3186d9cc4851d9ebac31facf8d3e2d8cbeb0c35884d542010daf946c160fbb35b1300eade74f38fcf2c0d95730eea6b18cdbadeda16957c95440d6f219a35cd1f2d311ad77b6275f61849421404c08b4e239e5d97d9ea4d533915452bfb2641112e2642f92ae7cfeff0f00c5720225d392060dabf187f572441718070a0d262d80fc3ba6120f99231a45e6e4af9991c46e10d130dd5f5d5e05a6ac8b5a085032751af5f1656b6e625134af5522ba870a85036f60de758daa912b587044da82bc9e20b5fc50c701af9d9571fd80c24f29fa3a3fcf4bb752cb08147c977f2b81f91f10921ebf936a89ece9f1318e66bd660319986921bc65362f6d17474ca54332b0477cc0e01713f63e1970f61f3d88245e8a40423d06e5f6d2ea7e7f1bf187caa01cdd07ed3b866b433c10010042def7a4b20a28e623c55c07804d9d63e5d10fa7bf7ca32ad365c066ee7137e80d9f76a3ea7750dbc663c8204df950fbd8f3e9d927ebc74a9ae3e94ac02c04e1804547c933b3f309648654b51435f4e4c3019d5684edb1ebf7ec90e63bc244123fd95d2be0832dbe7a5542ffcd7053f531f07ce1366ef2f22db6f2a376aeb799f108574bbc80e1f3d430ba7648f9c5c72d59e35ee22346289ff1a8d31d3a333a8103a7a9dcfea07d4731e48e6c688de2ac5ced034bccc303eaf049c29865b223bde03f7e08d1525e02eeac63b9f994a71895188b4296819bc85a695143899982d2ce18d5a2e72900b2fe722c002498e9ce4bc4d48e29917218a7a80929ca0d7247efac6d6c637fac1ac45fdb67d3afc3430df6ad7212667edcffe5ce67dc0e1d3b58f1647499242d8bb596c7da5b26b254948642d02a222a45a3648d0edd5728b27b48de2403e6fced57a75569c0188208d7f6ce41518155b8a62ec051420185e16cbd45fdf7e9de497796ba081ddf7800d9376fd8cdf9f3a8a6035eb90f9da9f7d1edc669bff8841507882f0779d5da431ff132720bfb8862de7d6c60ddce470b597fbf0cbfd40241692df6cff434765c56bc9bb9662cf61a7d20d95f4f0d9453c3801bbcfc2d6693de3ab7f920b465107dc870bb09dd7e6a3b1561eed217880d3942809536037572f8219515d46a91e496bf1c688ac3fea14bdb04f6e57c58023c7becaa32c319a8782d90c5d8dc95dfa9ffe1368dea6018fb95fce02389bad03b14d7cc36f49a39ba79751a7098f2f682b1e82648fb44908e1db3294ea814108528b16a05a4b8a123c72bb5ed2ee76b149fd023232c50a58531c1bb1faef3a56f69314460f7bcdaa9b9cedbf46940933d2023e8a093bd83479987c7759d04639fa8ba70abd498f62b35364b603f46aa39a7f7d606fdafea5e568d20d0e2ad016f5cae590e29002bf6f66db50c69c90ed0a31d02df617d05b2c7bf4a2b9fe2eb4280d7c46c128b02827c4c6f7e14e8ed8c886fc2ca6d6276cb62d177a32f082c5f09a9a336d61d84a2e9293fd3a4021fdf163f55d01f525b5ae7e9de87eca1e62556c805d72a89df2905bac92fadb15658c58efe43f39d7f78ae7f122bdf8b09a01b5bb83a30a93908901484de8f7c23e754905354a42ec2b8ab41e09d0cb1fd59be6862f7b6c3736bc6ef84ce997fff1aa4093f40be2913ba2e89fe452f2fa2c54c302d05c3ef15a07c17d63781e197d2e9ce18867d00293e79b53bf1af7eeb43d69693a1a1aad35d042c93a7d5e585e5373f4d6673ed0d9c8763c20ab455bdeb4065901495d132ae50bba183e4cdeb042fd501e4a4ca0bfa7a172eb6e83ff182dbbd3972c088ccd71d3933cbfafea61a274cf14c999ed34f3eb6af418d4acf64418ea6ae7d059c8ddcd2d32e44014867fad9f2c74773a47a7e29f18641f9029c8f763b86266ec4d9d3a5438a94e3b0535eeb8385f70b5b09f01f471cf849801f1afcc4209b40fd8afcb025d57b7925e94e46abff1b1c9a6b9d843e3f82e5b7f1d81d80e25adcc8ad782df679a6f8752d305948623473f149f9249396f6d8612e1739cf019dc39ecbccf1601415fd729fecf460f3f3d376ef7ae3a1368fb6eabf0b52bce454d1e5717eeea5a6bc5e9e1902294f3e65bb3d1786a404828dc9a7d44e7ec4c3e26d3b551bf89b09e3e5e29aa263b3f23eae037ac66aa180ff05aff0af730d55721f95dea6c0a3b5453b8baafa29c40fe3a1432945f0c44a83de122bee2d0b9c70646f6382fe73d68d8a93412f50f08a3d9af0f45b6adbf94062b7d5ada7b7764a2dd5872adf86d165f2c3d2bc06c3474b4dcbbf123707d61b3c378c51ad13ed227f99356830eb04a3a2378ac3cb765604fe28bd63865963aae38142b2bfd622617d38cbac836e3da3c4afe13e5fc2919a0998e223c837507cbe012226565a9e2334d7e7eaf9c3da8fed5e2dd51a54c03f3a397d5b7a2ab524cd6632b592e5d911c8d66283c798a257d03bd6c5236a8cb885d298a59133b72f8da18f1f0374a8dd482deafa687bc5f73a1322bfd03081d84ae3b6b60e64337f9ba8f04ff691bbd278a10d2697544df7170f1cf19a98f5ed0ec27579e2e12120ccee69d983cd8d7266571bd3d73514ddc44bda3d20bf772e581f79e31725dd1df434eedf87a08ed4afe11b596d5c3bc59b38e16d22104fb2bdcd4025a5e9313676b9179633d12653bc4c56afd4c56197d7333d8750a7e8a64ef56dc728d5306af158c6dce82db24639f76c8fa57f575a5eee2b227c17399ad1e211517fd981afa29b522118ebbab5b0ad23adcf0cb64028baab057c63a34b251238fa33b48afb1a0dac36c042831a4ea7ec878dc32d724b94ade6465306694e2df549eb0a6b5fe514da10fd409ef24fc247db2bb60e91710c74589ff36d9ebfc99d15c62626f120cb602c545430dd8af78600814f1f8a0f1906d2f22b088f51d2e9baef9e67f55ce1228a8b34d5abc114fda867e577c4c27f4bc9f7c037c5f3f967461c5cacbabb4d00d26269c4536db75f9120e397453da25b3b45b4d1a02ef6d4b94a11fa2298c6f304011331b990b06b3dda03948222808ee512f44fd5d66dbcafdf4dd8870c0f6b5ca16de0dcba767553a963d4bb6198e5eaff6b8e42840438abf7f9c77cab845ae5d62be845430c357596a4e99dd28d84aecad4420beb443a40d383466535caaba3a505a3a3beebf8dfec22f975f100091b466156b62877a274f463757d24424728b36f5e47a8e81d5ad3111e646762db08e69e7f441d141738327af5a839e926329951fd16c9e01ded1b592c09427362faa346e43d14077e5183dd28ab161f626a96b5bc9386d2cc2f0f4929bad1afc2bd296eeaa5ecc8d78c75f64fdb56f2c2308f08d50c690de594fdb7f5d5f6acc8d569318764f449b7765ffff1268ac5ed0c9ad53c3720327537b98bb0a7a6c9b876c692187845f3503e29c86aca07b2741355a64ffbe8eae3c21fcddd8ceef1c2fbbb828a5301efb9cae1e81b83df1766f86831335cf8c6201bf46414af80306d431fa6b5286ae1f1dd710be7f7aa6670923f05ce07329568966a4a465e940fbdb52830a012ef041977e4708d0909c5c12e7c660d5569c919d4736ecf1ca9e4fd5fffdb56dd121899433956a1338b5c4c17d3c8409fe7e0a9e27192fe9bf9428ebc7bb89ce12cf050863ed42c29d76a98b895dec472d2485232e892f1d52c76cb0dd3371d0c329778fbd859f6893143827aca3bb7b9cd7f60655b1756b64dc8303887b4ce3172aaed15672ce3fb7ef6d4c13700fb64c8770f2400baa0ab45769d6caf59318b428bd4e1f8b58d66ae39079be1fe6132c636f1d9d267291e750c33365b6abce7e38c9e8220934d1bbd6682e9ada9fd666acb3b66e1571555e71765ef531e285e008dd6062855e52d0be8866e8eb778928b95b3889db8932b1204e7b02d60b2aeca9d589f984de62fbac7a68001b5123eb410b92492ecab612475170958852e668aa28d7340cc632768dc3791ef5f38ea8b4c5d8b7146da4c82ec8d0118e6147e8400f95accedef98d5f9c6a0ff4e257e0ab619df5f1e85dfc25b399de80307e1d156516f388413556312a56d31722b838d60225266f50b7bf1451f8a9201eb5efe071a80a3e9109eeb9ca0eb36e29df61a16870301424fa761363515a1743bbfca50b45230d6ef9004105b3b432565875a5729917c26f522f7d23ca5438479be0a7934d5d4172679a9e53fd7c104add1982a3924604b2b1ed656bc8bb53610319b1052c86700851a7793cc8c498753aee11ef374b2677bf7c3d43b72188088bd47aa16b0fc19b6cb2ecfaaa204bc3d69f20a0909e405bfc80168560c968e9bd729302fb9524cb3f8c8df82a4ac561ef672f2775d0162ee04f3951c28d58c466490eb5fe866c9a10b2407f3f1a14aa8d18ab49b86ea3a3b1c5f00256689a228df1a246c4f42d3a790fb8a8e20115a3e00ceb2c929c432a3510404394348e920d7e1279dd4136e1a10a36203fef16982126933c48f76ae01b057e03984b09a9b2710536ed4f593cad7485ed805ef81d6f98b7ee08ef4af13e82402efda5856d70db13a5258fc6b51dae8ff6a7244965c4d8ba470e8b8b269f3ead8879a354ae6e65da7e2f755aca75df4364ac30771e5241da2b1a22bcdc96b16ffb13f971af3628a3817f18a70b995c685c2556097f3104f694548b176b7701a51788fe46f2e4a08313fc160ef750c6bcb2210ff9ffbd5780649f5e307fcb8e3d1e6b119177f3ef576e5a4a1a38ce6bacbc836fb7deb8e3963eacaea9908ae0c8c99428492932ad934f1ead9be92d1c462ba8954285ffbf66e37b03d5d3d580ec01b36f9e36375a9e64772f7729b44a4a33878d2acb357e57f75d64f069c4a919c6a0c1f1b9121f2f4d29f96170b807ed4df010ecdda109c82bf42635c9ffb8620f7d2dd4b41baedb888b30f2411582e51ae7efa5518b7a04e4fa566bffb772fc6021d25bbf244c9cfeb98a3984ea753b729a718c3886eaf90418ea93675204184687835c223da41eec026e04ec5ef5dc4fe107945f6c2aa09b742e562ceb88b0ee92e9b84db670c4ed2ac7dbea4c1b7099186e0136db8bfa72bf367471a866bfed31a15ec61978af415e0be1eb6592a637409235ef2fb9e934ffc52905ee6f3dd6306070f09699638cb5eb39843cc2c5d4b9bc295dae6a56ab21525061aedab4cb6f4e1e83916a026ef97bcd5e5dc654ebe078a0a4210eebe2cb5966ffa0b2c31321dc621642eb9c48f707d1da61e225926516d7c339b2bb003195ecad1dfe2049cae5528e6e629f08f997fa3f7a3eaf4bc6ffe5f41a691db6092815d6d894b35aed12d1e9f2cf92e100773a4614a0798f32916cff72dd990892a829ce4b9450b6d6c2582cc09ae92a9c73518ce76fb0355e867e88840b58dcea44bb35d27b88ab59948519cdbb91a51927039875341793ae31030bc70adea7d748bad264246ab27127e04b37b880606fc416d03ceda0706b4e6ef58287d58c970a29d2e655decb8a8e191b4baec63716a93b48b52fba712ceb4870e38f8406e6af00e2eefec40702c552eff982b8163eb6d3e3d43c10eeb913e274992fa52f062c1ff733e027985a58c00e49f41f1d027d20ba18e1b2fa3a8ceb2a7dffb77a376c81b17b0da9739cda239bd9d917268f2de038e261ac7255feab4b79cf94f0cbb9a9292f494f23af84deb26d871f7af24da9f56bfb2d62aa5645bc2c5276997debca7b6ba96eca9f39e0f939b8fcd59a0741382084e406663f56e4141d0716a3ae300440e295e96411eb9c58d9f3826d7c4a2555736bcea39e029f297505d1f4ea6c604ed88f0a73530e4c3384dea6c2c84d8689d229e3a1d36413bef41173ff58492c27f6afbc125c0bd704dbe95fd93114fad08200d79573642f69f847575be5fbc7e960c167c250c74583d939bfaff55e04e49ef24252ec029a5e2b9711c8269226e1415a37d230b9676905d1e726","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
