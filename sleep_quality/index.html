<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc59edb278b51515e26f34865e4360978eaa882e57c26baf7c08eff2c0c49c4ae307b670a6f9c0f7d5536694aaf18bc9adfa650162e4b99eac555d50f90dab0e516775f9c202dc9f500f629c9d2816137bd2976b74cec2853d9d58cd045d86182755b4ea66e13e6ede0f25c36c00e78ff89db43d5e2c867ef6f94e273cc4c291f82d5ad7240c9a272d3952729a3ff7f6bc943e2b8132b28ce1ec8b0729e16f04be68ff627a4cfebd5b41f9e61944860cb5416c08b1fa43a106c0205430838449a8dbd1aae783d01f1c314d870faf274bc16dd92fa306b74a8fd7daceb9186e076809d475b37a5d6f8fa702ed8fd1cc764c2e483478cba97407423fbf9949e5290fe80fa1a5ef98ff183ff66199776935a8139a3ee52647a0852ab3c2376b6de0d52e77090a4bf4e0687a04b0e40bde7900912fcd680a6b1b2be2f32e33d2edff54c2c8342634cc90d67e55302e3a9827264d7cf2e7308b0cd6129d2e7442c2b1191cf2bc137c72f765dc69483a2a1149dd21d42db699b42a86e1b201c1f12932289d1d60dee8d0effa4c30842fa90ca506a0909c4471cf69a697df1b6f90a18f64b1fab40b9347eba08d9b078d01dc880107eeac94522069009ef0346ce420ec446ded7e9409fb918ef99310e6822e9f631f1098eb7e791ed401af4076c1b534c376ff90d5a2d2a443a8ab1cc8facd48a58f94363f3b8dbcde791084a32a78092292d31d8447ee16fb467d5892d48a5e67ab87e26c8f70cb7904d97cadd0d2a62a581a9473abdc2a557aa33cd00d377f9c317a529c830b87f852d92ead3d36df529f891d25b2079e6bf3e9434e22236f4196ef98b4960f6e1375a221434ecb4648587f23bfe0ca0143e5a33f05fad1cbf1d28d8c2a996a4acc9376b5d0a143a48285e49c91a299812b490b07fb1119177f84e23e6f01c198cfc5b5e3e41871d651fbacce45787871e42acfb89eec1b83d642c3fd8b97305bf4ed1c0f4503d4509beb91fdc074f8058b78c9d04531a975463e2aabc2572811f938d18e83da92f6cd3b8e6765f0457797d7b9466ae80b76cda9bd6542f268768fbdd5350030cd3a27e64d57456ecc6a44b9130d0c679dad2e8e4c2d92afdad1dd0d0e3d70d219cbabb7aeddea5fc8ef8dfb2283aa884f9e0f673a934b204d73142572f45bf867415276dba41375b6e6fbbbc0b856320ecfd966cdf4690453df5898fafd48cba4a4a3d73ec6505c231a50b0b218dc9175131310948f156c488af5592ae11ec495282e33e615701d6d0f3302944c73aa16d3eebafbe25814fe7dd092b310cc0f513969138fb15eb58152043a44e58d3f4b353e9764a30b53bf736ffb3e9bffb8afd661e37f7b514f0d352c04eb367e1c91190c0e57b97dda16bd8eea701213bb1526a5bd11a5adced4d0bea18c843f5e6baedc81457dff54cd6525e0e6dd887df7636666f710624cb16fb2654cbf24000c0e4fd246a72ce76639069ecc024c4b7fa448c2c92d1602de0b93259fdc80d0a74ac69ecd8b5656e8045a56a8ef5208ca4f14e39edfb68d514531c7d02f090fac3eed74d661652635eb8d3504e4a321942f9381438dbfc155095e8e4ac2fe70b99221f47491075da19faab74c48c256b6e4e29c8e023dab4622286655b75090c1d4e759916e05f09ba1c6ca9ad8c42c2a20f67065908467e7a212b7f39bdd42aeec3c639571e1866a8aa95628a52cfe336d0fd0b3daafbce2e9eee6d28e0e20adda2c248bcbfca8b4e1dad769c88c29c5aed42220a49c45039a1cc6fb2fafcfe95c83e1f3b855a0bc0b87fc8a87530211cabc9fe36b5ebdd2e89cc696b6f17b904bed82507e03648eaf97a4c409fea519777b6369e19fc632fbb9c2a43133e5d2d7a94619a38971afc9c2a1d21cae5c1f7892902e50b755711db7a08b1e95af1e2afe599a695aa4f2d26cadefbc93b013bda339da2cdf8a399b3b614761bf7deb79128735dd45b62c8620badc4a9be928f45c2b1d25394760a9194037a052e90ebaa8e583361a798562d30e2895ec04cca80e8afaf9345bf7a10c0a16bef563435e87f82699a315eab1bf1aa443945563c8e15f3904b2690f91b40f574d414722e06cdaa6cd1e7f8a46d5b4e642c72accf638b68a94b71996815f9c638559033034baf9848301af1e4d52b66e657c0833f6769f4aaf861c18b3d849212c2c7155c957ea4778feb0194c5bc0a3870dd3dbe4a94ac16d6d3fc072b97122b999546e48bf347aeebbfd11fbad62bd31b07c6ffb60095e54a3422a058bcfbaec431c78ee417758351d13689eb0f8f1e3f14472c6f4c9c84dfb365a29798c5ef7aa766f981318e870ef9436e068ddb3505a70d69af532fa0bc6648752bf8ec833527fa50b5fffbe1a8dcb6b6a9e78ff5697eaaabd36fe22dfe0260cf26ec89b8461aebc3bb34355c8138425c7aa658b9c13bf045a56356e34e6807ba0d9337e9ce409c4abb701c01f2670341f4ed6a7deb045322322bc5ea5a0fdc898d670fa8ab7b0a4c643629bba2b73fa464c6ce379ea63b17644b9d744d3c982b0d08a659aa273a99472cb8b1dad25300f689a29f06a0bf64e23ac4433b3214edfe4f4934e3322d0a30aacd678ca4973f853a67542a20aa392c1bc49c5a60d779b4875ffdb3431e52e0356850a3bc50d924e4711591f755f3b4ce6e44027e46ad3a9ee9b0387e8a9cf6b6a6de12fc208dc09985433ceb815e2772189fb4d2dbf875f8196052e0f62c0051fdd74a0e707e1d6dfa54b83322b968a1274704ab1a7a148531e4c278e0294594d4f9d669f0c826631cf257bbe346060f537200f39e595ae4be9a1faa075edf792e0500c98e3dcea393f0f1a9f8f76c22d86edd174690f93472957527f17242dde084ae3f4bbf5ec4869c136a9ad879d12b3a78d16c5c17c19cc8bf7be49b17f1dd44201fa3d4495eacb8d4023f7eb2d064a781e1b12a0b1ad2e5b0eef1c522aece000cfa963ed1377d6e6f292017012abb0e940de4ef5cd01b6d11c7373a4342fdaa447937d01bc2fb71f060e380e9471eb87bbf73df4eebe8826798cf67821e68e8a16d30b587208913551b4a62a563fa994d830a519bb174d45ac8f3047c17ce0e6bed6597305dd3ba59f7f8aeadb96797c67524bda70bde3e91d2977c28ec66a63914290bd802f9fb024d773a10ba4eb6bcde8cdd3011a80eb7c2fc97927ddc52f60c23fdfd654579c7ade755fcf92b3384d3e2865de01e92d48f8ddcab96eb82f29852d47a1b821582ee286c53328304ced5ec90ab4cd322b4507f7b10848c6997869b1e12b137797093fdad1f7d8f67cc36d8dd7c89e85aa4706c1b84495ce7a828d9cf81343d48c88dafbc6165552fc4787f9db9b267e82bca8c341932b9745c3729d246420d2da363c6f31febe19dc7d22b7251ccd78aaa174f3c18f763491482bc8ec0352392000a4826525375644af51586c0d304424a634ad5b2f297c1572cd85be5172e27c3398c723c42d80f2bf8e2e83dba10cbbeebb46ea6e3a0775d4c624f4c9df87f00292f436703e099cf29559dccd230025be2690abfd220b5172a54d72f41c1838eac24556108363b6a255d5f27bd173175364677f542acb2dad491f0d245d1d4ef212848fdb7f68fb45db1cea09b12920ecda078c45d37eded5d13dfebdc0520268132fd7a9af8e976be053c999985003033984cbdda201d2355ad7ba26aff2d3bb26fed711a1cbf508ebe976dd3825be56d0bfc57c3c23bb562eed3dd4ed88fb3373ce4415cfd59c45de029c715934354fdd6b969184649ad52534baa7a2f01824e5f5616842c7675a1d2494f5bd8255ca182fce52c2bfc29364e068b6551ae93c4ba434b37c131c2bf5e63a89675316055186dfe4fa68c7ca5d55acb457c765c6013307b36931aa12dd2936b3daf48cc6948d14794593198f6c984962eaba4711d955602bdf995845a544eed91b29263e00e8c487ac325df1559c9d4f16e141455639daf1a4cd1de81912bf384e0d0fe1c6cafe12b808ede279becb9e6d13762b1557b946e645beb44d7db13d08792a8d0934bd35937e66f28e4fe50a94a517d0f9e81055434a89f427f1bf4cf59baa9d546da68f50b1953136261145ad2c28c096d9fca9d8586a27563eda26971b1ecd7d3e88a5bcd04199717e36110cbed1f1d46cef04216fb047b7431d0494b3b5cad4bee225eae688f234e09586ada1f0c513592f40756ec0697ae468d452954ebdd9ce2a616050456c8bfc63c1756c2905b79bc7f001623532adf3d69524b87b84ad3cce51a0175fc89fc5129397a439ae088d7b7a147d499d8830d85950162b8893cc462dd1701fb18c950b72a4fd52665aabd2cfbed647c23a1dab759ae57eb2b94c789c107008db2aaa3d75ca15bf490a91962bac0396494bd42cc3f531ca856700526370b5e180816e103fa67b04becc463377c0447f248afb51c16b84e6d367d42cad957f0826ac37758c3117cd3c4dd83b2ff5af656822bfde083ea17ebb7cf8e7da3d515f6e1c7c4ee0d5bee3099bc91743586dde126b679535aaa7f9eb603c24fc083ee412f4ff368cd566adb7ca8eeccdb7b5c1568fdc7a1e9d53f364647dc1a86fce16bdce3262b30970ebc71d44bffab5ce98ce874664c4d429694fb13ecafd24b1dfa394887f170964075221baa85cdaba60eaa397b9e84886716e65f76c80e6eccd84a08d7878573788ab80d161006fd50abe302b05a5cbc7c7522d184ed2efbe8f9105396feb3cb42c48fcae203aa64b1188ef1bb68e7c169d08bd76d6b5725f6024422cebfc86090bdf0c05593b918b5ca899e7a9a0e00b12992dd488d662083b435755decd5a5cf260b05f1c8d08f188926198023fdf7966faee4ccbf53bbdf4227e295fed0795d1779004a259986dde4cc66633d64f90917c19244ba29501dfdc60a8329de5b85ac821f927b5623cfd3ec3b692a6b19da9422317bcf321b8092fd1db65b15b9e7fb267bba4570af273eb17bcf2ad0577aad9215a9f13462c12f45f7272afac8674afdd00a2ab56b4ae60c312f1617a91960c7fb248910ea6d8af6a7d255e03c115136f39738c6c1ea42111d9c5392adc9c6b868ce1fbaaa82cabc6dc578f250ca4a235ae2f5dea6ff52ee5ed621bb6fee53724c723ce0c4dcd66ededd64db1e5d29ca109ec27721d9c83c368e1fea7a26802aa03cfe11ac1d524a584b321a6583409b9a052abef6fc01ea78ef3b6a60360b0ccc76cbd258907506e396d97bffca9c2650cdfd9555fa2374ad84233f618b90b0f3831d53afa34c92a8c8fdb3b66490ebb0fbb83209fb99e1c9f868bbb7e1ef1df9cff756b85aa6a1ba94510924022b24bdc2c71eb8c7dffb8ebd1cfd9e73e8d253cfafcd09c00f666f81317e8db6de5764e8f85d707e9b2f8113d4b4ae972112d4b25b2fd0a7ceb4962a573fe87d4eae0be18848a566fe616df614830f5dca2813843a13388dd6ba841d468ec12ca621412b515b3fbcba09fd2cfb527b0d586c18a3fd831c9fa4fd97496870792276e2c85d85ff081efc0fe30bd505ba988dcd52bf223203e7674580c0efeb05cb3b0762b5839ed67b732f6d58699a923186a5e3711447da398cbb6c3953c4f70a8c8fae4ae5f98e812403a202b151d1e4d20590c8ca1bdaaa07565441f848a0fd0244b0ae48a97226f61b1390e82d2c5731a5f581da44e280be85b37163fc17463e8b8db04d917ab257ed209fabff92ff59ea7584821d6bc70cafd1f3f0cdf9963934c94cb0319cf4a1959db9b9705b5e9fee94245925afa1b83a2d7b9773501445d056b5c65e5005251fb4ee4b5fab12e2263440b1a1d74f8d25116b65c695e53655b16939b0bf4e400e97b2dddc9bb398a95dbd11902e0d04d219c9e8222d2a777fb62c445737b75d31c5dd5a397f55c67d1a30581c8ebf94caac068bc5f5e6713e65b50af9af28c5624e6c8841e305fc2a78492122cc8e6946d2b73e03751827a1971d6920d954dc1d4203ae39888f3123d282b3b8c0e360192f51b8076d3318a9b8e221486d9f90fb42df453dd16fcccebd00eb7e95ad09cfc682127a3c25e4b2c8eac5f7445619e26876931c4d8bc5ce01b80631af93fd88a52833e6f254333fa5a6a278f0ad360e0c5a594af64a8522cd2d3eaf25fadbd363e3608bcca5d89f6338f2f284ac99e67f4cdc10fecf69dc7ebd4903e44a297718e829864567f3e1d717107301883f82a1cc23e3cb034a53488ec6bb87e27b3aabfcaf599ffabaa47a08a94691a94d46ac5548d4cf92bbe9b66822ba99d63ababc972dd27ac13a32556fcc1325148fe01c4c6c72c4f47276ee7c636a5abbcafad3c56bcdd8f3e99cd5f1859d7999daac0b4ef9c4fc6b62c8eeebbd2f0629fd38b9fc1884bc4c98610be1d184801e803cd42dc79ae24eafe529e75fa1a04234e4587e41dd39c9741f19ee4dceb024d43ccc0904afc7b42386fbd5e496f18db68dae50cc3d263299870e0298fb47409036bce097c826dabb71f72fa87f6ec661f54f242b6d2a7846a0e6b578439f4ea086ceb94893698b995d4addd98d6b7e6aebaac7f824be5d471d829ed2d3adf080ef06bd6e3af8dead48e5705c97c8caad62adca4cf02b53b02be6bbcebedc38aa2686ea20e1f2d30284ca997138ddaf701462adc1a332425f9b1fca5fd7fcbb4f5f1e5eb4e116af677509487d91f391e92531a4e8b609ea0b02ecafc56fb99d70d29e0673d89c97cc57b51fbcb30d08f66be04be20a335d0d06eb990197f815f1c68f439b5371a189317b61cee3c0d5ab361429b58af2ffbe06f24524a11956f778c8f72b666dd5c877146298c5d0467247bcbb16e6b6a910fe7ec77147b94697377fd7d3aa6927e4699b907441ef304076c60673f28015481fb05a980fa65975db1288b15e6d6a0a0a032613f7c657c36a90a0ea185d6d593c4d9daf46a2b95e3febb3f90da728fc9265fe04cfad975e20fc4b4497ab7e6edd08562977c38349241c2c4ebd8e1b3a52251a130d3afbcb025661ae3e2f3bc8a14a6572e7c791abb40690f4dd0de4d7b656c49beedeeca18860b87a125717503020712c7057dce5263434b23c17902f36861839084e93d0be14b19a8c524ec70240f4dd0dbb8ce486df0cd4cd79e829675726ba9dbdea0a6910f098e9ca735b60a3eae8cd7b0c4d731f7ebd9eb672dfc949f032e9fad9dcb508c2a3f8f2d1419b3e0e1fa1e5cb4a118614848698b92e469847a353e8ae3d5e1ff269ae86b9f77d6229bdd0eb502185ac34de3665cda0f71b426ad12c3f572b490ee78d9fd37872dca90f99252114c568df33c4094dc4e5710b0fc2de343f7c66531f777e1d4e9463025d40e712de768f840e40fe78eb8402c22bb98b9acb50ba8b5b6375410bc785aa64a667d89cb9a8e7ca6dedc80131f52b262de9a19437a4c0ca415cd83d30877e743aaeca363113d69f5f7c6ee4da50002fbd64edbc610954c13bfb71124f2e02b72f692f7948dc93b4db988b9c826df85db1c5d600b95642f4794d9d16e88829af0f93b3fa759031d70c7b9e25cd8a21974ec80689a01dc4b82432d2451d31a2455496bf79a57a688935dadb05c7bcecb78e2b9b60d4b301da1845b54c2c58364ef309fc6dc46999c1b72ea42234526dcb4e2c555f053c3585110c93fbf48dd2ad65e7d3a5ea17638f518b3106d6e5c841e359d3c9e1206a84e5a4c11959fbd97a3050d2ce7d5e21e0f4e5de29d644af0f09de155f81863c0e33108fa73ce635f4c46f8bc2af3012a87eae6e54722783a7df2fea53e69e103eb22c1adce4dc9631197c67cb6f90d05c05c55461cbf179398ec4983fcc3006d63d12f9f2e2c94f1c5fdfdf658d3e4462f70c42d64e3910090bfe63da8c83ca599a134f319adf96f21d73523fbce970301b52e730dbba1f8a3217ad97c7fb6eeac9e30eb6257f620160cfddb2ab07fc598da6685b01ca7e8648510688bf71f42ff620d3c4b38633d797760295cf2b73de658349bfc70c662ea31beceafad6940e86638ebd573cf8a9396b26aa8f16c6415e406c212876892959ac5f7290c2e46b8d14dfe81d3d0c13a9b2d6cc8de9271d29d183cd1ad97256e06c4099234f0e53a38b27121d675aa5ed6182655314476aac598c9dfec200039165ed692375abd506e656f03540164de71abb8ae340ee1ab2bedf9f185acd0a8aa6839bd39691a2c53b73778e7048e150eb118f1f381c43ab6d111b65711a5d7aecc14e1abee0fef8101304348e91319c5de9e35d09feac89b21eac08be7c327088d2f48164a748d8d605586240b7f590e0cb0e89a1bc0135ec8b02dff44d3656638cc92182c9d8a6e558953f8af8e6ef51bfd61dfd7e70288051dd97a256e6a0301795d1e2a89ff04e704a0804f7c23ff66b5d5a0971faa375c48ea819e3ce60765aabe37e696d050dcc17fef114b702f53f7d247c8c0daf416dbcf78bff86cbc726b0704f20a02073e03347b6895728a47d2b27fba80400530b7f11858512484e42dbce56f367eca62574f990e49eaddeeba58f89359bf32e0aae27b639a09b0164d7a16e58f410fad28843f2966b3f664bbd7a4d8bc5643f7b9706417d2a3b041b4810c253294661f14508b4b7856ba31ae32dc66591fb38f2504ae9e75c117955e61a5056021db1be506c5c1a1073a2be1d3745563a21ee06f83680f065edc04fdf69504413d75a93bff2a54bad5f1bc1c082de0b0a270646afed8ee4f1c5a375995fcd07fc1ba7603a0120a078abf9470b4147f66f96ca74deb64ff5d06dff0197d6fe99ba3c978f5489943b21bc53011c26c001a67e2e72a1044e2cdb49871bc1e2fbd0276e30e694881ffc2807639025e0d3e53fcd9c8ac196f84da3a6b742c8d03a501736a0ef2b439bf2d3751e5315fa22ed8b91616aa057ba5ee5b4bc1fc2af64c68b95cc024b7b12db65124c7895699bd45e0234a78a0f86751a55819a32140ce50d15832ae6d22e0431890be1f01e7134df39a95bb96b28194f73a80276bcd51a52ec16b0739ec54f3154955b6ddbcc269f18ebde6765d601effa6066e9b74247bf11c8599b74c430bf0d27b8bc3dbdb10155de1b804fddb99055105549b96f9c123b7e9bc9760840713174081581bba851566caa0f7dafa289eaa7014ad2c25fe2efae035aa2efad3e4f76202024918fad72869bf289e97703f0bf8566c3aa81328b6bb7aebed5f09faeb62ca2423b6be044f9cb43024f3d8b39729b17282bd455e61e036403881be8105c9794148923c4958f147808fb344","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
