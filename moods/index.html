<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1ea346b7113cac7a6a1abef8e6fc35bff5cf18742278ff728c97a9941dc7b9a3b0bd28d953f34242969798fc5a338704d39ab84ba4a65323dfd297616eefb2b19e8d1ab60bb7c9767fe80aa22a896f2eacb21f1e091f5de7e0cedb09048f63404c44052a0f3c487471e1bdf21bc339935253c180813d4ccd9117febea26e3abcac3508c531b58abd5d7b13cd007d8166cdcca7b716a2278d1d06dcfa8543c378aaa64b856d8234dd401e3e3250f658be20a724ccf871835586388540e188e3be3f3b29d655c4c6cd17c87e09a794c9cffda48d9531e39b36b47bfc10611d82d583e4678d7c6ed44696353c2ef70c1199954bb0da1ac71ac70ff62db18ec2e6a82841e9e78cde97264fed6ae77882f0d0ad4e5235248e6e4956789bb4c57600dafea3acfbb486e0e51bf5e00a548459535ae5193bf8fb1de8d05cdaeeed30d5bfe7935b7666138f4312ca20c7d7f554450a8c8b932bbca1a4baddfc0f4e8a0b90184e3f9235d9f3b1ce80ae221c831649059e714eeb56af7ef0e8828985ec40813d576ac4cd5d38cc57c91eb8977b7692423eb6a4653c1b63ac0f4268b25033fbe4858bc1eccded8a42f782a4f3029fefe1309396b11ff88c4d63f7f7d80630d719e2eb2e854503d805ff8cde048002ead967669418cab5584b0a5b0c74851eb3965eda1c82386743886062f0c790bc7044c3fe61ec2b0710db2c2971003cff9f346fa3e1d4241d3e65ba83a76b459078acbfcfb50c220e23e46df3fa84f86f670b24294323c9b215ff1de458ff974a246b2fcc119dfea50216baffb3728820aa3cb086d6197e90b101922c2f9e99f086ef39fd54db04d9880bcbed9ab9462e103cd460c087a1b66df239f443384e5239a04ebe7d0fd741dca0437fea8710d773d4bbb68a2cb4aa30837f7137188e8e3abaaf34f083a940613eed86f7d46596df61ea5f5dbb622cb7185b095313a758c26b95b02f5c37233ecafd9ea08fa7674b055054860ec38cd3678e5b1ba09fddd855b18b3c67551c73a08ba10b3d69e4803350bdc881d8867d0ac91e244e1634ebfcc6ace2c2617a26bba5fa5375a4312b463d3139ec531dfff2dde5d04d029d3da65272e07e937e87d27f9bd177425ce56daff2f9b64eedb6657d7b5133a5ad12c4eeea816a9271f92a34c3b4e26704a84527552a42128e51d8ebaadc45ee17c36dd503e182bb7ed16f7438e6e8c7ce6bbde92cd3fe6237fedee151d60496bd5b9c5982b253d0046f2cb257b02fbe4ea7c3b1846cd322bc9ee73887c603323830b51f54ea078ebed4361548b65aede6a633b71be17f1af95ac911395f55877e9b68ec1937e78c8eee04007e34b89998748bf847350f82246f3b9e97a03f4082d48d6ea963c5786c54fd1214760cfb150c32e9374a9a2daed45d978152699425b70484ad4b71c00c5fbe22f0e4363512acfc61fcc9eb8838e06d8070224e8b5cb6fee4438ee184d9388a39284feed99ceed680703b9677e20da2bd8c2daec14865af1e5b1252fe2d565d3bf0d08ff1e0fec24a0bd027f7f4feecc508aa978008d1622340b2c0f2d1a82a24a8db0c8ceb69838b7f8c1ba2f41c4de6dc94461d2e6d8133f6e712661e4fb8efd6967f87f356ab247f84e67874c2c42dec4a179381073b1febd756cd8dd6b91865baf57d39c4430091bc34e95ab9a422b43813ead1c1969760cd495bb915ca0cf1fb1a09426ba0d5156582a47a531cc701576e6d5cdd07cd15fd690805d0dc4ccce43f0be3286e704efb39e1828bb1b168506bc0ad7425b0bc5e5629fcdceefb6a580ef93ccb98d112fab12c3bfc69dbe69a86c1992f322dc3f250b56b33f8f261d19ef3cabf4775438b9ee0ede992fbb89c711521965e399d42e121f7d53f88d0ef4736e2b7870ad6d2b5b2a528f5db2f16cb45b5e776c262bcb5dc4539764cb12c56b5a19fa4dda195d1fac4389802c085d725d3f8c021628bbe4fc0c42a986a233274753fb8a4e3b197400ca97ec4f31d5329acf7aa47b729e09a1718089f2a5b027916b26dca3040cc431947a24ed7b9d5fc1ea61fc47930a7f2583da1116bc80b09c37e364e4da57f6ea90ca0e952557ec875e5d43453c80bbd642a47570baed97df5535ddd02261dadf1ab83cde85aab7c76fc22b4e71f9996acc864cc13bacfb0febf526c13923b90f0c9fbb0c80f2f053633bfdda2be25cff62efa90b63753872497797f13549a8b3fa0f3ebb26d3f95e0e24a6af1f89ebe2e85cc5c6b0a70ad3ac74dc3119f52b507b76b35630ff9f530b5ba7eb90cd86c8a488b9ec46215ec43ccbf81058813f8d5f2919a8cda9927dbafb6e8d9459e338388f6609749e741a5f7ebeb5cb233d81e6a97bb04fe08532e8722cad08b92954168fba20699f21535a106ccf6af1a53f2a186ecd148da09b9315036836af7e38ec4c6e4071e82714b59da865df9b0e87d8456abdd7422e4ba570e5ec755af5435da81601dbe2ab753f65497fad19401312674edae2dddcf06adb059a285563ef9ba07ee10660092ca68836399ca908bd914abcafc720d7b2b95c84b8170a740dc18992020d5395bca1b21b9539e1c41a544a872b588c7c78e3867eedbe52e59cace2c4c5c8d17e24b380c2a31bcdce69025eadd1c2c70a1d05c5986b744f848216736225136f5e89e3ddc1910ee4e0a28ffffc67b128d6d71b6c64a48f65809930b5e4a7dfd582636b6b952dd6915d2cfdc20d921e2479e6db0505f09c026be25f65d2746f8237c8e5247f7f619836bad4100b77f5495055b09be16b736add628fd4794736c08f588b6654809372f84ba578c4529f8c745f5cbf02dd5ca10736e6fadb2bd944d4159b783246bb32bef6718461a8c5cc96c29068681bdb415caf75653deace7e541c4d3f5f5946067a05872254af7ec82590771f452723e7d4a2723a2c6e91068b6f3ef75d8228c3f37d76015f9e45635c89ca9266be3ab711134549000c3d8149057b4118eb423555041877cf8722585dab5b417550f6c833739b45b2ad03ec59b43a7eb215eda3c673e90685265aeda061da80da61abac0812d2e4b2609697751cea329a76a8bef3077dfcdd52b32bedb1af4c122a5ad243a3827910524108618391fdaa39be46de1713f0abe28e64f47ca488d20ab9651b23b3c558da3e29c91b7550420c893616efcfcf40923c0d1fc0541200c7a28a9051368df9212e75a7cbacbd248d6f53bf14ad83ded4fbaf27f009fb4d8676806a037d4ada4a928c6171ee12add2fd1df3e7f044b63008ff32e57a690b581bf321a0dc64e5993a46fa654799a8385f7bfceb0a9c5f9de3c6b9a60613f5b1aa3bfec035d3098de0b054c2d7b52ede3a6b930d4652df86da9a3379d58712f1a1cfa4c8dbd39c79a0a7b71597676b3ede9c13be14419036d798160d223f631c4868e6e335d56157062b83d82336892b07079cf1027f9a137c81b79098d9d41fd8726d24313e1e76b2589f1993da45f2a286dbaffeb27c17c5a4a2ed4f962a7cef62cccc8e495bd7f418a2463e4897ad34e4d15e46125103fcc99eaf6a28978730ed247ba6b0cf7649e7a5460c8d6d7fd1e32283996d208ef66e75b2df7bb52067ed20494c3f815f338814c705bed33d54cbbdd5603ea846007d3736dbd0ac1c2e90e8221354a9bc7a7d8cd1823541884842be3f80eeced1cd219a7c4325d68cc97cb6b2b9ccde5c76c487206acdda0011b1f561287a12fe26e650066761fd6bcea3b18ab0669383505d7a5524feb3df73db939bd263406c8ca6a59615e02fa193aada736321ecebacae9e3b21d6a875677f5aed872dfdb483c006e9a9dfd2fc70e28aef11c95260c758c402fa673458471458807befd16b193d91cf24e1e9b40e2b13a8846f20e85ba314f43326a813328758e3387200d4398f4881e7f78e77f3221e5818def496bece6cd1e6a9f11076efd8aa0240f5f6d2073626ca41e152d6a69136578d76887ed2dc0321c5d491f0ea9f44e7161dd3a9af3a89bd870ffb9cac69473b4a00ea3fe4abbb9d6ede03737ce5fcd5b2f6949a01330b82231320fddfe0efb370c6f7187bfb80542c6b37837adf7b972fb43b296795ce702c3c3b082cfd4e51a414f694f881c3da388a78284f2072b8cee00969aafbd18543490dcd47a58b1c9f63adfd9e1b6e11fdcbaa6a08b9340037e8af5fb3f1d3b1455f819569c015220af6e63e28a0b89812193f0a3e014a77a9fec4e3daf58608d2d2ec855e64ef2b0ca3b539f159c62107b6b28d8bf267e6d893fc66c30529a4cd5c157ada1d9eb8d388ad20ca913b88a844a9a5d97dc80250f1cc9d0e488428337fe5c33f8d0ac7f709211c4b64e80c8678d0cf350378e92663b4f4d686337f391067b151cd85782b4af6300451c0e177f23a125d7ebb34ea471546581a281502fd23764e63b26e6f5971801a71e29cb966ea6d0fe9cda8e2a36944419c205231e9cf60c5e1495531fa8a567ac5d6590c3d20e2c6a89fc7ef911051cd8fe98107597c0b5edfe566aee9aa8b0b1117b42df46b493e32e815f19afa4e4bc3ecfb978cdfeca66b54226e05895b2e5b6be1e1218d29e61a9095416fdf0ddf1892e9d2e7ce8a2ff6dd851dfaaf6d30040d9db67e8f38e033244758ee777b7664cb2a6301577a47f4301f31a3e2f7558518933c75223407edef2037129b1cd4c41ebdd98da62c8e50540a6fb3304a036a05d9d2bcff05dca9b496aec476b27253f803e154360d3febd1c6c47227c9ec01b16d5c5fd4e718362f331acb3540587a8f5ef805de2c903babb50065a43a4361156a541146fe4337737fdbb112a0b757c45d158dc89898939e332b3b8a5ba8f32960ade3b4edffffe07628f488928f06fb1dc0b87ecdaa828e1016a14bb20c0ac3f4391b2427d9b5dab52319f62d26f3566f28d3a305c555cd74fe7d43e00f231e5286f40d537c2a58c3a01fe0429903f2468bd1b835ef2311aecf7a0bbdb7a523cb92aa2e330d6393573bb4954ae7c272d4eaff3cb46f8fe214c5772ed5186982a06a593fd68de23374315da59a7a7fd44fbc35143643b9025cf8f7fcb1f5649e43f27a41bfc3f34fe32bc3840936a6bcbdbe1b70ad9d60f478d91b493d67685e0616bca084adf13137ee04035c28a890229d6c2f4278797fd2f51e811fc0d11c5a82ce497a0890ad36e8e64f5bdaad1d751aec4bd82b6e2f1d0d1d7e8ae3e6b508ba260b5c507746fcd7c68e604d6be2ae95bb47aa802c45cac5517e353638f2a8bcb161427e2bf4edd8a100d977002714b608aae403db06c65d89d99600f595c3428fcc2d201167e556a53f99aecb6538f7e054fc52de8f1e1997f1ccf24d23c64b18a73c0013fe87ea644ff624e4ab8d566da14d3c256f40c854aa3c9af013bab2c80a4c341ad8fd54156cbe43b6262a375fb6b33fd314f0756bde78a6690ec9864cda93077403ee97d58baab51b1f610acdfaf041633f56a7bcdc8a6d596d9f62c40ef700147eafc3db69f7f8822607a324c2820250295c14afa686362a1fd3d0103076d62263feaa76c17d978e982a97dfbe2028e6113c3f2ce9deb8789f634b1440c7f6b2ec79298bceafbac51a8c0734eec03e5f96082c4a39e70ab5b7f0c2910f1fa7987b8be88d82fa754f2e52f5d857d73a0c7a9f460a260d9e77cc726dfddbc88d9d7323613b367364ae4440e5fc05b9f3caa07123b69fd28689537ae09e69f64f33216102e902d7576d3fd4138bcec3515280f1340bc4ec091429ac5981224fb726ac876cb81a3924806a0e7c208e177d6cab886e37ac977468988bb51f8356d4f021ecd366196243681118b6d53e5277bbf3b4f7f4fc9e8d6b0742cee80a38471f47bd203ce5c014fde708005704e4123f1a266352b8781358450b831a5231266d175b39f1ea21df906799d104045503a63928dcbaa9abf3b5117da234aa82a00e3a92553dc780207999676a1300edb06a403a4296ddc347cb11c5e3a40767483b1821aaf2ef625b716d0ac1917e3e17287e7ca0a348d1fee7cd230338af81ff789cb15fb2d9bba016e73db37210c1ba3043ee4b10d33af5e680f5074a51e6c8fc7bb096abf72a44886e3194e9bb4c611d113dbcfaf0c7e270ff6fa885bbaab0475b2661c77ce20b5e8eea1e71219d19834059f532938a57ff64cb7a7404627d69199f4bc847bd053f92d9053f94beda8b40cbbce1bf9441e55d93a06cbe30385c4acc53263c02f494a6cd5609b565f7f1488035f5ed59fb75571568c20b2d5d1f53aa12951eed3a3cb2df530b62e4040da59f4243abbd9a73124474976ce1937a161d501ca9e57323710e9a595db054f7e3092d388773fcde59eddd0447bbeb10b191bd78e6e2214b855cfb6803ee0a36022f344c06cbef48e9e84e2d0d8a300c407065ab82bf302f06116c04635d725878b5fd8782df7f901987699e4c72e95ecef336317dc6dc2949ecb1267289574ee63202f52e1b75864bb183549c4290de984cb8625e8a676e4c483ae0582bc90ca3c6a7b685371fc816e3095f85f5870551c36b6161eac63f540e868a97dce91676af4f0b4680eca0cc42067cd8c2324ac8cacd75d4d0b975b200b563c15e4dc419c5208212583303a14ed075a6ba11d0b0e8b3925c607001862ce58b8eab6103c4429262b504574c79cd09bc7bd72577e07b39fddb705cc74597386f379b7fd449a1d2856a7aa9b064719226e946df5ec13dc39aa1b8c11a9e0dda41377cc721bf82e8387c0ecb92d32e5ffd8cb7f989d40a00896e97c0abc4065b61d3612d7edf2f76e2cdd1b96d624cac963e6f39fc43d229e47889d9e074de00d5bd9e2257de07c4ebdae087f28ca05b07250f1c4c51d962b3c058099f05627c8e7ae573dd74ef85fa3d6c37719b8fc803f422c2f8c20f1cc89fdf109ed873d12ce0c3cbde66215c6addaff3f4663b3cbdcfd5b5db5f08464532b3531f28473ac418fd4c3db68819b970dd3d7d75460428c3ded1eafd5f546094cee1094b1c2703d72bb355c9a90c2c4d2672c72288fd07ab9f1c345886525aa9b258d970f8d50a0c257f6d0c9f8a715b3564bb2741e94ff3dd854a7a2cb8a4bbb19d9ddb170d11b784c1b7576907e6f64a6cda45fb8fe60cbac05b8e88e322ab995f4ac86c86e987ee4b6af862d6d922e96c089d98947b2b9a38e20e51d72272a9d2a5de9b49b03da8fa31c76a365bf004ec927ef72fa32ff4e39461f373cfaae27bd939daf7414cea42b179a270df90c52167d796c7206faea6bdd1915a23dad00436329de93f1c6309373e1cdceba2afb89c93a4adf2dc867632021ef0de93756d99b2b8c40c85ce1587c93862e6fb4a672f669bb6168a6d0edc756e976eb0a6144e51547ebce68415402b36dd7e2f53d7bc93690699552a80319ae8c7436543817d49021f969848e06ee9492af19bb58abba32e23989b2603e1d28e0482d6191beb613be86008bb879fe12e9a38620ebb516ee537bb1d7d5f51d5ab4567a8f3705b1bab491dc50992ff931b6d2f64af9c1bfc27f3e35d70204ea7cbc9f2f83d22e4fe8ed99a3f1a7d8e603a719c5aa15405d4c4c5de459342f3a647767ed5d3cb9cd3b35c1417d432c288c8de1775acafb31fe4aeffadd87d8de95e95273905e40622344154c38cf5083ee41219c69921f08e7947bc69556888b913e516ad10299bd1b9f9a1ceb89960661f7f3aef1a8810db17e0be4d30652c2a55ecaa748dfb4642a7aa519a6f03f0959f70148b3c0ed5002c0a5fc64fd98be857eeeefe43497c6df79149a427d0246c46c9c02c492099106d03b6caf730961dd69b64a3f67a5a32429680075b6ff8836897cd810401c75bdb03ab477de7e47336668835e1fa3144741fae0acc4ef25d1f57504a902c30d9a2d763094e010c949bf5381f2b02efed79f2b110dead92111d14fca9d4f1999d5b140cbced902f28c99ff0ec68dbd9e3a2f2427e7549aa8a0e913273d3f954c127bb3f34fecb9f3f091a7bced172f5ea8d49d44da7044da597d897cdfabb458c6057e2d49b6bda3237aa5dd9a000de1222c516e013c3ce8713b6ef24216be6b4eb81b0be5a3585d4102247cb797aff89804d3d3cbdf7f0d7d4beae8d9462c9ec8c2eb5711eb69e66c9406a6611da2709778d786a56652c3cd9397cf6bb87e9f64648e1c05d483210ed7cff39c8c3bc8ccdf26f452ebd6a2f7f0097b3e49dc7de631d5600a70679de2ce321bbb7caafc9f9e27081559db1697b7434eb9fabf66909278d1e4d14e244eeca3e0057a1ffdc8ca9bc400c98a09096cf3448262b2bed460a41a23a19c5f050df10514a3e8eb4f14e47573cf2e98a7aaac79a8d6062001b44d4be29a0ca56351861367f28fd4db5f68def54b5a230efeed4bd215fcbd08641f68aa531cbeac51384ac340757ae7824d2cbc1e8609df46da959888144d75edad601fdfdfea98a6f3d06ff81779c1ca8480cb4ceda4fdda88eba7d9fbb2efffaf4624ceb674a19ca6f2e0ae4125614e4216625b1166ce85490f3a7b10e8067c8d2477ddd944338246b586f8a577feb76a9e237b31a1226b27b1e8c019793f8a7e2a386187dac9facfe5585a2163dccecd0a22ec1f55f5ddb704c9cbab3749f62b2a3606a10284b27167d8148bfbefee99e08f43fab05aa9d98171901195484655f423a4e6a32716aaa13129217e08a7d8b3e9ee34758863e5069e9d2154678d0e50e1c38e8d32a0aa68b9069ea75fb355b2abc0a4502f8647acba9fd511d7b2b3446c5988f82e359f5834d784606c9a5a1a693d6e698bdcc64616f09a54ccbec4ee00cf5b8f53ef409a7c6559170627aace6fad4f3426304b48ea531cf24a256e8aee23cd4275feab109cae383ae8a097c4696b4b2d0e87165919766bb7fb741ec62f04b09533a0e5231f826f7ee383887f796ae19eba55cf1187387e432798d5e381b59a8cd7222568974a2938141c9b510552fb23f538d19ac6fae4a834a5e1928f59081e9e9093bef6d8ff719776ee43686b95dda1f963950102776cfae6ba1c97ee6270211530eb464fffcfb9ef7a6d9f04bbfe383062b8792ae0466292a65d4b1af025993c8b477781ccb72966f1605dd9cb92e65afdf3b5e3e038b7ee454a2302ac4ca373f60e3792f73a26abf1ef302840ce9646d155742627eac277e142df50fd45d735f82ca7db4cff5031ea94f63f44c2a7d1de093fbdcf3c24dd8348af7af14eb3d2b5c5dccf54bd3b64b1d2be662a4174c00977086d19c3a61505091fe3ab8993b65722f26313b81a61b4cc6ffb2d510b720c9d40178c44b30c3b0a22860be85d8ce91da2e1b85de8e540da811c3d177366fc2bdb5a4ec0aa9ad027d65cc7fe187696a74a5b965ad93aa0bdc641a6f5bc468623faf362060712a468b924eefffbafc8a33d2e33db6507a46df94424ccb4e45fc64ab0dc87cb7ffea037cb78db68670045ed92e96bc2f8205c2174bb0e751a7f1839e0c4e9490dffefaef19da67e31765559236db75c9027ce0fd2aee4c4d456ec955fa3cef7283c50facfe5c667e8c34a3af680ddcc6e30f2f9f4b76d419fa562b6cc6c699f65baa87ed4c9b7a56fb185ce959a1c28a06240fc4cb4698d97e5cee67f9bebf3b794f0829837c2222f69bcefd34494ad5f315af38198f30369e23f80ccfd35f348a044253c88335fc72ffae7d8bb58f56b9e06988bfd43e45334de08649cbf31c5087dfe7e02635d808afd9222999cc5d9225a42e8976eab2216262a4c3e2684624526ca44e005a68dddf41d4657d7764943a57391b0bb3f5e7afa0a3045d2d5b6e89249ef8746168216b5fb8f1ed719bff8147249961a429293dfc9ebabc8e37a4612f87a86fffada26c2ae3f9206db6b33bf99fc2813b44bd56c97731d63e2eabc9b12dbb45694061283f7b693717b8d6770c8a4df90a9177defd7ee8b9098e836da508d1004312b10eb89d2cc6b16e03865565afaa9f60dbe07b88334e8560c5d3fc0de00b93d74ef99f568b0dd76d00b213610e69079e08de804afe182d3ff22582e1ecf0e4b8406d88d6447b85d8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
