<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f014a4df86a961128602782f4e78b5526f7e9309b5149ac1a87dda1384265d06f5c82d011463abe70149fd78568ac9fe5f0aa088bbe60714e4270461ab0d018134c1276ff8855920303b61b07f00c967366e0a6a1711e353975ac2e4e94737a3e94656ad78787fd7853dba5001a7f0be856b530a135a9cf171b12a7f138acea08c4c5d306b68cb3491a5de560afc62071dd035d52f65bbe2fb329117b11aa34e0a700bcff2b37056617f85b2a667ceaa58b5ae123871c421bf65b4fa9c9d0dd6b9f556662742b57a393a74f816b50ae2f61f35c361e6e9d5ddd5535b5443bf2e84b9659932ba4e2e97bafc618caafca833900758ea5e4218efd8bd17e04c2acd57a4e919c19770f7c49bdf56d509ef68ba7deeecd8ede3d2d9129e6e65126b6cdb1fe171ff37cff04186312f610bda1bb5564964451892278b39bdaa7538ec86186959bce1d5beeddafa16c2bc2a8457f3f8f3183bcd0792e17dbfaa6d2e98a04c370ca7990bf3e9db1c97c455458bfa80dab57dfc4aa24002a30becb5cdff534ee64f86d2a94424ee70584f00b08c3e1a03d6b23aa97a0cc2a1d501ba0c2251d35c509eb0569eed024864d4c885a60f5a1b7df7753adbddce38623ed2a4412ca3aacf52e79854693399ec55dbd94001aa7abb3ab5f6ea8d21641dbd56f3e44b43ed7b4502277c462de996d2b069efd7254a9ccfdcf2e2d9eb6f443b7c4d68abef386799d1142a88d1f24d9cb40177409b11438a59a67a37e84a627d3ec4a3c04e4c5db520b9f30e94f43ad0254ab2e7f842a30810cb51f1dcc10b1a021a3f7bd138294ded23b649330476751b80dde4b8670a580da190ee03c48353ef298ca45a2102c8a70dee36e010d061825f307e5c31f7e343bd9d9321f9756eb9c294c18b6fef2560d605b093f7e829683c522e1dd1fa4e39fcd2adc8221e833ca07d63a93b2b31d51c5d14952e3aef788578af44619f5937a0c473c5c68743b94f7dcbec60c9d1d8aebda5587522f248183c50b382a010b7c07e4754fa02a21aeb384b9533b89aedb7976adae4dd38a50eefc55f2c5d6c821a77532713853c2b390b51ecd70feb8680fb79d7c4d4c1a9ac762efd53d82deff8aa57b103e696b2dee520b5b8c3925018a3f97e8c55930a670d99fcd51b20e2752c0e98ec9f1932292da74ad233fa9e78ab269a4f0b9a5ee08363bdd31b78e7ad80507db596111f287b7a3ae649db45f69ca9da594320f8cf7061f56eee3282566f08a785ade416286368709e6e244cd6b39a1c1cb0ab71c01fc50aae00f6c7ca09f618d2671340d8a5192e2c142a86803f8105270ff7ae1edb3ec03164d199b79aabc8e44ecc128381c314790d6a0594bd0f9d8e54267762736a43e1de526767ec43fa2a23c46fc68ac303a0acf4e90649f1ffc08832bd813795b17264ad9770bc1cbd911bc22a63d0c5723ab909ac2f728af52d9ee74aee9ba5c8bfe64442d9e63e619b01e0af58f5bfbe2c016388e58e8e63601daddadb84a1f675115299d002691a5a09524e23297deee8525e80a8833b47d01937bfafd48876fe584ad00bc5065dd33fb4a4fe29a173aa7a05d082e4084412358953464e2d27677c61b0d7eb4e2d09d3f089e2bea12b85915cbf76c91645f08300258770257266e828f0079b648260432fe8505036505170b03d1eb368600fbcb2bd066fec83ebf322c9ea42e052fdb5a4bd91f78a5a099a289590ae4b90970300ba3c51f2c36f7d7dd044717d1aaa5388a07ea5e281a056d098cbffa28dd71b077f4808b0435789f6e079fef5a225f1363f021b110e6ae8ebbaef42d5d8f7a0428069fcedaef89d8e921aef9f8a8840fbd0732de06f9b9365900e22a175c4f8e3e093c3457ca483df1b202e7009ae0fee693dad02867d7ee2462aaa85a4bd2fc378a6bbd4fce6bd96e717a8ed415730d7261216a2d2ba2a7827dd9635fe185a3b826f97a6f7ae8ff752d0ad4c567c56a2daade10fd6585b3f87df65dd029ec0b094c2dd36914525ca1f331b03ce2bb20d93ec8cb3e91344a3cfb5714e768879bbda7c6615a7e0576b7448d0700c633ba347334a4105610b33b130059e7cba7d5744e56dd229731bf54001614b08900f4db610e57c603c52c3f3170b949e28032ed1b81ca32bd314f20cc197318485d75649e0cdc35e49d7a64e4bf97b71439c9291c92e676358862bfc309209524d10cc83e5f2e8855e67f8d8d51559e06d4e79857fe1d73af2e7c3a36ff0ec32c9bc49e7bdcb65ca78b3ee3b2c6d84fb897a1c6fdc8db29643e9dded104f526e838068116e846afc2a8d7849e7073da9dd78898205ff6b3a52296dd20eccf8fe3b7ea273bd6fafedc28242a77f8621f46ba16eb3bb76b4229b331b2ae06e7a36770391e1036380f1fec820a3642792fc46a099579f7f6673165d651788d8b9b453544f6b48e5e495314f36b2c98091edf2b70399c64d928e63a6c39c56524ae6fc5c5f8aad9496db23f8e6899cfcfcbbebc03c6e3b9d87145391fe5018eb4ec21dc7a1db74ed3876e4b14f3e18c396e8a912d59af3811e7e61636820bbf0838d8f974f404b012b94a91d87d7b7418978a29d0691740e80e530342af20a65d6282decf0962e3cc8b8ebcb9c16b540a2ad73344a5d50449fd9c00f2d0629fae193a35e0bd9231b843c92e31ea5174b7dc6dc3f214012f445bcfed54890838e5be669b48de1bc1433d46dccdd170166d144ceda77d0b8f0fd4af80b6cd5a8c146c53157ee53e8f1c69643c488636a932ef2a7710ed9d8575e21f6f8230ec7408db8850c51ea4aa06da38507f5021b5a8f04eec52c9db6fa9befcb0ee0e387d0a59ee839129e78d6b914fc4d994101c8c979d4ae43584688e6e075905fba8a0132f8638bc11f71ab8346a9023b2eb87223ac01278d030d5a4bb2500384ddea824214638d348f69e7edd9028ebef03a3b2ba235e42c5f9c6e52dbdc87032c45af42b4a449172b5a9a213b08ee54754a19a939add0a7a4e1c668f99fcf3e442863664a4be155507ba332cd2fe50f49c48d6da3c819a56d337d96938e844de5772f94b3e07d19a2137d6641401db59244aabb945e8f81a6061e8a1496b4f9ea726b71eb6d5e507c5cfcfb4525a5e7fe90ee170bdba7b9ff261d197ff9b9937fb7e43bb49ef65eb3a1d96bb832ea1947f786808b96aae0cd58a33976ae046271dfb0bad678a2abc25684e8e09eab34f562c81aca512d15b5ca34417eee35515c5f2aacc534de84e5e878e280899cb383fe096b115f73c2bcdfda6eb4344672e8b5b6369840098b427dcf5b4398e4b7004d1d56440f86bf8a665672d0a4d8c9d5a97b0a0e9b3f5d81f38e59875ce55d9deca21ab0e5e322d65b662382a0fc08c6c2d275bd19eac8530b7869fa2251c2f635a0082863499eee1d5006d22a3f13c42e4cf68a98c5cdca4557c99e440b104ea42cbff1e215c68ae2d584dffb7ee41b525058c97df7afa1ba234807510eb29cf96a9935fe8a262ca6932e8dc63eb4f1bf941daa64a39b7b08aed01263dea1f6093ee94ecc33f2dfa7c9f81fec38dbd7eade9c96fc9b42a01cd3a9f1e6aca7e0f27fa409d01953f8615bbf91b4188924559b29f5f268915a85a8a80b508b904d1a8c2bb1b5e0fdbb90270768314dc8083a2995a907a57fc335199517e6ccaa88419eff8d188917af38ff286a1018685afa73ba5c9966e68988d27efc57d64c7843732a2baf82b094bd21ee96a57a70331fdd6f298ab85f5fcb40743baf68299c0431fb42a65ee38000657ff32333016624365c075b15f6564acc14da7bfc996a957cbb6c67dc52ac0e0ed7fa7347253707cad4598e270dc0d16a080b0f555ad748cea911d2618fbebda6d6d482d71882554d49ff919c60f3f766748ba28d0e144c73ee978e358549a65c55832c6e03d692d0ea78baae6925e0d91b0bc7d869de8dbc3126f77fa3d8f6e26d819e3ee0b81b6fcfde47d43e2d1348f119797b78cc7e9a69b6af7bde19a0d9df850e9f4f5aeba3b687a011db99c4108414e7b16474ab630e9d73638ea4bc28c4b4f4553392a536360167c8da93cfefd25c914dd25c32e79940f47466c5f6504a9d942cf48a8ca43f7873fc1e1437c6ea9c8ba0a6e515e3f92999a4c6d0be599e2e453d3a6dd63f7cd38ff4382800cb7de82c696e136cefebc4631c234010889a810eb62d6568a2cfe9960705527ed62fadafcf9e32bb81cf5111942f254149449f5a887e39f7a206e05eafcdba282ad208a8cc8bc6c547a9a1622f1fe3a3901de1f6fb09dfdd1ab9e2bd0f26af05764b5064817b18e5ffc6e3361cc228773ff10dc9cd515222c3b87a51b4527f0c9592340b48c50e8822a71d0489822d70e04f590e0749fb82b2f8b12fae16be9eee8d08c942a7ff4c7bdaafaceac3c4818725bfe7a83c7ec85137bf0a1deec7334a8955fbfb06045072e6ccffee89ce8741d1a84616843aa437bb7dd2018f5962eb02259f4a854ca3ae7b8fe7eb286895a5d11495a173df65234a8d16d2d5591ef799cda160e5d50f9cb3f681807c2730250d2b6aa6b106b650283c90d37fa9bac02fa609aaa2182b9167fa040bf4325bad23525921bf6eb142de360ad80813eddb824350eaa7c28b4c232c5ac80826d4c5bd8b2ea97ccd16bdcfee03dc30b103ea181a1639f41c9b5efe84d2ae65382ae9860a6996f3b6389f60c0e0e1c4aa3d0f13278483560b2495787c20269bc09ee7c1471739fe4582f8438af0cc423147b564ef71c699b60ebc69b4e984816481865c1c4bb05e80457340eb5a712b1d79090702307e71bac6ff8a86aa8357d80751b99499362d4e911d219bb9f2a350e1bf26aec3574eb1329e300cfbdb6ec1d70b87e246a24832216b852ab4e8f276585b85679ae11b10dd7aee984fabb04dd0c8eef6144777ab41dea5b6797548f6010fad12e7ee819cdb481a7836f57ffcc99b296eefd13ac967b6fb914d4458045082e2f8668e5a80f243924512bf798fbb8e6b59a1ead878f9f867759df3e4a44a86ce45619302b2eb37639029cf168eeef7c2156d3081eac70e920eb5ab5d7e9335c17df693e56b031341edf5fb6be09c72e53bbb3021ef60bac8ac43faa07219a3c13d4bcbf609782f14b680c41bd4f061f7143a077f19738074aaf0c665cecea151a2dd26d02a78c538cb032db6eb7325dff44b7c361bb5e373f8e72b041f00308c8caed055e3e427a4fffea51b0c52c11a30bfdecd20cefa496ca58a1d7c2bff07ddeac83e103d1921c111eb7612ef2395b9a10818a64e1bd8fcc22850c0009655863a388ed13e6b69ab02407d26aad1b8e8ed0237cfa425c7be803fd2d16cebe458719bc52244291a85ae10bb7bb50014edc5865f4432e83aeae8f9e37040ff426f8b41327b9c1eb5d72b2d9d20352e947011c88d668b66e57fff391f8b793f58e33e910611496363e16add51c85c95c966faa52aa80b53891ed45d214402bf407f365ac6b9c3069e2401c78291a7be8d41bd41dc92380c9cb95c927a3d5cf34d1d3f04f78d053ce461447096a95e3585bbf7040db8d81c20d62f90a5735cb272626ecbdeae2362d1938b603a3211571730b8b80a74a19b58590c99ba4dd0d2434c76dc84251de2a0509211bc94fba5a9d8a909ee3879a0994a63e56e883f7bb6069971a664ec0358fab86e95509a9413da6809d9ba47d7dbcb362032b4fb380c617b7c71249eb0d14600480fe4b7f228b7575d780076cd652fdefad92c7b8f3792e0dc7700ca147d55ab9cab7e3146786f6d8b9ab78681c63ac0bed489ef43fb7bbe3e8dc66634fe30c257f0b42de72c80d9f1a8a6097d175a4ed04ccf8d8d879691c8e4e9b87fb3d29109cd6cf6cde2e31f87ba313c18e6e3a3c4e67b284c020865aaac3dab1bfeab12f970159e5e8cbbd9c01dfbe6ce67045e1b384ae6086d1ce16f795a0a817457eab715ed9b5dbb3ba4c6312ef4ff14a65a75d38f2aab83bf717a38ea6d0e73c0b003d3ca2bf521e83c0378850810e6b2cde84726ddd606df8f9a9d8bbf16e5b0a508f62200d0d36b831c9e0237b71b6998c8b6dafa81c4dc8f6bea5b91d069e5f82ebe767a8c981477bc3eb8437db48aa6ab71693f39753eacc2121d11ab955661480bc465701a6d9a207670903814593e020a04170a872fdf1a8cba6bafd4b21b48d67a170c097f01515eb0eb4a3a7df462f7b6ba4be61537fa2bde24ef1c0a69bc088187aa30cff745c999079435d50ea97c74916dba03c7e236ce179c0754a72d0d2e0447736c216e0dfc28115d53562170e0f2fa5165dff563bea7b98a06e995f79f76959766cff918c64a3456deed2f02c46726ca0f5c42375176c059ea1125521273cb16d199e4dfaffa69d55351e6545586149b861239c763df3fb757d7e8c982c8ade1d11651e161c2a2df527407416c9d9a3988c3a8b90a76a0238a935bf23f7a4566af423543ae394c48cb4d6244fc59166a5c692e04804db69d181b4006ff40b5991c15dd52751490cacc35437e2ce6431fe32e9bd55ccb98bcdc04bc58ebc06993a4619ce7cdc5c33269eed94801f0cd0474fcd7969cc35cb576825a660b07a3d1f7023787fab3e5bc5322728ea9ac3753e6edc0e9c4b06b281a1a5a447a3af75833e440e84df1a9d7df900357be3f7fa599095fd274ea8828e3cce3fa3b0acf568bc68524bf45ce8625a92ddff519e095f200dd11030bd9c177e5d5bb4297736bd7a497ef7d6d25a9dd6b173aa62fd275a359c064550f2870a2745bd3d103b554705e08b868f8058a1d2d73a8aba3b4048de7792a4eb22c0acd58f165d3aa7b2d8476fc90f9f9f983b2c1550b626dfe7833effa79b7263c1b7c75e8e3edf78a8845937ab6377bd8f1c05cdd7318ef0899120cc46d389250b3898216526408c1b33bf8ffea4e5e97e510202d0d3c980882870300240637c74681433c17a471e1c92dc00466293102431f851980c3b9afe78eb00902f42ef8207d81b4f59b5c503574580eaf41b8035b667401f6e5a070a7ceb707c6b3e070973873fd5843572f8dc512758775b87978872d5abf6755837aeaca027659883baa54520ad57a41bc92a602cfb6837a06ed2a37ae4e3e65e0d47bb849a48137d9f783af6d4be759f57350e75431e2f652ebc0f5d99c53b4c698a7800777784ba1520467a0c5d26fcf6583172360ceeef52bac3c740e193f8d86a29d5e47c9de07f3be3515e2667813dab578accf6e7caa75cf8fb91c6b3fc9f80522b3fddbda830106bac1b68dc47d0f1e652524346268d9ee83d7e014c24d155d9981636d14215ff2b5fb83f753e7d442d364bcfca18206cc405295677c1539663fcf4dea0ea17ea3a650fcd95cb69753ab6dd00426889b617460cb1d7297c52539239535b18207a19fb35503a0a975017afe3b048ab9a7a600eb80b13e8f10762899f5444a0800ba66bf07e2db777327e22142605b1154c5859d2711bcb5f38c8901449c7a492de9d4146da163ec239d6015aa7aee8bdbbdfee2e650713a9f6ff659671ba8b888ca7d4a6949978f5c600b587cd7141c7981b1c3e8ce21d93556a70c248e10401ad542f30228e2ecf73f1a2d888730669f91ae6244fa3545d1fc60d06b39fd5a6e749efb326285d4f4fe0a5a02c08fafdd8be0fa95bfc00bf22904b1a7b40fe37ee157f35639951d69b09b4a3c66fe68a582e619c5351e771db495cf8ded779eadf10d3b7f73442d1ca1db6f2d7e8210c756fc448e77e8dde200d1adf54be4d576b4162ebd11d4c729e54f390da74e08699a6f794f51418d98dba5706d8a2e7ac1118d3ae0d7a102a19701ff251323978a438e6994e8e5da0d407bc0848774fdb06ecaf6d1f9cb9548e181a33cd828cd0484ad311a81ea84ea5cb554f280d4ece229ec3d3b715f1c0b22560005cf49da4f78f1ca79e37d95e840a4941cb90329ed5e19817c10578b235e2977f1a418199e83809e310ab520142400a2d1c5dac95654d83c02efb94cf84abac779ee3b5bd8d01185f8650adc56e66e817751a31a79f3ce471ab63c3f79a870472b54da9206ae7e6a192de7c56a17d82c12d27555d2f3f19692a27c6b1926c9008f96ff40d349030ec6d9c2798bfc52eeca0cf26792ee9a731bbdc9965b4f282d334a9246517e9f091b27cccde52bab920865c2583e86a655e705a7da1bd239f0bb5f0ec12b0b443a015c7462a739d341948ec0f63e1f260722e5593433b48ab5c1998a3f9e71fe439e34cff4a45597ad5fa30d89de1fbd1f668ac410fa5eb36a2b5461aea39e2fd2dca47bbf5a53d68854a418f5267cc140967e47a7d56980346a15b31aad6554b29c516fe61417d586032e85c10e095f37468400f17b2fcae33a6a3f0a7f6dbc657156371013ac649a39697c163a2e844fa38af5728ead89942890d5eacc84bdf2a1c1e6deaab8635dfaaf640b18287a092e587011e25b8a27294eaafde30a2400675b38f4cc949805580b36e16b4feadb4bd9177748d8a721dc9da3ae90f74b0b6e824cb19f0ede2127afb2af100d64adfdf5ad59b036a073b9fcb8a3c1613dc960bc2fc455b75db9b3a7f1c4750081ff7488ce76b5b8f27ad5cac92051e979d31ddfc63da8a3aff8af2312448c63e625d3d119c641a23da079265a7160ba4f4d73570bc011808150ba88111119830e129d1069af0c36beb414f77d0ff8a1bc9a31252a2a39eb6e3fc4229c254064e865ecc37cb58260ea016faf88778389fee0e3efbdad1627cab0e13c5071f20b00aef87d7823591ea6063854ab853918bc8ce54d2b3d7e0d2fa14dba58d27aaf32fed81da39860d40e3e13b19ae7edd7b5fc005ac397ff2b6efd74b22a10b73623fd9e44cbca8ababbb46281554a594ad7f04904e07e290fe8e7d42b147c1bcd511cf5afc22f82e09a0d90c7fd7d14819274ef0c0b3090e624421054a819dcb990541dc083c1ad2c81a759270a69257ab9d164229ce5c690ffed2061fb28ed233cfbcb37b373c21536ba777772cfeadcfd17ebf5f9e1ebe7748e943559016e4f5df65a6280289ac2f7c7b41ac7191cf688d1043603da6477169356185d28fcc20024b166ddcb331c166d53861f250c8f32951703fe7208ed17653539c1f9c2df35b0351c3daa24d48d73373145664b9edc3b0aebb7660b350ad29b4971ed91d52726ca1cd075430a998a5389c0f6eb37ea621b8ee40423ca13fe3e291927a79b2aefad5578d213dd0f77c48d039413119a8cfff0eda67e82756a08511e8bf2bc9ffbfbfd8685a0e1c728d275c321c25b1a34311d101b1ed140d1d479f31baec54a500a7f20c55e5da277ef93d57b7b8a643854d3e5099a24e3e0ac8f01df7234d33ae7cd9240c1aa3fe4fefbd5332ee022e3cca98ff9ce3a46b17f2465fc419ac641b0180370e71c269c0434f367f7778195b9c1bb165461570ba2ec2ef18fb9352afb88484d337be65e990545788be79e094ffc3bb2a8b883e832d938dbefba830a3883feb3ebc52ad0ad8b75e2a32ebf77ba985cd670e3d16287eb19edddb0ffe8843e21f1bd6147ebed5e3f41d4739da1fe7a8c9009e7e37927b4c8ea9d227737be353feecc0a09d261c65d555fc3d4350f9c5a698292e717d2ac4f1e2d377d7037577809a072bc424a36fbfa5b5c45cc50bb6181d78edb54500c21bc4c54adda6952f0959a1391c9ed9dcf394e09726cacc9a5ff8719168daba59f739fd90911ecd3c6aefcf197c1e6bea6e244ab215bc2bdc7c27fc8e5d85e48bb7a0ae7213127c9b1e55a00731709e1d7673c510471effb16400b822df04716ca473c0a46c95d8c8cb6d1a8dc0ed7da71e278f12a365d95e828aaf01f9790197d0060e468073dc6f38dd0dbca00c45b912eab55573b5b74836557a40c8be5c33a5f645c168d705a8157e7d1e1a93fe1c84ba7fbed42d894561bffb89fc3fc1223c7fb91f3d9b84f00723b670f21df8d9c645ee732ce4d0b8ee55b992d75e10b84bf864663bb171e743da2891a6687d7583fcd46164c78ff4dbfbb4d0e5674b548d224e5c78be8d577a7c000cb856da1782b7db5162a33cdc51e067b75419bf01c4130e9d5fdc0b5d76a37a79471ff6b368e5341b073b513658cfe0ec6a5db8bb82120463917977a9441813d4b77ef6227d0f7f8cca0744b57a454e355f0b81088652d66a9ce0d03569d6a2eba3ef4234905f5d19368bca6418c67141a74c267a85176b87f09278171cc86f2ee4682ecd18b3c77206a8e5ec9fbe5fe38f0b8ad1f307f5cbca484b32ae8c250d66082a0d96ca4a267b4ef31809d83f80a62ad2358d89850f505f0ee786b5ecc5effe7e31c37b6b6106a9773533e96edf918b3cce3776b74d8f238aad7906b92f47cd0c4d1b6e05b8cfe4d7ccc32d7672f71a2958b491bde65a060a76be63c247f105ca7c6a5e7b8aff4633ab82bfec6f2e267dbd61149e8fee91c4c30debfc9514872c5516ad57b92f75e1f806d17c6d78e60069aaf01183b85454e4198a6cd01c4206b3d6e7153b0de50c497f29c82fb7e62d39bff5c6588b0bbaae2fe105a459c88a04ffbf0b4c3085f5a34237383fa3c0dab47103a7c56971320e8b599ee9accb39dab96fadf7424c3be19a9ac3eba7b27b4ef2236f145019130cbab07bee6d104aa44f447735070359b5bfaa98a73291f00ecb1266fe3dec44b50a05c896a03ff97cd4b2ed5dc08a2b582945fc14e6fe825655d36556ad326e49e1f3844033eba0b553908fd36aaec73eac0a93d80f02bd6b1b717a4251eb0b3ba79a4974294f7cae788e00b97089fc1324267165ed3cf856de1af8ac10dcd64d3577b26021f0b787445a75d127e74b6624492e872a96af460a98772a378e000113ea036b5ea9c20506751424a2109267b00e6040cabe9f479085267e82a72458f2e5bf550e82a1613585e7f2d6b1c19dbe7bb73135812ad75d177eca203afec026b0e6152863f49a8f1d4f559ce1013744d595f220fc86b3434aafbd3b30707a4188935ed38d0e0959c78c1cc6ce62821d4287c8af738dfe6e78fd3d242235df62f2bb741c30531d38de4ebe7afa33b8982bae7b415b32b57a8a99884ee453cc3f3ce76aeb24076ffde96b92519fbcc91857128f3e2b3e3f4b84e114ee69812e9505f2c24a33049ea4560ac206fb4c748bb838a9603c46cf207d1c0c1c15e82eb30bce3877598eb3411d796191cf5fce0fcef44e12a5a9baf6a5a5d998a8ce0d227157647aa2a718f49f741e75011765379452fc1a49c2018f8c693ad23a76c47ac99f573d0386d058c8a0e1523d3f264952dcd0e21e89c67e3a61d51645c3c8840d1125b294a2763ef4f4e45aa75300a94a18743e3a90dce18a02b55f0bdc05807a82c55bc1ac891d3eb3f18daa4312299fd7760e51271a85b6a7abd96a8f2cc59746f76ac02c0a09f6f5a840befc176507ac2f2e5abb647b300c4aa70001ae93293a23436bf3ce3ff25b03e3bd1e82add054ecf513a945bde556aa288aecda90189e2e489b10e2f3f9cdb79aa75d3238a295f2b637820d83881653f55a30cbdb8b41b0cd8e6be9e78dccfa253efebf1dbca70dccfceb38c413e743678e9473d8319801122d96169d54317baa54483ec64071a95239d39b589ef20e849d61b22beea457ce247c216cf9f6c47cc385cee1d6ab9a02c3d43e495351a608731a8d0e7c026240be1aad09a5c9d3b3c9c537f09766e6d3ce1f75d236ebc5b2e325822bb2e766162247e15f8beea577c43c298c405cd8b72c6223e79049a9f0af55fdda1df6b36b415c5ac507cbd70bfba794700ac2b385105762bcc75fa21d2d72078f35e31f82db042cb28ea15118dc0d6a78abf051f1fda6c1d4e79a29e7aa2a31cd9809b85f33f91cad0ce0a747a6f5c8f5cb57b94081869dbdfab7095b7105fc5399ccbb1756f3ab4113089d45ef76da404bf6381acc1d023ee7e21eb02359e6548a4068a60121ef4434b90441b8219d7955dfd18f9bbadccda3a2b76fe4e82629e0ae14b9be94a4b1d103cf8750dca4c056d347c78c55e129b6ac4d7818f72fe0e4eef42e6fe0fd76e63890a9dc96dda6554597f4ff16b1c7db28c4977a2b3ac680297fdfc4ada1167f422a0eec1a78628bf06aef70287c090252accd3c29bb4fdad354969e6348f87312a2edbb2ecb3c50ddf1294ece035c4d97da59ab302a6338d3daa29c85f29aebec8b838ce9afc7cf32c0fcee8806acebd46d9803bcda085c4022bd78c8977475cba912fa4d698505a23151565bafae0c53aba839fe1af3f20d14251c857fe8f5ceda9759d614ca8940053172bdf96570940d67c9d9c2dbc758dc044b773334bd9ab8b8711b85c6fac419b691c5549d4f2271ac57cb4ad30f76b6857d745aaa3bc6fb825cd1af97096caa749a28f0c6cf1a88382adb6221a56a267ad0367cf34663375411b0d9cc653fb12c6b4e4cbcdb282364203321bc7ec60096940f4f870b88a232e416220d7862e0bc551aee4ad206d0f61cb03a27886f9b03ad36d38c1012db4c2839f13bb751cb8a1bbb30f87025a97cbbce2f5ec4cec5ed9edf19e706958f7191a212b025bccac85e157b6d60d5d9ca068eb01fd9e85021127f632db968d09b4aec8ff37f621f4fd27dd2531c8ee28c127544a686c9055031aee22453ad4d475138a30341f4ae7e06c92869def99602b745c446e69dc8ea64d6af480c96f603841e2a6045763adbc314c4208d7974c8347031f5697f3484eb5fce6066a746d05a01acb3a829cd1778ddd84307aa95a59577126b06bba4f9abf22f560c3dca3619f786d3df15850f7dcef116de0050fba8f66cc9cc8fc2da1992be0a96934c191ccae76ed351b4737b8c869b51f2834116532fbe87a20a22ae5fa52d0e921412ad5f032ec8faae8ccda9262c0111d255eca1a9a3649a35038228aa8525dc9f84b08ca7dee4ef1c27647b781e696dce667b90cc21d022eab4a4014021110ff1ba4c7f1deaba1cf76fcc08996414696902040eff55889dc099b9f5fc3e9701e65f137a4d2f7e513f0d061850f801cfcfdd2e4975093087b3d9d1df72b75fe0568dec9cf1c35fe4b16dcab43050f1cb4f60962a34125c39ef4a2986b359483fe33d13fbcd09762b7c4b3ae265ac37bad6538a7da6bf852d37b190c0834489a9126226a5edfe13b8ffd418d6421657dff56f446ffec74a6dd09cbe9658929899a9d642b32bf20a4ba4bc165cdf667590b2d3d266126af6655b32467e093f53a826c0f9b165d3acc69d22b9a039c5ed1e6f6b6f1218118be3be379fdcb46c1971b1dbb69be548e29b5452ef11d574f4fe30c2564b9e90429d7900f61ed609f0c2905f6886ed3f620c6b05d49652aa4149bcf0588870acb0910a6dd03ba7b35ebc55467923ac1252f8725126c915181a77b631008ad7c37850ebf192f6c5c5923cd6bebcce2010ff9bed5c4a5ec70bdc6428f4bb5df4152d96fd9c47f25db8361c0be5e09822b8c03c5b28f7809d62ac372a2befb7287bb21a4a0712188a78d238c5f1f07b3851ba3e9fba423ee8ac224a5e5e15b1540680f318b849641907580f0e7165a145577b57a5c3fc749ed5bde077197b7313f788f27f9711e5351d52f38dc75517128736de83ebee10bcc2baf6a138793a65baf5018c13cba05c14df8186b3e3be8389c17c262f5d52ace5fd8e12a86f70d488d0416a7bd1f6027f2e7d3f60a4fa708189abe6544e4b41c496f7491db8d32ece417bfc7abb7bd63519d61a737a946672ec97c467f275cd1c434a4856844708f676b323e4cdfd36fc6a5ab7ed1f2dead024863a2c9a850dcfb78f645a6c9181eca76039cfa6d88415fa0defa081e069790812138b052d57c27ea01ce7ab4a06d9d057cc54fabdcdc8fd7cb71a201228e0263c5b1b4e9018a557b051fdb524d67c8ce7d70c3197a9ab6ca5716e895d488123fd5d8fe25233e1816ae1eedc721ecef4fa9518e7eb625bdd88db4b4af85ab792fb2daad21db46d541c0e3670402e2be9c59717b7272067350a1a3bc2b9a88bfc0eb6483049cd53cfbff423847d2c5aed2e041b954f144a314578eaadadbabe0871b4f618234de708fe568805a81d09ee47a99a422d390f71940fcde0d67c5dabceb1a307711525c4a29ad1593dd8606e9c6667d24e12ea8a2f8f89b91cb5f5ef9566cd0573c820fea481a1734d0aa4637c6f142adac0ffbabd5f28972f977d7d4f89d5fff18f36f244101e77430416fa3b44029aecc6b116cf1ab9926520b8c1c81455e3c72da7c9e816c878523902eff9abecfba7e0cdccdd67f0242c87ee517d3eff5834021b88bc639d9ca368ae7b8ce9e405af1d00a3acdcf94171228a97bae4c03603e72b9fedd4666d1450ba28fad9ce9dbeaf3e63a92e40233062ebc7f6c39b6aa09c2bd6d667aa927275156f8ffb22bf0e9108f11bd1e519dcdd4c8643c3cce6ce59cd8173ffdc391c7b4f5b43b3963070366c2a39d01a9b598c2e94f131fb4715a18705c8700396134d08a371ec4df4cda2ac525ecdd81fc5746c23320803ce7314b405974b5ae16ed4ecca565d93c98528a27b34f3e4894ff1c0b3a204baeb1143f7d631a40f9a4290a5784210b630677bed1f300abfeb53f5433f57aeb5fab2c1e534377ac7f728b53b79494a6f08ea03cab5e739d9cbb2b30ad9cb9703a63fc0b7614dc11ca14f691fe70a3b6741e3c7607c90f6318a3a7cefbc49a8feaf5946659803cee5c8b44f5c5779eebcfc2a8a7b678457a1b0bc45b0207902f605d6f11637cf5aeb095d7c451195a4a5f7bdacc560a7d3fca1017941a3b4d1f9e9a575d54851413d50c348a1ddd971ab371699e04f64b3ef488c930c4149c4a7006a2a4e5193ad0f8c045a4be5b1a52772e02fb6bc1af6c70c791fed4468b489d91efaf0ae4891bddcdb3750c9d76550c4194c3a6b267855ab9e5489f78c36b96c83079b9f7676728756941fa691ad93706eafcfda9ae3893588f473ee16d955580d0301a15ed717d035b2a1773c2ca940a95ad59f8ed45727e7b9698a94a7d6eaef31b6341ac2c5770dc922dc7d98b2ce8e0281042e2403bfa295b2efc668fef4c6a99f33ad824d20831c54a75d319195376b3671089290dee73190749a677ad04e8d9d26e8a3162835bd066826dea5b4910765328dfbe45b19e1dcefc2f2833cb222576f4ba348102f41f53ceab474934ef5a3cca7a4f5c12f1b4c9b208157760ae75f9a5a3b69d023582dd6fd68be340f00a5bceee971a82dbb3e584e160a46bfe68abd17b2285d998a86a6b999499bb43b68a42a2f59c5b5e27299603f76bd18b37818818290ef215693e10f28ac0f265c35bada340ff037bb91eb58bb71669e1edcde450e48b0d3b3f47975d18cfdc10d6a2d534e8f6ac859c02a63fc32b997b5bb935a9321d555f158396d82235c0ec4876a33f374e85e3517854850ad7f1f35d67f0d7d5e069fb6ce53e6e7dcccc8fee38f05fe4d85d068546679742fadfb40ee98850cbef884f0b06bec9761715fcbb9633e5a89974c431f4522e5a7f7dda68f321dbb00f93f7699bf51989861f942c812004704dbfde4bd16d4e5149c99594f345891233ff5473e62caed6c682644a571202122d0e79e1784b671dc755f17b26b56c031a4bf866433428d1abe3eef8e78d79128c230c03fb828c6cb7bc8cea42bf3e38e5b60cfd33ea6486207ed2d5963ef4d2ac56e88046a1a2317fcda5b48edf0053ae81cb8aaf06920fe82a1c73e5498d0f5e1618245b150966c428a54fa74d3d6e867bed1cb6f92eff3e97f54a689178b28abb666d233a4b72a7b263cd4c5a5c00af4515f72294de8e0a2b4af8fce997f208c2687030a5321149b98c2e3599007be93b833c532eb09d7b4f937f250f184894edf9fc421b11801769113ee88d43bf92c1c157848ebf0ddfdbfa1c0eeab9e70985dc0dd97c4445e1018959e5d4b4fc1891fffacc52c6f4b8d027629708d41f194769d063997947f9e2a28636a86e665a27ca07f30f8252bea8cc0fb00f566bf0ac8e3011adb6b16dcdd3a8e9ab398f5d7b868dc2bc6c55cfbd309b76eb40b140f625ecda38b68cfaa01d6253c420a6f95c556487dca25577326b12cf8e228e1b457cb5ef8133d22c9a3c1d216e7994e547d02bcc7eec736a8c6232f9f7b77d72f3aa8835224344f7b3fa25daec64f6c158d9be6c940fcd896b6db7143f1ad06c47f7560099c9558b46518955e0f9c371d5b397361889cb4bdb58294966f3f8985bd2c4861d896f7b1aaf742121a75497c544df5a9b059bd4381425cb593c1b82c8cfe76da5d90b200af4096d0130d7fdce810d2987d2d477da45c540baff7498839f4dcabc014245c361c9bc5196b2bb3e1f69eb733bf1ef7cc5abf1bccfda75d1dc952f94e57371f97d6e0c2e5687221e1a6c8ba53fcde6868e1d8e6c62349c92656c2db48db09e0af7942f37e796c0995d51f43ea3943548d5eb49e77c407ce3f9c8f29ea6c9c809d65027dcd21ffaf0362a1ba61f0921184da4654363c693722892d233bb2b6b7e18c41d0b0f88908de7a25dbf4909a8e56b0616a62dfb284ea2dac7ee41a1b504dedf24ac86f06b832fc320e66846642fa76d7e19b53086b1d95b283a3103d8f34e11b561c3c103aec437289610a03ae79c2e2b8c818c2f9eba4ba5bf27f9100dea1a52363b799b19faff6301d89f57d5f3e365420125cc26b6d81f5e628ad236d654dba5c309d6d67e69c019ac8957fc68aa291adbf3565890d53a77fd7c3d51043edea316c639415d7b813abb8268db9865957490aa37dd2d33fcf437d56606086318143e30f42a1a93428e2d48f2bcade1438691606339607314f112b23dcce4832477cd6bc6f41adb2f162de83c31f93623231d21ec5d36fe893228745763aaa23d0d61faf8b7d9ff3329dc4787947de31dc645c64c7527a1d1aa8803b12da0db2760f6df6d364dee172347db609c271fa5705be09370e2a0bb12f241a22740839694a622f891add08d230aa4e87a760518341da768a36b121ce3cea8e04dd2a5e6cc66c71e345ddce36dda92c0d358362a40f193797736ec691e196cee88c80839758a5068000de45ed20b96501ed269543c7505e35e6831be14501dba825ea065b130af80f623ba9837cdc250e3d100a46f9b578c247fc5fabbe492b60af75fb88b264fbe86fe95ac123fb11332b565c8c309684c314fdac79251bb50da8dc4ad4e0fc0395028c47cc25213c3ea49c8bdb1e065dd6d695f038d44a351a4146ce673df006820b8c63470c6563443b1b8ca922a15fae0106215673a3d4c441e3ecd30187d54467aa23c6e4ccb154f895ea76219d60222c06aa0a31df0a1d1c05f3ec659795f9676a19193c91cb43ab07a40d4eac7f8deb11a03ccbef9ac1a45dba7b3cba2ea3a546ed115c1befab5f42beabda9b5a665c7bae9f836785206eff94645bea4ca0649e7f31ca83cfb0de61fef6ac4a500ef9895d350e3baeb6f62265e5ef8bd0f64f14dc6c562390c9ab001574664678061a6786b144e062368e7ab326eb18e48257b9e00c3bf7e1d9661df52492e9680b0525cd36b2b607ec67c676d21e029a3a54c90b530b7203f99599e8e729e78bd907883ad746fbccecf5ff651cf965f46552cc6e35d8c7f85e6498e188c50856774c70c322b5960ee253672edcd4ca009d57b98658735f791f51ee549cf91ce5ce6f355f64269f82217f988894f731825d6f6ad2d63e0e8bb179fa4deebfea6086cd7047c06bc7f8ddf14d7c67585a8065e8ed1606be25ef4a1dc29e5b4ac5c907261277aad7a164276898e7cecd54a9cadf22db371e627b019b993424f89d529bf069fa1d80a7d5ae8791f79a2e0dfc48755662019caf37e25b36f3b237bd10d905d8ba6d1c79c76b24d105cd55d9246f944ba601d1620719294e8d298603119ac63a91c9d5e33cffaf15c33e8dd807b225c49cac340e895d6cbbbc0c783435dabdee92c58ce462fe6691aa77f113a306029db96c1074546f19d7daf7c486003aefbb9ee971e3cb9446e6f7661eedded8ecb0f804a19dfabbcdc42ab37959021fe8f2e581e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
