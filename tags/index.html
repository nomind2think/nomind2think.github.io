<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e47fa6c79d43bce4d2f38a5ace90c8455d7d974bf66d5985c86c567570a74a915fb331b4beeb9d9b47c133ff0c48205a4144321cf59c8d420401bd4e9c61424a6a4c618cbd557bdc140649bc2d82ac442c15ec6719b2b8d0e553f18820fe87dc5726072c6b35232cc3c01686f7731a2bb2668afb5e1d16d0c52138fd83bd0d4d6c5f535e461553d0f7685feb9c78da92b268278c0bfc0bb3d2e1a5a25282c62a236a05cfbaf5c543c63788121f0a596f4a1bd5c202bad5a0010f2e023a503eb01b51505ad020ebcd33102816461a935438d2695f0d2fc025b8606be7243b3a698f98d36f12efdf42de575a25c2dce3c30107b205d905da64e80f6c03a5a099bd7c2ca65402eabe5d5c8f90b5dcf3b07216bf66025d9ffe1c8c4a809a37f7c13ad0bf7ad8ecf2f61bd6565435094377ae3fa2d6978e6a3b3ca2077084bf5543c26cbbd7ea2c56ff5fd13709e8b43c4c83282d94caf16c7907372f0c4d5acb01b7bfbb83ff071af846489c6bd46821d617262a91747e10777c520998975e29b92e76fae2bb007430c2cc88e77bc38b8d4f1aff01aaadde81698675f2d4bdc9089d2290e88c95228c51e9f6e52ffbd11af56d770e2bcc06b0114c98844e994d5a5732c28dd86109796acc7fad48a68c18290917a6c5c2a87af4991399f530decc4fd4f139794d24e4efc3fe4282a4b793f90d152c9a1dc0d0286ca1b8e97027a0f7094dc5c489824e624d65f06261d2913a4475908073fb3e07bbfd1bc365209e8aa6bf1a31e3e094d6e34544b9acfa819585d825f5b823a7ad6f70e9408d675845fdc53eaf8c197c20959438ae9de4b713f20282aa50612e3a351b6d0ef43431dffa4749083d787c3dc3203da694bd0cc4b78935b3326a2cc8802d83d8e667eb919942d3a738a612e55d043201dae93501b6b1c77ba259199f8c219f57dddd0332ae756dc9a1ed24add43fb30a158ac5a394c5a486b6b25b0beb0a9badce9eee8d156845b8b789d5406239ca309dd873ffccb59732de9719d83655376a499a004a533cab7f769114c1fb9d54d09377ae6ce68e49261cd9366608ed0a27c2e1971fc32dc0e035dd4e66ab319a8c64196e05bccab2358a16204117614a028bb818646a73f8fac670aadee50293fc919f355bd915484f49fa757c7fbd3437e71fdc4ab1be9f380d98bd1d6e3bd2184d9b57c4846b6ac48ce98bbe1f58e219e21b6ae0cfb8b62f0f2de515d3ccbb1ca9ad00f0093209113747839a6d224a15b9a5fe49e9ef45884d67a7d42671273a1853770eaae816df7be93793dcff9d5c9b9a5542c7dfb9827c848e7ddd5231b8969a8b3b677e90051972f834ccb3f5b0e38cc3e12844fbb1191b83df149ea326b9931b750718332fa03e5d669dd61f07241f48eaf3891596e67aabd05788f59eb96b00acc79d38924c64b70c6a62754229e1bb5b3c7b35bcec1444f31eac4666f3f3bbf19ebcd8ca67e586331aa28c535acc58466cfba494638156c8ff274c66ba61998c8134aba892abbedb42acada09d8827e52abd07d7de9df14545bb6087c43c9814e5fb0269f736decf4613fb0758dd4a4ada81019c97656334f0ade8067e1889e1a94b7e5e2d83326718c2496c1625188209d9de1ce6e23036fda35549ad0b749a2f08b34e65d6dddf99d144688bed66216b67a2ebc5efa5936a2ba5acc4215b7e5a39b2a5103f3552d1f20162ba8860b81df7476687893984a685dd8af8c683b41732d9228ce4a49368ced4dbd8332af3cc6d42350ba87043cee4054d966c4fdcf09d27a5f9067734aec5f623ace5da64cd4071864fe28534e226e7836970ff07b6999a8348c16a4e7acabb2a9e776cd11356842cc2a0351859ce4bc4fe903e7e2669699f45ba8d50f717bc3d910bc46c0fa8a1644fd0b3a413bea1a114c208d90661c433a73a7ec205aee14fe7d3858b3717b446b4b2435ee9e6c0a91647b7b30520b2223e08eb6c6d646b1009c1415c81a14b36f28052335b627c4d4260725c84fc6928c8dfebbae945ff2ffbe61f66587a0d330635e52f55efc2ea610af24f0bbb14042d92f1ec3ecd1db084cec00fc8f2e9204841f0878bf245673440148518e07849904eac376e7639d52a79d9f0d4cff3c6da41771562b0ed1530c4d417b53fd985186b1cba345309b7f64a7862095456e87191a5b5ef33943aba5534d339b9891489bf837da504c3407770ff62c76f9b9216a414c678ec5edffa11f93187185ce946e06bef3834f99aeaf4026834d6fe9546eaad327859832d07465888505e0d577a791ce5e471747116fef4b6d7388d8d04985609589406223486ff063b04135042fcf12515258a0c0bcfe2e5f6828a6e6540cff4784ca12d6c8df30876b2257fa3ad46d91ed20c5e6b1492bd7f9853c3ad0622186b095d427b7cfde6f6d149fb01184dd88a9b06a55957c995b7df4255c0ee244d4cde75f553b1f25394da70a497f0e96ab19541c7aaca67f01d8c216ddab6965246639b69f4400f61db76490a2b2e0bf297a770ec1b6199704bd1b573adecc6f71d6a60b3965e5bbeb4944b3b9a701a693b29a4c964efee38da6dccab6d09e42533ab64c49cfe691132062c729dcaea48725dc9cfbe187a770b25c27a49e2b0bf2e7b9db9e8156d85364f108426a6ca062754a30d31b781831618a9842d5e02c708e46f9d7d6e1c7831e99c1344918747e27ee2f5b800ae999e036cb5b6164635c5b7e8b742e10ff327a139f2c6ada75c507042652c07b266a62c25cb07dd926f591edfde774e9f34c0e89fc699daaf0250aedf4888711fa250c9a98102e6c5c928ac1eec6265fe347256ccae99ec32684ec9bfad4770e1467af8bec8c6484537ba0b5346bf97d5c3c1e8020ac26ce9549dbec20d509ca194eaa4c039c8f686717d42fd3de4ac7803bd5879d1a37559389d0321555721ada36a4188f54c2513b213635ce18a5672baf57b10f04918edcd8df633c940c89a12e7134d1b4b51e9f495a8beac0d46ddd9dcba5bf578dcf08c5d6f99d2e1185832735272361c452fb34ac5286e757f8e253727688a851b6c6467a4fbea2f3ef5fd054ebbaedbf807f84688f13c60048e38ee54d136839a3a0f663e397ed625b3a38e34f98fae58e4fdac2667ef32a0caadbfd4f743b78718558e2de24ebec384130824bbe021127330cfad8b7527890dac8cd73d6b4a9fccb811c87054dedbf61f13d7e2cb3f70cc80cd8d2e26332d22838a012a8504417aaa1ead085316f8e4973807181e95a3aeb7b4177ec9180db50f0a88544059571576ba83195934710b7453eeb3c5879a1a35c9cdc12366a76e58a8d3acf2cf018448d4f9bcd2589186774582d45f7d1c21caaa9076ed64147c83a6a41f9d4cd7d5e259e95b7ad49e9482a42fa798442ea712c6c1395c0fb2f6d1a8dc5073ca2ceffb8681c8a9f354a5fc0ef95b8745e91e9cb3bab431ee0859881d519f8df238ec70d1302f68c1949edb3f615d3744116cfa8d5f39c890a8e9b8e2fb63702e710f3740d5b105fa6923cc3d4983a7d018e8c467ee274a98f600e9c387b921dc97135ac5b13dafb75361aa66f370b03e8185bba3069fc352b268f71346df76d1605424b8549dbb531c50ec0115357bd7f75b821584931fff201bb0c18b3bf53f25c99b158a5b6797e2f1b874be32e6d254fb3f9965d2ff49617ac9b7d00cabf9f9b3daa155df01fb128c88a0604da356ee6383e06806dd04f5a7efc03f7b6979889138ae9a46fbf88bd06ca6c73418b6093745d26ee287dad3d2e6025de17499f26c4ac3f4060ff3f757ee282fc3a9c3fa9ff82855ce34e5b857566489e09e57ac022c3cab02d9cf2c621208b119a43d7bd990fd486fc5b4a6ec030271f5438794dfd12571100ff5a76dc355174949030011c594d29b39eee13ba659edbdbbc3c69c0f7090dc71242881247e6c6c90021cedb674bdbca1d7233ce72f76ab009b309f9b1c26b1aa3102964e41a213450013d42384160b94e64dfb2ae7048aeac2a54311c2d925fbc62e25264e8e41491bd0a795bc6bee6d5d032f3686dfd887c46d44807d92bd131dc23770b2f67b34112d1f56140189b51892dd4f3cc1a5e10dfc0de51c442d49cf67a30d4e0e4c85bf972018674d1a5d6447f72ae9bda6b142fdbc7ff6150004921e886fb10a4f4a21a7307a6d35ea91e7d626a56a9f5b83eb87f4bd8ca86e3071b2afa22001df8966132309702deda66882475cd9b47a3e682e713b16f6ceecb86483265c524381f62466f184432b996a9e5eac9ed8380ce4e0054c5db3f920a9edeabdaa3e8bc01642249600443195aa9233666cd790c85f571128c35ebce9b717f18bbc4c68af562f678d55e577c689572d0800fcf3b9b923a7f89651968b5da665e202d56ef72d742463f67c667e8a0ce4e8310a98be170b61bed7e7c833015fb7e91feeb8975efa0cda2389cfbe9f4c9b7bb34b08a19da70dc5472c39ea6f022156cc477fba20695389dda0be60131c1452aaba3b07bf8a37d3dee629a70d98c336ce99a378ed8a2ffc6383da3c818e5f17b158b30d56ab8ce7a2d7576e35470c124d771e91f9d2ddc17e6126c90f77d9d67ae868adfdb8c9495d1573cecb77fc95975de0b539914dd464e6981ff1098aa1cec2feca3631fe559a2ebee6e90ea8bd1b3d9be347a9f0ec6e45b75be8de64417d1ba776e2abf0f53d9b15321400d38488b0eb27d6b9d2722a5b954cb53ddf853ae394ed0be98b029381ffae394ee35bb47015b1599a05faea57ba0c9c328e61080db978f40ca4f5552e4260fe6e343959818e217c1d6debb9c8c69e8928c6d66610e6d672eff639e3781c806023c3c19da688bbfc5b18e8c347387780e1bfdd9b0d730d334ef9e2beaa8ccd22c302af672930fe53485cfa679cc02314fc07d2b9628b4024136393995c57800976c06d82722fa8645ed93b2d6e4e9b7e225a08915da1fded422e509f20f2764b5e165936749bd3fd23b22b319cb3ec2973e350737a86ec5ff1d66e13e85f090a8e5ff90393b5cee60b777e8c0d337ad004ddd9d0f9aa6194ab101fb37a7d6bb91648818d69a347333df2e151b389fb22438031be58c37e345db5ecedbacac3882e64d041704c2b31e977a884654ad4a7001ae1386f2c9470d8fcb3c143ddd22896644cf2f82755172ae8c8219b295653bab92c602ef9343cc7b74ad74931c3b2704ed0ca80c34a5b1dbf23ed853f51221dc82776919e71fda70f56084516600642c4e4147cd641f6a16ee5a9e3f0ba2655c5a1eeb2091e5f88f2bfd37565e2a80099fe9844befe4ad11843dad14e2ddd47579f4c527414dba076ab49251633ebbb31bdc13a7b8b23df3244cf3b657a6c32fd17824e814ff2bb4c764bf4beab4bd0a3a4f8abc17481089d4a710dc64999fdcac4bb752c31f5d0f4400cfbfe5ead5085aaf34253632358c06ecaa8ef9c202a92e3c80f3f55b5dcf32dd983d3eb6f5ea7bf30ba29a2612445f5182f242b37f3b45302b6b79671a7e517c40a78d0b0be87c75a286c0c19591021366f28f79c7678f90c1494feff7d32b36bb0c66deefaae7cd393fb8ec86b9ee81ca62c103a4f7873a3edca5c4a269c113a4df36fd63dc026f98d52de5b90c56f43e22e6f7de24f495b809ec53749b295f67c9b43d01e126d654e3a9f8cc1e1178be4e4eca0af699eda888b3c280fbf20792f41362269e2c0ee6171b0b4a5c94e951567c31b175d8cfe36e44d2cbb34b7a720522c3586876364ea985db9b8e15d30d213211e05b1253a55e0764a2b198776dc780990b0d48a077b0aa8c812cb8690adb7753812ab9dc2f6db3aae3d79c1381598dc156eac8185970cb510927fd0fbd91f78c350905401b9e1a548e516c5978fc2f8d9a288602af3d44c0795e5ab540d55068b168d65227f471c47a327638e62351af1a568a0cb7b4984c9e104f9c8b368eec681a7e185921c2b5e3f6a275d8178ab32d3699c9608691e5812e0d185e60b5e3896aeab45ec0d1560964f5bab403efe74a76f751d48d943e113702a4bace5d9055cee8896cabe08c69bf121789a1cd266041dd25aadb4002d4fe756320bebe387219dbd7cc82a684c7546c2037ceb28944df5a1d44036bc6ef0bd89745b98ccf7776164586a9cc9fd213cd492893b559e4be0b65e0c979db96fac700c65baf3eab1f4e539b1b4f6ab4b4d5b4acb270b91d004a01b3817225000504bcc8ebcdaaf2d227a665b7c5d255d5ef30ef5cf776f2ac5c52467465f195d3c8eff396cf74215db7b05213f8de852f2d54010569827e28a0d83c8e079fc0081fd92e178cc0a6cc7da0f61cdaeb5d925fa212111c0445bd9f4b7de983a31a98eab8ebdccae4a3e8651a1d017a161cc5b5170318e8ce447a1f07b571fcb2a32ae0c0d941d38f85e7b4abfb9365666f7ccfec96ac67f8e351eabad1f47bd299a369f58c6870e2f705cc12b963969f15113a181cfea3eae97bc8c259884fb011a7ecba467ef6081008476261b12889b319e6b7c5349a9149c9e65ad5a3a12d14cdceeaedf762ff9d112a7b6cc5e5d3db8ddd5a5c11792f6e8ad7d563876a59734394fe3a880f7d479cd4fd6166108248b4a252424c973cd8deb318a7c2e98efdb6af4b453d5aff1572b1ff6a6b38cf6b9a86873d5deaa476e65fc734b5f6796a8fe0494471ce8a311b7121645dfabcf70db0dcba8e2e8e0f020c098c2e924995e265a8d2231759a26920cd3a910bd153ac6362d91183b4f63521cd4c2533abdbd00a0a7f48095cf9e3b8b795aaf240441d6cf0c0023fc0dde0918f18ad940afcc841b7d90e9c5a8c91803c9a6ba220a3d029125ae70518b020415efb620a66b8ff1da57baed22fdad353e5b2d71df40bc2a1c4b39eac1f2a70e286610ddf71e62600209da023464d37bdefde81be3a603e34696445a3f380e9414c7639b7e7cd58b19bf80ad9a7feb8768d437395d7c6c21224db3694705c51ec152258af4190de047410587d9e2d40368b9d71fbe9870e0f16168d2846da8f28524efd28971d5fba0421a9b00f757ca947e5e90588a1b1c269eed2cc4bf5f06eceb9ae912b8f4cba1c3f7e7ba55ef2507a71dd7722ee6fc02ac22b0e87872b93d8f066e02057cf56b30b0ea3f015dabe7b671c344b7bc57223564dabe3b75be9984459de47bca922ec9a642e96ad4d41c7ad5f18d760995c1496cb426bf4767f21efb7dc36ff21bb105827359e126311e8c7aca1c5c714a45844f6e40d6551fe8462a14dae5a2a01d05ee1815be0f9b6548143ce24e2d46e0cd7faa6a59e007e027f6abb0b87d64e7789b0cb4ca6469d40687991f0909c6836cdb1fc1340cc1e90e2ca84f590b5cd43060fbc320d32d741f7d5ddf22cd015ebc7547a031775967ee1a8693626111d3448d138c3bebc168541c41201b7bb80a3f7ba111ac3231fd483898755b86857cb739bd890a0e5c81f48aa413f3c5e8daca612858acc6e9373e535530126fb0395631f64dc8b466b9c74fe524d2cdc04a524e5d2034822a47e7123bed64f9d81dc226397bf9dd2e0f5b8560fcb0392002d73c1f24dbad1d5d935abbd7564751a945767037878cf7cefaeb3bca8e4c0d8effc00dbb2ae4d205550f36820d34ffb4db3b0d152cb02b8a6177d40779b78419555846608bc72f66223135e4a6144624eaf7481958f6f2f1f4d3d3ad1fd77022e7504c15f7f2abf68473f94bb0df7a834afaa9beca04c6d97a0b75207a102041038c8b403900aa53b2a11299838ad35d28502f1fed987ce9a658ee68437213ae6b6eed9d6aafa9732786d2798788a90516552f3839da16def70d83ef6da5c8044c9d0d553716d6f5cc920b0742e87c17312ccf8564d92c28ea0f86ce1707e126609513a510e4ccc0ae5dc8be36f8630ff6ff1e9c6a60900bd8daee6a0fa9b8e538de6b5a031e0bf074720702365aebc3eedb2b320f0301ef0133952d354eb8d18673e6fc34df1b5de0e5d64e7c395efef1d791b01b66c8c64672f59e72bf26e1fd66aee9ed5e5738d97f9a474d74c232d21080e0e7b7da18f2589782996844cf29bf28de52e138a2cd1a6adb03e3606efee4848bb6d410e5c9121aae8a90e39c7fc148470691a4ca998c5d54785ff16733e8b3f8cd884e432b525b48e30b4889a4ec74e3d54a27fda9bdc79cd39f8e9d5769049689443ab671e8d5795a0903e84182620c8e8a0463673c531f20f2aaea651e4041439ee931c6391f36e18f20907f76126e7ab1532b0cdd3de63d03053dd3c6a95db13e6e70e591a91642f6a226ee2a5c9bc8229dd8c11b5100d12bfec08d76243e7c41716a0e36674642b9f62c0ba60330a219c8f210b6881aca295a22253ef1316e39d556f868328b59ecb84a0a4acd6bb0665d3d67879034a2a3f747cb6de10ea204a9269db76c2bd739720340e38769c13d1851be2af1838b9196e389d01648c4a8489d9c5c37a68d4617ac386e0e318f74740027deca2954d724da9ba0fe946b404e3d6a1decfc6719c2a79c67d1583a7c0d745c89825b489092ea34145fe8eb2b3e16b94ea49804a03aa2d73bdcbfd5d9814bc4455b62d6f2f7603a3adf36c2049ec83a9c5d59fb5715987c79cab7c8af1c23ce4665ddd01a733a6ee145ad47ee163060e4fabb96445e85cc7c8fa17c46da88c34f4578cbb4ef0c22939b190c560784c31a0b804b2561ad80bdfa45feacb6902469d90794559a2aa96e200be878f060a25a452afd1544bef1a53b767fc644b3208c955e8a57603b1708d7823ba50fad3da6fce29aa6bc865d4efc8f7b3a0c71e826ea1367c6a8bdf683b3c7aec317bfe57b7052c02e87a223342362967b6346cdc87ff0916aa61230d61936e86b675ff40aef879d74b2451fcee9d443f5968fa048e7e8037b9364f628e4d5528d0bfe29f2e4f4c141b9acaaade100f977c30aee3b795c206d260df67ae1529fe7dc330d03f033b89b89023ae3f89a5755c85a9f9db29de39a4f28d4cea523e19c48a640e5e161dea89cad9ead385ca48d7bc60e2d9d133ec9c35f05423f9e34824540f08184cd89ab3f31e3c619b1baf16dd0e84c1c2876220f5486f17f91f38c91ea4dd05eaf8d2bb8727aafbf3dc41a35e498055c693cb5af03e57711f0aee6928daffc214691dad17f48af476e42164cd7aa202abbd93234350a1219e280aec768e226a99c7b6827bb0db439002c5633261040e5bb7932e1acf26e140896fa89b53e7a34b8a536a0233d786a77a99577869db18c0adc34be79fea2e8d55f9e0a7a5ee860c29874df2be036189bd9883de7c1ac0ddca65829809c1df7dd0e2a2cc6393ba704cf56720660a05c955eff990c4fbd1ce0b681641516246ff6464754bd8680a79ff96a34f23538612aab1cb74f4702ef2946a4fa92730e93308699b57603f76141d57fa7f17bdabedaaf02ff689488842dbc8443ecb1ed7115cf90c36c33dd4e8fe777afd0ce9d7fdb154b4683f8f61f20b88b66c51d72d4a69a222a0a08ea7f58f1ab8be5f410f2cfd8353cd6d86a39879110a137f25b28efeda69bda6d1bc6c4c8081657a343ed32cf9159d574d8fde122cd7f822152c64d0d9fbe8876f4176520075ddb1bdb293360632df3cb8be1afbedcef28a48ff8ff40d75846a7b065886ca97feb2ef3f99eb3ed42f5a3fdf90a514a4b739f16d61b5dcddc39ffda161f522ddebec2f3e53ee09d64ce85f1ae08a03974f33babc77f258d9e5163a2a3ae82ebe1bfc9a0892fa40912b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
