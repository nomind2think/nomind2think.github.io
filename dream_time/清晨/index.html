<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9a61238d93ebc863a7ff4f3072ad2912a79e9df8e359579eb15a655bcb4ad7ae91785f7ef16e0465eeb54e1ed4cb784161e02ad44eca3fe0ee1b927064d9cac79d59591ad6d6d5dcd2da22362c82e6c37de6e0152899ec73a10879b517355d6fe4ce037d54ddfd0e6f61d1058a1212734507c41536377a01529d1a90bb8c3efe2f6a0d8310d9d7311d0c72cffd0b28952ec2f9afb96833cae6ef61a250d36ad30dd3bdb053d13fcfdbc1867bf6b8ba40398d1afc3661973a1ba1e0ab82a64e99ccdfd330b949fa8414b07be214a3897b20511d3a5e56c9697f81241d7770d6c41d6c96c2a9758e21524b686b5bac58ff775f7a41101d92d93747fee702742d43c115321c5f861d3156dc04f9cfa1c12f71c7a276c6d9877d48ca037c2a527a40012417df8e47f2dbdb54bac179a2d41030293ef32b8e30884ac5c8d22051ee28268f68e6d01036312a45064a7ee8cb3c5a8d14e305575000b77f360b335179be38d8a85508ac9e785edfd210f6cba98311fc2cb42fd2999b1a038f82958ab6f5ac24f2832e9f322328db8a8f6de2776c94a0a6b9aa6609c98e55d542d55ca248067dc3d2ea918c83c2834eff933a6e4c083a492d2f3e76226a633c37d58c6de54162f20e6bfed0a8d784e43d59adaf2191b53223221b4801d3d1a6821ed97f0f85d2df2205920e9c3fa328b8718e974ea81698a9d5c0685c7115aa4391763a7f283b7d01a335f9c5045856a77fca66e7f76e048ff56dd259312dd4864d95ba2d52761df65675ccc04d7b8f7e6ba2113d490036cc02a53b6b53702e9c3e55b59cee22b8ff1f8d455eb2f1601658f4406d65fbef6a67b649f9b06c7f2bf5f7ddb653e5ec0d974f65b05fed4deea627b85f35ccf2b7e71193f21278b94ffa5ed920f70eb78eceef6c93f2c9855e03fe83fce208e4ee0679d146239ef4a7e324f088fc324e1118afb33a2e39d53e19ba089731d602d473e9e7cbaa6885ecedda6e79d94185f09540784e12b9d6ea43f09ed3177d1b469c38282940cd65fdbffd7889f127045a7b1cdcaba9d437a36f19bc2dbc7a6a6137a1b98b56867b805577f4e1011e6305d9a9604784c492b3e099d54601372e7e1be1efe8253a5538f1060a04ccf3de554f4374dd03caa7d90045f7a478a4fb5fc9933c400db36f7ba0348f2c1dfcdfcdeebff01cc3facc165a7375a71766a4c6f05ac02e2b26340ad81524a5ac729bf3c35e1d7c40f38750ea1c93c3d0d3fe33a6997f8546f4d0a7f8af25097b39909c640d13837f042ef2ed781f14e7f84077a56e5d7976527e69e3a653b8c5b66c7dda749357101812513b2e1cc70400de6322ce5f3b0814f7e14ae046fcc7d68ead6a2e3735ff4c9f978a435957d350c4b97b8c9151a0b42cacd3e29571ebb5f716ce11968683e0b24ec7fbc76050ad7ef14189eca68ea5503c1e331112fae9b82c0b881d47ed21baa31470004db653e37303cdadf36e94df7166cc184eefaa835ea2ea2c0237217bbd4de1fe30002061df997cec44b066117a26278b83b422243fd88093501bcff78b1851843b4938e58c97e0c70ec2337103e9f57673c6cc2bd64ab9a6a857a05d181efc172745cf03d7e0268c423cd61c8f40b41d896031ccd894851cd49fdde9bef238c6e081c859df08296951e9bc9d8be300830b7c351d2f02f0f24bd3ca31cf7ba5cb6bfff385433409e8e92d16933e0c40e2d2324aec1e2860f5ae81908ba402636a7df13991878c94734ba2e40f036685e1115ac58bb1b4b14ca542abf938af29b8134ebe457a808aa07bfb5c2186d65411c99e9ffc00ff67f9f94813688007c4ad92bd9b24b3a09a41eee2b1ea3bce3b65437326ed76b288f2e30fa51f01d66b938fb7f40b931c4f8f0c333323af5651c66f289eda3cd18cdf1d5d5cb9084e3e21f35e1ad3223245e4891fd0ca1c2e514736fef3a4e9ad4b2c67ceda49059721c5e0b46123beb85411589a7c59abd422b15dfcced91f49111e90c08d385a5f4f134daefbb840c0cbd2a28d30751a8922c0e25502be511cd8f87ceb138154ad4b9c981cf7e7ba1776dc340515f203e04efc872416ab2bd8c9e90389494759dcbf51ef7bb56cc8c1a4b70e942baf7e77cc43a378796273afcc6277aeec758f270fc2491ae063adbc6205100fc9262a3abdbcd2121cb066af1d2ac98ddd3a65ac0c8b5c6d9b210e39ed86b6ccc0592deff848d3110740cf702b7c0e9faa0ecc44023db830c73d19e036267ead2987e3290d4086ab1f606c5f4838492dd74219252b50327168ec7dfdfd04162bf3d8a27523e8ea05f6d1046fac28ee07ca5249512fae75fe42752c43a385b1fa7b815b7128593a6ec39b50a2d11c6c9d889f37e5a5207d8c068963d1010e61b28a02c8b405562a4032046337a64af01bb35b77947977c89a91c910ab7aea4c0410a63ee2c0f7884589f22717f54a9aba23d9bc31fc64441166b3fa4db8b9e60acf9e8e5913094240d7ecf943a2dae28cdbc911dd7048314e216a050b61d45bb053b588340c56a321c0d803f0101ab759367f7aacf8241006b98be963c7744cd10de5c29888e43262855d0ffdc968da7be7c5aaead16a8d2bb6570a2a5d7bdaae18dc1aacee850a840f32de069fffbf3bf6e8e998385fdceefec63d540d0e5aef8b8b8bc877ff423c12a18a8a6595a9b9253bddde9492a2805b1d61298084be54ad6847d3dc97606820763eb4cfdca96d6afc199639595776e00df713e448cfe7e2f6ba41c5ff252bbab97701856bb0d2f631405227f3c1c79006683a6973c6325cd552acf36ecc870474a90ceed4faae11a491794fc4617520eee311123063a511fa7128b53c07986f49b466df38fbe51a7168cdefc39127f8d8d77f66029c9de3529034cf8e72a33195e541fcce737cade4ba52ffa009c16ab233d3c2c668839ce3e3279ff3b963732469f746f5a34c7d05b7d9c10daaf5a659ad36a4787dd1d85575745254dde3f346a3c132dec1d65070857689c4822d73bceb945028704ff7270dc5982d8d011aa957de2b55170212b6ceb3f6a729f10ba66615a1c4765ea7b9e8878da7604761e2ce29df509ba55ad2c97da4740e853df0805f5a3a6f90240878c44cf0a37be750412b0990b4f7846f6df0cef5cb3070b789a373a1ec539a3303fe16b53f1f86b3306a8864dcada5c7580109dfa8619a61abb71153edd138c2d8ae1b872595fe7e3f7b9e52751af11711176f624a0a8f5077467e2c807c44b83460019ca6b843eb45f03ddcba52e66034b95b34bb0a99df7e569e35802a07ee1a93ccdc37e0de4fbc8dd6ffd240caef0ab7eca463d39cd16def7195fde0027bae4f9516b40a2dfd658f49f902b6137a093dbfdbb5affb97d1c55e864e6ba5aa47342ccc538c816447796470b566afa71f2773d3a30b72cb383a24254efc2f271d28439da59f2255ea5173ad7a28ff23b424feff25c018fc26eb83ac0b0557a04648f80686b385c590bf368b1b5af1d6ff7500a796748cb9ea8a45282b4c4e21d603a6f2daf259c32a7f79759cff8f8ba9736051a4d8bb60e23e8d8962a114bc7f24de4c938644cb90961bed146747b1ac77c99c70acf35e013c1d7133d85eda493dd1210a01351fd7a618d954d49b71154ee1a39473679cd555f20c3fcc7b791cd96e87e45a14eb17662314f4a61af4c89b939e80418f628dc6fa57b65ceabec36ce7c43134ee65f70ef0a3a0734cf5fe342342747bd6dbe82d0015c6e7c59ee217e41f5c1c1b81d7c9944674e4565e029c23e68cd964478d9d76cde3560ce7348b825ff45975b9c18750864528ef5657eec44074d77b43c11fe6df98756ab860c42990f116a11460b976cc9d76fd5375ef399b8013deec4d03a861ba1e94a59d0076d8d7a88f03a2e2b21894418ea068a16db5f9f1b4c2ee0b4dfb728c8ffaf685cd94830f3612d22ec70e03366324f40685c6d5b19b102d05a6df47ef3476e07b6ac17138f95748ec10e9dd43094ff57d97e72292a9699fc3782aed57340a99a6a9034e92066a8af4d9450e0e2e1f2207bc9bbb7782526c6f0a4eaae63d3c50cbbbf67abc38fa37673e28d6daa72c71411a4287cf6aef9e770f7ddcc73cb894cbb3edddf3f9108264695fb8b9e901151700a26014439f1e9c6d180cfc9f4f714e7c27018f3afa327b43fc9808c7dc49c99aba3ab30a86aee7dbe23b4eeb60824f5da58bab2c204091317a255231bf45a277e108d291dade8ca54c4c75d1f2b521d634627515a2101eebe76b0095519126b5aa889cc692e968913f8bc2d157161b13501151888b9f54888b4c70fa4b229ec66a18c12422a4b1c49a4d3a047858e8f2c4be866994d8cd1c43c65747ebe0b6aebf7ceee33489070a509931e89d734e30192af6c16e4b9a67a4d78f4e8faafc4f1f123e43bc6f2e40ccfbbacced91ab87fc9eeda7b0ac8c738fdc196a328d562e76a82c7a29f285e59fbf3b57be368526a7747860e30f4f83ffa06a1aad7e0ba5cf35e5053b22a11da9771c85d1bd00481fdcad2d70b1dbb8d15c50daf61789d4979ecafdf363ba20ac8ce83395c31ba274f59a55498896360c6bd93165842e5af7119b0746efc6d661d17a6d7e70bef2dee4f1758355b5738a252e307c6c00487a5f5e97dfcd32cb649f58b46970299b3779ba861a3a421564562ff6a17b72ee2c9937cf0b6a843acc5b5e4f9c03d6071cafe9deb57efc81f3dd03bb9cf20af503a4ae3b879cdabb1688423c3e610fe7fdeb6b1bf88f30aff7a6e20c8717b579dcd1bd26ba16acb9b033e6f8f4fe522bc01315ad961e6aac8326c530e3c7319e1d192b824baabe5f527450e610adc117557b875b59e9b6b8801c9c140d574f3be005687338a81ab1369f23c0f6761656b35e06f5ab57ecaba450e535df6d60662ebbc51ed8328b3cb259874a7bf88d5a645e75ccd129b1ea9894b2922cc97026a085f499024c5f16332028df94210612eb0442ffb6c257a20bd80fe91950faacced9cfea824d0bceeaae126ec0ad5a8a60a8e2677da1f2ea399eac45a1e934f18cd9a0e645db6b602c10507b92fef9dc7725a1251a7fec5170a35dda256f11eac012928aec6e013165aadbb69ee6170bd7d0f7156c697b4d0a554426709425e6ae4d062a5535d7b814283d777a54e5a1cd2ca19c6401efbb7e6d2d4f0bbd3f9c85daa9e4d2289a078aa2bf16ecc57412edba2890d730db948120f054e15c0753b41056120f9f3e4f7863b063a2f333615652de0c45f1547dbb4039e73cbc2745bdb4bf2afc0a7fabfe0a21bb034e00cb5f93d15242d8831f48bc10bb84783d4c5d25e5b3f6c4ca9d34341eec17f3c1d99b6f53100fa8ab200dc84166d667f40dcf0bcfe7bc422ec7c070c710872125c127c17da306f693ef933e174589afeb818829cd1186ee6f3a5ef51c3f277a7a909ee3b64a9a206ee1a04ae5574c14f960cfd9f6d8ce8889d10dfe93803b22bbf28cd7f53fbbcffd804a7800b9999b237df18fda38e94047185c05bb1a5af214175415f03bb46d2ee42178ad4a0ec12576eeb0743162fe4b4c1247e125c42b2834323ebc9ec83389b2763ae399a45e5ec9f0d588c679c5b4cbe924a8fb5c7b25b25dffc944acfd8c143f8f9221f132c703702903452b793aa3cb64ae0ef1240a177939c75a5a86ecef322aa20067337e9dba3268b26b101759ed80e1b6c7b415c83056f89e68b819b56366fe6bf7e51c900a98290f7b19a9a267672f8c348b2af455fef12756b32679015f28668958cc34926860dd0983450bd49b23b17f51c6c63d000a680bf305f57ea015a88f9d52d9b47c6af5e0224ddcf8e9d7e1dd78a79b1667652187c990d12f97c2a52eec520ffd8a80d836a82649c2fc63142de01e959d9df914f5b5bb0af8110789c4d47e859dc709bb35d566433315514b212454e5557b41987c3a4fe4e63cceb7b7b6e0558860f63e7e2f0b140c2e7b8bc30ce3ea44f51f5b54f349672ab7f8155599e2a576d8a837bded590e15422af423d6267067ec7e2ce66689d14ca088cfc8a3c23ced613361f1ac049b7f4d09d6801cd936638b30498e41cb14a937d65413109875bc6e4c896fc654e0f1633fbe11fb63f69c4418727547eabd4baa1195c686f400a186c7956130e811ad59dbd8a701807ed2c9c584b7e4f0a28e738c956271101793b072803e4db8097ccb309fdcd0e085cbcd34fe35843695c0910dc8a2acd433aebf3983bdecc8c3cd25483539dd4948a140b7ce84a86302403ba71049600a7ddd2ead1a73e3af2c9280bd87760bc6503c22b8330e078b4fe6462e417eee1a7bd8de2252299e028ca5f264b59271fcc10178a20fb63a9f028543b510ac41e8784b5b8765ab76c1e7a95b62f1e12d95e9fd0bf21c03d2aff095fc361e86cfda17f96d339cdc9d6ad902d058863ff3853a9932eecd413498875f09d2cec1f4e42abc9e96f0a18195c39ccad8d486699b45cb9010f6543bcd25c5b0fef827a09cd93aa7fa13d9f5cd7eceb7d843ee90316f273afbfb1a769123777e13a7727646470e5213e516e8d59756025797c65ff4aa26668fa5c2e53bc112e3dcb0fb0641b9b01527acdac9f17991a68523c5861be079505a5e561b2cd1524d0a0685350a39304da4c58f61c445b498720d40a1139f254dfb3356423ea8a8ca9e880e48d929494d0c88ec52af3566a3ce88fb2e0467648948d643fc3e0c6e26bdafa4499d8268cc9bdab03d2faf03df73148c72864bcac8fb99e3def5af2cb23fb0283fde822076e7d58aa05a0e459aadca233b4923ae4598352b2a3200ccec6ff91cf62535ac1d70bccede07e37589ebe38ca329b3147c8abd7c5872e9300160fb10fdfe8adf1c03b480a7ad9bab8af702e93914e8b5e48041d18e76e3043c8975924334f3a6b72cc5a474109a8ac7cfbb522cf7c3bb2c2c3921521b9392fb0418a5fdfc5ebe1cdf0e38498a3fd2c2a34b96b06934a957e0f2d50ad4fd0f6b1004c7666c9c0d3b49723c9ddba67aa61753c3060bc56ce546256681e9c1111b65e71efe33a54aafbc3ca9ddb96a30644ae197d9ff169bcfc648c5c5f20e442f015cabdb6793d24797c97d37a8b9f4d785ea4d7b16b6cba29309a940923bb4eb48702fc1e6bee5d1901bdd92291a0aae41409478223c7ec782e2baa49fd230d818a2d878ac538e962e4984ee97c75246bca07ccbb84dbe0137e48263f00fec6d567cb3c6e00aa3daf748720acbfa4f5e96f3704889242e54591567728c8b7e236fcfda6c2a78cba3de9c9e50ae95f9ecd90398c2240e62a5352607ec35ef5a3f86dc16f50ae4c59ba989b0797761d5acafb9feafdfd49284455e5c883063aa60b3d9b17b7661a98db440803221d814b280370da8b6b2566a78cc1c9f327d52a96d3892f269d338827ca72c3cfd837418f67b988d5defb5ec7560e6ca6fa16e54a32fc33526fce2da35813eaa8ef6a702a9335128c7021d1fdfda0df95b8acee454ac5061bdf41315701a3e0e6c7690f8a8052a7a709a14b5715a3702565218172b3571731f93f95df65b928170f6b9348192c897446ef259c65706516670875c6807d50e82b13a74e87d3a3acf183c9939ee1e153cdc3f38e37a2a28962b64e7109dd167fb464e0964f0fd74bfd4ce8caebad0b43ee641807319df0f91e6ccdf505eb7088aa5649e919f27cfd865e52e628b4bc9e39f42e72b2dfbbb9bc368a39cd028579e0e0eb632b96bfbdf961bf69b062ced1afabf879f58e4ccfa6d41684f4bce5741fcfd9dd49690cef45570201d9e28eb36f1a1c4ac50131877ffa3156641c51a021e72595dcfb9151e661e8466d95abba92734040649eb8631621467ec9bc65a643961d9425880e27e9211e4f6334a58dd10b0fc8c6f20342f1dda94d3098d3e072629fad9b46bb45db64ae3e73a254e44ed89d7458c07eb5151c9fe016072901b997f87f2d9447c0355f71191e74bf01b80b0d6bcf5065dd962273d62a325faedcfe0682e326de57e23c4594bbce0972a8fa142491af937733bbdb640c89e1e193642a5996b092d799561c24dd57f38ea8e5b8e00437961cf79b0e13b30d0a788856f6ab2435fd5bbe0e1801bbcac59497933ad6d44313dcede8fdab3e326e28ed9aca200eaee74cf4fd15218c9c30dead387c6931385b4d42e680e702c999e29f133e7f826ac6f78e420cd313fa2a5dddc393582c95564b3f71ad60c0ac16c0ba0b3d4e0cadc50881b821c16089f1d13c598799a3825e7979871fe4af18750188f5c7be4e032a10b7cf2aa166bf28bd1260902f10014060c3feb94509afb77ee054ea60ec4205875114c0196066428ac02643a62c8bb8b13cfad413ac9bc975e2584b0e5ee41507dc1331515e63450428774bb1f2288299571f12124ee9ad46c6d897fddbc72626786906179af05cc8c8ddd3d74a910e6b224a11fc2b7104dac46c3ff4e8e29db680c1e9e48ca9f4ed59295dc7896424c0913a8a42d86d4a4962898d3a7c11321ceff367eb10ffd24cd7396d3142c6c2f6036f14088233b9dbb1a88b37ce2ef874e9293b524fde272eadb16a24dc12b52eb68c8000a65add50eb6e619463445f44673d09ce9b39bf5a84504e8b51f85b51ed7a387bf5f7fa2c5822fb69bb2d078ead1bb349947bc7feba0b4205850014915c9ae6249c1d704ccc3eec283e7f9267cea6fbac4ce9a46b397f60be83a51361b902cf06fbbf8c3a7ee734b3a7b340b021930bbf53f85f0338249a70fa137732a3469f44487fd56cb607e92545864e7e5a65fb6d801506f67e0826099937eda7ba9001d2cb5932167aae7dbe2c32fa90e2416efc1b384932860c2670c5788e9c6bacc5ee091f053b4eb6be05a709b1ab78023e5ecb2aba3929d676d62143267a1f58667b07a97ad99f1ebac078faee38d6b42a914c960ee6b4189e14a7d8a695cb43a84ca4279ed60b258dcc93f2898c048b0d61e846ba575ec28e11e0b4b24cf7688162a770ef469840c0b2d91fd4eb969d08379ca85b3486699a57fd7e0e31907f904526d85b5d33191bf6f0b55e0f9242897a2e7588ec517c342333f5f710cffcbe3a61b07ec7800632c098b7cd83ebb235f9efc223b9a30d0d7e1ffbffd0d533dcc67bf532c593f7ef8b1ffded279a58e3cfba05ee685858edce8c401f4cbf8d5a34753a654d17c6af8e685d4a57cd6006a4d492c7e53c709938de06f670c838f35bc4ec0d1c01514155faf0092f4537232d7d2d514d57bcbcf8bbf25c76c81ad884be8fc7b9181f8ef2b2e5b9cfab8f914d72400b8a975c2a413d8ec93333edc0dedc424d30b63db69e623178d57795f18f96a22b137e26aa24e5dda19405c6117d7a5e3e789fe0569c078c418450b41d81561c4a919391648af485d1e47f82c89520ee0e3138b21d64255e0f6e0521f1bdf845af5256812ec80f11d56c1c6d5d79ed5ab37f7b4b7dab425a56fead2aa77177c83d46846b92ad649016c79f3551024c13a696650c1c4a4b00466b57e9fe2dc74a897ab33417c40591880f8ca67d925429304197a153a803197d985ff5bbf69064e7e207f2ef2b513e223717af67b0600462dcc9472d829d7ec546ddf52ea44ef024a05317e65632ceb91e7e9740ad4921da20635a5f276261e2b4394a826a8ed3024cbb180b27dc532d58602b6001a7b203033e31139cbf566da967dfdab81733add9735b8c0bbacaafeccd99f79e0c5dbd1471cb2675110119d81fe30a64624bd708aaff020adc90ad4a2095bf1da8d87cc6ea805571e8b2394c312a7cc3c480f38ffe96ba9468144cdd3f162a48ee8ffbda5d6c0159597427dd561face130c32567d2a78cfe512acfb4c6fcf52de0f4602779b58c71000756634b24a41ef76db3da7e72593f326c28bc3e24a14bbdf373b105639801b56bb0b0af4f468ba5914778f2b88ca870720721fc7f9d98790933f86e6eeb4c64d22910f285bd2633082b033f5836119014cff1a89ee783707c06cbb9caa4f8bc1c661d78a1dbd724a5cd6074395f039c7a400f559ce220930872c5c3dfe26b4451b0de87c7182c6e876dd8776780d010299edc388aaee0d3cb4fbbe344cab0c7cfcd45a9dd9849ebffc1e48456b61fc13d709d975c8427e6a8b8acab199534a11b5feb4007c99673940632d21e24637b6f7407648f53b4c6e80f9036ab52a697d83b986661dccf84c0cd43b56be79e817464b448883016af5a2d69d7add074460f3d0f4ae01602c9ca02cfc613dca33a778f4f5ed2e0bee45cc3f93fc9b34e71443ad65b0261083821be33cdb8e2d507030a7fa705e77d65c0e7d752251d5abdf6f8a01100e73e4e465192c4b91e6b327d121fa072553f95698e0d5c81065aaec15e5999cf71697f61765026cc213062df3915fc9974d7fb34795310c8bdd73926e912b4ad99acbc48af739e2756d82bc2af103b6ed22139604f32e7445913dfe1a26ba3d5a840ba018c1a90d3e958f1d9b9c43cd230b11b4d1143d1b038cefb3afe86db3cd398f8a433878e74956b6d1680adaf2fbaf47d1bb5cfbdd99123575cbc434b397c8c835dc8f94823c11ca76591816e6b6cde9e395753f81afab65bab173d3c788c6203d578a1979e236f93fe2d7dec6f6114121a79ebf77db334a61123feda330cdbfe92dee0c82f2ef2af5d985167253ade2886f2f3954e3aed4d4ee424698e6ff90e3fea7f4f2092a56b00db2cf51dc58285df67c6f898ae164c551148fdb5a08c72153e4bbc9bbf0d03d0fe22e58cba4d48da1dedda7465b4ca672a45b68607c9eb3ccb6ab65b80","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
