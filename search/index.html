<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ba65f161e2c63c98a68cf976da1c000479373b39606bb6a078cb7ca1cef5ca0513a3a8378090fef7e98f9313e526d8da93f17906c8f0b7a4e300221d8bee135777e31c669384ed4957e3995ee22237de6ebe97d0763a2e694afb5da0eb76f1ab2ac507def8621e11a170b1baf36bde4298f06646bdfee495ed5a08188f31d127f53496cefc51d97d8b2c086e1cd5dd4f5350337c9dfb8c2d518255e0a95ef431dea5082feffb460035c58e55e6aa8d6f2e2fdf8cc48c0bcbe1a262dcc01a5e87dcde7227505236b798328ac27525c6b77ced5447169eea54265afbccced273a0259825e3b6436effa4efd4b8a445153fcf32dd1846202559ddef5d7af3ca3fd87b5a7baa60aeafe306e8f2e5d4c435bc2fd450fe2015701ecaf8bd07ae8e3d3fb672078c6e4dab1893a8d5388b93a626bab7094408b840e9207ffe9041aad0460e6077007193f7163f7126c9635f7e6e384205ca038b6acdcb4273d96120560624cc51f704d43930119663f7c7337161fc6ca8d81505677b0224c33accb33307b7127dc73dfd36847d96d0e25526bfc7cd997b2863387e2ac0aed9842fe3dd24801ef3d2efdb1fbe433f4a760f506169ce572a4e3fa2462e7ed760ea00fbe7eb63723a6664f9966c278465aa797e399f4593f8696e3aa165808d1549d5c22e4f49ed0afbf53eded6e4ad6678a861222d206526c2668790a964354c0c0fa91f63b7cbbf75fa9ea68d045f7e957590cb1645e3e9b69da56027817339029641b6de6401718b64687288b347f77213ed7fa0606452a0d18ba92c8aa89fa42e6102c6bc70d2695115d8130f4acb57d12d45b6f5517472019196e419420bfc4ad44c863c22bdd3cf4d1c92af587025cc0dd67adf210f44078ca0b8ef304e9bb15f964181e2da62b376e002ff707b59148a5283469a7da007ebb72cfe83968a8ffefee1a11a2942f0c56fd1cedd32bcaffcaf02bf1ff8aba5ee6a979fa285e73d743a9d6435ceb4557c20c8a96314dd029ee41f552a97ec001a42e285c8986e5e26f4030e568479aa7edb21490aa18e81a3d9de06bc656ddd6c0a9aaf229c8da493f1815f28d847d9869a46b7deca9d21371a8d21b35a50d14a55dc322aa38a0f10ad1a08e9c94d8f05d323710fd45cb82d5153d12f25bac111af255e38382d558c89b2d2ba74134e64baf4aba254ebe0d95aab523065b04f9433f1a93cfe6c5309c6f35d2f0b412f1f15143144d4285aca7941502148535521bdc237b73cbcebbff85732f8a19d25e224c80ff741f9c24385baa2c845eec5447f6fcae9ca332944ff4485786e21b74fbb953baa0998687d48e7883796974bd0ae3dc8039a643804545b221015e9d05d74e22603ee74f32bb29d45fdddab4d8cdf6aebaade8f59ac27c28e7384b117f29a1fdc2e4ab16dcc1a2f950764320ca4e1ae215ec9add20028a4bf3e5a333594fbbe3d1066ebff658afc557443bff08c68ebb5bc1bacb6588aea927feae781b860347a682b8a8ef063414272903cb1bb6badad85d858e20f26365bdba3ad512f42120b2b60c15360c72c62088714ac8288bb78e9e4725da37335f1b16eda38a78720b9c9bb856848107d9310e079f594380fe0d995ff3a99243e48633bfa24a5dbfaa02e684e34f10e470d41a8a6ca861f111d060a826255094a256dea4adbb18cda6ae963529020010397c05f146470d0a2578d309b3a67d9286643e986a51c04612ef8dbdc1b2d6e31c6eac4c98638b9ba3591398a738ad19b722f0f671098b0bfa92c516ee1e557dc509acd27455e0caf559d1cbe9efa3f42548954d9586837dee6897ed88042805a9b57f650b7e574cb96c3834c3c3679ddf69f33a3564d459d5525e65709a2f6c376fe0e5cf0b4dded02b12ec5f7ae4f4b84d7d8ebad9b73928ce395f27b7fcaf786aa4740d54b8565e95c45b8bf7754ee12eb456862ee63910e35f2c505e33ac55deca80f29c586a03b51050b456bffae7dd62616c4450c96fd4f7c84ce3fa356db3414d090b2b8567f7698a00f02488e7a0a5d2fc3ace1cbd0dbabed766a7531201a93b8186f6c98627608f9586ddd2d34fd3779a89e5cb93f3ec20f7947fa49bf1cb10943c2a3b153ed3d9ac2db527bef3e4d21d5d26c5efb07ec163c379568596dd9fd03a4b5f09550837908dc3715d5f499b3b68e6026deb2eb3de1bac07a45fd17cee86e98922e5d6b6355afbf8affe529e4eca39c7fa196a75476ffc6d86c4c61b6cdfe39a9575fd4954759627230f025f020fe52e47ee36ac01659716e4352443428551bc49330eeaba9b069dc7d3e693bfce5bf921ce56c3492183ff1362453ba1c91c55d1d65efadcb884fdc5dcf4eb2690e11d287d9d92db8e781e8e7f7289eb2bb0aa480e258219d4c9a5f5e3c69ce9b1f66abb0db3ba899e36bb0ca2c96df0186140899f7dd32de2885516095f8fda6bc25580494076b7095f43a2009e0892f48d5b13251cc80bdb98dcb6613e31c6c87d808302c44961105fb899faaafeaa37fe7c40c4d0e2d8f99f6ced4b7022765bb23e1db24f6bc2cc44f959789d37470e52566613e4ad0d82a0dbc1acd32fe1fcae193602e44cdfee2a0fc59b6b191706c6f9893367ae6475c745a67fa264a348c92fbe3e81757a99abd7f74f8da57a619de037ba6bf70416d7e62d6c022413466273bd23502c9446b0597b941ea50967fe15220e219676453b6adbe7e7023994c0d250a9c3a67c88afc86779347f2ae9802d1c1ec4eac99cc27cd6421dedd7228c4e2434515a3751836b6aa714eb89fe995bde141fb0cb112726d6c84584dc6c2ade697a5b6684e22277ba409339bcb1ce64368583553d606e96ec5eab5e6c46209126cab3c2b52789d0c8eed4ab8a0946756904387ed6c6a3fb291bbe11ec57d71ffef0a70ab9be809dd9f4160e522652d616ecc6903a9622afb8008524f81dfc570e6c824cc8ac9d11bd76f6505e55682a1a0490c69d5c56056036a5a700df4f55746acf011148adb4d783acb2d50b0e9250b6357b8b458ce72841ee3620296729b62e2c14ef1b2c1e2ad9a46454f7d0f6689543a96300f3f3ee85259e5094352fbf72795f3e7e904fd6b2d445eb0c3b747007e0afaba2f4ee7650894f622898886eca0c1a0a19023157018d6f1d6e3b701cd563cb6844ceb553bae900dbfb12877e543e87b81970f4d38668f6ba3f6dbe434e9f48d9208e15dae6f90e09529e48e6b353fac28b107994834b13b9f06b93ba8ec9504987499cabe26d4c305d16867d65166849d1a074580858e1bd1b9f08b0f6727c10cb12be3a99b36451640bcdee630bdcef48f2586566d5199ae60a07fb3dbfb6c1674860fdefaf843b87559ccf343908a199cc59e2ff6c7b977212de29160709aa8e626ceb8140008f13f11d240f4182fe5614f54b9047cef9b8400cfbe2905da19a6ffeb57d79bfee8d9d5c3d9a052b15fde756798b94649debdf91449a741f2c248734e2ad8b91a3225b1c838b9e080f9c6f5d6ba8ed02aa4bcd7ba01e71283a0a8e1b48b101d92131a016426c150d929b37163af78bb27cb0f457b7dac985acba66cc268f0c14e64f9465b01816e0370f8d5c73ffb59160314ca413d35b7828ea9845cb892dda2578524ac41bef388d523955f32144ef64a0c228ce769d688feeeca33881d5d829d510d203c43d9d2c0ac266fa30e01cd6c0c82b35768555aa858f5a0079bfadd2a4ec85a07d83cb6b7a5f992e5ba89a784ecfaba52046104a8826138d7d93510415ad1d3ba0475896e31675338e403c1e1d6d8b6f0cdba8e36e00a3064dd61737ff527f49c26a1e73e5d0e4d8fe23196a7b0dece141d07ba2929bc6e75e9a8defeeb871e0d381a247cbdf1d3f855995705478ad60bba06b50d5ec71377214a4dd4c5167b923388549521f210bec66ff86e998e7e280df918d850fc2899c7ff5b3ff842fffec0e2d5765d764f155803867428b9c171c5932bfc789a9b4ce80ba4538d35593f26ccc949ddd594ba3cbf7f96d9fd51e3d0f9a99ca9eee6d7afbda7d9b1c6d1083eea462e9c0ef8ce64f4ce8ea7994e2b836d6063dbc5d95574f5fd378e4fa24b1c0e5fa61a5a6c9ee14531cb6ff0ecfbe6d21a171834ce5f370220686fe97a410e1203a11fe3ff192353702e28b893b4614c0fc01a0b67af296d85fffdc470e7a136f66f878c389678cc7ceac1fc9db80c553489631207d108059bfabd1b9972e1e869c8afbca26f237c47f9ea20af9eddbb742ec43e93403da69df21bfa4487555c56d1b4ef89cfe836a5e6a6394efe44897041c87c8b613f60713bf33324acfe409e97156dda7ee491b4f90d7ea37629151639df53d50b80124cdfbed622a2af35f91d4844228c4e31afaa43a9486adb3fc3ae8c096be7f42b2e49998e8cb615f2c6871c0afc04a439c7b3cbc1322dec7d1bd8aae4a977a65b79f8dcc18a32481ef3306697462544bbbeb417cc5b58d2152c706854db64c2739a6c52fa46763d77614db1c60eab255396985129a56446a47223cc72098b2ac6ec226820c9b3791fb967137191cb1e983e47527e7e5a3e3b1cc4e9054aaf551decb0697c0b0ad961f1612dd9606c410c5dbd8960ba21cf5fb4dbea851a8279b747de9b5519f78cd3fda84461f7e4db792c0ffd3311acf2ca0bafc20bc87d6e8fc05b0ae0bcc18633aabe753023a64a32420f73d85294f4d898814318b08cd310ef0c9abd2c386c02078a04f9c48314a1c599ade3da72c3a6ce131d9d43452653309e1bf8c875f3c7f18568348a1ff66b860e48988c71c7567ab7614edf9925869c144fbd6f5fb37a4f39b2be2d2412a8acdb0f8a09dd6c4849a8516246900aeadd4db77bcb3d706c9b66f8bb685ad53486cc0fca0cc7cac5e5813b4dccb1afe22ef6b74fb28bbbb62ba50937878a137244dea4bff59d914040f98f7607ebe7818bd802d4c673bf9b22b90e2fe867fdc7967deeb2d3840f3811aa72511b2af8d2a6c959e470d8163bf11a3888ee1d2ff0eeef55769517795e39c3e5d7215f6c55053e22996b37eb6be34e5e586dda87e747ac27a34db541b68e2c8aad53a7d25a9b5ac72c62befedf761d5bea5475344aafe333ebde409bf4fa76ed49e8bf944c48f05981f1c6bc87944f5c3922ac17ed2a0ad9862eed8352b8ec9ad98fb7e51290ac9c108f8615e7009bb558b7381ec0da8d04c44a3f2bf0192efdc842a4d82340e8b11867b7a0f7a413c947ab9597ce24495ec20923a7bfe5b84749b9c555108c27620bc05b6cdda13837184441cba8dab2273f28ec632bd5e285fa5adf65fb1e3fe1d5e46726db8fdc448bc5d1e44a54ed725541074d4606ed88bc60ca39b4f1211aa2c6747971ee52ec65597bf67187d23be4e4fce61967dff8a4def70920a1f7747d59a853abbd520860b3fba8daa2cc438420895d48f00ce2724d42602ff030689deb5c3615852c44d4eeef5881e860e530fe028cc3783ff014065e1dc76106c8614b0cb6fcc3f2cb741983f1b68713d4fd0b14990ace6afacd005412fb844f34c346c7cd9e555e4fb906704ae7cfd73b866af34f9c10c7d2025563470fc05714ab53c5ffecd35ade325eb5d0423be15e213cdf182a820d65129e50ae0795e7b0128f8212288d943e7dc9bb126b38475ebb6a17d4649143184e922ab0b6f1a2a4960143bb13b2da4664d5c6c44ae736d3915f5d64e17d46df6829bd026c98f81d1d9b46207b8df5f4f5d9893154c56313cf4b2d632365a19c0abcc8959705be8db36e4a6627e2316fb0ec1591fc9836cc805d195f26c226b05bddf5ca3670661a6d20bcdb9a7b9257423ba9b2501fdb01aba8343292f3272490075fdacdeddeb17e1850cf40f0e8aa3a7a7ff8f6f8f71ea4102b9ffdb87a73a04178faa6840b2c8a5e12edfe92a9f5336610cc6edefe87c5c294a9a86c4bec9bf295eb3d1b4da8514a28c8e92ebe2241915d99433081c0019fe9f074e163b4f9588eeef78c91a99b1c5785c01e06a598aa947f0d937777a972b5f859de86c3b375f6998c5aeb0fb3aa4beb81cc7a266c1fde387a3c907ae07398a93a1c7a688950a91f1eb908aa53efa4b01e58439033f54195b44a5f8a0960fc62862597caf88473fe7130100ec7bc7a8e983f959abc807a262354b599a8578eb4056d47a9ceb0cd26c3027c13d8de282455829cc3bb5dc00d109e539ae39b17d5935488cd58930021fd49062d6ddeb0ecdf7fbce4aeafb67222675be626fb484be4e3985345326938ec65dfc7d8172d7171e04070c23a0cd0734906d50e7f8086f1fc04552d4e5ce603086e8e3dd29871ec60c16f9c60a351a83f6ce2674726461d276401481efe714d59771fed619360a349fb27f999c0213cba96cce4c8708516bff76b65aaa18682b81427d8a5a5e2d99524f598dca861ba86dc4ce1c44405c18cbe9122a9735059c2c934994dbd08e19d5bacb62b76114dfe96c898606a3277dce64384ea95278b300bf505bd84397b4d1f2e47c14e23bb2b2301beabe8b754be64392ae86500c15993b7a12a9c34512f63613483d20baf9d74896e0c658087dbf9156e7814e3f0004be8c66dd8302841271837e4fb244d2d385eab73ccb1b2bb96df785a23dbb95c380c76e258da1d90b049cb4ad0650ba548558097619f0eea5f358fdda379731a0346d7d4a5847c001c6e22639f8c66e2bd2f0df29bf3c30195d459c0730967099918f99acd0b1436ecdd9b924c25cddb1a6cedd69902cba70b49c38b79e4488d21cf6966146e76dbdc604d5543747d2c55d4db924d186ea41e363d854efc018f11e3a43904d4630ed962632260f104b3b25e918e3ea34086a351a422b6beb90a13a6b97ae36882c7edf89dfae7ad00bf12c939e7325ff91cb2350b1aedbeb0269b9e253222aa02d2f519bd62d528f48f537b4a4f64fffc1f0b17bb669791b056864205e97720f830b1bb8fb46e42199d1471507f541710fc447056e7aaab4b547c6347022c4287ba596429901ce4d9838fc664bd9ae134f2bc7256ba13ab819decafc23ac19f0b2daeb4fb5202e71178d08e3b8c7749219f90716e85ff068eac3837084d162beb39cd5824deb0b706f0ce3d3b9e4aaf5ba9212461014e352be92635c21ae74c579114baf1c57bc9fd41865098e707b1b804f265977e3df927a90d253bd92c1c16d018b089b581bc656ac775453672e980d07457d14434542ee8710efc5a22c4884ab419ab10090b885cd98579add0f30d8a4bb2d13e2fe9e1047abdbe2403601b78882db832141e81bd49c80657f3a5dbf90a2ee33a866be76d6b19888c8dbb2e64a2327d6bc5b1a7e6894a68b52b3f366aae3099d9d645d43f469cc102165553f5f76a5d56cbf1eede0b76b27d2c50d7e80f14ec1f5e22c03b606acb40831a7b0bda0df1573f0bff214b1a81960771c014878ca8ba87f2f116f512ff0c0b5f13e3965d104c4be2dcd1fd93135279de6ebedc37a3b4bd9e3c2ca120a1441f6da7c64a16ace1abcc110d016b651c486cb01539f4a35fc822b6a1657f3812078894354f1adf4995020b4018e79e85ce2621b28404bb9ffbd6b5e6bf7b5e9ff30fe7b8df44c65277d92f339b250fa19ae0bf7090948b01bb46fac76e9b54ecff7ae400bdb9ae4c2089ebcf13b04d657144c81f0b08cd488e1f2284adbb0bb441a7705d3cc6d4969fd5cfeb604e6e96d2d31d66b2a4ab296e73f1ddf172e7a0e2abcf00e3523dbb0f9d0b6a9792b158fb967d6a92f405fa7c76903a4b389b12935a0e6d10327bb561a4dc75286c85c530b084088d83e3836744edcaa0928eae6db13cbf2fd0ad307ed173d46360f440a11962af95a6c1b1f5abd4cbc932a719c929347bfe238863f2a68e914023f322ab0bfcfa782dfd6c7fc5606d1f31d3677b788b6f4749410f5aba2ad22ac57de9e969400dd33ae224fa61ec867ba3922e117b9583d644e4cdca8faac831a8bccd28b340fd14423530b65a618cc04a747339195512e0a30d4766137c77fdb2a32417dbe78b608a7afc3d6b44160255c3cbb7908731ef0b0b39a2346f0b567239cc0662822a2e28b55e0d12f05eb391576a4a24d2ede8364f56111b85d9abb118f4a66e9a11a76f581757c7241e6fcf3e348f0a02b7102de96fbbce7ddf9a5f1e6cdec82cb7bce96e85d333880b4d79b2246a2ebcd0e385f0220a4db8ea74b229505622b43242b6e42283801098380d1448eff78daf5de9de8855e91c0237608a4a6c3aaf58b9081aa30408cd2d1c5859fc25778cb67540a30d702baab75201b6e9bf7aa79ebf722d85a37b68458fcaa8135debc553464143932b3f8ae387ccc7beb9666aa49b82bee25ef19bed11bd063973e6ccc3df5fce5e6e1b14e1b391967c20cb63a38b008c9720e933b2187deb0029585fc7d87a648f40bc919899262aced4ddea108d6825b19c65e6877a065ce2ab6458233b983c8b7665423937dc35d09edcf2f86c575caba2f1d014bb7e7317f5c17f4650ddfac585d92b570a6d7789f85546abd9b48b686b55fec4390ccf0d4a57a032ec77ee2a914ec5ea0da62815f84276737411850329b07db01a0d91bebed1e737c7931e4b119962f22a43b89bc32e3d5552332d3e666aed8e8ef12436c49f483974b118962c51f3624714966510776129e4b611b9a93e1839a56962395bc77410afa721dd33513bf20ec0217a29ae0ec433569adb64b61ccd81c7e62dec941ce6e4c40388fc4d5dbd0ac8a78ba8b772fec561caf58128c92537c5aced5e751b2a82ee7b285a9a1c181f53f7d0301bfb70c9ce2142188693b1b0ec9a043be638327c50003fd2a218c09764ed29c2eaf04926306c6ba573c1016346c3ff3f29950287b1e8be9cbf6ef24a113a3b1afe99ecd64818b6a924c5fc4af052871e22afeb4776bb1b7d87a21be03595683f3e7c48a4000e67ae5cf285ebbc7d0f68c10031be41e9ac8d4c25113c21e35d55ec4d808049fdca567523d1d8d3d50f8f15261cddc3cb540e7b49cd12e0329fe564faefe9b7750bb75e59b1a9b4ae6b15a6a09785d604430764b57a407cf905726aa79205ec50a94f6f3262d6a4f0fcbb36d405e4f4fd206b35dc647f68514bc60b7592096d8c8a178b3800c9e58c8d8aca16cc7fe29c76cacc605e0913082c455bb65421da4d33844962842e02db267bcec6548b5b6eee6c25d747a12ea5755c4580e9e1483ce260ce7ef74fbc72505ad9a2561ee1f90647d89a31c3f0e81c6fd547c5bee157e6ef7c05d10814958e67b2337b1a7fa590aff641b15f191de6883058d3eca2f0bd76bf755fab2d4936673728cf48965ab1fd3010d59e32a6a32b132b7ad039fc2ed90a1e2dffc637ff11e8396a6a1810094c0e0480f407472f004183030e06e6e45f3cd68c970fe6cfba91d11fe3ec904d92a9ea96c3df9a7afac5c441ab771e442e91d6044505e4588fe7d10dab224f0458cf537b5647f6d3baaaf9cfa1f5bac373cf228535e72c981079bc6b212cc7118040177900fc44ed51de1c1ee1c9b08900839aad7b9213d64abde87ef913003b2f06914dd8cca4de03990dc900304e502d024ba03e67d0458969376bd7b3300730af25aff08733345a0c708366db40aea1e0bc2e6502ecd91baaed89c9774111fed7ed292a3f0866c9ac5ab63d12ddb3ccf38bcf72eff65cd1458330a42dc11726ef47935877116bc5775041c9ad652d2f5d144aae8abae3e04beff84f81e16a1165071d1b0f7a5db4a794dab1d136cea012f86ab20575e42d5a6a9b46759b923f8df91905d310a9cfd96f0bc20e1c779e6e7dd0fd54f290a8b18ba7ba190805425992c9c57077dcb3d5e46546b90d413f3877aaf917351b923cead9d802fad8f47a52cf412bb6bef1aa45677c8480a2e0459b5ebb87e434d75146bd9b4457234ab5f07a75b94fc314f67513b50d1124f354f984191fe780ba815930ac895a41b82655a85ed6f77b2af0b12eb5f112be9826c5ea806543b4f3b11958c9949161597218cd408348b61844c6510e2613eb04d1f052353cb22bc793a1aaa7ca4b89808bd0c70cda1a9e6535d44d22751666ec7349956b52471d20f6d992e92e265ff78d89c204f2355eb107b5a6b405da19926ad821c49b49aaf46e000a4e41ecde12ca8d0583d57bae6b5dbac66a31ab7e72dfc45db6d0e1fa12e2fc8e1f4d3b8af9032a4cce04ce8a115cf20ea9f39a358cc924d36b4c5d049c6f4bb185a5b610ab1dd3decd01672f80de27311341a6c4cc157dda755ab1dde41ca990a4b87bf51d225b8c582e3cbf8d1faf4c797bc99cdcf2dd7ed3f7ea078af78e664b848eb15f96f82a4ea0dfc13ae3d5355730a231b08ecfdaa41127892035279f34ed3dbc512a4e7f120ae7b638e54bd279a63a0fc2844fd006b1a2c33a913ab633ea1dee61cc1ef35622f4c3e0ee82bea833357d2c8cb60a0dd131b8fc711a7675711c2d54d1aae4f14863afefe55794f563ad180b5d675c1df103b13a633390dd6ef235d0d20068c0b8169f720eaf839821b7e48b6a9fe959f8a660caeb695b0febdce05af75e69e1953619d1bdb5cf4a83a8ce7a920bf54c3e6b9e538609847eab8b66a15f3d7d196a085584fb49945b353cae58a8a8cb6e0d8850cff3c8224012833086d613362e4eb2c834357083544f130cd76126aca9de332c7017c9e6179eeebe8e96ea45fc1c77a5eb6ce90b1efbfd5698e22248f361f66d0d0ca85994ffc189255a205833d7875efb228afcfa1a3710ca777ac4a2daf763ea4c77494df8b68ce17532d116e40d7da76bd98a39bdfc87182e8fc5d752910d2881ddf49f664feaac6b8d479b1f0c9c0e43497d913b83f9115b303ae5126de964ff4c635d58fd1b91e48752b0c0dd4fa5d70babcf810e6a0a228b6af61b7c3b4b9e5f1ec63b1215221f8e342d418924e90b248a386e10b3dc62b1e18dc688c03f07d29723ba0d6037c3401145b1235bf0c3560fa37602ca7d283605494e215e4bfa440140dd36f3946738bb584942e7046a2cc6bd76ce3efafa132245790450abf59e0efdc96c029d352509772a3d5dc024f821d45f847e76ffd085dec17b6a2c7af9e50e58c7c8b020bcd1dd975a01e37f9c0bb56f6c901303d70756a97ce722504fd11918ed1cc7dd191a8a9474195495eb58774f06ccd5d2669cc9cad0673cf6d3d492fab18acd3334eaa8b2665fa4dc7e101f5a8a8d478d9a8fd81fafae1e135fa98ede16b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
