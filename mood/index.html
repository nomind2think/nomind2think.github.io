<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c22415a721c850dcb8b4740fb552c470b9951176183d1729b441874cbfb827029d9aedcc6106a0ed6e4b998ddcaaaa32add9566064b76502ca5a844e206c29ce23ae3564ff9c5989b90c0082a42fc22091fdb3fabe268a669d3fdd0f9070554fdc8e64c6ae635800f02d4bc1d1f12750692629e56855589156a200605ce5be874dab684d99f6eb2f7df16b031db4b5a4d570d3486f2ae09159ae2c407ee7e15cdc7896857038c9ac191ee3b360a321cadf7f74bcd65cb25d3237999bd04c8adafff3f4fc2a15d1f7e0e3d08aefc9cfc4e2641e710594afc4ee6e2b908f01bacc1d56f6e587e3dcc2ad4e3a1b9dc686285dffcd11b32c299bd5d71a0c46b3cd782743c5869b7c45bd1f71f3a43140b6aeba9c9873cadce8ee1fa759f871f9315ae37e9afb618be1431def238d5b94d65fd1b744c5d1f878f8c2da002fa4a2152c1cfc39a42b405a0a0b6ca38eec61233c59a65ef4d9d25149af2af84e49250867db753f9dab229a6b59efbbde60bd809b6a929b9802e50570a226d8cc418820b33be488ed2a6def4940fa3c5fa10a2b2bf5de33d4feb75e25d770487a4b41ff919ce1a609ed6762885aea13b3ae29c3291dbc5dc79ea346e1ae84df6a247f83b28d58787de0920668fffbcd11345ccb96ab8cf2649c075681318c31eacc6a1447ea0af48d9bc8a5de94936ffb03f0693359117fb524ec712769e3f98f62273afe24c4493a0552a3dbce8e75566b4a66e0e8039ca60b2a23a020846be8f1e144bee9297f88ce1fd5d62bf7c03b135f7a539c9b119649317f90c15938ec28a7b7d41390060ba15228eb6a246d1188ddea52105a18d536f8563f8e388f3a4cedda28b584c8aed3513b6f1920431a7d2a7f415bd86baf0b3523847993fcc3df188dd98dcec8ec0f529603f318106a0165dd8f674f7cf2b2b13f23530b146488c1667c2553e1a32ab227cc42255b1017c19f9cdef4ed9e5f2c266516e72809070ef119af8a73d18ab6f59c25e8cf0acb597b049f683d9fbcf37526a3a14d07793aac4f975d135698fa968ea2bdb57a6badb77aaa72ba0bfcafcfa09eee3c14afbc74411c3c5ffa874b0a09a5b7d9c598e8008a27c5b708ce98e789eeb991b7b742e3040f6fb37c123b82adfe877a4113b9bb1d142614b73c9cd6d22208374c793c60bc200147a2ced161f825291850c5352a5fafc7b464a737bb1bff8463593cab4f9ab348004e8d3736f319de9c7f2ff00a6b776e606e212f7e256efdf76347b2cdfad76ce0c16a489bef14a92cf1bc9b9b27b36b604ee24135d93d6ae959bd271941ee58b088fc1bd225bc415af20e371ef14a87d12d3e3ab21541a7992482b4dbb136038eae41f6f33eb6061e55b36e4f2cfeb068d6be78d4f7e6cc54e132c7221ec7a3bf3d23c2d307052a13b432a22e767c9d908e438004f81c2605f8322758232f015c06c75510a8fe910c16ba29fa7e42cb53c06faac405fef09b30e45831b21014a552a34df3c240c9f10b72a8fe826ff576ceb48f2144d555e25f8905fc424b8250779966c499fdc622c221fc9a16a70f84987273f82d3be2ea51820e3a4d30b3bfd6fa5e426bd9aebf619e476a91a0eceb87ad5de17e91290030dabf8744faff2def05157a2177300e3fa97dee542da904d8a53707259ad616e1556746f357cbded4e85436da6c0675f1aeb9c34fe5cd00fcbf85cb5b60aa638fb0a625d5e001d7657e95c17b32880951744afc2c0071ce687f66c101f220237a98e2d157dd203428f23d383c6b6da9566f51de3d693bf54abcd96ca605621e363814224fdbbab8079daaea1d0c1e9850e2947154251258d67231d411f1163fd8032586e9c649df02aa1d61f679c28e4261c15b444ce5a57ec58a755560ae6fa7123e27f3823778ced39c85d705fe07d39545a24a554c24834b7d1039c559bfb637213fd3c6b1114fdeaabeaa2714e1dbe3ce76674a54e50fc44bf242428b5ae9f29021f9c5b9ddc7a72e932f9f68fe11cc45b5a9307f59561006733e280a31c5c16435f734dbe4a1cda06ab14960b41cb655e811b54a2103038afde7cd0dcad79e61be55d410a37c41ba44571ec89513b2c712ba985f9fb7d45fd528f6466d818559d06181fe612d9b8b57a80e5ea021834977e53993e63c6965f819f72265029e2a0542ed616a875688fd245423bd61e0d6609a902a5089e7ff21113cf70bce1e1b9e3b065e0e0dec0bb2b4308c91e2be25349dd9194be3f189615874b90a019157594f126a9fe9919917a47322ac30041a92b0e76f3ee0bae5a13ec65c0ed5434821cb72f6fb7aa924c968f371a1941d54115b318e60fb843497c5176eb9cffc426e595e22043c28ea1d43c3a5e54994f932e16efe547fdbbd3b3046e0cea0df24e169f2a701428b708724614b830fab603a8911fba7bdff988630150e589c625ae4b086d558405f0a07ad5c42f0621fb073550fe91ab61e12354642ce51125d415b8e2085d157441e6a42f59b7a5d67c187fdd9087fbfb0bb1ec0013c91694a7a53d8fbce557e75753e1c07b6266867db2794f119de4ef0af3b26a704a2a19a21eb7b546d85d11f0c36dc163e3c29b8b6708b9c08350ae46a6ccd02d89f877063f919a89e302084ebb4fca345905e2f0f8f1d7f16cddcac99013efc55c2afe09a299a9083e7061afaade8ec0b8fdb4bcd04cdf0403359186f4d31561f418a1487e7ec267d940dd936f2c615add41507927c0a4cb921484bc94f480f1a7d65579ee46ce54ba68a3d4d98027573f75bc47e44a4d6d8242d64e4d73a8c4f37d3cfa830a3ce7a6a704071bc5305c7712242e9fc59f80a87b3ae068a107a77db512092d7d854e07bcda5deb1f6b7055db352af2b41a3e53797a5b703710f519e838a8066b64ab70fbaf812efa107a90d5685ce29ac9d9d72cdaa03abb5c2541591fee7fe5a2976a8bd5b34156a0751721126b65c371917e454a1c6fef9e2dfbf06796f8098101c874026d008ddedce1ab0e214acbea006ae3998298bd134373a34769c471b265138d186bdb55c29df6c43e4b67ac59ec9647ddc9232db2e936488c3a58825b7c03e158016865dd0a92a952fc265e1ab5bf93bbc767b7d76247b2e6c0162609f56f6f1b9c2e9483355db425c2c401ec0c748cebb218a2e897989f2fca81712f5db2538f220141a87da4fbbb3aafbb7f35d566342b3ca3152c8c0e4b49478d972b4cc557df83220fb46ab3f8c30a5a83e6eb0492627aa7c162081ce9c774fb03cfa942172e517c5fd6c06e5a08b41de4766ba75b2188d74899d41b0ce53dcc3acb4b5aa76273bfbde53fa1787533d3f70eb370731671ffaf04af57b9ec6cda7e010f0e7beca5a549f26c714d6a033cba6bac0c1fabd5c30bc21ec517603310bc63b70d6dbf1fe92114a4039bc05cca4beb1d85ec2f2e0226985a06a0f0431b619f757bb1357c19ea7c40b9019334d93438bdf2bcba0860e896204c0d85329e544fad20912915085f5a9e8c7393dd8b66f489a2c6db0e3d63914e3599e5225e7839319df3b4bc16dc889f3ae9ccd64c75a14455be606db4e80f53a58a0a14bda41f64d53435b35c8495a781da96ce1aab230dca58419753ad389fa45cf2b450f3bebbcb895579606fcc7c09a3d0c21fb2514c92b170155e9df6a4785ed06ebf68b5930cab8772eca5c9e0210f05e935d158e43a403ad2f441f94bc084634a3462a2ecd8d02babea96171f608a3dd73cee691b7f98b89971d924efd5326e862c91b09ad9d8a47500bcf8686c7536ea7c3aa665dc50798cbf052819379f31a9aea4e0648e6856847f121349d52352f9c52b4c7d3e92f12fbf5ccbc17411dfbec275638c6c90d7ab0c44cff349f20b8ffacc8382c005edac62187d0bd7d509e6c04fc6af7f3bbc6697669cda7812c7acbd16ba3a9207bdc1461635fe6008112d42694f82b7019313eed1ad1eb7922db9d906f4024257f20d10d5f568a5b9612a9ae8d91cbb9347d22af79fd66140d9143f6926920d08658958195b40500b8f1f166f59ab5e085d72af1723c3f2cd0c7c2dac131b5b4a446b152b6346de16183f6264a8962ac98bf73714fcf94fb2e699bf1678cbf7a992baac1beed0be0083ce4e93c0d53b7d894153ebe25251d4273808f71dd88258d8656d52b03c9df629c962a026d08dd41e2c0147630a7a975b6423a42e50f62590cdb1d3f6a2b921dc431f77eecdaa2d0d232349a59b61ab0f4add282c09284c5f3d61a6c58f235e7b0599ac846b9c7515582f5e1ff70cce30c4b55a63fe73b20f5295a669b9400959757b0e6911379b1514eaab509bcc3b8d09d6a2571a6b340c9c135b45fe48aa8464f31d757009631f6d111759fe450061cb03e3c4bdc649b2588efbbfdb72964ab263f570557e4f0ba837edeffac3d1ddb243a796c10c59e7236f0fcf23ed4e09348f8a35f610c9be95cf19261271ed108c9041e2e1840fbf08925cbde81ab50702de44b8f9300f97faa7d7d4ddb05002d56452867241d619b2426a25e6ea0964f62e52d739202ca9e1c7f0af7d8bbc553deaad52174e66e771260105d09d6c46a99bc8b28a8a7ebb5b52350896df6c0b70af9c727376dd257630c042b20e0648155c3a55eb3bef6efbe9abcf7c50969e1178e441abc2e4f522803dc91894e090702dbc162f6eb40e6d2f4f5502a5795c89f5ea6933185919799bead2199d3b78a080ecc0c4106600a0e579368b09cd5b982edd863e9d90059ceadbde3f3d409a8ac37f9256fa26b0d64c9a1a4ddc406841d6c21a0765585532e32e0031528f29f1bdf6bfe9760ca26cd300166051b09e04e8723d74a2d510fdc4677f16563b3882e6efe3d9b9cdbc1f55d96928ff6a1ce59e81996fb62221ad3f03ef3020898037d897e7359ec3511bd89809df5e6522dcb6f07e7ea78e18c356ddf8cf711874b4750c120822d3059fe4fb85769bd6dfb6deb1a0597f7bd3f4ee917b47ce3bf9f7166467f114b73725f6a48adb8bca5cf9e40d43d9dab3fa57366c2a22df695229b23f9d702a124c6b1188b66297b47a28204c7dd01ef3a76f877684e61e85970811e9e77f9db14a95dd7530136dc8c170040f85489a7c35e11f42a8216787ef1a62b7f165e8304261e03c27a16f317085017fcd8c0e4a33c6960d5a0b961fdaf5ff09568b4a5c183acb3696ffa77212312d89dc4f6d81129291e21fe7cbc23059db46a953873949abaea9c6c3a4d91e4d7b2e1c9f11f573c18309802dfb56f4d35048268cedf089228fe54edb55138a8a94f254cb2ea55b46d713d312be1954619945725e0b8d26c7d50afb58f070fd87fef759e43f00d9bdb9c2bd059bce1b47d597df1dec7b4d0872db99e1908f7db510adb9c28f9b5aa448054d47e7fabdbda3141b281d39bc1c8c564a45aa0b2af64818fc300412ae0421b9e126ea40ce7cf6420798b05fa6c6045bfd4406d93f25146266fde27cd4c43fdeee60e231d855d10d2c26eb072c1f118082533fd1d036580ab1a4a77a6cb954c289c1a2c2951cf56fb4fa7e2d28c8f3c226497366f4c51547576d3349bad78fe29b79a7a476590aa8ff100f7d80434e55fe18d76e1d443cf71d9748083acc0bfda099a1b21d69569336681d4418de4a2cfe2a1bc045fa086a8c39fabdb29e1d3dfa05c6816d03cde8a13783cb65ca621e3523b388d9adfe0c2aeb0cc57f4b6bd966d3fd4cf3e1f8fef41b85dafd4b579b41879fb849abc901260816e2aa3bb92f0ca2c7d64a07bae0ed4648bf0c9a468c37e97277a21b55eac16bd407a524a7360a909df04c94ceff3a27e46c9e0c9aa25a7fd293fc80d8f70ca5b072ed5e913128ef7730426fdaecc1765cf4cc796dc09aa7247720f3f4f4f7c8c863f1df5c479d0983f7ca117d2befa575e187739b2a7ec9e341d8606b575af895bb7848ca251da33ef7c10e2f4e359a28d2495adce59b3cc0701da777a369bb9b67b405d141d4a7ecca9cfc1887c7cd9321a179c3d815b41d0dc83afdf3281a3561504a5dd474fb235a240aa9c5318b790fe306ed1308f255176bdceb2e9048627a11fab5b01c6b7223092fa1747cc0a542c92e120f04836aa3deed33e077a6b10ee37a705cf9cc2d7f61c41cd6be05b81c5e7439324153a0c36015e2355734b814ee2fb1e9c40be9d3216f8c1cc1eb20d625660f661ac157daf64463e2c0b8505d101c46cb390ebf334d0d192a29cbba2459716cd8eb33e51c4e7a2118c7244d90adfdf5fc56cd82a8103ce192d476dc049022062ea14ccab27e8cdde40df8e190b4546ea8f129fcbd119be901f62a0124d99592864318fc215d4adc9838d9078e53ddbd88e2b9044f853822d8de40d1eab6f0973160fe18b1fc9c0ec4a2688f6834ba464fd210f03906355a5c7d2a84f5e7a4d9a739eba362922aa14ec9a13b57ab7805ac090d647e3a03a73fe06ba8016b54bc060055245dca3d8dd04b7017637a06bf03f535ef5db4f2b45561a4d3acc17582292ba4f8661df3e2c056fcaf07f26836fdf8c6b686ea046bcb73b5455cc8b101849775f63ca9cb2016ae7b1f9268f8c4037f93513dc1af8b8202c84424358d78c9596c1fbe119babc2757ae58d688d97b5bd0faa6229d9328a407fd0459e8272046207c39b9972baef9f0e7301e72250768a3085882790f0990baa2f9e82202a4f94f97326c9e8c0343d9e85aa29040eaa93523d83c1fb0a0f944e47b228aed1b2d10cb15de5ed3f83c1c124781dd078437f3b5f498fdf64eb8d08f5ebce8bdf5a800e0cf9fa35bc324f44c7094c20cccdce72353387fb313845618b435328ad0b65d3864a928a48c69a85d45bff99510320147d5252d9eb53dcbdcbaad9fe11c7a4cc4612259cd5ba7a83975f116a7ec34b40be9a424bb46b86179366757a7b5a90e0a53ae243454d7aec1f62204547f7a1953140581bc01e13909ed275cf93f27c2ff316c51fec41e97a2aad1f895a6cab8de4f75aec93b41720ef8c129cc7dd65e324be7d3a7162c893c56efb880372b57389da8a4f045685526c618a37f4d9d66d231668f025c1a56f1c641d8fb4ee70e589d5a680d4ca32104a7df6582a76369600269903173c606d4fba58b5314466c7e28a158e85af6f09921e5434d55478c345a2c96c1d7eafc978ab942386f7543ecb27864fd46cc66bd71512fcd1a266d278475a79546e9497c79ad479b29a620d23be8d8eafa976021c1701f031344303f0a16ff59ba76680e640fa8769a22cbb28b93a04fb696bc359c58808df9b7080f238d462ed8fe4887dd514f293b260db9630b3ee026697e031beeb7b299d7f5fa8924974db76d5d29693daf841a63a45090c5eaebb253e81dfd104db36b02ba199306cebc0f697ccb5784a9a51f79c3490f17fbebfb62acb6c756e362a505ad96f1990cea4ff128f8702840d453b16acac8d2f496b709536125bd5838c884e747cfce78d05f1027be1d6969f48e911f217791521cf25c59a11b5367269a64b6a1df56bbbe9dd62a7dc8f9b6160bee05550ff031c2e5fd2508d0cce727de79796faad81dab81a593f06424e16fe2387347f1a89c075f5348c71652022f8e8062538cbf45df18a948a4f193438cb9df9155e13454f74baa6780c7f1bea5ef328290ae0b7a2750c580007704b40c765e8b92e68c50029981b8e781370dac5e3edadd03a73a038c23f6cd8c3441d6b94d8bd23afcb1f949b26eccbbf8415af2a75bbe0cf9d274ad7b321050e674db095ec8f526e5a02ec37911dfba14fc5f532d5cf6fb3468aaddab9d47f107896bc2e54f1bb72ebf1255071678ebb598304aaabbce0b9dd4ed4d573c433309df232f4e21ee3a4e774ec51807ad2d2bdd6684d67e16c2be250459c10df34cb1d1f630426f93c4fe8452b078967fc3e21648509537935648e88e4d081b9dd818df5a4d7414d542f9e2e2cf66195feaaf80023d59cb85fae5e4d3e3564af3515dd3f6e6936c470921991d955d97cc98d3a003bff380a767c2bb608dceb593e205a379c4e9d80638ebdf18c332732317ef6f7b26434d7645a88184873db8cb36ae5f7f1a4f2e81d485dfd6d7429fe3e7cccb30a475abebf3d8551b661abb0c846cd38f36d09de3a69f38ee5f45a39396975ab335894b111ab568acf7b7653a01dbb8a192d5b71ee4004f719a9431354fffcd46fb7350261020fcb80d1a8b1719ab84597e69e51ebff0610a631155d11c9c3302d464fdcdbd441167cffac25d88ee5558d4c37a73a10154740cca43a26e776ba6b3906f18c178579f46ff1d4ad11bd64951ba6a2d2c864d659d4a6d8a0a802b0a01b5ea12f63ca820088beb5449983c26972372cf7d3de86c7bd2b812d2374b394d852c408745004e7a4d95bb17f0a5a4f81a53a1bc466ef4693055d8b50da066cc7a451c605872b9e719396d1e9f3fe61a9621f9d259cba4ed5bd09cf9862f31b1a285a7541736585f7fcb11aa34d74a7d23ccd7b8eb5d62c5a1f1dc00b5a7ce269d36e8810dce57a678fdfd4aa5d4256fe60e4e5c7d7893747d8f267fd9f774a8621839a8398e1670f2f3c13eee2480e573e8b255c7e96b3d5d6d09b53d1d05a579e026dc593f73bd39f8c776b9983228a612f1799508889f641fb1f0ef156395e98af6958515912c4bd44b8a845452e97090a05764f7ec300f43ec9bf5eb045038aa12cdf7ecfbf62fddc0ffedae08d56d3b937b42a7f9e9237413f1816128e6ba4a7305c4956789e6246826af394c0f9401b8ad277708ef771f00373ee5c09e8cb448404de840207fa4a842896a0ee61b7b1150598a4e41964c930372929487f9c22136a5a7b4bb07b4fa48f907cf53fe22e0b91141083bbdf063f3f0e3aac00b09f8520e9c56eab7ff59e0a6d55c043a9706ffeb44ccf4f4b16e84cbd41d2798b3c93b7f69e657bb9d7b176268afbe7e60a9f6dfabdcd73aec63a308edab499f89ac6ed37c255ff034c6b911adb0c9e83a439d6794e7d87748657ed7fea3f10b97e3d1f1141557905c7821a66b444fd2dc92766061ab530951f5b0fa518010e02e0d9fe733beae09064d34cebb956f035137898918ec6dba9e4573024d53f8785a6a8b5bc876c9f98fb68251ef1b7aa1f5f84c3e8f6f85d804a6db2bc3859a87ed78e1e8aec745b108b20414d16920cf9220d33b983b82adf02e2bfab623a08ad06590c9d684de9ad3cb7c360568f0209b5f07d43db8c79b3a8b7a4850190f09f147c8a9ffae9616642ea79d3eaabd60565cc38574177264d72a2470bb6db2d69cfac9c37582423f861f381998ac515145335ea2b9eab67472c8ecd1d19bcc289e2a12fe51e0be7a13fb4834ac369a9ca86ec572a9d68d17174d202866bbe9453926011bf4cb536b00a9b75428397ff5399cf49d0a41f2122cc9766cc44514e5698b9c16dcc35269f0d2df81984fcc025c60bde6c420ae2ddd82da69d4f275cf3e2ece5ac591311eed82d121787b571caeb52d0d6eb643f0fd2cc5642e282b19848e328785c9ac9f9bbac074eefc09ff15364884e58c79736669111ca54c953eb8165f76759b800f8453b765fb9295b6b73c8f7a1e754a882fe3b7de964664303e3f03ec90040737a9031770424d4ac4313dede2029e628e6942075b499c899a5fb976a43b91b045dcdf945ece16ddf91aaf1bade296d73dc57e411c984462f2b8d80cd649da34f0cba22bb2650c228a6b191618d8de9654d8392745dae5a35df5bd6f09c6ab3726777810744d17de483641d5dc766402e8b6d954ee6287c8edc9f13c5c177b0387fef0f5033deb9f5fa200bb2b0b7bba9d955190e01a95ba3ab53585c3f82b0ce841a7d5ce43aa5aa8b08772519e9646f9c93770e74547b666b6297c3bb62ee9a247759471473c420d51c270d991e53f49ae0a49d87a67de9fc0bb4d646474c42b958caea5f01b04edbbc11afd97541f20f9c8294c663e009c91e2d349493fb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
