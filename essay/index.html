<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bee81b732c53e9f9459e64964bbdb1632921a00b68815245cba52e8103af1e5ffea557ba5087e123a78e703dbf3c97eec925263d3df3f76158cd6926e5c70c79d67d7bbd3a7d8fb4a6657c383a45878e2bb526cc46619b0de29c72b14c2c358f2e7ff67faebf29d3c89f08fc587649f383b0db3c30f7fae7d5446e157e99792ef807633fbc2722353b6a6c8e4e2d9a9ccf3cf71832f296fb476a5c6539e54c16dabe6dd9b6432b8b8dd5c7efd0cd2af0ba82225f8088fafc00ae8bd9d39c76d9116d24dda89f6696b1c67b8105163f689e4f6e74934c0dcd7dc5599ba9cf64f4afc263cd8bfaf03a3b3f6e35dea146a27d2ec1fc0e1efce34af12c64aee4c59990e40bd8f74e073692cb9beb52fb1f9d3c4c8b86f1e78d1046e9f7158763ebaccff8099eb33da74328c9feffe6a06482f6abc092a129ddaf2029ab4bd80896bee7340b82b61ed22dab4741e3d7f51728406616a25dfc9cb7412a54d0ef33121e09eef696d6170c3a734e03965a913ef92e4a8106fe74744b1ab53d8be5ed177499d5639f4451f77157cafb6bdd2697d483395677738aeb7c0a609256c1a9d7f56dc12d2df7d7363340b60a778957e2d1ea17151ecc88e224ecd4277881d84409dee88b87da6cff4826f0442ed07a82c62cea5644ee23f0b64c164e2ff5d1417808c8cb2a5ffc51126101b377c456891e0b758eb95751d2e8e50724ba6f35bfaaa5386bc7bee611f83031a9bb900aa4347e2327f83aa7a2f6f260f52e7b9d4978a7d5fb3924fcf9c94e60d36c28e24628b81a2b285cce5b855b82a4da1b1fa57981ae44c650b504a2631f2d331e6bf7c85675e07affe82542923c7206bf2571370e537a8c2e3237e4c56e751cf2ada312f39283f1a9558e3dfd73c55fce85dcbb2cd4bfed4c01698ba719c84ae60a7516059c3968231fa986e34e68f80776be7afd4d743bf64c4bfc26060f0b7c54af12b55e2a172e069c42e1d4f5da5deb6b59cd6b0b96e6fe72010193de79049fad5d448b235a32d1e5b702cb7af6995666740b2178a80dbbf0b165f914cd5f435edc1ec700f1e65a5cd457f93c9f8c4ce01f36513b41caa2c041e595dd6820de00b68f4d58e146edf2b73d94a3c77d389661e46698905309c92001e5e14af93930cd119e440d425207cd85ede98f16680f1d73f0d626adf2f0f51b7017a894bd4ba99a1e9e615a4d86e71ecff15ffa0187fb35a18b313dc147d839ca764fafdfd6e8c89d61f13cb5627e11bc26a5d12f72a85c7c3eceacda4ed986381c5eccf03bb477dc1426fafb54bf8634135d71b2bc658bbea4294f872175b4583d6a6a2387ffe5d9ebb6ec051f1869d95218acea9c7597736f76b254d980b49e7dddd09a36fad6252131ffde7f7a41e9e96fbf956a842929ed6ab1896708d1f90a0057244058940c7d32592de7c6930f89ec106f818f669ee9b17d758133e32769004d026aa333e9e87e7ff5f2df60cc3b8221eb141ab572ea1f20a909238a80287b835c88736bce871ee807cf49bdb7490ddebe274880de2ee8b92d12f3cf731492747802c3997a0a42e4fb37d571de54254b628cdccd229b2e32534646870e1dd4278e8f1bed1b6d7f165d351426845bfa6f2cff2db36f7efe6e78862a91422e7b0f20aae33a5550f5760c99e66d448ade967ba3e7d4665c522afa7427ca4bd293b94b6734f8f0f9a3e32205ad9cb90db6e0448ad2e4d81a1f9d27952e827203d7c44c667d4a186c7da6e917284e00964120fa25722d13bd90ef8970fdde235ed5e3584087d55a43debc877ceec7aaee57739affe02ad726a11f6b115d45857b9f87eaf169389564eac4aeef1b49a057abe82619c4022503d1149f1fa4f02021c5759519a5995c638276371b87ef9b2f32332529e2c1deaa9c0800a1bc5535f4799497fc62912887440d7d3f545b5bbee0b68a3b9bf6d7702066e6f1bc9ca26544d8213f7e10ccf28de8d3ed5c4d29e55582e32e37e7e51a0315daead4f59ad8f23a925d12ad2be6ecf7b484a3ac23cdc5d841fdda8e2f7176db10963e44168150d3cd1221e2ae720a219201e09187ffe3e778ade19ede155047423359d559722d172d29e15afa21c029cbcf0a42f92d2dff066da7f60b308de2c5f984de8941f9f24a99b509afd20581256ab5074fd5562a336d7f017630488c2b168b8f597bd05b5ba3655b589367fc9efd1310a655bd67376b282f1fde586f145e1bdb1a05a244676170ef201abec5fdfd4f8a9920bd687001a339971abaf0d349a500ee9a69c7df4ee7a095d65e16d16454d3b2f13ad59eb71a6db8c4963b5988eaab3dbdc3d623e0329352b1a2e3fb93d43044260fb1a442cc6a3304b20fb022171a93212e83b458424f7b1a6ff5f3e933f1f6a1e1da36fefdc7c3e3996fdc9bd4a29a2863969053b3b29603a24e1ba1acd323bc1467cc76a08a03157dc32a93ffdf8edd3833e6822da7fe05641430d4e39c75ad0c858131304dcb6596fb66327605c9672d8f938faccf59864402317d2f72aba8dbbc000ad5dedb0997616368e58734bbcf3a1a30bd7c8230cee88f50623befcf8e5379a3e4ac8c8217dcddcb060b3de6db749c8fa52db1fd385dbbbe2ed88418d9974481ed2bc82cb9ddd96645d5ca73ecbd0848ffda3f1eff35d7e2c490d07eed92c1a3449173862c1e682274caf96996b0fe881ce5ed5f1796f6dd537d3e2772c9f9d8c473790f7e6196c19149339570e21c4495eac3b7afb7b039b58b94f579a22f0a02d8c9fd18e75662592c1875e99e3b4449aa7c4c40d898a5119882a07915efb3ba2997533c35db05d9a3106a64a244ef31f792a5ddacf3f37b8bb9a582eb6fd69f84f8717466cffe4354e5aa028e1b8b2c3be6e7d413bdf06b53ada3e7a035d9deb46aa45a30a3f6ebad4fda1446c86f96ac079a678c4b71afe346eef4a37ff8b199dde911fffe3a4f6dfef6b7accfee8e95a2419a55535cd5abfbe6f710180220bd3089486b8f2f7518ee8874a12fb4427898bd45f1e7b2db88810fd59bc066f66e97312ee63bc76f5cf4317188a0ac40ca2f8ca05683c332381741b474c535787ac36a1f711d3365cf89a2fbf2717f9721520bc58e7866ed826a5aafa3fd5c3c920e7fbfcc8080a3240e58897f34ba24b71982a6a7c65ac1f66d88e5314cb8881748a18c07c578d4376adcfef9e79781f8f85c6c7c4c1dd76a00b046004635468709236fb7161fa6394df9ebd30785876266e8604b92dbcdba5919c39c71a2edf387a8bbbab4d527dabc7cf2397cbcfd0364718f7fbfdac568375eea22279ea0d96c6aa08bcdf3a14ab849b49c906d35c8a77b7344ed374ab1934df0b72f339e0bc3658288ffc56a55b77c85364d074ab477c18be8d8d822b821e221e357f2e484433b5d005ec6eb1d2cb448d67c1657e822a9ef9a4b9d4682e0374a254fb87009c1d74cbadb7b04db89134c15560a1126f301417596e6954d475ed6c693248949baab6fd4542207ebc45bef8f1769fa325d8bb14346cb8a86d185f78e9e83171c7c401ab2e7ae255841f67caff3431e44cafd731b3acb44f9607d8e6da0e4231a84154a926381d2020f602cc0d09b211414a42099619e55e5e391c8409191fe6e0c2bc09b0c0fa4a78d7955b604861fcd9042c38cb11181d10c82e52cd33047f91c687ba48c0bfd683197992ca761883d9cda647055cdaeee0d576c608cea71ad12093b6ad82092cde79809bf582aec029ed4e9827eb7f1a3e5c362fc47f4a551d7cb276908ddc526a66e2a5a5a9289f3a851d19a4b81024b0c1b1ca309948ab2a9eef011e98c0286532280b7de589253d450b126727e20e2337724236e35c2add778b816fcf5967135b6bf29ef5a996c2f30090980b98c9391979cd2a11e9c780868ecd3f8346ede109ca41f6a958491b93f3f5ee9a34cf1359cbfa85bc8e8f39fd92fcfe7b6ff3ea6da9f9bc3de9e00e0d870288dd5a17136d36c1875045a5ab882a3f2274443d461be91311f479c6ab34529a8d477f8dbaa9da2ba1fc866e3ee1617cd2210ad5fd96437a54376904fcc9b291c6c98f9c8692c1a6c1348d7d55aa0a4bf864b48b8b860ad7909409588c09425ca910ed0e5a800dd3e5cead7f940f94de06d790373fc1abd89fec7ed1f846f6673dd359fd985659bc77dbf8431fa43aac09f70f3a646976df98957895149dcb0c15d3ea015e5e3eb54cac67e1baaaa68c0bb82112f1ad4cf83c7c01bf704d4d6bf51cf0b77d4eee04fddf175c538896dbabdf46da2a11becb3f8175c945b7b3abb4769d36fabdc7606077aae696587e0b96d072acf8b4658facf40ab5fb3b2b27e6b8075049e1eee93f655787fbd40cdc2eb89f668ecf38e0480e1f5cb2eadaf839c404fc378b43359baa4ceefb264df915c541adafd8c95298acb0ce9beb10bcc941623b23794a42b17d378104018fc473dade87f2d0ad60113d168c536aaf16b20c804cb9c708cea5ddb6d7cf747a93008a47d3bf9cc4924eed5740f89ec008ddda05e8525b49c3e81ef2724ee1b66ff5d17790beb6afadc6b8956889410a1c849f865064648b1eba83d2d4cc97a7978d5d919086e8c6e2adabaf8f250ab87eae5662195c53b4126de01cf217a060d588f0382b3dc11f3b7eda9a89124c879e4ef3e919bb5abccd8d4ab4ecd10244cdba90d56ae54836da2515345ab700882920b9845353eaf850cfb7cda1a1de733e1769e683010f4f40acad72c8b6227407eb564445c4ecc66fcbb8e0dec5529919a34344403c36247e22ce9ccbd0e185d7fcf6b193733d350b51bcc99b46b153aedce0d2558df57710135386d1674bf9104bb67c2d0202f0e895314d7bb09a2a7ae8fa8e68a9f9cb782d1fcc077d54d838e6e5e93e6f9e5e85bc00b291278f77f09143dcd5a0a91f9cfe3502268862a4dba8898feafedf4312aa3fab7eb95612f16fbf74fb9d28153965328641739beb360395fb92e30cf09b048f22e2c4b3115ff71369fdf992442e5903701e86c874e4f241469a1afe3899295a71b27976fb51a3cb88e8a55dada792a3a716b004ac602ded26db019bd6e1c2fb3d09267d49d1def975c5dc596692e62cd9d38d7821cc9f6d19069465ffd2d56d7571dad5b333f9348db5585c83245317d700e60c12397beae31b35d7965404cf3a496e140b696e4fa7e3116fde4eff58532ed80c6be4c5c9621599d9a13fb84499886282c714dd212c827609f5a8cf71205b0b0b9b9004b078df71bff7e59d0cddf6966848430853736054f7bf93f55ce56cfe7a26b98dcfb345fa0b74dcb6525fe9a624dd9baccb2fd939f6065384104dbccde35ecd53854fa087bbea62434cb0f8ddf9cc1d46fe94ecacb93b3742f7c33f97e814b4be1e20542c15316a007840bc8e60c44c2429993e9024a25b1cd4c4de70fda601365629adcc9acc3ce112cbf32038d3bf889a4e5edbf8185ef8c70feb5b89aa6b6311c7f7f87f96a9d8f6fc5c93f047a3a9eb6b549d1d5de6b7f015143d649ca2775b959fc4a047ea83bc5ce7bf5a28b48b10db9d3951b75ebaa4d58e9e7c1afe3501608c91f689586dfc163ac3e724f2d625cbfa9992e0b25d3082a08fd5205cdb39aaf17b0c93556b3fc357e34408082493de8567b30bcff3e4b45218e814a7bf22f849d3c4273918af701f8206a3916b6473c3144354b6a24717eb1affb91ea9b6ae7ff2018363970dfecb8984a28ffdbbeab5999b863763f8f946c652d9ef3e2da21b09d6b8180f271953bdfd1fe544ad1dc5f866cb1f5eba1c254c20620571af786a5a6cf73eef02321c5f701d1e0ee0c5dca7944efc5c5682f5fdbda5638ad2a8e4cc3c046e55fb219dd0fe6ad3afb6966d92f0bda9239ff2ed390cef8fd90ba993d8d74729a40487fd9311a8901e03e9f9d8931dec4fcaa756889b01e87646e530d547d8a9acf72ddb5a082d2fc19ff52e9496a3d9706f433c37017c6a183a27a7eb2065f41c9517908edbf552174dcf5008ca8b429d544916dd464491b1268d4453b6951e4ab94c4e4ce5444bd3427bfc42b5006a9869a41aad0cd815e860ab7133970e4c3fa4abf4ce73ae788e4c4599eeffa412eb4cdf6f798cbd367af0125cf691933c09db14943237bdeeaf6d48aa58fb4b5065a1e24ef21c813c3f8a71f7a440e3b2bbabff44553b1f7ed0fdb89ed86ff41d92849a89d102438da36fd13e7e285bf4d2f85b7241a31190a1c220609645aa29cba67c703cb6559337b99a5eab108bf6a0de366bdf0e87845cd78d9bb258cc387d81bc26684d0f8fb7192207a1a83e418b52752153eac4052a3a9213cdcc4ecd58a49e9d2181adde8f20b2e2a03602fe6d5514abef3bd99d0d0ef6824ace9007bd81e7bd3c9a45a9a7dff27df368be99c62dfbcdf0404ab76ef3992154edba4aaf24edbf91ac0709285727165a9fa68a149e3c1d07e471535a1ad6fa17f460e893eb7e72a0b265b812fee18f5805412f7698cb3bedbc6b88d41ef8361588f54abd457cf1f2fca79754c1299438f2b9fb6fc07a09635230c13021bee68aa70a05b1c4c1641b9bedd0ed0adf23caa4c32b68ef997f3a5ecae29915b03346ff9b038a01f43c160b7b7e9ae4e60f839a384c693f7b96083798b33cd8dc51ea813806342e19877c002ecebb16d29535b9d806806c7f4256de926cde59d0149816c41191aa8ffd2ed60260da62c65d8d2d62982fed1bb2b344a032928c247cc71daa9613a5ed4dd551917d0bd032f5ed22128c75e08a89a513d8d843a62148fbde27c72f7d8ffcb92eeccaf656c3194eb3be376ede5113c65422f8f330ea84704669ba0757312e371f29803e261b23d8fdfb845501ab50a0c6d8d3b3d97213ffab9a58b5e7c605a79722c49354031cf8e6b443d25106cf9ad474fdf17096a27b97bbf45085dfdfd03bf007bf0081c62c4cb8ba5536bf3889ce2171237d94f4a348ca664f443ceb4de26270368d5416d30d016c91efe4875cb2092e5d1f84d5fe103c8d7e2dfa6823ace2bc249fcb58376875d3d09a179e07a2535d8223e04dadfeebdc8228ffc7e743adac9eceaa936ee095948b74a9a5f5a6d71582cdf5e712af078b7d692e445b4f4249011fa5615f876e1d655de6d5a9ab86d546bfbcb64ef7e73cb4a48c7a7417a25fa44aa0b8b556cbab35e809a57bae5f94f876a388963cdcf109dcd58c4f4cff3d92362bb11c3cd4f1b3a2510cf1bd987a82076c6f16011f1d3022e99e795494a1d7b31bcca286e09ca699ed429e13892f2f595ccfb18d769f47025f798a9267279cd642837eb309dee212527bc23c5a93af0a882e2656807106da82d79f04947c54e6b7a2c20b02066c91170963d7120d59aa3d01133a2e193341f0ea94f3389c345bb6a9c262ffcbbf601c6f3a56663810d8bb02e6632bab42835b6af21bb1a8f75942bcb781bde29e4222233cad4b87d3e43837d2e2829bd6030af795c50c1aa5746b55e92f40c87275cf5db8fcc8a63551f5ce9a14202bf6201404a49e7fe3c53cffe002667fd2464407cfc9bb0e2de28e75b4c8606c076bd9c80262e8837b1970d4beafb3be06088702b194dfd2f6a0f7684141ebe11df5489cdbd4361a100008888f1c4fd19e21f951d544cc8c617d4f9f39ab9a408a9917bf1eee6484cf6977ab5eaf71af0caf57b5aa9e82921242b42cbee95c7110f52fb702bfdb1ef06ddda24b3c768ef5bea0574728f97bd996056a2b269030fd0ddf1ab7fdf21255b259515f38e3b6202a211188224eabe015dfdb6abaff7d20770dba7f5f41751ad01ace3559620f571ea2a258e119192378bd8bdaa222d9e8ff25f854c9145cc31cc9c2e755acfac724583e6c83ead2b45c4a8ec397c0a587f44e43c4bb057c8998e727a48a598cfc2683c31da75053ab7598c5f65656aabd50b9d0e63a0be83565be42bf8c1fb0bc4f36a0f736c8ec47ee92d5dfd9ca16db9aa264a4a1a1be494181543459b38fddf6fc4060d9d50bfbc6e16bdeec3caba5c21d17f9823fcf17d931a44e5e92624016b3ddee21ef41855e9c7cd04dde8cca05d804fdc1073c50fd0566147c6e436d529d075c5c15e93a58f6da5dd0cf704e3b6f8de4ba43f6f1083393ebc6775d7a68d94d34e95dcfe4e2965679ff724b3d089dc05a67aa460594f5c893210d35148a5f9ef456fb329a66d7f9e710d4529e275684354fe5f183758f39dd5a97c5b175ec29c550069a0e248f3bf7444d5fc442e360d5fcf9abeae5ffc0152074c1f8f9d43ecb7a1841a526de3649fca9f5c863f25fc6414bfe1d9b2b5633f3be05cbcce65e8f69102fde9eedeac3fd3f22d10ae182da9982cdba5ee83345d32ad177bdc730bd29bf4947cbca6d88efc0cfeb8e2641a811af42d34fdf1185427130a5ea0eea1b44b700d9de075590569250426265a9716eebff3eda2452ee4f8e22de9a4cf4f37add78ce1510d4e95c473527b0db25418ab4005299db8dc6c452eb98ba92a42603a7def72aa5b1edaac7960aebca98401e0e49b090f124369130e26cc613d3648d878324a3974151a26550af988772b01b791414f2dea37e52def33ede3a83a0f360b046e847ed6f01f206cd928264d6ab1dc8022c0bad7f18cb821c681d1bdcaf98e364f10c529952f6a215b35d0ff479552d2bf8a4977b1111bdcaabe016aa6e1455245bdb6514c1f60e1c482d118eff0a45b2a06546d2afbe54d0712fda1e9e6eaa3b49fc509e8577a5b0045fd890918d53ea5de7736d2103ff86e0eb8f189297c3a6ade9ef675306544d497799c9a9bf1cb78693f779a10b74a283a2b81a05068c4c2ded878b5788bddee5f6b99faf38a63fc8e4132aaa2603159c416f2d4e9f95bbe4a421e1454202b87e066bbba121c922b50de76429f743462370bde6d799fe47ad95d99f9db343cc1399163edcea8f3d6786b132464e730131b072efe40564be301dab4eaf87d123354a0919f3a3a83f4dc9e0c8b7b4b71901575a0909f2f793faa1c1d3485233260140ed5bda133d624af8a5fa8b6e148cce91e890a52cb8ddde9b5a651ab9cedbb5522747c69f6dd1a9efe49937d0cde6f2eba80b2da5520920b1008ce36334b5b6d7b97adacfccfe29f23a44154d433f58072a05377ceff03a4c62853edfa097c344101f5e27d5712398de248c50a4a0681b725a5fb1de62f7ec326686e9e5f8df99c3a1c0a5e6dc24061125636ea026dc779e7431027707dc9b33e0f36c05cbd7baa9e9738a91a8fa3d93ec8443b6c8bcb18648d30baf3c63b40827ef9d19f33eae8f5418e58006af9a6778e5f58be29ecdd8fb78426ce86121ab0022a88c47aa041c4274d764ad8c0a572f40bc9656d54c0e84604e8ebbc47b492a182b742f342482b3165a4d1ed6adb97d7eb2504a45c3dc2a4bb89e55229e1c3f90f347d8039ad79dd2329e898d82b90951c3f082d57851b6d0f80808e3c632994b8e0d0391c104acc0f3200c042d4cdf0826a3f8114df1661ef8b08038a16d5be91083fcac30540f04b1db313409874dfcd9ca8ab8abfc10d0de897187df5b321fa5df14063e143fbb0827ba2dc6cdd83a1abee7c54e47b715a6ca51a335d17f03ee169c0b3e94010b62ebafc9dcdc6503b65e41200cc0a9138684598b08aea0054ebc0cd13827695dc36853dfb6bcaf7b6ed016ebf0db35b3e3ca331fc9e401b583f453950de37a27d51a594294737e0802b17487d2ca033fb3681e0cabf07ec1c23d05114f5fdb0ed2dc5a1f27ae57f9aacee0d42e6b8cebf60d7c17dfc9dbfd0d00dbd6fbb8f72704755b9fc4cebe1b94e6c054493de81960ccd6707a3d692bb2ece89fd60a75344bef21c8b0811404170a0d8fd4bba9160dee2726521c72909c84202dacf81f695dfbedb3c2d9e98e7d12ef2c73f652f3162c6cea62c66f63356fae0d48f0ff5bb90412329440078e0ddf775781e976c956319bf3a880eb2811ab6805781b67ebd0edc2e8b103e934d59574140ab52df99cb6b210d037d71368f7fbe62a00","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
