<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b85385b55c336336b491ca53c167602c1ecd18f72dafd2bafb75f58aaff2e18db1c09360e12b6a7db8363922b9083360699c816491e720f5243f1413d64ec7dc3cecd8114960975398fd1a6f34c396537f9400499270d092fc721a2bdf971711692a2df129a1eb7701f359d059273ee3e010a32e144485a3b3e2a18cdbd51c8bdbcea82bb207990445d2fa5ec4bdb61d177d61bd869d3ca488ffec75978e4e677e2cf9d97ef0f5d17f3ac6f7bfd10d71286b95268176a4e156bdac2e13838cf620c13d09d23e6cde569fdfbb3cd76d3cd580a339ab02c67018c5c3705636716806e083b3c1f100c8e69da23ea87959897432d29b5222d2679918b847b57316ad48acba604ac86a25b2ec04456ea9f9672786f9868c8d7b2e6ac70cf31c6d5f7606c30c424e8202a2948000f11a182000d71444c0fd86507ae055462ed1fef46bd5ce4a9886ff385ede38dc8195d77656ee1d641d1d9fe510e706b5f916f0769911f27f7c877d564344e8a8b081682120abcef9c427804c3be2173e3ab516c9aff50b8d731262a8003253e6e908a63a97671fd2645b31794ec85b3cdc0aec450a7fc29d94198220a3eee17930d3e899d6847462eb34e76b28c4ebd22e9fff0234c3d5831e8067504b3e0b4cecc11eba5517af1fdf7ec050c3935b10beafb46f485f14640759304dca1a8efb800f063a53905269f40366443c20ddd38076e6733e7c2ceab4cb240531ef211c69d516d10bed5bfd679ba0d49b0d7d17bb8e189c30955910990d9810a1d8cb2c258277feeeed1ec9c2ace2791b6db918a0a2f5503bd1eaa2cd6f8b1122b8b2a2e57345cca5c05051a5b42ab908f6f28c5a2d1e8fd576f2216b3bd17cde75005e9521d4e962803c8ebba9041be3611a4a5ba46b6883b550934eedae2478a3dede1ba315e83a1ed58dcec70e6367c8862096cdaac03170f35be47e80001887c8184817af7f5d2825b818bd6ddf14db16bc62fa0c22dcfff4611a8b12e9e95a98294db1ede4525491f60f77665ff30587806662717aa523c042cd2bffe2855b02a71b021685f159d785815006d9ff98736e07316ea5520cd5ae0caa212ef980f7fb1d55eac23037d8ec4c59d70e34d34d234bf6a4a9f6881d0fa50aa99b4da485b92b0126b76352a5653db54ebd68b5cdbfd908fff8f698a811d8632c572c5bdc71659eb1296e121f8e96b80744ed6e70bb3a15bca47474c0930921da366ea93594e08af9e5caae0edebc04236d87a49467c50fe68b6db135c5e31754c80d057d44eaff66ed7919485e4b17f490c76bbfe4e86ebfee0f706a7db7b4ed14dd7a410b4bbe7c930ca425f63dcd0d16091f38f19b618a7e7e1d7517d3a27d527c8546f8e0751e434ac9c298b8e49d9a25e5838a8ca43fecd7b0c598d5227622892766f047e01baaf52b3a6cdc810395969ce72ef9d00a94360e31fda151b0fa5ba741e4b525fa6657875ede1cc3726ab6db1466356d038fd678d9c88ef54cb73b0d3afd05bcffb93c33d0c8f73026d3a07e8ed97ef6ea5582da02bff2643055387771dbe25be29572ec1e695ed02d69589ad5ff5d943b69a9ea555482a8787b467c7482a5786adda61ec12c14579bff344b3dc307788f994cfd769f095d9e3d072e41806b772487471eed7e0446036f2389cf3b629286da36ed011200f11e1728752cf1e499b668e2a2a31afc1fc2e352f689ba8d275576b8961fed44b17a3af93c20e931e3abe5bc390f82acdab886a81c014e2fdb6dbe1f4bdf1a858a6610404c24fdf8b2be097739f63f04b9fce09ff98a00368e816fe5c52687cd8d33b759aa9053645e0eff994a9d5e374c2180c9df39815699d4bc877df9a6510e61459716e4ab246b3bd6f6f6c837012def4bf030d601ceb681d042b7a35e9131559b12ea30f824e928ea1fba67797d9a21b5785e183c70f4da4a69cb507ed5d9ee1573ba446fff5c99df1bb9810f4ae9de249e9737b001db2ee7fbf979f07b7127f14db1e336399d8c4f61697d04bb5b3922084cf1d8f5c130c32ca620a793a34d758e6505739bad7fd7c3899b6ec7cd5c8b7aea0fedbbbc7abb7186814811bc83cecfbe452b9c71b0d566229fabbebf9e7f417380628630d8409946583d71ec4c1fd5006add39b5fefcb8ceef31ee496dd14fd8df275950ddb920a2f13aa7e8274a8d8a99a507b07e015dc9cbe7de576854d86237116844910b767a0eabe09013b9a1ac17740477dfcb7181874d841201ee07b6ddc16b2e8eba5227a28c3a619d72f46a79c1a8339ff1dc94b4f94d8dfb625ee76197dee41e48761a20fe9d32d2a00d6e07ccf27b9db1c2bd41f57197c407b0df68622d2cc555972b5a367f0198918489a684c13ab95ec767ea6c3600bfb413be6fe71f4e7bee1a11d27191839bf9628e0188618e9f108b9ceaf1c3a18d05f41d92ce2f192458015863e91dd791bb72ad22b71614c0a62a6ee16902816c9e1d2d6f0b3c9cce4d26fdf347b25ce918d5202eae3d81afed1d15b922572a331fd17a45f634fcb81aa99619b7e16f026a9ad1cd41d07bb9f7a7c9520c958dfed0177e4e0e925d797fbd07deb61e15a6a6c8fcb5cc1ebe602eccc4a1a70888c479ff41aaf2219c1b0cab83e7f9f0a22ae63ea13689f2298abce88c1728386a4fd26e6fc1be181d8790b2f98e439fd0b4770423631a9fa982d99983dc7b2b6256ff9bcaf85896917f8ce05e589423c57399d381106fbc2fca654ab5770f232ea1d0c59be49abf51bf260cebec4950cbd8160fe4a57030144d4e47b612348f76476069ab57d28c46a4a6a87bf947432b54adeef0a17b7eb5cbbd2cfbeb4e66a96bfc5413f1a1e8deed2f53ac212008194dc477a13845c37e7a3708fe207909ee9e0e5337a56f0d61a7fc7f00be29303a5e6a406236d79dd99dc2a8197de118272de24e14ceb47dcdbd2c0c348ce3cde31ca458cca3bce59111613d82e3b3a9097b241cf5ad2a7aff4d7c77e25f786933a1cf099cb88060848c5e36faae9cbd17e21e8351548fa1af922c87a8974d5335d98f95355e9e21f1248dd65056e2dfc5272b1dc3088371daf69f0b9afccdf34dc23e27006f510c07ee39a7155e0c5725ad20be05619dda81b1c954956f5b4d902867f3fbe42d72dc23f5ad6b764c836df663161571ef5bf2af697d8ed11d994e8ab37321d88edc30c619715b665228bd5deda986029b3cf53245a8e0e1969e5e83582321d3153dba339440a5edbeb9d49e070a9e22e1b45d695a157f0712712179a3a1f44ec48fe5e06c6186db84841824561079301144d141542fc8f0f9f2d3159cbe6efcd0c2c41e895d647c92891a2b4442e1f072934837b0c5381f8b0f26a4a179ff014d1a8aa3a6abffae63ec8499543a477bb885a82410322849406e8e22f819a55fb671556226574840a176839533ab8b70a98cf4b48992d27b37cd2ed107740b9987a7a3a792b187c497f8e2926900e87654c8996768a343ba1d058331794738923a35f2fc5e170c0daf9112b0d98df319922fac1a8eb14407cf8563fb30e3183eec52a2a63c0baf573def05948f9225f0efe61abcdfe0f43873f2757583fa0de6179a272acaae05ea2639af05fa0865d793bf7b3376c76f3978e2c2d1740a09692d5897c1ba0475d84a8e59c8c072be1e5ac6debfa6757e81237e0dbffa0e8d9e2263ce8bc9a14ae415afbcef955cc259d3a0877d733f65b73789f26805f852886f038f3b3bd4a021aa1c21627e8fc6f2a7e4d234fd7dfc69825b6061b481a8d37571073e5765fdaf496fb7dc9d1734b198c64a53dd5956e727e0bc9fe8b5253ffb1f7a4f898d68f79c914ee848b6c6fa11208f14105778d9586e070b5b049773e29b8e0e7454ded994a179fad986b6e712ff64e3d97e551bafd7d33bf88371a763957a789f4e0f74adfbf868e999cf667ac5b02943d358a368ffffe8831f96d7bb25a77c10d0f70bfb975349d8242577d9b6be6d543a26eee1de80c00fb5ed59a37a74f487b358375288826cfb630a05eba8c603970d4e4484db1140fd5c74e444faeba0bd32a1de066410937aef8da43a5af74c963f99d7a87231ec3e9d9774f841dc94cdfc534fc4c4efddd7d32d4b35dff8ccd3aa84379959848f390b815105a9347668f8dcb8161386b30ec55789128fcefe2f5a976c037b54868e46f396128355a516bbc0c79eb869a3dcba73760c87f729668429cc49560cbf72616a301b735da8f64084fc880c7be792047fc8f95e3936868b36e3a14ced8a467be1a45098c0fc78e1aba41ac4b0bfe615fb6f6586cae0512237b2dc4fddb2d1f7c0b57adf569aa651781a01b33390c362c22c9c9a71a1e3172ce71022ccce9e3f0520450d9f382c851337dc2851cb7ed3e2e9c280a9b8e644813812fb1236e57e4ab6c794a78523bf02bcd6ee1ddcc8c6daa868e4520e4695fe29d3e7a11699a1d4021d036535c634fe006606d58d714e3cb99e174be062f3eddf7cd14f8775ce3cbdf38c42ac6e1d09b03164a3dda14c1b8d8b208406f0f752615bc2c56392b0444c20eaff92410ab5dbba282bbbd17b846384f5523e44a2bf0d738d4c362c2ab9128e5103d999e9de0b5b3532df2bd39f40446ae33e430abdbe5cbcbe2f3e1af72edecc48127fd5d4504169d3b6476aec0df0a26a4dc4ffdd1f6f151b7ee7ddc7d5139972fd37e2c122a965e7620d7d6b264a17404f10f4a47104fb0078741b5d02beb7575030b4b94bc2ec7b15ed1405e61aeae5800d09d6c47539f737495486755c3571fb8d248fda5951f40d637e1664c8aca72a89fb135e0ff14a5e24a2bddd04d9bbc48fae6666ecf10e97a0b5fbdf132af9d5a6ee1ec9ed4d4ae15c7f217e9cdd24d3e6a8cc7e13da57f6441f71a9fc6b41479a38ab6fa1feb89184502d9b6d97a41412518fb652f822e0796c6b246e30551bab1fda3c2fce5ccf06cad4674d724b8eab88a8abfaa6f27e3ddb444393d83d574c756e6a0524b35208baa90fcfa9dcc54771aab2e5f97a82ca8d5eb504b445a65c7f45655c59bc5208bcb75e5409c491e3c364aafdcf39710dd158fb2439174f0011d4c0ac6af46f6597264f16d63a7bffb1a845326c0fbef0b076eba59ed4fc95b8d8a627269c073a14e3ef7e20216e4532d89b4660b5865cd8bcdc474561edb9916333d3b3999fd856a27dd43e7a02b781b486ff4f87945d213ee96c4a33f43d4a8d9a498c20783a5fb1c7e9dcdead9ffbd3ee48c73e93a7e376666d9c520990a506d1bcc9ed8f73478da297dbcee114656c0dbf0366ede3da9ef77fd3a99b2bea40b13d91699bd1dc72307cf6a178dfac2b72adc22d3e82fc02f0e71f487f250641924c0e3103594080d57ca58de7a033571794e9357bea1475120a1eb37cdfed8e527d114922e51f00247160a09f76775115a056ad7006f8bab8db68c88f003ec9af675f5b1987b42b43fc2fcebc4fe23eb03ce18e92dc5897cd657e916ad6975731998998d09df6367bae7d9fbdf807f72001c0a53f825cf8767d32f966bcd00e4869adfd3cf7da80f68c4f4a048b9cbe13b6c23afff0f5a535d06d34f4edd120180d50bdae229f223ba556a3825b4be45ff0e9a45c99290f56e3fb2b5294ece8f63042d92dfb9005c0a8bdaf13d532df50ee6a48f5af12ad04bd2d261b897aacb807f987997beae51bb6e4d7a2ce22bd1ac517dfcb00beff16da98c1fdab73e48dc93136a46e708bca23d0be1d9be8ac6760955215a45212ae67a168fc2f4835295d5bcb0304f6c65173cfa8b08de64abcebc29a70825bdbfa33775c24e2f07f05451bd0e2ed91637d75e52aaccab72cb16123e64b45991f37b1a4d50d6615e480ce5f276dfe1c38d6bcd64524fd91ffb81f51370846574f24ca95b5b18956d2b798d6e378e0faa30ac7ae849cb5e81b3eb4c26d22d04d5ec941524c5958a255470f67dae49529f117b58eb899364b99a0bdce41ea811c24e8ef52ec405fbe8acafa09a5b5214618187982025af5eee21bf187e3b4a3eb9c822f21b15d618e6bef1939d0c93d5618c4f40a4e4fa04801fcaf623ed1d088552cc37e7cd8d61ce0862f729d6d0712989deee3f845d603fb598accf44aa9f26f890ae306f822181004ceebf02a06a5137a04592b64e1e38cbb73fb35c781b57681c370bfe0ca658237eeac879df38435b80e46628573a41f13237bfeeccdf5754c259b468ccc06a2e1a170fb383ccd00aa41dd1086822739f08de175e28d28f292a1aeefad01289d23cb24ebf8090b50252c2dad8a277d6ab9090663134c4aa622ebad9cbb968238dd341e48eaeb4c76c978fcceac3a7413f174590b58c701eddc5c7ea3a296efb92a4db4d93fa4aa36cdc0f93728b7a9f1356b933bba4810112ed9b0d42880a680a885975c2f533a48c261a8b79fc7baeb3d4cceda2df5c97983430b00abb7c30693db4851600471218556fc63e8aad0e916f6dcb0db343ad99153652c00b529cb35ccd51e8f7c6b9786ae899dfe8dce9c442a4ccdd855323c4428a7f7da5e4e927c5ded98d3cde07d55215ea06122a7373d21a56d8792e4fa764914d0489a5c538786f7a944af74f09e71b70ac658d193845084a1856362d395b94b8104c05c7f75fb8e1e2ddff4147e29ee17a2ddd90892053b238b5f49264dcd66e5f1326128348e0845ed021d102eb62f8d7873a6674bb193894a07d6882dae4db1896a6970dddebe5d632e74d2944bbbeb2290f174b36d6bf03108108377033e1849af7bb0e9fdc7e2c4eaaed89867522fa436e6854385622c978d0b178122a04a87cb5cbf510d17d6f1f7ede14bded039dc7d19793edf03f6cdd9cb8cb8ebc6821e050ffb86e818387e87552f712385bc8c090f7339bc5d55ab0b27648f56a62f28ecc885dea335f3aabf6f9ddb11cbd52eda50ff04fee63f0a9ada8c13d66508b7c7b533d036cab4f3d549b39d59f1c73024ef5492d95890e48a8309de85c06d175e49dc886a84d50d4d57f4692d03ec3fd07e11c4b5b8b492d35e971f2a4d2027f1f327d1044ab7a2d32cc172bd542d052cb4b7aa847174c80cc886284beffb6bbb927a73c07d1b14ecace82bad324bd0e1684759c697a8012000c5682509873245d8dedf277d9f478a6a54776dc09b158c77de09ea29b46f1a723ce69e80a64225ab8df4f526a97e86adafa9bbe51dab54c137941a8920ac67f8b5c9776f9ff7fb2a381a78a7e042233e5db0832e2fd8af7979bd2c2d73684a7c5f4d69d2a507b2bf679d3f38f15a4fa24faac3f447c2fdc00990f6df83493bdf98d9b3c03f1c4070a4f7e2cf512d7d3bdc85c2fa2866d4b6a08352e991e89acdf750c51515a589080e4a5d050816d73798a41ddf8a840dd964718e36b887eff2e86d72d5ba43d515203aa821bc92cb48ff970943cab7e9f8e11aeea069eb61593bd9c4c5a2818fff12c4ad3532e22303617c1dc308aec0ef1d512e84f06e0ae187c0c08f666f59ba24385b4293a8bfea1b776ab00694a38ff7e2f3404430499617c389b2ef9ffa3cbd474001bb117027d2b773a9e650498e54fd79e1a44d2f680195dc8cf51483756ae3d1e54acd159dfc194e1e774ddd64f8a12fb4bb0319b81fe882cf757a6048a33f7ef4224fdba316b894d8e9dd644b1ee992107e2c4ecb07fe94883a7913b0e3df34e0ee0874232236e165198b8337facedd98b1435d5b09a581f20cdfd688abc2527c9f77faf90aea2abc48165749e248e47005630d9d6ba6eac79dbe65bc3e06c96703a8abf1c94912717eca8e126e220f9bc5d92bae33fd365eb89d97a504f80408c1fb84d7675d1050f992b596fc05bb2e4f2321785c0eee4ec71dd639a1a8f37b77c4c10b3e843525c241b5c5b26133be9236c04eeda3b616b67fb14cb036d967e57f008fda902237729d378dce1366c7497f27666f6c7a6d2d9febd4c00f4ab1775eae371107dfc7163c61f3e2d5c44e1528d6486501f44fc2183be25c7c91b83fe482e6fc4507aea2b6940af8cb323d2dd443230ee507d7d4c6750b76721bf73b1841e951e10dc3cae5928c1756083d1be49d0c9e7099a24bab80fc69ac76ed769cec894289d41af02d78e51f3d9570a72c6cbc20f00a016cbb4c0bbed366aca4689b038ea23643770ce348979aac37970678e912334e63300535feb2ca830696f49637a36a9fd988ab31bb53f13dc06589218388c266d1cbc6de1971eec75b1aab8ad6227a3a38d4650f062a5f31c6314c0e44623d318923a2e81ca0915897ccd4b4aae314341f2e10806ea33a819c1047535b33a789f58371d3aa492c78b630808b560f189328b4c351e2ade26dd8a257da3a4f4c84bdec5f1ce69f815c34ca0cf19452d4cff4d6ac3f5078dba36b463bcd92484d8c1d129dc8a2d76fe0a6161d8fec710889820fad63c4575f9989db18ba57950036eb6622a117405b83529a6cc9c00f13253ac7bccb1aa61de7c865507cea67c117465675884f8b33bf40c01268195d3c2c5f43db784e56bd954d31c889190f2826ea1111fa38ef60b49f437ac2cd33a23142893a471a3f80253d1c5aa50e527da8d0654aa90e956cfad47725bd2ba63c6728001b558c70e03fbad1a285c920d190102a5f1d9a09ecb258ab588e5b8b6de28c86bf10bbea90e44be2275eca3d89c35f12a4f5f349eaa00723b342d4c9deb0e39d78716ef7dcaee78e380651928f86b8f31361cba32eb4a0ff3cef158b29c10664536c395a34a7a97d256e7b1d610983041d538237d36bf69e60e6ecc066110695dca144c733f504b2a32a8db19455dcf53406613091409120bc0a435493e083c881220bdc51043beaa47a4b0a898e41f547b4a92a059c699bc7b8648ce3d9972c28c42b3a7bbe570cf51ee5427da9d1e3d1231f628dd0640f967e12ad380e4bf22d5017129598e975d4d7a49eba3331c7a1802f2d36a9420c0b8b71691caf1d7ee8ac3679316e495ce5fd423f8a11e7be06abf782bc580b5db4bbf35a510360362f85d3678edcbe78b5d21545432173ee7feed6f365f9f6014dd152b5ebb4a8d77ef882fab2298270c132a1fbdfc10a5dfd91ddd4b6a87b53091271eed8c705c1f4c83be99d50cea4761d732d66fdf6b42aed4b89e18fa45083df7883616f74f4265ba1134e24ded2b593a9cf25eccf0cb27e280eac692d60f1678d79677d09cff817c7906548d47ec633bef3e678a8071f78096c0b35d37e9fc858b2d9e29e6370091546736becc2baa2fe4f3269c9981aa7a85dc6ef2beb156cc70be67685a478290115991aeb1f8a6830918453edf4224365d5b99f627b467cce50eb107c04da49c08059e3d42d5ccd15f9115cc0b24dee2bbd6987b93dd13cb6cf638d80641b27bacd60e6c7884a146fdc871ebc63cbcafe6624d05a9e39ec9e66049143e3bb0761886dda70d773290b1444e00d22011d7d55c9f2e508e6ab02b986593b8a8667346124bef7329af81a992a3c2a9b9506297a20441530640dfc2d70a0f2dd5a4830721709a6f5dd5fc686940b8a9c1befa1812f6c9d6e4cfbe348bc43174c691b301ad4c4d88a4252bc6fe7eddc47541eca367c5c7df451cadf13464b728c876d234bf8848af2f2a63296b11fbd8561e28250980343bdcb75f7c0da23a4703d674c6864b8024edad19ecfb2602015d6c19b316f140805b37bd5b0cac012de364fdf85bd67b1cd78fad5f971b9d6eb778c75ff69229d2fa05826cca169ad994eacf71c840861214e55fb9a0f4cb6e632d7d6499e753febd4b33781b8ac486810d85ef030bfc50acd4c59863da8c7b51094e0fcf6dc02c34341c532e7947f04c2252346d578afb0f23abde3e49d7f0a534b5e4a67920e069236f5b643d4c947b719f1a0f8e78d65b3b926518723c93cc0f1c5a40817911d00f84d3350fc5af7414c8dcb6911c14372767f857f7fd36ea21f9c17e0344de6344bfb5d4efc543e8fcff4085f932762c18734ba71f23f3d3fed7a3db4c2aaa6da1cb8d51c908c984068c4770d960ee63d09de775a0184443746db704128c0707f73b261bd816c058e4a608a22921468a52f11817d38e66f26cb6b786939f45b1f434999a578ba70ba41fbcb37cb01d2b0b4314eaababd6fcf3b15041cc3099f98f2e44af44de0e1d4dabc03c8ab5dde1b88f94e5e93b7bb1ac6121b129830ea4d96b3a579b5d876b1efb2d18288d21d6cbe2ddf7211b44763b142e75523ec729f48fc5e46dc594d4211e93611bb3bfc9583426adffa38690802f82b3916c321bd5014831ecbab9a0e5a058574166696ec68543e4ff011ec5141fbaed1f2cce481c315d6fadef377e20c8e86a7f05c84141f2c0e242364671f156db333e9209460a461a1833fdcfc94406d14fec615234746245ac6eba32ff67c81a312f7284a27190f6e8c2d35183a396254748bc0010c8a317a6d9a2e75085fa8369d33d05da28a171040cacdd60c5c49bcd70dd2a0300d82ebe09f2441ef3d3e52feb182c57ecc419d43b7f79c4615aa868a4a9ab72021e81daac4cdfad000051453485167f60bad2fc6429bc65b163868a325ab554517628cbd4c937eb799e6644d58209faffbf831366f72d1c5d4f7eb484926283764e7274dc0d88c614a0a6bc0df2a079af5ba2261b977a2f8ecd2788079137e290137f6961804594200ed5de00c40c9642c6ef821697f31e2e4f01196f45584c8b90a1bdb33c3964769233486735df788a4541ef153ae1edb11b329390bc3b296d4d9553ecec72ea45bbb6936ad3eaecd75730ffe2f5b57dfe4c55ebc1be062c6fd8ceeef3fcebeb1f93fc987b396ddaf9f9d05be6a54f28f08273aba7a12980b0cf1c53b8ff8cceb925109dc10587ae6684318ee28a85f8b1f4b3289c9d230b98f145e1de12dc4cc368ba661d1ac289ecdf552f35aaeab05dc0776f6fcc2837453d7b79e5b1eb9cefbae8525d299bdb3be69e9d8746aa3d5d7923e2c80a246ad5f0f2e9e9ee0ea4155b2e48024ff53bbb26f8cd914ce23cce6f8c07230009cea5b6556b0cdd276997d88b64b2943d95b56d35f3a3a915b3c68de026ea3d4f9e34ab1db9a0828260f8ffcf0d9798b3cb45d1a77f35a5a4bf09f3479bdc1b4d8508f1f6007f026bc01d9ef2b1520498fd90d85173ad1865a964fddc32f6b4b4a9a62baaa7a71974b548e30c95087038cbee310f024b07f104668f435fc6ae27328398b2ff9b400651d2f27fdf8685d5c8262c25031d6bd2339ed2640e4b8df638f1e64435e42e0f92f8c60a98f3e150c119866a542dc5560006a97b6477b19c9c5b34dd3a56433cb82948a015a03f490f5ee56c6b799b2455ad06675d27be4e04d277ca4906dc440bf459cfafdf4aedb098810d0cd9d03112bf3633133b88aff9ae9ea4fada31fc518b11ca9ad84cb811202fcb240b53591e4c5983f039a20581319721452b3a5b74f728f8127aa23dd9281044a087252de3ca37a4d7e4a1f34fe85db053eaa55f7e7b89d85015d6647d3c1f444b4906a273106de6f880c9ba1ae4a48cdf54194479209f4edba3bea8340a62ea9d0fa350813b1cc103f305436bec3d9a51b392f0e8cf28cbd5388c6c868b4abcd8e913ebf4f72587c87b60d836135c4d904948245bc760d4ac4c7acb233dc6e49a7d6db92328acc8c013d26e0c64261d5fe4e2de4d98ff55d1ac60a0ddd43a7a4321c124e6be44415854b2c166e5c7ed2f667c6a8a47f0a91e12cdb8d25fdd71577824543d5d300e1d2b1ab188e8e0c783959821bf8246fb3cf99c6951a406401b6977a643bffb8024be6804d8d5e3c29315b283ff47ffd7db9cf1a53eda35ae5b04f739997603c345f500d50658d7bcf827e284f11ed9a03f57721d80d00e87dbaec3639627a1605fc4edb6f4b87442321e9d6fba0f11860494d3ad283469464f82595d77e00c094be6d59621d45503d3342743a53ff504e623bf43a774003e700263703219ee183015de0217a6d9cbf6d42b41a2fce1830c4d2df07e891f918b7e57bc9d072da4a95398af0933ad6405fe8ac32f0b8b6650ba1810be1fd26c5c629f92506733ea1ec14c5137de4b2c30cf83be3b1bc95c0493f4b3169945e12d30ec453cb91d706dbc55184c5cecf578ac3837c6eaaaac1ae84ed86c51e350cca35b5e659e0b1f6b4ea924391f0627234f26284e991b49a204cc026092260dfc9b31fc6dc1801","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
