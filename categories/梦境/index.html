<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a5563ee9d0d807a4101b71e2678d18944b7bbc56dc0797230fe203a69a74442006f365a00d16d59d9af571ca884f919f647cc25982f7f2f8693eb57174dd3eef8a04107b8f1f863eadcb3fa9eb2431c06b2efafde5b0bb0e8d6acd836c30ebfc0859734bcf2d8eec9360bd1cfab2d29db88dc16e562a97ad33d0c9f65713b4a69cdbcb84b3b8f0cec82ebb4dda8594fa900cab2b94ffdb5ee2f866a2ae308dc92426a79e4c47318bed7d0332573a1ee44a83a5cd777b195063370d8a421250f4f85589a2e69659d65fd11d89425a4d2cafac3ec89d3ce52ca51f7dc06a202497d79b93fe34ac3f42f8b97d4f380faf47353f5581094a1bd19eb6c463e383d14abaacb1faf57ed4703c7a448f4983f237f2ee6a33e320fb3ae7dcf5dc1a3cc5b01d782b75a08dedd2030d21c742645b5aa9fe4d0cf100407f2995e8ce669c3afe7c871ed982830cbf1ea71f4b79d856317da739bee6dd013a00460cf792673aeef87dc50e2fd0176916eaa8c8878403da1d21fcbd9b3d2b227116662e1e4d56e6316602f476b9d3cb623cfbbf01e1607fee3464a07c5d17c01d9fcb04c06def006689364398e8d4a71c38963765d2cdc905381d593dfdcb69e6832dc3fa1206f46ee3a28323709bfb1365622e71e8572b1f71c87b42987d28f22462c24437dba9dfdcfa27c1d3d6a8a130a1cb3c75bc3bb96898557c05533566b89797e3e47408a02bd1b1e064d3bfd17dd6b6aa28abd34cb7f50bbf289d32a68fe5616064b16a8df246fe48ca7969c911b9a3d4c6164c859e070554a5466892766b8846c9db29565e96443d816be3d54521d9b26b00899d0803a497890a19c8841d976b97500c8e560ffd36eab7a9cb4d47be1a526911d5b05214451bb507358c8e128e5693798c49f1dc608bced4c8e90fb289c1d0a17ed450c6771d58d0131afbd86f25c1504f881a779ea8e65664f4899a850784e95f67c69dbad1c65f89e879dfad84128ec2c3e3e217ae847ad4f5c0585ee330396378bd9eb62296e389e09398366bc8a2f43992dfafca44d3fc56e64a46b139b2e8decf0e92459c7f9f0d2c84b059e06b59cede4080694f7fcc431e24cf7884b345d7c616d4b736218bdf1fe20517e76755a728c1d42d787ada230be2283f786e2d7d5b631c0fdb8a210fa4baea87d1f6f57ae7b40758f2c9dfbbb8b55b177b993f48928cde553386fa4ae7c12300c0414b3d0db41218f99e4c70006728c9575d910b6592b02969ca5c6f2fbef292e5ee21bfb158c2045e085fdd856dde31bee6e8b4b863b9b133954a7618e7350a95d344c430a5c50743dbcc259f2e61b5715076176060a43b9b8804f406f261d37d0cefbffb67a486c84c294e1945ce2ba6a43740f507432e59dbaf4e6c655182505c5daee40f866fe1f7e101bac4f9ae1985c77c215a3bbde639299c1a996ee0ad9d537793151b0312d8db2c71f5d2471a8c2e34d7d2c75a950291a0b443e9a58840772de573a20d912a7c467a5669c83acb3569bd51aab78d0b9b6e0e57f3370e97b536c4d7137fb528004a5a3af52346f49589d0eb99fbce70333ef1d2f2bac2355d7ffb27518beee2e8252de88bfc21801dbcb2df6ddf70c7e460607f759fa0a057c0aa73df502b2fe3c2764b4f019411a1a9519596bb70fa400e66e748457913902e5be55c074d6389bd362cf028a1f42c7e5ca021975554e7c1e8efd1ec7bc7833f344802e1c549ef8fcaabd940fa0b24e35b312304d746292e1138d23917b6bce1186953ba14474f14603b07c7cfcd8e72814a4001573adef142743539b44b7ae304414717ccc20ce0a9153c0d3a9ad0b0026a210802422f4dcb562a090154a0b4b6aa5c566d2372ca7be80f1bc333b0c2e32e5920ad2e79f157b41d1ac61054819477183c080913844dd8c0f9985c72f66d772e433b9a146963250448e8396cd3de3e8ea8cd444b637e182ae747360cac80da19878b404c3bcf944790b08dd6da6143497ff9c17d9f82d999ff82dd986d9c78d7cd7c5eeb6aecaf08a93e8a95a227ae1c14d6441ab009982910b5407ceff26a2f67b8b192d466185660f4bd97e0c298cbf06297eed3e04b7dcc3f8e0104624a20817e7d9fe630d8ea6c15fd828c076f44d841e04cbf39acbdd07eba1f747ce1b260ce888d4d8e140854558a76e47caed22ea1d7818872d987e4c8f159d0d226c0351f016ea15b17c6e374adfd99bd0d9c01ff5a8efedf6b795caf580b6164a57b237574bad7e06db57411003de61583c5de8ab42274fb8644c7d592471a8352e36be7e559dfee0c988baa34dbd1102028cb7564b3449dcebf377f29cf6694011dad51b5d39e1e9ea9c9eff134e680c4e0e48b914e04122b9dc54c60f20a743b7aa8af708e25a6b00f5ed641eb9cca2fa7cc66161f21c6022e0e18e44e4716ab16cdfaf97f5019c44578be20f3f02d7e4c5c4f21dec9a69c30bb0f9c1c418e0befe046149cc0fa78ddca7fe5944188dd8bd3c71c9e776a3e5900a785d5b3fefe2bddb832fb0eda3233d2baa07c7b4518b3aee28609345255bb557e5534f41d002111cc927e6c96b40567ea95796d9da5b73804f9ef65ba6f7444f26d926a48a16414c61264fa52f9542b39749bf765c8216e6f3f34c1e278d40246d171f7ba61cf2ec5448589d5d5b7c11180ecbb23fabb00c127d25b1d12d5ccab14787fb8e3e9cf15233acfdac5ef9798c6a216be71e5bcd5974d9ecc9fea503ff907a60b9bab9db3e0a213825fca56cd8fcbb1c94b89cc5c8776b055b156654739f4b16c58e4b7f2f21614a5d5c23596b3caeb2d9e1d8acb8d5720e95a8700432790be68e0dcf104498227290316f755513841b75ea57b0bd50944270149edf367950dc0cfaf58076de3288040091ae3b0dd9a7dccd2e7818d59c963fee7950c79778fa70a5b5511516c7c69ef8d7321b4ce3830e76fe1210c3c0626b7f7d04c503a22de4a1058a6852cc0b344def4c2c17ce1ced91de4620d249448a9a72d45d32bbbc2a51d06752ecb50e5ad90a343f6e7da42af18591f8b0c3acadf44c4cb3b6c590805df66c59e5fd60e8fdc7245923fab5bfb84d61a9420bb80fd5030f4f0112af3c1bccfe42cbc110c58c3fdc6283348c6890bb2eb974a23d83ea40cd26640a778fb242173343431df745e78e6d78c1e49af6197ae15fe94b82402bc1722d6aa0480b191bc5d6c5ebf17ba0d3c031470c2b2a61c3d2b9a9521ac0f9cc4f565cef5bea42656eaed34577b98c9546530640fbacd8df229864dd2f37204beea705b0b01e6d249acdd6db8ba403cfedd46e5fd7a35f002bbcc01a0737a6f43beff7ddae69278dacbffa57f2b7c7482ab673d4df5a6cd2f0b39a3371569275e9b83bfe3d326a92aa97e206d37eb2a4fa5deff516bc1abac7094d8ea6e460ec0aad6536b0bf7b23bbe418f4519677265482b9b7e417a0ed035496f8e6c0300a0594a5725b0c31b5992a9202bd4cef5c57c8d835b53549c29179dc9e1385ae7676fda76df110c619284e0c0ff6fc3f4c7f817d97676e1b1cb7ea919e0192d2aae5269cba1182b9f6cd9d0894c1383829c8ac39fd74d5e9380cb63d31fbb22f4fc664df8f887ee63559312a342dab86b94481006d0ed4f773afeae7c108edb5f48cc0514d494ffaf42cca6b843ca151bed4aaee3ba0b21e01a4164abd57e9c212326e24f067deaa3f7d8cc9a2759ea1705b8beb60451d026947760f975a5d8064e7db47dd623e426a96477dc01099c0bc9a5494374058560184cd837a1e28cc30330a7190f641f9d710b0320216b95036d23b6eded81c004458a2d3f34cb87ac4b8f396f0999acb907c14a36134b6695d46da0b9b6b37c999abf2066613e5d4cdedc66948650758f82f4cf61bed5ebcc4ece956a53a40e29304e14e6cfdac517aac51f4b11c20f1eb72188efb758633039703d248af6e3080767a72b00a0f73757a80aa887168aa53b9acf1a98403b769807f05bf21b35b1c485a9dff84669a475bf68612eec8211921cd7671610b68b9d71e0b342930d1167c89c3d4dadc11130c31481d85ebecd9191c8d5ba376e84459a6bde910f73ea92d2ee6af547071cf4ce219498836da4fc33dd9af751ed400dc42143b680a6c2e44e8ba548f415bffc410d35159dfaaafdcba122afae085424f5dc927e158c8738b1100c45ad801a29a6c7f78005a6d1867e72d0aba443782769fb6fe5399a2ee3bb55bccf5dc45b15defa8c5b0a3b541b8e434c144355a2e1de0b2ce6fb7ac95023af88d077a53377292e69960a54b8b83c28d1967a6c0ed4ec783d074591dae29367dfe5f0ffe86a5aaf6e4ddb0d3e4ce68df7bd70838f1fdf47c4e0c5f88484d273ad14b2016827999a10759d3883fc53ceb815bf4ae27a37ce604383a79eed2660b279c8b720b508bd55256a5570921b44385e9e52dffa0e225358f3a958a2498db17c84a6f6650cf85fc8459012e3d3726930ac3a21fb619655e7b772853100b600916d91f81c6db6583d38ed4230b78772edc4348cdcfd0fbe7d88a9c9455a55ce22ea620802c305d4feb4cec9626cecbc5364e35232e98a85b56e4ed423d374740fff0ea7eafd656d3e0092815dab5edafd983f003382f1e7cd3365801f485c91d236a0a906862b697046a81f22899d753a6d36ff208a41bca4caf8256ec7d3709cfdf25f65bb30f41d1295d80c4ecaf5787e53eefabe6f1959add8a8475f23aec0d123b37434018fd975f7c7dfd0bdac101e1ad695024cebdca0e7782d5b7fa69bbdc700e89e25c39eb8ec80dcd486bad27efc61f24aeac52af92d9f66109fe1d6b5a8702eb2d65766695b07a76ec761563d365d15fef56f0671cc5cc1e7b098a45bba90fa4c3d29ab5cf3bc4f06e40c722e681657079bf8b89332e678031ad3f950d644d33588b85a11bdf3c05a0eb676768a95c20f89b2ec9a284dbf4934c4bcb8d5b55c7b405f2de81c3190d33b968752e11444186fa211dba7f0053b20c4dd836ff20229941758ddb437be12beb6272ee403269629cd631e46b652f88302eb78b680d1714f650a2e560b6320eeb5d2a02116c249974796f51f2dfb751a9c73b8b0218ee7af3a112bed48c536eabe639f3dc549154a82e9a36d2b58fa8751631a0aefa2e7c3573986d3f602ebdbf3aa8b34e977975424406f1bcc55c96152a803bbd7f8bb87e77f59d5fa34c70ca7ee4e8d125f02ea24e07ce5ea0299173b674b3becc973ab7dbb91063ced8d5f56f57aea0675c4f6a8dded6bc339991b0beff925f36ddd67581db90b33a3be996abea3b097e34f2f68007b89eeec3258f21e98f918836a45f821d3385138f2555858172d8ae67610746b47dab7566d32926f8d3500f1449beca89d66c6879624fed3816c3a24bb4a92f27920c327d83fb4bcb6e8361594bc7151817a1aae4d41c809808845068bb3d3bdbfd451c5e5545ffd11cd9bed3197ebcd58801d45fdabf77312b512a1f9d682ce6ba97640f7c23491a9c3a77bedc030949e8e57e830d50f3c905ea3ccc7d58a2a6cd57cfc778025458f8605eb3cfc60fb9803d21bc040e5b3eab53ef24074751727793b299f068447f65daab7a56f650106f382522b25dcf85a1a962ca5188aa781898f39fbfd524e79bdeee54d951ec89c753d86c61fadcecc12cb37ee204af29d556fd82a57e264a343e82a9ee531e1e6af008d62549a4da0e743a1034ffe86bef928f3e110269f4231d4e087079bc03153f80dbfc48ad020033c7efc54ca94c18b8c91fb871f03bc86a1aa3e29b0c64d48781dfb89b9655b3e62b8c8bf18d949c2a343fb51f12d7f3f5947bc344c00693b960e41743aedb550074f9bb393d6be04745918e6bee62655ee73fa5395e7e34f98505e5c54a848037e13b8e70170e4d39a7daddfbcc05b66f6884e9bdbfcdec461a7ea2d3b0aebca58ba6ab248d6ef780bdb15b348ddb7b6e8f3a624349ccd35079afbe7576b075cff24ea91ed9d6b0da9a5a3751f413ddf144561441ccc6a510173a485e9dd96a8859224c9b01a3d419d67795d5f4f1a4d62a6f5339c2f1a9d14dd4eca27325d6d3e3a22830f3fe23a75209a1a6657740437f55ff51832579bd0217eb1c8534cb135fb016af519c4749645b3c9088a50177bd7472d11e5571891e74290b2af2b81eb35968abe58537bc8c358b32cc5e9326afe72ea9b58010d6b65605fc468f4780bc5d70b49ba091ce72febef98887c9e8aae42900b25c1819235e3cacaaf76416bea5208cbdeb4bd5193eeefe1d2169efeb3c38b2cdb4a41d240cb901527b7724d741f3e801e6cb7931daa1c623498724d76e8785f94c2db7e6c6dc9afa276599f259fda2b11341c0b629ff1fff6b37b3e59836cd0fcd19118e97bd8a86c5c9b4fd42e1ebd77dcb84f7bca8b55605a2d3399140b831d932b3dc505a89bd1bc30867785ac8bc3ae64db3247b839f84d4946ee24e5bdc91948894267051e776224f4e3803618b1a2cc97ec0a0c4c551e725795b17d5a8d62f04f29e42c57f313b2503e573f5f6b679fe5fbd207751cda045fe6a49cd1482ec0c8bbac2e5efd985a34193fb0f738a0a5fe1defadd6d39f68181155ace11fca184a3b94786713dd268f05726cee9155c74a4829d3fba2fb0c1d5aa5b60a44965f7cf8046f149f46bae80a7a9c435cd4415d5b58a04b7b80b225a52731a701c9607cec0d47647039a42c122d44c7c90a1d13590c0ada4c6c8d4b9b86e28a22ec1e5ab8d4d2486768284eea21901f135397ca3e56c607d5203515c3e75a2cbd885d744b03c7fc6b5fd2e9cc32191ce880fa09ff1fc63a5d23dbc38e15ee86744d4a336280ba0a2cd6959e5749480d1c44bde29ed9d4b1441101e7a2b09240c6159c19c12b8e390d9d8908fb3de800cf98b9ca043115365b25e8ee45c2b227022247e13e78f83fd4b9dea1d4b44a0dc066ec41f25bfd7916d3a79895f221418fc0c534e11586aff6e8b263ecd2a4ca32e18f1d801fcb9972676b636d62f2ddb935303b51d6b5319b804013e0058221709424a9e22d9a86fb4ad87bbd13190c2c0f63eeccd27a54990ed72931d8bf0269d24046ffc8ac355190cf1b95b14bc138f206dc93331a753c086292f044ba488e32aff9bb58638929df1d1914a69751e8658e2c714f438c27f1e48f9f5d13c70d8b4fe1a7bdbe0fbae9a63f792a4188077c860222f40040be5049f12c667e3035979c10446a16779b006d740305e102c0a0f0f665eff0b10989a1b1db36fe76eeebc3e35b4117ad0a4c58ddcdee7fd0aa4f4c3b744b13a627d2af293c52e02801ac351a53f6e337c615f8a716397a9ca285969454d7c35f9867a8523b765ad50d547116b1c6efcb91176dd181a26f628bd62b8ad7656ec51c75bf35700368c68b2270187f46d97159cac9606ae3a995373aa5674682c8e429c28a50b9eba2ce6c3a4e6633e74a86cb7d53c997f0daea0d2af3f034975276d94eadd51076e05c13b53426c1f8b64fd20ece1ec17aad2ff01bef0b387abbd1da5986562f8dd29b830c22931b55270cb89a7251162f9f763cc45a82721ed0b29469fe4512787a7a2051b0b772dd426865b04f1d4b5ecbf772769e0bc52d756a1f0d8efd6d9f9b615cf05552d56829d97dea3a436430de97956ecb62091f4e203beb638f4affa12070881e802b3f337abe2ee4e9f7b9c3b3c41c259b084ffc9a3f0df75999299bfaae7aaf993825b6c367e315c4b8e487b93bd0408082d65eeec953938bc0832a08446f1ef574d343591d45abac5cfd1e09d2c33f7207eaa66437d6735d6023a8e9af6dc4be4a3bc46ed1ab99a3534043e435bdbeb882df9b4fd65acfe4eb7feeb398583a34cedfb3cdadc72dbe3d66c78dd3cbff4d4020a711bd8c4e54a29f056e95627f1fcd9b0b6ea37aba820057899c18e76100a9446200cf33daf2ac5e6987ce4a28ed79ce49d9149affae55677d16c9acad88b37ae403e2be5128bbebd029d6e6b5a0307030635a368baaa3d6a8000f9348c26651cd55756b8b1a47d9d4e7bc69c242df5475e2b48844bb2fcf3b084e9fbd397f68e4080b5dc32ad5285e786cb823d0a2387536c52619097343d2df10e8d099f4c7f85a9f092d05e6ca9a69f2b5f71b47f598f07b39272ad36e99505a384adc0238d34d94f6c4a80b52a2a6bd511951d922c4a5185cd1c63f4d082cb67b327f6c10f7d0154a6278a6c17132cb8c0ee559d5af71118660383a694643ab27fabd48098cce0a1c66e99fc308d6e8cc6627f7671efc7bfb3c0ca3094e95b1d41be86f53ca8fd97c48406c025ff0530ba5caf3ddf2c3b3c1577b9e413bbb9dfa147114b13d4bad22cba3910a6afbd27cb8c483240a738def31764fcf12c94f39fe7948b14314a581a1bd0c134533bd50e77946e3b67aac732e11455c0da8e0e81aa521f94122a45992d009d18b3978a6d508fa6564bbce43b5f3db21bacf8b7b3f89efcc36ee5f992529443c7aa94025686d130c14429f4807404d0f9bcd969e3e9d4f7196800caea5d4d36805cf2a3e04cc97097c0365f43f3850674e1a748881cd363458ac16fc5f749679d936a086d8100ad6224d860e4a9b437d53ebe55c19fc30f2e4d6f8091433cff20c28b1d28052a19f03ae33694f8e4bf4a3fc117fc6e74d349dd8d0b91275acd7abb37eb50839217ca8bba0075f7f5b59e9632bb6eb415512762c4c2fdea7caedd9960bad148c1a3f8a4afc015b1dfd4e4edeee4746de5f68e6719731bcc9ffc8cfb1560496aea9e28afbd7ee8dc65049095c2e182f5c275f791449d246ec77c557e6bba2ed5eadf6030e6a634d39727585c27e51ff9994b44c8523ea1f1b1104463c6a85eff12c1a4be1a786794d74295e421e39be91a561ea601c1528e2c1d810e94ba58a60a6be6e82a4fce075ec4b10d7cccf5039f0f0d1b62e4caea24e1d06a1138fad21a163577493d6d37ca81702b54508ea69962933912e6fd81dcccd1deed6d331b61f5a93d5b07e7fbbad61b59fda25d608ba276019c715005aaf2330bc145475860f435a54feb064980f329cc12d322c20dfbdea66bc02f8bad5cdf55742ea46ede52986a9209cfc5c7a7ea17a593a98cd8fa50fd0a06062c643b93ec5a6d0ef0d247b65ded604959eaf6d59817aa51dce63078fb0f966ff7db946ffb79fefa1282d8ba856283f5f2016b67d7233e38157e04bce14460ff84333d4ec80ae72565afc3e90751f2b315d4eab40b6ce575455cee4c34d3529d0e5cd25baac8cdb03da73beea3be80e3df78acb5e0ff0e42441bef2d87aaf07872258dcfa6dbb0662712dcfde4ac9a0f0e3596eabbcbd9f6d406804be81121bfffe0832c4c38b7ae6529666d30349dc8139fd2a8ecace051b153fee7530ed977bf0ce45575fec43671f348d1528d6070b4ecfa06507d94866f395dcde489e6b2755be46cc6accceda82980930a18e28706b0c7490dd56364e033c42cea7efb054298c78ed8580b03e82a408704b8ead4c8a5a7cab0d3248b338c7d76cbd2b5ff7e7105f48c89e78c8afa4d1b8172367b72266de93787f107bbf1276e19466615d32c02e7f0b7ea7f8421758bc444041003567777cc5ede9270665ddf224ed7f67c77f8a3c1d61785d321ce45778d095feab1bc508045646402ccfca6c5ebcc45cde855254963f74900306d79b421f35e7c5838f871e56aef880024da05733f67297a93426c2324d46a22df825de97e9d82400cf5844a9bed16f3dec16bc72e705a1b4930dea5fdffd0794b7d741109ca32d0da7fe1ac4605daf26d8a8aac20645ee24e3123b333534f0c01ec5c8223aecf3d589ceab2aa66a935b6d69990a305c3b8ef30041dd4bd31586950802fb7979f35b63c768c463ea533b1b51d00da39a0100adb9af92fd56d7ab9f5c605841b245af8694aca48f5a718d529bdb8ab6171e4a61a550a3c99e55b7684f44291ab35f30431cbdd1d78e14c14efc04fd956a53c49fb9802391080002a8f5a869078c0d7a84fcde0e7fd2aa5196d955fa36066eaf3626e8e1265f64b7f24bce09699f5ba2c732fe8fd03dfb6cf684895dd1019c3939262578ce5c43410b41912c75ab91ec3b0ee06ddae23649a89cb7bd8c52351e48c6e201ce55dd088567c6f1d94c24f093ccb4ce9a5b59d1f258ddbb43618275639fab1f4dec9d68bcad21a71fedb0be3404ada82948ef08d77e9b292cff3cb2e8cecf9bf8d936dc1cb314964c8d44ef505e4bd35b0d1027c9c4f0673164ac2ce75e5231d084f56d4fe1839eccf8eb8c05c6069dd18ec88019f9d8f59e34119d6e89466542018f76bb09fbaac55b98d0a5e71339c69b3503ada389ae875cbe7694c5a27c75e44505a6c7d766bb748447ea1f05ac636cd003c60fd4d535daf0d286567b022f479b21646d8b6923c8b3006e005beaa63deadfcd44a335d6e550c8ecf7aaf1f0c06e166b261c2febacd50c820c0c453211be12457c63f3474909974ca507160f1e6874594699bc711dbb8c309ddf764f076b8006a74649bfeff2def55f69c43bb44cb8471ebb42c727935a71734f16eb2c59be41031b072d9e50ae0b21abc214e37bcabe6020b9ac663c9135c781175b8144f8dbaae4597bfcf11ef8bc3fbc92db9b9092fb4675eac13228a9d9b3cb541bc532628ffe3ac9a4b4ba87e8af65d7b027dc3e3aeaa686909a757aae57d8bd4eea9f750ea99a062d7c00c9c64a8d119d5e1038cc20afdacf617e2059b855d3547585fce7694d24754f3eff485aed87e8c03d6fcf25aa5b60c93e3b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
