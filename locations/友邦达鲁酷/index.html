<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5141cdfc4cff2b8f785145b44b23fa663e97e9848a4bc3694921815deefdb2eecfc04dc6ee3a473c30f65131d1870464f4cdae52433185bc6c8f2ee0f2d535900de9c8899d2be5957d7aff8a56d20f3fd0e65dd4e27d2c214d2d23342febaa7b17cdb44c45255f93587d624e7634c75087c59064244bf65634458aa3055b54ca9db851c0d7fce96d46cac105500c845bf2949b714d86cb7f17679aad83495acb5a1fea05f92cac69f6df080ef65acb2615348d85c63f3c32247b22a6aa48ae7d42724b89724d3154ddff31f7e5858d63b9595cc298827330ec3d80d93e54a59bd2526ca242fc79c6b1c6625f9e58377e59686dc904d6163cd4e0024db09a14baee8ecf7653aa9819e9461265019a847f43cb8818f646f62f09a2f00c3288e2ffa42490bea79ac022a0094349bffe1fb0ea2dd76b3ca12a3dce7900e805c1ba910a482d5303bbfe99288b79be8674690dcbd8f4b3c76afe9cc2d90df97386a315b439794ee09d6fd5ad17671e27936869e301917d151f9a65598ae29bd30ce78a55469e0fa80e2e86604ec4ff5ad6d1438ad5d1f7891ba1d7895e4e6c96398908a6fa27e7c6f79aefa862d3218dc2146c657ec33e4d783c0a68236f1b072bc90538cb284415a4aeb0e494ec808c4b3e95a29279c4aea34ae815fe1a636e17223251e0be608ba67ea27d164d7903f3d49bdd0b6e30907f891418d602a5ebfaf05a46b2beca6e06dbd2a09502b182f613504b034ac877fdccb8d29bfc0bd97ee5ebde50879ccc4bd012f61bbc28ab4ab0168105dc52daa3ed47682d243bf527ef98f136bb9acf839010724feac0e2916f9c7f39871e882b34671767397fe4803e34e3f67a74bc2ba612b7e4963b76d1f54935baec79793b8dca875afb0da7c0f7e9f67937d2ee8638f38bd90aa9ac26789df6774d9050985f0f8f9557556a59072d4daed02b4ea247f6863300f429b277ec97b5a71fa5c2b78fb9bc2ad9e2ead3f68c831551bc32a693d9cd3169da90033edf8ddc33a25875d81af8e3c0cdb0e47edcb169057215d148789491ccb0a1938da1864480889a8d36e5c15bedb5c1d06a084ccfedeb16cfded95bec0a1d91b4a0c7139126a76c1ee2c08b5c991f1748deffaf0c1d2c64b1c21ff3b5e82c13905802a6014f287dc941f1a0b914f4562a2ced94de87943504df40b1bcdb30c866150783910eb92912824231fac3ad157760b60ac091da461d11efaf85ab28fce0db69a9f3bde0e26133fe0c23388f1e10d66270e15f39c3b3a87cf39dd3d57dc06d09b7f40108f279958178772b05b5ef09f947ae1332d2595d01d9fbd43fb0d37548a6edaad275ad17a35d49968ac059feef5baf841a1573f53632075f98c985d1bc83bc5be41b591365d277af3162291cd44b9b439a98358b9ef616fd39836146b674d369b3166276949d479ee92a65e701fbb87c24b58a33d0e34838fad6a8f2758602067250b16c11698a948004c955d6cd439e020c3961a1afcea17939e6be66f54682f1e22b185ad73d905eb2c5d9524a16ab2c4a8dc616db2a404e2069c6480afa4c201adcb3f6caf1270a3774f0e15b01753060ff68808eb6d62b451c748b1f03a15e0d3d5cdac8e96869b3e806e3b804b1c74aea439f854a1e3e5274d6e97d3d2bc54b3f28be73d6bc3439b6d272aa3b57fe10b592591d6d2b19f8085fe8095bd0dfa6160e8b5abf048de99aa640f8c30c95c08cde2c4752c154fe05f0cf8d4f04d729b91d5294601cbc82a94d23a57546e3fd2d40d91ca1fbac30f68443c8e66d273284251bdd2f6be79a7e68428c6bb9bec7c6944a4153efa8ac29b1ada09803322c81b7c76468c272083c414b0dccdd2468b1caf26e9632af2c7a03e579a9647c2ce0b38bd4ff62c1abb3c891a0afebbe479c45266d5fc084156ce89632ba5089bf0a889b4bfa1a38d93a52db0c5a70e52a07db95461e4b3cd1c87844e31c2cae6606896b6f63303a8d36b5a019d83a6f51df5f0fe145c18588de10a0f370b7906f71f2b05d295d567710363e548be5446df4202ee5831bc3e40855b832ee6890dda77526357f9d1513ed5ef73b32f9803e677c28dbd6f4a6d868640171ce7f7be1ef02cfc01aa3619de928b5c835041fa005e1331628f55b0c87bafa875de6404b5066244f3679c03f669c7ecba18ff96585d8c0267074a4b9fd2a5b540597eceea632480131cc8caa7ba0d3ad4914fb53c654774b969ef1e785204ba88429f4f50e9dd5a0071837a2e49bc8ef4bd9fe39edaa01cae6a839c8cddbd4045496fb4d32cad6cb2fe7bd673f039c63544c5307a0e2666546f3d1e4e075d27f1016072b016dda77728b49367f858a5d4bc2415ed14cd882e1a0098785bc225a4e2605b29fb6801ae270f9f1b47828c68ada2cbcf3b260d3ad49d70248164f886882e6eaf62e3b9c5468331978e9abbcc23223522de6fd9c622211dd73a9d0a61bd8f2d3cc5f9ecb94eaea89fad4b1858f487ba3ed2633901e6227e2cb2fb84b73d06901503e68d61b591c9496102949e5391de2fc497503caaa0564f1a43d43b98d69dd61cd5cdff2e723f62e1d24d9345d431c09a540b54de6bb2b7e4722970110a445758e20a147985e0e13e12effc527e6a2c4958b91198d99e4d5079a50ef8a825b35e51bc2c286f07ae3c71520aba53ee647e7e3f5914e0da24e596b9ec1b23d2a65f85ceb30769d3f943d4211621c3496d1ede0638fd09b19bc65dd715986f493205192565dbd106ee2a183dadfc826c4ea8ab9656a2ff5218d5a544a3d66898f15f7facfef23018db008f90f490ce67294b00b5dc386c75943494e45b2de1edd6ef4bc0d9063717b63f50dfc1a730e3df4ece0e33f6df3ab9b2750e3de10cf04d4335bfb88c282af8d5f277a3a418662d70ff8a9f861a892af1c829488295333a73e881c280c059d5835c0e61d05c2bc3b139901326f1ed64433633ea1b1274f8ca5f6baf1b76ca0f08c48c8fe2cd30d62d7d599e072d7c14c54e420d65e8004e3d00008a71fed3aee180e3997ed947d70638ac2c4ea585fe2692e5edd44158cb8795ac387d45d5eb7a3ac61deb3aaf65e8c737fcff22c259ed08f1d66434f9905635cb4af5551dfe1496b47ac8f09f01a23604bd321ebc2943cdee9c26ccb6a8951fda34271caa7de8adf1a7ee964ccb1dc482b6122e82d2a6ba077322926b067ff07c8fd2ca4eb09288a2b8e1a5073b6c1a9bbf578a0da5ce5abbae87e666216f3aec79c08fdea3f6f06eb3637209689d922275ec318cfca5787aa89401b38c1f1474605ba8da31638753ccb12f41d2a7f07ff50d1d0c21fd92126f4492e470ef6d900648ee5ee3addb0a084f2d53f2a8eb0b6c33669ee0132414531595bdb528d28169375f2bdecad6f11ee96537050268fc6badea49f5a8a7d52048917b40b5a0240fe3f077d0806092da986f46be75bcbd8156dd6803ca04a28aef7c9961dd88ae2e62682f5553c7d1c9911b2786185d080f690495d364bdf57759f6da71470b10ad7bbf14e16d22af63d962d236be3ef2dec8bc948b8c5591e4d69e42632b355ffae52e7539a745e1820b986b450f40f4fe36592058dc7ea2860e2742a5431e1fdf91cfcb169c137b04e66341c1411ff205f45f6d57b17a7e393d9f9e744b7803bfd737a63982bf2fc43148f7684b2836928e6771da52c81857f53e77a457eda53230a7e3672af087ecde73d0fdfbe1cf5bc8752245ed795039831a0a2d419b21f4432ea8cedde6c804a1f9de16b65d509ba4e882e1564d33e944b0db16d80964ec90019b9ba11613a985dc97702df62c6ae895138fd908840f1e7f868e8224f80e6e508fb60ac5664d9f4129d39bd9040b25ca8b17169cc3e14e3bdad079666bcb6b1afefa90ebe30217c267c06f6b31e82cc0dd401ba2d6206b9add7e32d5f8da09e7328a4b551f31f0e201e3debbcd72fdcd47c2679b0467d85877b144bcd85461ff48bcc8b6048c66f96a107b1604c93b01545441d709bd6f056cfb606de0aadb45b0dc75d7aefbbb277ab955c564545497c89a9e7a69de53c62e82d7f7015c9109dd16c4883ed1ebe986535b528678e835e7cb72b3f2b8a7c59475c198915b97e4008998fbe46946369b775b504ea34c362bcfaa7aa39ab9b7354abadda6918ad38dcdebb2fd2db80f4158d4fa36adeaabb6306945c3a2b88f6eef999a064f5b1b84efa1ecc7183debf077fbca4cc9da135d281e5b53879baf6a9dde0fd794d5880057e716f4786eb90c50aeb1ca5b9c6677631a51c7672192b893ebb04e12ed5a653c9422ac2df726cbf866181bee75afdea1f91e88d85b8d6cb78336d977e713bbd98b19be09a727349ed0485743165923420b2af48c2946015ad808a619cb427f54db0988a598e1094dda551ba8cc660a8582d33929c45ce5ee87151816e309117c5cbd78e1f7b52a95e8652e2b463ddee766e353abbea2ec32f789fb06edb3598c19150ed16c8855072ad49c9a2a6411b958062646d39f406574cfffc232043a4eef4045dc99f5336ae2795ce93e926d99c2f82c00a7e2ff11b297e458f248ef860d04288df20e7e1456b6bdda6231d8b9b8fc35825ee8c58502f546dfee1baf29f95987fea0d08107d1e3dd9316c3c811bcb40a05bbe7a92e46446dfd6af2107d3186506492e35d3e284ae3d8c0ac7d0e013c4b17b35387358417ee036973071b841d0f80d400abb62b0721237196c2725d7da20da3cc59e848d56cc486a7cde530a5b1be1a1cea0274b64951f9eb6ce7138d14cc2bda8e1a138646cad70b475e70e05c68dbaf50bca5cd82cf5b0084145e410c590bcdf884d3b28818d8e473e4e6973e12e630df94c7028f38f5d5e6830137c05dacdaf7e8d67b3fdc093d3b2b226c0cbc46290d7b97317556a123342c31ecba562b29e4bef1cc8d6a39dca858b41268a36d2dd9c6b21bcddced70b4b9227d292c230546d372eac28fe37e00c6a225c8ca8b4eca30aa94ee7f0fdbec35620f9d7f3ef470eeb3d9ce07b98524dd2df8b41f03a0825494b233d56aaee33d3087a8268d118955bf35fef9108f0b49747cb3c647148b726cb74e880da457defde063af44e481e36e1d555aa410cb7addd3af6853b98b62a798f40fb578c8b1c963fe1c2812bffc879e5b88c697b64bc05bfcfecdb3e8c7b0cf1b8e7eda30dcca6895f982b3c92adc05fd695d573d5d7fa794570d9828f2e9fea312d6951245be4bd3a0fd9ccd4009f94afb07b496f6ec0f03fcb6fe6333b10d137efcda1987f7f63c68b04cad55e975c0387f3690c21961b154bf38e9a974491f4aeac144ccc3a25c6f1cf3f83a4d837e8997a8e883fb8675b9955ccf61e71482677ab838fad95d8f47a8af091cd86384daf39b08b28b88560abaa18d5f0ad544749ef5aa42c394cca34e7d147b178c242282558b471360d89eb16cdf7cf1833c2d5c6a04541c820783ba0c909148b8c05394f4fe5ee5e41b17c9bafe9e39a24cd68aa743074da3db6bbebe8342b988800f2c025c5d4385f24f1b8f6eb11da6099509767a4ff6500b7abd5e4b151baebbc0a7b88c0a532d4284881952dd4a21d981d388a281b10d9130125633c06aee7214150785aff7ec6fae9fdf0f2459861df397ec422c7b3d56b37c7d78148cd457fbfbbb2e0e2c2a47e5598cc4a238b3bd612cd57057c48ed4c6d4e35501d104792e59773302434988a9477ac78f50220e1b1f18c40f2ccf3fac1e2d01b64431f6cafed8e25f29d83dcee14e072f607a7eb1df2b2699a42973792238bd4087b4d929c05e451c69e3827b5d4bae56bcf3baca89f1b6de69ff3ecf70e7d3e9e46e0f7dd0f86bfab86260a2a76babf2194c83e7da4fc5b3343e7d6f6f7e61b37614190438205c567a4fc22b8388908d2e43ed390047f0d1067afc7462064679c004c8a7363cbdb89599b6e548e705aec3be97d806e87519c376de0b5c18e4a0c9bc7562a25ca7023c33ab5b45efbafefee233c3f7bb5f4c6577099ee493b28a2f8480e6a2d0e586cabe2f112f78b8fe9ccd59013a05e6276d706892fec4291e10ce33707cfa0554760b2dc568ecab28aea606d42d6935f2082c9fe404ea4040770cdd0609551a25c947e208474e2164e0a1ea6a86c2109f58d6756e049af356ec45744a27cb6a516b74c3b13dcebf7b506090ebeecaa738bca98d81d23fc06e66d9f28100a6b612c7ce9567dc44e235c91e3351f8803f5a397fd5222fd0c779b6061600bbc06ba3c26e20bd183bad69003035f5ae67236eb5d90ee1457de64715b46e8beba108eb959056c6e14276d782c69cd1e45a3e619fcc893e5d651490aea3d6a7de0ccc0ed3e54490505035f49f3d100c0647daea8ab2a7c22ad021defec7e6a6763c3ba94ab7daf222a6f2fad947cdd333555a5d38464f61b035579b0d79e0f45d074a58045df9f2f77b652390016894393f12d12734eb401fba2c02e43f841e9625d8c8d7d3a921701ce0a16dfb6f5b3b8e1cee8daefea0f7f3ea602b935069456c82c883bf1cb0cf343914357aef9c321c56c085d84a42acbd652c1271518f43da103d782d3f1724ace3daddbd3323928e9521e2a2a6d97c28354665e6ae261ea76649f13be1ea477e099974072fb96f574884457d47b4e15646ef96e5e1961fa7fc0f6f55fd4dfd003a175ac81d34bc950c85dfb6426d9b06e6e99a2b90cadb116ac91045556d108a14ff87ded92cc14b2031d7d52509827bfdef9e9e50176ff0d318ca452997cd137f8cd4f12f8057f2dfa5cd62311aea6be8b69afa5c53f3191b362db394c54c9c60ebbfcced5209c467c49c2eaccb5e61da67bd1f44f233fc507f8edd47b5da75a521edd0a749f5f31a8cafc6b6930dc2db67ad75946f8eae8ccc0beafd2f8db2f24ee23def6dccb2c57acaa7a9a0341d609bdfda3d0b4611bbc0b3996fcc2c4bd03891c9f9e9e61f0ecc794dd5c871fc07683bd097ed31e207592e2d7e720a793be73bbaeaa06861f970925a4c44d35fefbc61030b75a006478a1404386b74d55e89435f8c8d8b1d9ae3058afd21735f1abd36bbb0126e5d85a4679a804a7b3b5bf11f844c4198061651053b8a61d298d615cb55fb415caac0f2ee9df5b1f5b315b4d42762179b51df81975ba7aec02ba72487d90a4e70bd9e76ccc6dfd6e4d0ae0ca37bcb62aea68b6c227e0476a217b13620ee1c96db7bb702e095e4f90430b65ffcbda14a0728e756f17fa89c809e7721d98a5cbec74aee84beaf0bea33dc472f8f42f45257b44b6b41db182a449daaf54af35ada7a7874a8292316082ef4b338fcc9cc9ede6477985389214b4649e98821b1c2042ac895b23d4ff9f7569a867b7ccb331491409f8d22908550a5627e3369b0b3b53abcba52fce4b12f850f13b461016776812baabe4d2052bedca1f03816d64efcaf95649f2b72c1dedfb37e83356c6cb49c70cab959d5cc1c5f801a5c77f3bf4604b795a2147c801fbce9c2de3f8aa3800c6d3148bfd5796ef9bb9991ace61feaa66f717fa0754b05e3827fb29d295fd4092b5d4d670ab7b60c1070b6077c1a0c5d31296cb5f457a7198f49fd68a3ec848de8b4742669efabdea0aef06d106b18c312b30f9132abaea81b8e60d85f48f1d70d4d1c1d7e3049349e16d88f4b113a0d4bf78ea7f719f6c9771aa7a6d761214b43628659384da10989623846641f85e84fcf13930aa09055389cb5c70181b60883f8d5d62f38a146ab84a606c4a9c33fc1e70f4b7a468e0db0fa16179f4e7abc19caaa8818562ede5d5b70c770ee5248ba6871300fd4a697a2c5f623522f6f8d5dffef226b7c8e228d8bd8f453804869d1263fdfc024c35157be644f447808ea64d95be22195c633f78ddd56e49e2121186c6af2e6fbeb7e1a0cee7998b95e9d90763d2152c92c69cb579068d0119bc3f650ba18020afcc4d96a5d8c995244e09fc28e1ea6b02085f91b5ab7079f9760bbe5a5fa409b73d3f4c6ba1cd883b6a5a5bc5405bac30103307df7f4a0682a3fc9bb717ba6ae2ce2979d75072366b1db91510b7f697aacfe8a102d996b1dbd0bd0f14dd8821172e87b9354744cb6add5f0ce49ac7a7d8d9cfe6323f8ab5c75ebbc7fb5e1b9d7cc966d8938dd76b33ceb0d0707a83f9abbe55763d4f2717e5ba5a574079f8a3a2ab03a2be0882fdbad81a8b78b40b89cc69edbbab6976d2369f731902753736ba1f2c7b2881e4d3e2611db28c6913407193b56b5bbcb37e47808bfe651d1294c5cda45810d87c0c866216c0257d88f018620f25070ff0342ea812fdbdea51329a555edbb684ed62427476e573cbf8dc00632589bee0a118e3cccbcf6055ae0c1340c4760f25dd9d7c3eeed538f0f36e3c06e860d9d3a43e29c82f6e8658e55a4150f59de1cfb8e156c97d41349e24b8d9e69dd569aa3cb002bb649a11e126a1ac861222c77987edd807eaafcb7344612546e2ec34a30a9e7487b92b4ad51268e94600509f39682c61c931f0f62170741680bc6ad5732439575530edd2a848fd82ca2dfe90b8215b7167d207919ef3b80e4a8dc3c6d761d914b582e0f17f835fe25401444e374a0df3e34335886139d8a6ea505dfb4f08f86fe376d10268fafebbb0fec4c523860d59b92ef25ac70aedf55eb8cef2ac5e67f124e6bcbe56b55d27bad78970129dae9e507fb1b38935d581bbb42ca92d693ec084faa2b6287fe27938ba1d3d2b8c5b3c4070b62c78ee7504b5f1c79f4a54eceb086ff9fbd5a602109c97801265fc33491f9dbccbd371938b671848c1969f6697b96ed21317bf83002285e77c25311b904d34dcb2e14e60b570f92ba8791eee7a29556adb13d676b5fd01ccdb07cfbad79809a8d4b3a216fe7b18e753ceeb1db8edd10c6d64ce43de8cbfe9499924967f7376be93b01563b8b7e0c91c48b86231ac86dfdf63be72f6f26e272c5c9ef5117fe8cc1bf7516c288935c10798599f33d9a409b49cb099e48ff2ee0b6f382e263a7b7f2c24aa9bf05228a9cd342bd1e1951522f9aee26b8253d208e496b5923cc7122da533ffdf1e22afceace6a4f8705aa808c34c5723e26e880a4bd4c2a17164b8aa35c532f47ac96f1118a823c459b381e2187d36f69f512e73c86a68b5bbdb4ee6e387822e27d2f1bf8992cd81608360ae9efc99f6846d0587945e7f36f223ace64a51a0b47f444358cc8b04d150d020ad8d0fca20970629d733122401a494f8d73b9728bbe69b4970f9f00db97c575bff60f970aefd5e76eec9bb5e4af93d42f0db37441a270977a6714034518318bb3d058ad7c5fab140cdabdee92acae03298e76c58c69b5fe8ab210fc4eebf2e2d4fbd854c9b23e5059834530231a4896a205ab365cec219f9086a76b10c2edf5e2d4eec99aa582a8ccb9f5fa00aec763e53743ddc2f9ee4efdf86fcea963f5d894e728d5a93369f1594e617b75347f8f133cec98b87dabeb6e0e70a1d9d812e264cb9da18657d7d01fb17ae2bd0332eae3482cb5a401f8a791d2e439e5f91d59da1aaa52c640cebc485bce86d78bd86ffd50d098def76bfdd69fb50f037cdedaf09a057597d0229f674da6fed85c8654a5b5b78b68b9e399f609361552208dec05a43a1ace277f7d43e642429a1c22766c95fbc9e147ed5e1d0ada1128157c3040c7bbc8ec697c6a87168572fe28e7079d868f26dd2c2612923bc3cf0be6f7fa415243e596e552a8d70b0a6f8cac418ae2723a8c0e9b20b21cb43d5f1bc91128e48d20220a3163dafd198cf53de4cf0d538d0b212b5d91d3c149c25f8c1c6da7727b64bdc6e4f7465160031cfe2e19927dee3c0043ec64205076ee6bcb27123a9621bff921f3c39e482e9ed7c12a0da97a4fb2f30810bfec96595bee5de4ea4c5e35c3a0f05a4b3966ca19a46dc19af9c0e9e7355cc8fa5017542b01a77a3a8c39fd95052a7abc574ae51b02044ee1d63cbdd516202c63841a7e1c1f76e30fb5496d0f7fb3575ed82bb21e3d773307933d9a5bd8c7e9da41f44a92acc7719a54ba45fc0fb0070de56efcf2eaa677afd83222926b151ac88f39bb446d83d849cd88a6ca03b3cc6c80ec93b4af86574601e0e236000847191de3eee3e5b10bb891fbb8418844d102e2a59b7ec44040fa6b148ef607ea5b9da7de704bd19c438a51905f06dd9e53965932c3e341285ba27ab2e3f1b5251d08272ca44a94d628870434184cf5a2dd385521ace72541b44fb0a7030915d1b586e1f04d5398546be1a8f582da51b6996d2d3c23ad004a7eee7f92d440bbb44b8acf8acd1f4c32deb245a806e36ff9ee30778e02da82bab48dd0528736a3d7e3bcdcac69ec63e5a2b280a0f046bae87b2d83a3567041fd52aae24140b6feb6330c2904fcd99c4bcf81d1769e4952d6e222258516c0bd58d4104eec37afb0b9208830c6863bf9ee27373f7572851eda09129f44fd4ea5a146b02520e22108456753a73b7ef26f35f30a2ef96267cb74b36110f078553e7df60f4dca23889058c47472e00ac17f300898ab028ce63d7229b39f5e6019b1d0d629a33ada7f12d78248a6b6919c462f77e3d67beb9538f44ac056a3a4ce6d83991f90bc89539a6d30eac09491c954dca9727da0749946e0759a9ea84e11e3974abc39deea50ab","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
