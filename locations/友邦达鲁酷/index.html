<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b65a396bfadecac31dd63abb3d49c73973df12bda340eef5132e5f4301254b01fb16e634a79f9879948fea4d80f765a635b3ddee7b9a061a2541630d2a7b9248e1e6cb9794825d65d6937cb57c88031ca169cb7bc5c0f9d456d5e904107764f4d9e6194dfa0db834a6c33b11431e91b00233086949bd70232e7683bebddb291192969d967da868157a6ddd85dc3f884072a3ae349b2015e0d97fb0053034626c6a0c27c152498db4a9608521d11a6ad59c69c136996798db392c0cf5515dc72e553b3c1a1f5cdddb33bab76bc27dc140634599aaadb84d9e166114bca074dece46c62db7fce0604a6578d85f9fc6e9dda787f2d10bcecdb6f56b21222ac1eefb934877ababfa93b3c0e57bfc9be43e1eb3bf5a848eac895433bfe2e5968628912227066d795086a806f9fecc9b882c537cea53e94969072dda9630447fbdde7adde120812e361336104d6744d39a119ae2b80efd211da105ad5d0389f296ea3a10ade029347d00699a45bd4d895ed86caa34a64aef6cf3696c99d8532b8c60be913babca47134b3de551c2edca03e000820ce160de123adc6abdb6baf329175f53e8f9bafd3002c91cf49cb222004cf07daa1c5da71166506e74ed66cc582944874b7725a42f67be6887aa0d318bc29355f5a13a908c7c29e4fced0f25c3c853ce0580f2d20fa19dfcbfa010965cf2506ecfa68f5948476c5e51e605d003a99010daf512cd02687ed040d7a58bccdc00b4f1f37a7924f776274de0da3bb141ce25310b1b7a9a9bb2a73c6fd20ffcae2e6414ade047d66990ff77c059c6dadcc240b38e6076b82731b28b9f61335e915ed0d4381a23ceb9283ee811a0fe72ef2ea94f34dc86fb929736936a5ab6e1fa144bb7f992baa5b86749fa10abc93d0258fcde5dc9eb6eec5f55d720fe1e634a682574cf16a619205eaaf653a09c0377841157c19663290fefd5ede8eae74dc1f284ac54e650e25120c6899628c1fa5cfdeeda0b8431887678897362fe99d3999a62453bde25b6cb66d97b53da91568a571cf9d2888df049890e375d31106e1ab68789fc25f0d8443992457ac5a67feb271368ef752782ae0b03004f47a6298dd31ad5dcf6088ffcbc4c7d8925e635357e765aab4955b8e40951f8bb8b75e55717b284dee4a0cec98fa52cc998f0d4563a77cddecd49664b8519e76f5c3c06448047561059c9af7fedadf43905a6694c3bcdd7b2288a840917c71270b2a90946954b2a19f85056c023b06ea59ed074683d2960fd24b9c289ca278e60d0ba6904ed051482160dbc1833220f88b117bf837d84cc12ca17c09a53ed6fa1bf950fddf4ec62fdac7aecbd7e1db26552440ad6b58adbe026bf80101e1088b319355cadecdaa3f9de6028ff5b90828a3a29fcf3ebf7ffebcc413728ab09b2e8d6226b210172456032f34e44f87af4c92de7218e9520c0e803ab77a10685fc2312a9e1e35c583a54cab9720d6398420a5c0e8b730c3366cc14c88612e5ccb36dd1b5dac0f1808719c2a7ad779ea014cb04ff620942eebaf740d51d3a3df1149e3078d9917a3bc5bd411058878bc93981944bf94dfb30533a816daed30925674d5b0db974f953ee6f1d058f2b6e314d3c91f89536beba3532a57206a5f4d8e06b76acde2246b189280e93ea5a83bb4633eb08b181ba2b7bb59a1dc413a9a1d3da4c103ed8dd1caa59622c7f75fe6072af2a12ee5da9f2f238f6fd7baba39bc667151332fdd45105fd0642d97e1dd8ef1c7d02422f833860e4bd6b25978a5b53d881953bd93905a55ce1bdae2c0f8e8a55ddbb888d4eb77575f6333c531ab12f0680035621d3a1c84dc4ad4eb574d78dea1c32c82e5e3456e919db88187b6d1ab37511f12bb186e4abd75a286a1d3139b3d9b9efdb35d75509d59e8740f7570e5b4fd92cccb19fde1c2013709142d86a02aa9fa1ad8ccebb3668bcdcb447c2d343c34b814d578f94e67b599d77a9f89a03cc2b6e2fe500e147ca1af7a87977e2beaec2de2da190cc2be34b7300c84c119ed19748d03ce1fe33e159404d93a160769c502948088532f9643b204a6a0b5382a3a0353029503cbda422781dc0a3980d3525139c47ef3f8b24403934c488addbc0b1ad917abd1fd4535b32c278e8214544d6e91083c1e607751bd8d18ce3da32e14145a6a8058a2da8502110938ac27125ca2a0755f68a12bcf6a6d85dee99af1be843847239b1ed017e0fef87bdd262fa96f322fbe79c3a613abb451de14db7334faaceb757ab6ef4bc9332f599689dfd5116e8b256e39bed76b1e76d048db7cdec36679edb9ab194337e6b7f7ebc058741220e070564ae94a24eeb037bc9a23cb6cd15efa41ec39a816678c7cfd61b267de32ca1bbb06d835a30d5572aa34e116a969310194d77d76a87a59ed60e797f8b192a0c334a3f5f582c31359ea73032560d6d514e4f9289b029e846401902adabca16e58c7c1b5cf756965764aa11bac8ad001ed4c5b468c72d41a16b849ff5ce45bcdff3df30887026c1adec43374abbb3df255676546cc9a40ac0285e21570d632a20ac3db4fea94c812f2201ef6bbfb49396765bcc1df2a7a0951b6b8c23c26de993b2fb9d05f1b25a9726c805cb4e02119919d2931a358e6bf4cdfb69f39dc1a68b0029080d488a3c288fa03892fe2d3c178888ca799fcf9e475582d5c3d28bd240e5a82d81bb2bf782f978dfb8e1065cde5cf724693be5570f92a1445f40c9d734b43ac1a1ccd9a0a4d09133912176da94f3a4be5a62171301620b5ccde8aa5477f56a41571f4676195b4830fdd2d69fbb5b7d6652bb432d9164399f7fe7198226e1842623bc59136d706b33e2bd975716e02001abaf631fa244574bd456ee35ab818ac440b190c2ddc044a0f5412da23c5570c986f0d2857ea04ca606b82af0ea6d256261ea05527be1530b9323763b2ebb7e4988fb01711a035197eca322179b8a269c810874efa029e61e0c60b5c9fc9a3d93ef0d536dab69f1ebea0dc613fd3b9e508895df304c0d693f9ab681bfaa8b9ef1f82d3be0470874aaa5c5697705a20af44e0ef426b404f6ffff2b6c3c8c6377141103ccff49c6584d35cf48f16e0716fa1be7ad469b3d8c07166f3e189d4c2c2d6ed6b2274db85069c386b19b1ac2e2602ae0d269d1d4cf86e54ce3cc83e8f60bcf0cb658936c3b844fcfbfa47e2df2198b18b6cd797372273c5cb3488b63bea63b8290ff943b448dfe0f684f8a80c9ed3cf6518259ee251f47b53b2cbb5378def126d7be15590289a715f04fd043b0157ced670afb6c2d70989acef04dfc215885bd9607e9352fba7a8a448d32957b62365cd4d1ded9c76060cc858a2c03e819404e958897f0bca166eab66d3c74b3178adc50486ca24d9875dac501204f3697120e5dfce92c83b503b0e8b17034154a0b0a34ba484cdf7548b43a3f3e8de081fd66bf123715a658cfe78a4f7267a5cb753c3d4a9fc12e523b6bf1dd36ffda434adcf976b655c80d1b132ff351ccae272cafa0886cdaf96d0740a7892ca15782170db48434b9f43cc1666633d2683f7ce4d94f111aa99e4359cac5b5c6d948ba032c6de8a4d8547350d117a79a4333e3cfe35f0a24c46eb5bb6b9adc89b0949e702c481a61f182f78aaf3a4171afec2f3c9dda46dfce758ab8e009e2ef52d6e026ebb08fd55efd862f24e6dd7178e46cded4e8ac1604ff536631f44370cf90b18c117341c1a19f7e66be3a488f339822ddd3654b2e18ae2388aaf6058ea80f8ec36d611abb826f197d928f133f3a827a8f08759ae88849527f51fb3e8e192d30c4d8ba9247bc541d4d2ea7ead0397f73a276d2381755c7cd212f7329c07d70bab98d7efa0f31425ad08917d0f9de33715a02f521f9035d020077701a46d08ace52a705c4b2cb3d0b54520743b65fa7f7860e8472f5e8853a700986f2ab4cd85ca3f49d571393998d70f323517a2f83f202493ee247b3f5034c43725cb0e58abb4ccdc00143d6b64aaafb8cebd33b563e1f7f1ded637ec06e2de415071191cb4e941728c3cf070b50ca6936170e77b28b52dc6533fe6bf86efdaa5e347b21bb596f0aa747e98c53d4eaa014fb5ad0cb4b0856f9bdd41488d91c469d58e1cc9141bb1b22bbad1d5a7e2950b3ca512e32de19c313462c2e442d92c82acedda94cdc49f17082a7a1e299ba33cd79a0d4ae0192b757fcb2d3e589b40d8113b82f5ca2f422bdee3c998af3d40105fcb0d5962475e63709f7fdcedbc4af3f106fd5dbf5ffa06856ad5711fe58db01a3ac28af7dd429b6cd98d373c1f37cfe01d1dd64fd41e4d79735e0323f45c0dd61b02748d1cef9fa3579abdee402cf04cbf0c40ef9c2ff01ffbe9b70dc5fa346befcc309f483ff4ea2645b0dcd42fb22da6cdca92baaa3a7d048bbb28e83466946b027e723b791dc94cc168e453bbba4078f8495b550df0876cdc4a9bb99f30b31767cec2bb1d3211ab6b0f0df292f8e27c2a23b1a02058a41eac1aba892cfc4eb2ab20c21ebc53f5a7dfdb6058895bc90d31dbde90253ebb1b1a58e17aca2fd64a9dcff439ac93eeb6f510cbf5fd94a74938b09b7f581cb4a0d07b016dda08dff7685948689d5f04fd3fc2c93462d3572110f64ee1450877fa5567f78a64cdab3d8302eca26ed95f13740b573084e306812e7be59273396034b57befe17e4dc506cfca41859dd7bced212b4b9c86d6044d1cff6989a8e6d6961062ff59552c522b8fb87ce4f7964635d891ae7349af74869957cffde18ace9b50ae67a665d8528d0b7033329b82aec6857b9fa4dc075403bebd7db8c5bb1e35a38b7e3cc53595be8c184a8a4457a6dffc798309125bce6e9fe712a2e4cdf1f39e71ccb33f30073ebf3ea23516c43c3e981dc28738abdb925399e73f98376f01e4a93ff0a6cb0f7f71cb3b0f7ed021a77bfe15ae983011d19f62c366c6b8e23211507bde0a3caca7ba7d496285938bf2ca167d63ee0f882febd35a9d7770ae0ee14cefdb59a187d3f41748b84046afa1de3efe6fbc9a392f07f62019311d77c1ac847ffc53d79307ccf85be7c9c1ad81f92a9cd5076c58ecc325ec7447eed2b241d54979a9228881233e4dec006e43ba7dd2534f66f06822bbd508a78f3cb7cf1e83af1a666aea3825dd13a59d14a0508565bb3594689c25b6c84489e7f4ca43a3da4de0359cb35c55cfeef858cba08f634bcf89899900f79ebcbb9527fcb7c936b131f43496843424feb88505334ddb5f1cca31e43a3fc8001fa2a6ed4d77a59a29d03e10a3683b43131fcdb1d262868fc7c5d5ca119077c252e053172e58a8020eb8504410044e784c1c2a4e987415a3444b4a49a63ee7bf476008cfe5fc4f860147cd103f0987a2c6d7bdf7058ea9eea53e69d6bda0eec22fa4201a658c92477b8f214b543ed622723dd7df2956385ff803a45b23ac96b98721c2ac4f9a7ad4727540ee6bd317ec256c792d69151d9bcc3a3f3159e9b84947dc56fcf43535f74849c565fcd1b08e27add8c79b1e6a44f8f6980658da86e9f843db28739be1b31cc5ed0393a02ef048f7651a13ef1439be6770a0110e5ef480048e7e3703f3dd3235f6857fa879848c68151ccd44fce2fd64e7a80e63181b6923413df2ecf834e345f00654b322945c5ca178929dc41002177a2d7936041deab4f9aed16003cb11d6fc503a084fd1ea67cac0eefda8c7755986f1a70c6e495c7a425baf445c8cda335b93ea815f1b072c8128a0c70e8eb98527c5f325a9f591f27db8d865d6cc9a1b57e3537f823bb138cb01ddbc035b33ef238d34aad2ca13a2771f63238cfe5e71c2374544c753b16a36e081c03a9bd76b8ebd8d269602230a3c6e2ba44e5e2dd6a22ca337d6132031c1edba1ef2cc6df776568454d76dc15e2767a425c692134a53a00c2c56ba11e27cc041fdeeee7dd0b43317100203bceeb897fa9aafe4bc8f368794f33610b7398e558bb427303ba4a9c39776a994a43d0634f1a0474217a2d5a3c81b982ccc8410cf3bb63e769a40b6e1dcf3b47124ea28194121ddea5109d929de56c72b0db15e1c3e84855b974b4398a1b0eeb50592f983284c90f6d4201309f41b47539c9c436ec8dee7a82543e3777d40d55e56d39e826c13610b2dfe92f42b3d6688e2c2ef9d4af5a76d917017b154df1bd4ddfd72dd12d3fa2d5badace94a3bef904dbbff7da8f84a2b63bed294502fe1b4a0dc90a67c848db8414600f30874497dd7f5f05b72bd7c12c4ab8321d1e9968650ff6c2d4f0831ad5af79bfa249ba9b60380f74f2170634900f511f42c61ba8caed069586be8d119d5434c2a12a269e668d5667bc9c861e0c0f5c819d569bd7141df79331e845da3d46508b7c6095dd81986dc32422a6395d754a1c2ad98435a4e95da4366a42fd3988933204ebfc82cbb63a175bfecb499d405472bec57b0d519ef47f22180f7d33014723008b6f7adb05f388597008c8281088b03b19e71ba03d6770aa38f8e5dbc4ff4ea8fa360955a8bf4b681b07173b0564d0e0a495625a6b6a878f40eaeaf453c6147d3314e6470b544d785ccfc4615a4bacb5ee7f2de34b386c38fcb4dc8067a64cb1a9528c8ecffba4193653446e0bb50dddf1ac21902d707c36f680fb730c088311b74ca3d8e5831a40752577c09c98144ea97eb8efbb678fe24c74803ccc5832816360175cc7e20a100e9a6b86e1a82d7a764b419b9931e2a65fe3d9628906c86120f8ff98271e11cc46dd9a53833c4ddc7debf2a41eddb24c03ee8652ba0561045c00a41c4601cfd79d20d674a8fc9385432203c53e485fe04e2fcc079a06e5299d09cd85b7bdc6abea4b9abc2f684d80eeb995b63e4ebdfba72baf9e82835ecbf5833f73b51f60f1ac228fe00b4799fcb0833b8d0cb515d4f24f4b7f846c454163ddb83f871302408db21cd398c2118379ef975507b231e5b9748bb358772a85dad8d601ef999a6e4df5f7763af71abfb0605a3b1950afe833e12d11c68c0783b4c6e348b60da20e91214df1aa25472dbb50e38d473ee9a53099a963184958361ec55ba40e7aa6d76c5a62b9e077474e41a350c4b294392cb7150b1e45bf7c9b1ee43d4a6b1353d2dd09e3c6442aa7cb16985344f020613f22a2114f7f3be3a057828afa06f94b4e82654de1353b5cf8d06514ea77797070c35291c70e4598942105a66f52a2a536fc28cdaf2ae0bc3870af93a4cf413e4fbb650d7a8f28ab5465d249c4ec511d208d50fdcd567a9c3c69d56b310362f99f611d169c3480332a1a79558ac79a142a7fcda4f7a33418a9a54388ea24fc044a9f90167281162e014f901fbfa5362adcdd37eea99ec2febb82d4935090cf8140d2717602748d1facfe8fe75702118ce76160ff6d3fd9c243987a89cd655c28b83c2b92c07ee9dc5bfa05b78c85188315bfe6c7f71c581c6ca53d10818aafb9ed950b239a1a6592190d7ef8db30e33b46344f9f63e82b58db338a31e5b0a70746cb46883bff157f97d67ce3e43f0da01505938230322ef391a65a7ecdf4ca558fb409726b826cc87f6dfcaf4e8c3c2d36ebadc271536e15c229f82dd40293e4ac043912d8441479df897a6a6a4f0f18ef568dac4410ef2f3a5dfc6d2d103a224a2bbfc34d21dd74ae3161a4ad4f90a574b3795c70e8b1fc9b3d1ced6bf0f82ef0720d8d2bfe1c272b522fa1b03eac59fba53c785b8a74fe47e7fd9d317ba25ac6e8b173181b29463522189f20b9915f44b16f0bcd54135922b24c868ca8bfb62ef1a5fd9dc2fc439b3b230f3067c49c37571aedea450d644dc1f6a311e48264baaf535b443b7b22ec23cfc1e988032b609e97a6203d30efeef65347e7b65d0a4a77b1867fe127a20b527323a92676799e337184b56ee578637b6c397454e0daf84f430400c22a887dae2dc9669f1bc544af168d3e53a47daea665e0ab069461ba9bdbe66f2adb8942c162c393dc96c5bed0ceee983cd780e8e1fe46f91b7ef22084ba37508c7737f5e4ca7ae443ddd42bdf08f946c71d03e2f8bf6b6b8121d49bd064c1a98ed24b2413eb7824004f02bf3e71b6887f13a6e3d94dc2c20594ca1ca9c3c3d04fd69815dabde9b194ece7d8983193fe6d1cbcb2791e81d055d833846811bb74c908b84a274ac08838e31a6583d635a396b7d0039725696883e4c5e4ba053b05f8a4e8ef5f22b06e2cb6e57c108bb2a8eeacea204022337a360396421f28b501fab8a238d901f6443c201c7e20240e9760192360a7fac03debb980a1c860ceec3a57afad4c965212003d1cc8577743a69ba3c1286874b022908916f70cc5a55d6577bd9442cc94ced9728e8cc1589fe9c828fa2aa6c93e3acb6cca17720cedd82bbd60ba7c63fcfa74d176ce4240c28d6d5b97e889f6bda18c3c181f7a12e4cd047d8a6c760c0e4486a502fcb2630c668ebdf53cd1c7b1778911bfc946b0a9f44bf78a3c91c9eee869e8939ffd807e04e2099f560a2532ec1ffcb2b61d2a766b9480dda034506fa5b9fd3163cd2ae8691ecb2298ccfdb8fd625fafcbb150b05321779f54fbe74d9f51d16451e87a77adc4af2c6123e3378df5e84613336c7d1e913f60936b29440ab4436471c724dab557e75826ad9103e01c106172683d7acc58ec1315378bbc0bc07a2e4c05dc305267ff05538f5cf726a761b9055c98595bf7f08ed86f3ffcb20678f43fea1db4002b687e45c840a87ed2c8cc5d83b8c3856d599b87d323aca9f8fc9f969e80f8af27ffbc0384955c2f6e32f1ef6ac737d67f5e5b6034b2e7ba9995a0d9d413b086e97e177a04659e69d029afa8b473090668aded6f3391bbbd6d0263336ff5ffd8bfdfbf288121a90569b1ef288b927c29cf80fb5c20fe62fc51eab0767ee175acc0ae216d9c66fd713f2dfb449381acf8c1768ffdf40ed928b20064634e6360092a8d66bd73792d9283a3235882e8be3f081f2d1a98b6632a944273fc47ff952f7f9100e945e33f5d9635180ba8a3ae4b2fd540cd31414c16fcde7ca71c1ee91f3dbaecdfa58ec23ac442e90cdf7a23c420894eaf5c53ad011a85ee9557a3bbb1a1c226756468c7a87dc6d70ddf0683581f637526122827549d15d4b599368c698cc076f83302c82b1455bb2a5233f835416c861bd87bda61b4a17e5d3205554255ee4b1cc934fecf51011810b654263cbaae65b2d528061c1715945408f1f5fc8f5e44ec3df704b1bf769be171a3387c75cdafc09b4a4ec4a4beb0185d15a169c79c9776c88650f4e8c0c28aaad48a687a4e524ab1f1c6415f1bb6551dd6e3d4dcc4ad3a97032a9a5ac0b3de17d72da86e789e01bf5712a93b1fd798016aa0b4333858fde6ee3cc1e3761e44c0be4bf481cca4e6c7b4de8e77128c620fc453087cd1aa30ccc64b86ccc100ebc20c6c8202cf198f3b55d4e414d6b37c67ba1d790f1252db957f1f8fa1f37e853e569650d27f710d4f4965210107a19c8cbe1b4356121d4b2a5322a449b5ed7ec9d96913a93ff2bb686d447484da8ec46749b14006b16b43d6de0bb7f7e2828d71cbe76f282673521ca1a52ebec71025a465fec01d56e623b521a63a9cbbeaac2b76cd26ef26a06c2e05a10bd95f17bfa63796dc5acc899d0b2261d92339362ec315eea7aeea992e4a3cf37b0aed4092fd6ceec62d1b318e59a555bec00e93260127a0e699fd3d2de2ca6d1f4f3495c711995c09b8cc633a987616a04aeb29e23d3cdd81d7570d332340fc5ffa278b22a9d9794e619845100c7e44b8424dc838b5dfb9fa569cd042cf15e7b104b6326b3a859d32b0ba9f774824413c168af106bb62384c5c4f85c52ed1af38b91c501ffb1376d6704be4a91b8fbda75daa39b685908d7ec891c75b7ff28b039aff9390283eab3ce0b667a8d41c8d984594c2395fa68019282b56e3eb582eb8ef9704882d8b4513a61cdd4d92ae90230bc26b9a8c01b561606107a6021688615940d43eb3ae94656885a7aaae1ca0dafc6de37b621ebcfa0d2884347d1cba06c21017e336d1fa1f2931a2918d00b6a4c8f9edb1c0d06f11be207ffa939a32602836b730394c1883a66c1e302347dc87ca35502412bcc2820ad3d94232a9535875da87fc07e980f3a9f683061878c90c07d612cdd6d896f8f032e4055119ac0212e82607fbaebe4d6f67e7179344c43cb7713a51442ac3845c72ce11a4b2ecb0a2101e30053f60b98690dd1530f730bb16f7f0d45115a85d6a4d7a9a4f2593c25ceac081c5d685171ef61b4becec8f17335b9ede630d2f74d37348b6584b6776fe5b6911412ceb5d50ee6f2f6e3eb5fc87a9ffb0a62bf19a5a6c74601933db5bbc6369b85448bf34975bb8c94146d9bc242b14973227005afac25c4dabf374e2a37d3f30a86fd36297d787abd9d2e45aaaed68cf1060b7396c35b485085a93f0ee6119fb734657f97ece8dd112ab23151bf36f8ef9f721c7b17ba08f5b0c9c68bb0568279fbe5fa22c342eedec484a0b9c11ffc729b35ad8d04fddd21e77998d91e95de98e3ffc1d2c44f4ce9b5969695a1d6a32b002516350d75031abefacb79bfd617f00ab177c233d8fc3c465f7579822f614777c5c7b9169dae54df324487c8361f3875195c44e635beba42c7caf46640cb7c8ab2e513de01de02a1928","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
